'use strict';
/* global BaseInstrument */
/* global registerInstrument */
class InstrumentLogic extends BaseInstrument {
    constructor() {
        super();
        let lastTime = this._lastTime;
        this.getDeltaTime = () => {
            const nowTime = Date.now();
            const deltaTime = nowTime - lastTime;
            lastTime = nowTime;
            return deltaTime;
        };
    }

    get templateID() {
        return 'DCDU';
    }

    get isInteractive() {
        return true;
    }

    get IsGlassCockpit() {
        return true;
    }

    connectedCallback() {
        super.connectedCallback();
        (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "../node_modules/object-assign/index.js"(exports, module2) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // ../node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "../node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      var l = require_object_assign();
      var n = 60103;
      var p = 60106;
      exports.Fragment = 60107;
      exports.StrictMode = 60108;
      exports.Profiler = 60114;
      var q = 60109;
      var r = 60110;
      var t = 60112;
      exports.Suspense = 60113;
      var u = 60115;
      var v = 60116;
      if ("function" === typeof Symbol && Symbol.for) {
        w = Symbol.for;
        n = w("react.element");
        p = w("react.portal");
        exports.Fragment = w("react.fragment");
        exports.StrictMode = w("react.strict_mode");
        exports.Profiler = w("react.profiler");
        q = w("react.provider");
        r = w("react.context");
        t = w("react.forward_ref");
        exports.Suspense = w("react.suspense");
        u = w("react.memo");
        v = w("react.lazy");
      }
      var w;
      var x = "function" === typeof Symbol && Symbol.iterator;
      function y(a) {
        if (null === a || "object" !== typeof a)
          return null;
        a = x && a[x] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      function z(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
          b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var A = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var B = {};
      function C(a, b, c) {
        this.props = a;
        this.context = b;
        this.refs = B;
        this.updater = c || A;
      }
      C.prototype.isReactComponent = {};
      C.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a)
          throw Error(z(85));
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      C.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function D() {
      }
      D.prototype = C.prototype;
      function E(a, b, c) {
        this.props = a;
        this.context = b;
        this.refs = B;
        this.updater = c || A;
      }
      var F = E.prototype = new D();
      F.constructor = E;
      l(F, C.prototype);
      F.isPureReactComponent = true;
      var G = { current: null };
      var H = Object.prototype.hasOwnProperty;
      var I = { key: true, ref: true, __self: true, __source: true };
      function J(a, b, c) {
        var e, d = {}, k = null, h = null;
        if (null != b)
          for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
            H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
        var g = arguments.length - 2;
        if (1 === g)
          d.children = c;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++)
            f[m] = arguments[m + 2];
          d.children = f;
        }
        if (a && a.defaultProps)
          for (e in g = a.defaultProps, g)
            void 0 === d[e] && (d[e] = g[e]);
        return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G.current };
      }
      function K(a, b) {
        return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function L(a) {
        return "object" === typeof a && null !== a && a.$$typeof === n;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var M = /\/+/g;
      function N(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function O(a, b, c, e, d) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k)
          a = null;
        var h = false;
        if (null === a)
          h = true;
        else
          switch (k) {
            case "string":
            case "number":
              h = true;
              break;
            case "object":
              switch (a.$$typeof) {
                case n:
                case p:
                  h = true;
              }
          }
        if (h)
          return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function(a2) {
            return a2;
          })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
        h = 0;
        e = "" === e ? "." : e + ":";
        if (Array.isArray(a))
          for (var g = 0; g < a.length; g++) {
            k = a[g];
            var f = e + N(k, g);
            h += O(k, b, c, f, d);
          }
        else if (f = y(a), "function" === typeof f)
          for (a = f.call(a), g = 0; !(k = a.next()).done; )
            k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
        else if ("object" === k)
          throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
        return h;
      }
      function P(a, b, c) {
        if (null == a)
          return a;
        var e = [], d = 0;
        O(a, e, "", "", function(a2) {
          return b.call(c, a2, d++);
        });
        return e;
      }
      function Q(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          a._status = 0;
          a._result = b;
          b.then(function(b2) {
            0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
          }, function(b2) {
            0 === a._status && (a._status = 2, a._result = b2);
          });
        }
        if (1 === a._status)
          return a._result;
        throw a._result;
      }
      var R = { current: null };
      function S() {
        var a = R.current;
        if (null === a)
          throw Error(z(321));
        return a;
      }
      var T = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G, IsSomeRendererActing: { current: false }, assign: l };
      exports.Children = { map: P, forEach: function(a, b, c) {
        P(a, function() {
          b.apply(this, arguments);
        }, c);
      }, count: function(a) {
        var b = 0;
        P(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return P(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!L(a))
          throw Error(z(143));
        return a;
      } };
      exports.Component = C;
      exports.PureComponent = E;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;
      exports.cloneElement = function(a, b, c) {
        if (null === a || void 0 === a)
          throw Error(z(267, a));
        var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = G.current);
          void 0 !== b.key && (d = "" + b.key);
          if (a.type && a.type.defaultProps)
            var g = a.type.defaultProps;
          for (f in b)
            H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f)
          e.children = c;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++)
            g[m] = arguments[m + 2];
          e.children = g;
        }
        return {
          $$typeof: n,
          type: a.type,
          key: d,
          ref: k,
          props: e,
          _owner: h
        };
      };
      exports.createContext = function(a, b) {
        void 0 === b && (b = null);
        a = { $$typeof: r, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
        a.Provider = { $$typeof: q, _context: a };
        return a.Consumer = a;
      };
      exports.createElement = J;
      exports.createFactory = function(a) {
        var b = J.bind(null, a);
        b.type = a;
        return b;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a) {
        return { $$typeof: t, render: a };
      };
      exports.isValidElement = L;
      exports.lazy = function(a) {
        return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
      };
      exports.memo = function(a, b) {
        return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
      };
      exports.useCallback = function(a, b) {
        return S().useCallback(a, b);
      };
      exports.useContext = function(a, b) {
        return S().useContext(a, b);
      };
      exports.useDebugValue = function() {
      };
      exports.useEffect = function(a, b) {
        return S().useEffect(a, b);
      };
      exports.useImperativeHandle = function(a, b, c) {
        return S().useImperativeHandle(a, b, c);
      };
      exports.useLayoutEffect = function(a, b) {
        return S().useLayoutEffect(a, b);
      };
      exports.useMemo = function(a, b) {
        return S().useMemo(a, b);
      };
      exports.useReducer = function(a, b, c) {
        return S().useReducer(a, b, c);
      };
      exports.useRef = function(a) {
        return S().useRef(a);
      };
      exports.useState = function(a) {
        return S().useState(a);
      };
      exports.version = "17.0.2";
    }
  });

  // ../node_modules/react/index.js
  var require_react = __commonJS({
    "../node_modules/react/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_react_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // ../node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "../node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      var f;
      var g;
      var h;
      var k;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
        t = null, u = null, w = function() {
          if (null !== t)
            try {
              var a = exports.unstable_now();
              t(true, a);
              t = null;
            } catch (b) {
              throw setTimeout(w, 0), b;
            }
        };
        f = function(a) {
          null !== t ? setTimeout(f, 0, a) : (t = a, setTimeout(w, 0));
        };
        g = function(a, b) {
          u = setTimeout(a, b);
        };
        h = function() {
          clearTimeout(u);
        };
        exports.unstable_shouldYield = function() {
          return false;
        };
        k = exports.unstable_forceFrameRate = function() {
        };
      } else {
        x = window.setTimeout, y = window.clearTimeout;
        if ("undefined" !== typeof console) {
          z = window.cancelAnimationFrame;
          "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        A = false, B = null, C = -1, D = 5, E = 0;
        exports.unstable_shouldYield = function() {
          return exports.unstable_now() >= E;
        };
        k = function() {
        };
        exports.unstable_forceFrameRate = function(a) {
          0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1e3 / a) : 5;
        };
        F = new MessageChannel(), G = F.port2;
        F.port1.onmessage = function() {
          if (null !== B) {
            var a = exports.unstable_now();
            E = a + D;
            try {
              B(true, a) ? G.postMessage(null) : (A = false, B = null);
            } catch (b) {
              throw G.postMessage(null), b;
            }
          } else
            A = false;
        };
        f = function(a) {
          B = a;
          A || (A = true, G.postMessage(null));
        };
        g = function(a, b) {
          C = x(function() {
            a(exports.unstable_now());
          }, b);
        };
        h = function() {
          y(C);
          C = -1;
        };
      }
      var t;
      var u;
      var w;
      var x;
      var y;
      var z;
      var A;
      var B;
      var C;
      var D;
      var E;
      var F;
      var G;
      function H(a, b) {
        var c = a.length;
        a.push(b);
        a:
          for (; ; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (void 0 !== e && 0 < I(e, b))
              a[d] = b, a[c] = e, c = d;
            else
              break a;
          }
      }
      function J(a) {
        a = a[0];
        return void 0 === a ? null : a;
      }
      function K(a) {
        var b = a[0];
        if (void 0 !== b) {
          var c = a.pop();
          if (c !== b) {
            a[0] = c;
            a:
              for (var d = 0, e = a.length; d < e; ) {
                var m = 2 * (d + 1) - 1, n = a[m], v = m + 1, r = a[v];
                if (void 0 !== n && 0 > I(n, c))
                  void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);
                else if (void 0 !== r && 0 > I(r, c))
                  a[d] = r, a[v] = c, d = v;
                else
                  break a;
              }
          }
          return b;
        }
        return null;
      }
      function I(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      var L = [];
      var M = [];
      var N = 1;
      var O = null;
      var P = 3;
      var Q = false;
      var R = false;
      var S = false;
      function T(a) {
        for (var b = J(M); null !== b; ) {
          if (null === b.callback)
            K(M);
          else if (b.startTime <= a)
            K(M), b.sortIndex = b.expirationTime, H(L, b);
          else
            break;
          b = J(M);
        }
      }
      function U(a) {
        S = false;
        T(a);
        if (!R)
          if (null !== J(L))
            R = true, f(V);
          else {
            var b = J(M);
            null !== b && g(U, b.startTime - a);
          }
      }
      function V(a, b) {
        R = false;
        S && (S = false, h());
        Q = true;
        var c = P;
        try {
          T(b);
          for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
            var d = O.callback;
            if ("function" === typeof d) {
              O.callback = null;
              P = O.priorityLevel;
              var e = d(O.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? O.callback = e : O === J(L) && K(L);
              T(b);
            } else
              K(L);
            O = J(L);
          }
          if (null !== O)
            var m = true;
          else {
            var n = J(M);
            null !== n && g(U, n.startTime - b);
            m = false;
          }
          return m;
        } finally {
          O = null, P = c, Q = false;
        }
      }
      var W = k;
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        R || Q || (R = true, f(V));
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return P;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return J(L);
      };
      exports.unstable_next = function(a) {
        switch (P) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = P;
        }
        var c = P;
        P = b;
        try {
          return a();
        } finally {
          P = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = W;
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = P;
        P = a;
        try {
          return b();
        } finally {
          P = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: N++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = true, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = true, f(V)));
        return a;
      };
      exports.unstable_wrapCallback = function(a) {
        var b = P;
        return function() {
          var c = P;
          P = b;
          try {
            return a.apply(this, arguments);
          } finally {
            P = c;
          }
        };
      };
    }
  });

  // ../node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../node_modules/scheduler/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_scheduler_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // ../node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "../node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      var aa = require_react();
      var m = require_object_assign();
      var r = require_scheduler();
      function y(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
          b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      if (!aa)
        throw Error(y(227));
      var ba = /* @__PURE__ */ new Set();
      var ca = {};
      function da(a, b) {
        ea(a, b);
        ea(a + "Capture", b);
      }
      function ea(a, b) {
        ca[a] = b;
        for (a = 0; a < b.length; a++)
          ba.add(b[a]);
      }
      var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var ia = Object.prototype.hasOwnProperty;
      var ja = {};
      var ka = {};
      function la(a) {
        if (ia.call(ka, a))
          return true;
        if (ia.call(ja, a))
          return false;
        if (ha.test(a))
          return ka[a] = true;
        ja[a] = true;
        return false;
      }
      function ma(a, b, c, d) {
        if (null !== c && 0 === c.type)
          return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d)
              return false;
            if (null !== c)
              return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function na(a, b, c, d) {
        if (null === b || "undefined" === typeof b || ma(a, b, c, d))
          return true;
        if (d)
          return false;
        if (null !== c)
          switch (c.type) {
            case 3:
              return !b;
            case 4:
              return false === b;
            case 5:
              return isNaN(b);
            case 6:
              return isNaN(b) || 1 > b;
          }
        return false;
      }
      function B(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var D = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        D[a] = new B(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        D[b] = new B(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        D[a] = new B(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        D[a] = new B(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        D[a] = new B(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        D[a] = new B(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var oa = /[\-:]([a-z])/g;
      function pa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          oa,
          pa
        );
        D[b] = new B(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(oa, pa);
        D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(oa, pa);
        D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
      });
      D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function qa(a, b, c, d) {
        var e = D.hasOwnProperty(b) ? D[b] : null;
        var f = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
        f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
      }
      var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var sa = 60103;
      var ta = 60106;
      var ua = 60107;
      var wa = 60108;
      var xa = 60114;
      var ya = 60109;
      var za = 60110;
      var Aa = 60112;
      var Ba = 60113;
      var Ca = 60120;
      var Da = 60115;
      var Ea = 60116;
      var Fa = 60121;
      var Ga = 60128;
      var Ha = 60129;
      var Ia = 60130;
      var Ja = 60131;
      if ("function" === typeof Symbol && Symbol.for) {
        E = Symbol.for;
        sa = E("react.element");
        ta = E("react.portal");
        ua = E("react.fragment");
        wa = E("react.strict_mode");
        xa = E("react.profiler");
        ya = E("react.provider");
        za = E("react.context");
        Aa = E("react.forward_ref");
        Ba = E("react.suspense");
        Ca = E("react.suspense_list");
        Da = E("react.memo");
        Ea = E("react.lazy");
        Fa = E("react.block");
        E("react.scope");
        Ga = E("react.opaque.id");
        Ha = E("react.debug_trace_mode");
        Ia = E("react.offscreen");
        Ja = E("react.legacy_hidden");
      }
      var E;
      var Ka = "function" === typeof Symbol && Symbol.iterator;
      function La(a) {
        if (null === a || "object" !== typeof a)
          return null;
        a = Ka && a[Ka] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var Ma;
      function Na(a) {
        if (void 0 === Ma)
          try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            Ma = b && b[1] || "";
          }
        return "\n" + Ma + a;
      }
      var Oa = false;
      function Pa(a, b) {
        if (!a || Oa)
          return "";
        Oa = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b)
            if (b = function() {
              throw Error();
            }, Object.defineProperty(b.prototype, "props", { set: function() {
              throw Error();
            } }), "object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(b, []);
              } catch (k) {
                var d = k;
              }
              Reflect.construct(a, [], b);
            } else {
              try {
                b.call();
              } catch (k) {
                d = k;
              }
              a.call(b.prototype);
            }
          else {
            try {
              throw Error();
            } catch (k) {
              d = k;
            }
            a();
          }
        } catch (k) {
          if (k && d && "string" === typeof k.stack) {
            for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
              h--;
            for (; 1 <= g && 0 <= h; g--, h--)
              if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h) {
                  do
                    if (g--, h--, 0 > h || e[g] !== f[h])
                      return "\n" + e[g].replace(" at new ", " at ");
                  while (1 <= g && 0 <= h);
                }
                break;
              }
          }
        } finally {
          Oa = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
      }
      function Qa(a) {
        switch (a.tag) {
          case 5:
            return Na(a.type);
          case 16:
            return Na("Lazy");
          case 13:
            return Na("Suspense");
          case 19:
            return Na("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Pa(a.type, false), a;
          case 11:
            return a = Pa(a.type.render, false), a;
          case 22:
            return a = Pa(a.type._render, false), a;
          case 1:
            return a = Pa(a.type, true), a;
          default:
            return "";
        }
      }
      function Ra(a) {
        if (null == a)
          return null;
        if ("function" === typeof a)
          return a.displayName || a.name || null;
        if ("string" === typeof a)
          return a;
        switch (a) {
          case ua:
            return "Fragment";
          case ta:
            return "Portal";
          case xa:
            return "Profiler";
          case wa:
            return "StrictMode";
          case Ba:
            return "Suspense";
          case Ca:
            return "SuspenseList";
        }
        if ("object" === typeof a)
          switch (a.$$typeof) {
            case za:
              return (a.displayName || "Context") + ".Consumer";
            case ya:
              return (a._context.displayName || "Context") + ".Provider";
            case Aa:
              var b = a.render;
              b = b.displayName || b.name || "";
              return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
            case Da:
              return Ra(a.type);
            case Fa:
              return Ra(a._render);
            case Ea:
              b = a._payload;
              a = a._init;
              try {
                return Ra(a(b));
              } catch (c) {
              }
          }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "object":
          case "string":
          case "undefined":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a)
          return false;
        var b = a._valueTracker;
        if (!b)
          return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a)
          return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function $a(a, b) {
        b = b.checked;
        null != b && qa(a, "checked", b, false);
      }
      function ab(a, b) {
        $a(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c)
          if ("number" === d) {
            if (0 === c && "" === a.value || a.value != c)
              a.value = "" + c;
          } else
            a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function cb(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
            return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function bb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a)
          null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      function db(a) {
        var b = "";
        aa.Children.forEach(a, function(a2) {
          null != a2 && (b += a2);
        });
        return b;
      }
      function eb(a, b) {
        a = m({ children: void 0 }, b);
        if (b = db(b.children))
          a.children = b;
        return a;
      }
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++)
            b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++)
            e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML)
          throw Error(y(91));
        return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b)
              throw Error(y(92));
            if (Array.isArray(c)) {
              if (!(1 >= c.length))
                throw Error(y(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
      function lb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function mb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var nb;
      var ob = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if (a.namespaceURI !== kb.svg || "innerHTML" in a)
          a.innerHTML = b;
        else {
          nb = nb || document.createElement("div");
          nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = nb.firstChild; a.firstChild; )
            a.removeChild(a.firstChild);
          for (; b.firstChild; )
            a.appendChild(b.firstChild);
        }
      });
      function pb(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var qb = {
        animationIterationCount: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var rb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(qb).forEach(function(a) {
        rb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          qb[b] = qb[a];
        });
      });
      function sb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
      }
      function tb(a, b) {
        a = a.style;
        for (var c in b)
          if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--"), e = sb(c, b[c], d);
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : a[c] = e;
          }
      }
      var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function vb(a, b) {
        if (b) {
          if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
            throw Error(y(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children)
              throw Error(y(60));
            if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
              throw Error(y(61));
          }
          if (null != b.style && "object" !== typeof b.style)
            throw Error(y(62));
        }
      }
      function wb(a, b) {
        if (-1 === a.indexOf("-"))
          return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb)
            throw Error(y(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b)
            for (a = 0; a < b.length; a++)
              Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb(a, b, c, d, e) {
        return a(b, c, d, e);
      }
      function Ib() {
      }
      var Jb = Gb;
      var Kb = false;
      var Lb = false;
      function Mb() {
        if (null !== zb || null !== Ab)
          Ib(), Fb();
      }
      function Nb(a, b, c) {
        if (Lb)
          return a(b, c);
        Lb = true;
        try {
          return Jb(a, b, c);
        } finally {
          Lb = false, Mb();
        }
      }
      function Ob(a, b) {
        var c = a.stateNode;
        if (null === c)
          return null;
        var d = Db(c);
        if (null === d)
          return null;
        c = d[b];
        a:
          switch (b) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
              a = !d;
              break a;
            default:
              a = false;
          }
        if (a)
          return null;
        if (c && "function" !== typeof c)
          throw Error(y(231, b, typeof c));
        return c;
      }
      var Pb = false;
      if (fa)
        try {
          Qb = {};
          Object.defineProperty(Qb, "passive", { get: function() {
            Pb = true;
          } });
          window.addEventListener("test", Qb, Qb);
          window.removeEventListener("test", Qb, Qb);
        } catch (a) {
          Pb = false;
        }
      var Qb;
      function Rb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (n) {
          this.onError(n);
        }
      }
      var Sb = false;
      var Tb = null;
      var Ub = false;
      var Vb = null;
      var Wb = { onError: function(a) {
        Sb = true;
        Tb = a;
      } };
      function Xb(a, b, c, d, e, f, g, h, k) {
        Sb = false;
        Tb = null;
        Rb.apply(Wb, arguments);
      }
      function Yb(a, b, c, d, e, f, g, h, k) {
        Xb.apply(this, arguments);
        if (Sb) {
          if (Sb) {
            var l = Tb;
            Sb = false;
            Tb = null;
          } else
            throw Error(y(198));
          Ub || (Ub = true, Vb = l);
        }
      }
      function Zb(a) {
        var b = a, c = a;
        if (a.alternate)
          for (; b.return; )
            b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function $b(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b)
            return b.dehydrated;
        }
        return null;
      }
      function ac(a) {
        if (Zb(a) !== a)
          throw Error(y(188));
      }
      function bc(a) {
        var b = a.alternate;
        if (!b) {
          b = Zb(a);
          if (null === b)
            throw Error(y(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e)
            break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c)
                return ac(e), a;
              if (f === d)
                return ac(e), b;
              f = f.sibling;
            }
            throw Error(y(188));
          }
          if (c.return !== d.return)
            c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g)
                throw Error(y(189));
            }
          }
          if (c.alternate !== d)
            throw Error(y(190));
        }
        if (3 !== c.tag)
          throw Error(y(188));
        return c.stateNode.current === c ? a : b;
      }
      function cc(a) {
        a = bc(a);
        if (!a)
          return null;
        for (var b = a; ; ) {
          if (5 === b.tag || 6 === b.tag)
            return b;
          if (b.child)
            b.child.return = b, b = b.child;
          else {
            if (b === a)
              break;
            for (; !b.sibling; ) {
              if (!b.return || b.return === a)
                return null;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return null;
      }
      function dc(a, b) {
        for (var c = a.alternate; null !== b; ) {
          if (b === a || b === c)
            return true;
          b = b.return;
        }
        return false;
      }
      var ec;
      var fc;
      var gc;
      var hc;
      var ic = false;
      var jc = [];
      var kc = null;
      var lc = null;
      var mc = null;
      var nc = /* @__PURE__ */ new Map();
      var oc = /* @__PURE__ */ new Map();
      var pc = [];
      var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function rc(a, b, c, d, e) {
        return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
      }
      function sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            kc = null;
            break;
          case "dragenter":
          case "dragleave":
            lc = null;
            break;
          case "mouseover":
          case "mouseout":
            mc = null;
            break;
          case "pointerover":
          case "pointerout":
            nc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            oc.delete(b.pointerId);
        }
      }
      function tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f)
          return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return kc = tc(kc, a, b, c, d, e), true;
          case "dragenter":
            return lc = tc(lc, a, b, c, d, e), true;
          case "mouseover":
            return mc = tc(mc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function vc(a) {
        var b = wc(a.target);
        if (null !== b) {
          var c = Zb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = $b(c), null !== b) {
                a.blockedOn = b;
                hc(a.lanePriority, function() {
                  r.unstable_runWithPriority(a.priority, function() {
                    gc(c);
                  });
                });
                return;
              }
            } else if (3 === b && c.stateNode.hydrate) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function xc(a) {
        if (null !== a.blockedOn)
          return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null !== c)
            return b = Cb(c), null !== b && fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function zc(a, b, c) {
        xc(a) && c.delete(b);
      }
      function Ac() {
        for (ic = false; 0 < jc.length; ) {
          var a = jc[0];
          if (null !== a.blockedOn) {
            a = Cb(a.blockedOn);
            null !== a && ec(a);
            break;
          }
          for (var b = a.targetContainers; 0 < b.length; ) {
            var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
            if (null !== c) {
              a.blockedOn = c;
              break;
            }
            b.shift();
          }
          null === a.blockedOn && jc.shift();
        }
        null !== kc && xc(kc) && (kc = null);
        null !== lc && xc(lc) && (lc = null);
        null !== mc && xc(mc) && (mc = null);
        nc.forEach(zc);
        oc.forEach(zc);
      }
      function Bc(a, b) {
        a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
      }
      function Cc(a) {
        function b(b2) {
          return Bc(b2, a);
        }
        if (0 < jc.length) {
          Bc(jc[0], a);
          for (var c = 1; c < jc.length; c++) {
            var d = jc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== kc && Bc(kc, a);
        null !== lc && Bc(lc, a);
        null !== mc && Bc(mc, a);
        nc.forEach(b);
        oc.forEach(b);
        for (c = 0; c < pc.length; c++)
          d = pc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); )
          vc(c), null === c.blockedOn && pc.shift();
      }
      function Dc(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") };
      var Fc = {};
      var Gc = {};
      fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
      function Hc(a) {
        if (Fc[a])
          return Fc[a];
        if (!Ec[a])
          return a;
        var b = Ec[a], c;
        for (c in b)
          if (b.hasOwnProperty(c) && c in Gc)
            return Fc[a] = b[c];
        return a;
      }
      var Ic = Hc("animationend");
      var Jc = Hc("animationiteration");
      var Kc = Hc("animationstart");
      var Lc = Hc("transitionend");
      var Mc = /* @__PURE__ */ new Map();
      var Nc = /* @__PURE__ */ new Map();
      var Oc = [
        "abort",
        "abort",
        Ic,
        "animationEnd",
        Jc,
        "animationIteration",
        Kc,
        "animationStart",
        "canplay",
        "canPlay",
        "canplaythrough",
        "canPlayThrough",
        "durationchange",
        "durationChange",
        "emptied",
        "emptied",
        "encrypted",
        "encrypted",
        "ended",
        "ended",
        "error",
        "error",
        "gotpointercapture",
        "gotPointerCapture",
        "load",
        "load",
        "loadeddata",
        "loadedData",
        "loadedmetadata",
        "loadedMetadata",
        "loadstart",
        "loadStart",
        "lostpointercapture",
        "lostPointerCapture",
        "playing",
        "playing",
        "progress",
        "progress",
        "seeking",
        "seeking",
        "stalled",
        "stalled",
        "suspend",
        "suspend",
        "timeupdate",
        "timeUpdate",
        Lc,
        "transitionEnd",
        "waiting",
        "waiting"
      ];
      function Pc(a, b) {
        for (var c = 0; c < a.length; c += 2) {
          var d = a[c], e = a[c + 1];
          e = "on" + (e[0].toUpperCase() + e.slice(1));
          Nc.set(d, b);
          Mc.set(d, e);
          da(e, [d]);
        }
      }
      var Qc = r.unstable_now;
      Qc();
      var F = 8;
      function Rc(a) {
        if (0 !== (1 & a))
          return F = 15, 1;
        if (0 !== (2 & a))
          return F = 14, 2;
        if (0 !== (4 & a))
          return F = 13, 4;
        var b = 24 & a;
        if (0 !== b)
          return F = 12, b;
        if (0 !== (a & 32))
          return F = 11, 32;
        b = 192 & a;
        if (0 !== b)
          return F = 10, b;
        if (0 !== (a & 256))
          return F = 9, 256;
        b = 3584 & a;
        if (0 !== b)
          return F = 8, b;
        if (0 !== (a & 4096))
          return F = 7, 4096;
        b = 4186112 & a;
        if (0 !== b)
          return F = 6, b;
        b = 62914560 & a;
        if (0 !== b)
          return F = 5, b;
        if (a & 67108864)
          return F = 4, 67108864;
        if (0 !== (a & 134217728))
          return F = 3, 134217728;
        b = 805306368 & a;
        if (0 !== b)
          return F = 2, b;
        if (0 !== (1073741824 & a))
          return F = 1, 1073741824;
        F = 8;
        return a;
      }
      function Sc(a) {
        switch (a) {
          case 99:
            return 15;
          case 98:
            return 10;
          case 97:
          case 96:
            return 8;
          case 95:
            return 2;
          default:
            return 0;
        }
      }
      function Tc(a) {
        switch (a) {
          case 15:
          case 14:
            return 99;
          case 13:
          case 12:
          case 11:
          case 10:
            return 98;
          case 9:
          case 8:
          case 7:
          case 6:
          case 4:
          case 5:
            return 97;
          case 3:
          case 2:
          case 1:
            return 95;
          case 0:
            return 90;
          default:
            throw Error(y(358, a));
        }
      }
      function Uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c)
          return F = 0;
        var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
        if (0 !== f)
          d = f, e = F = 15;
        else if (f = c & 134217727, 0 !== f) {
          var k = f & ~g;
          0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
        } else
          f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);
        if (0 === d)
          return 0;
        d = 31 - Vc(d);
        d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
        if (0 !== b && b !== d && 0 === (b & g)) {
          Rc(b);
          if (e <= F)
            return b;
          F = e;
        }
        b = a.entangledLanes;
        if (0 !== b)
          for (a = a.entanglements, b &= d; 0 < b; )
            c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function Wc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function Xc(a, b) {
        switch (a) {
          case 15:
            return 1;
          case 14:
            return 2;
          case 12:
            return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;
          case 10:
            return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;
          case 8:
            return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;
          case 2:
            return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
        }
        throw Error(y(358, a));
      }
      function Yc(a) {
        return a & -a;
      }
      function Zc(a) {
        for (var b = [], c = 0; 31 > c; c++)
          b.push(a);
        return b;
      }
      function $c(a, b, c) {
        a.pendingLanes |= b;
        var d = b - 1;
        a.suspendedLanes &= d;
        a.pingedLanes &= d;
        a = a.eventTimes;
        b = 31 - Vc(b);
        a[b] = c;
      }
      var Vc = Math.clz32 ? Math.clz32 : ad;
      var bd = Math.log;
      var cd = Math.LN2;
      function ad(a) {
        return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
      }
      var dd = r.unstable_UserBlockingPriority;
      var ed = r.unstable_runWithPriority;
      var fd = true;
      function gd(a, b, c, d) {
        Kb || Ib();
        var e = hd, f = Kb;
        Kb = true;
        try {
          Hb(e, a, b, c, d);
        } finally {
          (Kb = f) || Mb();
        }
      }
      function id(a, b, c, d) {
        ed(dd, hd.bind(null, a, b, c, d));
      }
      function hd(a, b, c, d) {
        if (fd) {
          var e;
          if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a))
            a = rc(null, a, b, c, d), jc.push(a);
          else {
            var f = yc(a, b, c, d);
            if (null === f)
              e && sc(a, d);
            else {
              if (e) {
                if (-1 < qc.indexOf(a)) {
                  a = rc(f, a, b, c, d);
                  jc.push(a);
                  return;
                }
                if (uc(f, a, b, c, d))
                  return;
                sc(a, d);
              }
              jd(a, b, d, null, c);
            }
          }
        }
      }
      function yc(a, b, c, d) {
        var e = xb(d);
        e = wc(e);
        if (null !== e) {
          var f = Zb(e);
          if (null === f)
            e = null;
          else {
            var g = f.tag;
            if (13 === g) {
              e = $b(f);
              if (null !== e)
                return e;
              e = null;
            } else if (3 === g) {
              if (f.stateNode.hydrate)
                return 3 === f.tag ? f.stateNode.containerInfo : null;
              e = null;
            } else
              f !== e && (e = null);
          }
        }
        jd(a, b, d, e, c);
        return null;
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md)
          return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++)
          ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
          ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a)
            a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        m(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = m({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a)
          return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = m({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = m({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = m({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = m({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = m({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b)
            return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = m({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = fa && "CompositionEvent" in window;
      var be = null;
      fa && "documentMode" in document && (be = document.documentMode);
      var ce = fa && "TextEvent" in window && !be;
      var de = fa && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which)
              return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie)
          return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length)
                return b.char;
              if (b.which)
                return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b))
          return a;
      }
      function ve(a, b) {
        if ("change" === a)
          return b;
      }
      var we = false;
      if (fa) {
        if (fa) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else
          xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          a = re;
          if (Kb)
            a(b);
          else {
            Kb = true;
            try {
              Gb(a, b);
            } finally {
              Kb = false, Mb();
            }
          }
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a)
          return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a)
          return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a)
          return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      var Ie = Object.prototype.hasOwnProperty;
      function Je(a, b) {
        if (He(a, b))
          return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
          return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length)
          return false;
        for (d = 0; d < c.length; d++)
          if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
            return false;
        return true;
      }
      function Ke(a) {
        for (; a && a.firstChild; )
          a = a.firstChild;
        return a;
      }
      function Le(a, b) {
        var c = Ke(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b)
              return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Ke(c);
        }
      }
      function Me(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Ne() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c)
            a = b.contentWindow;
          else
            break;
          b = Xa(a.document);
        }
        return b;
      }
      function Oe(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      Pc(
        "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
        0
      );
      Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
      Pc(Oc, 2);
      for (Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
        Nc.set(Ve[We], 0);
      var Ve;
      var We;
      ea("onMouseEnter", ["mouseout", "mouseover"]);
      ea("onMouseLeave", ["mouseout", "mouseover"]);
      ea("onPointerEnter", ["pointerout", "pointerover"]);
      ea("onPointerLeave", ["pointerout", "pointerover"]);
      da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
      function Ze(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Yb(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b)
              for (var g = d.length - 1; 0 <= g; g--) {
                var h = d[g], k = h.instance, l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped())
                  break a;
                Ze(e, h, l);
                f = k;
              }
            else
              for (g = 0; g < d.length; g++) {
                h = d[g];
                k = h.instance;
                l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped())
                  break a;
                Ze(e, h, l);
                f = k;
              }
          }
        }
        if (Ub)
          throw a = Vb, Ub = false, Vb = null, a;
      }
      function G(a, b) {
        var c = $e(b), d = a + "__bubble";
        c.has(d) || (af(b, a, 2, false), c.add(d));
      }
      var bf = "_reactListening" + Math.random().toString(36).slice(2);
      function cf(a) {
        a[bf] || (a[bf] = true, ba.forEach(function(b) {
          Ye.has(b) || df(b, false, a, null);
          df(b, true, a, null);
        }));
      }
      function df(a, b, c, d) {
        var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f = c;
        "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);
        if (null !== d && !b && Ye.has(a)) {
          if ("scroll" !== a)
            return;
          e |= 2;
          f = d;
        }
        var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
        g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
      }
      function af(a, b, c, d) {
        var e = Nc.get(b);
        switch (void 0 === e ? 2 : e) {
          case 0:
            e = gd;
            break;
          case 1:
            e = id;
            break;
          default:
            e = hd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function jd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d)
          a:
            for (; ; ) {
              if (null === d)
                return;
              var g = d.tag;
              if (3 === g || 4 === g) {
                var h = d.stateNode.containerInfo;
                if (h === e || 8 === h.nodeType && h.parentNode === e)
                  break;
                if (4 === g)
                  for (g = d.return; null !== g; ) {
                    var k = g.tag;
                    if (3 === k || 4 === k) {
                      if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e)
                        return;
                    }
                    g = g.return;
                  }
                for (; null !== h; ) {
                  g = wc(h);
                  if (null === g)
                    return;
                  k = g.tag;
                  if (5 === k || 6 === k) {
                    d = f = g;
                    continue a;
                  }
                  h = h.parentNode;
                }
              }
              d = d.return;
            }
        Nb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = Mc.get(a);
            if (void 0 !== h2) {
              var k2 = td, x = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c))
                    break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  x = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  x = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button)
                    break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case Ic:
                case Jc:
                case Kc:
                  k2 = Hd;
                  break;
                case Lc:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var w = 0 !== (b & 4), z = !w && "scroll" === a, u = w ? null !== h2 ? h2 + "Capture" : null : h2;
              w = [];
              for (var t = d2, q; null !== t; ) {
                q = t;
                var v = q.stateNode;
                5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));
                if (z)
                  break;
                t = t.return;
              }
              0 < w.length && (h2 = new k2(h2, x, null, c, e2), g2.push({ event: h2, listeners: w }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff]))
                break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (x = c.relatedTarget || c.toElement, k2 = d2, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag))
                    x = null;
                } else
                  k2 = null, x = d2;
                if (k2 !== x) {
                  w = Bd;
                  v = "onMouseLeave";
                  u = "onMouseEnter";
                  t = "mouse";
                  if ("pointerout" === a || "pointerover" === a)
                    w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
                  z = null == k2 ? h2 : ue(k2);
                  q = null == x ? h2 : ue(x);
                  h2 = new w(v, t + "leave", k2, c, e2);
                  h2.target = z;
                  h2.relatedTarget = q;
                  v = null;
                  wc(e2) === d2 && (w = new w(u, t + "enter", x, c, e2), w.target = q, w.relatedTarget = z, v = w);
                  z = v;
                  if (k2 && x)
                    b: {
                      w = k2;
                      u = x;
                      t = 0;
                      for (q = w; q; q = gf(q))
                        t++;
                      q = 0;
                      for (v = u; v; v = gf(v))
                        q++;
                      for (; 0 < t - q; )
                        w = gf(w), t--;
                      for (; 0 < q - t; )
                        u = gf(u), q--;
                      for (; t--; ) {
                        if (w === u || null !== u && w === u.alternate)
                          break b;
                        w = gf(w);
                        u = gf(u);
                      }
                      w = null;
                    }
                  else
                    w = null;
                  null !== k2 && hf(g2, h2, k2, w, false);
                  null !== x && null !== z && hf(g2, z, x, w, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type)
                var J = ve;
              else if (me(h2))
                if (we)
                  J = Fe;
                else {
                  J = De;
                  var K = Ce;
                }
              else
                (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (J = Ee);
              if (J && (J = J(a, d2))) {
                ne(g2, J, c, e2);
                break a;
              }
              K && K(a, h2, d2);
              "focusout" === a && (K = h2._wrapperState) && K.controlled && "number" === h2.type && bb(h2, "number", h2.value);
            }
            K = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(K) || "true" === K.contentEditable)
                  Qe = K, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe)
                  break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var Q;
            if (ae)
              b: {
                switch (a) {
                  case "compositionstart":
                    var L = "onCompositionStart";
                    break b;
                  case "compositionend":
                    L = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    L = "onCompositionUpdate";
                    break b;
                }
                L = void 0;
              }
            else
              ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");
            L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K = oe(d2, L), 0 < K.length && (L = new Ld(L, a, null, c, e2), g2.push({ event: L, listeners: K }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));
            if (Q = ce ? je(a, c) : ke(a, c))
              d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld(
                "onBeforeInput",
                "beforeinput",
                null,
                c,
                e2
              ), g2.push({ event: e2, listeners: d2 }), e2.data = Q);
          }
          se(g2, b);
        });
      }
      function ef(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function gf(a) {
        if (null === a)
          return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function hf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d)
            break;
          5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      function jf() {
      }
      var kf = null;
      var lf = null;
      function mf(a, b) {
        switch (a) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!b.autoFocus;
        }
        return false;
      }
      function nf(a, b) {
        return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var of = "function" === typeof setTimeout ? setTimeout : void 0;
      var pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      function qf(a) {
        1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
      }
      function rf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b)
            break;
        }
        return a;
      }
      function sf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b)
                return a;
              b--;
            } else
              "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var tf = 0;
      function uf(a) {
        return { $$typeof: Ga, toString: a, valueOf: a };
      }
      var vf = Math.random().toString(36).slice(2);
      var wf = "__reactFiber$" + vf;
      var xf = "__reactProps$" + vf;
      var ff = "__reactContainer$" + vf;
      var yf = "__reactEvents$" + vf;
      function wc(a) {
        var b = a[wf];
        if (b)
          return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[ff] || c[wf]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child)
              for (a = sf(a); null !== a; ) {
                if (c = a[wf])
                  return c;
                a = sf(a);
              }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[wf] || a[ff];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag)
          return a.stateNode;
        throw Error(y(33));
      }
      function Db(a) {
        return a[xf] || null;
      }
      function $e(a) {
        var b = a[yf];
        void 0 === b && (b = a[yf] = /* @__PURE__ */ new Set());
        return b;
      }
      var zf = [];
      var Af = -1;
      function Bf(a) {
        return { current: a };
      }
      function H(a) {
        0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
      }
      function I(a, b) {
        Af++;
        zf[Af] = a.current;
        a.current = b;
      }
      var Cf = {};
      var M = Bf(Cf);
      var N = Bf(false);
      var Df = Cf;
      function Ef(a, b) {
        var c = a.type.contextTypes;
        if (!c)
          return Cf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
          return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c)
          e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Ff(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function Gf() {
        H(N);
        H(M);
      }
      function Hf(a, b, c) {
        if (M.current !== Cf)
          throw Error(y(168));
        I(M, b);
        I(N, c);
      }
      function If(a, b, c) {
        var d = a.stateNode;
        a = b.childContextTypes;
        if ("function" !== typeof d.getChildContext)
          return c;
        d = d.getChildContext();
        for (var e in d)
          if (!(e in a))
            throw Error(y(108, Ra(b) || "Unknown", e));
        return m({}, c, d);
      }
      function Jf(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
        Df = M.current;
        I(M, a);
        I(N, N.current);
        return true;
      }
      function Kf(a, b, c) {
        var d = a.stateNode;
        if (!d)
          throw Error(y(169));
        c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
        I(N, c);
      }
      var Lf = null;
      var Mf = null;
      var Nf = r.unstable_runWithPriority;
      var Of = r.unstable_scheduleCallback;
      var Pf = r.unstable_cancelCallback;
      var Qf = r.unstable_shouldYield;
      var Rf = r.unstable_requestPaint;
      var Sf = r.unstable_now;
      var Tf = r.unstable_getCurrentPriorityLevel;
      var Uf = r.unstable_ImmediatePriority;
      var Vf = r.unstable_UserBlockingPriority;
      var Wf = r.unstable_NormalPriority;
      var Xf = r.unstable_LowPriority;
      var Yf = r.unstable_IdlePriority;
      var Zf = {};
      var $f = void 0 !== Rf ? Rf : function() {
      };
      var ag = null;
      var bg = null;
      var cg = false;
      var dg = Sf();
      var O = 1e4 > dg ? Sf : function() {
        return Sf() - dg;
      };
      function eg() {
        switch (Tf()) {
          case Uf:
            return 99;
          case Vf:
            return 98;
          case Wf:
            return 97;
          case Xf:
            return 96;
          case Yf:
            return 95;
          default:
            throw Error(y(332));
        }
      }
      function fg(a) {
        switch (a) {
          case 99:
            return Uf;
          case 98:
            return Vf;
          case 97:
            return Wf;
          case 96:
            return Xf;
          case 95:
            return Yf;
          default:
            throw Error(y(332));
        }
      }
      function gg(a, b) {
        a = fg(a);
        return Nf(a, b);
      }
      function hg(a, b, c) {
        a = fg(a);
        return Of(a, b, c);
      }
      function ig() {
        if (null !== bg) {
          var a = bg;
          bg = null;
          Pf(a);
        }
        jg();
      }
      function jg() {
        if (!cg && null !== ag) {
          cg = true;
          var a = 0;
          try {
            var b = ag;
            gg(99, function() {
              for (; a < b.length; a++) {
                var c = b[a];
                do
                  c = c(true);
                while (null !== c);
              }
            });
            ag = null;
          } catch (c) {
            throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
          } finally {
            cg = false;
          }
        }
      }
      var kg = ra.ReactCurrentBatchConfig;
      function lg(a, b) {
        if (a && a.defaultProps) {
          b = m({}, b);
          a = a.defaultProps;
          for (var c in a)
            void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      var mg = Bf(null);
      var ng = null;
      var og = null;
      var pg = null;
      function qg() {
        pg = og = ng = null;
      }
      function rg(a) {
        var b = mg.current;
        H(mg);
        a.type._context._currentValue = b;
      }
      function sg(a, b) {
        for (; null !== a; ) {
          var c = a.alternate;
          if ((a.childLanes & b) === b)
            if (null === c || (c.childLanes & b) === b)
              break;
            else
              c.childLanes |= b;
          else
            a.childLanes |= b, null !== c && (c.childLanes |= b);
          a = a.return;
        }
      }
      function tg(a, b) {
        ng = a;
        pg = og = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = true), a.firstContext = null);
      }
      function vg(a, b) {
        if (pg !== a && false !== b && 0 !== b) {
          if ("number" !== typeof b || 1073741823 === b)
            pg = a, b = 1073741823;
          b = { context: a, observedBits: b, next: null };
          if (null === og) {
            if (null === ng)
              throw Error(y(308));
            og = b;
            ng.dependencies = { lanes: 0, firstContext: b, responders: null };
          } else
            og = og.next = b;
        }
        return a._currentValue;
      }
      var wg = false;
      function xg(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
      }
      function yg(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function zg(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function Ag(a, b) {
        a = a.updateQueue;
        if (null !== a) {
          a = a.shared;
          var c = a.pending;
          null === c ? b.next = b : (b.next = c.next, c.next = b);
          a.pending = b;
        }
      }
      function Bg(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else
            e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function Cg(a, b, c, d) {
        var e = a.updateQueue;
        wg = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var n = a.alternate;
          if (null !== n) {
            n = n.updateQueue;
            var A = n.lastBaseUpdate;
            A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
          }
        }
        if (null !== f) {
          A = e.baseState;
          g = 0;
          n = l = k = null;
          do {
            h = f.lane;
            var p = f.eventTime;
            if ((d & h) === h) {
              null !== n && (n = n.next = {
                eventTime: p,
                lane: 0,
                tag: f.tag,
                payload: f.payload,
                callback: f.callback,
                next: null
              });
              a: {
                var C = a, x = f;
                h = b;
                p = c;
                switch (x.tag) {
                  case 1:
                    C = x.payload;
                    if ("function" === typeof C) {
                      A = C.call(p, A, h);
                      break a;
                    }
                    A = C;
                    break a;
                  case 3:
                    C.flags = C.flags & -4097 | 64;
                  case 0:
                    C = x.payload;
                    h = "function" === typeof C ? C.call(p, A, h) : C;
                    if (null === h || void 0 === h)
                      break a;
                    A = m({}, A, h);
                    break a;
                  case 2:
                    wg = true;
                }
              }
              null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
            } else
              p = { eventTime: p, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;
            f = f.next;
            if (null === f)
              if (h = e.shared.pending, null === h)
                break;
              else
                f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
          } while (1);
          null === n && (k = A);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = n;
          Dg |= g;
          a.lanes = g;
          a.memoizedState = A;
        }
      }
      function Eg(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a)
          for (b = 0; b < a.length; b++) {
            var d = a[b], e = d.callback;
            if (null !== e) {
              d.callback = null;
              d = c;
              if ("function" !== typeof e)
                throw Error(y(191, e));
              e.call(d);
            }
          }
      }
      var Fg = new aa.Component().refs;
      function Gg(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : m({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Kg = { isMounted: function(a) {
        return (a = a._reactInternals) ? Zb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = Hg(), e = Ig(a), f = zg(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        Ag(a, f);
        Jg(a, e, d);
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = Hg(), e = Ig(a), f = zg(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        Ag(a, f);
        Jg(a, e, d);
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = Hg(), d = Ig(a), e = zg(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        Ag(a, e);
        Jg(a, d, c);
      } };
      function Lg(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
      }
      function Mg(a, b, c) {
        var d = false, e = Cf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Kg;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Ng(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
      }
      function Og(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = Fg;
        xg(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
        Cg(a, c, e, d);
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4);
      }
      var Pg = Array.isArray;
      function Qg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag)
                throw Error(y(309));
              var d = c.stateNode;
            }
            if (!d)
              throw Error(y(147, a));
            var e = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
              return b.ref;
            b = function(a2) {
              var b2 = d.refs;
              b2 === Fg && (b2 = d.refs = {});
              null === a2 ? delete b2[e] : b2[e] = a2;
            };
            b._stringRef = e;
            return b;
          }
          if ("string" !== typeof a)
            throw Error(y(284));
          if (!c._owner)
            throw Error(y(290, a));
        }
        return a;
      }
      function Rg(a, b) {
        if ("textarea" !== a.type)
          throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
      }
      function Sg(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.lastEffect;
            null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
            c2.nextEffect = null;
            c2.flags = 8;
          }
        }
        function c(c2, d2) {
          if (!a)
            return null;
          for (; null !== d2; )
            b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
            null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Tg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a)
            return c2;
          d2 = b2.alternate;
          if (null !== d2)
            return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
          b2.flags = 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags = 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag)
            return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          if (null !== b2 && b2.elementType === c2.type)
            return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
          d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Qg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
            return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function n(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag)
            return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function A(a2, b2, c2) {
          if ("string" === typeof b2 || "number" === typeof b2)
            return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case sa:
                return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
              case ta:
                return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
            }
            if (Pg(b2) || La(b2))
              return b2 = Xg(
                b2,
                a2.mode,
                c2,
                null
              ), b2.return = a2, b2;
            Rg(a2, b2);
          }
          return null;
        }
        function p(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 || "number" === typeof c2)
            return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case sa:
                return c2.key === e2 ? c2.type === ua ? n(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
              case ta:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            }
            if (Pg(c2) || La(c2))
              return null !== e2 ? null : n(a2, b2, c2, d2, null);
            Rg(a2, c2);
          }
          return null;
        }
        function C(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 || "number" === typeof d2)
            return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case sa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
              case ta:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            }
            if (Pg(d2) || La(d2))
              return a2 = a2.get(c2) || null, n(b2, a2, d2, e2, null);
            Rg(b2, d2);
          }
          return null;
        }
        function x(e2, g2, h2, k2) {
          for (var l2 = null, t = null, u = g2, z = g2 = 0, q = null; null !== u && z < h2.length; z++) {
            u.index > z ? (q = u, u = null) : q = u.sibling;
            var n2 = p(e2, u, h2[z], k2);
            if (null === n2) {
              null === u && (u = q);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, z);
            null === t ? l2 = n2 : t.sibling = n2;
            t = n2;
            u = q;
          }
          if (z === h2.length)
            return c(e2, u), l2;
          if (null === u) {
            for (; z < h2.length; z++)
              u = A(e2, h2[z], k2), null !== u && (g2 = f(u, g2, z), null === t ? l2 = u : t.sibling = u, t = u);
            return l2;
          }
          for (u = d(e2, u); z < h2.length; z++)
            q = C(u, e2, z, h2[z], k2), null !== q && (a && null !== q.alternate && u.delete(null === q.key ? z : q.key), g2 = f(q, g2, z), null === t ? l2 = q : t.sibling = q, t = q);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          return l2;
        }
        function w(e2, g2, h2, k2) {
          var l2 = La(h2);
          if ("function" !== typeof l2)
            throw Error(y(150));
          h2 = l2.call(h2);
          if (null == h2)
            throw Error(y(151));
          for (var t = l2 = null, u = g2, z = g2 = 0, q = null, n2 = h2.next(); null !== u && !n2.done; z++, n2 = h2.next()) {
            u.index > z ? (q = u, u = null) : q = u.sibling;
            var w2 = p(e2, u, n2.value, k2);
            if (null === w2) {
              null === u && (u = q);
              break;
            }
            a && u && null === w2.alternate && b(e2, u);
            g2 = f(w2, g2, z);
            null === t ? l2 = w2 : t.sibling = w2;
            t = w2;
            u = q;
          }
          if (n2.done)
            return c(e2, u), l2;
          if (null === u) {
            for (; !n2.done; z++, n2 = h2.next())
              n2 = A(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, z), null === t ? l2 = n2 : t.sibling = n2, t = n2);
            return l2;
          }
          for (u = d(e2, u); !n2.done; z++, n2 = h2.next())
            n2 = C(u, e2, z, n2.value, k2), null !== n2 && (a && null !== n2.alternate && u.delete(null === n2.key ? z : n2.key), g2 = f(n2, g2, z), null === t ? l2 = n2 : t.sibling = n2, t = n2);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          return l2;
        }
        return function(a2, d2, f2, h2) {
          var k2 = "object" === typeof f2 && null !== f2 && f2.type === ua && null === f2.key;
          k2 && (f2 = f2.props.children);
          var l2 = "object" === typeof f2 && null !== f2;
          if (l2)
            switch (f2.$$typeof) {
              case sa:
                a: {
                  l2 = f2.key;
                  for (k2 = d2; null !== k2; ) {
                    if (k2.key === l2) {
                      switch (k2.tag) {
                        case 7:
                          if (f2.type === ua) {
                            c(a2, k2.sibling);
                            d2 = e(k2, f2.props.children);
                            d2.return = a2;
                            a2 = d2;
                            break a;
                          }
                          break;
                        default:
                          if (k2.elementType === f2.type) {
                            c(a2, k2.sibling);
                            d2 = e(k2, f2.props);
                            d2.ref = Qg(a2, k2, f2);
                            d2.return = a2;
                            a2 = d2;
                            break a;
                          }
                      }
                      c(a2, k2);
                      break;
                    } else
                      b(a2, k2);
                    k2 = k2.sibling;
                  }
                  f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case ta:
                a: {
                  for (k2 = f2.key; null !== d2; ) {
                    if (d2.key === k2)
                      if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                        c(a2, d2.sibling);
                        d2 = e(d2, f2.children || []);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      } else {
                        c(a2, d2);
                        break;
                      }
                    else
                      b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Wg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
            }
          if ("string" === typeof f2 || "number" === typeof f2)
            return f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
          if (Pg(f2))
            return x(a2, d2, f2, h2);
          if (La(f2))
            return w(a2, d2, f2, h2);
          l2 && Rg(a2, f2);
          if ("undefined" === typeof f2 && !k2)
            switch (a2.tag) {
              case 1:
              case 22:
              case 0:
              case 11:
              case 15:
                throw Error(y(152, Ra(a2.type) || "Component"));
            }
          return c(a2, d2);
        };
      }
      var Yg = Sg(true);
      var Zg = Sg(false);
      var $g = {};
      var ah = Bf($g);
      var bh = Bf($g);
      var ch = Bf($g);
      function dh(a) {
        if (a === $g)
          throw Error(y(174));
        return a;
      }
      function eh(a, b) {
        I(ch, b);
        I(bh, a);
        I(ah, $g);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
        }
        H(ah);
        I(ah, b);
      }
      function fh() {
        H(ah);
        H(bh);
        H(ch);
      }
      function gh(a) {
        dh(ch.current);
        var b = dh(ah.current);
        var c = mb(b, a.type);
        b !== c && (I(bh, a), I(ah, c));
      }
      function hh(a) {
        bh.current === a && (H(ah), H(bh));
      }
      var P = Bf(0);
      function ih(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
              return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 64))
              return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a)
            break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var jh = null;
      var kh = null;
      var lh = false;
      function mh(a, b) {
        var c = nh(5, null, null, 0);
        c.elementType = "DELETED";
        c.type = "DELETED";
        c.stateNode = b;
        c.return = a;
        c.flags = 8;
        null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
      }
      function oh(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
          case 13:
            return false;
          default:
            return false;
        }
      }
      function ph(a) {
        if (lh) {
          var b = kh;
          if (b) {
            var c = b;
            if (!oh(a, b)) {
              b = rf(c.nextSibling);
              if (!b || !oh(a, b)) {
                a.flags = a.flags & -1025 | 2;
                lh = false;
                jh = a;
                return;
              }
              mh(jh, c);
            }
            jh = a;
            kh = rf(b.firstChild);
          } else
            a.flags = a.flags & -1025 | 2, lh = false, jh = a;
        }
      }
      function qh(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
          a = a.return;
        jh = a;
      }
      function rh(a) {
        if (a !== jh)
          return false;
        if (!lh)
          return qh(a), lh = true, false;
        var b = a.type;
        if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps))
          for (b = kh; b; )
            mh(a, b), b = rf(b.nextSibling);
        qh(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a)
            throw Error(y(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    kh = rf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else
                  "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            kh = null;
          }
        } else
          kh = jh ? rf(a.stateNode.nextSibling) : null;
        return true;
      }
      function sh() {
        kh = jh = null;
        lh = false;
      }
      var th = [];
      function uh() {
        for (var a = 0; a < th.length; a++)
          th[a]._workInProgressVersionPrimary = null;
        th.length = 0;
      }
      var vh = ra.ReactCurrentDispatcher;
      var wh = ra.ReactCurrentBatchConfig;
      var xh = 0;
      var R = null;
      var S = null;
      var T = null;
      var yh = false;
      var zh = false;
      function Ah() {
        throw Error(y(321));
      }
      function Bh(a, b) {
        if (null === b)
          return false;
        for (var c = 0; c < b.length && c < a.length; c++)
          if (!He(a[c], b[c]))
            return false;
        return true;
      }
      function Ch(a, b, c, d, e, f) {
        xh = f;
        R = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        vh.current = null === a || null === a.memoizedState ? Dh : Eh;
        a = c(d, e);
        if (zh) {
          f = 0;
          do {
            zh = false;
            if (!(25 > f))
              throw Error(y(301));
            f += 1;
            T = S = null;
            b.updateQueue = null;
            vh.current = Fh;
            a = c(d, e);
          } while (zh);
        }
        vh.current = Gh;
        b = null !== S && null !== S.next;
        xh = 0;
        T = S = R = null;
        yh = false;
        if (b)
          throw Error(y(300));
        return a;
      }
      function Hh() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === T ? R.memoizedState = T = a : T = T.next = a;
        return T;
      }
      function Ih() {
        if (null === S) {
          var a = R.alternate;
          a = null !== a ? a.memoizedState : null;
        } else
          a = S.next;
        var b = null === T ? R.memoizedState : T.next;
        if (null !== b)
          T = b, S = a;
        else {
          if (null === a)
            throw Error(y(310));
          S = a;
          a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
          null === T ? R.memoizedState = T = a : T = T.next = a;
        }
        return T;
      }
      function Jh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Kh(a) {
        var b = Ih(), c = b.queue;
        if (null === c)
          throw Error(y(311));
        c.lastRenderedReducer = a;
        var d = S, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          e = e.next;
          d = d.baseState;
          var h = g = f = null, k = e;
          do {
            var l = k.lane;
            if ((xh & l) === l)
              null !== h && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
            else {
              var n = {
                lane: l,
                action: k.action,
                eagerReducer: k.eagerReducer,
                eagerState: k.eagerState,
                next: null
              };
              null === h ? (g = h = n, f = d) : h = h.next = n;
              R.lanes |= l;
              Dg |= l;
            }
            k = k.next;
          } while (null !== k && k !== e);
          null === h ? f = d : h.next = g;
          He(d, b.memoizedState) || (ug = true);
          b.memoizedState = d;
          b.baseState = f;
          b.baseQueue = h;
          c.lastRenderedState = d;
        }
        return [b.memoizedState, c.dispatch];
      }
      function Lh(a) {
        var b = Ih(), c = b.queue;
        if (null === c)
          throw Error(y(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (ug = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Mh(a, b, c) {
        var d = b._getVersion;
        d = d(b._source);
        var e = b._workInProgressVersionPrimary;
        if (null !== e)
          a = e === d;
        else if (a = a.mutableReadLanes, a = (xh & a) === a)
          b._workInProgressVersionPrimary = d, th.push(b);
        if (a)
          return c(b._source);
        th.push(b);
        throw Error(y(350));
      }
      function Nh(a, b, c, d) {
        var e = U;
        if (null === e)
          throw Error(y(349));
        var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
          return Mh(e, b, c);
        }), l = k[1], n = k[0];
        k = T;
        var A = a.memoizedState, p = A.refs, C = p.getSnapshot, x = A.source;
        A = A.subscribe;
        var w = R;
        a.memoizedState = { refs: p, source: b, subscribe: d };
        h.useEffect(function() {
          p.getSnapshot = c;
          p.setSnapshot = l;
          var a2 = f(b._source);
          if (!He(g, a2)) {
            a2 = c(b._source);
            He(n, a2) || (l(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
            a2 = e.mutableReadLanes;
            e.entangledLanes |= a2;
            for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
              var k2 = 31 - Vc(h2), v = 1 << k2;
              d2[k2] |= a2;
              h2 &= ~v;
            }
          }
        }, [c, b, d]);
        h.useEffect(function() {
          return d(b._source, function() {
            var a2 = p.getSnapshot, c2 = p.setSnapshot;
            try {
              c2(a2(b._source));
              var d2 = Ig(w);
              e.mutableReadLanes |= d2 & e.pendingLanes;
            } catch (q) {
              c2(function() {
                throw q;
              });
            }
          });
        }, [b, d]);
        He(C, c) && He(x, b) && He(A, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n }, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
        return n;
      }
      function Ph(a, b, c) {
        var d = Ih();
        return Nh(d, a, b, c);
      }
      function Qh(a) {
        var b = Hh();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
        a = a.dispatch = Oh.bind(null, R, a);
        return [b.memoizedState, a];
      }
      function Rh(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = R.updateQueue;
        null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function Sh(a) {
        var b = Hh();
        a = { current: a };
        return b.memoizedState = a;
      }
      function Th() {
        return Ih().memoizedState;
      }
      function Uh(a, b, c, d) {
        var e = Hh();
        R.flags |= a;
        e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function Vh(a, b, c, d) {
        var e = Ih();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== S) {
          var g = S.memoizedState;
          f = g.destroy;
          if (null !== d && Bh(d, g.deps)) {
            Rh(b, c, f, d);
            return;
          }
        }
        R.flags |= a;
        e.memoizedState = Rh(1 | b, c, f, d);
      }
      function Wh(a, b) {
        return Uh(516, 4, a, b);
      }
      function Xh(a, b) {
        return Vh(516, 4, a, b);
      }
      function Yh(a, b) {
        return Vh(4, 2, a, b);
      }
      function Zh(a, b) {
        if ("function" === typeof b)
          return a = a(), b(a), function() {
            b(null);
          };
        if (null !== b && void 0 !== b)
          return a = a(), b.current = a, function() {
            b.current = null;
          };
      }
      function $h(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return Vh(4, 2, Zh.bind(null, b, a), c);
      }
      function ai() {
      }
      function bi(a, b) {
        var c = Ih();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Bh(b, d[1]))
          return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ci(a, b) {
        var c = Ih();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Bh(b, d[1]))
          return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function di(a, b) {
        var c = eg();
        gg(98 > c ? 98 : c, function() {
          a(true);
        });
        gg(97 < c ? 97 : c, function() {
          var c2 = wh.transition;
          wh.transition = 1;
          try {
            a(false), b();
          } finally {
            wh.transition = c2;
          }
        });
      }
      function Oh(a, b, c) {
        var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
        null === g ? f.next = f : (f.next = g.next, g.next = f);
        b.pending = f;
        g = a.alternate;
        if (a === R || null !== g && g === R)
          zh = yh = true;
        else {
          if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g))
            try {
              var h = b.lastRenderedState, k = g(h, c);
              f.eagerReducer = g;
              f.eagerState = k;
              if (He(k, h))
                return;
            } catch (l) {
            } finally {
            }
          Jg(a, e, d);
        }
      }
      var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false };
      var Dh = { readContext: vg, useCallback: function(a, b) {
        Hh().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return Uh(4, 2, Zh.bind(
          null,
          b,
          a
        ), c);
      }, useLayoutEffect: function(a, b) {
        return Uh(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Hh();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Hh();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        a = a.dispatch = Oh.bind(null, R, a);
        return [d.memoizedState, a];
      }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
        var b = Qh(a), c = b[0], d = b[1];
        Wh(function() {
          var b2 = wh.transition;
          wh.transition = 1;
          try {
            d(a);
          } finally {
            wh.transition = b2;
          }
        }, [a]);
        return c;
      }, useTransition: function() {
        var a = Qh(false), b = a[0];
        a = di.bind(null, a[1]);
        Sh(a);
        return [a, b];
      }, useMutableSource: function(a, b, c) {
        var d = Hh();
        d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
        return Nh(d, a, b, c);
      }, useOpaqueIdentifier: function() {
        if (lh) {
          var a = false, b = uf(function() {
            a || (a = true, c("r:" + (tf++).toString(36)));
            throw Error(y(355));
          }), c = Qh(b)[1];
          0 === (R.mode & 2) && (R.flags |= 516, Rh(
            5,
            function() {
              c("r:" + (tf++).toString(36));
            },
            void 0,
            null
          ));
          return b;
        }
        b = "r:" + (tf++).toString(36);
        Qh(b);
        return b;
      }, unstable_isNewReconciler: false };
      var Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
        return Kh(Jh);
      }, useDebugValue: ai, useDeferredValue: function(a) {
        var b = Kh(Jh), c = b[0], d = b[1];
        Xh(function() {
          var b2 = wh.transition;
          wh.transition = 1;
          try {
            d(a);
          } finally {
            wh.transition = b2;
          }
        }, [a]);
        return c;
      }, useTransition: function() {
        var a = Kh(Jh)[0];
        return [
          Th().current,
          a
        ];
      }, useMutableSource: Ph, useOpaqueIdentifier: function() {
        return Kh(Jh)[0];
      }, unstable_isNewReconciler: false };
      var Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
        return Lh(Jh);
      }, useDebugValue: ai, useDeferredValue: function(a) {
        var b = Lh(Jh), c = b[0], d = b[1];
        Xh(function() {
          var b2 = wh.transition;
          wh.transition = 1;
          try {
            d(a);
          } finally {
            wh.transition = b2;
          }
        }, [a]);
        return c;
      }, useTransition: function() {
        var a = Lh(Jh)[0];
        return [
          Th().current,
          a
        ];
      }, useMutableSource: Ph, useOpaqueIdentifier: function() {
        return Lh(Jh)[0];
      }, unstable_isNewReconciler: false };
      var ei = ra.ReactCurrentOwner;
      var ug = false;
      function fi(a, b, c, d) {
        b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
      }
      function gi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        tg(b, e);
        d = Ch(a, b, c, d, f, e);
        if (null !== a && !ug)
          return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
        b.flags |= 1;
        fi(a, b, d, e);
        return b.child;
      }
      function ii(a, b, c, d, e, f) {
        if (null === a) {
          var g = c.type;
          if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps)
            return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
          a = Vg(c.type, null, d, b, b.mode, f);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        g = a.child;
        if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref))
          return hi(a, b, f);
        b.flags |= 1;
        a = Tg(g, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function ki(a, b, c, d, e, f) {
        if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref)
          if (ug = false, 0 !== (f & e))
            0 !== (a.flags & 16384) && (ug = true);
          else
            return b.lanes = a.lanes, hi(a, b, f);
        return li(a, b, c, d, f);
      }
      function mi(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode)
          if (0 === (b.mode & 4))
            b.memoizedState = { baseLanes: 0 }, ni(b, c);
          else if (0 !== (c & 1073741824))
            b.memoizedState = { baseLanes: 0 }, ni(b, null !== f ? f.baseLanes : c);
          else
            return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
        else
          null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
        fi(a, b, e, c);
        return b.child;
      }
      function oi(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c)
          b.flags |= 128;
      }
      function li(a, b, c, d, e) {
        var f = Ff(c) ? Df : M.current;
        f = Ef(b, f);
        tg(b, e);
        c = Ch(a, b, c, d, f, e);
        if (null !== a && !ug)
          return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
        b.flags |= 1;
        fi(a, b, c, e);
        return b.child;
      }
      function pi(a, b, c, d, e) {
        if (Ff(c)) {
          var f = true;
          Jf(b);
        } else
          f = false;
        tg(b, e);
        if (null === b.stateNode)
          null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));
          var n = c.getDerivedStateFromProps, A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;
          A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);
          wg = false;
          var p = b.memoizedState;
          g.state = p;
          Cg(b, d, g, e);
          k = b.memoizedState;
          h !== d || p !== k || N.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = false);
        } else {
          g = b.stateNode;
          yg(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : lg(b.type, h);
          g.props = l;
          A = b.pendingProps;
          p = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
          var C = c.getDerivedStateFromProps;
          (n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);
          wg = false;
          p = b.memoizedState;
          g.state = p;
          Cg(b, d, g, e);
          var x = b.memoizedState;
          h !== A || p !== x || N.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(
            d,
            x,
            k
          ), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = false);
        }
        return qi(a, b, c, d, f, e);
      }
      function qi(a, b, c, d, e, f) {
        oi(a, b);
        var g = 0 !== (b.flags & 64);
        if (!d && !g)
          return e && Kf(b, c, false), hi(a, b, f);
        d = b.stateNode;
        ei.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
        b.memoizedState = d.state;
        e && Kf(b, c, true);
        return b.child;
      }
      function ri(a) {
        var b = a.stateNode;
        b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
        eh(a, b.containerInfo);
      }
      var si = { dehydrated: null, retryLane: 0 };
      function ti(a, b, c) {
        var d = b.pendingProps, e = P.current, f = false, g;
        (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        g ? (f = true, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e |= 1);
        I(P, e & 1);
        if (null === a) {
          void 0 !== d.fallback && ph(b);
          a = d.children;
          e = d.fallback;
          if (f)
            return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
          if ("number" === typeof d.unstable_expectedLoadTime)
            return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
          c = vi({ mode: "visible", children: a }, b.mode, c, null);
          c.return = b;
          return b.child = c;
        }
        if (null !== a.memoizedState) {
          if (f)
            return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
          c = xi(a, b, d.children, c);
          b.memoizedState = null;
          return c;
        }
        if (f)
          return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
        c = xi(a, b, d.children, c);
        b.memoizedState = null;
        return c;
      }
      function ui(a, b, c, d) {
        var e = a.mode, f = a.child;
        b = { mode: "hidden", children: b };
        0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
        c = Xg(c, e, d, null);
        f.return = a;
        c.return = a;
        f.sibling = c;
        a.child = f;
        return c;
      }
      function xi(a, b, c, d) {
        var e = a.child;
        a = e.sibling;
        c = Tg(e, { mode: "visible", children: c });
        0 === (b.mode & 2) && (c.lanes = d);
        c.return = b;
        c.sibling = null;
        null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
        return b.child = c;
      }
      function wi(a, b, c, d, e) {
        var f = b.mode, g = a.child;
        a = g.sibling;
        var h = { mode: "hidden", children: c };
        0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
        null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
        d.return = b;
        c.return = b;
        c.sibling = d;
        b.child = c;
        return d;
      }
      function yi(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        sg(a.return, b);
      }
      function zi(a, b, c, d, e, f) {
        var g = a.memoizedState;
        null === g ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
      }
      function Ai(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        fi(a, b, d.children, c);
        d = P.current;
        if (0 !== (d & 2))
          d = d & 1 | 2, b.flags |= 64;
        else {
          if (null !== a && 0 !== (a.flags & 64))
            a:
              for (a = b.child; null !== a; ) {
                if (13 === a.tag)
                  null !== a.memoizedState && yi(a, c);
                else if (19 === a.tag)
                  yi(a, c);
                else if (null !== a.child) {
                  a.child.return = a;
                  a = a.child;
                  continue;
                }
                if (a === b)
                  break a;
                for (; null === a.sibling; ) {
                  if (null === a.return || a.return === b)
                    break a;
                  a = a.return;
                }
                a.sibling.return = a.return;
                a = a.sibling;
              }
          d &= 1;
        }
        I(P, d);
        if (0 === (b.mode & 2))
          b.memoizedState = null;
        else
          switch (e) {
            case "forwards":
              c = b.child;
              for (e = null; null !== c; )
                a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
              c = e;
              null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
              zi(b, false, e, c, f, b.lastEffect);
              break;
            case "backwards":
              c = null;
              e = b.child;
              for (b.child = null; null !== e; ) {
                a = e.alternate;
                if (null !== a && null === ih(a)) {
                  b.child = e;
                  break;
                }
                a = e.sibling;
                e.sibling = c;
                c = e;
                e = a;
              }
              zi(b, true, c, null, f, b.lastEffect);
              break;
            case "together":
              zi(b, false, null, null, void 0, b.lastEffect);
              break;
            default:
              b.memoizedState = null;
          }
        return b.child;
      }
      function hi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        Dg |= b.lanes;
        if (0 !== (c & b.childLanes)) {
          if (null !== a && b.child !== a.child)
            throw Error(y(153));
          if (null !== b.child) {
            a = b.child;
            c = Tg(a, a.pendingProps);
            b.child = c;
            for (c.return = b; null !== a.sibling; )
              a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
            c.sibling = null;
          }
          return b.child;
        }
        return null;
      }
      var Bi;
      var Ci;
      var Di;
      var Ei;
      Bi = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag)
            a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b)
            break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Ci = function() {
      };
      Di = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          dh(ah.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "option":
              e = eb(a, e);
              d = eb(a, d);
              f = [];
              break;
            case "select":
              e = m({}, e, { value: void 0 });
              d = m({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
          }
          vb(c, d);
          var g;
          c = null;
          for (l in e)
            if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
              if ("style" === l) {
                var h = e[l];
                for (g in h)
                  h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
              } else
                "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h))
              if ("style" === l)
                if (h) {
                  for (g in h)
                    !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                  for (g in k)
                    k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                } else
                  c || (f || (f = []), f.push(l, c)), c = k;
              else
                "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
          }
          c && (f = f || []).push(
            "style",
            c
          );
          var l = f;
          if (b.updateQueue = l)
            b.flags |= 4;
        }
      };
      Ei = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Fi(a, b) {
        if (!lh)
          switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b; )
                null !== b.alternate && (c = b), b = b.sibling;
              null === c ? a.tail = null : c.sibling = null;
              break;
            case "collapsed":
              c = a.tail;
              for (var d = null; null !== c; )
                null !== c.alternate && (d = c), c = c.sibling;
              null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
          }
      }
      function Gi(a, b, c) {
        var d = b.pendingProps;
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return null;
          case 1:
            return Ff(b.type) && Gf(), null;
          case 3:
            fh();
            H(N);
            H(M);
            uh();
            d = b.stateNode;
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child)
              rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
            Ci(b);
            return null;
          case 5:
            hh(b);
            var e = dh(ch.current);
            c = b.type;
            if (null !== a && null != b.stateNode)
              Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
            else {
              if (!d) {
                if (null === b.stateNode)
                  throw Error(y(166));
                return null;
              }
              a = dh(ah.current);
              if (rh(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[wf] = b;
                d[xf] = f;
                switch (c) {
                  case "dialog":
                    G("cancel", d);
                    G("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    G("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (a = 0; a < Xe.length; a++)
                      G(Xe[a], d);
                    break;
                  case "source":
                    G("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    G("error", d);
                    G("load", d);
                    break;
                  case "details":
                    G("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    G("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    G("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), G("invalid", d);
                }
                vb(c, f);
                a = null;
                for (var g in f)
                  f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));
                switch (c) {
                  case "input":
                    Va(d);
                    cb(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = jf);
                }
                d = a;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                a === kb.html && (a = lb(c));
                a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[wf] = b;
                a[xf] = d;
                Bi(a, b, false, false);
                b.stateNode = a;
                g = wb(c, d);
                switch (c) {
                  case "dialog":
                    G("cancel", a);
                    G("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    G("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < Xe.length; e++)
                      G(Xe[e], a);
                    e = d;
                    break;
                  case "source":
                    G("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    G("error", a);
                    G("load", a);
                    e = d;
                    break;
                  case "details":
                    G("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    G("invalid", a);
                    break;
                  case "option":
                    e = eb(a, d);
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = m({}, d, { value: void 0 });
                    G("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    G("invalid", a);
                    break;
                  default:
                    e = d;
                }
                vb(c, e);
                var h = e;
                for (f in h)
                  if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
                  }
                switch (c) {
                  case "input":
                    Va(a);
                    cb(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = jf);
                }
                mf(c, d) && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 128);
            }
            return null;
          case 6:
            if (a && null != b.stateNode)
              Ei(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode)
                throw Error(y(166));
              c = dh(ch.current);
              dh(ah.current);
              rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
            }
            return null;
          case 13:
            H(P);
            d = b.memoizedState;
            if (0 !== (b.flags & 64))
              return b.lanes = c, b;
            d = null !== d;
            c = false;
            null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
            if (d && !c && 0 !== (b.mode & 2))
              if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1))
                0 === V && (V = 3);
              else {
                if (0 === V || 3 === V)
                  V = 4;
                null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
              }
            if (d || c)
              b.flags |= 4;
            return null;
          case 4:
            return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;
          case 10:
            return rg(b), null;
          case 17:
            return Ff(b.type) && Gf(), null;
          case 19:
            H(P);
            d = b.memoizedState;
            if (null === d)
              return null;
            f = 0 !== (b.flags & 64);
            g = d.rendering;
            if (null === g)
              if (f)
                Fi(d, false);
              else {
                if (0 !== V || null !== a && 0 !== (a.flags & 64))
                  for (a = b.child; null !== a; ) {
                    g = ih(a);
                    if (null !== g) {
                      b.flags |= 64;
                      Fi(d, false);
                      f = g.updateQueue;
                      null !== f && (b.updateQueue = f, b.flags |= 4);
                      null === d.lastEffect && (b.firstEffect = null);
                      b.lastEffect = d.lastEffect;
                      d = c;
                      for (c = b.child; null !== c; )
                        f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                      I(P, P.current & 1 | 2);
                      return b.child;
                    }
                    a = a.sibling;
                  }
                null !== d.tail && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
              }
            else {
              if (!f)
                if (a = ih(g), null !== a) {
                  if (b.flags |= 64, f = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh)
                    return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
                } else
                  2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
              d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
            }
            return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;
          case 23:
          case 24:
            return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
        }
        throw Error(y(156, b.tag));
      }
      function Li(a) {
        switch (a.tag) {
          case 1:
            Ff(a.type) && Gf();
            var b = a.flags;
            return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
          case 3:
            fh();
            H(N);
            H(M);
            uh();
            b = a.flags;
            if (0 !== (b & 64))
              throw Error(y(285));
            a.flags = b & -4097 | 64;
            return a;
          case 5:
            return hh(a), null;
          case 13:
            return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
          case 19:
            return H(P), null;
          case 4:
            return fh(), null;
          case 10:
            return rg(a), null;
          case 23:
          case 24:
            return Ki(), null;
          default:
            return null;
        }
      }
      function Mi(a, b) {
        try {
          var c = "", d = b;
          do
            c += Qa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e };
      }
      function Ni(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Oi = "function" === typeof WeakMap ? WeakMap : Map;
      function Pi(a, b, c) {
        c = zg(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Qi || (Qi = true, Ri = d);
          Ni(a, b);
        };
        return c;
      }
      function Si(a, b, c) {
        c = zg(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            Ni(a, b);
            return d(e);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      var Ui = "function" === typeof WeakSet ? WeakSet : Set;
      function Vi(a) {
        var b = a.ref;
        if (null !== b)
          if ("function" === typeof b)
            try {
              b(null);
            } catch (c) {
              Wi(a, c);
            }
          else
            b.current = null;
      }
      function Xi(a, b) {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
          case 22:
            return;
          case 1:
            if (b.flags & 256 && null !== a) {
              var c = a.memoizedProps, d = a.memoizedState;
              a = b.stateNode;
              b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
              a.__reactInternalSnapshotBeforeUpdate = b;
            }
            return;
          case 3:
            b.flags & 256 && qf(b.stateNode.containerInfo);
            return;
          case 5:
          case 6:
          case 4:
          case 17:
            return;
        }
        throw Error(y(163));
      }
      function Yi(a, b, c) {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
          case 22:
            b = c.updateQueue;
            b = null !== b ? b.lastEffect : null;
            if (null !== b) {
              a = b = b.next;
              do {
                if (3 === (a.tag & 3)) {
                  var d = a.create;
                  a.destroy = d();
                }
                a = a.next;
              } while (a !== b);
            }
            b = c.updateQueue;
            b = null !== b ? b.lastEffect : null;
            if (null !== b) {
              a = b = b.next;
              do {
                var e = a;
                d = e.next;
                e = e.tag;
                0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
                a = d;
              } while (a !== b);
            }
            return;
          case 1:
            a = c.stateNode;
            c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(
              d,
              b.memoizedState,
              a.__reactInternalSnapshotBeforeUpdate
            )));
            b = c.updateQueue;
            null !== b && Eg(c, b, a);
            return;
          case 3:
            b = c.updateQueue;
            if (null !== b) {
              a = null;
              if (null !== c.child)
                switch (c.child.tag) {
                  case 5:
                    a = c.child.stateNode;
                    break;
                  case 1:
                    a = c.child.stateNode;
                }
              Eg(c, b, a);
            }
            return;
          case 5:
            a = c.stateNode;
            null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
            return;
          case 6:
            return;
          case 4:
            return;
          case 12:
            return;
          case 13:
            null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
            return;
          case 19:
          case 17:
          case 20:
          case 21:
          case 23:
          case 24:
            return;
        }
        throw Error(y(163));
      }
      function aj(a, b) {
        for (var c = a; ; ) {
          if (5 === c.tag) {
            var d = c.stateNode;
            if (b)
              d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
            else {
              d = c.stateNode;
              var e = c.memoizedProps.style;
              e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
              d.style.display = sb("display", e);
            }
          } else if (6 === c.tag)
            c.stateNode.nodeValue = b ? "" : c.memoizedProps;
          else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === a)
            break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === a)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      }
      function bj(a, b) {
        if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
          try {
            Mf.onCommitFiberUnmount(Lf, b);
          } catch (f) {
          }
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
          case 22:
            a = b.updateQueue;
            if (null !== a && (a = a.lastEffect, null !== a)) {
              var c = a = a.next;
              do {
                var d = c, e = d.destroy;
                d = d.tag;
                if (void 0 !== e)
                  if (0 !== (d & 4))
                    Zi(b, c);
                  else {
                    d = b;
                    try {
                      e();
                    } catch (f) {
                      Wi(d, f);
                    }
                  }
                c = c.next;
              } while (c !== a);
            }
            break;
          case 1:
            Vi(b);
            a = b.stateNode;
            if ("function" === typeof a.componentWillUnmount)
              try {
                a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
              } catch (f) {
                Wi(
                  b,
                  f
                );
              }
            break;
          case 5:
            Vi(b);
            break;
          case 4:
            cj(a, b);
        }
      }
      function dj(a) {
        a.alternate = null;
        a.child = null;
        a.dependencies = null;
        a.firstEffect = null;
        a.lastEffect = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.return = null;
        a.updateQueue = null;
      }
      function ej(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function fj(a) {
        a: {
          for (var b = a.return; null !== b; ) {
            if (ej(b))
              break a;
            b = b.return;
          }
          throw Error(y(160));
        }
        var c = b;
        b = c.stateNode;
        switch (c.tag) {
          case 5:
            var d = false;
            break;
          case 3:
            b = b.containerInfo;
            d = true;
            break;
          case 4:
            b = b.containerInfo;
            d = true;
            break;
          default:
            throw Error(y(161));
        }
        c.flags & 16 && (pb(b, ""), c.flags &= -17);
        a:
          b:
            for (c = a; ; ) {
              for (; null === c.sibling; ) {
                if (null === c.return || ej(c.return)) {
                  c = null;
                  break a;
                }
                c = c.return;
              }
              c.sibling.return = c.return;
              for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
                if (c.flags & 2)
                  continue b;
                if (null === c.child || 4 === c.tag)
                  continue b;
                else
                  c.child.return = c, c = c.child;
              }
              if (!(c.flags & 2)) {
                c = c.stateNode;
                break a;
              }
            }
        d ? gj(a, c, b) : hj(a, c, b);
      }
      function gj(a, b, c) {
        var d = a.tag, e = 5 === d || 6 === d;
        if (e)
          a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
        else if (4 !== d && (a = a.child, null !== a))
          for (gj(a, b, c), a = a.sibling; null !== a; )
            gj(a, b, c), a = a.sibling;
      }
      function hj(a, b, c) {
        var d = a.tag, e = 5 === d || 6 === d;
        if (e)
          a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a))
          for (hj(a, b, c), a = a.sibling; null !== a; )
            hj(a, b, c), a = a.sibling;
      }
      function cj(a, b) {
        for (var c = b, d = false, e, f; ; ) {
          if (!d) {
            d = c.return;
            a:
              for (; ; ) {
                if (null === d)
                  throw Error(y(160));
                e = d.stateNode;
                switch (d.tag) {
                  case 5:
                    f = false;
                    break a;
                  case 3:
                    e = e.containerInfo;
                    f = true;
                    break a;
                  case 4:
                    e = e.containerInfo;
                    f = true;
                    break a;
                }
                d = d.return;
              }
            d = true;
          }
          if (5 === c.tag || 6 === c.tag) {
            a:
              for (var g = a, h = c, k = h; ; )
                if (bj(g, k), null !== k.child && 4 !== k.tag)
                  k.child.return = k, k = k.child;
                else {
                  if (k === h)
                    break a;
                  for (; null === k.sibling; ) {
                    if (null === k.return || k.return === h)
                      break a;
                    k = k.return;
                  }
                  k.sibling.return = k.return;
                  k = k.sibling;
                }
            f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
          } else if (4 === c.tag) {
            if (null !== c.child) {
              e = c.stateNode.containerInfo;
              f = true;
              c.child.return = c;
              c = c.child;
              continue;
            }
          } else if (bj(a, c), null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b)
            break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b)
              return;
            c = c.return;
            4 === c.tag && (d = false);
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      }
      function ij(a, b) {
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
          case 22:
            var c = b.updateQueue;
            c = null !== c ? c.lastEffect : null;
            if (null !== c) {
              var d = c = c.next;
              do
                3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
              while (d !== c);
            }
            return;
          case 1:
            return;
          case 5:
            c = b.stateNode;
            if (null != c) {
              d = b.memoizedProps;
              var e = null !== a ? a.memoizedProps : d;
              a = b.type;
              var f = b.updateQueue;
              b.updateQueue = null;
              if (null !== f) {
                c[xf] = d;
                "input" === a && "radio" === d.type && null != d.name && $a(c, d);
                wb(a, e);
                b = wb(a, d);
                for (e = 0; e < f.length; e += 2) {
                  var g = f[e], h = f[e + 1];
                  "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
                }
                switch (a) {
                  case "input":
                    ab(c, d);
                    break;
                  case "textarea":
                    ib(c, d);
                    break;
                  case "select":
                    a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
                }
              }
            }
            return;
          case 6:
            if (null === b.stateNode)
              throw Error(y(162));
            b.stateNode.nodeValue = b.memoizedProps;
            return;
          case 3:
            c = b.stateNode;
            c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
            return;
          case 12:
            return;
          case 13:
            null !== b.memoizedState && (jj = O(), aj(b.child, true));
            kj(b);
            return;
          case 19:
            kj(b);
            return;
          case 17:
            return;
          case 23:
          case 24:
            aj(b, null !== b.memoizedState);
            return;
        }
        throw Error(y(163));
      }
      function kj(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Ui());
          b.forEach(function(b2) {
            var d = lj.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function mj(a, b) {
        return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
      }
      var nj = Math.ceil;
      var oj = ra.ReactCurrentDispatcher;
      var pj = ra.ReactCurrentOwner;
      var X = 0;
      var U = null;
      var Y = null;
      var W = 0;
      var qj = 0;
      var rj = Bf(0);
      var V = 0;
      var sj = null;
      var tj = 0;
      var Dg = 0;
      var Hi = 0;
      var uj = 0;
      var vj = null;
      var jj = 0;
      var Ji = Infinity;
      function wj() {
        Ji = O() + 500;
      }
      var Z = null;
      var Qi = false;
      var Ri = null;
      var Ti = null;
      var xj = false;
      var yj = null;
      var zj = 90;
      var Aj = [];
      var Bj = [];
      var Cj = null;
      var Dj = 0;
      var Ej = null;
      var Fj = -1;
      var Gj = 0;
      var Hj = 0;
      var Ij = null;
      var Jj = false;
      function Hg() {
        return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
      }
      function Ig(a) {
        a = a.mode;
        if (0 === (a & 2))
          return 1;
        if (0 === (a & 4))
          return 99 === eg() ? 1 : 2;
        0 === Gj && (Gj = tj);
        if (0 !== kg.transition) {
          0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
          a = Gj;
          var b = 4186112 & ~Hj;
          b &= -b;
          0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
          return b;
        }
        a = eg();
        0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
        return a;
      }
      function Jg(a, b, c) {
        if (50 < Dj)
          throw Dj = 0, Ej = null, Error(y(185));
        a = Kj(a, b);
        if (null === a)
          return null;
        $c(a, b, c);
        a === U && (Hi |= b, 4 === V && Ii(a, W));
        var d = eg();
        1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
        vj = a;
      }
      function Kj(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; )
          a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      function Mj(a, b) {
        for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
          var h = 31 - Vc(g), k = 1 << h, l = f[h];
          if (-1 === l) {
            if (0 === (k & d) || 0 !== (k & e)) {
              l = b;
              Rc(k);
              var n = F;
              f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5e3 : -1;
            }
          } else
            l <= b && (a.expiredLanes |= k);
          g &= ~k;
        }
        d = Uc(a, a === U ? W : 0);
        b = F;
        if (0 === d)
          null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
        else {
          if (null !== c) {
            if (a.callbackPriority === b)
              return;
            c !== Zf && Pf(c);
          }
          15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Nj(a) {
        Fj = -1;
        Hj = Gj = 0;
        if (0 !== (X & 48))
          throw Error(y(327));
        var b = a.callbackNode;
        if (Oj() && a.callbackNode !== b)
          return null;
        var c = Uc(a, a === U ? W : 0);
        if (0 === c)
          return null;
        var d = c;
        var e = X;
        X |= 16;
        var f = Pj();
        if (U !== a || W !== d)
          wj(), Qj(a, d);
        do
          try {
            Rj();
            break;
          } catch (h) {
            Sj(a, h);
          }
        while (1);
        qg();
        oj.current = f;
        X = e;
        null !== Y ? d = 0 : (U = null, W = 0, d = V);
        if (0 !== (tj & Hi))
          Qj(a, 0);
        else if (0 !== d) {
          2 === d && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
          if (1 === d)
            throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
          a.finishedWork = a.current.alternate;
          a.finishedLanes = c;
          switch (d) {
            case 0:
            case 1:
              throw Error(y(345));
            case 2:
              Uj(a);
              break;
            case 3:
              Ii(a, c);
              if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
                if (0 !== Uc(a, 0))
                  break;
                e = a.suspendedLanes;
                if ((e & c) !== c) {
                  Hg();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = of(Uj.bind(null, a), d);
                break;
              }
              Uj(a);
              break;
            case 4:
              Ii(a, c);
              if ((c & 4186112) === c)
                break;
              d = a.eventTimes;
              for (e = -1; 0 < c; ) {
                var g = 31 - Vc(c);
                f = 1 << g;
                g = d[g];
                g > e && (e = g);
                c &= ~f;
              }
              c = e;
              c = O() - c;
              c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
              if (10 < c) {
                a.timeoutHandle = of(Uj.bind(null, a), c);
                break;
              }
              Uj(a);
              break;
            case 5:
              Uj(a);
              break;
            default:
              throw Error(y(329));
          }
        }
        Mj(a, O());
        return a.callbackNode === b ? Nj.bind(null, a) : null;
      }
      function Ii(a, b) {
        b &= ~uj;
        b &= ~Hi;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - Vc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Lj(a) {
        if (0 !== (X & 48))
          throw Error(y(327));
        Oj();
        if (a === U && 0 !== (a.expiredLanes & W)) {
          var b = W;
          var c = Tj(a, b);
          0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
        } else
          b = Uc(a, 0), c = Tj(a, b);
        0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
        if (1 === c)
          throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Uj(a);
        Mj(a, O());
        return null;
      }
      function Vj() {
        if (null !== Cj) {
          var a = Cj;
          Cj = null;
          a.forEach(function(a2) {
            a2.expiredLanes |= 24 & a2.pendingLanes;
            Mj(a2, O());
          });
        }
        ig();
      }
      function Wj(a, b) {
        var c = X;
        X |= 1;
        try {
          return a(b);
        } finally {
          X = c, 0 === X && (wj(), ig());
        }
      }
      function Xj(a, b) {
        var c = X;
        X &= -2;
        X |= 8;
        try {
          return a(b);
        } finally {
          X = c, 0 === X && (wj(), ig());
        }
      }
      function ni(a, b) {
        I(rj, qj);
        qj |= b;
        tj |= b;
      }
      function Ki() {
        qj = rj.current;
        H(rj);
      }
      function Qj(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, pf(c));
        if (null !== Y)
          for (c = Y.return; null !== c; ) {
            var d = c;
            switch (d.tag) {
              case 1:
                d = d.type.childContextTypes;
                null !== d && void 0 !== d && Gf();
                break;
              case 3:
                fh();
                H(N);
                H(M);
                uh();
                break;
              case 5:
                hh(d);
                break;
              case 4:
                fh();
                break;
              case 13:
                H(P);
                break;
              case 19:
                H(P);
                break;
              case 10:
                rg(d);
                break;
              case 23:
              case 24:
                Ki();
            }
            c = c.return;
          }
        U = a;
        Y = Tg(a.current, null);
        W = qj = tj = b;
        V = 0;
        sj = null;
        uj = Hi = Dg = 0;
      }
      function Sj(a, b) {
        do {
          var c = Y;
          try {
            qg();
            vh.current = Gh;
            if (yh) {
              for (var d = R.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              yh = false;
            }
            xh = 0;
            T = S = R = null;
            zh = false;
            pj.current = null;
            if (null === c || null === c.return) {
              V = 1;
              sj = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = W;
              h.flags |= 2048;
              h.firstEffect = h.lastEffect = null;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k;
                if (0 === (h.mode & 2)) {
                  var n = h.alternate;
                  n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
                }
                var A = 0 !== (P.current & 1), p = g;
                do {
                  var C;
                  if (C = 13 === p.tag) {
                    var x = p.memoizedState;
                    if (null !== x)
                      C = null !== x.dehydrated ? true : false;
                    else {
                      var w = p.memoizedProps;
                      C = void 0 === w.fallback ? false : true !== w.unstable_avoidThisFallback ? true : A ? false : true;
                    }
                  }
                  if (C) {
                    var z = p.updateQueue;
                    if (null === z) {
                      var u = /* @__PURE__ */ new Set();
                      u.add(l);
                      p.updateQueue = u;
                    } else
                      z.add(l);
                    if (0 === (p.mode & 2)) {
                      p.flags |= 64;
                      h.flags |= 16384;
                      h.flags &= -2981;
                      if (1 === h.tag)
                        if (null === h.alternate)
                          h.tag = 17;
                        else {
                          var t = zg(-1, 1);
                          t.tag = 2;
                          Ag(h, t);
                        }
                      h.lanes |= 1;
                      break a;
                    }
                    k = void 0;
                    h = b;
                    var q = f.pingCache;
                    null === q ? (q = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = /* @__PURE__ */ new Set(), q.set(l, k)));
                    if (!k.has(h)) {
                      k.add(h);
                      var v = Yj.bind(null, f, l, h);
                      l.then(v, v);
                    }
                    p.flags |= 4096;
                    p.lanes = b;
                    break a;
                  }
                  p = p.return;
                } while (null !== p);
                k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
              }
              5 !== V && (V = 2);
              k = Mi(k, h);
              p = g;
              do {
                switch (p.tag) {
                  case 3:
                    f = k;
                    p.flags |= 4096;
                    b &= -b;
                    p.lanes |= b;
                    var J = Pi(p, f, b);
                    Bg(p, J);
                    break a;
                  case 1:
                    f = k;
                    var K = p.type, Q = p.stateNode;
                    if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
                      p.flags |= 4096;
                      b &= -b;
                      p.lanes |= b;
                      var L = Si(p, f, b);
                      Bg(p, L);
                      break a;
                    }
                }
                p = p.return;
              } while (null !== p);
            }
            Zj(c);
          } catch (va) {
            b = va;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Pj() {
        var a = oj.current;
        oj.current = Gh;
        return null === a ? Gh : a;
      }
      function Tj(a, b) {
        var c = X;
        X |= 16;
        var d = Pj();
        U === a && W === b || Qj(a, b);
        do
          try {
            ak();
            break;
          } catch (e) {
            Sj(a, e);
          }
        while (1);
        qg();
        X = c;
        oj.current = d;
        if (null !== Y)
          throw Error(y(261));
        U = null;
        W = 0;
        return V;
      }
      function ak() {
        for (; null !== Y; )
          bk(Y);
      }
      function Rj() {
        for (; null !== Y && !Qf(); )
          bk(Y);
      }
      function bk(a) {
        var b = ck(a.alternate, a, qj);
        a.memoizedProps = a.pendingProps;
        null === b ? Zj(a) : Y = b;
        pj.current = null;
      }
      function Zj(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 2048)) {
            c = Gi(c, b, qj);
            if (null !== c) {
              Y = c;
              return;
            }
            c = b;
            if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
              for (var d = 0, e = c.child; null !== e; )
                d |= e.lanes | e.childLanes, e = e.sibling;
              c.childLanes = d;
            }
            null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
          } else {
            c = Li(b);
            if (null !== c) {
              c.flags &= 2047;
              Y = c;
              return;
            }
            null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === V && (V = 5);
      }
      function Uj(a) {
        var b = eg();
        gg(99, dk.bind(null, a, b));
        return null;
      }
      function dk(a, b) {
        do
          Oj();
        while (null !== yj);
        if (0 !== (X & 48))
          throw Error(y(327));
        var c = a.finishedWork;
        if (null === c)
          return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current)
          throw Error(y(177));
        a.callbackNode = null;
        var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
        a.pendingLanes = e;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= e;
        a.mutableReadLanes &= e;
        a.entangledLanes &= e;
        e = a.entanglements;
        for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
          var k = 31 - Vc(f), l = 1 << k;
          e[k] = 0;
          g[k] = -1;
          h[k] = -1;
          f &= ~l;
        }
        null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
        a === U && (Y = U = null, W = 0);
        1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
        if (null !== d) {
          e = X;
          X |= 32;
          pj.current = null;
          kf = fd;
          g = Ne();
          if (Oe(g)) {
            if ("selectionStart" in g)
              h = { start: g.selectionStart, end: g.selectionEnd };
            else
              a:
                if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
                  h = l.anchorNode;
                  f = l.anchorOffset;
                  k = l.focusNode;
                  l = l.focusOffset;
                  try {
                    h.nodeType, k.nodeType;
                  } catch (va) {
                    h = null;
                    break a;
                  }
                  var n = 0, A = -1, p = -1, C = 0, x = 0, w = g, z = null;
                  b:
                    for (; ; ) {
                      for (var u; ; ) {
                        w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);
                        w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);
                        3 === w.nodeType && (n += w.nodeValue.length);
                        if (null === (u = w.firstChild))
                          break;
                        z = w;
                        w = u;
                      }
                      for (; ; ) {
                        if (w === g)
                          break b;
                        z === h && ++C === f && (A = n);
                        z === k && ++x === l && (p = n);
                        if (null !== (u = w.nextSibling))
                          break;
                        w = z;
                        z = w.parentNode;
                      }
                      w = u;
                    }
                  h = -1 === A || -1 === p ? null : { start: A, end: p };
                } else
                  h = null;
            h = h || { start: 0, end: 0 };
          } else
            h = null;
          lf = { focusedElem: g, selectionRange: h };
          fd = false;
          Ij = null;
          Jj = false;
          Z = d;
          do
            try {
              ek();
            } catch (va) {
              if (null === Z)
                throw Error(y(330));
              Wi(Z, va);
              Z = Z.nextEffect;
            }
          while (null !== Z);
          Ij = null;
          Z = d;
          do
            try {
              for (g = a; null !== Z; ) {
                var t = Z.flags;
                t & 16 && pb(Z.stateNode, "");
                if (t & 128) {
                  var q = Z.alternate;
                  if (null !== q) {
                    var v = q.ref;
                    null !== v && ("function" === typeof v ? v(null) : v.current = null);
                  }
                }
                switch (t & 1038) {
                  case 2:
                    fj(Z);
                    Z.flags &= -3;
                    break;
                  case 6:
                    fj(Z);
                    Z.flags &= -3;
                    ij(Z.alternate, Z);
                    break;
                  case 1024:
                    Z.flags &= -1025;
                    break;
                  case 1028:
                    Z.flags &= -1025;
                    ij(Z.alternate, Z);
                    break;
                  case 4:
                    ij(Z.alternate, Z);
                    break;
                  case 8:
                    h = Z;
                    cj(g, h);
                    var J = h.alternate;
                    dj(h);
                    null !== J && dj(J);
                }
                Z = Z.nextEffect;
              }
            } catch (va) {
              if (null === Z)
                throw Error(y(330));
              Wi(Z, va);
              Z = Z.nextEffect;
            }
          while (null !== Z);
          v = lf;
          q = Ne();
          t = v.focusedElem;
          g = v.selectionRange;
          if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
            null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
            q = [];
            for (v = t; v = v.parentNode; )
              1 === v.nodeType && q.push({ element: v, left: v.scrollLeft, top: v.scrollTop });
            "function" === typeof t.focus && t.focus();
            for (t = 0; t < q.length; t++)
              v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
          }
          fd = !!kf;
          lf = kf = null;
          a.current = c;
          Z = d;
          do
            try {
              for (t = a; null !== Z; ) {
                var K = Z.flags;
                K & 36 && Yi(t, Z.alternate, Z);
                if (K & 128) {
                  q = void 0;
                  var Q = Z.ref;
                  if (null !== Q) {
                    var L = Z.stateNode;
                    switch (Z.tag) {
                      case 5:
                        q = L;
                        break;
                      default:
                        q = L;
                    }
                    "function" === typeof Q ? Q(q) : Q.current = q;
                  }
                }
                Z = Z.nextEffect;
              }
            } catch (va) {
              if (null === Z)
                throw Error(y(330));
              Wi(Z, va);
              Z = Z.nextEffect;
            }
          while (null !== Z);
          Z = null;
          $f();
          X = e;
        } else
          a.current = c;
        if (xj)
          xj = false, yj = a, zj = b;
        else
          for (Z = d; null !== Z; )
            b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
        d = a.pendingLanes;
        0 === d && (Ti = null);
        1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
        c = c.stateNode;
        if (Mf && "function" === typeof Mf.onCommitFiberRoot)
          try {
            Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
          } catch (va) {
          }
        Mj(a, O());
        if (Qi)
          throw Qi = false, a = Ri, Ri = null, a;
        if (0 !== (X & 8))
          return null;
        ig();
        return null;
      }
      function ek() {
        for (; null !== Z; ) {
          var a = Z.alternate;
          Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = true));
          var b = Z.flags;
          0 !== (b & 256) && Xi(a, Z);
          0 === (b & 512) || xj || (xj = true, hg(97, function() {
            Oj();
            return null;
          }));
          Z = Z.nextEffect;
        }
      }
      function Oj() {
        if (90 !== zj) {
          var a = 97 < zj ? 97 : zj;
          zj = 90;
          return gg(a, fk);
        }
        return false;
      }
      function $i(a, b) {
        Aj.push(b, a);
        xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
      }
      function Zi(a, b) {
        Bj.push(b, a);
        xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
      }
      function fk() {
        if (null === yj)
          return false;
        var a = yj;
        yj = null;
        if (0 !== (X & 48))
          throw Error(y(331));
        var b = X;
        X |= 32;
        var c = Bj;
        Bj = [];
        for (var d = 0; d < c.length; d += 2) {
          var e = c[d], f = c[d + 1], g = e.destroy;
          e.destroy = void 0;
          if ("function" === typeof g)
            try {
              g();
            } catch (k) {
              if (null === f)
                throw Error(y(330));
              Wi(f, k);
            }
        }
        c = Aj;
        Aj = [];
        for (d = 0; d < c.length; d += 2) {
          e = c[d];
          f = c[d + 1];
          try {
            var h = e.create;
            e.destroy = h();
          } catch (k) {
            if (null === f)
              throw Error(y(330));
            Wi(f, k);
          }
        }
        for (h = a.current.firstEffect; null !== h; )
          a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
        X = b;
        ig();
        return true;
      }
      function gk(a, b, c) {
        b = Mi(c, b);
        b = Pi(a, b, 1);
        Ag(a, b);
        b = Hg();
        a = Kj(a, 1);
        null !== a && ($c(a, 1, b), Mj(a, b));
      }
      function Wi(a, b) {
        if (3 === a.tag)
          gk(a, a, b);
        else
          for (var c = a.return; null !== c; ) {
            if (3 === c.tag) {
              gk(c, a, b);
              break;
            } else if (1 === c.tag) {
              var d = c.stateNode;
              if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
                a = Mi(b, a);
                var e = Si(c, a, 1);
                Ag(c, e);
                e = Hg();
                c = Kj(c, 1);
                if (null !== c)
                  $c(c, 1, e), Mj(c, e);
                else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d)))
                  try {
                    d.componentDidCatch(b, a);
                  } catch (f) {
                  }
                break;
              }
            }
            c = c.return;
          }
      }
      function Yj(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = Hg();
        a.pingedLanes |= a.suspendedLanes & c;
        U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
        Mj(a, b);
      }
      function lj(a, b) {
        var c = a.stateNode;
        null !== c && c.delete(b);
        b = 0;
        0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
        c = Hg();
        a = Kj(a, b);
        null !== a && ($c(a, b, c), Mj(a, c));
      }
      var ck;
      ck = function(a, b, c) {
        var d = b.lanes;
        if (null !== a)
          if (a.memoizedProps !== b.pendingProps || N.current)
            ug = true;
          else if (0 !== (c & d))
            ug = 0 !== (a.flags & 16384) ? true : false;
          else {
            ug = false;
            switch (b.tag) {
              case 3:
                ri(b);
                sh();
                break;
              case 5:
                gh(b);
                break;
              case 1:
                Ff(b.type) && Jf(b);
                break;
              case 4:
                eh(b, b.stateNode.containerInfo);
                break;
              case 10:
                d = b.memoizedProps.value;
                var e = b.type._context;
                I(mg, e._currentValue);
                e._currentValue = d;
                break;
              case 13:
                if (null !== b.memoizedState) {
                  if (0 !== (c & b.child.childLanes))
                    return ti(a, b, c);
                  I(P, P.current & 1);
                  b = hi(a, b, c);
                  return null !== b ? b.sibling : null;
                }
                I(P, P.current & 1);
                break;
              case 19:
                d = 0 !== (c & b.childLanes);
                if (0 !== (a.flags & 64)) {
                  if (d)
                    return Ai(a, b, c);
                  b.flags |= 64;
                }
                e = b.memoizedState;
                null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
                I(P, P.current);
                if (d)
                  break;
                else
                  return null;
              case 23:
              case 24:
                return b.lanes = 0, mi(a, b, c);
            }
            return hi(a, b, c);
          }
        else
          ug = false;
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            d = b.type;
            null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
            a = b.pendingProps;
            e = Ef(b, M.current);
            tg(b, c);
            e = Ch(null, b, d, a, e, c);
            b.flags |= 1;
            if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
              b.tag = 1;
              b.memoizedState = null;
              b.updateQueue = null;
              if (Ff(d)) {
                var f = true;
                Jf(b);
              } else
                f = false;
              b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
              xg(b);
              var g = d.getDerivedStateFromProps;
              "function" === typeof g && Gg(b, d, g, a);
              e.updater = Kg;
              b.stateNode = e;
              e._reactInternals = b;
              Og(b, d, a, c);
              b = qi(null, b, d, true, f, c);
            } else
              b.tag = 0, fi(null, b, e, c), b = b.child;
            return b;
          case 16:
            e = b.elementType;
            a: {
              null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
              a = b.pendingProps;
              f = e._init;
              e = f(e._payload);
              b.type = e;
              f = b.tag = hk(e);
              a = lg(e, a);
              switch (f) {
                case 0:
                  b = li(null, b, e, a, c);
                  break a;
                case 1:
                  b = pi(null, b, e, a, c);
                  break a;
                case 11:
                  b = gi(null, b, e, a, c);
                  break a;
                case 14:
                  b = ii(null, b, e, lg(e.type, a), d, c);
                  break a;
              }
              throw Error(y(306, e, ""));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
          case 3:
            ri(b);
            d = b.updateQueue;
            if (null === a || null === d)
              throw Error(y(282));
            d = b.pendingProps;
            e = b.memoizedState;
            e = null !== e ? e.element : null;
            yg(a, b);
            Cg(b, d, null, c);
            d = b.memoizedState.element;
            if (d === e)
              sh(), b = hi(a, b, c);
            else {
              e = b.stateNode;
              if (f = e.hydrate)
                kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
              if (f) {
                a = e.mutableSourceEagerHydrationData;
                if (null != a)
                  for (e = 0; e < a.length; e += 2)
                    f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
                c = Zg(b, null, d, c);
                for (b.child = c; c; )
                  c.flags = c.flags & -3 | 1024, c = c.sibling;
              } else
                fi(a, b, d, c), sh();
              b = b.child;
            }
            return b;
          case 5:
            return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
          case 6:
            return null === a && ph(b), null;
          case 13:
            return ti(a, b, c);
          case 4:
            return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
          case 7:
            return fi(a, b, b.pendingProps, c), b.child;
          case 8:
            return fi(
              a,
              b,
              b.pendingProps.children,
              c
            ), b.child;
          case 12:
            return fi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              g = b.memoizedProps;
              f = e.value;
              var h = b.type._context;
              I(mg, h._currentValue);
              h._currentValue = f;
              if (null !== g)
                if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
                  if (g.children === e.children && !N.current) {
                    b = hi(a, b, c);
                    break a;
                  }
                } else
                  for (h = b.child, null !== h && (h.return = b); null !== h; ) {
                    var k = h.dependencies;
                    if (null !== k) {
                      g = h.child;
                      for (var l = k.firstContext; null !== l; ) {
                        if (l.context === d && 0 !== (l.observedBits & f)) {
                          1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
                          h.lanes |= c;
                          l = h.alternate;
                          null !== l && (l.lanes |= c);
                          sg(h.return, c);
                          k.lanes |= c;
                          break;
                        }
                        l = l.next;
                      }
                    } else
                      g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;
                    if (null !== g)
                      g.return = h;
                    else
                      for (g = h; null !== g; ) {
                        if (g === b) {
                          g = null;
                          break;
                        }
                        h = g.sibling;
                        if (null !== h) {
                          h.return = g.return;
                          g = h;
                          break;
                        }
                        g = g.return;
                      }
                    h = g;
                  }
              fi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(
              e,
              f.unstable_observedBits
            ), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
          case 14:
            return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
          case 15:
            return ki(a, b, b.type, b.pendingProps, d, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
          case 19:
            return Ai(a, b, c);
          case 23:
            return mi(a, b, c);
          case 24:
            return mi(a, b, c);
        }
        throw Error(y(156, b.tag));
      };
      function ik(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.flags = 0;
        this.lastEffect = this.firstEffect = this.nextEffect = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function nh(a, b, c, d) {
        return new ik(a, b, c, d);
      }
      function ji(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function hk(a) {
        if ("function" === typeof a)
          return ji(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Aa)
            return 11;
          if (a === Da)
            return 14;
        }
        return 2;
      }
      function Tg(a, b) {
        var c = a.alternate;
        null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Vg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a)
          ji(a) && (g = 1);
        else if ("string" === typeof a)
          g = 5;
        else
          a:
            switch (a) {
              case ua:
                return Xg(c.children, e, f, b);
              case Ha:
                g = 8;
                e |= 16;
                break;
              case wa:
                g = 8;
                e |= 1;
                break;
              case xa:
                return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
              case Ba:
                return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
              case Ca:
                return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
              case Ia:
                return vi(c, e, f, b);
              case Ja:
                return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
              default:
                if ("object" === typeof a && null !== a)
                  switch (a.$$typeof) {
                    case ya:
                      g = 10;
                      break a;
                    case za:
                      g = 9;
                      break a;
                    case Aa:
                      g = 11;
                      break a;
                    case Da:
                      g = 14;
                      break a;
                    case Ea:
                      g = 16;
                      d = null;
                      break a;
                    case Fa:
                      g = 22;
                      break a;
                  }
                throw Error(y(130, null == a ? a : typeof a, ""));
            }
        b = nh(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Xg(a, b, c, d) {
        a = nh(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function vi(a, b, c, d) {
        a = nh(23, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        return a;
      }
      function Ug(a, b, c) {
        a = nh(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Wg(a, b, c) {
        b = nh(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function jk(a, b, c) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.pendingContext = this.context = null;
        this.hydrate = c;
        this.callbackNode = null;
        this.callbackPriority = 0;
        this.eventTimes = Zc(0);
        this.expirationTimes = Zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = Zc(0);
        this.mutableSourceEagerHydrationData = null;
      }
      function kk(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function lk(a, b, c, d) {
        var e = b.current, f = Hg(), g = Ig(e);
        a:
          if (c) {
            c = c._reactInternals;
            b: {
              if (Zb(c) !== c || 1 !== c.tag)
                throw Error(y(170));
              var h = c;
              do {
                switch (h.tag) {
                  case 3:
                    h = h.stateNode.context;
                    break b;
                  case 1:
                    if (Ff(h.type)) {
                      h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                      break b;
                    }
                }
                h = h.return;
              } while (null !== h);
              throw Error(y(171));
            }
            if (1 === c.tag) {
              var k = c.type;
              if (Ff(k)) {
                c = If(c, k, h);
                break a;
              }
            }
            c = h;
          } else
            c = Cf;
        null === b.context ? b.context = c : b.pendingContext = c;
        b = zg(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        Ag(e, b);
        Jg(e, g, f);
        return g;
      }
      function mk(a) {
        a = a.current;
        if (!a.child)
          return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function nk(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function ok(a, b) {
        nk(a, b);
        (a = a.alternate) && nk(a, b);
      }
      function pk() {
        return null;
      }
      function qk(a, b, c) {
        var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
        c = new jk(a, b, null != c && true === c.hydrate);
        b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
        c.current = b;
        b.stateNode = c;
        xg(b);
        a[ff] = c.current;
        cf(8 === a.nodeType ? a.parentNode : a);
        if (d)
          for (a = 0; a < d.length; a++) {
            b = d[a];
            var e = b._getVersion;
            e = e(b._source);
            null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
          }
        this._internalRoot = c;
      }
      qk.prototype.render = function(a) {
        lk(a, this._internalRoot, null, null);
      };
      qk.prototype.unmount = function() {
        var a = this._internalRoot, b = a.containerInfo;
        lk(null, a, null, function() {
          b[ff] = null;
        });
      };
      function rk(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function sk(a, b) {
        b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
        if (!b)
          for (var c; c = a.lastChild; )
            a.removeChild(c);
        return new qk(a, 0, b ? { hydrate: true } : void 0);
      }
      function tk(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f._internalRoot;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = mk(g);
              h.call(a2);
            };
          }
          lk(b, g, a, e);
        } else {
          f = c._reactRootContainer = sk(c, d);
          g = f._internalRoot;
          if ("function" === typeof e) {
            var k = e;
            e = function() {
              var a2 = mk(g);
              k.call(a2);
            };
          }
          Xj(function() {
            lk(b, g, a, e);
          });
        }
        return mk(g);
      }
      ec = function(a) {
        if (13 === a.tag) {
          var b = Hg();
          Jg(a, 4, b);
          ok(a, 4);
        }
      };
      fc = function(a) {
        if (13 === a.tag) {
          var b = Hg();
          Jg(a, 67108864, b);
          ok(a, 67108864);
        }
      };
      gc = function(a) {
        if (13 === a.tag) {
          var b = Hg(), c = Ig(a);
          Jg(a, c, b);
          ok(a, c);
        }
      };
      hc = function(a, b) {
        return b();
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            ab(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; )
                c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e)
                    throw Error(y(90));
                  Wa(d);
                  ab(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Wj;
      Hb = function(a, b, c, d, e) {
        var f = X;
        X |= 4;
        try {
          return gg(98, a.bind(null, b, c, d, e));
        } finally {
          X = f, 0 === X && (wj(), ig());
        }
      };
      Ib = function() {
        0 === (X & 49) && (Vj(), Oj());
      };
      Jb = function(a, b) {
        var c = X;
        X |= 2;
        try {
          return a(b);
        } finally {
          X = c, 0 === X && (wj(), ig());
        }
      };
      function uk(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!rk(b))
          throw Error(y(200));
        return kk(a, b, null, c);
      }
      var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] };
      var wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
      var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = cc(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!yk.isDisabled && yk.supportsFiber)
          try {
            Lf = yk.inject(xk), Mf = yk;
          } catch (a) {
          }
      }
      var yk;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
      exports.createPortal = uk;
      exports.findDOMNode = function(a) {
        if (null == a)
          return null;
        if (1 === a.nodeType)
          return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render)
            throw Error(y(188));
          throw Error(y(268, Object.keys(a)));
        }
        a = cc(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports.flushSync = function(a, b) {
        var c = X;
        if (0 !== (c & 48))
          return a(b);
        X |= 1;
        try {
          if (a)
            return gg(99, a.bind(null, b));
        } finally {
          X = c, ig();
        }
      };
      exports.hydrate = function(a, b, c) {
        if (!rk(b))
          throw Error(y(200));
        return tk(null, a, b, true, c);
      };
      exports.render = function(a, b, c) {
        if (!rk(b))
          throw Error(y(200));
        return tk(null, a, b, false, c);
      };
      exports.unmountComponentAtNode = function(a) {
        if (!rk(a))
          throw Error(y(40));
        return a._reactRootContainer ? (Xj(function() {
          tk(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[ff] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Wj;
      exports.unstable_createPortal = function(a, b) {
        return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
      };
      exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!rk(c))
          throw Error(y(200));
        if (null == a || void 0 === a._reactInternals)
          throw Error(y(38));
        return tk(a, b, c, false, d);
      };
      exports.version = "17.0.2";
    }
  });

  // ../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../node_modules/react-dom/index.js"(exports, module2) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module2.exports = require_react_dom_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // ../node_modules/@sentry/browser/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "../node_modules/@sentry/browser/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter7;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root, createExporter(module2.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter7 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault7 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter7);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/minimal/node_modules/tslib/tslib.js
  var require_tslib2 = __commonJS({
    "../node_modules/@sentry/minimal/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter7;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root, createExporter(module2.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter7 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault7 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter7);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/hub/node_modules/tslib/tslib.js
  var require_tslib3 = __commonJS({
    "../node_modules/@sentry/hub/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter7;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root, createExporter(module2.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter7 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault7 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter7);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/utils/node_modules/tslib/tslib.js
  var require_tslib4 = __commonJS({
    "../node_modules/@sentry/utils/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter7;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root, createExporter(module2.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter7 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault7 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter7);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/core/node_modules/tslib/tslib.js
  var require_tslib5 = __commonJS({
    "../node_modules/@sentry/core/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter7;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root, createExporter(module2.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter7 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault7 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter7);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/tracing/node_modules/tslib/tslib.js
  var require_tslib6 = __commonJS({
    "../node_modules/@sentry/tracing/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter7;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root, createExporter(module2.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter7 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (Object.hasOwnProperty.call(mod, k))
                result[k] = mod[k];
          }
          result["default"] = mod;
          return result;
        };
        __importDefault7 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter7);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // src/systems/instruments/src/DCDU/index.tsx
  var import_react21 = __toESM(require_react());

  // ../node_modules/@microsoft/msfs-sdk/msfssdk.js
  var SimVarValueType;
  (function(SimVarValueType2) {
    SimVarValueType2["Number"] = "number";
    SimVarValueType2["Percent"] = "percent";
    SimVarValueType2["Degree"] = "degrees";
    SimVarValueType2["Knots"] = "knots";
    SimVarValueType2["Feet"] = "feet";
    SimVarValueType2["Meters"] = "meters";
    SimVarValueType2["FPM"] = "feet per minute";
    SimVarValueType2["Radians"] = "radians";
    SimVarValueType2["InHG"] = "inches of mercury";
    SimVarValueType2["MB"] = "Millibars";
    SimVarValueType2["Bool"] = "bool";
    SimVarValueType2["Celsius"] = "celsius";
    SimVarValueType2["MHz"] = "MHz";
    SimVarValueType2["KHz"] = "KHz";
    SimVarValueType2["NM"] = "nautical mile";
    SimVarValueType2["String"] = "string";
    SimVarValueType2["RPM"] = "Rpm";
    SimVarValueType2["PPH"] = "Pounds per hour";
    SimVarValueType2["GPH"] = "gph";
    SimVarValueType2["Farenheit"] = "farenheit";
    SimVarValueType2["PSI"] = "psi";
    SimVarValueType2["GAL"] = "gallons";
    SimVarValueType2["LBS"] = "pounds";
    SimVarValueType2["Hours"] = "Hours";
    SimVarValueType2["Volts"] = "Volts";
    SimVarValueType2["Amps"] = "Amperes";
    SimVarValueType2["Seconds"] = "seconds";
    SimVarValueType2["Enum"] = "enum";
    SimVarValueType2["LLA"] = "latlonalt";
    SimVarValueType2["MetersPerSecond"] = "meters per second";
    SimVarValueType2["Mach"] = "mach";
    SimVarValueType2["Pounds"] = "pounds";
    SimVarValueType2["SlugsPerCubicFoot"] = "slug per cubic foot";
  })(SimVarValueType || (SimVarValueType = {}));
  var latlonaltRegEx = new RegExp(/latlonalt/i);
  var latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
  var pbhRegex = new RegExp(/pbh/i);
  var pid_structRegex = new RegExp(/pid_struct/i);
  var xyzRegex = new RegExp(/xyz/i);
  var stringRegex = new RegExp(/string/i);
  var boolRegex = new RegExp(/boolean|bool/i);
  var numberRegex = new RegExp(/number/i);
  var defaultSource = "";
  SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
      if (simvar) {
        let output;
        const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
        if (registeredID >= 0) {
          if (numberRegex.test(unit)) {
            output = simvar.getValueReg(registeredID);
          } else if (stringRegex.test(unit)) {
            output = simvar.getValueReg_String(registeredID);
          } else if (latlonaltRegEx.test(unit)) {
            output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
          } else if (latlonaltpbhRegex.test(unit)) {
            output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
          } else if (pbhRegex.test(unit)) {
            output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
          } else if (pid_structRegex.test(unit)) {
            output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
          } else if (xyzRegex.test(unit)) {
            output = new XYZ(simvar.getValue_XYZ(name, dataSource));
          } else {
            output = simvar.getValueReg(registeredID);
          }
        }
        return output;
      } else {
        console.warn("SimVar handler is not defined (" + name + ")");
      }
    } catch (error) {
      console.warn("ERROR ", error, " GetSimVarValue " + name + " unit : " + unit);
      return null;
    }
    return null;
  };
  SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == void 0) {
      console.warn(name + " : Trying to set a null value");
      return Promise.resolve();
    }
    try {
      if (simvar) {
        const regID = SimVar.GetRegisteredId(name, unit, dataSource);
        if (regID >= 0) {
          if (stringRegex.test(unit)) {
            return Coherent.call("setValueReg_String", regID, value);
          } else if (boolRegex.test(unit)) {
            return Coherent.call("setValueReg_Bool", regID, !!value);
          } else if (numberRegex.test(unit)) {
            return Coherent.call("setValueReg_Number", regID, value);
          } else if (latlonaltRegEx.test(unit)) {
            return Coherent.call("setValue_LatLongAlt", name, value, dataSource);
          } else if (latlonaltpbhRegex.test(unit)) {
            return Coherent.call("setValue_LatLongAltPBH", name, value, dataSource);
          } else if (pbhRegex.test(unit)) {
            return Coherent.call("setValue_PBH", name, value, dataSource);
          } else if (pid_structRegex.test(unit)) {
            return Coherent.call("setValue_PID_STRUCT", name, value, dataSource);
          } else if (xyzRegex.test(unit)) {
            return Coherent.call("setValue_XYZ", name, value, dataSource);
          } else {
            return Coherent.call("setValueReg_Number", regID, value);
          }
        }
      } else {
        console.warn("SimVar handler is not defined");
      }
    } catch (error) {
      console.warn("error SetSimVarValue " + error);
    }
    return Promise.resolve();
  };
  var NumberUnit = class {
    constructor(number, unit) {
      this._number = number;
      this._unit = unit;
      this.readonly = new NumberUnitReadOnly(this);
    }
    get number() {
      return this._number;
    }
    get unit() {
      return this._unit;
    }
    toNumberOfThisUnit(value, unit) {
      if (typeof value !== "number" && this.unit.canConvert(value.unit)) {
        return this.unit.convertFrom(value.number, value.unit);
      }
      if (typeof value === "number" && (!unit || this.unit.canConvert(unit))) {
        return unit ? this.unit.convertFrom(value, unit) : value;
      }
      return void 0;
    }
    set(arg1, arg2) {
      const converted = this.toNumberOfThisUnit(arg1, arg2);
      if (converted !== void 0) {
        this._number = converted;
        return this;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number + converted, this.unit);
        } else {
          out = this;
          this._number += converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number - converted, this.unit);
        } else {
          out = this;
          this._number -= converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    scale(factor, out) {
      if (out) {
        return out.set(this.number * factor, this.unit);
      } else {
        this._number *= factor;
        return this;
      }
    }
    ratio(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted) {
        return this.number / converted;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    abs(out) {
      if (out) {
        return out.set(Math.abs(this.number), this.unit);
      } else {
        this._number = Math.abs(this._number);
        return this;
      }
    }
    asUnit(unit) {
      return this.unit.convertTo(this.number, unit);
    }
    compare(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        throw new Error("Invalid unit conversion attempted.");
      }
      const diff = this.number - converted;
      if (Math.abs(diff) < 1e-14) {
        return 0;
      }
      return Math.sign(diff);
    }
    equals(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        return false;
      }
      if (isNaN(converted) && this.isNaN()) {
        return true;
      }
      const diff = this.number - converted;
      return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    isNaN() {
      return isNaN(this.number);
    }
    copy() {
      return new NumberUnit(this.number, this.unit);
    }
  };
  var NumberUnitReadOnly = class {
    constructor(source) {
      this.source = source;
    }
    get number() {
      return this.source.number;
    }
    get unit() {
      return this.source.unit;
    }
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.add(arg1, arg2, out);
      } else {
        return this.source.add(arg1, out);
      }
    }
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.subtract(arg1, arg2, out);
      } else {
        return this.source.subtract(arg1, out);
      }
    }
    scale(factor, out) {
      return this.source.scale(factor, out);
    }
    ratio(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.ratio(arg1, arg2);
      } else {
        return this.source.ratio(arg1);
      }
    }
    abs(out) {
      return this.source.abs(out);
    }
    asUnit(unit) {
      return this.source.asUnit(unit);
    }
    compare(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.compare(arg1, arg2);
      } else {
        return this.source.compare(arg1);
      }
    }
    equals(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2);
      } else {
        return this.source.equals(arg1);
      }
    }
    isNaN() {
      return this.source.isNaN();
    }
    copy() {
      return this.source.copy();
    }
  };
  var AbstractUnit = class {
    constructor(name) {
      this.name = name;
    }
    canConvert(otherUnit) {
      return this.family === otherUnit.family;
    }
    createNumber(value) {
      return new NumberUnit(value, this);
    }
    equals(other) {
      return this.family === other.family && this.name === other.name;
    }
  };
  var SimpleUnit = class extends AbstractUnit {
    constructor(family, name, scaleFactor, zeroOffset = 0) {
      super(name);
      this.family = family;
      this.scaleFactor = scaleFactor;
      this.zeroOffset = zeroOffset;
    }
    canConvert(otherUnit) {
      return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
  };
  var CompoundUnit = class extends AbstractUnit {
    constructor(family, numerator, denominator, name) {
      if (name === void 0) {
        name = "";
        let i = 0;
        while (i < numerator.length - 1) {
          name += `${numerator[i++].name}-`;
        }
        name += `${numerator[i].name}`;
        if (denominator.length > 0) {
          name += " per ";
          i = 0;
          while (i < denominator.length - 1) {
            name += `${denominator[i++].name}-`;
          }
          name += `${denominator[i].name}`;
        }
      }
      super(name);
      this.family = family;
      this.numerator = Array.from(numerator);
      this.denominator = Array.from(denominator);
      this.numerator.sort((a, b) => a.family.localeCompare(b.family));
      this.denominator.sort((a, b) => a.family.localeCompare(b.family));
      this.scaleFactor = this.getScaleFactor();
    }
    getScaleFactor() {
      let factor = 1;
      factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
      factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
      return factor;
    }
    canConvert(otherUnit) {
      return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
  };
  var UnitFamily;
  (function(UnitFamily2) {
    UnitFamily2["Distance"] = "distance";
    UnitFamily2["Angle"] = "angle";
    UnitFamily2["Duration"] = "duration";
    UnitFamily2["Weight"] = "weight";
    UnitFamily2["Volume"] = "volume";
    UnitFamily2["Pressure"] = "pressure";
    UnitFamily2["Temperature"] = "temperature";
    UnitFamily2["TemperatureDelta"] = "temperature_delta";
    UnitFamily2["Speed"] = "speed";
    UnitFamily2["Acceleration"] = "acceleration";
    UnitFamily2["WeightFlux"] = "weight_flux";
    UnitFamily2["VolumeFlux"] = "volume_flux";
  })(UnitFamily || (UnitFamily = {}));
  var UnitType = class {
  };
  UnitType.METER = new SimpleUnit(UnitFamily.Distance, "meter", 1);
  UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, "foot", 0.3048);
  UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, "kilometer", 1e3);
  UnitType.MILE = new SimpleUnit(UnitFamily.Distance, "mile", 1609.34);
  UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, "nautical mile", 1852);
  UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, "great arc radian", 6378100);
  UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, "radian", 1);
  UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, "degree", Math.PI / 180);
  UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, "minute", Math.PI / 180 / 60);
  UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, "second", Math.PI / 180 / 3600);
  UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, "millisecond", 1e-3);
  UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, "second", 1);
  UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, "minute", 60);
  UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, "hour", 3600);
  UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, "kilogram", 1);
  UnitType.POUND = new SimpleUnit(UnitFamily.Weight, "pound", 0.453592);
  UnitType.TON = new SimpleUnit(UnitFamily.Weight, "ton", 907.185);
  UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, "tonne", 1e3);
  UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, "liter", 0.80283679);
  UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "gallon", 3.0390664);
  UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "imperial gallon", 3.6497683);
  UnitType.LITER = new SimpleUnit(UnitFamily.Volume, "liter", 1);
  UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, "gallon", 3.78541);
  UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, "hectopascal", 1);
  UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, "atmosphere", 1013.25);
  UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, "inch of mercury", 33.8639);
  UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, "millimeter of mercury", 1.33322);
  UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, "kelvin", 1, 0);
  UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, "\xB0 Celsius", 1, 273.15);
  UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, "\xB0 Fahrenheit", 5 / 9, 459.67);
  UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, "\xB0 Rankine", 5 / 9, 0);
  UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Celsius", 1);
  UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Fahrenheit", 5 / 9);
  UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], "knot");
  UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
  UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
  UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
  UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
  UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
  UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
  UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [new SimpleUnit(UnitFamily.Distance, "9.80665 meter", 9.80665)], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
  UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
  UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
  UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
  UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
  var BasePublisher = class {
    constructor(bus, pacer = void 0) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.publishActive = false;
      this.pacer = pacer;
    }
    startPublish() {
      this.publishActive = true;
    }
    stopPublish() {
      this.publishActive = false;
    }
    isPublishing() {
      return this.publishActive;
    }
    onUpdate() {
      return;
    }
    publish(topic, data, sync = false, isCached = true) {
      if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
        this.publisher.pub(topic, data, sync, isCached);
      }
    }
  };
  var SimVarPublisher = class extends BasePublisher {
    constructor(simVarMap, bus, pacer) {
      super(bus, pacer);
      this.resolvedSimVars = /* @__PURE__ */ new Map();
      this.indexedSimVars = /* @__PURE__ */ new Map();
      this.subscribed = /* @__PURE__ */ new Set();
      for (const [topic, entry] of simVarMap) {
        if (entry.indexed) {
          this.indexedSimVars.set(topic, entry);
          this.resolveIndexedSimVar(topic, entry);
        } else {
          this.resolvedSimVars.set(topic, entry);
        }
      }
      const handleSubscribedTopic = (topic) => {
        if (this.resolvedSimVars.has(topic)) {
          this.onTopicSubscribed(topic);
        } else {
          this.tryMatchIndexedSubscribedTopic(topic);
        }
      };
      this.bus.forEachSubscribedTopic(handleSubscribedTopic);
      this.bus.getSubscriber().on("event_bus_topic_first_sub").handle(handleSubscribedTopic);
    }
    tryMatchIndexedSubscribedTopic(topic) {
      if (this.indexedSimVars.size === 0) {
        return;
      }
      if (!SimVarPublisher.INDEXED_REGEX.test(topic)) {
        return;
      }
      const match = topic.match(SimVarPublisher.INDEXED_REGEX);
      const [, matchedTopic, index] = match;
      const entry = this.indexedSimVars.get(matchedTopic);
      if (entry) {
        this.onTopicSubscribed(this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index)));
      }
    }
    resolveIndexedSimVar(topic, entry, index) {
      const resolvedTopic = index === void 0 ? topic : `${topic}_${index}`;
      if (this.resolvedSimVars.has(resolvedTopic)) {
        return resolvedTopic;
      }
      this.resolvedSimVars.set(resolvedTopic, { name: entry.name.replace("#index#", `${index !== null && index !== void 0 ? index : 1}`), type: entry.type, map: entry.map });
      return resolvedTopic;
    }
    onTopicSubscribed(topic) {
      if (this.subscribed.has(topic)) {
        return;
      }
      this.subscribed.add(topic);
      if (this.publishActive) {
        this.publishTopic(topic);
      }
    }
    subscribe(data) {
      return;
    }
    unsubscribe(data) {
      return;
    }
    onUpdate() {
      for (const topic of this.subscribed.values()) {
        this.publishTopic(topic);
      }
    }
    publishTopic(topic) {
      const value = this.getValue(topic);
      if (value !== void 0) {
        this.publish(topic, value);
      }
    }
    getValue(topic) {
      const entry = this.resolvedSimVars.get(topic);
      if (entry === void 0) {
        return void 0;
      }
      return entry.map === void 0 ? this.getSimVarValue(entry) : entry.map(this.getSimVarValue(entry));
    }
    getSimVarValue(entry) {
      const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
      if (entry.type === SimVarValueType.Bool) {
        return svValue === 1;
      }
      return svValue;
    }
  };
  SimVarPublisher.INDEXED_REGEX = /(.*)_([1-9]\d*)$/;
  var AeroMath = class {
    static pressureAir(temperature, density) {
      return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    static densityAir(pressure, temperature) {
      return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    static temperatureAir(pressure, density) {
      return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    static soundSpeedAir(temperature) {
      return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    static totalPressureRatioAir(mach) {
      return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    static isaTemperature(altitude) {
      if (altitude < 11e3) {
        return 15 + Math.max(altitude, -610) * -65e-4;
      } else if (altitude < 2e4) {
        return -56.5;
      } else if (altitude < 32e3) {
        return -56.5 + (altitude - 2e4) * 1e-3;
      } else if (altitude < 47e3) {
        return -44.5 + (altitude - 32e3) * 28e-4;
      } else if (altitude < 51e3) {
        return -2.5;
      } else if (altitude < 71e3) {
        return -2.5 + (altitude - 51e3) * -28e-4;
      } else {
        return -58.5 + (Math.min(altitude, 8e4) - 71e3) * -2e-3;
      }
    }
    static isaPressure(altitude) {
      if (altitude < -610) {
        return 1099.15;
      } else if (altitude <= 11e3) {
        return 1013.25 * Math.pow(1 - 22558e-9 * altitude, 5.2558);
      } else if (altitude <= 2e4) {
        return 226.32 * Math.exp(-157686e-9 * (altitude - 11e3));
      } else if (altitude <= 32e3) {
        return 54.7499 * Math.pow(1 + 461574e-11 * (altitude - 2e4), -34.1627);
      } else if (altitude <= 47e3) {
        return 8.68058 * Math.pow(1 + 122458e-10 * (altitude - 32e3), -12.201);
      } else if (altitude <= 51e3) {
        return 1.10914 * Math.exp(-126225e-9 * (altitude - 47e3));
      } else if (altitude <= 71e3) {
        return 0.669439 * Math.pow(1 - 103455e-10 * (altitude - 51e3), 12.201);
      } else if (altitude <= 8e4) {
        return 0.039568 * Math.pow(1 - 931749e-11 * (altitude - 71e3), 17.0814);
      } else {
        return 88638e-7;
      }
    }
    static isaDensity(altitude, deltaIsa = 0) {
      return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    static soundSpeedIsa(altitude, deltaIsa = 0) {
      return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    static tasToMach(tas, soundSpeed) {
      return tas / soundSpeed;
    }
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
      return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static machToTas(mach, soundSpeed) {
      return mach * soundSpeed;
    }
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
      return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static casToMach(cas, pressure) {
      const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
      const impactPressure = 1013.25 * (Math.pow(1 + 0.2 * mach0 * mach0, 3.5) - 1);
      return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    static casToMachIsa(cas, altitude) {
      return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    static machToCas(mach, pressure) {
      const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
      return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    static machToCasIsa(mach, altitude) {
      return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    static casToTas(cas, pressure, temperature) {
      return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
      return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static tasToCas(tas, pressure, temperature) {
      return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
      return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    static flowCoefFromForce(force, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return force / (dynamicPressure * area);
    }
    static flowForceFromCoef(coef, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return coef * dynamicPressure * area;
    }
  };
  AeroMath.R = 8.314462618153;
  AeroMath.R_AIR = 287.057;
  AeroMath.GAMMA_AIR = 1.4;
  AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
  AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.lift = AeroMath.flowForceFromCoef;
  AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.drag = AeroMath.flowForceFromCoef;
  var BitFlags = class {
    static createFlag(index) {
      if (index < 0 || index > 32) {
        throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
      }
      return 1 << index;
    }
    static not(flags, mask = ~0) {
      return flags ^ mask;
    }
    static union(...flags) {
      let result = 0;
      const len = flags.length;
      for (let i = 0; i < len; i++) {
        result |= flags[i];
      }
      return result;
    }
    static intersection(...flags) {
      const len = flags.length;
      if (len === 0) {
        return 0;
      }
      let result = flags[0];
      for (let i = 1; i < len; i++) {
        result &= flags[i];
      }
      return result;
    }
    static set(flags, valuesToSet, mask) {
      return flags & ~mask | valuesToSet & mask;
    }
    static isAny(flags, conditions) {
      return (flags & conditions) !== 0;
    }
    static isAll(flags, conditions) {
      return (flags & conditions) === conditions;
    }
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
      startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0, 0, 32);
      endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = 32, 0, 32);
      for (let i = startIndex; i < endIndex; i++) {
        const value = (flags & 1 << i) !== 0;
        if (valueFilter === void 0 || valueFilter === value) {
          callback(value, i, flags);
        }
      }
    }
  };
  var HandlerSubscription = class {
    constructor(handler, initialNotifyFunc, onDestroy) {
      this.handler = handler;
      this.initialNotifyFunc = initialNotifyFunc;
      this.onDestroy = onDestroy;
      this._isAlive = true;
      this._isPaused = false;
      this.canInitialNotify = initialNotifyFunc !== void 0;
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    initialNotify() {
      if (!this._isAlive) {
        throw new Error("HandlerSubscription: cannot notify a dead Subscription.");
      }
      this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot pause a dead Subscription.");
      }
      this._isPaused = true;
      return this;
    }
    resume(initialNotify = false) {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot resume a dead Subscription.");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      if (initialNotify) {
        this.initialNotify();
      }
      return this;
    }
    destroy() {
      if (!this._isAlive) {
        return;
      }
      this._isAlive = false;
      this.onDestroy && this.onDestroy(this);
    }
  };
  var SubscribablePipe = class extends HandlerSubscription {
    constructor(from, to, arg3, arg4) {
      let handler;
      let onDestroy;
      if (typeof arg4 === "function") {
        handler = (fromVal) => {
          to.set(arg3(fromVal, to.get()));
        };
        onDestroy = arg4;
      } else {
        handler = (fromVal) => {
          to.set(fromVal);
        };
        onDestroy = arg3;
      }
      super(handler, (sub) => {
        sub.handler(from.get());
      }, onDestroy);
    }
  };
  var AbstractSubscribable = class {
    constructor() {
      this.isSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.notifySubscription.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    notify() {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            this.notifySubscription(sub);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`AbstractSubscribable: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    notifySubscription(sub) {
      sub.handler(this.get());
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    map(fn, equalityFunc, mutateFunc, initialVal) {
      return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var MappedSubscribableClass = class extends AbstractSubscribable {
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
      super();
      this.input = input;
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.input.get()));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.input.get());
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSub = this.input.sub((inputValue) => {
        this.updateValue(inputValue);
      }, true);
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    updateValue(inputValue) {
      const value = this.mapFunc(inputValue, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    get() {
      return this.value;
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot pause a dead subscribable");
      }
      if (this._isPaused) {
        return this;
      }
      this.inputSub.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot resume a dead subscribable");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this.inputSub.resume(true);
      return this;
    }
    destroy() {
      this._isAlive = false;
      this.inputSub.destroy();
    }
  };
  var NumberUnitSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    static createFromNumberUnit(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var Vec2Math = class {
    static create(x, y) {
      const vec = new Float64Array(2);
      if (x !== void 0 && y !== void 0) {
        vec[0] = x;
        vec[1] = y;
      }
      return vec;
    }
    static theta(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    static set(x, y, vec) {
      vec[0] = x;
      vec[1] = y;
      return vec;
    }
    static setFromPolar(r, theta, vec) {
      vec[0] = r * Math.cos(theta);
      vec[1] = r * Math.sin(theta);
      return vec;
    }
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      return out;
    }
    static abs(v1) {
      return Math.hypot(v1[0], v1[1]);
    }
    static normalize(v1, out) {
      const mag = Vec2Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      return out;
    }
    static normal(v1, out, counterClockwise = false) {
      const x = v1[0];
      const y = v1[1];
      if (!counterClockwise) {
        out[0] = y;
        out[1] = -x;
      } else {
        out[0] = -y;
        out[1] = x;
      }
      return out;
    }
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    static copy(from, to) {
      return Vec2Math.set(from[0], from[1], to);
    }
    static pointWithinPolygon(polygon, point) {
      let k = 0;
      let f = 0;
      let u1 = 0;
      let v1 = 0;
      let u2 = 0;
      let v2 = 0;
      let currentP = null;
      let nextP = null;
      const x = point[0];
      const y = point[1];
      const contourLen = polygon.length - 1;
      currentP = polygon[0];
      if (currentP[0] !== polygon[contourLen][0] && currentP[1] !== polygon[contourLen][1]) {
        throw new Error("First and last coordinates in a ring must be the same");
      }
      u1 = currentP[0] - x;
      v1 = currentP[1] - y;
      for (let i = 0; i < polygon.length - 1; i++) {
        nextP = polygon[i + 1];
        v2 = nextP[1] - y;
        if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
          currentP = nextP;
          v1 = v2;
          u1 = currentP[0] - x;
          continue;
        }
        u2 = nextP[0] - point[0];
        if (v2 > 0 && v1 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f > 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v1 > 0 && v2 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f < 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v2 === 0 && v1 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 === 0) {
          if (u2 <= 0 && u1 >= 0) {
            return void 0;
          } else if (u1 <= 0 && u2 >= 0) {
            return void 0;
          }
        }
        currentP = nextP;
        v1 = v2;
        u1 = u2;
      }
      if (k % 2 === 0) {
        return false;
      }
      return true;
    }
  };
  var Vec3Math = class {
    static create(x, y, z) {
      const vec = new Float64Array(3);
      if (x !== void 0 && y !== void 0 && z !== void 0) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
      }
      return vec;
    }
    static theta(vec) {
      return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    static phi(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    static set(x, y, z, vec) {
      vec[0] = x;
      vec[1] = y;
      vec[2] = z;
      return vec;
    }
    static setFromSpherical(r, theta, phi, vec) {
      const sinTheta = Math.sin(theta);
      vec[0] = sinTheta * Math.cos(phi);
      vec[1] = sinTheta * Math.sin(phi);
      vec[2] = Math.cos(theta);
      return vec;
    }
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      out[2] = v1[2] + v2[2];
      return out;
    }
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      out[2] = v1[2] - v2[2];
      return out;
    }
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    static cross(v1, v2, out) {
      const x1 = v1[0];
      const y1 = v1[1];
      const z1 = v1[2];
      const x2 = v2[0];
      const y2 = v2[1];
      const z2 = v2[2];
      out[0] = y1 * z2 - z1 * y2;
      out[1] = z1 * x2 - x1 * z2;
      out[2] = x1 * y2 - y1 * x2;
      return out;
    }
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      out[2] = v1[2] * scalar;
      return out;
    }
    static abs(v1) {
      return Math.hypot(v1[0], v1[1], v1[2]);
    }
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      out[2] = v1[2] / mag;
      return out;
    }
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    static copy(from, to) {
      return Vec3Math.set(from[0], from[1], from[2], to);
    }
  };
  var VecNMath = class {
    static create(length, ...components) {
      const vec = new Float64Array(length);
      for (let i = 0; i < length && components.length; i++) {
        vec[i] = components[i];
      }
      return vec;
    }
    static set(vec, ...components) {
      for (let i = 0; i < vec.length && components.length; i++) {
        vec[i] = components[i];
      }
      return vec;
    }
    static abs(vec) {
      return Math.hypot(...vec);
    }
    static dot(v1, v2) {
      if (v1.length !== v2.length) {
        throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
      }
      let dot = 0;
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        dot += v1[i] * v2[i];
      }
      return dot;
    }
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        out[i] = v1[i] / mag;
      }
      return out;
    }
    static equals(vec1, vec2) {
      if (vec1.length !== vec2.length) {
        return false;
      }
      for (let i = 0; i < vec1.length; i++) {
        if (vec1[i] !== vec2[i]) {
          return false;
        }
      }
      return true;
    }
    static copy(from, to) {
      if (from.length !== to.length) {
        throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
      }
      to.set(from);
      return to;
    }
  };
  var Vec2Subject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new Vec2Subject(initialVal);
    }
    static createFromVector(initialVal) {
      return new Vec2Subject(initialVal);
    }
    get() {
      return this.value;
    }
    set(arg1, arg2) {
      let x, y;
      if (typeof arg1 === "number") {
        x = arg1;
        y = arg2;
      } else {
        x = arg1[0];
        y = arg1[1];
      }
      const equals = x === this.value[0] && y === this.value[1];
      if (!equals) {
        Vec2Math.set(x, y, this.value);
        this.notify();
      }
    }
  };
  var VecNSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new VecNSubject(initialVal);
    }
    static createFromVector(initialVal) {
      return new VecNSubject(initialVal);
    }
    get() {
      return this.value;
    }
    set(arg1, ...args) {
      let array;
      if (typeof arg1 === "number") {
        array = args;
        args.unshift(arg1);
      } else {
        array = arg1;
      }
      if (array.length > this.value.length) {
        throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
      }
      let equals = true;
      const len = array.length;
      for (let i = 0; i < len; i++) {
        if (array[i] !== this.value[i]) {
          equals = false;
          break;
        }
      }
      if (!equals) {
        this.value.set(array);
        this.notify();
      }
    }
  };
  var Subject = class extends AbstractSubscribable {
    constructor(value, equalityFunc, mutateFunc) {
      super();
      this.value = value;
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.isMutableSubscribable = true;
    }
    static create(v, equalityFunc, mutateFunc) {
      return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    notifySub(sub) {
      sub(this.value);
    }
    set(value) {
      if (!this.equalityFunc(value, this.value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    apply(value) {
      let changed = false;
      for (const prop in value) {
        changed = value[prop] !== this.value[prop];
        if (changed) {
          break;
        }
      }
      Object.assign(this.value, value);
      changed && this.notify();
    }
    notify() {
      super.notify();
    }
    get() {
      return this.value;
    }
  };
  var Transform2D = class {
    constructor() {
      this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    getParameters() {
      return this.array;
    }
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
      let scaleX = arg1;
      if (arg1 instanceof Transform2D) {
        [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewX;
      array[2] = translateX;
      array[3] = skewY;
      array[4] = scaleY;
      array[5] = translateY;
      return this;
    }
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    setScaleY(value) {
      this.array[4] = value;
      return this;
    }
    setScale(x, y) {
      this.array[0] = x;
      this.array[4] = y;
      return this;
    }
    setSkewX(value) {
      this.array[1] = value;
      return this;
    }
    setSkewY(value) {
      this.array[3] = value;
      return this;
    }
    setTranslateX(value) {
      this.array[2] = value;
      return this;
    }
    setTranslateY(value) {
      this.array[5] = value;
      return this;
    }
    setTranslate(x, y) {
      this.array[2] = x;
      this.array[5] = y;
      return this;
    }
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_10 = array[3];
      const e_11 = array[4];
      const e_12 = array[5];
      const i_00 = e_11;
      const i_01 = -e_10;
      const i_10 = -e_01;
      const i_11 = e_00;
      const i_20 = e_01 * e_12 - e_02 * e_11;
      const i_21 = -(e_00 * e_12 - e_02 * e_10);
      const det = e_00 * i_00 + e_01 * i_01;
      return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    copy() {
      return new Transform2D().set(this);
    }
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
      const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
      return Vec2Math.set(x, y, out);
    }
    offsetOrigin(x, y) {
      Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
      Transform2D.offsetOriginCache[1] = this;
      Transform2D.offsetOriginCache[2].toTranslation(x, y);
      return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    toIdentity() {
      return this.set(1, 0, 0, 0, 1, 0);
    }
    toTranslation(x, y) {
      return this.set(1, 0, x, 0, 1, y);
    }
    toScale(x, y, originX, originY) {
      this.set(x, 0, 0, 0, y, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    toRotation(theta, originX, originY) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, -sin, 0, sin, cos, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    toReflection(theta, originX, originY) {
      const sin = Math.sin(2 * theta);
      const cos = Math.cos(2 * theta);
      this.set(cos, sin, 0, sin, -cos, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    addTranslation(x, y, order = "after") {
      if (order === "before") {
        Transform2D.addCache[0].toTranslation(x, y);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        Transform2D.addCache[1].toTranslation(x, y);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addScale(x, y, arg3, arg4, arg5) {
      let originX, originY, order;
      if (typeof arg3 === "number") {
        originX = arg3;
        originY = arg4;
        order = arg5;
      } else {
        order = arg3;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addRotation(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addReflection(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform2D.concatCache[0];
      const newTransform = Transform2D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 2; j++) {
            newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform2D.offsetOriginCache = [new Transform2D(), void 0, new Transform2D()];
  Transform2D.addCache = [new Transform2D(), new Transform2D()];
  Transform2D.concatCache = [new Transform2D(), new Transform2D()];
  var Transform3D = class {
    constructor() {
      this.array = new Float64Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    }
    getParameters() {
      return this.array;
    }
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
      let scaleX = arg1;
      if (arg1 instanceof Transform3D) {
        [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewXY;
      array[2] = skewXZ;
      array[3] = translateX;
      array[4] = skewYX;
      array[5] = scaleY;
      array[6] = skewYZ;
      array[7] = translateY;
      array[8] = skewZX;
      array[9] = skewZY;
      array[10] = scaleZ;
      array[11] = translateZ;
      return this;
    }
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    setScaleY(value) {
      this.array[5] = value;
      return this;
    }
    setScaleZ(value) {
      this.array[10] = value;
      return this;
    }
    setScale(x, y, z) {
      this.array[0] = x;
      this.array[5] = y;
      this.array[10] = z;
      return this;
    }
    setSkewX(y, z) {
      this.array[1] = y;
      this.array[2] = z;
      return this;
    }
    setSkewY(x, z) {
      this.array[4] = x;
      this.array[6] = z;
      return this;
    }
    setSkewZ(x, y) {
      this.array[8] = x;
      this.array[9] = y;
      return this;
    }
    setTranslateX(value) {
      this.array[3] = value;
      return this;
    }
    setTranslateY(value) {
      this.array[7] = value;
      return this;
    }
    setTranslateZ(value) {
      this.array[11] = value;
      return this;
    }
    setTranslate(x, y, z) {
      this.array[3] = x;
      this.array[7] = y;
      this.array[11] = z;
      return this;
    }
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_03 = array[3];
      const e_10 = array[4];
      const e_11 = array[5];
      const e_12 = array[6];
      const e_13 = array[7];
      const e_20 = array[8];
      const e_21 = array[9];
      const e_22 = array[10];
      const e_23 = array[11];
      const c_00 = e_11 * e_22 - e_12 * e_21;
      const c_01 = e_12 * e_20 - e_10 * e_22;
      const c_02 = e_10 * e_21 - e_11 * e_20;
      const c_10 = e_02 * e_21 - e_01 * e_22;
      const c_11 = e_00 * e_22 - e_02 * e_20;
      const c_12 = e_01 * e_20 - e_00 * e_21;
      const c_20 = e_01 * e_12 - e_02 * e_11;
      const c_21 = e_02 * e_10 - e_00 * e_12;
      const c_22 = e_00 * e_11 - e_01 * e_10;
      const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
      if (det === 0) {
        throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
      }
      const i_00 = c_00 / det;
      const i_01 = c_10 / det;
      const i_02 = c_20 / det;
      const i_10 = c_01 / det;
      const i_11 = c_11 / det;
      const i_12 = c_21 / det;
      const i_20 = c_02 / det;
      const i_21 = c_12 / det;
      const i_22 = c_22 / det;
      const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
      const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
      const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
      return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    copy() {
      return new Transform3D().set(this);
    }
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
      const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
      const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
      return Vec3Math.set(x, y, z, out);
    }
    offsetOrigin(x, y, z) {
      Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
      Transform3D.offsetOriginCache[1] = this;
      Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
      return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    toIdentity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    toTranslation(x, y, z) {
      return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    toScale(x, y, z, originX, originY, originZ) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationX(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationY(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationZ(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
      const abs = Math.hypot(axisX, axisY, axisZ);
      const ux = axisX / abs;
      const uy = axisY / abs;
      const uz = axisZ / abs;
      const ux_uy = ux * uy;
      const ux_uz = ux * uz;
      const uy_uz = uy * uz;
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      const cosCompl = 1 - cos;
      this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    addTranslation(x, y, z, order = "after") {
      if (order === "before") {
        Transform3D.addCache[0].toTranslation(x, y, z);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        Transform3D.addCache[1].toTranslation(x, y, z);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
      let originX, originY, originZ, order;
      if (typeof arg4 === "number") {
        originX = arg4;
        originY = arg5;
        originZ = arg6;
        order = arg7;
      } else {
        order = arg4;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationX(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationY(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
      let originX, originY, originZ, order;
      if (typeof arg5 === "number") {
        originX = arg5;
        originY = arg6;
        originZ = arg7;
        order = arg8;
      } else {
        order = arg5;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform3D.concatCache[0];
      const newTransform = Transform3D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 3; j++) {
            newArray[j * 4 + i] = oldArray[i] * nextArray[j * 4] + oldArray[4 + i] * nextArray[j * 4 + 1] + oldArray[8 + i] * nextArray[j * 4 + 2] + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform3D.offsetOriginCache = [new Transform3D(), void 0, new Transform3D()];
  Transform3D.addCache = [new Transform3D(), new Transform3D()];
  Transform3D.concatCache = [new Transform3D(), new Transform3D()];
  var TransformPerspective = class {
    constructor() {
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create(0, 0, 1);
      this.cameraPosTransform = new Transform3D();
      this.cameraRotationTransform = new Transform3D();
      this.cameraRotationInverseTransform = new Transform3D();
      this.allCameraTransforms = [this.cameraPosTransform, this.cameraRotationInverseTransform];
      this.fullTransform = new Transform3D();
    }
    getCameraPosition() {
      return this.cameraPos;
    }
    getCameraRotation() {
      return this.cameraRotationTransform;
    }
    getSurfacePosition() {
      return this.cameraPos;
    }
    set(arg1, arg2, arg3) {
      if (arg1 instanceof Float64Array) {
        this._setCameraPosition(arg1);
        this._setCameraRotation(arg2);
        this.setSurfacePosition(arg3);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
      } else {
        return this.set(arg1.getCameraPosition(), arg1.getCameraRotation(), arg1.getSurfacePosition());
      }
    }
    _setCameraPosition(cameraPos) {
      Vec3Math.copy(cameraPos, this.cameraPos);
      this.cameraPosTransform.toTranslation(-cameraPos[0], -cameraPos[1], -cameraPos[2]);
    }
    _setCameraRotation(cameraRotation) {
      this.cameraRotationTransform.set(cameraRotation);
      this.cameraRotationInverseTransform.set(cameraRotation).invert();
    }
    setCameraPosition(cameraPos) {
      this._setCameraPosition(cameraPos);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    setCameraRotation(cameraRotation) {
      this._setCameraRotation(cameraRotation);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    setSurfacePosition(surfacePos) {
      Vec3Math.copy(surfacePos, this.surfacePos);
      return this;
    }
    copy() {
      return new TransformPerspective().set(this);
    }
    apply(vec, out) {
      const transformedVec = this.fullTransform.apply(vec, TransformPerspective.vec3Cache[0]);
      if (Vec3Math.abs(transformedVec) < 1e-7) {
        return Vec2Math.set(0, 0, out);
      }
      if (transformedVec[2] < 0) {
        return Vec2Math.set(NaN, NaN, out);
      }
      const ratio = this.surfacePos[2] / transformedVec[2];
      return Vec2Math.set(transformedVec[0] * ratio + this.surfacePos[0], transformedVec[1] * ratio + this.surfacePos[1], out);
    }
  };
  TransformPerspective.vec3Cache = [Vec3Math.create()];
  var MathUtils = class {
    static clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    static round(value, precision = 1) {
      return Math.round(value / precision) * precision;
    }
    static diffAngle(start, end, directional = true) {
      const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
      return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      if (x0 !== x1 && y0 !== y1) {
        const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
        return fraction * (y1 - y0) + y0;
      } else {
        return y0;
      }
    }
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      const length = Math.min(y0.length, y1.length, out.length);
      for (let i = 0; i < length; i++) {
        out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
      }
      return out;
    }
  };
  MathUtils.TWO_PI = Math.PI * 2;
  MathUtils.HALF_PI = Math.PI / 2;
  var ExpSmoother = class {
    constructor(tau, initial = null, dtThreshold = Infinity) {
      this.tau = tau;
      this.dtThreshold = dtThreshold;
      this.lastValue = initial;
    }
    last() {
      return this.lastValue;
    }
    next(raw, dt) {
      let next;
      if (this.tau > 0 && this.lastValue !== null) {
        const factor = this.calculateFactor(dt);
        next = ExpSmoother.smooth(raw, this.lastValue, factor);
      } else {
        next = raw;
      }
      this.lastValue = next;
      return next;
    }
    calculateFactor(dt) {
      if (dt > this.dtThreshold) {
        return 0;
      } else {
        return Math.exp(-dt / this.tau);
      }
    }
    reset(value) {
      return this.lastValue = value !== null && value !== void 0 ? value : null;
    }
    static smooth(value, last, factor) {
      return value * (1 - factor) + last * factor;
    }
  };
  var GeoPointReadOnly = class {
    constructor(source) {
      this.source = source;
    }
    get lat() {
      return this.source.lat;
    }
    get lon() {
      return this.source.lon;
    }
    distance(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distance(arg1, arg2);
      } else {
        return this.source.distance(arg1);
      }
    }
    distanceRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distanceRhumb(arg1, arg2);
      } else {
        return this.source.distanceRhumb(arg1);
      }
    }
    bearingTo(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingTo(arg1, arg2);
      } else {
        return this.source.bearingTo(arg1);
      }
    }
    bearingFrom(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingFrom(arg1, arg2);
      } else {
        return this.source.bearingFrom(arg1);
      }
    }
    bearingRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingRhumb(arg1, arg2);
      } else {
        return this.source.bearingRhumb(arg1);
      }
    }
    offset(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offset(bearing, distance, out);
    }
    offsetRhumb(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offsetRhumb(bearing, distance, out);
    }
    antipode(out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.antipode(out);
    }
    toCartesian(out) {
      return this.source.toCartesian(out);
    }
    equals(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2, arg3);
      } else {
        return this.source.equals(arg1, arg2);
      }
    }
    copy(to) {
      return this.source.copy(to);
    }
  };
  var GeoPoint = class {
    constructor(lat, lon) {
      this._lat = 0;
      this._lon = 0;
      this.set(lat, lon);
      this.readonly = new GeoPointReadOnly(this);
    }
    get lat() {
      return this._lat;
    }
    get lon() {
      return this._lon;
    }
    static asLatLonInterface(arg1, arg2) {
      if (typeof arg1 === "number") {
        return GeoPoint.tempGeoPoint.set(arg1, arg2);
      } else {
        return arg1;
      }
    }
    static asVec3(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
      } else {
        return arg1;
      }
    }
    set(arg1, arg2) {
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      lat = GeoPoint.toPlusMinus180(lat);
      lon = GeoPoint.toPlusMinus180(lon);
      if (Math.abs(lat) > 90) {
        lat = 180 - lat;
        lat = GeoPoint.toPlusMinus180(lat);
        lon += 180;
        lon = GeoPoint.toPlusMinus180(lon);
      }
      this._lat = lat;
      this._lon = lon;
      return this;
    }
    setFromCartesian(arg1, arg2, arg3) {
      const vec = GeoPoint.asVec3(arg1, arg2, arg3);
      const theta = Vec3Math.theta(vec);
      const phi = Vec3Math.phi(vec);
      return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    distance(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    distanceRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    bearingTo(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    bearingFrom(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    bearingRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    offset(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(latRad);
      const cosLat = Math.cos(latRad);
      const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
      const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
      const angularDistance = distance;
      const sinAngularDistance = Math.sin(angularDistance);
      const cosAngularDistance = Math.cos(angularDistance);
      const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
      const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
      const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
      const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    offsetRhumb(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const bearingRad = bearing * Avionics.Utils.DEG2RAD;
      const deltaLat = distance * Math.cos(bearingRad);
      let offsetLat = latRad + deltaLat;
      let offsetLon;
      if (Math.abs(offsetLat) >= Math.PI / 2) {
        offsetLat = Math.sign(offsetLat) * 90;
        offsetLon = 0;
      } else {
        const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
        const deltaLon = distance * Math.sin(bearingRad) / correction;
        offsetLon = lonRad + deltaLon;
        offsetLat *= Avionics.Utils.RAD2DEG;
        offsetLon *= Avionics.Utils.RAD2DEG;
      }
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    antipode(out) {
      return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    toCartesian(out) {
      return GeoPoint.sphericalToCartesian(this, out);
    }
    equals(arg1, arg2, arg3) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      if (other) {
        if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
          return true;
        }
        const tolerance = typeof arg1 === "number" ? arg3 : arg2;
        const distance = this.distance(other);
        return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return false;
      }
    }
    copy(to) {
      return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    static sphericalToCartesian(arg1, arg2, arg3) {
      const point = GeoPoint.asLatLonInterface(arg1, arg2);
      const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
      const phi = point.lon * Avionics.Utils.DEG2RAD;
      return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    static equals(arg1, arg2, arg3, arg4, arg5) {
      if (arg1 instanceof Float64Array) {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      } else if (typeof arg1 === "number") {
        return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      }
    }
    static distance(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof Float64Array) {
        return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
      } else {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === "number") {
          lat1 = arg1;
          lon1 = arg2;
          lat2 = arg3;
          lon2 = arg4;
        } else {
          lat1 = arg1.lat;
          lon1 = arg1.lon;
          lat2 = arg2.lat;
          lon2 = arg2.lon;
        }
        lat1 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
        const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
        const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
    }
    static distanceRhumb(arg1, arg2, arg3, arg4) {
      let lat1, lon1, lat2, lon2;
      if (typeof arg1 === "number") {
        lat1 = arg1 * Avionics.Utils.DEG2RAD;
        lon1 = arg2 * Avionics.Utils.DEG2RAD;
        lat2 = arg3 * Avionics.Utils.DEG2RAD;
        lon2 = arg4 * Avionics.Utils.DEG2RAD;
      } else if (arg1 instanceof Float64Array) {
        const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
        lat1 = point1.lat;
        lon1 = point1.lon;
        const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
        lat2 = point2.lat;
        lon2 = point2.lon;
      } else {
        lat1 = arg1.lat;
        lon1 = arg1.lon;
        lat2 = arg2.lat;
        lon2 = arg2.lon;
      }
      const deltaLat = lat2 - lat1;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    static initialBearing(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      const cosLat2 = Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
      const y = Math.sin(lon2 - lon1) * cosLat2;
      const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
      return (bearing + 360) % 360;
    }
    static finalBearing(lat1, lon1, lat2, lon2) {
      return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    static bearingRhumb(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    static toPlusMinus180(angle) {
      return (angle % 360 + 540) % 360 - 180;
    }
    static deltaPsi(latRad1, latRad2) {
      return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
      return Math.abs(deltaPsi) > 1e-12 ? (latRad2 - latRad1) / deltaPsi : Math.cos(latRad1);
    }
  };
  GeoPoint.EQUALITY_TOLERANCE = 1e-7;
  GeoPoint.tempVec3 = new Float64Array(3);
  GeoPoint.tempGeoPoint = new GeoPoint(0, 0);
  var GeoCircle = class {
    constructor(center, radius) {
      this._center = new Float64Array(3);
      this._radius = 0;
      this._sinRadius = 0;
      this.set(center, radius);
    }
    get center() {
      return this._center;
    }
    get radius() {
      return this._radius;
    }
    isGreatCircle() {
      return this._radius === Math.PI / 2;
    }
    arcLength(angle) {
      return this._sinRadius * angle;
    }
    angularWidth(length) {
      return length / this._sinRadius;
    }
    set(center, radius) {
      if (center instanceof Float64Array) {
        if (Vec3Math.abs(center) === 0) {
          Vec3Math.set(1, 0, 0, this._center);
        } else {
          Vec3Math.normalize(center, this._center);
        }
      } else {
        GeoPoint.sphericalToCartesian(center, this._center);
      }
      this._radius = Math.abs(radius) % Math.PI;
      this._sinRadius = Math.sin(this._radius);
      return this;
    }
    setAsGreatCircle(arg1, arg2) {
      this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
      return this;
    }
    reverse() {
      Vec3Math.multScalar(this._center, -1, this._center);
      this._radius = Math.PI - this._radius;
      return this;
    }
    distanceToCenter(point) {
      if (point instanceof Float64Array) {
        point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
      } else {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const dot = Vec3Math.dot(point, this._center);
      return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    closest(point, out) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
      const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
      const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
        return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
      }
      const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
      const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
      return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    distance(point) {
      const distanceToCenter = this.distanceToCenter(point);
      return distanceToCenter - this._radius;
    }
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return Math.abs(distance) < tolerance;
    }
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return inclusive ? distance <= tolerance : distance < -tolerance;
    }
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
      }
      if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
        throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
      const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
      const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
      const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
      return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angle = distance / Math.sin(this.radius);
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this.radius === 0) {
        return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
      }
      point = this.closest(point, GeoCircle.vec3Cache[3]);
      const sin = Math.sin(angle / 2);
      const q0 = Math.cos(angle / 2);
      const q1 = sin * this._center[0];
      const q2 = sin * this._center[1];
      const q3 = sin * this._center[2];
      const q0Sq = q0 * q0;
      const q1Sq = q1 * q1;
      const q2Sq = q2 * q2;
      const q3Sq = q3 * q3;
      const q01 = q0 * q1;
      const q02 = q0 * q2;
      const q03 = q0 * q3;
      const q12 = q1 * q2;
      const q13 = q1 * q3;
      const q23 = q2 * q3;
      const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
      const rot_12 = 2 * (q12 - q03);
      const rot_13 = 2 * (q13 + q02);
      const rot_21 = 2 * (q12 + q03);
      const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
      const rot_23 = 2 * (q23 - q01);
      const rot_31 = 2 * (q13 - q02);
      const rot_32 = 2 * (q23 + q01);
      const rot_33 = q0Sq - q1Sq - q2Sq + q3Sq;
      const x = point[0];
      const y = point[1];
      const z = point[2];
      const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
      const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
      const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
      return out instanceof Float64Array ? Vec3Math.set(rotX, rotY, rotZ, out) : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    intersection(other, out) {
      const center1 = this._center;
      const center2 = other._center;
      const radius1 = this._radius;
      const radius2 = other._radius;
      const dot = Vec3Math.dot(center1, center2);
      const dotSquared = dot * dot;
      if (dotSquared === 1) {
        return 0;
      }
      const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross, cross);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
      let solutionCount = 1;
      if (!out[0]) {
        out[0] = new Float64Array(3);
      }
      out[0].set(cross);
      Vec3Math.multScalar(out[0], offset, out[0]);
      Vec3Math.add(out[0], intersection, out[0]);
      if (offset > 0) {
        if (!out[1]) {
          out[1] = new Float64Array(3);
        }
        out[1].set(cross);
        Vec3Math.multScalar(out[1], -offset, out[1]);
        Vec3Math.add(out[1], intersection, out[1]);
        solutionCount++;
      }
      return solutionCount;
    }
    intersectionGeoPoint(other, out) {
      const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
      for (let i = 0; i < solutionCount; i++) {
        if (!out[i]) {
          out[i] = new GeoPoint(0, 0);
        }
        out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
      }
      return solutionCount;
    }
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const center1 = this.center;
      const center2 = other.center;
      const radius1 = this.radius;
      const radius2 = other.radius;
      const dot = Vec3Math.dot(center1, center2);
      const dotSquared = dot * dot;
      if (dotSquared === 1) {
        if (dot === 1) {
          return Math.abs(this.radius - other.radius) <= tolerance ? NaN : 0;
        } else {
          return Math.abs(Math.PI - this.radius - other.radius) <= tolerance ? NaN : 0;
        }
      }
      const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross, cross);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const sinTol = Math.sin(tolerance);
      return (1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol ? 2 : 1;
    }
    static createFromPoint(point, radius) {
      return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
      return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    static createGreatCircleFromPointBearing(point, bearing) {
      return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    static getGreatCircleNormal(arg1, arg2, out) {
      return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    static _getGreatCircleNormal(arg1, arg2, out) {
      if (typeof arg2 === "number") {
        return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
      } else {
        return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
      }
    }
    static getGreatCircleNormalFromPoints(point1, point2, out) {
      if (!(point1 instanceof Float64Array)) {
        point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
      }
      return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
      if (point instanceof Float64Array) {
        point = GeoCircle.tempGeoPoint.setFromCartesian(point);
      }
      const lat = point.lat * Avionics.Utils.DEG2RAD;
      const long = point.lon * Avionics.Utils.DEG2RAD;
      bearing *= Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(lat);
      const sinLon = Math.sin(long);
      const cosLon = Math.cos(long);
      const sinBearing = Math.sin(bearing);
      const cosBearing = Math.cos(bearing);
      const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
      const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
      const z = Math.cos(lat) * sinBearing;
      return Vec3Math.set(x, y, z, out);
    }
  };
  GeoCircle.ANGULAR_TOLERANCE = 1e-7;
  GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
  GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
  GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var NavMath = class {
    static clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    static normalizeHeading(heading) {
      if (isFinite(heading)) {
        return (heading % 360 + 360) % 360;
      } else {
        console.error(`normalizeHeading: Invalid heading: ${heading}`);
        return NaN;
      }
    }
    static reciprocateHeading(heading) {
      return NavMath.normalizeHeading(heading + 180);
    }
    static turnRadius(airspeedTrue, bankAngle) {
      return Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)) / 3.2808399;
    }
    static bankAngle(airspeedTrue, radius) {
      const airspeedMS = airspeedTrue * 0.51444444;
      return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    static getTurnDirection(startCourse, endCourse) {
      return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? "left" : "right";
    }
    static polarToDegreesNorth(radians) {
      return NavMath.normalizeHeading(180 / Math.PI * (Math.PI / 2 - radians));
    }
    static degreesNorthToPolar(degrees) {
      return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    static calculateArcDistance(startBearing, endBearing, radius) {
      const angularWidth = (endBearing - startBearing + 360) % 360 * Avionics.Utils.DEG2RAD;
      const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
      return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const a = dx * dx + dy * dy;
      const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
      const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
      const det = b * b - 4 * a * c;
      if (a < 1e-7 || det < 0) {
        sRef.x1 = NaN;
        sRef.x2 = NaN;
        sRef.y1 = NaN;
        sRef.y2 = NaN;
        return 0;
      } else if (det == 0) {
        const t = -b / (2 * a);
        sRef.x1 = x1 + t * dx;
        sRef.y1 = y1 + t * dy;
        sRef.x2 = NaN;
        sRef.y2 = NaN;
        return 1;
      } else {
        const t1 = (-b + Math.sqrt(det)) / (2 * a);
        sRef.x1 = x1 + t1 * dx;
        sRef.y1 = y1 + t1 * dy;
        const t2 = (-b - Math.sqrt(det)) / (2 * a);
        sRef.x2 = x1 + t2 * dx;
        sRef.y2 = y1 + t2 * dy;
        return 2;
      }
    }
    static northAngle(cx, cy, x, y) {
      return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    static bearingIsBetween(bearing, start, end) {
      const range = this.normalizeHeading(end - start);
      const relativeBearing = this.normalizeHeading(bearing - start);
      return relativeBearing >= 0 && relativeBearing <= range;
    }
    static headingToAngle(heading, turnDirection) {
      return NavMath.normalizeHeading(heading + (turnDirection === "left" ? 90 : -90));
    }
    static angleToHeading(angle, turnDirection) {
      return NavMath.normalizeHeading(angle + (turnDirection === "left" ? -90 : 90));
    }
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
      const currCrosswind = windSpeed * Math.sin(course * Math.PI / 180 - windDirection * Math.PI / 180);
      const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
      return windCorrection;
    }
    static crossTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    static alongTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
      return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    static desiredTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    static desiredTrackArc(center, turnDirection, pos) {
      const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
      return NavMath.angleToHeading(northAngle, turnDirection);
    }
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
      const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
      const sign = turnDirection === "right" ? 1 : -1;
      const alpha = ((end - start) * sign + 360) % 360;
      const mid = (start + alpha / 2 * sign + 360) % 360;
      const rotBearing = (bearingFromCenter - mid + 540) % 360 - 180;
      const frac = rotBearing * sign / alpha + 0.5;
      return frac;
    }
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
      const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
      const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
      const bearing = turnDirection === "right" ? start + theta : start - theta;
      center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
      return out;
    }
    static crossTrackArc(center, radius, pos) {
      return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    static diffAngle(a, b) {
      let diff = b - a;
      while (diff > 180) {
        diff -= 360;
      }
      while (diff <= -180) {
        diff += 360;
      }
      return diff;
    }
    static napierSide(b, c, beta, gamma) {
      return 2 * Math.atan(Math.tan(0.5 * (b - c)) * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    static normal(course, turnDirection, outVector) {
      const normalCourse = NavMath.headingToAngle(course, turnDirection);
      const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
      outVector[0] = Math.cos(polarCourse);
      outVector[1] = Math.sin(polarCourse);
    }
  };
  NavMath.vec3Cache = [new Float64Array(3)];
  NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MagVar = class {
    static get(arg1, arg2) {
      return MagVar.getMagVar(arg1, arg2);
    }
    static magneticToTrue(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing + (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    static trueToMagnetic(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing - (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    static getMagVar(arg1, arg2) {
      if (typeof Facilities === "undefined") {
        return 0;
      }
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      return Facilities.getMagVar(lat, lon);
    }
  };
  var GeoPointSubject = class extends AbstractSubscribable {
    constructor(value, tolerance) {
      super();
      this.value = value;
      this.tolerance = tolerance;
      this.isMutableSubscribable = true;
    }
    static create(initialVal, tolerance) {
      return new GeoPointSubject(initialVal, tolerance);
    }
    static createFromGeoPoint(initialVal) {
      return new GeoPointSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var AbstractGeoProjection = class {
    constructor() {
      this.center = new GeoPoint(0, 0);
      this.centerTranslation = new Float64Array(2);
      this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
      this.preRotation = new Float64Array(3);
      this.translation = new Float64Array(2);
      this.postRotation = 0;
      this.rotationSin = 0;
      this.rotationCos = 1;
      this.reflectY = 1;
      this.preRotationForwardTransform = new Transform3D();
      this.preRotationReverseTransform = new Transform3D();
      this.rotationCache = [new Transform3D(), new Transform3D()];
    }
    getCenter() {
      return this.center.readonly;
    }
    getScaleFactor() {
      return this.scaleFactor;
    }
    getPreRotation() {
      return this.preRotation;
    }
    getTranslation() {
      return this.translation;
    }
    getPostRotation() {
      return this.postRotation;
    }
    getReflectY() {
      return this.reflectY === -1;
    }
    setCenter(point) {
      this.center.set(point);
      this.updateCenterTranslation();
      return this;
    }
    setScaleFactor(factor) {
      this.scaleFactor = factor;
      return this;
    }
    setPreRotation(vec) {
      this.preRotation.set(vec);
      this.updatePreRotationTransforms();
      this.updateCenterTranslation();
      return this;
    }
    setTranslation(vec) {
      this.translation.set(vec);
      return this;
    }
    setPostRotation(rotation) {
      this.postRotation = rotation;
      this.rotationCos = Math.cos(rotation);
      this.rotationSin = Math.sin(rotation);
      return this;
    }
    setReflectY(val) {
      this.reflectY = val ? -1 : 1;
      return this;
    }
    copyParametersFrom(other) {
      return this.setCenter(other.getCenter()).setPreRotation(other.getPreRotation()).setScaleFactor(other.getScaleFactor()).setTranslation(other.getTranslation()).setPostRotation(other.getPostRotation()).setReflectY(other.getReflectY());
    }
    updatePreRotationTransforms() {
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      this.rotationCache[0].toRotationX(gamma);
      this.rotationCache[1].toRotationY(-phi);
      Transform3D.concat(this.preRotationForwardTransform, this.rotationCache);
      this.preRotationReverseTransform.set(this.preRotationForwardTransform);
      this.preRotationReverseTransform.invert();
    }
    updateCenterTranslation() {
      const centerArray = AbstractGeoProjection.vec2Cache[0];
      centerArray[0] = this.center.lon;
      centerArray[1] = this.center.lat;
      this.preRotateForward(centerArray, centerArray);
      this.projectRaw(centerArray, this.centerTranslation);
    }
    preRotateForward(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      if (phi === 0 && gamma === 0) {
        return Vec2Math.set(rotatedLon, lat, out);
      }
      const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
      const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
      const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
      return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    preRotateReverse(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      let rotatedLat = lat;
      let rotatedLon = lon;
      if (phi !== 0 || gamma !== 0) {
        const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
        const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
        rotatedLat = unrotated.lat;
        rotatedLon = unrotated.lon;
      }
      rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    project(point, out) {
      if (point instanceof Float64Array) {
        out.set(point);
      } else {
        out[0] = point.lon;
        out[1] = point.lat;
      }
      this.preRotateForward(out, out);
      this.projectRaw(out, out);
      out[0] -= this.centerTranslation[0];
      out[1] -= this.centerTranslation[1];
      out[1] *= this.reflectY;
      out[0] *= this.scaleFactor;
      out[1] *= this.scaleFactor;
      const x = out[0];
      const y = out[1];
      out[0] = x * this.rotationCos - y * this.rotationSin;
      out[1] = x * this.rotationSin + y * this.rotationCos;
      out[0] += this.translation[0];
      out[1] += this.translation[1];
      return out;
    }
    invert(vec, out) {
      const projected = AbstractGeoProjection.vec2Cache[0];
      projected.set(vec);
      projected[0] -= this.translation[0];
      projected[1] -= this.translation[1];
      const x = projected[0];
      const y = projected[1];
      projected[0] = x * this.rotationCos + y * this.rotationSin;
      projected[1] = -x * this.rotationSin + y * this.rotationCos;
      projected[0] /= this.scaleFactor;
      projected[1] /= this.scaleFactor;
      projected[1] *= this.reflectY;
      projected[0] += this.centerTranslation[0];
      projected[1] += this.centerTranslation[1];
      const inverted = this.invertRaw(projected, projected);
      this.preRotateReverse(inverted, inverted);
      if (out instanceof Float64Array) {
        out.set(inverted);
        return out;
      } else {
        return out.set(inverted[1], inverted[0]);
      }
    }
  };
  AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
  AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
  AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
  var MercatorProjection = class extends AbstractGeoProjection {
    projectRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.DEG2RAD;
      out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
      return out;
    }
    invertRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.RAD2DEG;
      out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
      return out;
    }
  };
  var GeoCircleResampler = class {
    constructor(minDistance, dpTolerance, maxDepth) {
      this.minDistance = minDistance;
      this.dpTolerance = dpTolerance;
      this.maxDepth = maxDepth;
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.startVector = {
        type: "start",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.lineVector = {
        type: "line",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.arcVector = {
        type: "arc",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        projectedArcCenter: new Float64Array(2),
        projectedArcRadius: 0,
        projectedArcStartAngle: 0,
        projectedArcEndAngle: 0,
        index: 0
      };
      this.state = {
        index: 0,
        prevX: 0,
        prevY: 0,
        vectorType: "line",
        arcCenterX: 0,
        arcCenterY: 0,
        arcRadius: 0,
        isArcCounterClockwise: false
      };
      this.cosMinDistance = Math.cos(minDistance);
      this.dpTolSq = dpTolerance * dpTolerance;
    }
    resample(projection, circle, start, end, handler) {
      let startPoint, startVec, endPoint, endVec;
      if (start instanceof Float64Array) {
        startPoint = this.geoPointCache[0].setFromCartesian(start);
        startVec = start;
      } else {
        startPoint = start;
        startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
      }
      if (end instanceof Float64Array) {
        endPoint = this.geoPointCache[0].setFromCartesian(end);
        endVec = end;
      } else {
        endPoint = end;
        endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
      }
      const startLat = startPoint.lat;
      const startLon = startPoint.lon;
      const endLat = endPoint.lat;
      const endLon = endPoint.lon;
      const startProjected = projection.project(start, this.vec2Cache[0]);
      const endProjected = projection.project(end, this.vec2Cache[1]);
      const startX = startProjected[0];
      const startY = startProjected[1];
      const endX = endProjected[0];
      const endY = endProjected[1];
      this.startVector.point.set(startLat, startLon);
      Vec2Math.copy(startProjected, this.startVector.projected);
      handler(this.startVector);
      this.state.index = 1;
      this.state.prevX = startX;
      this.state.prevY = startY;
      this.state.vectorType = "line";
      const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
      this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
      if (depth >= this.maxDepth) {
        return state;
      }
      const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
      const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
      const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
      if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
        return state;
      }
      const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
      const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
      const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
      const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
      const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
      const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
      const midProjected = projection.project(midPoint, this.vec2Cache[2]);
      const lat0 = midPoint.lat;
      const lon0 = midPoint.lon;
      const x0 = midVec[0];
      const y0 = midVec[1];
      const z0 = midVec[2];
      const projX0 = midProjected[0];
      const projY0 = midProjected[1];
      const A = projX2 - projX1;
      const B = projY2 - projY1;
      const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
      const D = projX0 - projX1;
      const E = projY0 - projY1;
      const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
      const det = 2 * (A * E - B * D);
      const dpDisSq = det * det / 4 / deltaProjectedDot;
      if (dpDisSq > this.dpTolSq) {
        const arcCenterX = (B * F - C * E) / det;
        const arcCenterY = (C * D - A * F) / det;
        const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
        const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
        const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
        const cross = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
        state.vectorType = "arc";
        state.arcCenterX = arcCenterX;
        state.arcCenterY = arcCenterY;
        state.arcRadius = arcRadius;
        state.isArcCounterClockwise = cross[2] > 0;
      } else {
        state.vectorType = "line";
      }
      const cosDistance = Vec3Math.dot(startVec, midVec);
      if (cosDistance > this.cosMinDistance) {
        if (state.vectorType === "line") {
          return state;
        }
        const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
        const projectedQuery = projection.project(query, this.vec2Cache[0]);
        let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
        if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
          circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
          projection.project(query, projectedQuery);
          distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
          if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
            return state;
          }
        }
      }
      state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
      this.callHandler(handler, lat0, lon0, projX0, projY0, state);
      state.index++;
      state.prevX = projX0;
      state.prevY = projY0;
      return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    callHandler(handler, lat, lon, projX, projY, state) {
      let vector;
      if (state.vectorType === "line") {
        vector = this.lineVector;
      } else {
        vector = this.arcVector;
        Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
        vector.projectedArcRadius = state.arcRadius;
        vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
        vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
        if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
          vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils.TWO_PI : MathUtils.TWO_PI;
        }
      }
      vector.point.set(lat, lon);
      Vec2Math.set(projX, projY, vector.projected);
      vector.index = state.index;
      handler(vector);
    }
  };
  var NavAngleUnitReferenceNorth;
  (function(NavAngleUnitReferenceNorth2) {
    NavAngleUnitReferenceNorth2["True"] = "true";
    NavAngleUnitReferenceNorth2["Magnetic"] = "magnetic";
  })(NavAngleUnitReferenceNorth || (NavAngleUnitReferenceNorth = {}));
  var BasicNavAngleUnit = class extends AbstractUnit {
    constructor(referenceNorth, magVar) {
      super(referenceNorth === NavAngleUnitReferenceNorth.True ? "true bearing" : "magnetic bearing");
      this.family = "navangle";
      this._magVar = 0;
      this._magVar = magVar;
    }
    get magVar() {
      return this._magVar;
    }
    isMagnetic() {
      return this.name === "magnetic bearing";
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === toUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.magneticToTrue(value, this.magVar) : MagVar.trueToMagnetic(value, this.magVar);
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === fromUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.trueToMagnetic(value, this.magVar) : MagVar.magneticToTrue(value, this.magVar);
    }
    setMagVar(magVar) {
      this._magVar = magVar;
    }
    setMagVarFromLocation(arg1, arg2) {
      if (typeof arg1 === "number") {
        this._magVar = MagVar.get(arg1, arg2);
      } else {
        this._magVar = MagVar.get(arg1);
      }
    }
    equals(other) {
      return other instanceof BasicNavAngleUnit && this.name === other.name && this.magVar === other.magVar;
    }
    static create(isMagnetic, arg2, arg3) {
      const referenceNorth = isMagnetic ? NavAngleUnitReferenceNorth.Magnetic : NavAngleUnitReferenceNorth.True;
      let magVar = 0;
      if (arg2 !== void 0) {
        if (typeof arg2 === "number") {
          if (arg3 === void 0) {
            magVar = arg2;
          } else {
            magVar = MagVar.get(arg2, arg3);
          }
        } else {
          magVar = MagVar.get(arg2);
        }
      }
      return new BasicNavAngleUnit(referenceNorth, magVar);
    }
  };
  var BasicNavAngleSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new BasicNavAngleSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2, arg3) {
      const isArg1Number = typeof arg1 === "number";
      const isArg2Number = typeof arg2 === "number";
      const isArg2LatLon = typeof arg2 === "object" && "lat" in arg2 && "lon" in arg2;
      const unit = isArg1Number ? isArg2Number || isArg2LatLon || arg2 === void 0 ? this.value.unit : arg2 : arg1.unit;
      const oldMagVar = this.value.unit.magVar;
      const oldValue = this.value.number;
      if (isArg2LatLon) {
        this.value.unit.setMagVarFromLocation(arg2);
      } else if (isArg2Number) {
        if (typeof arg3 === "number") {
          this.value.unit.setMagVarFromLocation(arg2, arg3);
        } else {
          this.value.unit.setMagVar(arg2);
        }
      } else {
        this.value.unit.setMagVar(unit.magVar);
      }
      if (isArg1Number) {
        this.value.set(arg1, unit);
      } else {
        this.value.set(arg1);
      }
      if (!(isNaN(oldMagVar) && isNaN(this.value.unit.magVar)) && oldMagVar !== this.value.unit.magVar || !(isNaN(oldValue) && isNaN(this.value.number)) && oldValue !== this.value.number) {
        this.notify();
      }
    }
  };
  BasicNavAngleSubject.TRUE_BEARING = BasicNavAngleUnit.create(false);
  var AntiIcePublisher = class extends SimVarPublisher {
    constructor(bus, pacer) {
      const engineIndexedSimVars = [
        ["anti_ice_engine_switch_on", { name: "ENG ANTI ICE", type: SimVarValueType.Bool }],
        ["anti_ice_prop_switch_on", { name: "PROP DEICE SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(AntiIcePublisher.nonIndexedSimVars);
      const engineCount = SimVar.GetSimVarValue("NUMBER OF ENGINES", SimVarValueType.Number);
      for (const [topic, simvar2] of engineIndexedSimVars) {
        for (let i = 1; i <= engineCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  AntiIcePublisher.nonIndexedSimVars = [
    ["anti_ice_structural_switch_on", { name: "STRUCTURAL DEICE SWITCH", type: SimVarValueType.Bool }],
    ["anti_ice_windshield_switch_on", { name: "WINDSHIELD DEICE SWITCH", type: SimVarValueType.Bool }]
  ];
  var BasicConsumer = class {
    constructor(subscribe, state = {}, currentHandler) {
      this.subscribe = subscribe;
      this.state = state;
      this.currentHandler = currentHandler;
      this.isConsumer = true;
      this.activeSubs = /* @__PURE__ */ new Map();
    }
    handle(handler, paused = false) {
      let activeHandler;
      if (this.currentHandler !== void 0) {
        activeHandler = (data) => {
          this.currentHandler(data, this.state, handler);
        };
      } else {
        activeHandler = handler;
      }
      let activeSubArray = this.activeSubs.get(handler);
      if (!activeSubArray) {
        activeSubArray = [];
        this.activeSubs.set(handler, activeSubArray);
      }
      const onDestroyed = (destroyed) => {
        const activeSubsArray = this.activeSubs.get(handler);
        if (activeSubsArray) {
          activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
          if (activeSubsArray.length === 0) {
            this.activeSubs.delete(handler);
          }
        }
      };
      const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
      if (sub.isAlive) {
        activeSubArray.push(sub);
      } else if (activeSubArray.length === 0) {
        this.activeSubs.delete(handler);
      }
      return sub;
    }
    off(handler) {
      var _a;
      const activeSubArray = this.activeSubs.get(handler);
      if (activeSubArray) {
        (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
        if (activeSubArray.length === 0) {
          this.activeSubs.delete(handler);
        }
      }
    }
    atFrequency(frequency, immediateFirstPublish = true) {
      const initialState = {
        previousTime: Date.now(),
        firstRun: immediateFirstPublish
      };
      return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    getAtFrequencyHandler(frequency) {
      const deltaTimeTrigger = 1e3 / frequency;
      return (data, state, next) => {
        const currentTime = Date.now();
        const deltaTime = currentTime - state.previousTime;
        if (deltaTimeTrigger <= deltaTime || state.firstRun) {
          while (state.previousTime + deltaTimeTrigger < currentTime) {
            state.previousTime += deltaTimeTrigger;
          }
          if (state.firstRun) {
            state.firstRun = false;
          }
          this.with(data, next);
        }
      };
    }
    withPrecision(precision) {
      return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    getWithPrecisionHandler(precision) {
      return (data, state, next) => {
        const dataValue = data;
        const multiplier = Math.pow(10, precision);
        const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
        if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
          state.hasLastValue = true;
          state.lastValue = currentValueAtPrecision;
          this.with(currentValueAtPrecision, next);
        }
      };
    }
    whenChangedBy(amount) {
      return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    getWhenChangedByHandler(amount) {
      return (data, state, next) => {
        const dataValue = data;
        const diff = Math.abs(dataValue - state.lastValue);
        if (!state.hasLastValue || diff >= amount) {
          state.hasLastValue = true;
          state.lastValue = dataValue;
          this.with(data, next);
        }
      };
    }
    whenChanged() {
      return new BasicConsumer(this.subscribe, { lastValue: "", hasLastValue: false }, this.getWhenChangedHandler());
    }
    getWhenChangedHandler() {
      return (data, state, next) => {
        if (!state.hasLastValue || state.lastValue !== data) {
          state.hasLastValue = true;
          state.lastValue = data;
          this.with(data, next);
        }
      };
    }
    onlyAfter(deltaTime) {
      return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    getOnlyAfterHandler(deltaTime) {
      return (data, state, next) => {
        const currentTime = Date.now();
        const timeDiff = currentTime - state.previousTime;
        if (timeDiff > deltaTime) {
          state.previousTime += deltaTime;
          this.with(data, next);
        }
      };
    }
    with(data, handler) {
      if (this.currentHandler !== void 0) {
        this.currentHandler(data, this.state, handler);
      } else {
        handler(data);
      }
    }
  };
  var ConsumerSubscription = class {
    constructor(sub, onDestroy) {
      this.sub = sub;
      this.onDestroy = onDestroy;
    }
    get isAlive() {
      return this.sub.isAlive;
    }
    get isPaused() {
      return this.sub.isPaused;
    }
    get canInitialNotify() {
      return this.sub.canInitialNotify;
    }
    pause() {
      this.sub.pause();
      return this;
    }
    resume(initialNotify = false) {
      this.sub.resume(initialNotify);
      return this;
    }
    destroy() {
      this.sub.destroy();
      this.onDestroy(this);
    }
  };
  var EventSubscriber = class {
    constructor(bus) {
      this.bus = bus;
    }
    on(topic) {
      return new BasicConsumer((handler, paused) => {
        return this.bus.on(topic, handler, paused);
      });
    }
  };
  var APLockType;
  (function(APLockType2) {
    APLockType2[APLockType2["Heading"] = 0] = "Heading";
    APLockType2[APLockType2["Nav"] = 1] = "Nav";
    APLockType2[APLockType2["Alt"] = 2] = "Alt";
    APLockType2[APLockType2["Bank"] = 3] = "Bank";
    APLockType2[APLockType2["WingLevel"] = 4] = "WingLevel";
    APLockType2[APLockType2["Vs"] = 5] = "Vs";
    APLockType2[APLockType2["Flc"] = 6] = "Flc";
    APLockType2[APLockType2["Pitch"] = 7] = "Pitch";
    APLockType2[APLockType2["Approach"] = 8] = "Approach";
    APLockType2[APLockType2["Backcourse"] = 9] = "Backcourse";
    APLockType2[APLockType2["Glideslope"] = 10] = "Glideslope";
    APLockType2[APLockType2["VNav"] = 11] = "VNav";
  })(APLockType || (APLockType = {}));
  var APSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(APSimVarPublisher.simvars, bus, pacer);
    }
  };
  APSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["ap_heading_selected", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_1", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_2", { name: "AUTOPILOT HEADING LOCK DIR:2", type: SimVarValueType.Degree }],
    ["ap_heading_selected_3", { name: "AUTOPILOT HEADING LOCK DIR:3", type: SimVarValueType.Degree }],
    ["ap_altitude_selected", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_1", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_2", { name: "AUTOPILOT ALTITUDE LOCK VAR:2", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_3", { name: "AUTOPILOT ALTITUDE LOCK VAR:3", type: SimVarValueType.Feet }],
    ["ap_master_status", { name: "AUTOPILOT MASTER", type: SimVarValueType.Bool }],
    ["ap_yd_status", { name: "AUTOPILOT YAW DAMPER", type: SimVarValueType.Bool }],
    ["ap_heading_hold", { name: "AUTOPILOT HEADING LOCK", type: SimVarValueType.Bool }],
    ["ap_nav_hold", { name: "AUTOPILOT NAV1 LOCK", type: SimVarValueType.Bool }],
    ["ap_bank_hold", { name: "AUTOPILOT BANK HOLD", type: SimVarValueType.Bool }],
    ["ap_max_bank_id", { name: "AUTOPILOT MAX BANK ID", type: SimVarValueType.Number }],
    ["ap_max_bank_value", { name: "AUTOPILOT MAX BANK", type: SimVarValueType.Degree }],
    ["ap_wing_lvl_hold", { name: "AUTOPILOT WING LEVELER", type: SimVarValueType.Bool }],
    ["ap_approach_hold", { name: "AUTOPILOT APPROACH HOLD", type: SimVarValueType.Bool }],
    ["ap_backcourse_hold", { name: "AUTOPILOT BACKCOURSE HOLD", type: SimVarValueType.Bool }],
    ["ap_vs_hold", { name: "AUTOPILOT VERTICAL HOLD", type: SimVarValueType.Bool }],
    ["ap_flc_hold", { name: "AUTOPILOT FLIGHT LEVEL CHANGE", type: SimVarValueType.Bool }],
    ["ap_alt_hold", { name: "AUTOPILOT ALTITUDE LOCK", type: SimVarValueType.Bool }],
    ["ap_glideslope_hold", { name: "AUTOPILOT GLIDESLOPE HOLD", type: SimVarValueType.Bool }],
    ["ap_pitch_hold", { name: "AUTOPILOT PITCH HOLD", type: SimVarValueType.Bool }],
    ["ap_toga_hold", { name: "AUTOPILOT TAKEOFF POWER ACTIVE", type: SimVarValueType.Bool }],
    ["ap_vs_selected", { name: "AUTOPILOT VERTICAL HOLD VAR:1", type: SimVarValueType.FPM }],
    ["ap_fpa_selected", { name: "L:WT_AP_FPA_Target:1", type: SimVarValueType.Degree }],
    ["ap_ias_selected", { name: "AUTOPILOT AIRSPEED HOLD VAR", type: SimVarValueType.Knots }],
    ["ap_mach_selected", { name: "AUTOPILOT MACH HOLD VAR", type: SimVarValueType.Number }],
    ["ap_selected_speed_is_mach", { name: "AUTOPILOT MANAGED SPEED IN MACH", type: SimVarValueType.Bool }],
    ["ap_selected_speed_is_manual", { name: "L:XMLVAR_SpeedIsManuallySet", type: SimVarValueType.Bool }],
    ["flight_director_bank", { name: "AUTOPILOT FLIGHT DIRECTOR BANK", type: SimVarValueType.Degree }],
    ["flight_director_pitch", { name: "AUTOPILOT FLIGHT DIRECTOR PITCH", type: SimVarValueType.Degree }],
    ["flight_director_is_active_1", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:1", type: SimVarValueType.Bool }],
    ["flight_director_is_active_2", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:2", type: SimVarValueType.Bool }],
    ["vnav_active", { name: "L:XMLVAR_VNAVButtonValue", type: SimVarValueType.Bool }],
    ["ap_pitch_selected", { name: "AUTOPILOT PITCH HOLD REF", type: SimVarValueType.Degree }]
  ]);
  var RadioUtils = class {
    static isNavFrequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 108e3 || freqKhz > 117950) {
        return false;
      }
      return freqKhz % 50 === 0;
    }
    static isLocalizerFrequency(freq) {
      return freq >= 108.1 && freq <= 111.95 && Math.trunc(freq * 10) % 2 === 1;
    }
    static isCom833Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136990) {
        return false;
      }
      return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    static isCom25Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136975) {
        return false;
      }
      return freqKhz % 25 === 0;
    }
    static isAdfFrequency(freq) {
      const freqHz = Math.round(freq * 1e3);
      if (freqHz < 19e4 || freqHz > 1799500) {
        return false;
      }
      return freqHz % 500 === 0;
    }
  };
  RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];
  var RadioType;
  (function(RadioType2) {
    RadioType2["Com"] = "COM";
    RadioType2["Nav"] = "NAV";
    RadioType2["Adf"] = "ADF";
  })(RadioType || (RadioType = {}));
  var FrequencyBank;
  (function(FrequencyBank2) {
    FrequencyBank2[FrequencyBank2["Active"] = 0] = "Active";
    FrequencyBank2[FrequencyBank2["Standby"] = 1] = "Standby";
  })(FrequencyBank || (FrequencyBank = {}));
  var ComSpacing;
  (function(ComSpacing2) {
    ComSpacing2[ComSpacing2["Spacing25Khz"] = 0] = "Spacing25Khz";
    ComSpacing2[ComSpacing2["Spacing833Khz"] = 1] = "Spacing833Khz";
  })(ComSpacing || (ComSpacing = {}));
  var NavProcSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    static createNavRadioDefinitions(index) {
      return [
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
        [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
        [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
        [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
        [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
        [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
        [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
        [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
        [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
        [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
        [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
        [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
      ];
    }
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
      ];
    }
  };
  NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ["gps_dtk", { name: "GPS WP DESIRED TRACK", type: SimVarValueType.Degree }],
    ["gps_xtk", { name: "GPS WP CROSS TRK", type: SimVarValueType.NM }],
    ["gps_wp", { name: "GPS WP NEXT ID", type: SimVarValueType.NM }],
    ["gps_wp_bearing", { name: "GPS WP BEARING", type: SimVarValueType.String }],
    ["gps_wp_distance", { name: "GPS WP DISTANCE", type: SimVarValueType.NM }],
    ["mkr_bcn_state_simvar", { name: "MARKER BEACON STATE", type: SimVarValueType.Number }],
    ["gps_obs_active_simvar", { name: "GPS OBS ACTIVE", type: SimVarValueType.Bool }],
    ["gps_obs_value_simvar", { name: "GPS OBS VALUE", type: SimVarValueType.Degree }]
  ]);
  var NavSourceType;
  (function(NavSourceType2) {
    NavSourceType2[NavSourceType2["Nav"] = 0] = "Nav";
    NavSourceType2[NavSourceType2["Gps"] = 1] = "Gps";
    NavSourceType2[NavSourceType2["Adf"] = 2] = "Adf";
  })(NavSourceType || (NavSourceType = {}));
  var VorToFrom;
  (function(VorToFrom2) {
    VorToFrom2[VorToFrom2["OFF"] = 0] = "OFF";
    VorToFrom2[VorToFrom2["TO"] = 1] = "TO";
    VorToFrom2[VorToFrom2["FROM"] = 2] = "FROM";
  })(VorToFrom || (VorToFrom = {}));
  var MarkerBeaconState;
  (function(MarkerBeaconState2) {
    MarkerBeaconState2[MarkerBeaconState2["Inactive"] = 0] = "Inactive";
    MarkerBeaconState2[MarkerBeaconState2["Outer"] = 1] = "Outer";
    MarkerBeaconState2[MarkerBeaconState2["Middle"] = 2] = "Middle";
    MarkerBeaconState2[MarkerBeaconState2["Inner"] = 3] = "Inner";
  })(MarkerBeaconState || (MarkerBeaconState = {}));
  var EventBus = class {
    constructor(useAlternativeEventSync = false, shouldResync = true) {
      this._topicSubsMap = /* @__PURE__ */ new Map();
      this._wildcardSubs = new Array();
      this._notifyDepthMap = /* @__PURE__ */ new Map();
      this._wildcardNotifyDepth = 0;
      this._eventCache = /* @__PURE__ */ new Map();
      this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
      this._busId = Math.floor(Math.random() * 2147483647);
      useAlternativeEventSync = typeof RegisterGenericDataListener === "undefined";
      const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
      this._busSync = new syncFunc(this.pub.bind(this), this._busId);
      if (shouldResync === true) {
        this.syncEvent("event_bus", "resync_request", false);
        this.on("event_bus", (data) => {
          if (data == "resync_request") {
            this.resyncEvents();
          }
        });
      }
    }
    on(topic, handler, paused = false) {
      let subs = this._topicSubsMap.get(topic);
      if (subs === void 0) {
        this._topicSubsMap.set(topic, subs = []);
        this.pub("event_bus_topic_first_sub", topic, false, false);
      }
      const initialNotifyFunc = (sub2) => {
        const lastState = this._eventCache.get(topic);
        if (lastState !== void 0) {
          sub2.handler(lastState.data);
        }
      };
      const onDestroyFunc = (sub2) => {
        var _a;
        if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
          const subsToSplice = this._topicSubsMap.get(topic);
          if (subsToSplice) {
            subsToSplice.splice(subsToSplice.indexOf(sub2), 1);
          }
        }
      };
      const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
      subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
    off(topic, handler) {
      const handlers2 = this._topicSubsMap.get(topic);
      const toDestroy = handlers2 === null || handlers2 === void 0 ? void 0 : handlers2.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    onAll(handler) {
      const sub = new HandlerSubscription(handler, void 0, this.onWildcardSubDestroyedFunc);
      this._wildcardSubs.push(sub);
      return sub;
    }
    offAll(handler) {
      const toDestroy = this._wildcardSubs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    pub(topic, data, sync = false, isCached = true) {
      var _a;
      if (isCached) {
        this._eventCache.set(topic, { data, synced: sync });
      }
      const subs = this._topicSubsMap.get(topic);
      if (subs !== void 0) {
        let needCleanUpSubs2 = false;
        const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
        this._notifyDepthMap.set(topic, notifyDepth + 1);
        const len = subs.length;
        for (let i = 0; i < len; i++) {
          try {
            const sub = subs[i];
            if (sub.isAlive && !sub.isPaused) {
              sub.handler(data);
            }
            needCleanUpSubs2 || (needCleanUpSubs2 = !sub.isAlive);
          } catch (error) {
            console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
            if (error instanceof Error) {
              console.error(error.stack);
            }
          }
        }
        this._notifyDepthMap.set(topic, notifyDepth);
        if (needCleanUpSubs2 && notifyDepth === 0) {
          const filteredSubs = subs.filter((sub) => sub.isAlive);
          this._topicSubsMap.set(topic, filteredSubs);
        }
      }
      if (sync) {
        this.syncEvent(topic, data, isCached);
      }
      let needCleanUpSubs = false;
      this._wildcardNotifyDepth++;
      const wcLen = this._wildcardSubs.length;
      for (let i = 0; i < wcLen; i++) {
        const sub = this._wildcardSubs[i];
        if (sub.isAlive && !sub.isPaused) {
          sub.handler(topic, data);
        }
        needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
      }
      this._wildcardNotifyDepth--;
      if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
        this._wildcardSubs = this._wildcardSubs.filter((sub) => sub.isAlive);
      }
    }
    onWildcardSubDestroyed(sub) {
      if (this._wildcardNotifyDepth === 0) {
        this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
      }
    }
    resyncEvents() {
      for (const [topic, event] of this._eventCache) {
        if (event.synced) {
          this.syncEvent(topic, event.data, true);
        }
      }
    }
    syncEvent(topic, data, isCached) {
      this._busSync.sendEvent(topic, data, isCached);
    }
    getPublisher() {
      return this;
    }
    getSubscriber() {
      return new EventSubscriber(this);
    }
    getTopicSubscriberCount(topic) {
      var _a, _b;
      return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    forEachSubscribedTopic(fn) {
      this._topicSubsMap.forEach((subs, topic) => {
        subs.length > 0 && fn(topic, subs.length);
      });
    }
  };
  var EventBusSyncBase = class {
    constructor(recvEventCb, busId) {
      this.isPaused = false;
      this.lastEventSynced = -1;
      this.dataPackageQueue = [];
      this.recvEventCb = recvEventCb;
      this.busId = busId;
      this.hookReceiveEvent();
      const sendFn = () => {
        if (!this.isPaused && this.dataPackageQueue.length > 0) {
          const syncDataPackage = {
            busId: this.busId,
            packagedId: Math.floor(Math.random() * 1e9),
            data: this.dataPackageQueue
          };
          if (this.executeSync(syncDataPackage)) {
            this.dataPackageQueue.length = 0;
          } else {
            console.warn("Failed to send sync data package");
          }
        }
        requestAnimationFrame(sendFn);
      };
      requestAnimationFrame(sendFn);
    }
    processEventsReceived(syncData) {
      if (this.busId !== syncData.busId) {
        if (this.lastEventSynced !== syncData.packagedId) {
          this.lastEventSynced = syncData.packagedId;
          syncData.data.forEach((data) => {
            try {
              this.recvEventCb(data.topic, data.data !== void 0 ? data.data : void 0, false, data.isCached);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          });
        }
      }
    }
    sendEvent(topic, data, isCached) {
      const dataObj = data;
      const dataPackage = {
        topic,
        data: dataObj,
        isCached
      };
      this.dataPackageQueue.push(dataPackage);
    }
  };
  var EventBusCoherentSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, void 0, true);
      this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
        try {
          const evt = JSON.parse(e);
          this.processEventsReceived(evt);
        } catch (error) {
          console.error(error);
        }
      });
    }
  };
  EventBusCoherentSync.EB_KEY = "eb.evt";
  EventBusCoherentSync.EB_LISTENER_KEY = "JS_LISTENER_SIMVARS";
  var EventBusFlowEventSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        LaunchFlowEvent("ON_MOUSERECT_HTMLEVENT", EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      Coherent.on("OnInteractionEvent", (target, args) => {
        if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
          return;
        }
        this.processEventsReceived(JSON.parse(args[2]));
      });
    }
  };
  EventBusFlowEventSync.EB_LISTENER_KEY = "EB_EVENTS";
  var EventBusListenerSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      this.isPaused = true;
      this.listener = RegisterGenericDataListener(() => {
        this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
          try {
            this.processEventsReceived(data);
          } catch (error) {
            console.error(error);
          }
        });
        this.isPaused = false;
      });
    }
  };
  EventBusListenerSync.EB_KEY = "wt.eb.evt";
  EventBusListenerSync.EB_LISTENER_KEY = "JS_LISTENER_GENERICDATA";
  var ConsumerValue = class {
    constructor(consumer, initialValue) {
      this.consumerHandler = (v) => {
        this.value = v;
      };
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialValue;
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    get isPaused() {
      return this._isPaused;
    }
    get() {
      return this.value;
    }
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    destroy() {
      var _a;
      this.isDestroyed = true;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    static create(consumer, initialValue) {
      return new ConsumerValue(consumer, initialValue);
    }
  };
  var ConsumerSubject = class extends AbstractSubscribable {
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
      super();
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.consumerHandler = this.onEventConsumed.bind(this);
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialVal;
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    get isPaused() {
      return this._isPaused;
    }
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
      return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    onEventConsumed(value) {
      if (!this.equalityFunc(this.value, value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    get() {
      return this.value;
    }
    destroy() {
      var _a;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.isDestroyed = true;
    }
  };
  var CompositeLogicXMLValueType;
  (function(CompositeLogicXMLValueType2) {
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Any"] = 0] = "Any";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Number"] = 1] = "Number";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["String"] = 2] = "String";
  })(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
  var DataStore;
  (function(DataStore2) {
    function set(key, value) {
      SetStoredData(key, JSON.stringify(value));
    }
    DataStore2.set = set;
    function get(key) {
      try {
        const string = GetStoredData(key);
        return JSON.parse(string);
      } catch (e) {
        return void 0;
      }
    }
    DataStore2.get = get;
    function remove(key) {
      DeleteStoredData(key);
    }
    DataStore2.remove = remove;
  })(DataStore || (DataStore = {}));
  var GameStateProvider = class {
    constructor() {
      this.gameState = Subject.create(void 0);
      window.document.addEventListener("OnVCockpitPanelAttributesChanged", this.onAttributesChanged.bind(this));
      this.onAttributesChanged();
    }
    onAttributesChanged() {
      var _a;
      if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute("gamestate")) {
        const attribute = window.parent.document.body.getAttribute("gamestate");
        if (attribute !== null) {
          this.gameState.set(GameState[attribute]);
          return;
        }
      }
      this.gameState.set(void 0);
    }
    static get() {
      var _a;
      return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : GameStateProvider.INSTANCE = new GameStateProvider()).gameState;
    }
  };
  var KeyEventManager = class {
    constructor(keyListener, bus) {
      this.keyListener = keyListener;
      this.bus = bus;
      Coherent.on("keyIntercepted", this.onKeyIntercepted.bind(this));
    }
    onKeyIntercepted(key, value1, value0, value2) {
      if (value0 !== void 0 && value0 >= 2147483648) {
        value0 -= 4294967296;
      }
      this.bus.pub("key_intercept", { key, value0, value1, value2 }, false, false);
    }
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
      return Coherent.call("TRIGGER_KEY_EVENT", key, bypass, value0, value1, value2);
    }
    interceptKey(key, passThrough) {
      Coherent.call("INTERCEPT_KEY_EVENT", key, passThrough ? 0 : 1);
    }
    static getManager(bus) {
      if (KeyEventManager.INSTANCE) {
        return Promise.resolve(KeyEventManager.INSTANCE);
      }
      if (!KeyEventManager.isCreatingInstance) {
        KeyEventManager.createInstance(bus);
      }
      return new Promise((resolve) => {
        KeyEventManager.pendingPromiseResolves.push(resolve);
      });
    }
    static async createInstance(bus) {
      KeyEventManager.isCreatingInstance = true;
      KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
      KeyEventManager.isCreatingInstance = false;
      for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
        KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
      }
    }
    static create(bus) {
      return new Promise((resolve, reject) => {
        const gameState = GameStateProvider.get();
        const sub = gameState.sub((state) => {
          if (window["IsDestroying"]) {
            sub.destroy();
            reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            sub.destroy();
            const keyListener = RegisterViewListener("JS_LISTENER_KEYEVENT", () => {
              if (window["IsDestroying"]) {
                reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
                return;
              }
              resolve(new KeyEventManager(keyListener, bus));
            });
          }
        }, false, true);
        sub.resume(true);
      });
    }
  };
  KeyEventManager.isCreatingInstance = false;
  KeyEventManager.pendingPromiseResolves = [];
  var FacilityFrequencyType;
  (function(FacilityFrequencyType2) {
    FacilityFrequencyType2[FacilityFrequencyType2["None"] = 0] = "None";
    FacilityFrequencyType2[FacilityFrequencyType2["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType2[FacilityFrequencyType2["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType2[FacilityFrequencyType2["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType2[FacilityFrequencyType2["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType2[FacilityFrequencyType2["Ground"] = 5] = "Ground";
    FacilityFrequencyType2[FacilityFrequencyType2["Tower"] = 6] = "Tower";
    FacilityFrequencyType2[FacilityFrequencyType2["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType2[FacilityFrequencyType2["Approach"] = 8] = "Approach";
    FacilityFrequencyType2[FacilityFrequencyType2["Departure"] = 9] = "Departure";
    FacilityFrequencyType2[FacilityFrequencyType2["Center"] = 10] = "Center";
    FacilityFrequencyType2[FacilityFrequencyType2["FSS"] = 11] = "FSS";
    FacilityFrequencyType2[FacilityFrequencyType2["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType2[FacilityFrequencyType2["ASOS"] = 13] = "ASOS";
    FacilityFrequencyType2[FacilityFrequencyType2["CPT"] = 14] = "CPT";
    FacilityFrequencyType2[FacilityFrequencyType2["GCO"] = 15] = "GCO";
  })(FacilityFrequencyType || (FacilityFrequencyType = {}));
  var AdditionalApproachType;
  (function(AdditionalApproachType2) {
    AdditionalApproachType2[AdditionalApproachType2["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
  })(AdditionalApproachType || (AdditionalApproachType = {}));
  var FixTypeFlags;
  (function(FixTypeFlags2) {
    FixTypeFlags2[FixTypeFlags2["None"] = 0] = "None";
    FixTypeFlags2[FixTypeFlags2["IAF"] = 1] = "IAF";
    FixTypeFlags2[FixTypeFlags2["IF"] = 2] = "IF";
    FixTypeFlags2[FixTypeFlags2["MAP"] = 4] = "MAP";
    FixTypeFlags2[FixTypeFlags2["FAF"] = 8] = "FAF";
    FixTypeFlags2[FixTypeFlags2["MAHP"] = 16] = "MAHP";
  })(FixTypeFlags || (FixTypeFlags = {}));
  var RnavTypeFlags;
  (function(RnavTypeFlags2) {
    RnavTypeFlags2[RnavTypeFlags2["None"] = 0] = "None";
    RnavTypeFlags2[RnavTypeFlags2["LNAV"] = 1] = "LNAV";
    RnavTypeFlags2[RnavTypeFlags2["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags2[RnavTypeFlags2["LP"] = 4] = "LP";
    RnavTypeFlags2[RnavTypeFlags2["LPV"] = 8] = "LPV";
  })(RnavTypeFlags || (RnavTypeFlags = {}));
  var AirportClass;
  (function(AirportClass2) {
    AirportClass2[AirportClass2["None"] = 0] = "None";
    AirportClass2[AirportClass2["HardSurface"] = 1] = "HardSurface";
    AirportClass2[AirportClass2["SoftSurface"] = 2] = "SoftSurface";
    AirportClass2[AirportClass2["AllWater"] = 3] = "AllWater";
    AirportClass2[AirportClass2["HeliportOnly"] = 4] = "HeliportOnly";
    AirportClass2[AirportClass2["Private"] = 5] = "Private";
  })(AirportClass || (AirportClass = {}));
  var AirportClassMask;
  (function(AirportClassMask2) {
    AirportClassMask2[AirportClassMask2["None"] = 0] = "None";
    AirportClassMask2[AirportClassMask2["HardSurface"] = 2] = "HardSurface";
    AirportClassMask2[AirportClassMask2["SoftSurface"] = 4] = "SoftSurface";
    AirportClassMask2[AirportClassMask2["AllWater"] = 8] = "AllWater";
    AirportClassMask2[AirportClassMask2["HeliportOnly"] = 16] = "HeliportOnly";
    AirportClassMask2[AirportClassMask2["Private"] = 32] = "Private";
  })(AirportClassMask || (AirportClassMask = {}));
  var IntersectionType;
  (function(IntersectionType2) {
    IntersectionType2[IntersectionType2["None"] = 0] = "None";
    IntersectionType2[IntersectionType2["Named"] = 1] = "Named";
    IntersectionType2[IntersectionType2["Unnamed"] = 2] = "Unnamed";
    IntersectionType2[IntersectionType2["Vor"] = 3] = "Vor";
    IntersectionType2[IntersectionType2["NDB"] = 4] = "NDB";
    IntersectionType2[IntersectionType2["Offroute"] = 5] = "Offroute";
    IntersectionType2[IntersectionType2["IAF"] = 6] = "IAF";
    IntersectionType2[IntersectionType2["FAF"] = 7] = "FAF";
    IntersectionType2[IntersectionType2["RNAV"] = 8] = "RNAV";
    IntersectionType2[IntersectionType2["VFR"] = 9] = "VFR";
  })(IntersectionType || (IntersectionType = {}));
  var UserFacilityType;
  (function(UserFacilityType2) {
    UserFacilityType2[UserFacilityType2["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType2[UserFacilityType2["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType2[UserFacilityType2["LAT_LONG"] = 2] = "LAT_LONG";
  })(UserFacilityType || (UserFacilityType = {}));
  var LegType;
  (function(LegType2) {
    LegType2[LegType2["Unknown"] = 0] = "Unknown";
    LegType2[LegType2["AF"] = 1] = "AF";
    LegType2[LegType2["CA"] = 2] = "CA";
    LegType2[LegType2["CD"] = 3] = "CD";
    LegType2[LegType2["CF"] = 4] = "CF";
    LegType2[LegType2["CI"] = 5] = "CI";
    LegType2[LegType2["CR"] = 6] = "CR";
    LegType2[LegType2["DF"] = 7] = "DF";
    LegType2[LegType2["FA"] = 8] = "FA";
    LegType2[LegType2["FC"] = 9] = "FC";
    LegType2[LegType2["FD"] = 10] = "FD";
    LegType2[LegType2["FM"] = 11] = "FM";
    LegType2[LegType2["HA"] = 12] = "HA";
    LegType2[LegType2["HF"] = 13] = "HF";
    LegType2[LegType2["HM"] = 14] = "HM";
    LegType2[LegType2["IF"] = 15] = "IF";
    LegType2[LegType2["PI"] = 16] = "PI";
    LegType2[LegType2["RF"] = 17] = "RF";
    LegType2[LegType2["TF"] = 18] = "TF";
    LegType2[LegType2["VA"] = 19] = "VA";
    LegType2[LegType2["VD"] = 20] = "VD";
    LegType2[LegType2["VI"] = 21] = "VI";
    LegType2[LegType2["VM"] = 22] = "VM";
    LegType2[LegType2["VR"] = 23] = "VR";
    LegType2[LegType2["Discontinuity"] = 99] = "Discontinuity";
    LegType2[LegType2["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
  })(LegType || (LegType = {}));
  var AltitudeRestrictionType;
  (function(AltitudeRestrictionType2) {
    AltitudeRestrictionType2[AltitudeRestrictionType2["Unused"] = 0] = "Unused";
    AltitudeRestrictionType2[AltitudeRestrictionType2["At"] = 1] = "At";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType2[AltitudeRestrictionType2["Between"] = 4] = "Between";
  })(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
  var LegTurnDirection;
  (function(LegTurnDirection2) {
    LegTurnDirection2[LegTurnDirection2["None"] = 0] = "None";
    LegTurnDirection2[LegTurnDirection2["Left"] = 1] = "Left";
    LegTurnDirection2[LegTurnDirection2["Right"] = 2] = "Right";
    LegTurnDirection2[LegTurnDirection2["Either"] = 3] = "Either";
  })(LegTurnDirection || (LegTurnDirection = {}));
  var AirwayType;
  (function(AirwayType2) {
    AirwayType2[AirwayType2["None"] = 0] = "None";
    AirwayType2[AirwayType2["Victor"] = 1] = "Victor";
    AirwayType2[AirwayType2["Jet"] = 2] = "Jet";
    AirwayType2[AirwayType2["Both"] = 3] = "Both";
  })(AirwayType || (AirwayType = {}));
  var NdbType;
  (function(NdbType2) {
    NdbType2[NdbType2["CompassPoint"] = 0] = "CompassPoint";
    NdbType2[NdbType2["MH"] = 1] = "MH";
    NdbType2[NdbType2["H"] = 2] = "H";
    NdbType2[NdbType2["HH"] = 3] = "HH";
  })(NdbType || (NdbType = {}));
  var VorType;
  (function(VorType2) {
    VorType2[VorType2["Unknown"] = 0] = "Unknown";
    VorType2[VorType2["VOR"] = 1] = "VOR";
    VorType2[VorType2["VORDME"] = 2] = "VORDME";
    VorType2[VorType2["DME"] = 3] = "DME";
    VorType2[VorType2["TACAN"] = 4] = "TACAN";
    VorType2[VorType2["VORTAC"] = 5] = "VORTAC";
    VorType2[VorType2["ILS"] = 6] = "ILS";
    VorType2[VorType2["VOT"] = 7] = "VOT";
  })(VorType || (VorType = {}));
  var RunwaySurfaceType;
  (function(RunwaySurfaceType2) {
    RunwaySurfaceType2[RunwaySurfaceType2["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType2[RunwaySurfaceType2["Grass"] = 1] = "Grass";
    RunwaySurfaceType2[RunwaySurfaceType2["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType2[RunwaySurfaceType2["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType2[RunwaySurfaceType2["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType2[RunwaySurfaceType2["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType2[RunwaySurfaceType2["Snow"] = 8] = "Snow";
    RunwaySurfaceType2[RunwaySurfaceType2["Ice"] = 9] = "Ice";
    RunwaySurfaceType2[RunwaySurfaceType2["Urban"] = 10] = "Urban";
    RunwaySurfaceType2[RunwaySurfaceType2["Forest"] = 11] = "Forest";
    RunwaySurfaceType2[RunwaySurfaceType2["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType2[RunwaySurfaceType2["Coral"] = 13] = "Coral";
    RunwaySurfaceType2[RunwaySurfaceType2["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType2[RunwaySurfaceType2["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType2[RunwaySurfaceType2["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType2[RunwaySurfaceType2["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType2[RunwaySurfaceType2["Brick"] = 18] = "Brick";
    RunwaySurfaceType2[RunwaySurfaceType2["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType2[RunwaySurfaceType2["Planks"] = 20] = "Planks";
    RunwaySurfaceType2[RunwaySurfaceType2["Sand"] = 21] = "Sand";
    RunwaySurfaceType2[RunwaySurfaceType2["Shale"] = 22] = "Shale";
    RunwaySurfaceType2[RunwaySurfaceType2["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType2[RunwaySurfaceType2["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    RunwaySurfaceType2[RunwaySurfaceType2["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType2[RunwaySurfaceType2["Water"] = 27] = "Water";
    RunwaySurfaceType2[RunwaySurfaceType2["Pond"] = 28] = "Pond";
    RunwaySurfaceType2[RunwaySurfaceType2["Lake"] = 29] = "Lake";
    RunwaySurfaceType2[RunwaySurfaceType2["River"] = 30] = "River";
    RunwaySurfaceType2[RunwaySurfaceType2["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType2[RunwaySurfaceType2["Paint"] = 32] = "Paint";
  })(RunwaySurfaceType || (RunwaySurfaceType = {}));
  var RunwayLightingType;
  (function(RunwayLightingType2) {
    RunwayLightingType2[RunwayLightingType2["Unknown"] = 0] = "Unknown";
    RunwayLightingType2[RunwayLightingType2["None"] = 1] = "None";
    RunwayLightingType2[RunwayLightingType2["PartTime"] = 2] = "PartTime";
    RunwayLightingType2[RunwayLightingType2["FullTime"] = 3] = "FullTime";
    RunwayLightingType2[RunwayLightingType2["Frequency"] = 4] = "Frequency";
  })(RunwayLightingType || (RunwayLightingType = {}));
  var AirportPrivateType;
  (function(AirportPrivateType2) {
    AirportPrivateType2[AirportPrivateType2["Uknown"] = 0] = "Uknown";
    AirportPrivateType2[AirportPrivateType2["Public"] = 1] = "Public";
    AirportPrivateType2[AirportPrivateType2["Military"] = 2] = "Military";
    AirportPrivateType2[AirportPrivateType2["Private"] = 3] = "Private";
  })(AirportPrivateType || (AirportPrivateType = {}));
  var GpsBoolean;
  (function(GpsBoolean2) {
    GpsBoolean2[GpsBoolean2["Unknown"] = 0] = "Unknown";
    GpsBoolean2[GpsBoolean2["No"] = 1] = "No";
    GpsBoolean2[GpsBoolean2["Yes"] = 2] = "Yes";
  })(GpsBoolean || (GpsBoolean = {}));
  var VorClass;
  (function(VorClass2) {
    VorClass2[VorClass2["Unknown"] = 0] = "Unknown";
    VorClass2[VorClass2["Terminal"] = 1] = "Terminal";
    VorClass2[VorClass2["LowAlt"] = 2] = "LowAlt";
    VorClass2[VorClass2["HighAlt"] = 3] = "HighAlt";
    VorClass2[VorClass2["ILS"] = 4] = "ILS";
    VorClass2[VorClass2["VOT"] = 5] = "VOT";
  })(VorClass || (VorClass = {}));
  var FacilityType;
  (function(FacilityType2) {
    FacilityType2["Airport"] = "LOAD_AIRPORT";
    FacilityType2["Intersection"] = "LOAD_INTERSECTION";
    FacilityType2["VOR"] = "LOAD_VOR";
    FacilityType2["NDB"] = "LOAD_NDB";
    FacilityType2["USR"] = "USR";
    FacilityType2["RWY"] = "RWY";
    FacilityType2["VIS"] = "VIS";
  })(FacilityType || (FacilityType = {}));
  var FacilitySearchType;
  (function(FacilitySearchType2) {
    FacilitySearchType2[FacilitySearchType2["All"] = 0] = "All";
    FacilitySearchType2[FacilitySearchType2["Airport"] = 1] = "Airport";
    FacilitySearchType2[FacilitySearchType2["Intersection"] = 2] = "Intersection";
    FacilitySearchType2[FacilitySearchType2["Vor"] = 3] = "Vor";
    FacilitySearchType2[FacilitySearchType2["Ndb"] = 4] = "Ndb";
    FacilitySearchType2[FacilitySearchType2["Boundary"] = 5] = "Boundary";
    FacilitySearchType2[FacilitySearchType2["User"] = 6] = "User";
    FacilitySearchType2[FacilitySearchType2["Visual"] = 7] = "Visual";
    FacilitySearchType2[FacilitySearchType2["AllExceptVisual"] = 8] = "AllExceptVisual";
  })(FacilitySearchType || (FacilitySearchType = {}));
  var BoundaryType;
  (function(BoundaryType2) {
    BoundaryType2[BoundaryType2["None"] = 0] = "None";
    BoundaryType2[BoundaryType2["Center"] = 1] = "Center";
    BoundaryType2[BoundaryType2["ClassA"] = 2] = "ClassA";
    BoundaryType2[BoundaryType2["ClassB"] = 3] = "ClassB";
    BoundaryType2[BoundaryType2["ClassC"] = 4] = "ClassC";
    BoundaryType2[BoundaryType2["ClassD"] = 5] = "ClassD";
    BoundaryType2[BoundaryType2["ClassE"] = 6] = "ClassE";
    BoundaryType2[BoundaryType2["ClassF"] = 7] = "ClassF";
    BoundaryType2[BoundaryType2["ClassG"] = 8] = "ClassG";
    BoundaryType2[BoundaryType2["Tower"] = 9] = "Tower";
    BoundaryType2[BoundaryType2["Clearance"] = 10] = "Clearance";
    BoundaryType2[BoundaryType2["Ground"] = 11] = "Ground";
    BoundaryType2[BoundaryType2["Departure"] = 12] = "Departure";
    BoundaryType2[BoundaryType2["Approach"] = 13] = "Approach";
    BoundaryType2[BoundaryType2["MOA"] = 14] = "MOA";
    BoundaryType2[BoundaryType2["Restricted"] = 15] = "Restricted";
    BoundaryType2[BoundaryType2["Prohibited"] = 16] = "Prohibited";
    BoundaryType2[BoundaryType2["Warning"] = 17] = "Warning";
    BoundaryType2[BoundaryType2["Alert"] = 18] = "Alert";
    BoundaryType2[BoundaryType2["Danger"] = 19] = "Danger";
    BoundaryType2[BoundaryType2["NationalPark"] = 20] = "NationalPark";
    BoundaryType2[BoundaryType2["ModeC"] = 21] = "ModeC";
    BoundaryType2[BoundaryType2["Radar"] = 22] = "Radar";
    BoundaryType2[BoundaryType2["Training"] = 23] = "Training";
  })(BoundaryType || (BoundaryType = {}));
  var BoundaryAltitudeType;
  (function(BoundaryAltitudeType2) {
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType2[BoundaryAltitudeType2["MSL"] = 1] = "MSL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["AGL"] = 2] = "AGL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unlimited"] = 3] = "Unlimited";
  })(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
  var BoundaryVectorType;
  (function(BoundaryVectorType2) {
    BoundaryVectorType2[BoundaryVectorType2["None"] = 0] = "None";
    BoundaryVectorType2[BoundaryVectorType2["Start"] = 1] = "Start";
    BoundaryVectorType2[BoundaryVectorType2["Line"] = 2] = "Line";
    BoundaryVectorType2[BoundaryVectorType2["Origin"] = 3] = "Origin";
    BoundaryVectorType2[BoundaryVectorType2["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType2[BoundaryVectorType2["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType2[BoundaryVectorType2["Circle"] = 6] = "Circle";
  })(BoundaryVectorType || (BoundaryVectorType = {}));
  var MetarWindSpeedUnits;
  (function(MetarWindSpeedUnits2) {
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["KilometerPerHour"] = 2] = "KilometerPerHour";
  })(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
  var MetarVisibilityUnits;
  (function(MetarVisibilityUnits2) {
    MetarVisibilityUnits2[MetarVisibilityUnits2["Meter"] = 0] = "Meter";
    MetarVisibilityUnits2[MetarVisibilityUnits2["StatuteMile"] = 1] = "StatuteMile";
  })(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
  var MetarCloudLayerCoverage;
  (function(MetarCloudLayerCoverage2) {
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Few"] = 3] = "Few";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Overcast"] = 6] = "Overcast";
  })(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
  var MetarCloudLayerType;
  (function(MetarCloudLayerType2) {
    MetarCloudLayerType2[MetarCloudLayerType2["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType2[MetarCloudLayerType2["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType2[MetarCloudLayerType2["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType2[MetarCloudLayerType2["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
  })(MetarCloudLayerType || (MetarCloudLayerType = {}));
  var MetarPhenomenonType;
  (function(MetarPhenomenonType2) {
    MetarPhenomenonType2[MetarPhenomenonType2["None"] = 0] = "None";
    MetarPhenomenonType2[MetarPhenomenonType2["Mist"] = 1] = "Mist";
    MetarPhenomenonType2[MetarPhenomenonType2["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType2[MetarPhenomenonType2["Dust"] = 3] = "Dust";
    MetarPhenomenonType2[MetarPhenomenonType2["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType2[MetarPhenomenonType2["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType2[MetarPhenomenonType2["Fog"] = 6] = "Fog";
    MetarPhenomenonType2[MetarPhenomenonType2["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType2[MetarPhenomenonType2["Hail"] = 8] = "Hail";
    MetarPhenomenonType2[MetarPhenomenonType2["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType2[MetarPhenomenonType2["Haze"] = 10] = "Haze";
    MetarPhenomenonType2[MetarPhenomenonType2["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType2[MetarPhenomenonType2["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType2[MetarPhenomenonType2["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType2[MetarPhenomenonType2["Spray"] = 14] = "Spray";
    MetarPhenomenonType2[MetarPhenomenonType2["Rain"] = 15] = "Rain";
    MetarPhenomenonType2[MetarPhenomenonType2["Sand"] = 16] = "Sand";
    MetarPhenomenonType2[MetarPhenomenonType2["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType2[MetarPhenomenonType2["Shower"] = 18] = "Shower";
    MetarPhenomenonType2[MetarPhenomenonType2["Snow"] = 19] = "Snow";
    MetarPhenomenonType2[MetarPhenomenonType2["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType2[MetarPhenomenonType2["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType2[MetarPhenomenonType2["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType2[MetarPhenomenonType2["VolcanicAsh"] = 23] = "VolcanicAsh";
  })(MetarPhenomenonType || (MetarPhenomenonType = {}));
  var MetarPhenomenonIntensity;
  (function(MetarPhenomenonIntensity2) {
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Light"] = -1] = "Light";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Heavy"] = 1] = "Heavy";
  })(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
  var ICAO = class {
    static getFacilityType(icao) {
      switch (icao[0]) {
        case "A":
          return FacilityType.Airport;
        case "W":
          return FacilityType.Intersection;
        case "V":
          return FacilityType.VOR;
        case "N":
          return FacilityType.NDB;
        case "U":
          return FacilityType.USR;
        case "R":
          return FacilityType.RWY;
        case "S":
          return FacilityType.VIS;
        default:
          throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
      }
    }
    static getAssociatedAirportIdent(icao) {
      return icao.substr(3, 4).trim();
    }
    static isFacility(icao, type) {
      switch (icao[0]) {
        case "A":
          return type === void 0 || type === FacilityType.Airport;
        case "W":
          return type === void 0 || type === FacilityType.Intersection;
        case "V":
          return type === void 0 || type === FacilityType.VOR;
        case "N":
          return type === void 0 || type === FacilityType.NDB;
        case "U":
          return type === void 0 || type === FacilityType.USR;
        case "R":
          return type === void 0 || type === FacilityType.RWY;
        case "S":
          return type === void 0 || type === FacilityType.VIS;
        default:
          return false;
      }
    }
    static getIdent(icao) {
      return icao.substr(7).trim();
    }
    static getRegionCode(icao) {
      return icao.substr(1, 2).trim();
    }
  };
  ICAO.emptyIcao = "            ";
  var FacilityUtils = class {
    static isFacilityType(facility, type) {
      if (facility["__Type"] === "JS_FacilityIntersection") {
        return type === FacilityType.Intersection;
      }
      return ICAO.isFacility(facility.icao, type);
    }
    static getMagVar(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
        return -facility.magneticVariation;
      } else {
        return MagVar.get(facility.lat, facility.lon);
      }
    }
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
      return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
      const magVar1 = FacilityUtils.getMagVar(reference1);
      const magVar2 = FacilityUtils.getMagVar(reference2);
      const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
      const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
      const radial1IncludesRef2 = radialCircle1.includes(reference2);
      const radial2IncludesRef1 = radialCircle2.includes(reference1);
      if (radial1IncludesRef2 && radial2IncludesRef1) {
        return out.set(NaN, NaN);
      } else if (radial1IncludesRef2) {
        return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
      } else if (radial2IncludesRef1) {
        return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
      }
      const numIntersections = radialCircle1.encircles(reference2) ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache) : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
      if (numIntersections === 0) {
        return out.set(NaN, NaN);
      }
      return out.set(FacilityUtils.intersectionCache[0]);
    }
  };
  FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
  FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var IntersectionFacilityUtils = class {
    static isTerminal(arg) {
      const icao = typeof arg === "string" ? arg : arg.icao;
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao);
    }
    static getNonTerminalICAO(icao) {
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao) ? `${icao.substring(0, 3)}    ${icao.substring(7)}` : icao;
    }
    static getIcaoIdentity(icao) {
      return icao;
    }
    static getIcaoFacility(facility) {
      return facility.icao;
    }
    static filterDuplicates(array, arg2, arg3) {
      if (array.length === 0) {
        return [];
      }
      let getIcao;
      let retainTerminal;
      if (typeof arg2 === "function") {
        getIcao = arg2;
        retainTerminal = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        retainTerminal = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        if (typeof array[0] === "string") {
          getIcao = IntersectionFacilityUtils.getIcaoIdentity;
        } else {
          getIcao = IntersectionFacilityUtils.getIcaoFacility;
        }
      }
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      for (let i = 0; i < array.length; i++) {
        const icao = getIcao(array[i]);
        if (ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) === retainTerminal) {
          IntersectionFacilityUtils.filterDuplicatesSet.add(IntersectionFacilityUtils.getNonTerminalICAO(icao));
        }
      }
      if (IntersectionFacilityUtils.filterDuplicatesSet.size === 0) {
        return array.slice();
      }
      const filtered = array.filter((icao) => {
        return IntersectionFacilityUtils.filterDuplicatesHelper(icao, getIcao, retainTerminal, IntersectionFacilityUtils.filterDuplicatesSet);
      });
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      return filtered;
    }
    static filterDuplicatesHelper(element, getIcao, retainTerminal, nonTerminalIcaosToFilter) {
      const icao = getIcao(element);
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        return true;
      }
      const isTerminal = IntersectionFacilityUtils.isTerminal(icao);
      if (isTerminal === retainTerminal) {
        return true;
      }
      if (isTerminal) {
        return !nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao));
      } else {
        return !nonTerminalIcaosToFilter.has(icao);
      }
    }
  };
  IntersectionFacilityUtils.TERMINAL_REGEX = /^...[a-zA-Z\d]/;
  IntersectionFacilityUtils.filterDuplicatesSet = /* @__PURE__ */ new Set();
  var UserFacilityUtils = class {
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
      const fac = {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat,
        lon,
        userFacilityType: UserFacilityType.LAT_LONG,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(lat, lon)
      };
      return fac;
    }
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
      const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
      return {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_DISTANCE,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference.icao,
        reference1Radial: radial,
        reference1MagVar: FacilityUtils.getMagVar(reference),
        reference1Distance: distance
      };
    }
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
      const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
      if (isNaN(location.lat) || isNaN(location.lon)) {
        return void 0;
      }
      return {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_RADIAL,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference1.icao,
        reference1Radial: radial1,
        reference1MagVar: FacilityUtils.getMagVar(reference1),
        reference2Icao: reference2.icao,
        reference2Radial: radial2,
        reference2MagVar: FacilityUtils.getMagVar(reference2)
      };
    }
  };
  UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  var RunwaySurfaceCategory;
  (function(RunwaySurfaceCategory2) {
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Water"] = 8] = "Water";
  })(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
  var RunwayUtils = class {
    static getDesignatorLetter(designator, lowerCase = false) {
      const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
      return lowerCase ? letter.toLowerCase() : letter;
    }
    static createEmptyOneWayRunway() {
      return {
        parentRunwayIndex: -1,
        designation: "",
        direction: 36,
        runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
        course: 0,
        elevation: 0,
        elevationEnd: 0,
        gradient: 0,
        latitude: 0,
        longitude: 0,
        length: 0,
        width: 0,
        startThresholdLength: 0,
        endThresholdLength: 0,
        surface: RunwaySurfaceType.Concrete,
        lighting: RunwayLightingType.Unknown
      };
    }
    static getOneWayRunwaysFromAirport(airport) {
      const runways = [];
      airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach((d) => {
        runways.push(d[0]);
        runways.push(d[1]);
      });
      runways.sort(RunwayUtils.sortRunways);
      return runways;
    }
    static getOneWayRunways(runway, index) {
      const splitRunways = [];
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        let course = 0;
        let thresholdDistanceFromCenter = 0;
        let thresholdElevation = 0;
        let endThresholdElevation = 0;
        let ilsFrequency;
        let startThresholdLength = 0, endThresholdLength = 0;
        if (i === 0) {
          designator = runway.designatorCharPrimary;
          course = runway.direction;
          thresholdDistanceFromCenter = runway.length / 2 - runway.primaryThresholdLength;
          thresholdElevation = runway.primaryElevation;
          endThresholdElevation = runway.secondaryElevation;
          ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? void 0 : runway.primaryILSFrequency;
          startThresholdLength = runway.primaryThresholdLength;
          endThresholdLength = runway.secondaryThresholdLength;
        } else if (i === 1) {
          designator = runway.designatorCharSecondary;
          course = NavMath.normalizeHeading(runway.direction + 180);
          thresholdDistanceFromCenter = runway.length / 2 - runway.secondaryThresholdLength;
          thresholdElevation = runway.secondaryElevation;
          endThresholdElevation = runway.primaryElevation;
          ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? void 0 : runway.secondaryILSFrequency;
          startThresholdLength = runway.secondaryThresholdLength;
          endThresholdLength = runway.primaryThresholdLength;
        }
        const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
        const coordinates = RunwayUtils.tempGeoPoint.set(runway.latitude, runway.longitude).offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
        splitRunways.push({
          parentRunwayIndex: index,
          designation,
          direction: runwayNumber,
          runwayDesignator: designator,
          course,
          elevation: thresholdElevation,
          elevationEnd: endThresholdElevation,
          gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
          latitude: coordinates.lat,
          longitude: coordinates.lon,
          ilsFrequency,
          length: runway.length,
          width: runway.width,
          startThresholdLength,
          endThresholdLength,
          surface: runway.surface,
          lighting: runway.lighting
        });
      }
      return splitRunways;
    }
    static getRunwayPairNameString(runway, padded = true) {
      const pad = padded ? 2 : 0;
      const dashIndex = runway.designation.search("-");
      const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
      const secondary = dashIndex < 0 ? "" : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
      return primary + secondary;
    }
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = "") {
      let numberText = `${runwayNumber}`;
      if (padded) {
        numberText = numberText.padStart(2, "0");
      }
      return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    static getRunwayNumberPrimary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return parseInt(runway.designation);
      } else {
        return parseInt(runway.designation.substring(0, dashIndex));
      }
    }
    static getRunwayNumberSecondary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return void 0;
      } else {
        return parseInt(runway.designation.substring(dashIndex + 1));
      }
    }
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const length = airport.runways.length;
      for (let r = 0; r < length; r++) {
        const runway = airport.runways[r];
        const designation = runway.designation;
        const primaryRunwayNumber = parseInt(designation.split("-")[0]);
        const secondaryRunwayNumber = parseInt(designation.split("-")[1]);
        if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
          const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
          return oneWayRunways[0];
        } else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
          const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
          return oneWayRunways[1];
        }
      }
      return void 0;
    }
    static matchOneWayRunwayFromDesignation(airport, designation) {
      const length = airport.runways.length;
      for (let i = 0; i < length; i++) {
        const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
          return r.designation === designation;
        });
        if (match) {
          return match;
        }
      }
      return void 0;
    }
    static matchOneWayRunwayFromIdent(airport, ident) {
      return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    static getProceduresForRunway(procedures, runway) {
      const oneways = new Array();
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let runwayName;
        if (i === 0) {
          runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, "");
        } else {
          runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, "");
        }
        oneways.push(runwayName);
      }
      const found = new Array();
      for (const procedure of procedures) {
        if (oneways.includes(procedure.runway.trim())) {
          found.push(procedure);
        } else if (procedure.runwayNumber === 0) {
          found.push(procedure);
        }
      }
      return found;
    }
    static getLocFrequency(airport, arg1, arg2) {
      let runway;
      if (typeof arg1 === "string") {
        const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else if (typeof arg1 === "number") {
        const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else {
        runway = arg1;
      }
      const runwayDesignation = runway.designation;
      if (runway.ilsFrequency) {
        return runway.ilsFrequency;
      }
      for (let i = 0; i < airport.frequencies.length; i++) {
        const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ""));
        if (match > -1) {
          return airport.frequencies[i];
        }
      }
      return void 0;
    }
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
      const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
      if (!matchedRunway) {
        return void 0;
      }
      return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
      let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
      switch (runwayDesignator) {
        case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
          break;
        case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
          break;
        default:
          oppositeRunwayDesignator = runwayDesignator;
          break;
      }
      return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    static sortRunways(r1, r2) {
      if (r1.direction === r2.direction) {
        let v1 = 0;
        if (r1.designation.indexOf("L") != -1) {
          v1 = 1;
        } else if (r1.designation.indexOf("C") != -1) {
          v1 = 2;
        } else if (r1.designation.indexOf("R") != -1) {
          v1 = 3;
        }
        let v2 = 0;
        if (r2.designation.indexOf("L") != -1) {
          v2 = 1;
        } else if (r2.designation.indexOf("C") != -1) {
          v2 = 2;
        } else if (r2.designation.indexOf("R") != -1) {
          v2 = 3;
        }
        return v1 - v2;
      }
      return r1.direction - r2.direction;
    }
    static getRunwayFacilityIcao(airport, runway) {
      const icao = typeof airport === "string" ? airport : airport.icao;
      return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, " ")}`;
    }
    static createRunwayFacility(airport, runway) {
      return {
        icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
        name: `Runway ${runway.designation}`,
        region: airport.region,
        city: airport.city,
        lat: runway.latitude,
        lon: runway.longitude,
        magvar: airport.magvar,
        runway
      };
    }
    static getRunwayCode(number) {
      const n = Math.round(number);
      return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    static getSurfaceCategory(runway) {
      const surface = typeof runway === "object" ? runway.surface : runway;
      if (this.SURFACES_HARD.includes(surface)) {
        return RunwaySurfaceCategory.Hard;
      } else if (this.SURFACES_SOFT.includes(surface)) {
        return RunwaySurfaceCategory.Soft;
      } else if (this.SURFACES_WATER.includes(surface)) {
        return RunwaySurfaceCategory.Water;
      } else {
        return RunwaySurfaceCategory.Unknown;
      }
    }
  };
  RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: "",
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: "L",
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: "R",
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: "C",
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: "W",
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: "A",
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: "B"
  };
  RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban
  ];
  RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
  ];
  RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
  ];
  RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);
  var AirportUtils = class {
    static tryGetRegionCode(facility) {
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        if (approach.runway.length === 0 || approach.finalLegs.length === 0) {
          continue;
        }
        const fixIcao = approach.finalLegs[approach.finalLegs.length - 1].fixIcao;
        if (ICAO.isFacility(fixIcao, FacilityType.RWY)) {
          const region = ICAO.getRegionCode(fixIcao);
          if (AirportUtils.REGION_CODES.has(region)) {
            return region;
          }
        }
      }
      if (facility.approaches.length > 1) {
        let region = void 0;
        let regionCount = 0;
        for (let i = 0; i < facility.approaches.length; i++) {
          const approach = facility.approaches[i];
          for (let j = 0; j < approach.finalLegs.length; j++) {
            const leg = approach.finalLegs[j];
            if (leg.fixTypeFlags === FixTypeFlags.FAF && ICAO.isFacility(leg.fixIcao)) {
              const fafRegion = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(fafRegion)) {
                region !== null && region !== void 0 ? region : region = fafRegion;
                if (region !== fafRegion) {
                  region = void 0;
                }
                regionCount++;
                break;
              }
            }
          }
          if (region === void 0 && regionCount > 0) {
            break;
          }
        }
        if (region !== void 0 && regionCount > 1) {
          return region;
        }
      }
      const ident = ICAO.getIdent(facility.icao);
      if (ident.length === 4 && ident.search(AirportUtils.NUMERAL_REGEX) < 0) {
        const region = ident.substring(0, 2);
        if (AirportUtils.REGION_CODES.has(region)) {
          return region;
        }
      }
      for (let i = 0; i < facility.departures.length; i++) {
        const departure = facility.departures[i];
        for (let j = 0; j < departure.commonLegs.length; j++) {
          const leg = departure.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < departure.runwayTransitions.length; j++) {
          const transition = departure.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.arrivals.length; i++) {
        const arrival = facility.arrivals[i];
        for (let j = 0; j < arrival.commonLegs.length; j++) {
          const leg = arrival.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < arrival.runwayTransitions.length; j++) {
          const transition = arrival.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        for (let j = 0; j < approach.finalLegs.length; j++) {
          const leg = approach.finalLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < approach.transitions.length; j++) {
          const transition = approach.transitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      return void 0;
    }
    static getElevation(facility) {
      if (facility.runways.length === 0) {
        return void 0;
      }
      return facility.runways.reduce((sum, runway) => sum + runway.elevation, 0) / facility.runways.length;
    }
    static getLongestRunway(facility) {
      let longestRunway = null;
      for (const runway of facility.runways) {
        if (longestRunway === null || runway.length > longestRunway.length) {
          longestRunway = runway;
        }
      }
      return longestRunway;
    }
    static getFilteredRunways(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      const result = [];
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
            result.push(runway);
          }
        }
      }
      return result;
    }
    static hasMatchingRunway(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
            return true;
          }
        }
      }
      return false;
    }
  };
  AirportUtils.REGION_CODES = /* @__PURE__ */ new Set([
    "AG",
    "AN",
    "AY",
    "BG",
    "BI",
    "BK",
    "CY",
    "DA",
    "DB",
    "DF",
    "DG",
    "DI",
    "DN",
    "DR",
    "DT",
    "DX",
    "EB",
    "ED",
    "EE",
    "EF",
    "EG",
    "EH",
    "EI",
    "EK",
    "EL",
    "EN",
    "EP",
    "ES",
    "ET",
    "EV",
    "EY",
    "FA",
    "FB",
    "FC",
    "FD",
    "FE",
    "FG",
    "FH",
    "FI",
    "FJ",
    "FK",
    "FL",
    "FM",
    "FN",
    "FO",
    "FP",
    "FQ",
    "FS",
    "FT",
    "FV",
    "FW",
    "FX",
    "FY",
    "FZ",
    "GA",
    "GB",
    "GC",
    "GE",
    "GF",
    "GG",
    "GL",
    "GM",
    "GO",
    "GQ",
    "GS",
    "GU",
    "GV",
    "HA",
    "HB",
    "HD",
    "HE",
    "HH",
    "HK",
    "HL",
    "HR",
    "HS",
    "HT",
    "HU",
    "K1",
    "K2",
    "K3",
    "K4",
    "K5",
    "K6",
    "K7",
    "LA",
    "LB",
    "LC",
    "LD",
    "LE",
    "LF",
    "LG",
    "LH",
    "LI",
    "LJ",
    "LK",
    "LL",
    "LM",
    "LO",
    "LP",
    "LQ",
    "LR",
    "LS",
    "LT",
    "LU",
    "LV",
    "LW",
    "LX",
    "LY",
    "LZ",
    "MB",
    "MD",
    "MG",
    "MH",
    "MK",
    "MM",
    "MN",
    "MP",
    "MR",
    "MS",
    "MT",
    "MU",
    "MW",
    "MY",
    "MZ",
    "NC",
    "NF",
    "NG",
    "NI",
    "NL",
    "NS",
    "NT",
    "NV",
    "NW",
    "NZ",
    "OA",
    "OB",
    "OE",
    "OI",
    "OJ",
    "OK",
    "OL",
    "OM",
    "OO",
    "OP",
    "OR",
    "OS",
    "OT",
    "OY",
    "PA",
    "PG",
    "PH",
    "PJ",
    "PK",
    "PL",
    "PM",
    "PO",
    "PP",
    "PT",
    "PW",
    "RC",
    "RJ",
    "RK",
    "RO",
    "RP",
    "SA",
    "SB",
    "SC",
    "SD",
    "SE",
    "SG",
    "SI",
    "SJ",
    "SK",
    "SL",
    "SM",
    "SO",
    "SP",
    "SS",
    "SU",
    "SV",
    "SW",
    "SY",
    "TA",
    "TB",
    "TD",
    "TF",
    "TG",
    "TI",
    "TJ",
    "TK",
    "TL",
    "TN",
    "TQ",
    "TT",
    "TU",
    "TV",
    "TX",
    "UA",
    "UB",
    "UC",
    "UD",
    "UE",
    "UG",
    "UH",
    "UI",
    "UK",
    "UL",
    "UM",
    "UN",
    "UO",
    "UR",
    "US",
    "UT",
    "UU",
    "UW",
    "VA",
    "VC",
    "VD",
    "VE",
    "VG",
    "VH",
    "VI",
    "VL",
    "VM",
    "VN",
    "VO",
    "VR",
    "VT",
    "VV",
    "VY",
    "WA",
    "WB",
    "WI",
    "WM",
    "WR",
    "WS",
    "YB",
    "YM",
    "ZB",
    "ZG",
    "ZH",
    "ZK",
    "ZL",
    "ZM",
    "ZP",
    "ZS",
    "ZU",
    "ZW",
    "ZY"
  ]);
  AirportUtils.NUMERAL_REGEX = /\d/;
  var AirspaceType;
  (function(AirspaceType2) {
    AirspaceType2[AirspaceType2["None"] = 0] = "None";
    AirspaceType2[AirspaceType2["Center"] = 1] = "Center";
    AirspaceType2[AirspaceType2["ClassA"] = 2] = "ClassA";
    AirspaceType2[AirspaceType2["ClassB"] = 3] = "ClassB";
    AirspaceType2[AirspaceType2["ClassC"] = 4] = "ClassC";
    AirspaceType2[AirspaceType2["ClassD"] = 5] = "ClassD";
    AirspaceType2[AirspaceType2["ClassE"] = 6] = "ClassE";
    AirspaceType2[AirspaceType2["ClassF"] = 7] = "ClassF";
    AirspaceType2[AirspaceType2["ClassG"] = 8] = "ClassG";
    AirspaceType2[AirspaceType2["Tower"] = 9] = "Tower";
    AirspaceType2[AirspaceType2["Clearance"] = 10] = "Clearance";
    AirspaceType2[AirspaceType2["Ground"] = 11] = "Ground";
    AirspaceType2[AirspaceType2["Departure"] = 12] = "Departure";
    AirspaceType2[AirspaceType2["Approach"] = 13] = "Approach";
    AirspaceType2[AirspaceType2["MOA"] = 14] = "MOA";
    AirspaceType2[AirspaceType2["Restricted"] = 15] = "Restricted";
    AirspaceType2[AirspaceType2["Prohibited"] = 16] = "Prohibited";
    AirspaceType2[AirspaceType2["Warning"] = 17] = "Warning";
    AirspaceType2[AirspaceType2["Alert"] = 18] = "Alert";
    AirspaceType2[AirspaceType2["Danger"] = 19] = "Danger";
    AirspaceType2[AirspaceType2["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType2[AirspaceType2["ModeC"] = 21] = "ModeC";
    AirspaceType2[AirspaceType2["Radar"] = 22] = "Radar";
    AirspaceType2[AirspaceType2["Training"] = 23] = "Training";
    AirspaceType2[AirspaceType2["Max"] = 24] = "Max";
  })(AirspaceType || (AirspaceType = {}));
  var CoherentAirspace = class {
    constructor(def, uid) {
      this.name = "";
      this._segments = [];
      this.type = def.type;
      this.uid = uid;
      const segments = def.segments;
      const len = segments.length;
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        this._segments[i] = new GeoPoint(point.lat, point.long);
      }
    }
    get segments() {
      return this._segments;
    }
    equals(other) {
      if (other instanceof CoherentAirspace) {
        return this.uid === other.uid;
      }
      return this.type === other.type && this.segments.length === other.segments.length && this.segments.every((point, index) => point.equals(other.segments[index]));
    }
  };
  var AirspaceSearcher = class {
    constructor(cacheSize = AirspaceSearcher.DEFAULT_CACHE_SIZE) {
      this.cacheSize = cacheSize;
      this.cache = /* @__PURE__ */ new Map();
      this._isBusy = false;
      this.queue = [];
    }
    isBusy() {
      return this._isBusy;
    }
    search(center) {
      return new Promise((resolve) => {
        if (this._isBusy || this.queue.length > 0) {
          this.enqueueSearch(center, resolve);
        } else {
          this.doSearch(center, resolve);
        }
      });
    }
    enqueueSearch(center, resolve) {
      this.queue.push(this.doSearch.bind(this, center, resolve));
    }
    processQueue() {
      const next = this.queue.shift();
      if (next) {
        next();
      }
    }
    async doSearch(center, resolve) {
      this._isBusy = true;
      try {
        const coherentDefs = await Promise.race([
          this.executeCoherentSearch(center),
          new Promise((timeoutResolve, reject) => setTimeout(() => reject("Airspace search timed out."), AirspaceSearcher.SEARCH_TIMEOUT))
        ]);
        const airspaces = this.processCoherentDefs(coherentDefs);
        resolve(airspaces);
      } catch (e) {
        resolve([]);
      }
      this._isBusy = false;
      this.processQueue();
    }
    async executeCoherentSearch(center) {
      await Coherent.call("SET_LOAD_LATLON", center.lat, center.lon);
      return await Coherent.call("GET_NEAREST_AIRSPACES");
    }
    processCoherentDefs(defs) {
      const result = [];
      const len = defs.length;
      for (let i = 0; i < len; i++) {
        const def = defs[i];
        if (def.type === AirspaceType.None) {
          continue;
        }
        const uid = AirspaceSearcher.generateUID(def);
        let airspace = this.cache.get(uid);
        if (!airspace) {
          airspace = new CoherentAirspace(def, uid);
          this.cacheAirspace(airspace);
        }
        result.push(airspace);
      }
      return result;
    }
    cacheAirspace(airspace) {
      this.cache.set(airspace.uid, airspace);
      if (this.cache.size > this.cacheSize) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    static generateUID(def) {
      const segments = def.segments;
      let uid = `${def.type}[${segments.length}]:`;
      const len = Math.min(segments.length - 1, 10);
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        uid += `(${point.lat},${point.long})`;
      }
      if (len < segments.length - 1) {
        const point = segments[segments.length - 2];
        uid += `(${point.lat},${point.long})`;
      }
      return uid;
    }
  };
  AirspaceSearcher.SEARCH_TIMEOUT = 5e3;
  AirspaceSearcher.DEFAULT_CACHE_SIZE = 1e3;
  var MSFSAPStates;
  (function(MSFSAPStates2) {
    MSFSAPStates2[MSFSAPStates2["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates2[MSFSAPStates2["APOn"] = 2] = "APOn";
    MSFSAPStates2[MSFSAPStates2["FDOn"] = 4] = "FDOn";
    MSFSAPStates2[MSFSAPStates2["FLC"] = 8] = "FLC";
    MSFSAPStates2[MSFSAPStates2["Alt"] = 16] = "Alt";
    MSFSAPStates2[MSFSAPStates2["AltArm"] = 32] = "AltArm";
    MSFSAPStates2[MSFSAPStates2["GS"] = 64] = "GS";
    MSFSAPStates2[MSFSAPStates2["GSArm"] = 128] = "GSArm";
    MSFSAPStates2[MSFSAPStates2["Pitch"] = 256] = "Pitch";
    MSFSAPStates2[MSFSAPStates2["VS"] = 512] = "VS";
    MSFSAPStates2[MSFSAPStates2["Heading"] = 1024] = "Heading";
    MSFSAPStates2[MSFSAPStates2["Nav"] = 2048] = "Nav";
    MSFSAPStates2[MSFSAPStates2["NavArm"] = 4096] = "NavArm";
    MSFSAPStates2[MSFSAPStates2["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates2[MSFSAPStates2["Attitude"] = 16384] = "Attitude";
    MSFSAPStates2[MSFSAPStates2["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates2[MSFSAPStates2["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates2[MSFSAPStates2["ATArm"] = 131072] = "ATArm";
    MSFSAPStates2[MSFSAPStates2["YD"] = 262144] = "YD";
    MSFSAPStates2[MSFSAPStates2["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates2[MSFSAPStates2["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates2[MSFSAPStates2["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates2[MSFSAPStates2["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates2[MSFSAPStates2["Bank"] = 8388608] = "Bank";
    MSFSAPStates2[MSFSAPStates2["FBW"] = 16777216] = "FBW";
    MSFSAPStates2[MSFSAPStates2["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates2[MSFSAPStates2["None"] = -2147483648] = "None";
  })(MSFSAPStates || (MSFSAPStates = {}));
  var airportIcaoRegionPattern = new RegExp(/^A../);
  var FacilityTypeSearchType = {
    [FacilityType.Airport]: FacilitySearchType.Airport,
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    [FacilityType.VOR]: FacilitySearchType.Vor,
    [FacilityType.USR]: FacilitySearchType.User,
    [FacilityType.VIS]: FacilitySearchType.Visual
  };
  var FacilityLoader = class {
    constructor(facilityRepo, onInitialized = () => {
    }) {
      this.facilityRepo = facilityRepo;
      this.onInitialized = onInitialized;
      if (FacilityLoader.facilityListener === void 0) {
        FacilityLoader.facilityListener = RegisterViewListener("JS_LISTENER_FACILITY", () => {
          FacilityLoader.facilityListener.on("SendAirport", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendIntersection", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendVor", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendNdb", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("NearestSearchCompleted", FacilityLoader.onNearestSearchCompleted);
          setTimeout(() => FacilityLoader.init(), 2e3);
        }, true);
      }
      this.awaitInitialization().then(() => this.onInitialized());
    }
    static init() {
      FacilityLoader.isInitialized = true;
      for (const resolve of this.initPromiseResolveQueue) {
        resolve();
      }
      this.initPromiseResolveQueue.length = 0;
    }
    awaitInitialization() {
      if (FacilityLoader.isInitialized) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          FacilityLoader.initPromiseResolveQueue.push(resolve);
        });
      }
    }
    getFacility(type, icao) {
      switch (type) {
        case FacilityType.USR:
        case FacilityType.RWY:
        case FacilityType.VIS:
          return this.getFacilityFromRepo(type, icao);
        default:
          return this.getFacilityFromCoherent(type, icao);
      }
    }
    async getFacilityFromRepo(type, icao) {
      const fac = this.facilityRepo.get(icao);
      if (fac) {
        return fac;
      } else if (type === FacilityType.RWY) {
        try {
          const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
          const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
          if (runway) {
            const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
            this.facilityRepo.add(runwayFac);
            return runwayFac;
          }
        } catch (e) {
        }
      }
      throw `Facility ${icao} could not be found.`;
    }
    async getFacilityFromCoherent(type, icao) {
      const isMismatch = ICAO.getFacilityType(icao) !== type;
      if (type === FacilityType.Airport) {
        icao = icao.replace(airportIcaoRegionPattern, "A  ");
      }
      let queue = FacilityLoader.requestQueue;
      let cache = FacilityLoader.facCache;
      if (isMismatch) {
        queue = FacilityLoader.mismatchRequestQueue;
        cache = FacilityLoader.typeMismatchFacCache;
      }
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const cachedFac = cache.get(icao);
      if (cachedFac !== void 0) {
        return Promise.resolve(cachedFac);
      }
      const currentTime = Date.now();
      let request = queue.get(icao);
      if (request === void 0 || currentTime - request.timeStamp > 1e4) {
        if (request !== void 0) {
          request.reject(`Facility request for ${icao} has timed out.`);
        }
        let resolve = void 0;
        let reject = void 0;
        const promise = new Promise((resolution, rejection) => {
          resolve = resolution;
          reject = rejection;
          Coherent.call(type, icao).then((isValid) => {
            if (!isValid) {
              rejection(`Facility ${icao} could not be found.`);
              queue.delete(icao);
            }
          });
        });
        request = { promise, timeStamp: currentTime, resolve, reject };
        queue.set(icao, request);
      }
      return request.promise;
    }
    async getAirway(airwayName, airwayType, icao) {
      if (FacilityLoader.airwayCache.has(airwayName)) {
        const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
        const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
          w.icao === icao;
        });
        if (match !== void 0 && cachedAirway !== void 0) {
          return cachedAirway;
        }
      }
      const fac = await this.getFacility(FacilityType.Intersection, icao);
      const route = fac.routes.find((r) => r.name === airwayName);
      if (route !== void 0) {
        const airwayBuilder = new AirwayBuilder(fac, route, this);
        const status = await airwayBuilder.startBuild();
        if (status === AirwayStatus.COMPLETE) {
          const waypoints = airwayBuilder.waypoints;
          if (waypoints !== null) {
            const airway = new AirwayObject(airwayName, airwayType);
            airway.waypoints = [...waypoints];
            FacilityLoader.addToAirwayCache(airway);
            return airway;
          }
        }
      }
      throw new Error("Airway could not be found.");
    }
    async startNearestSearchSession(type) {
      switch (type) {
        case FacilitySearchType.User:
        case FacilitySearchType.Visual:
          return this.startRepoNearestSearchSession(type);
        case FacilitySearchType.AllExceptVisual:
          return this.startCoherentNearestSearchSession(FacilitySearchType.All);
        default:
          return this.startCoherentNearestSearchSession(type);
      }
    }
    async startCoherentNearestSearchSession(type) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const sessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", type);
      let session;
      switch (type) {
        case FacilitySearchType.Airport:
          session = new NearestAirportSearchSession(sessionId);
          break;
        case FacilitySearchType.Intersection:
          session = new NearestIntersectionSearchSession(sessionId);
          break;
        case FacilitySearchType.Vor:
          session = new NearestVorSearchSession(sessionId);
          break;
        case FacilitySearchType.Boundary:
          session = new NearestBoundarySearchSession(sessionId);
          break;
        default:
          session = new CoherentNearestSearchSession(sessionId);
          break;
      }
      FacilityLoader.searchSessions.set(sessionId, session);
      return session;
    }
    startRepoNearestSearchSession(type) {
      const sessionId = FacilityLoader.repoSearchSessionId--;
      switch (type) {
        case FacilitySearchType.User:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        case FacilitySearchType.Visual:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        default:
          throw new Error();
      }
    }
    async getMetar(arg) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const ident = typeof arg === "string" ? arg : ICAO.getIdent(arg.icao);
      const metar = await Coherent.call("GET_METAR_BY_IDENT", ident);
      return FacilityLoader.cleanMetar(metar);
    }
    async searchMetar(lat, lon) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const metar = await Coherent.call("GET_METAR_BY_LATLON", lat, lon);
      return FacilityLoader.cleanMetar(metar);
    }
    static cleanMetar(raw) {
      if (raw.icao === "") {
        return void 0;
      }
      raw.gust < 0 && delete raw.gust;
      raw.vertVis < 0 && delete raw.vertVis;
      isNaN(raw.altimeterA) && delete raw.altimeterA;
      raw.altimeterQ < 0 && delete raw.altimeterQ;
      isNaN(raw.slp) && delete raw.slp;
      return raw;
    }
    async searchByIdent(filter, ident, maxItems = 40) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      let results;
      if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
        const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
        results = await Coherent.call("SEARCH_BY_IDENT", ident, coherentFilter, maxItems);
      } else {
        results = [];
      }
      const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
      if (facRepositorySearchTypes) {
        this.facilityRepo.forEach((fac) => {
          const facIdent = ICAO.getIdent(fac.icao);
          if (facIdent === ident) {
            results.unshift(fac.icao);
          } else if (facIdent.startsWith(ident)) {
            results.push(fac.icao);
          }
        }, facRepositorySearchTypes);
      }
      return results;
    }
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
      const results = await this.searchByIdent(filter, ident, maxItems);
      if (!results) {
        return [];
      }
      const promises = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i];
        const facIdent = ICAO.getIdent(icao);
        if (facIdent === ident) {
          const facType = ICAO.getFacilityType(icao);
          promises.push(this.getFacility(facType, icao));
        }
      }
      const foundFacilities = await Promise.all(promises);
      if (foundFacilities.length > 1) {
        foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
        return foundFacilities;
      } else if (foundFacilities.length === 1) {
        return foundFacilities;
      } else {
        return [];
      }
    }
    static onFacilityReceived(facility) {
      const isMismatch = facility["__Type"] === "JS_FacilityIntersection" && facility.icao[0] !== "W";
      const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
      const request = queue.get(facility.icao);
      if (request !== void 0) {
        request.resolve(facility);
        FacilityLoader.addToFacilityCache(facility, isMismatch);
        queue.delete(facility.icao);
      }
    }
    static onNearestSearchCompleted(results) {
      const session = FacilityLoader.searchSessions.get(results.sessionId);
      if (session instanceof CoherentNearestSearchSession) {
        session.onSearchCompleted(results);
      }
    }
    static addToFacilityCache(fac, isTypeMismatch) {
      const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
      cache.set(fac.icao, fac);
      if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
        cache.delete(cache.keys().next().value);
      }
    }
    static addToAirwayCache(airway) {
      FacilityLoader.airwayCache.set(airway.name, airway);
      if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
        FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
      }
    }
  };
  FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1e3;
  FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1e3;
  FacilityLoader.requestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.mismatchRequestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.facCache = /* @__PURE__ */ new Map();
  FacilityLoader.typeMismatchFacCache = /* @__PURE__ */ new Map();
  FacilityLoader.airwayCache = /* @__PURE__ */ new Map();
  FacilityLoader.searchSessions = /* @__PURE__ */ new Map();
  FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
  };
  FacilityLoader.repoSearchSessionId = -1;
  FacilityLoader.isInitialized = false;
  FacilityLoader.initPromiseResolveQueue = [];
  var CoherentNearestSearchSession = class {
    constructor(sessionId) {
      this.sessionId = sessionId;
      this.searchQueue = /* @__PURE__ */ new Map();
    }
    searchNearest(lat, lon, radius, maxItems) {
      const promise = new Promise((resolve) => {
        Coherent.call("SEARCH_NEAREST", this.sessionId, lat, lon, radius, maxItems).then((searchId) => {
          this.searchQueue.set(searchId, { promise, resolve });
        });
      });
      return promise;
    }
    onSearchCompleted(results) {
      const request = this.searchQueue.get(results.searchId);
      if (request !== void 0) {
        request.resolve(results);
        this.searchQueue.delete(results.searchId);
      }
    }
  };
  var NearestAirportSearchSession = class extends CoherentNearestSearchSession {
    setAirportFilter(showClosed, classMask) {
      Coherent.call("SET_NEAREST_AIRPORT_FILTER", this.sessionId, showClosed ? 1 : 0, classMask);
    }
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      Coherent.call("SET_NEAREST_EXTENDED_AIRPORT_FILTERS", this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
  };
  NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
  };
  var NearestIntersectionSearchSession = class extends CoherentNearestSearchSession {
    setIntersectionFilter(typeMask) {
      Coherent.call("SET_NEAREST_INTERSECTION_FILTER", this.sessionId, typeMask);
    }
  };
  NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
  };
  var NearestVorSearchSession = class extends CoherentNearestSearchSession {
    setVorFilter(classMask, typeMask) {
      Coherent.call("SET_NEAREST_VOR_FILTER", this.sessionId, classMask, typeMask);
    }
  };
  NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
  };
  var NearestBoundarySearchSession = class extends CoherentNearestSearchSession {
    setBoundaryFilter(classMask) {
      Coherent.call("SET_NEAREST_BOUNDARY_FILTER", this.sessionId, classMask);
    }
  };
  var NearestRepoFacilitySearchSession = class {
    constructor(repo, sessionId) {
      this.repo = repo;
      this.sessionId = sessionId;
      this.filter = void 0;
      this.cachedResults = /* @__PURE__ */ new Set();
      this.searchId = 0;
    }
    searchNearest(lat, lon, radius, maxItems) {
      const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
      const added = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i].icao;
        if (this.cachedResults.has(icao)) {
          this.cachedResults.delete(icao);
        } else {
          added.push(icao);
        }
      }
      const removed = Array.from(this.cachedResults);
      this.cachedResults.clear();
      for (let i = 0; i < results.length; i++) {
        this.cachedResults.add(results[i].icao);
      }
      return Promise.resolve({
        sessionId: this.sessionId,
        searchId: this.searchId++,
        added,
        removed
      });
    }
    setUserFacilityFilter(filter) {
      this.filter = filter;
    }
  };
  var AirwayObject = class {
    constructor(name, type) {
      this._waypoints = [];
      this._name = name;
      this._type = type;
    }
    get name() {
      return this._name;
    }
    get type() {
      return this._type;
    }
    get waypoints() {
      return this._waypoints;
    }
    set waypoints(waypoints) {
      this._waypoints = waypoints;
    }
  };
  var AirwayStatus;
  (function(AirwayStatus2) {
    AirwayStatus2[AirwayStatus2["INCOMPLETE"] = 0] = "INCOMPLETE";
    AirwayStatus2[AirwayStatus2["COMPLETE"] = 1] = "COMPLETE";
    AirwayStatus2[AirwayStatus2["PARTIAL"] = 2] = "PARTIAL";
  })(AirwayStatus || (AirwayStatus = {}));
  var AirwayBuilder = class {
    constructor(_initialWaypoint, _initialData, facilityLoader) {
      this._initialWaypoint = _initialWaypoint;
      this._initialData = _initialData;
      this.facilityLoader = facilityLoader;
      this._waypointsArray = [];
      this._hasStarted = false;
      this._isDone = false;
    }
    get hasStarted() {
      return this._hasStarted;
    }
    get isDone() {
      return this._isDone;
    }
    get waypoints() {
      return this._waypointsArray;
    }
    async _step(stepForward, arrayInsertFunc) {
      let isDone = false;
      let current = this._initialData;
      while (!isDone && current) {
        const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
        if (nextICAO && nextICAO.length > 0 && nextICAO[0] != " " && this._waypointsArray !== null && !this._waypointsArray.find((waypoint) => waypoint.icao === nextICAO)) {
          const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
          arrayInsertFunc(fac);
          const next = fac.routes.find((route) => route.name === current.name);
          if (next !== void 0) {
            current = next;
          } else {
            isDone = true;
          }
        } else {
          isDone = true;
        }
      }
    }
    async _stepForward() {
      if (this._waypointsArray !== null) {
        return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
      }
    }
    async _stepBackward() {
      if (this._waypointsArray !== null) {
        return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
      }
    }
    setWaypointsArray(array) {
      this._waypointsArray = array;
    }
    startBuild() {
      if (this.hasStarted) {
        return Promise.reject(new Error("Airway builder has already started building."));
      }
      return new Promise((resolve) => {
        this._hasStarted = true;
        if (this._waypointsArray !== null) {
          this._waypointsArray.push(this._initialWaypoint);
          Promise.all([
            this._stepForward(),
            this._stepBackward()
          ]).then(() => {
            this._isDone = true;
            resolve(AirwayStatus.COMPLETE);
          }).catch(() => {
            this._isDone = true;
            resolve(AirwayStatus.PARTIAL);
          });
        }
      });
    }
  };
  var ArrayUtils = class {
    static create(length, init2) {
      const newArray = [];
      for (let i = 0; i < length; i++) {
        newArray[i] = init2(i);
      }
      return newArray;
    }
    static at(array, index) {
      if (index < 0) {
        index += array.length;
      }
      if (index < 0 || index >= array.length) {
        throw new RangeError();
      }
      return array[index];
    }
    static peekAt(array, index) {
      if (index < 0) {
        index += array.length;
      }
      return array[index];
    }
    static first(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[0];
    }
    static peekFirst(array) {
      return array[0];
    }
    static last(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[array.length - 1];
    }
    static peekLast(array) {
      return array[array.length - 1];
    }
    static includes(array, searchElement, fromIndex) {
      return array.includes(searchElement, fromIndex);
    }
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalsFunc(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    static flatMap(array, map) {
      const out = [];
      for (let i = 0; i < array.length; i++) {
        const mapped = map(array[i], i, array);
        if (Array.isArray(mapped)) {
          for (let j = 0; j < mapped.length; j++) {
            out[out.length] = mapped[j];
          }
        } else {
          out[out.length] = mapped;
        }
      }
      return out;
    }
    static flat(array, depth = 1) {
      const out = [];
      this.flatHelper(array, depth, 0, out);
      return out;
    }
    static flatHelper(array, maxDepth, depth, out) {
      for (let i = 0; i < array.length; i++) {
        const element = array[i];
        if (Array.isArray(element) && depth < maxDepth) {
          this.flatHelper(element, maxDepth, depth + 1, out);
        } else {
          out[out.length] = element;
        }
      }
    }
    static shallowCopy(source, target = []) {
      target.length = source.length;
      for (let i = 0; i < source.length; i++) {
        target[i] = source[i];
      }
      return target;
    }
    static binarySearch(array, element, comparator, first = true) {
      let min = 0;
      let max = array.length;
      let index = Math.floor((min + max) / 2);
      while (min < max) {
        const compare = comparator(element, array[index]);
        if (compare < 0) {
          max = index;
        } else if (compare > 0) {
          min = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min + max) / 2);
      }
      return -(index + 1);
    }
    static getMaxStringLength(array) {
      return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
  };
  ArrayUtils.STRICT_EQUALS = (a, b) => a === b;
  var BinaryHeap = class {
    constructor(comparator) {
      this.comparator = comparator;
      this.tree = [];
    }
    get size() {
      return this.tree.length;
    }
    findMin() {
      return this.tree[0];
    }
    removeMin() {
      if (this.tree.length === 0) {
        return void 0;
      }
      const min = this.tree[0];
      this.swap(0, this.tree.length - 1);
      this.tree.length--;
      this.heapifyDown(0);
      return min;
    }
    insert(element) {
      this.tree.push(element);
      this.heapifyUp(this.tree.length - 1);
      return this;
    }
    insertAndRemoveMin(element) {
      if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
        return element;
      }
      return this.removeMinAndInsert(element);
    }
    removeMinAndInsert(element) {
      const min = this.tree[0];
      this.tree[0] = element;
      this.heapifyDown(0);
      return min;
    }
    clear() {
      this.tree.length = 0;
      return this;
    }
    heapifyUp(index) {
      let parent = BinaryHeap.parent(index);
      while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
        this.swap(parent, index);
        index = parent;
        parent = BinaryHeap.parent(index);
      }
    }
    heapifyDown(index) {
      const len = this.tree.length;
      while (index < len) {
        const left = BinaryHeap.left(index);
        const right = BinaryHeap.right(index);
        let needSwapFlags = 0;
        if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
          needSwapFlags |= 1;
        }
        if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
          needSwapFlags |= 2;
        }
        if (needSwapFlags === 3) {
          needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
        }
        if (needSwapFlags === 0) {
          break;
        }
        const swapChild = needSwapFlags === 1 ? left : right;
        this.swap(index, swapChild);
        index = swapChild;
      }
    }
    swap(index1, index2) {
      const old1 = this.tree[index1];
      this.tree[index1] = this.tree[index2];
      this.tree[index2] = old1;
    }
    static parent(index) {
      return index - 1 >> 1;
    }
    static left(index) {
      return index * 2 + 1;
    }
    static right(index) {
      return index * 2 + 2;
    }
  };
  var SortedArray = class {
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
      this.comparatorFunc = comparatorFunc;
      this.equalityFunc = equalityFunc;
      this._array = [];
    }
    get array() {
      return this._array;
    }
    get length() {
      return this._array.length;
    }
    findIndex(element, first = true) {
      let min = 0;
      let max = this._array.length;
      let index = Math.floor((min + max) / 2);
      while (min < max) {
        const compare = this.comparatorFunc(element, this._array[index]);
        if (compare < 0) {
          max = index;
        } else if (compare > 0) {
          min = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min + max) / 2);
      }
      return -(index + 1);
    }
    searchEquals(element, startIndex) {
      let index = startIndex;
      while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
        if (this.equalityFunc(element, this._array[index])) {
          return index;
        }
        index++;
      }
      return -1;
    }
    get(index) {
      if (index < 0 || index >= this._array.length) {
        throw new RangeError();
      }
      return this._array[index];
    }
    peek(index) {
      return this._array[index];
    }
    first() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[0];
    }
    peekFirst() {
      return this._array[0];
    }
    last() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[this._array.length - 1];
    }
    peekLast() {
      return this._array[this._array.length - 1];
    }
    has(element) {
      return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    insert(element) {
      let index = this.findIndex(element, false);
      if (index < 0) {
        index = -index - 1;
      }
      this._array.splice(index, 0, element);
      return index;
    }
    insertAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let toInsertIndex = 0;
      let toInsert = sorted[toInsertIndex];
      const len = this._array.length;
      const insertLen = sorted.length;
      for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
        if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
          this._array.splice(i, 0, toInsert);
          toInsert = sorted[++toInsertIndex];
        }
      }
      for (; toInsertIndex < insertLen; toInsertIndex++) {
        this._array.push(sorted[toInsertIndex]);
      }
      return sorted.length;
    }
    remove(element) {
      const index = this.searchEquals(element, this.findIndex(element));
      if (index >= 0) {
        this._array.splice(index, 1);
      }
      return index;
    }
    removeAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let numRemoved = 0;
      let toRemoveIndex = 0;
      let toRemove = sorted[toRemoveIndex];
      const len = this._array.length;
      const removeLen = sorted.length;
      for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
        if (this.equalityFunc(toRemove, this._array[i])) {
          this._array.splice(i--, 1);
          toRemove = sorted[++toRemoveIndex];
          numRemoved++;
        }
      }
      return numRemoved;
    }
    removeAt(index) {
      if (index < 0 || index >= this._array.length) {
        return void 0;
      }
      return this._array.splice(index, 1)[0];
    }
    pop() {
      return this._array.pop();
    }
    shift() {
      return this._array.shift();
    }
    resort() {
      this._array.sort(this.comparatorFunc);
    }
    indexOf(element) {
      return this.searchEquals(element, this.findIndex(element));
    }
    match(query) {
      const index = this.matchIndex(query);
      return this._array[index];
    }
    matchIndex(query) {
      return this.findIndex(query);
    }
    clear() {
      this._array.length = 0;
    }
    values() {
      return this._array.values();
    }
    [Symbol.iterator]() {
      return this._array.values();
    }
  };
  SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var LerpLookupTable = class {
    constructor(arg) {
      this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg === "number") {
        this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
        return;
      }
      const leastDimension = arg.reduce((accum, current) => current.length < accum.length ? current : accum);
      this._dimensionCount = Math.max(0, leastDimension ? leastDimension.length - 1 : 0);
      if (this._dimensionCount === 0) {
        return;
      }
      for (let i = 0; i < arg.length; i++) {
        this.insertBreakpoint(arg[i]);
      }
    }
    get dimensionCount() {
      return this._dimensionCount;
    }
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    get(...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table);
      if (value === void 0) {
        throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    lookupHelper(key, dimension, lookupArray) {
      const dimensionKey = key[dimension];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array);
        endValue = this.lookupHelper(key, dimension + 1, end.array);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      if (startValue === endValue) {
        return startValue;
      }
      return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpLookupTable.tempBreakpoint = { key: 0 };
  var LerpVectorLookupTable = class {
    constructor(arg1, arg2) {
      var _a, _b;
      this.table = new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg1 === "number") {
        this._dimensionCount = isFinite(arg1) ? 0 : Math.max(0, arg1);
        this._vectorLength = isFinite(arg2) ? 0 : Math.max(0, arg2);
      } else {
        let leastBreakpointDimension = Infinity;
        let leastVectorLength = Infinity;
        for (let i = 0; i < arg1.length; i++) {
          leastBreakpointDimension = Math.min(leastBreakpointDimension, Math.max(arg1[i].length - 1, 0));
          leastVectorLength = Math.min(leastVectorLength, (_b = (_a = arg1[i][0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        }
        this._dimensionCount = isFinite(leastBreakpointDimension) ? leastBreakpointDimension : 0;
        this._vectorLength = isFinite(leastVectorLength) ? leastVectorLength : 0;
        if (this._dimensionCount > 0) {
          for (let i = 0; i < arg1.length; i++) {
            this.insertBreakpoint(arg1[i]);
          }
        }
      }
      this.tempVectors = ArrayUtils.create(this._dimensionCount * 2, () => new Float64Array(this._vectorLength));
    }
    get dimensionCount() {
      return this._dimensionCount;
    }
    get vectorLength() {
      return this._vectorLength;
    }
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      if (breakpoint[0].length < this._vectorLength) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint[0].length}-length vector into a table with vectors of length ${this._vectorLength}`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    get(out, ...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table, out);
      if (value === void 0) {
        throw new Error(`LerpVectorLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    lookupHelper(key, dimension, lookupArray, out) {
      const dimensionKey = key[dimension];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array, this.tempVectors[dimension * 2]);
        endValue = this.lookupHelper(key, dimension + 1, end.array, this.tempVectors[dimension * 2 + 1]);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      return MathUtils.lerpVector(out, dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpVectorLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpVectorLookupTable.tempBreakpoint = { key: 0 };
  var KdTree = class {
    constructor(dimensionCount, keyFunc) {
      this.keyFunc = keyFunc;
      this.elements = [];
      this.keys = [];
      this.nodes = [];
      this.minDepth = -1;
      this.maxDepth = -1;
      this.dimensionCount = Math.trunc(dimensionCount);
      if (this.dimensionCount < 2) {
        throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
      }
      this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
      this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
        return (a, b) => {
          const aKey = this.keys[a];
          const bKey = this.keys[b];
          for (let i = 0; i < this.dimensionCount; i++) {
            const dimension = (i + index) % this.dimensionCount;
            if (aKey[dimension] < bKey[dimension]) {
              return -1;
            } else if (aKey[dimension] > bKey[dimension]) {
              return 1;
            }
          }
          return 0;
        };
      });
      this.keyCache = [
        new Float64Array(this.dimensionCount)
      ];
    }
    get size() {
      return this.elements.length;
    }
    searchKey(key, radius, arg3, out, filter) {
      if (typeof arg3 === "number") {
        return this.doResultsSearch(void 0, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(void 0, key, radius, arg3);
      }
    }
    search(element, radius, arg3, out, filter) {
      const key = this.keyFunc(element, this.keyCache[0]);
      if (typeof arg3 === "number") {
        return this.doResultsSearch(element, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(element, key, radius, arg3);
      }
    }
    doVisitorSearch(element, key, radius, visitor) {
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        return visitor(elementInner, keyInner, distance, queryKey, queryElement);
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        return searchRadius + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
      if (maxResultCount <= 0) {
        out.length = 0;
        return out;
      }
      const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
          if (heap.size === maxResultCount) {
            heap.insertAndRemoveMin(elementIndex);
          } else {
            heap.insert(elementIndex);
          }
        }
        return true;
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        let maxDist = searchRadius;
        if (heap.size === maxResultCount) {
          maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
        }
        return maxDist + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
      out.length = heap.size;
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = this.elements[heap.removeMin()];
      }
      return out;
    }
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
      const elementIndex = this.nodes[nodeIndex];
      if (elementIndex === void 0) {
        return true;
      }
      const nodeKey = this.keys[elementIndex];
      const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
      if (distanceFromNode <= radius) {
        if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
          return false;
        }
      }
      const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      const lesserNodeIndex = KdTree.lesser(nodeIndex);
      const greaterNodeIndex = KdTree.greater(nodeIndex);
      if (this.nodes[lesserNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, -1)) {
        if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      if (this.nodes[greaterNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, 1)) {
        if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      return true;
    }
    insert(element) {
      const insertDepth = this.insertElementInTree(element) + 1;
      this.maxDepth = Math.max(this.maxDepth, insertDepth);
      if (insertDepth === this.minDepth + 1) {
        this.minDepth = KdTree.depth(this.nodes.indexOf(void 0, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
      }
      if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
        this.rebuild();
      }
    }
    insertAll(elements) {
      for (const element of elements) {
        this.elements.push(element);
        this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
        const insertedIndex = this.elements.length - 1;
        for (let i = 0; i < this.dimensionCount; i++) {
          this.indexArrays[i].push(insertedIndex);
        }
      }
      this.rebuild();
    }
    insertElementInTree(element) {
      const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
      let index = 0;
      let depth = 0;
      let elementIndex;
      while ((elementIndex = this.nodes[index]) !== void 0) {
        const pivotDimension = depth % this.dimensionCount;
        const keyToCompare = key[pivotDimension];
        if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
          index = KdTree.lesser(index);
        } else {
          index = KdTree.greater(index);
        }
        depth++;
      }
      this.elements.push(element);
      this.keys.push(key);
      const insertedIndex = this.elements.length - 1;
      this.nodes[index] = insertedIndex;
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].push(insertedIndex);
      }
      return depth;
    }
    remove(element) {
      if (!this.removeElementFromArrays(element)) {
        return false;
      }
      this.resetIndexArrays();
      this.rebuild();
      return true;
    }
    removeAll(elements) {
      let removed = false;
      for (const element of elements) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
        this.rebuild();
      }
      return removed;
    }
    removeElementFromArrays(element) {
      const index = this.elements.indexOf(element);
      if (index < 0) {
        return false;
      }
      const lastIndex = this.elements.length - 1;
      this.elements[index] = this.elements[lastIndex];
      this.keys[index] = this.keys[lastIndex];
      this.elements.length--;
      this.keys.length--;
      return true;
    }
    resetIndexArrays() {
      for (let i = 0; i < this.dimensionCount; i++) {
        const array = this.indexArrays[i];
        array.length = this.elements.length;
        for (let j = 0; j < array.length; j++) {
          array[j] = j;
        }
      }
    }
    removeAndInsert(toRemove, toInsert) {
      let removed = false;
      for (const element of toRemove) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
      }
      this.insertAll(toInsert);
    }
    rebuild() {
      this.nodes.length = 0;
      if (this.size === 0) {
        return;
      }
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].sort(this.indexSortFuncs[i]);
      }
      this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
      const log = Math.log2(this.elements.length + 1);
      this.minDepth = Math.floor(log) - 1;
      this.maxDepth = Math.ceil(log) - 1;
    }
    buildSubTree(nodeIndex, pivotDimension, start, end) {
      const tempArray = this.indexArrays[this.dimensionCount];
      const sortedArray = this.indexArrays[0];
      const medianIndex = Math.trunc((start + end) / 2);
      const medianKeyIndex = sortedArray[medianIndex];
      this.nodes[nodeIndex] = medianKeyIndex;
      if (end - start === 1) {
        return;
      }
      if (end - start <= 3) {
        const lesserIndex = medianIndex - 1;
        const greaterIndex = medianIndex + 1;
        if (lesserIndex >= start) {
          this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
        }
        if (greaterIndex < end) {
          this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
        }
        return;
      }
      for (let i = start; i < end; i++) {
        tempArray[i] = sortedArray[i];
      }
      for (let i = 1; i < this.dimensionCount; i++) {
        const targetArray = this.indexArrays[i - 1];
        const toPartitionArray = this.indexArrays[i];
        let lesserCount = 0;
        let greaterCount = 0;
        for (let j = start; j < end; j++) {
          const keyIndex = toPartitionArray[j];
          if (keyIndex === medianKeyIndex) {
            targetArray[medianIndex] = keyIndex;
          } else {
            const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
            if (comparison <= 0) {
              const index = start + lesserCount++;
              targetArray[index] = keyIndex;
            } else {
              const index = medianIndex + 1 + greaterCount++;
              targetArray[index] = keyIndex;
            }
          }
        }
      }
      const newSortedArray = this.indexArrays[this.dimensionCount - 1];
      for (let i = start; i < end; i++) {
        newSortedArray[i] = tempArray[i];
      }
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
      this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    clear() {
      this.elements.length = 0;
      this.keys.length = 0;
      this.nodes.length = 0;
      for (let i = 0; i < this.indexArrays.length; i++) {
        this.indexArrays[i].length = 0;
      }
      this.minDepth = -1;
      this.maxDepth = -1;
    }
    static parent(index) {
      return index - 1 >> 1;
    }
    static lesser(index) {
      return index * 2 + 1;
    }
    static greater(index) {
      return index * 2 + 2;
    }
    static leastIndexAtDepth(depth) {
      return 1 << depth - 1;
    }
    static depth(index) {
      return Math.trunc(Math.log2(index + 1));
    }
    static distance(key1, key2, dimensionCount) {
      let sumSq = 0;
      for (let i = 0; i < dimensionCount; i++) {
        const diff = key1[i] - key2[i];
        sumSq += diff * diff;
      }
      return Math.sqrt(sumSq);
    }
  };
  var GeoKdTree = class {
    constructor(keyFunc) {
      this.keyFunc = keyFunc;
      this.cartesianTree = new KdTree(3, (element, out) => {
        const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
        out[0] = vec[0];
        out[1] = vec[1];
        out[2] = vec[2];
        return out;
      });
    }
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
      let center, radius;
      let argA, argB, argC;
      if (typeof arg1 === "number") {
        center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
        radius = arg3;
        argA = arg4;
        argB = arg5;
        argC = arg6;
      } else if (!(arg1 instanceof Float64Array)) {
        center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      } else {
        center = arg1;
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      }
      const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
      if (typeof argA === "number") {
        return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
      } else {
        this.doVisitorSearch(center, radiusCartesian, argA);
      }
    }
    doVisitorSearch(center, radiusCartesian, visitor) {
      this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return visitor(element, vec, greatCircleDist, center);
      });
    }
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
      const cartesianFilter = filter ? (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return filter(element, vec, greatCircleDist, center);
      } : void 0;
      return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    insert(element) {
      this.cartesianTree.insert(element);
    }
    insertAll(elements) {
      this.cartesianTree.insertAll(elements);
    }
    remove(element) {
      return this.cartesianTree.remove(element);
    }
    removeAll(elements) {
      return this.cartesianTree.removeAll(elements);
    }
    removeAndInsert(toRemove, toInsert) {
      this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    rebuild() {
      this.cartesianTree.rebuild();
    }
    clear() {
      this.cartesianTree.clear();
    }
  };
  GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  var SubscribableArrayEventType;
  (function(SubscribableArrayEventType2) {
    SubscribableArrayEventType2["Added"] = "Added";
    SubscribableArrayEventType2["Removed"] = "Removed";
    SubscribableArrayEventType2["Cleared"] = "Cleared";
  })(SubscribableArrayEventType || (SubscribableArrayEventType = {}));
  var AbstractSubscribableArray = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    get(index) {
      const array = this.getArray();
      if (index > array.length - 1) {
        throw new Error("Index out of range");
      }
      return array[index];
    }
    tryGet(index) {
      return this.getArray()[index];
    }
    notify(index, type, modifiedItem) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(index, type, modifiedItem, this.getArray());
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ArraySubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    initialNotify(sub) {
      const array = this.getArray();
      sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
  };
  var FacilityRepositorySyncType;
  (function(FacilityRepositorySyncType2) {
    FacilityRepositorySyncType2["Add"] = "Add";
    FacilityRepositorySyncType2["Remove"] = "Remove";
    FacilityRepositorySyncType2["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType2["DumpResponse"] = "DumpResponse";
  })(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
  var FacilityRepository = class {
    constructor(bus) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.repos = /* @__PURE__ */ new Map();
      this.trees = {
        [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc)
      };
      this.ignoreSync = false;
      bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
      this.pubSyncEvent({
        type: FacilityRepositorySyncType.DumpRequest,
        uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
      });
    }
    size(types) {
      var _a, _b;
      let size = 0;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          size += repo.size;
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        }
      }
      return size;
    }
    get(icao) {
      var _a;
      if (!ICAO.isFacility(icao)) {
        return void 0;
      }
      return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    search(type, lat, lon, radius, arg5, out, filter) {
      if (type !== FacilityType.USR && type !== FacilityType.VIS) {
        throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
      }
      if (typeof arg5 === "number") {
        return this.trees[type].search(lat, lon, radius, arg5, out, filter);
      } else {
        this.trees[type].search(lat, lon, radius, arg5);
      }
    }
    add(fac) {
      if (!ICAO.isFacility(fac.icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
      }
      this.addToRepo(fac);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    addMultiple(facs) {
      this.addMultipleToRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    remove(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      if (!ICAO.isFacility(icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
      }
      this.removeFromRepo(icao);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    removeMultiple(facs) {
      this.removeMultipleFromRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map((fac) => typeof fac === "object" ? fac.icao : fac) });
    }
    forEach(fn, types) {
      var _a;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          repo.forEach(fn);
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
      }
    }
    addToRepo(fac) {
      const facilityType = ICAO.getFacilityType(fac.icao);
      let repo = this.repos.get(facilityType);
      if (repo === void 0) {
        this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
      }
      const existing = repo.get(fac.icao);
      repo.set(fac.icao, fac);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        if (existing === void 0) {
          this.trees[facilityType].insert(fac);
        } else {
          this.trees[facilityType].removeAndInsert([existing], [fac]);
        }
      }
      if (existing === void 0) {
        this.publisher.pub("facility_added", fac, false, false);
      } else {
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    addMultipleToRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const addedFacilities = [];
      const changedFacilitiesRemoved = [];
      const changedFacilitiesAdded = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === void 0) {
          this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (existing === void 0) {
          addedFacilities.push(fac);
        } else {
          changedFacilitiesRemoved.push(existing);
          changedFacilitiesAdded.push(fac);
        }
      }
      const addedUserFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (addedUserFacilities.length > 0) {
        const removedUserFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
      }
      const addedVisFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (addedVisFacilities.length > 0) {
        const removedVisFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
      }
      for (let i = 0; i < addedFacilities.length; i++) {
        const fac = addedFacilities[i];
        this.publisher.pub("facility_added", fac, false, false);
      }
      for (let i = 0; i < changedFacilitiesAdded.length; i++) {
        const fac = changedFacilitiesAdded[i];
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    removeFromRepo(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      const facilityType = ICAO.getFacilityType(icao);
      const repo = this.repos.get(ICAO.getFacilityType(icao));
      if (repo === void 0) {
        return;
      }
      const facilityInRepo = repo.get(icao);
      if (facilityInRepo === void 0) {
        return;
      }
      repo.delete(icao);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        this.trees[facilityType].remove(facilityInRepo);
      }
      this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
      this.publisher.pub("facility_removed", facilityInRepo, false, false);
    }
    removeMultipleFromRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const removedFacilities = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const icao = typeof fac === "string" ? fac : fac.icao;
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === void 0) {
          continue;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === void 0) {
          continue;
        }
        repo.delete(icao);
        removedFacilities.push(facilityInRepo);
      }
      const removedUserFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (removedUserFacilities.length > 0) {
        this.trees[FacilityType.USR].removeAll(removedUserFacilities);
      }
      const removedVisFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (removedVisFacilities.length > 0) {
        this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
      }
      for (let i = 0; i < removedFacilities.length; i++) {
        const removedFac = removedFacilities[i];
        this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
        this.publisher.pub("facility_removed", removedFac, false, false);
      }
    }
    pubSyncEvent(data) {
      this.ignoreSync = true;
      this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
      this.ignoreSync = false;
    }
    onSyncEvent(data) {
      if (this.ignoreSync) {
        return;
      }
      switch (data.type) {
        case FacilityRepositorySyncType.DumpResponse:
          if (data.uid !== this.lastDumpRequestUid) {
            break;
          } else {
            this.lastDumpRequestUid = void 0;
          }
        case FacilityRepositorySyncType.Add:
          if (data.facs.length === 1) {
            this.addToRepo(data.facs[0]);
          } else {
            this.addMultipleToRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.Remove:
          if (data.facs.length === 1) {
            this.removeFromRepo(data.facs[0]);
          } else {
            this.removeMultipleFromRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.DumpRequest:
          if (data.uid !== this.lastDumpRequestUid) {
            const facs = [];
            this.forEach((fac) => facs.push(fac));
            this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
          }
          break;
      }
    }
    static getRepository(bus) {
      var _a;
      return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : FacilityRepository.INSTANCE = new FacilityRepository(bus);
    }
  };
  FacilityRepository.SYNC_TOPIC = "facilityrepo_sync";
  FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
  };
  var HoldEntryType;
  (function(HoldEntryType2) {
    HoldEntryType2[HoldEntryType2["Direct"] = 0] = "Direct";
    HoldEntryType2[HoldEntryType2["Teardrop"] = 1] = "Teardrop";
    HoldEntryType2[HoldEntryType2["Parallel"] = 2] = "Parallel";
    HoldEntryType2[HoldEntryType2["None"] = 3] = "None";
  })(HoldEntryType || (HoldEntryType = {}));
  var HoldMaxSpeedRule;
  (function(HoldMaxSpeedRule2) {
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Faa"] = 0] = "Faa";
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Icao"] = 1] = "Icao";
  })(HoldMaxSpeedRule || (HoldMaxSpeedRule = {}));
  var SubscribableUtils = class {
    static isSubscribable(query) {
      return typeof query === "object" && query !== null && query.isSubscribable === true;
    }
    static isMutableSubscribable(query) {
      return typeof query === "object" && query !== null && query.isMutableSubscribable === true;
    }
    static toSubscribable(value, excludeSubscribables) {
      if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
        return value;
      } else {
        return Subject.create(value);
      }
    }
  };
  SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || isNaN(a) && isNaN(b);
  var facilitySearchTypeMap = /* @__PURE__ */ new Map([
    [FacilitySearchType.Airport, FacilityType.Airport],
    [FacilitySearchType.Intersection, FacilityType.Intersection],
    [FacilitySearchType.Vor, FacilityType.VOR],
    [FacilitySearchType.Ndb, FacilityType.NDB],
    [FacilitySearchType.User, FacilityType.USR]
  ]);
  var AbstractNearestSubscription = class extends AbstractSubscribableArray {
    constructor(facilityLoader, type) {
      super();
      this.facilityLoader = facilityLoader;
      this.type = type;
      this.facilities = [];
      this.facilityIndex = /* @__PURE__ */ new Map();
      this.startPromiseResolves = [];
      this.updatePromiseResolves = [];
      this.hasRequestedSession = false;
      this.searchInProgress = false;
    }
    get length() {
      return this.facilities.length;
    }
    get started() {
      return this.session !== void 0;
    }
    getArray() {
      return this.facilities;
    }
    awaitStart() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        this.startPromiseResolves.push(resolve);
      });
    }
    start() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      if (this.hasRequestedSession) {
        return this.awaitStart();
      }
      return new Promise((resolve) => {
        this.hasRequestedSession = true;
        this.startPromiseResolves.push(resolve);
        this.facilityLoader.startNearestSearchSession(this.type).then((session) => {
          this.session = session;
          this.startPromiseResolves.forEach((queuedResolve) => {
            queuedResolve();
          });
          this.startPromiseResolves.length = 0;
        });
      });
    }
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      if (!this.started) {
        await this.start();
      }
      const results = await this.session.searchNearest(lat, lon, radius, maxItems);
      await this.onResults(results);
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    addFacility(facility, key) {
      if (this.facilityIndex.has(key)) {
        console.warn(`Facility ${key} is already in the collection.`);
      }
      this.facilities.push(facility);
      this.facilityIndex.set(key, facility);
      this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, facility);
    }
    removeFacility(key) {
      const facility = this.facilityIndex.get(key);
      if (facility !== void 0) {
        const index = this.facilities.indexOf(facility);
        this.facilities.splice(index, 1);
        this.facilityIndex.delete(key);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Removed, facility);
      }
    }
  };
  var NearestWaypointSubscription = class extends AbstractNearestSubscription {
    constructor(facilityLoader, type, filterCb) {
      super(facilityLoader, type);
      this.facilityCache = /* @__PURE__ */ new Map();
      this.filterCb = filterCb;
    }
    setFilterCb(filter) {
      this.filterCb = filter;
      this.refilter();
    }
    refilter() {
      if (this.filterCb) {
        for (const icao of this.facilityIndex.keys()) {
          if (!this.filterCb(this.facilityIndex.get(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
          this.addFacility(this.facilityCache.get(icao), icao);
        }
      }
    }
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          this.facilityCache.set(added[i].icao, added[i]);
          if (this.filterCb === void 0 || this.filterCb(added[i])) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestAirportSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader, filterCb) {
      super(facilityLoader, FacilitySearchType.Airport, filterCb);
    }
    setFilter(showClosed, classMask) {
      if (this.session !== void 0) {
        this.session.setAirportFilter(showClosed, classMask);
      }
    }
    setExtendedFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      if (this.session !== void 0) {
        this.session.setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
      }
    }
  };
  var NearestIntersectionSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader, filterCb, filterDupTerminal = false) {
      super(facilityLoader, FacilitySearchType.Intersection, filterCb);
      this.nonTerminalIcaosToFilter = /* @__PURE__ */ new Set();
      this.filterDupTerminal = filterDupTerminal;
    }
    setFilter(typeMask) {
      if (this.session !== void 0) {
        this.session.setIntersectionFilter(typeMask);
      }
    }
    setFilterDupTerminal(filter) {
      if (filter === this.filterDupTerminal) {
        return;
      }
      this.filterDupTerminal = filter;
      this.refilter();
    }
    refilter() {
      this.nonTerminalIcaosToFilter.clear();
      if (this.filterDupTerminal) {
        for (const icao of this.facilityCache.keys()) {
          if (ICAO.isFacility(icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
            this.nonTerminalIcaosToFilter.add(icao);
          }
        }
      }
      if (this.filterCb || this.filterDupTerminal) {
        for (const icao of this.facilityIndex.keys()) {
          if (this.filterCb && !this.filterCb(this.facilityIndex.get(icao)) || this.filterDupTerminal && ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) && this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao)) {
          if ((this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao))) && (!this.filterDupTerminal || !ICAO.isFacility(icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(icao) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao)))) {
            this.addFacility(this.facilityCache.get(icao), icao);
          }
        }
      }
    }
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.nonTerminalIcaosToFilter.delete(results.removed[i]);
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          this.facilityCache.set(fac.icao, fac);
          if (this.filterDupTerminal && ICAO.isFacility(fac.icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(fac) && (this.filterCb === void 0 || this.filterCb(fac))) {
            this.nonTerminalIcaosToFilter.add(fac.icao);
          }
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          if ((this.filterCb === void 0 || this.filterCb(fac)) && (!this.filterDupTerminal || !ICAO.isFacility(fac.icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(fac) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(fac.icao)))) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestVorSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Vor);
    }
    setVorFilter(classMask, typeMask) {
      if (this.session !== void 0) {
        this.session.setVorFilter(classMask, typeMask);
      }
    }
  };
  var NearestNdbSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Ndb);
    }
  };
  var NearestUsrSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.User);
    }
  };
  var AdaptiveNearestSubscription = class extends AbstractSubscribableArray {
    constructor(innerSubscription, absoluteMaxItems) {
      super();
      this.innerSubscription = innerSubscription;
      this.sortFunc = (a, b) => this.pos.distance(a) - this.pos.distance(b);
      this.facilities = [];
      this.derivedMaxItems = 0;
      this.searchInProgress = false;
      this.pos = new GeoPoint(0, 0);
      this.diffMap = /* @__PURE__ */ new Map();
      this.updatePromiseResolves = [];
      this.absoluteMaxItems = SubscribableUtils.toSubscribable(absoluteMaxItems, true);
    }
    get length() {
      return this.facilities.length;
    }
    getArray() {
      return this.facilities;
    }
    get started() {
      return this.innerSubscription.started;
    }
    awaitStart() {
      return this.innerSubscription.awaitStart();
    }
    start() {
      return this.innerSubscription.start();
    }
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      this.pos.set(lat, lon);
      maxItems = Math.max(0, maxItems);
      if (maxItems > this.derivedMaxItems) {
        this.derivedMaxItems = maxItems;
      }
      await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
      if (this.innerSubscription.length > maxItems) {
        this.derivedMaxItems = Math.max(Math.round(this.derivedMaxItems - this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_DOWN_FACTOR), maxItems);
      } else {
        const absoluteMaxItems = this.absoluteMaxItems.get();
        while (this.innerSubscription.length < maxItems && this.derivedMaxItems < absoluteMaxItems) {
          this.derivedMaxItems = Math.min(Math.round(this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_UP_FACTOR), absoluteMaxItems);
          await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
        }
      }
      if (this.innerSubscription.length > maxItems) {
        if (maxItems > 1) {
          const sorted = Array.from(this.innerSubscription.getArray()).sort(this.sortFunc);
          sorted.length = maxItems;
          this.diffAndNotify(sorted);
        } else if (maxItems === 1) {
          this.diffAndNotify([this.findNearest(this.innerSubscription.getArray())]);
        } else {
          this.diffAndNotify(AdaptiveNearestSubscription.EMPTY_ARRAY);
        }
      } else {
        this.diffAndNotify(this.innerSubscription.getArray());
      }
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    findNearest(array) {
      let nearest = array[0];
      let nearestDistance = this.pos.distance(nearest);
      for (let i = 1; i < array.length; i++) {
        const fac = array[i];
        const distance = this.pos.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    diffAndNotify(newArray) {
      if (this.facilities.length === 0 && newArray.length === 0) {
        return;
      }
      if (newArray.length === 0) {
        this.facilities.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
        return;
      }
      if (this.facilities.length === 0) {
        for (let i = 0; i < newArray.length; i++) {
          this.facilities[i] = newArray[i];
        }
        this.facilities.length = newArray.length;
        this.notify(0, SubscribableArrayEventType.Added, this.facilities);
        return;
      }
      for (let i = 0; i < newArray.length; i++) {
        this.diffMap.set(newArray[i].icao, newArray[i]);
      }
      for (let i = this.facilities.length - 1; i >= 0; i--) {
        const old = this.facilities[i];
        if (this.diffMap.has(old.icao)) {
          this.diffMap.delete(old.icao);
        } else {
          this.facilities.splice(i, 1);
          this.notify(i, SubscribableArrayEventType.Removed, old);
        }
      }
      for (const toAdd of this.diffMap.values()) {
        this.facilities.push(toAdd);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, toAdd);
      }
      this.diffMap.clear();
    }
  };
  AdaptiveNearestSubscription.RAMP_UP_FACTOR = 1.33;
  AdaptiveNearestSubscription.RAMP_DOWN_FACTOR = 0.1;
  AdaptiveNearestSubscription.EMPTY_ARRAY = [];
  var LodBoundary = class {
    constructor(facility, lodDistanceThresholds, lodVectorCountTargets) {
      this.facility = facility;
      this.lodDistanceThresholds = (lodDistanceThresholds === null || lodDistanceThresholds === void 0 ? void 0 : lodDistanceThresholds.length) ? [...lodDistanceThresholds] : [0];
      this.lodVectorCountTargets = lodVectorCountTargets ? [...lodVectorCountTargets] : [];
      this.lods = this.processLods();
    }
    processLods() {
      var _a;
      const lodShapes = [];
      const originalShapes = this.processShapes(this.facility.vectors);
      if (Array.isArray(this.facility.lods)) {
        lodShapes.push(originalShapes);
        for (let i = 0; i < this.facility.lods.length; i++) {
          lodShapes.push(this.processShapes(this.facility.lods[i]));
        }
      } else {
        let startIndex = 0;
        if (this.lodDistanceThresholds[0] === 0 && ((_a = this.lodVectorCountTargets[0]) !== null && _a !== void 0 ? _a : 0) <= 0) {
          lodShapes.push(originalShapes);
          startIndex = 1;
        }
        const len = this.lodDistanceThresholds.length;
        for (let i = startIndex; i < len; i++) {
          lodShapes.push(this.simplifyShapes(originalShapes, this.lodDistanceThresholds[i], this.lodVectorCountTargets[i]));
        }
      }
      return lodShapes;
    }
    processShapes(vectors) {
      const shapes = [];
      const len = vectors.length;
      let index = 0;
      let currentShape;
      while (index < len) {
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            currentShape = [];
            index = this.processShape(currentShape, vectors, index);
            shapes.push(currentShape);
            break;
          case BoundaryVectorType.Circle:
            currentShape = [];
            index = this.processCircle(currentShape, vectors, index - 1);
            shapes.push(currentShape);
            break;
        }
        index++;
      }
      return shapes;
    }
    processShape(shape, vectors, index) {
      const start = vectors[index++];
      shape.push({ end: new GeoPoint(start.lat, start.lon) });
      const origins = [];
      const len = vectors.length;
      while (index < len) {
        const lastEndpoint = shape[shape.length - 1].end;
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            break;
          case BoundaryVectorType.Line:
            if (!lastEndpoint.equals(vector)) {
              shape.push({ circle: GeoCircle.createGreatCircle(lastEndpoint, vector), end: new GeoPoint(vector.lat, vector.lon) });
            }
            break;
          case BoundaryVectorType.Origin:
            origins[vector.originId] = vector;
            break;
          case BoundaryVectorType.ArcCCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const radius = end.distance(origin);
            shape.push({ circle: GeoCircle.createFromPoint(origin, radius), end });
            break;
          }
          case BoundaryVectorType.ArcCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const circle = GeoCircle.createFromPoint(origin, end.distance(origin)).reverse();
            shape.push({ circle, end });
            break;
          }
          case BoundaryVectorType.Circle:
            return index - 1;
        }
        index++;
      }
      return index - 1;
    }
    processCircle(shape, vectors, index) {
      const originVector = vectors[index];
      const circleVector = vectors[index + 1];
      if (originVector.type === BoundaryVectorType.Origin && circleVector.originId === originVector.originId) {
        const radius = UnitType.METER.convertTo(circleVector.radius, UnitType.GA_RADIAN);
        const circle = GeoCircle.createFromPoint(originVector, radius);
        const isCenterPole = circle.center[0] === 0 && circle.center[1] === 0 && Math.abs(circle.center[2]) === 1;
        const end = isCenterPole ? new GeoPoint(0, 0) : new GeoPoint(90, 0);
        circle.closest(end, end);
        shape.push({ end });
        shape.push({ circle, end });
      }
      return index + 1;
    }
    simplifyShapes(shapes, distanceThreshold, vectorCountTarget) {
      const simplified = [];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        simplified.push(this.simplifyShape(shapes[i], distanceThreshold, vectorCountTarget));
      }
      return simplified;
    }
    simplifyShape(shape, distanceThreshold, vectorCountTarget) {
      if (shape.length < 3) {
        return shape;
      }
      const simplified = [];
      const retain = [];
      retain[0] = true;
      retain[shape.length - 1] = true;
      if (vectorCountTarget === void 0 || vectorCountTarget <= 0) {
        this.simplify(distanceThreshold, shape, 0, shape.length, retain);
      } else {
        this.simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, 0, shape.length, retain);
      }
      this.rebuildSimplifiedVectors(shape, retain, simplified);
      return simplified;
    }
    simplify(distanceThreshold, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.index < 0) {
        return;
      }
      if (farthest.distance >= distanceThreshold) {
        retain[farthest.index] = true;
        this.simplify(distanceThreshold, shape, startIndex, farthest.index + 1, retain);
        this.simplify(distanceThreshold, shape, farthest.index, endIndex, retain);
      }
    }
    simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const queue = LodBoundary.queue;
      queue.clear();
      let edgeIndex = 0;
      let currentStartIndex = startIndex;
      let currentEndIndex = endIndex;
      let currentFarthestIndex;
      let retainCount = 2;
      while (retainCount < vectorCountTarget) {
        if (currentFarthestIndex === void 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentEndIndex, queue, edgeIndex++);
        } else if (currentFarthestIndex >= 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentFarthestIndex + 1, queue, edgeIndex++);
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentFarthestIndex, currentEndIndex, queue, edgeIndex++);
        }
        if (queue.size === 0) {
          break;
        }
        const edge = queue.removeMin();
        currentStartIndex = edge.startIndex;
        currentEndIndex = edge.endIndex;
        currentFarthestIndex = edge.farthestVectorIndex;
        retain[currentFarthestIndex] = true;
        retainCount++;
      }
    }
    computeAndInsertEdgeToQueue(distanceThreshold, shape, startIndex, endIndex, queue, edgeIndex) {
      var _a;
      var _b;
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.distance >= distanceThreshold) {
        const edge = (_a = (_b = LodBoundary.edgeCache)[edgeIndex]) !== null && _a !== void 0 ? _a : _b[edgeIndex] = LodBoundary.createEdge();
        edge.startIndex = startIndex;
        edge.endIndex = endIndex;
        edge.farthestVectorIndex = farthest.index;
        edge.distanceToFarthestVector = farthest.distance;
        queue.insert(edge);
      }
    }
    findFarthestVector(shape, startIndex, endIndex, reference) {
      let maxDistance = 0;
      let index = -1;
      for (let i = startIndex; i < endIndex; i++) {
        const distance = this.getDistanceFromReference(shape, i, reference);
        if (distance > maxDistance) {
          index = i;
          maxDistance = distance;
        }
      }
      return { index, distance: maxDistance };
    }
    getDistanceFromReference(shape, index, reference) {
      const vector = shape[index];
      if (!vector.circle) {
        return reference instanceof GeoCircle ? Math.abs(reference.distance(vector.end)) : reference.distance(vector.end);
      } else {
        const center = reference instanceof GeoCircle ? reference.center : reference;
        const arcStart = shape[index - 1].end;
        const maxAngularDist = vector.circle.angleAlong(arcStart, vector.end, Math.PI);
        const projectedAngularDist = vector.circle.angleAlong(arcStart, center, Math.PI);
        const oppositeAngularDist = (projectedAngularDist + Math.PI) % (2 * Math.PI);
        let arcDistance;
        if (oppositeAngularDist > 0 && oppositeAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center) + vector.circle.radius * 2);
          arcDistance = Math.min(arcDistance, 2 * Math.PI - arcDistance);
        } else if (projectedAngularDist > 0 && projectedAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center));
        }
        if (reference instanceof GeoCircle) {
          return arcDistance ? Math.abs(arcDistance - Math.PI / 2) : Math.abs(reference.distance(vector.end));
        } else {
          return arcDistance !== null && arcDistance !== void 0 ? arcDistance : vector.end.distance(reference);
        }
      }
    }
    rebuildSimplifiedVectors(shape, retain, simplified) {
      var _a;
      let lastRetained;
      const len = shape.length;
      for (let i = 0; i < len; i++) {
        if (!retain[i]) {
          continue;
        }
        const currentVector = shape[i];
        if (currentVector) {
          const prevRetain = retain[i - 1];
          const prevVector = shape[i - 1];
          if (!prevRetain) {
            if (lastRetained) {
              if (currentVector.circle && !currentVector.circle.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, prevVector.end), end: prevVector.end });
                simplified.push(LodBoundary.copyVector(currentVector));
              } else if ((_a = currentVector.circle) === null || _a === void 0 ? void 0 : _a.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, currentVector.end), end: currentVector.end });
              } else {
                simplified.push(LodBoundary.copyVector(currentVector));
              }
            } else {
              simplified.push({ end: currentVector.end });
            }
          } else {
            simplified.push(LodBoundary.copyVector(currentVector));
          }
          lastRetained = currentVector;
        }
      }
    }
    static copyVector(source) {
      return { circle: source.circle ? new GeoCircle(source.circle.center, source.circle.radius) : void 0, end: source.end.copy() };
    }
    static createEdge() {
      return {
        startIndex: -1,
        endIndex: -1,
        farthestVectorIndex: -1,
        distanceToFarthestVector: 0
      };
    }
  };
  LodBoundary.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  LodBoundary.edgeCache = [];
  LodBoundary.queue = new BinaryHeap((a, b) => b.distanceToFarthestVector - a.distanceToFarthestVector);
  var LodBoundaryCache = class {
    constructor(size, lodDistanceThresholds, lodVectorCountTargets) {
      this.size = size;
      this.lodDistanceThresholds = lodDistanceThresholds;
      this.lodVectorCountTargets = lodVectorCountTargets;
      this.cache = /* @__PURE__ */ new Map();
    }
    get(facility) {
      const existing = this.cache.get(facility.id);
      if (existing) {
        return existing;
      }
      return this.create(facility);
    }
    create(facility) {
      const boundary = new LodBoundary(facility, this.lodDistanceThresholds, this.lodVectorCountTargets);
      this.cache.set(facility.id, boundary);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
      return boundary;
    }
  };
  var ArrayTaskQueue = class {
    constructor(tasks) {
      this.tasks = tasks;
      this.head = 0;
    }
    hasNext() {
      return this.head < this.tasks.length;
    }
    next() {
      return this.tasks[this.head++];
    }
  };
  var ThrottledTaskQueueProcess = class {
    constructor(queue, handler) {
      this.queue = queue;
      this.handler = handler;
      this._hasStarted = false;
      this._hasEnded = false;
      this._shouldAbort = false;
    }
    hasStarted() {
      return this._hasStarted;
    }
    hasEnded() {
      return this._hasEnded;
    }
    start() {
      this._hasStarted = true;
      this.processQueue(0);
    }
    processQueue(elapsedFrameCount) {
      let dispatchCount = 0;
      const t0 = performance.now();
      while (!this._shouldAbort && this.queue.hasNext()) {
        if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
          const task = this.queue.next();
          task();
          dispatchCount++;
        } else {
          break;
        }
      }
      if (this._shouldAbort) {
        return;
      }
      if (!this.queue.hasNext()) {
        this.handler.onFinished(elapsedFrameCount);
        this._hasEnded = true;
      } else {
        this.handler.onPaused(elapsedFrameCount);
        requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
      }
    }
    abort() {
      if (this._hasStarted && !this._hasEnded) {
        this.handler.onAborted();
        this._shouldAbort = true;
        this._hasEnded = true;
      }
    }
  };
  var NearestLodBoundarySearchSession = class {
    constructor(cache, session, frameBudget) {
      this.cache = cache;
      this.session = session;
      this.frameBudget = frameBudget;
    }
    async searchNearest(lat, lon, radius, maxItems) {
      const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
      const results = { added: [], removed: facilityResults.removed };
      const tasks = facilityResults.added.map((fac, index) => () => {
        results.added[index] = this.cache.get(fac);
      });
      await new Promise((resolve) => {
        const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
        taskQueue.start();
      });
      return results;
    }
    setFilter(classMask) {
      this.session.setBoundaryFilter(classMask);
    }
  };
  var NearestLodBoundarySearchTaskQueueHandler = class {
    constructor(frameBudget, resolve) {
      this.frameBudget = frameBudget;
      this.resolve = resolve;
    }
    onStarted() {
    }
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
      return timeElapsed < this.frameBudget;
    }
    onPaused() {
    }
    onFinished() {
      this.resolve();
    }
    onAborted() {
    }
  };
  var FlightPathVectorFlags;
  (function(FlightPathVectorFlags2) {
    FlightPathVectorFlags2[FlightPathVectorFlags2["None"] = 0] = "None";
    FlightPathVectorFlags2[FlightPathVectorFlags2["TurnToCourse"] = 1] = "TurnToCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Arc"] = 2] = "Arc";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Direct"] = 4] = "Direct";
    FlightPathVectorFlags2[FlightPathVectorFlags2["InterceptCourse"] = 8] = "InterceptCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["CourseReversal"] = 512] = "CourseReversal";
    FlightPathVectorFlags2[FlightPathVectorFlags2["LegToLegTurn"] = 1024] = "LegToLegTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Fallback"] = 4096] = "Fallback";
  })(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
  var ProcedureDetails = class {
    constructor() {
      this.originRunway = void 0;
      this.departureIndex = -1;
      this.departureTransitionIndex = -1;
      this.departureRunwayIndex = -1;
      this.arrivalIndex = -1;
      this.arrivalTransitionIndex = -1;
      this.arrivalRunwayTransitionIndex = -1;
      this.arrivalRunway = void 0;
      this.approachIndex = -1;
      this.approachTransitionIndex = -1;
      this.destinationRunway = void 0;
    }
  };
  var FlightPlanSegmentType;
  (function(FlightPlanSegmentType2) {
    FlightPlanSegmentType2["Origin"] = "Origin";
    FlightPlanSegmentType2["Departure"] = "Departure";
    FlightPlanSegmentType2["Enroute"] = "Enroute";
    FlightPlanSegmentType2["Arrival"] = "Arrival";
    FlightPlanSegmentType2["Approach"] = "Approach";
    FlightPlanSegmentType2["Destination"] = "Destination";
    FlightPlanSegmentType2["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType2["RandomDirectTo"] = "RandomDirectTo";
  })(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
  var FlightPlanSegment = class {
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
      this.segmentIndex = segmentIndex;
      this.offset = offset;
      this.legs = legs;
      this.segmentType = segmentType;
      this.airway = airway;
    }
  };
  FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
  var LegDefinitionFlags;
  (function(LegDefinitionFlags2) {
    LegDefinitionFlags2[LegDefinitionFlags2["None"] = 0] = "None";
    LegDefinitionFlags2[LegDefinitionFlags2["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags2[LegDefinitionFlags2["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags2[LegDefinitionFlags2["Obs"] = 4] = "Obs";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
  })(LegDefinitionFlags || (LegDefinitionFlags = {}));
  var VerticalFlightPhase;
  (function(VerticalFlightPhase2) {
    VerticalFlightPhase2["Climb"] = "Climb";
    VerticalFlightPhase2["Descent"] = "Descent";
  })(VerticalFlightPhase || (VerticalFlightPhase = {}));
  var SpeedUnit;
  (function(SpeedUnit2) {
    SpeedUnit2[SpeedUnit2["IAS"] = 0] = "IAS";
    SpeedUnit2[SpeedUnit2["MACH"] = 1] = "MACH";
  })(SpeedUnit || (SpeedUnit = {}));
  var SpeedRestrictionType;
  (function(SpeedRestrictionType2) {
    SpeedRestrictionType2[SpeedRestrictionType2["Unused"] = 0] = "Unused";
    SpeedRestrictionType2[SpeedRestrictionType2["At"] = 1] = "At";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType2[SpeedRestrictionType2["Between"] = 4] = "Between";
  })(SpeedRestrictionType || (SpeedRestrictionType = {}));
  var FlightPathUtils = class {
    static createEmptyCircleVector() {
      return {
        vectorType: "circle",
        flags: FlightPathVectorFlags.None,
        radius: 0,
        centerX: 1,
        centerY: 0,
        centerZ: 0,
        startLat: 0,
        startLon: 0,
        endLat: 0,
        endLon: 0,
        distance: 0
      };
    }
    static setCircleVector(vector, circle, start, end, flags) {
      vector.flags = flags;
      vector.radius = circle.radius;
      vector.centerX = circle.center[0];
      vector.centerY = circle.center[1];
      vector.centerZ = circle.center[2];
      vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
      start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
      end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
      vector.startLat = start.lat;
      vector.startLon = start.lon;
      vector.endLat = end.lat;
      vector.endLon = end.lon;
      return vector;
    }
    static isVectorGreatCircle(vector) {
      return vector.radius === Math.PI / 2;
    }
    static setGeoCircleFromVector(vector, out) {
      return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    static getVectorTurnDirection(vector) {
      return vector.radius > MathUtils.HALF_PI ? "right" : "left";
    }
    static getVectorTurnRadius(vector) {
      return Math.min(vector.radius, Math.PI - vector.radius);
    }
    static getVectorInitialCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    static getVectorFinalCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    static getLegTrueCourse(leg, point, magVarFacility) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      const magVar = magVarFacility ? -magVarFacility.magneticVariation : Facilities.getMagVar(point.lat, point.lon);
      return NavMath.normalizeHeading(leg.course + magVar);
    }
    static getLegFinalPosition(legCalc, out) {
      if (legCalc.endLat !== void 0 && legCalc.endLon !== void 0) {
        return out.set(legCalc.endLat, legCalc.endLon);
      }
      return void 0;
    }
    static getLegFinalCourse(legCalc) {
      if (legCalc.flightPath.length > 0) {
        const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
        return this.getVectorFinalCourse(vector);
      }
      return void 0;
    }
    static getTurnCircle(center, radius, turnDirection, out) {
      out.set(center, radius);
      if (turnDirection === "right") {
        out.reverse();
      }
      return out;
    }
    static reverseTurnCircle(circle, out) {
      return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    static getTurnDirectionFromCircle(circle) {
      return circle.radius > MathUtils.HALF_PI ? "right" : "left";
    }
    static getTurnRadiusFromCircle(circle) {
      return Math.min(circle.radius, Math.PI - circle.radius);
    }
    static getTurnCenterFromCircle(circle, out) {
      return circle.radius > MathUtils.HALF_PI ? out instanceof Float64Array ? Vec3Math.multScalar(circle.center, -1, out) : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2]) : out instanceof Float64Array ? Vec3Math.copy(circle.center, out) : out.setFromCartesian(circle.center);
    }
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
      }
      const radius = turnDirection === "left" ? turnRadius : Math.PI - turnRadius;
      const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
      const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
      return out.set(turnCenter, radius);
    }
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      return circle.arcLength((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
        return posAngularDistance >= Math.PI ? -Infinity : Infinity;
      }
      return ((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angularTolerance = circle.angularWidth(tolerance);
      if (typeof end !== "number") {
        end = circle.angleAlong(start, end, Math.PI, angularTolerance);
      }
      if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
        return true;
      }
      const angle = circle.angleAlong(start, pos, Math.PI);
      if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
        return true;
      }
      const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
      return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    static projectVelocityToCircle(speed, position, direction, projectTo) {
      if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      if (speed === 0) {
        return 0;
      }
      if (!(position instanceof Float64Array)) {
        position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
      }
      const velocityPath = typeof direction === "number" ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction) : direction.isGreatCircle() ? direction : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
      const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
      const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
      const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
      const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
      const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
      return speed * sinTheta * sign;
    }
    static resolveIngressToEgress(legCalc) {
      var _a, _b, _c, _d, _e, _f;
      var _g, _h, _j, _k, _l, _m;
      const vectors = legCalc.ingressToEgress;
      let vectorIndex = 0;
      let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
      const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
      const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
      const firstEgressVector = legCalc.egress[0];
      const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
      if (lastIngressVector && ingressJoinVector) {
        const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
        const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
        const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon) : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
        const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
        const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
        if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
          if (ingressEndAlongVectorDistance > normalizedTolerance) {
            ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
            FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : vectors[_g] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
          } else {
            Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : vectors[_h] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVector);
          }
        }
        flightPathVectorIndex++;
      }
      const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
      for (let i = flightPathVectorIndex; i < end; i++) {
        Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : vectors[_j] = FlightPathUtils.createEmptyCircleVector(), legCalc.flightPath[i]);
        flightPathVectorIndex++;
      }
      if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
        if (firstEgressVector) {
          const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
          const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
          const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
          const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
          const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
          const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
          if (egressStartAlongVectorDistance > normalizedTolerance) {
            if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
              egressJoinVectorCircle.closest(egressStart, egressStart);
              FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : vectors[_k] = FlightPathUtils.createEmptyCircleVector(), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
            } else {
              Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : vectors[_l] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
            }
          }
        } else {
          Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : vectors[_m] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
        }
      }
      vectors.length = vectorIndex;
      return legCalc;
    }
  };
  FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var CircleVectorBuilder = class {
    build(vectors, index, ...args) {
      if (args[0] instanceof GeoCircle) {
        this.setFromCircle(vectors, index, ...args);
      } else {
        this.setFromPoints(vectors, index, ...args);
      }
      return 1;
    }
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
      return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
      var _a;
      const vector = ((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === "circle" ? vectors[index] : vectors[index] = FlightPathUtils.createEmptyCircleVector();
      return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
  };
  CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var GreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, pathArg, endArg, flags) {
      if (pathArg instanceof GeoCircle) {
        return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
      } else {
        return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
      }
    }
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
      const startPoint = start instanceof Float64Array ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start) : GreatCircleBuilder.geoPointCache[0].set(start);
      const endPoint = end instanceof Float64Array ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end) : GreatCircleBuilder.geoPointCache[1].set(end);
      const distance = startPoint.distance(endPoint);
      const path = GreatCircleBuilder.geoCircleCache[0];
      if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
        if (initialCourse === void 0) {
          throw new Error("GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.");
        } else {
          path.setAsGreatCircle(start, initialCourse);
        }
      } else {
        path.setAsGreatCircle(start, end);
      }
      return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
      if (!path.isGreatCircle()) {
        throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
      }
      const end = typeof endArg === "number" ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI) : endArg;
      return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
  };
  GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
  GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var TurnToCourseBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
      if (start instanceof Float64Array) {
        start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
      }
      const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === "left" ? -90 : 90), radiusRad);
      const turnStartBearing = turnCenterPoint.bearingTo(start);
      const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
      if (turnEndPoint.equals(start)) {
        return 0;
      }
      return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
  };
  TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var CircleInterceptBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, pathArg, circle, flags = 0) {
      if (circle.includes(start)) {
        return 0;
      }
      let startPath;
      if (pathArg instanceof GeoCircle) {
        if (!pathArg.includes(start)) {
          throw new Error("CircleInterceptBuilder: the starting point does not lie on the starting path.");
        }
        startPath = pathArg;
      } else {
        startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
      }
      const intersections = CircleInterceptBuilder.intersectionCache;
      const numIntersections = startPath.intersection(circle, intersections);
      if (numIntersections === 0) {
        return 0;
      }
      const intersectionIndex = numIntersections === 1 || circle.encircles(start) ? 0 : 1;
      const endVec = intersections[intersectionIndex];
      return startPath.isGreatCircle() ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags) : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
  };
  CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
      if (!endPath.isGreatCircle()) {
        throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
      }
      let startPath;
      if (startPathArg instanceof GeoCircle) {
        if (!startPathArg.isGreatCircle()) {
          throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
        } else if (!startPathArg.includes(start)) {
          throw new Error("TurnToJoinPathBuilder: the starting point does not lie on the starting path.");
        }
        startPath = startPathArg;
      } else {
        startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
      }
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
      }
      const turnDirection = endPath.encircles(start) ? "left" : "right";
      const radiusRad = turnDirection === "left" ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
      const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
      const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === "left" ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
  };
  TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var ConnectCirclesBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, fromCircle, toCircle, radius, from, to, fromCircleVectorFlags = 0, toCircleVectorFlags = 0, connectVectorFlags = 0) {
      if (radius === 0) {
        return 0;
      }
      const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
      if (angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius || Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE) {
        return 0;
      }
      if (from && !(from instanceof Float64Array)) {
        from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
      }
      if (to && !(to instanceof Float64Array)) {
        to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
      }
      const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
      const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
      if (!joinCircle) {
        return 0;
      }
      let vectorIndex = index;
      const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
      const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
      if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart, fromCircleVectorFlags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd, connectVectorFlags);
      if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to, toCircleVectorFlags);
      }
      return vectorIndex - index;
    }
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
      const solutions = [];
      const intersections = ConnectCirclesBuilder.intersectionCache;
      const leftTurnRadius = radius;
      let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
      let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
      let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
      let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
      const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
      if (numLeftTurnSolutions === 1) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
      } else if (numLeftTurnSolutions === 2) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
      }
      if (radius !== Math.PI / 2) {
        const rightTurnRadius = Math.PI - radius;
        fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
        toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
        fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
        toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
        const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numRightTurnSolutions === 1) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
        } else if (numRightTurnSolutions === 2) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
          solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
        }
      }
      if (solutions.length === 0) {
        return null;
      } else if (solutions.length === 1) {
        return out.set(solutions[0].center, solutions[0].radius);
      } else {
        let circle = solutions[0];
        let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
        for (let i = 1; i < solutions.length; i++) {
          const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
          if (distance < minDistance) {
            circle = solutions[i];
            minDistance = distance;
          }
        }
        return out.set(circle.center, circle.radius);
      }
    }
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
      let distance = 0;
      const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
      const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
      if (from) {
        distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
      }
      distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
      if (to) {
        distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
      }
      return distance;
    }
  };
  ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleAtPointBuilder = class {
    constructor() {
      this.connectCirclesBuilder = new ConnectCirclesBuilder();
    }
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, end, endPath, endTurnRadius, endTurnDirection, startTurnVectorFlags = 0, endTurnVectorFlags = 0, connectVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[1]);
      }
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      const startTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
      const startTurnCircleRadiusRad = startTurnDirection === "left" ? startTurnRadiusRad : Math.PI - startTurnRadiusRad;
      const startTurnCircleCenter = startTurnOffsetPath.offsetDistanceAlong(start, startTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const startTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].set(startTurnCircleCenter, startTurnCircleRadiusRad);
      const endTurnRadiusRad = UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      const endTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
      const endTurnCircleRadiusRad = endTurnDirection === "left" ? endTurnRadiusRad : Math.PI - endTurnRadiusRad;
      const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const endTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
      return this.connectCirclesBuilder.build(vectors, index, startTurnCircle, endTurnCircle, void 0, start, end, startTurnVectorFlags, endTurnVectorFlags, connectVectorFlags);
    }
  };
  TurnToJoinGreatCircleAtPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleAtPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var InterceptGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
      }
      const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
      if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
      const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
      const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      if (startTurnDirection === void 0) {
        const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
        if (interceptCount === 0) {
          startTurnDirection = startPath.encircles(end) ? "left" : "right";
        } else {
          let intersectionIndex = 0;
          if (interceptCount > 1) {
            intersectionIndex = endPath.encircles(start) ? 0 : 1;
          }
          let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
          if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
            cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
              startTurnDirection = "right";
            } else {
              startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? "left" : "right";
            }
          } else {
            startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? "left" : "right";
          }
        }
      }
      const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
      const endTurnRadiusRad = endTurnRadius === void 0 ? void 0 : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        const startTurnEnd2 = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd2, end, Math.PI);
        if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd2, startTurnVectorFlags);
      }
      const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
      const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
      if (interceptPathCount === 0) {
        return 0;
      }
      const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
      let interceptCrossSign;
      if (startToEndPathAngleRad >= interceptAngleRad) {
        const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
        const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
        interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
        interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === "right") ? 1 : -1;
      } else {
        interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
        interceptCrossSign = startTurnDirection === "right" ? 1 : -1;
      }
      const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
      const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
      const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      let minDInterceptEnd = 0;
      if (endTurnRadiusRad !== void 0) {
        const endTheta = Math.PI - interceptAngleRad;
        minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
        if (isNaN(minDInterceptEnd)) {
          return 0;
        }
      }
      const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
      if (interceptToEndOffset < minDInterceptEnd) {
        return 0;
      }
      let vectorIndex = index;
      if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
        if (endTurnRadiusRad === void 0) {
          const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
          if (startTurnEndPathIntersectionCount === 0) {
            return 0;
          }
          const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === "right" ? 0 : 1];
          if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
        } else {
          const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
          const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === "left" ? 1 : -1));
          const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
          if (endTurnCircleCount === 0) {
            return 0;
          }
          const endTurnCenter = intersections[0];
          const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === "left" ? "right" : "left", InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
          endTurnCircle.closest(startTurnCenter, startTurnEnd);
          const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
        }
      } else {
        if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        let interceptPathEnd = intercept;
        if (endTurnRadiusRad !== void 0) {
          interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
        }
        if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
        }
        if (endTurnRadius !== void 0) {
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
        }
      }
      return vectorIndex - index;
    }
  };
  InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var JoinGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
      this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
      }
      if (!intersection) {
        const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
        const solutionCount = startPath.intersection(endPath, intersections);
        if (solutionCount === 0) {
          return 0;
        }
        intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0 ? intersections[0] : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
      const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
      const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const isEndForwardOfIntersection = intersectionToEndSign > 0;
      minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : minTurnRadius = 0;
      const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
      const pathDot = Vec3Math.dot(startPath.center, endPath.center);
      const theta = Math.acos(-pathDot);
      const tanHalfTheta = Math.tan(theta / 2);
      let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
      if (isNaN(minD)) {
        minD = Infinity;
      }
      const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
      const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
      const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
      const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
      const towardEndPointTurnDirection = startPath.encircles(end, false) ? "left" : "right";
      let needCalculateTwoTurnPath = false;
      let needCalculateOneTurnPath = false;
      if (isEndForwardOfIntersection) {
        if (desiredTurnDirection === void 0 || desiredTurnDirection === towardEndPointTurnDirection) {
          const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
          const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
          if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          } else {
            const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
            if (intersectionStartDistance <= intersectionEndDistance) {
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
              if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
              }
            } else {
              let turnStart = start;
              if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
              }
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
            }
          }
        } else {
          if (pathDot >= 0) {
            if (intersectionStartOffset <= minD) {
              needCalculateOneTurnPath = true;
            } else {
              needCalculateTwoTurnPath = !preferSingleTurn;
              needCalculateOneTurnPath = preferSingleTurn;
            }
          } else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          }
        }
      } else {
        needCalculateTwoTurnPath = !preferSingleTurn;
        needCalculateOneTurnPath = preferSingleTurn;
      }
      let needDirectFallback = false;
      if (needCalculateTwoTurnPath) {
        const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
        const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, void 0, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
        if (numInterceptVectors === 0) {
          needDirectFallback = allowDirectFallback;
        } else {
          vectorIndex += numInterceptVectors;
          const lastVector = vectors[vectorIndex - 1];
          const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
          if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
          }
        }
      } else if (needCalculateOneTurnPath) {
        minD = Math.min(minD, Math.PI / 2);
        if (minD > Math.PI / 2) {
          needDirectFallback = allowDirectFallback;
        } else {
          const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
          const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
          const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
          const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
          if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
          }
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
          if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
          }
        }
      }
      if (needDirectFallback) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
      }
      return vectorIndex - index;
    }
  };
  JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45;
  JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var ProcedureTurnBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
      }
      initialCourse !== null && initialCourse !== void 0 ? initialCourse : initialCourse = startPath.bearingAt(start, Math.PI);
      finalCourse !== null && finalCourse !== void 0 ? finalCourse : finalCourse = endPath.bearingAt(end, Math.PI);
      const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
      const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
      const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === "left");
      const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
      const thetaOutbound = (Math.PI - deltaOutbound) / 2;
      const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : initialTurnDirection === "left" === deltaOutbound < Math.PI ? "right" : "left";
      const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
      let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10 ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1) : 0;
      desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound)) * (isInitialTurnTowardEndPath ? 1 : -1);
      const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
      let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
      desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
      desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
      const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
      const initialTurnStartPoint = alongStartPathDistance > 0 ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1]) : startPoint;
      const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
      const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
      const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
      const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === "left" ? -1 : 1));
      const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
      const turnStartPoint = alongTurnOutboundPathDistance > 0 ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4]) : initialTurnEndPoint;
      const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
      const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
      let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
      const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
      let finalTurnDirection;
      let finalTurnRadius;
      let finalTurnStartPoint;
      let finalTurnCenterPoint;
      let finalTurnEndPoint;
      let endPoint;
      if (endPath.encircles(turnEndVec) === (initialTurnDirection === "left")) {
        const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnCircle.intersection(endPath, intersections);
        if (numIntersections === 0) {
          endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
        } else {
          if (numIntersections === 2) {
            const headingAdjustment = turnDirection === "left" ? -90 : 90;
            const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
          } else {
            turnEndPoint.setFromCartesian(intersections[0]);
          }
          turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
        }
      } else {
        const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
        const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnInboundPath.intersection(endPath, intersections);
        if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
          const intersection = intersections[numIntersections === 1 || endPath.encircles(turnEndVec) ? 0 : 1];
          if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
            const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
            const thetaInbound = (Math.PI - deltaInbound) / 2;
            const tanThetaInbound = Math.tan(thetaInbound);
            const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
            const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
            const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance ? desiredTurnRadiusRad : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
            finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
            finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
            finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
            finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === "left" ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
            finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
          }
        }
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      if (initialTurnStartPoint !== startPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
      if (turnStartPoint !== initialTurnEndPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
      if (finalTurnCenterPoint) {
        if (!finalTurnStartPoint.equals(turnEndPoint)) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, void 0, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
      } else {
        if (endPoint) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, void 0, flags);
        }
      }
      return vectorIndex - index;
    }
  };
  ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0)
  ];
  ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var DirectToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
    }
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
      let vectorIndex = index;
      if (typeof startPath === "number") {
        startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
      }
      const endPos = DirectToPointBuilder.geoPointCache[0];
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        endPos.set(end);
        end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
      } else {
        endPos.setFromCartesian(end);
      }
      const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
      if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
        return vectorIndex - index;
      } else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
        return vectorIndex - index;
      }
      const startPathEncirclesTerminator = startPath.encircles(end);
      const startPathIncludesTerminator = startPath.includes(end);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPathEncirclesTerminator && !startPathIncludesTerminator ? "left" : "right";
      const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === "left" ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2]) : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
      let maxTurnRadiusRad;
      if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === "left")) {
        const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
        const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
        maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
      } else {
        maxTurnRadiusRad = Math.PI / 2;
      }
      const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
      const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
      const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
      const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
      const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
      const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
      const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === "left" ? -1 : 1) + 180);
      const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
      const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
      flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
      if (!GeoPoint.equals(turnEndVec, start)) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
      }
      if (!GeoPoint.equals(turnEndVec, end)) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, void 0, flags);
      }
      return vectorIndex - index;
    }
  };
  DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var AbstractFlightPathLegCalculator = class {
    constructor(facilityCache, skipWhenActive = false) {
      this.facilityCache = facilityCache;
      this.skipWhenActive = skipWhenActive;
    }
    getPositionFromIcao(icao, out) {
      const facility = this.facilityCache.get(icao);
      return facility ? out.set(facility) : void 0;
    }
    getTerminatorPosition(leg, icao, out) {
      if (leg.lat !== void 0 && leg.lon !== void 0) {
        return out.set(leg.lat, leg.lon);
      } else {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility.lat, facility.lon) : void 0;
      }
    }
    getLegMagVar(leg, point) {
      const facIcao = leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR) ? leg.originIcao : leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR) ? leg.fixIcao : void 0;
      const facility = facIcao !== void 0 ? this.facilityCache.get(facIcao) : void 0;
      return facility === void 0 ? MagVar.get(point) : -facility.magneticVariation;
    }
    getLegTrueCourse(leg, point) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
      var _a, _b, _c;
      var _d;
      const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : _d.calculated = {
        courseMagVar: 0,
        startLat: void 0,
        startLon: void 0,
        endLat: void 0,
        endLon: void 0,
        distance: 0,
        distanceWithTransitions: 0,
        initialDtk: void 0,
        cumulativeDistance: 0,
        cumulativeDistanceWithTransitions: 0,
        flightPath: [],
        ingress: [],
        ingressJoinIndex: -1,
        ingressToEgress: [],
        egressJoinIndex: -1,
        egress: [],
        endsInFallback: false
      };
      const vectors = calcs.flightPath;
      if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
        state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
        state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
        state.isFallback = calcs.endsInFallback;
        return calcs;
      }
      try {
        this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
        this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
        resolveIngressToEgress && this.resolveIngressToEgress(calcs);
        calcs.endsInFallback = state.isFallback;
      } catch (e) {
        console.error(e);
        if (e instanceof Error) {
          console.error(e.stack);
        }
        vectors.length = 0;
        calcs.ingress.length = 0;
        calcs.ingressJoinIndex = 0;
        calcs.egress.length = 0;
        calcs.egressJoinIndex = -1;
        calcs.ingressToEgress.length = 0;
        calcs.endsInFallback = false;
        state.isFallback = false;
      }
      return calcs;
    }
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
      return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    resolveIngressToEgress(legCalc) {
      FlightPathUtils.resolveIngressToEgress(legCalc);
    }
  };
  var CourseToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    constructor(facilityCache) {
      super(facilityCache, true);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0)
      ];
      this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
      this.procTurnBuilder = new ProcedureTurnBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const leg = legs[calculateIndex].leg;
      const prevLeg = legs[calculateIndex - 1];
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : void 0;
      const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
      if (!endPoint) {
        vectors.length = vectorIndex;
        state.isFallback = false;
        return;
      }
      const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
      if (state.isFallback && state.currentPosition !== void 0 && state.currentCourse !== void 0) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, void 0, FlightPathVectorFlags.Fallback);
        state.isFallback = false;
      } else {
        state.isFallback = false;
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM)) {
          const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        } else {
          const startVec = startPoint.toCartesian(this.vec3Cache[0]);
          const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
          const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
          const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
          const isStartEqualToEnd = startPoint.equals(endPoint);
          const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
          if (!leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type) && threshold.encircles(startVec, false)) {
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
            (_d = state.currentCourse) !== null && _d !== void 0 ? _d : state.currentCourse = currentCourse;
            state.isFallback = true;
          } else {
            const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
            if (pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE) {
              let desiredTurnDirection;
              switch (leg.turnDirection) {
                case LegTurnDirection.Left:
                  desiredTurnDirection = "left";
                  break;
                case LegTurnDirection.Right:
                  desiredTurnDirection = "right";
                  break;
                default: {
                  const endDistanceFromStartPath = startPath.distance(endVec);
                  if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? "left" : "right";
                  } else {
                    desiredTurnDirection = endDistanceFromStartPath < 0 ? "left" : "right";
                  }
                }
              }
              vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === "left" ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
              if (vectorIndex > 0) {
                const lastVector2 = vectors[vectorIndex - 1];
                const interceptVec = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                  vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector2.endLat, lastVector2.endLon), endPoint);
                }
              }
            } else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE || !isStartEqualToEnd && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 || ((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))) {
              if (!isStartEqualToEnd) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
              }
            } else {
              const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : void 0;
              vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
              const lastVector2 = vectors[vectorIndex - 1];
              if (lastVector2 !== void 0 && Math.abs(FlightPathUtils.getVectorFinalCourse(lastVector2) - endCourse) > 1 && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                let startTurnCircle;
                let startTurnEnd;
                const isLastVectorGreatCircle = FlightPathUtils.isVectorGreatCircle(lastVector2);
                if (isLastVectorGreatCircle && vectors[vectorIndex - 2] !== void 0) {
                  const startTurnVector = vectors[vectorIndex - 2];
                  startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                  startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[2]);
                } else if (!isLastVectorGreatCircle) {
                  startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPath.encircles(endVec) ? "left" : "right", this.geoCircleCache[3]);
                  if (Math.min(lastVector2.radius, Math.PI - lastVector2.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                    startTurnEnd = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                  }
                }
                if (startTurnCircle !== void 0) {
                  const intersections = this.intersectionCache;
                  const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                  if (intersectionCount === 1) {
                    if (threshold.encircles(FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, this.vec3Cache[2]))) {
                      vectorIndex = 0;
                      ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
                      (_h = state.currentCourse) !== null && _h !== void 0 ? _h : state.currentCourse = currentCourse;
                      state.isFallback = true;
                    }
                  } else if (startTurnEnd === void 0 || intersectionCount === 2) {
                    const thresholdCrossing = intersections[0];
                    const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                    if (startTurnEnd === void 0 || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                      vectorIndex = 0;
                      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                      state.isFallback = true;
                    }
                  }
                }
              }
            }
          }
        }
      }
      const lastVector = vectors[vectorIndex - 1];
      if (lastVector !== void 0) {
        ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : state.currentPosition = new GeoPoint(0, 0)).set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
      }
      vectors.length = vectorIndex;
    }
  };
  CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
  ];
  var FlightPathTurnCalculator = class {
    constructor() {
      this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
      var _a, _b, _c, _d, _e, _f;
      const end = startIndex + count;
      let currentIndex = startIndex;
      while (currentIndex < end) {
        const fromLegCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
        const toLegCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
        if (fromLegCalc && toLegCalc) {
          const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
          const toVector = toLegCalc.flightPath[0];
          if (fromVector && toVector && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn)) && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
              currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
              continue;
            } else if (toVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
              continue;
            } else if (fromVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
              continue;
            }
          }
        }
        if (fromLegCalc && BitFlags.isAll((_d = (_c = fromLegCalc.egress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
          fromLegCalc.egress.length = 0;
          fromLegCalc.egressJoinIndex = -1;
        }
        if (toLegCalc && BitFlags.isAll((_f = (_e = toLegCalc.ingress[0]) === null || _e === void 0 ? void 0 : _e.flags) !== null && _f !== void 0 ? _f : 0, FlightPathVectorFlags.LegToLegTurn)) {
          toLegCalc.ingress.length = 0;
          toLegCalc.ingressJoinIndex = -1;
        }
        currentIndex++;
      }
    }
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
      const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
      const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
      if (trackAngleDiff < 1 || fromTrack.distance === 0 || toTrack.distance === 0 || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      if (trackAngleDiff > 175) {
        return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
      }
      const theta = (180 - trackAngleDiff) / 2;
      const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
      const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
      let restrictedD = Infinity;
      if (isRestrictedByPrevTurn) {
        if (previousTanTheta === void 0) {
          if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
            const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
            restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
          }
        } else {
          const tanThetaRatio = previousTanTheta / tanTheta;
          const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
          const cosTotalD = Math.cos(totalD);
          let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
          if (prevTurnRestrictedD > totalD) {
            prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
          }
          restrictedD = prevTurnRestrictedD;
        }
      }
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          let nextTurnRestrictedD;
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
          }
          restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
        }
      }
      const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
      const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
      const turnRadiusRad = desiredD === D ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN) : Math.atan(Math.sin(D) * tanTheta);
      if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
      const turnBisectorBearing = toTrackBearing + theta * (turnDirection === "left" ? -1 : 1);
      const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
      const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
      const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
      return lastComputedIndex;
    }
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
          }
        }
      }
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
      const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? "left" : "right";
      const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === "left" ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
      toLegCalc.ingress.length = length;
      toLegCalc.ingressJoinIndex = 0;
      return lastComputedIndex;
    }
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      if (arc.distance === 0 || track.distance === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const fromVector = isArcFirst ? arc : track;
      const toVector = isArcFirst ? track : arc;
      const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
      const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
      if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
        return toIndex;
      }
      const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
      const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
      const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
      if (vectorBearingDiff < 1) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
      const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, FlightPathTurnCalculator.geoPointCache[2]);
      const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
      const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const arcCircle = FlightPathTurnCalculator.geoCircleCache[0].set(arcCenter, arcRadius);
      const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[1]);
      const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
      const arcStartRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
      const arcEndRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
      const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
      if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
      let isInside;
      let turnRadiusRad;
      let arcCircleOffsetSign;
      let trackPathOffsetSign;
      if (arcTrackIntersectionCount === 1) {
        const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
        if (isForward) {
          this.setEmptyTurn(fromLegCalc, toLegCalc);
          return toIndex;
        } else {
          isInside = false;
          turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
          arcCircleOffsetSign = 1;
          trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
        }
      } else {
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        isInside = isArcFirst ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90 : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
        const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, FlightPathTurnCalculator.vector3Cache[0]);
        const maxTrackLimitDistance = isInside ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius)) : Infinity;
        const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
        const trackLimitPoint = isArcFirst ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]) : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]);
        const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, isArcFirst === isInside ? -1 : 1, FlightPathTurnCalculator.vector3Cache[1]), arcCircle.center, FlightPathTurnCalculator.vector3Cache[1]), Math.PI / 2);
        const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
        trackPerpendicularDiameter.intersection(arcCircle, antipodes);
        const intersectingPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === "left") ? antipodes[0] : antipodes[1], trackLimitPoint);
        const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
        let arcLimitAngularWidth = Infinity;
        if (numArcIntersections > 0) {
          const pseudoArcLimitPoint = arcIntersections[0];
          const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
          arcLimitAngularWidth = Math.abs(NavMath.diffAngle(isArcFirst ? arcEndRadial : arcStartRadial, pseudoArcLimitPointAngle));
        }
        let arcTurnRadiusLimit = 0;
        const arcAngularWidth = ((arcDirection === "left" ? arcStartRadial - arcEndRadial : arcEndRadial - arcStartRadial) + 360) % 360;
        arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
        if (arcLimitAngularWidth > 0) {
          const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * (arcDirection === "left" ? -1 : 1);
          const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, FlightPathTurnCalculator.geoPointCache[4]);
          const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
          const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
          if (theta >= Math.PI / 2) {
            if (isInside) {
              const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
              arcTurnRadiusLimit = (arcRadius - d) / 2;
            } else {
              arcTurnRadiusLimit = Infinity;
            }
          } else {
            const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
            arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
            const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
            const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[1]), FlightPathTurnCalculator.vector3Cache[1]);
            const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
            const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
            const sinTheta = Math.sin(theta);
            const sign = isInside ? -1 : 1;
            arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
          }
        }
        turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
        arcCircleOffsetSign = isInside ? -1 : 1;
        trackPathOffsetSign = turnDirection === "left" ? -1 : 1;
      }
      if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
      const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
      const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
      const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
      if (intersectionCount === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      let turnCenter;
      if (intersectionCount === 2) {
        if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
          turnCenter = intersections[1];
        } else {
          turnCenter = intersections[0];
        }
      } else {
        turnCenter = intersections[0];
      }
      const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
      const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
      const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
      const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
      let turnAngularDelta = turnEndBearing - turnStartBearing;
      if (turnDirection === "right" && turnEndBearing <= turnStartBearing) {
        turnAngularDelta += 360;
      } else if (turnDirection === "left" && turnEndBearing >= turnStartBearing) {
        turnAngularDelta -= 360;
      }
      const turnMiddleBearing = (turnStartBearing + turnAngularDelta / 2 + 360) % 360;
      const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
      const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
      const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
      turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
      return toIndex;
    }
    setEmptyTurn(fromLegCalc, toLegCalc) {
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      toLegCalc.ingress.length = 0;
      toLegCalc.ingressJoinIndex = -1;
    }
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
      var _a, _b;
      var _c, _d;
      const egress = (_a = (_c = fromLegCalc.egress)[0]) !== null && _a !== void 0 ? _a : _c[0] = FlightPathUtils.createEmptyCircleVector();
      const ingress = (_b = (_d = toLegCalc.ingress)[0]) !== null && _b !== void 0 ? _b : _d[0] = FlightPathUtils.createEmptyCircleVector();
      fromLegCalc.egress.length = 1;
      toLegCalc.ingress.length = 1;
      fromLegCalc.egressJoinIndex = fromLegCalc.flightPath.length - 1;
      toLegCalc.ingressJoinIndex = 0;
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
      const egressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | fromLegCalc.flightPath[fromLegCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      const ingressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | toLegCalc.flightPath[toLegCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      FlightPathUtils.setCircleVector(egress, circle, start, middle, egressFlags);
      FlightPathUtils.setCircleVector(ingress, circle, middle, end, ingressFlags);
    }
  };
  FlightPathTurnCalculator.vector3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
  };
  var FlightPlanUtils = class {
    static isAltitudeLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    static isHeadingToLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    static isHoldLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    static isManualDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    static isDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    static getTerminatorIcao(leg) {
      switch (leg.type) {
        case LegType.IF:
        case LegType.TF:
        case LegType.DF:
        case LegType.CF:
        case LegType.AF:
        case LegType.RF:
        case LegType.HA:
        case LegType.HF:
        case LegType.HM:
          return leg.fixIcao;
        default:
          return void 0;
      }
    }
  };
  FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
  FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
  FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
  FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
  FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];
  var FlightPathAirplaneSpeedMode;
  (function(FlightPathAirplaneSpeedMode2) {
    FlightPathAirplaneSpeedMode2["Default"] = "Default";
    FlightPathAirplaneSpeedMode2["GroundSpeed"] = "GroundSpeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeed"] = "TrueAirspeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
  })(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
  var LegEventType;
  (function(LegEventType2) {
    LegEventType2["Added"] = "Added";
    LegEventType2["Removed"] = "Removed";
    LegEventType2["Changed"] = "Changed";
  })(LegEventType || (LegEventType = {}));
  var SegmentEventType;
  (function(SegmentEventType2) {
    SegmentEventType2["Added"] = "Added";
    SegmentEventType2["Removed"] = "Removed";
    SegmentEventType2["Changed"] = "Changed";
    SegmentEventType2["Inserted"] = "Inserted";
  })(SegmentEventType || (SegmentEventType = {}));
  var ActiveLegType;
  (function(ActiveLegType2) {
    ActiveLegType2["Lateral"] = "Lateral";
    ActiveLegType2["Vertical"] = "Vertical";
    ActiveLegType2["Calculating"] = "Calculating";
  })(ActiveLegType || (ActiveLegType = {}));
  var OriginDestChangeType;
  (function(OriginDestChangeType2) {
    OriginDestChangeType2["OriginAdded"] = "OriginAdded";
    OriginDestChangeType2["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType2["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType2["DestinationRemoved"] = "DestinationRemoved";
  })(OriginDestChangeType || (OriginDestChangeType = {}));
  var FlightPlan = class {
    constructor(planIndex, calculator, onLegNameRequested) {
      this.planIndex = planIndex;
      this.calculator = calculator;
      this.onLegNameRequested = onLegNameRequested;
      this._activeLateralLeg = 0;
      this._activeVerticalLeg = 0;
      this._activeCalculatingLeg = 0;
      this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
      this.events = {};
      this.procedureDetails = new ProcedureDetails();
      this.planSegments = [];
      this.userData = {};
    }
    get originAirport() {
      return this._originAirport;
    }
    get destinationAirport() {
      return this._destinationAirport;
    }
    get activeLateralLeg() {
      return this._activeLateralLeg;
    }
    get activeVerticalLeg() {
      return this._activeVerticalLeg;
    }
    get activeCalculatingLeg() {
      return this._activeCalculatingLeg;
    }
    get length() {
      const segment = this.planSegments[this.planSegments.length - 1];
      if (segment !== void 0) {
        return segment.offset + segment.legs.length;
      }
      return 0;
    }
    get segmentCount() {
      return this.planSegments.length;
    }
    legs(reverse = false, startIndex, endIndex) {
      return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    *_legs(startIndex = 0, endIndex = this.length) {
      endIndex = Math.min(this.length, endIndex);
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.min(segment.legs.length, endIndex - segment.offset);
          if (end <= 0) {
            return;
          }
          for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
            yield segment.legs[l];
          }
        }
      }
    }
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
      endIndex = Math.max(-1, endIndex);
      for (let i = this.planSegments.length - 1; i > -1; i--) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.max(-1, endIndex - segment.offset);
          if (end >= segment.legs.length) {
            return;
          }
          for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
            yield segment.legs[l];
          }
        }
      }
    }
    *segments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0) {
          yield segment;
        }
      }
    }
    *segmentsOfType(segmentType) {
      for (const segment of this.segments()) {
        if (segment.segmentType == segmentType) {
          yield segment;
        }
      }
    }
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
      this.planSegments[segmentIndex] = segment;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
      return segment;
    }
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segment !== void 0) {
        const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments.splice(segmentIndex, 0, newSegment);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
        return newSegment;
      } else {
        return this.addSegment(segmentIndex, segmentType, airway, notify);
      }
    }
    reflowSegments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.segmentIndex !== i) {
          segment.segmentIndex = i;
        }
      }
    }
    deleteSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segmentIndex === this.planSegments.length - 1) {
        this.planSegments.splice(segmentIndex, 1);
      } else {
        delete this.planSegments[segmentIndex];
      }
      if (this.directToData.segmentIndex === segmentIndex)
        ;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    removeSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      this.planSegments.splice(segmentIndex, 1);
      this.reflowSegments();
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    getSegment(segmentIndex) {
      const segment = this.tryGetSegment(segmentIndex);
      if (segment === null) {
        throw new Error(`Flight plan segment with ${segmentIndex === void 0 ? "active leg" : `segment index ${segmentIndex}`} could not be found.`);
      } else {
        return segment;
      }
    }
    tryGetSegment(segmentIndex) {
      if (segmentIndex === void 0) {
        let calculatedSegmentIndex = 0;
        for (const segment2 of this.segments()) {
          if (this.activeLateralLeg == 0 && segment2.legs.length == 0) {
            calculatedSegmentIndex++;
          } else if (this.activeLateralLeg > segment2.offset + segment2.legs.length) {
            calculatedSegmentIndex++;
          } else {
            break;
          }
        }
        const segment = this.planSegments[calculatedSegmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      } else if (segmentIndex >= 0) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      }
      return null;
    }
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
      const segment = this.getSegment(segmentIndex);
      const legDefinition = {
        name: this.onLegNameRequested(leg),
        leg,
        flags,
        verticalData: {
          phase: VerticalFlightPhase.Descent,
          altDesc: AltitudeRestrictionType.Unused,
          altitude1: 0,
          altitude2: 0,
          displayAltitude1AsFlightLevel: false,
          displayAltitude2AsFlightLevel: false,
          speedDesc: SpeedRestrictionType.Unused,
          speed: 0,
          speedUnit: SpeedUnit.IAS
        }
      };
      if (segmentLegIndex === void 0) {
        segment.legs.push(legDefinition);
        segmentLegIndex = segment.legs.length - 1;
      } else {
        segment.legs.splice(segmentLegIndex, 0, legDefinition);
      }
      this.reflowSegmentOffsets();
      notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
      return legDefinition;
    }
    getLeg(arg1, arg2) {
      const leg = this._tryGetLeg(arg1, arg2);
      if (leg) {
        return leg;
      }
      throw new Error(`Leg with ${arg2 === void 0 ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    tryGetLeg(arg1, arg2) {
      return this._tryGetLeg(arg1, arg2);
    }
    _tryGetLeg(arg1, arg2) {
      var _a, _b;
      if (arg2 === void 0) {
        const legIndex = arg1;
        for (const segment of this.segments()) {
          if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
            return segment.legs[legIndex - segment.offset];
          }
        }
        return null;
      } else {
        const segmentIndex = arg1;
        const segmentLegIndex = arg2;
        return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
      }
    }
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
      const segment = this.getSegment(segmentIndex);
      let legDefinition;
      if (segmentLegIndex === void 0) {
        legDefinition = segment.legs.pop();
        segmentLegIndex = segment.legs.length;
      } else {
        const deleted = segment.legs.splice(segmentLegIndex, 1);
        legDefinition = deleted[0];
      }
      if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex)
        ;
      this.reflowSegmentOffsets();
      notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
      return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    async calculate(globalLegIndex, notify = true) {
      const legs = [...this.legs()];
      await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === void 0 ? this.activeCalculatingLeg : globalLegIndex);
      notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    setOriginAirport(facilityIcao, notify = true) {
      this._originAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    removeOriginAirport(notify = true) {
      const facilityIcao = this._originAirport;
      this._originAirport = void 0;
      this.procedureDetails.departureIndex = -1;
      this.procedureDetails.departureRunwayIndex = -1;
      this.procedureDetails.departureTransitionIndex = -1;
      this.procedureDetails.originRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    setDestinationAirport(facilityIcao, notify = true) {
      this._destinationAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    removeDestinationAirport(notify = true) {
      const facilityIcao = this._destinationAirport;
      this._destinationAirport = void 0;
      this.procedureDetails.approachIndex = -1;
      this.procedureDetails.approachTransitionIndex = -1;
      this.procedureDetails.arrivalIndex = -1;
      this.procedureDetails.arrivalRunwayTransitionIndex = -1;
      this.procedureDetails.arrivalRunway = void 0;
      this.procedureDetails.arrivalTransitionIndex = -1;
      this.procedureDetails.destinationRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    setLateralLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeLateralLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    setVerticalLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeVerticalLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    setCalculatingLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeCalculatingLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    setProcedureDetails(details, notify = true) {
      for (const key of Object.keys(this.procedureDetails)) {
        this.procedureDetails[key] = details[key];
      }
      notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    getLegIndexFromLeg(leg) {
      let index = 0;
      for (const toCompare of this.legs()) {
        if (toCompare === leg) {
          return index;
        }
        index++;
      }
      return -1;
    }
    getSegmentFromLeg(leg) {
      for (const segment of this.segments()) {
        if (segment.legs.includes(leg)) {
          return segment;
        }
      }
      return null;
    }
    getSegmentIndex(globalLegIndex) {
      for (const segment of this.segments()) {
        if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.segmentIndex;
        }
      }
      return -1;
    }
    getSegmentLegIndex(globalLegIndex) {
      const segmentIndex = this.getSegmentIndex(globalLegIndex);
      if (segmentIndex === -1) {
        return -1;
      }
      return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    getPrevLeg(segmentIndex, legIndex) {
      var _a, _b;
      if (segmentIndex < 0) {
        return null;
      }
      segmentIndex = Math.min(segmentIndex, this.planSegments.length);
      legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
      while (!leg && --segmentIndex >= 0) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[segment.legs.length - 1];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    getNextLeg(segmentIndex, legIndex) {
      if (segmentIndex >= this.planSegments.length) {
        return null;
      }
      segmentIndex = Math.max(segmentIndex, -1);
      legIndex = Math.max(legIndex, -1);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
      while (!leg && ++segmentIndex < this.planSegments.length) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[0];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    setDirectToData(arg1, arg2, arg3) {
      if (typeof arg1 !== "number") {
        arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
      }
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let notify = true;
      if (typeof arg2 !== "number") {
        const globalLegIndex = arg1;
        if (globalLegIndex >= 0) {
          segmentIndex = this.getSegmentIndex(globalLegIndex);
          if (segmentIndex >= 0) {
            segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
          }
        }
        notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
      }
      this.directToData.segmentIndex = segmentIndex;
      this.directToData.segmentLegIndex = segmentLegIndex;
      notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    setLegVerticalData(arg1, arg2, arg3, arg4) {
      let notify = true;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let verticalData;
      if (typeof arg2 !== "number") {
        segmentIndex = this.getSegmentIndex(arg1);
        const segment = this.getSegment(segmentIndex);
        segmentLegIndex = arg1 - segment.offset;
        verticalData = arg2;
        notify = arg3 !== void 0 ? arg3 : notify;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        verticalData = arg3;
        notify = arg4 !== void 0 ? arg4 : notify;
      }
      const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
      if (leg) {
        Object.assign(leg.verticalData, verticalData);
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
      } else {
        console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
      }
    }
    setAirway(segmentIndex, airway, notify = true) {
      const segment = this.getSegment(segmentIndex);
      if (!airway) {
        segment.airway = void 0;
      } else {
        segment.airway = airway;
      }
      this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    setUserData(key, data, notify = true) {
      this.userData[key] = data;
      this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    deleteUserData(key, notify = true) {
      if (this.userData[key] !== void 0) {
        delete this.userData[key];
      }
      this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    getUserData(key) {
      return this.userData[key];
    }
    reflowSegmentOffsets() {
      let nextOffset = void 0;
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment) {
          if (nextOffset === void 0) {
            segment.offset = 0;
          } else {
            segment.offset = nextOffset;
          }
          nextOffset = segment.legs.length + segment.offset;
        }
      }
    }
    setOriginRunway(runway = void 0, notify = true) {
      this.procedureDetails.originRunway = runway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setDestinationRunway(runway = void 0, notify = true) {
      this.procedureDetails.destinationRunway = runway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setDeparture(facilityIcao = void 0, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
      this.procedureDetails.departureIndex = departureIndex;
      this.procedureDetails.departureFacilityIcao = facilityIcao;
      this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
      this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setArrival(facilityIcao = void 0, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = void 0, notify = true) {
      this.procedureDetails.arrivalIndex = arrivalIndex;
      this.procedureDetails.arrivalFacilityIcao = facilityIcao;
      this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
      this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
      this.procedureDetails.arrivalRunway = arrivalRunway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setApproach(facilityIcao = void 0, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachFacilityIcao = facilityIcao;
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    copy(planIndex, copyCalcs = false) {
      if (planIndex === void 0) {
        planIndex = this.planIndex;
      }
      const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
      newPlan.setProcedureDetails(this.procedureDetails, false);
      newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
      for (const segment of this.segments()) {
        newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
        for (const leg of segment.legs) {
          const newLeg = newPlan.addLeg(segment.segmentIndex, leg.leg, void 0, leg.flags, false);
          const legIndex = newPlan.getLegIndexFromLeg(newLeg);
          newPlan.setLegVerticalData(legIndex, leg.verticalData);
          copyCalcs && this.copyLegCalculations(leg, newLeg);
        }
      }
      if (this.originAirport !== void 0) {
        newPlan.setOriginAirport(this.originAirport, false);
      }
      if (this.destinationAirport !== void 0) {
        newPlan.setDestinationAirport(this.destinationAirport, false);
      }
      newPlan.setLateralLeg(this.activeLateralLeg);
      newPlan.setVerticalLeg(this.activeVerticalLeg);
      newPlan.setCalculatingLeg(this.activeCalculatingLeg);
      for (const key in this.userData) {
        newPlan.setUserData(key, this.userData[key], false);
      }
      return newPlan;
    }
    copyLegCalculations(existingLeg, newLeg) {
      if (existingLeg.calculated !== void 0) {
        newLeg.calculated = {
          courseMagVar: existingLeg.calculated.courseMagVar,
          initialDtk: existingLeg.calculated.initialDtk,
          distance: existingLeg.calculated.distance,
          cumulativeDistance: existingLeg.calculated.cumulativeDistance,
          distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
          cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
          startLat: existingLeg.calculated.startLat,
          startLon: existingLeg.calculated.startLon,
          endLat: existingLeg.calculated.endLat,
          endLon: existingLeg.calculated.endLon,
          flightPath: existingLeg.calculated.flightPath.map((vector) => Object.assign({}, vector)),
          ingress: existingLeg.calculated.ingress.map((vector) => Object.assign({}, vector)),
          ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
          ingressToEgress: existingLeg.calculated.ingressToEgress.map((vector) => Object.assign({}, vector)),
          egressJoinIndex: existingLeg.calculated.egressJoinIndex,
          egress: existingLeg.calculated.egress.map((vector) => Object.assign({}, vector)),
          endsInFallback: existingLeg.calculated.endsInFallback
        };
      }
      return newLeg;
    }
  };
  FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
  }, partial);
  var SubEvent = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    on(handler, paused = false) {
      const sub = new HandlerSubscription(handler, void 0, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      }
      return sub;
    }
    off(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    clear() {
      this.notifyDepth++;
      for (let i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }
      this.notifyDepth--;
      if (this.notifyDepth === 0) {
        this.subs.length = 0;
      }
    }
    notify(sender, data) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(sender, data);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`SubEvent: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
  };
  var WaypointTypes;
  (function(WaypointTypes2) {
    WaypointTypes2["Custom"] = "Custom";
    WaypointTypes2["Airport"] = "Airport";
    WaypointTypes2["NDB"] = "NDB";
    WaypointTypes2["VOR"] = "VOR";
    WaypointTypes2["Intersection"] = "Intersection";
    WaypointTypes2["Runway"] = "Runway";
    WaypointTypes2["User"] = "User";
    WaypointTypes2["Visual"] = "Visual";
    WaypointTypes2["FlightPlan"] = "FlightPlan";
    WaypointTypes2["VNAV"] = "VNAV";
  })(WaypointTypes || (WaypointTypes = {}));
  var AbstractWaypoint = class {
    equals(other) {
      return this.uid === other.uid;
    }
  };
  var BasicFacilityWaypoint = class extends AbstractWaypoint {
    constructor(facility, bus) {
      super();
      this.bus = bus;
      this.isFacilityWaypoint = true;
      this._facility = Subject.create(facility);
      this._location = GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat, facility.lon));
      this._type = BasicFacilityWaypoint.getType(facility);
      const facType = ICAO.getFacilityType(facility.icao);
      if (facType === FacilityType.VIS || facType === FacilityType.USR) {
        this.facChangeSub = this.bus.getSubscriber().on(`facility_changed_${facility.icao}`).handle((newFacility) => {
          this._facility.set(newFacility);
          this._location.set(newFacility.lat, newFacility.lon);
        });
      }
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this.facility.get().icao;
    }
    get type() {
      return this._type;
    }
    get facility() {
      return this._facility;
    }
    static getType(facility) {
      switch (ICAO.getFacilityType(facility.icao)) {
        case FacilityType.Airport:
          return WaypointTypes.Airport;
        case FacilityType.Intersection:
          return WaypointTypes.Intersection;
        case FacilityType.NDB:
          return WaypointTypes.NDB;
        case FacilityType.RWY:
          return WaypointTypes.Runway;
        case FacilityType.USR:
          return WaypointTypes.User;
        case FacilityType.VIS:
          return WaypointTypes.Visual;
        case FacilityType.VOR:
          return WaypointTypes.VOR;
        default:
          return WaypointTypes.User;
      }
    }
  };
  var FacilityWaypointUtils = class {
    static isFacilityWaypoint(waypoint, facilityType) {
      if (waypoint.isFacilityWaypoint !== true) {
        return false;
      }
      return facilityType === void 0 || FacilityUtils.isFacilityType(waypoint.facility.get(), facilityType);
    }
  };
  var FlightPathWaypoint = class extends AbstractWaypoint {
    constructor(arg1, arg2, arg3, arg4, arg5) {
      super();
      if (typeof arg1 === "number") {
        this._location = GeoPointSubject.create(new GeoPoint(arg1, arg2));
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg4}`;
        this.leg = arg3;
        this.ident = arg5;
      } else {
        this._location = arg1;
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg3}`;
        this.leg = arg2;
        this.ident = arg4;
      }
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this._uid;
    }
    get type() {
      return WaypointTypes.FlightPlan;
    }
  };
  FlightPathWaypoint.UID_PREFIX = "FLPTH";
  var VNavWaypoint = class extends AbstractWaypoint {
    constructor(leg, distanceFromEnd, uid, ident) {
      super();
      this.ident = ident;
      this._uid = uid;
      this._location = GeoPointSubject.create(this.getWaypointLocation(leg, distanceFromEnd, new GeoPoint(0, 0)));
    }
    get type() {
      return WaypointTypes.VNAV;
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this._uid;
    }
    setLocation(leg, distanceFromEnd) {
      this._location.set(this.getWaypointLocation(leg, distanceFromEnd, VNavWaypoint.geoPointCache[0]));
    }
    getWaypointLocation(leg, distanceFromEnd, out) {
      var _a, _b;
      if (leg.calculated !== void 0) {
        const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
        let vectorIndex = vectors.length - 1;
        while (vectorIndex >= 0) {
          const vector = vectors[vectorIndex];
          const vectorDistance = vector.distance;
          if (vectorDistance >= distanceFromEnd) {
            const end = GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, VNavWaypoint.vec3Cache[0]);
            return FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]).offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out, Math.PI);
          } else {
            distanceFromEnd -= vectorDistance;
          }
          vectorIndex--;
        }
        if (vectors.length > 0) {
          out.set(vectors[0].startLat, vectors[0].startLon);
        } else {
          out.set((_a = leg.calculated.endLat) !== null && _a !== void 0 ? _a : 0, (_b = leg.calculated.endLon) !== null && _b !== void 0 ? _b : 0);
        }
      }
      return out;
    }
  };
  VNavWaypoint.vec3Cache = [new Float64Array(3)];
  VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
  VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var DefaultFacilityWaypointCache = class {
    constructor(bus, size) {
      this.bus = bus;
      this.size = size;
      this.cache = /* @__PURE__ */ new Map();
    }
    get(facility) {
      const key = DefaultFacilityWaypointCache.getFacilityKey(facility);
      let existing = this.cache.get(key);
      if (!existing) {
        existing = new BasicFacilityWaypoint(facility, this.bus);
        this.addToCache(key, existing);
      }
      return existing;
    }
    addToCache(key, waypoint) {
      this.cache.set(key, waypoint);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    static getCache(bus) {
      var _a;
      return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(bus, 1e3);
    }
    static getFacilityKey(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection) && ICAO.getFacilityType(facility.icao) !== FacilityType.Intersection) {
        return `mismatch.${facility.icao}`;
      }
      return facility.icao;
    }
  };
  var DefaultLodBoundaryCache = class {
    static getCache() {
      var _a;
      return (_a = DefaultLodBoundaryCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultLodBoundaryCache.INSTANCE = new LodBoundaryCache(DefaultLodBoundaryCache.SIZE, DefaultLodBoundaryCache.DISTANCE_THRESHOLDS, DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS);
    }
  };
  DefaultLodBoundaryCache.SIZE = 500;
  DefaultLodBoundaryCache.DISTANCE_THRESHOLDS = [0, 3e-5, 1e-4, 3e-4];
  DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS = [500, 300, 200, 100];
  var SubscribableMapFunctions = class {
    static identity() {
      return (input) => input;
    }
    static not() {
      return (input) => !input;
    }
    static negate() {
      return (input) => -input;
    }
    static abs() {
      return Math.abs;
    }
    static withPrecision(precision) {
      return SubscribableUtils.isSubscribable(precision) ? (input) => {
        const precisionVal = precision.get();
        return Math.round(input / precisionVal) * precisionVal;
      } : (input) => {
        return Math.round(input / precision) * precision;
      };
    }
    static changedBy(threshold) {
      return SubscribableUtils.isSubscribable(threshold) ? (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal : (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    static atFrequency(freq, timeFunc = Date.now) {
      let t0;
      let timeRemaining = 0;
      if (SubscribableUtils.isSubscribable(freq)) {
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            const period = 1e3 / freq.get();
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      } else {
        const period = 1e3 / freq;
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      }
    }
  };
  var MappedSubject = class extends AbstractSubscribable {
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
      super();
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      this.inputs = inputs;
      this.inputValues = inputs.map((input) => input.get());
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.inputValues, void 0));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.inputValues, void 0);
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSubs = this.inputs.map((input, index) => input.sub((inputValue) => {
        this.inputValues[index] = inputValue;
        this.updateValue();
      }));
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    static create(...args) {
      let mapFunc, equalityFunc, mutateFunc, initialVal;
      if (typeof args[0] === "function") {
        mapFunc = args.shift();
        if (typeof args[0] === "function") {
          equalityFunc = args.shift();
        } else {
          equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
        }
        if (typeof args[0] === "function") {
          mutateFunc = args.shift();
          initialVal = args.shift();
        }
      } else {
        mapFunc = MappedSubject.IDENTITY_MAP;
        equalityFunc = MappedSubject.NEVER_EQUALS;
      }
      return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    updateValue() {
      const value = this.mapFunc(this.inputValues, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    get() {
      return this.value;
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot pause a dead subject");
      }
      if (this._isPaused) {
        return this;
      }
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].pause();
      }
      this._isPaused = true;
      return this;
    }
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot resume a dead subject");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputValues[i] = this.inputs[i].get();
        this.inputSubs[i].resume();
      }
      this.updateValue();
      return this;
    }
    destroy() {
      this._isAlive = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].destroy();
      }
    }
  };
  MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
  MappedSubject.NEVER_EQUALS = () => false;
  var SubscribableSetEventType;
  (function(SubscribableSetEventType2) {
    SubscribableSetEventType2["Added"] = "Added";
    SubscribableSetEventType2["Deleted"] = "Deleted";
  })(SubscribableSetEventType || (SubscribableSetEventType = {}));
  var ArraySubject = class extends AbstractSubscribableArray {
    constructor(arr) {
      super();
      this.array = arr;
    }
    get length() {
      return this.array.length;
    }
    static create(arr = []) {
      return new ArraySubject(arr);
    }
    insert(item, index) {
      if (index === void 0 || index > this.array.length - 1) {
        index = this.array.length;
        this.array.push(item);
      } else {
        this.array.splice(index, 0, item);
      }
      this.notify(index, SubscribableArrayEventType.Added, item);
    }
    insertRange(index = 0, arr) {
      this.array.splice(index, 0, ...arr);
      this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    removeAt(index) {
      const removedItem = this.array.splice(index, 1);
      this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    removeItem(item) {
      const index = this.array.indexOf(item);
      if (index > -1) {
        this.removeAt(index);
        return true;
      } else {
        return false;
      }
    }
    set(arr) {
      this.clear();
      this.insertRange(0, arr);
    }
    clear() {
      this.array.length = 0;
      this.notify(0, SubscribableArrayEventType.Cleared);
    }
    getArray() {
      return this.array;
    }
  };
  var ObjectSubject = class {
    constructor(obj) {
      this.obj = obj;
      this.isSubscribable = true;
      this.isMutableSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    static create(v) {
      return new ObjectSubject(v);
    }
    get() {
      return this.obj;
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    set(arg1, value) {
      if (typeof arg1 === "object") {
        for (const prop in arg1) {
          if (prop in this.obj) {
            this.set(prop, arg1[prop]);
          }
        }
      } else {
        const oldValue = this.obj[arg1];
        if (value !== oldValue) {
          this.obj[arg1] = value;
          this.notify(arg1, oldValue);
        }
      }
    }
    notify(key, oldValue) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(this.obj, key, this.obj[key], oldValue);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ObjectSubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    initialNotify(sub) {
      for (const key in this.obj) {
        const v = this.obj[key];
        sub.handler(this.obj, key, v, v);
      }
    }
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    map(fn, equalityFunc, mutateFunc, initialVal) {
      const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
      return mutateFunc ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this) : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  var NearestContext = class {
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this.airports = new NearestAirportSubscription(facilityLoader);
      this.vors = new NearestVorSubscription(facilityLoader);
      this.intersections = new NearestIntersectionSubscription(facilityLoader);
      this.ndbs = new NearestNdbSubscription(facilityLoader);
      this.usrs = new NearestUsrSubscription(facilityLoader);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("NearestContext was not initialized.");
    }
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new NearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("NearestContext was already initialized.");
      }
    }
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    getRegionCode() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region;
        }
      }
      return void 0;
    }
    getRegionIdent() {
      const region = this.getRegionCode();
      if (region !== void 0) {
        return region[0] === "K" ? "K" : region;
      }
      return void 0;
    }
    getRegionLetter() {
      const region = this.getRegionCode();
      return region !== void 0 ? region[0] : void 0;
    }
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  NearestContext.initializedSubEvent = new SubEvent();
  var AdaptiveNearestContext = class {
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this._maxAirportsAbsolute = Subject.create(100);
      this._maxVorsAbsolute = Subject.create(100);
      this._maxIntersectionsAbsolute = Subject.create(100);
      this._maxNdbsAbsolute = Subject.create(100);
      this._maxUsrsAbsolute = Subject.create(100);
      this.airports = new AdaptiveNearestSubscription(new NearestAirportSubscription(facilityLoader), this._maxAirportsAbsolute);
      this.vors = new AdaptiveNearestSubscription(new NearestVorSubscription(facilityLoader), this._maxVorsAbsolute);
      this.intersections = new AdaptiveNearestSubscription(new NearestIntersectionSubscription(facilityLoader), this._maxIntersectionsAbsolute);
      this.ndbs = new AdaptiveNearestSubscription(new NearestNdbSubscription(facilityLoader), this._maxNdbsAbsolute);
      this.usrs = new AdaptiveNearestSubscription(new NearestUsrSubscription(facilityLoader), this._maxUsrsAbsolute);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    get maxAirportsAbsolute() {
      return this._maxAirportsAbsolute.get();
    }
    set maxAirportsAbsolute(val) {
      this._maxAirportsAbsolute.set(val);
    }
    get maxVorsAbsolute() {
      return this._maxVorsAbsolute.get();
    }
    set maxVorsAbsolute(val) {
      this._maxVorsAbsolute.set(val);
    }
    get maxIntersectionsAbsolute() {
      return this._maxIntersectionsAbsolute.get();
    }
    set maxIntersectionsAbsolute(val) {
      this._maxIntersectionsAbsolute.set(val);
    }
    get maxNdbsAbsolute() {
      return this._maxNdbsAbsolute.get();
    }
    set maxNdbsAbsolute(val) {
      this._maxNdbsAbsolute.set(val);
    }
    get maxUsrsAbsolute() {
      return this._maxUsrsAbsolute.get();
    }
    set maxUsrsAbsolute(val) {
      this._maxUsrsAbsolute.set(val);
    }
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("AdaptiveNearestContext was not initialized.");
    }
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new AdaptiveNearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("AdaptiveNearestContext was already initialized.");
      }
    }
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    getRegionLetter() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region[0];
        }
      }
      return void 0;
    }
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  AdaptiveNearestContext.initializedSubEvent = new SubEvent();
  var IcaoSearchFilter;
  (function(IcaoSearchFilter2) {
    IcaoSearchFilter2[IcaoSearchFilter2["ALL"] = 0] = "ALL";
    IcaoSearchFilter2[IcaoSearchFilter2["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter2[IcaoSearchFilter2["VOR"] = 2] = "VOR";
    IcaoSearchFilter2[IcaoSearchFilter2["NDB"] = 3] = "NDB";
    IcaoSearchFilter2[IcaoSearchFilter2["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter2[IcaoSearchFilter2["USR"] = 5] = "USR";
  })(IcaoSearchFilter || (IcaoSearchFilter = {}));
  var ElectricalPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(ElectricalPublisher.simvars, bus, pacer);
      this.flightStarted = false;
      this.avBusList = ["elec_av1_bus", "elec_av2_bus"];
      for (const topic of this.avBusList) {
        if (bus.getTopicSubscriberCount(topic)) {
          this.subscribed.add(topic);
        }
      }
      bus.getSubscriber().on("event_bus_topic_first_sub").handle((event) => {
        if (this.avBusList.includes(event)) {
          this.subscribed.add(event);
        }
      });
      const gameStateSub = GameStateProvider.get().sub((state) => {
        if (state === GameState.briefing || state === GameState.ingame) {
          gameStateSub.destroy();
          this.flightStarted = true;
        }
      }, false, true);
      gameStateSub.resume(true);
    }
    onUpdate() {
      if (this.flightStarted) {
        super.onUpdate();
        if (this.av1BusLogic && this.subscribed.has("elec_av1_bus")) {
          this.publish("elec_av1_bus", this.av1BusLogic.getValue() !== 0);
        }
        if (this.av2BusLogic && this.subscribed.has("elec_av2_bus")) {
          this.publish("elec_av2_bus", this.av2BusLogic.getValue() !== 0);
        }
      }
    }
    setAv1Bus(logicElement) {
      this.av1BusLogic = logicElement;
    }
    setAv2Bus(logicElement) {
      this.av2BusLogic = logicElement;
    }
  };
  ElectricalPublisher.simvars = /* @__PURE__ */ new Map([
    ["elec_master_battery", { name: "ELECTRICAL MASTER BATTERY", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_1", { name: "CIRCUIT AVIONICS ON:1", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_2", { name: "CIRCUIT AVIONICS ON:2", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom1_on", { name: "CIRCUIT NAVCOM1 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom2_on", { name: "CIRCUIT NAVCOM2 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom3_on", { name: "CIRCUIT NAVCOM3 ON", type: SimVarValueType.Bool }],
    ["elec_bus_main_v", { name: "ELECTRICAL MAIN BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_main_a", { name: "ELECTRICAL MAIN BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_avionics_v", { name: "ELECTRICAL AVIONICS BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_avionics_a", { name: "ELECTRICAL AVIONICS BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_1_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_2_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:2", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_1_a", { name: "ELECTRICAL GENALT BUS AMPS:1", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_2_a", { name: "ELECTRICAL GENALT BUS AMPS:2", type: SimVarValueType.Amps }],
    ["elec_bat_a_1", { name: "ELECTRICAL BATTERY LOAD:1", type: SimVarValueType.Amps }],
    ["elec_bat_v_1", { name: "ELECTRICAL BATTERY VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bat_a_2", { name: "ELECTRICAL BATTERY LOAD:2", type: SimVarValueType.Amps }],
    ["elec_bat_v_2", { name: "ELECTRICAL BATTERY VOLTAGE:2", type: SimVarValueType.Volts }]
  ]);
  var FlightTimerMode;
  (function(FlightTimerMode2) {
    FlightTimerMode2[FlightTimerMode2["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode2[FlightTimerMode2["CountingUp"] = 1] = "CountingUp";
  })(FlightTimerMode || (FlightTimerMode = {}));
  var SBASGroupName;
  (function(SBASGroupName2) {
    SBASGroupName2["WAAS"] = "WAAS";
    SBASGroupName2["EGNOS"] = "EGNOS";
    SBASGroupName2["GAGAN"] = "GAGAN";
    SBASGroupName2["MSAS"] = "MSAS";
  })(SBASGroupName || (SBASGroupName = {}));
  var GPSSatelliteState;
  (function(GPSSatelliteState2) {
    GPSSatelliteState2["None"] = "None";
    GPSSatelliteState2["Unreachable"] = "Unreachable";
    GPSSatelliteState2["Acquired"] = "Acquired";
    GPSSatelliteState2["Faulty"] = "Faulty";
    GPSSatelliteState2["DataCollected"] = "DataCollected";
    GPSSatelliteState2["InUse"] = "InUse";
    GPSSatelliteState2["InUseDiffApplied"] = "InUseDiffApplied";
  })(GPSSatelliteState || (GPSSatelliteState = {}));
  var GPSSystemState;
  (function(GPSSystemState2) {
    GPSSystemState2["Searching"] = "Searching";
    GPSSystemState2["Acquiring"] = "Acquiring";
    GPSSystemState2["SolutionAcquired"] = "SolutionAcquired";
    GPSSystemState2["DiffSolutionAcquired"] = "DiffSolutionAcquired";
  })(GPSSystemState || (GPSSystemState = {}));
  var GPSSystemSBASState;
  (function(GPSSystemSBASState2) {
    GPSSystemSBASState2["Disabled"] = "Disabled";
    GPSSystemSBASState2["Inactive"] = "Inactive";
    GPSSystemSBASState2["Active"] = "Active";
  })(GPSSystemSBASState || (GPSSystemSBASState = {}));
  var MinimumsMode;
  (function(MinimumsMode2) {
    MinimumsMode2[MinimumsMode2["OFF"] = 0] = "OFF";
    MinimumsMode2[MinimumsMode2["BARO"] = 1] = "BARO";
    MinimumsMode2[MinimumsMode2["RA"] = 2] = "RA";
    MinimumsMode2[MinimumsMode2["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
  })(MinimumsMode || (MinimumsMode = {}));
  var MinimumsSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(MinimumsSimVarPublisher.simvars, bus);
    }
  };
  MinimumsSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["decision_height_feet", { name: "DECISION HEIGHT", type: SimVarValueType.Feet }],
    ["decision_altitude_feet", { name: "DECISION ALTITUDE MSL", type: SimVarValueType.Feet }],
    ["minimums_mode", { name: "L:WT_MINIMUMS_MODE", type: SimVarValueType.Number }]
  ]);
  var NavComSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(NavComSimVarPublisher.simvars, bus, pacer);
    }
    static createNavRadioDefinitions(index) {
      return [
        [`nav_active_frequency_${index}`, { name: `NAV ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_standby_frequency_${index}`, { name: `NAV STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_sound_${index}`, { name: `NAV SOUND:${index}`, type: SimVarValueType.Bool }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_volume_${index}`, { name: `NAV VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    static createComRadioDefinitions(index) {
      return [
        [`com_active_frequency_${index}`, { name: `COM ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_standby_frequency_${index}`, { name: `COM STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_active_facility_name_${index}`, { name: `COM ACTIVE FREQ NAME:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_type_${index}`, { name: `COM ACTIVE FREQ TYPE:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_ident_${index}`, { name: `COM ACTIVE FREQ IDENT:${index}`, type: SimVarValueType.String }],
        [`com_receive_${index}`, { name: `COM RECEIVE EX1:${index}`, type: SimVarValueType.Bool }],
        [`com_status_${index}`, { name: `COM STATUS:${index}`, type: SimVarValueType.Number }],
        [`com_transmit_${index}`, { name: `COM TRANSMIT:${index}`, type: SimVarValueType.Bool }],
        [`com_spacing_mode_${index}`, { name: `COM SPACING MODE:${index}`, type: SimVarValueType.Enum }],
        [`com_volume_${index}`, { name: `COM VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_active_frequency_${index}`, { name: `ADF ACTIVE FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_standby_frequency_${index}`, { name: `ADF STANDBY FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_sound_${index}`, { name: `ADF SOUND:${index}`, type: SimVarValueType.Bool }],
        [`adf_volume_${index}`, { name: `ADF VOLUME:${index}`, type: SimVarValueType.Percent }],
        [`adf_ident_${index}`, { name: `ADF IDENT:${index}`, type: SimVarValueType.String }],
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }]
      ];
    }
  };
  NavComSimVarPublisher.simvars = new Map([
    ...NavComSimVarPublisher.createNavRadioDefinitions(1),
    ...NavComSimVarPublisher.createNavRadioDefinitions(2),
    ...NavComSimVarPublisher.createNavRadioDefinitions(3),
    ...NavComSimVarPublisher.createNavRadioDefinitions(4),
    ...NavComSimVarPublisher.createComRadioDefinitions(1),
    ...NavComSimVarPublisher.createComRadioDefinitions(2),
    ...NavComSimVarPublisher.createComRadioDefinitions(3),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(2),
    ["marker_beacon_hisense_on", { name: "MARKER BEACON SENSITIVITY HIGH", type: SimVarValueType.Bool }],
    ["marker_beacon_sound", { name: "MARKER SOUND", type: SimVarValueType.Bool }]
  ]);
  var PitotPublisher = class extends SimVarPublisher {
    constructor(bus, pitotCount, pacer) {
      const indexedSimVars = [
        ["pitot_heat_switch_on", { name: "PITOT HEAT SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(PitotPublisher.nonIndexedSimVars);
      for (const [topic, simvar2] of indexedSimVars) {
        for (let i = 1; i <= pitotCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  PitotPublisher.nonIndexedSimVars = [
    ["pitot_heat_on", { name: "PITOT HEAT", type: SimVarValueType.Bool }],
    ["pitot_icing_pct", { name: "PITOT ICE PCT", type: SimVarValueType.Percent }]
  ];
  var PressurizationPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(PressurizationPublisher.simvars, bus, pacer);
    }
    onUpdate() {
      super.onUpdate();
    }
  };
  PressurizationPublisher.simvars = /* @__PURE__ */ new Map([
    ["cabin_altitude", { name: "PRESSURIZATION CABIN ALTITUDE", type: SimVarValueType.Feet }],
    ["cabin_altitude_rate", { name: "PRESSURIZATION CABIN ALTITUDE RATE", type: SimVarValueType.FPM }],
    ["pressure_diff", { name: "PRESSURIZATION PRESSURE DIFFERENTIAL", type: SimVarValueType.PSI }]
  ]);
  var DebounceTimer = class {
    constructor() {
      this.timer = null;
    }
    isPending() {
      return this.timer !== null;
    }
    schedule(action, delay) {
      this.clear();
      this.timer = setTimeout(() => {
        this.timer = null;
        action();
      }, delay);
    }
    clear() {
      if (this.timer === null) {
        return;
      }
      clearTimeout(this.timer);
      this.timer = null;
    }
  };
  var XPDRMode;
  (function(XPDRMode2) {
    XPDRMode2[XPDRMode2["OFF"] = 0] = "OFF";
    XPDRMode2[XPDRMode2["STBY"] = 1] = "STBY";
    XPDRMode2[XPDRMode2["TEST"] = 2] = "TEST";
    XPDRMode2[XPDRMode2["ON"] = 3] = "ON";
    XPDRMode2[XPDRMode2["ALT"] = 4] = "ALT";
    XPDRMode2[XPDRMode2["GROUND"] = 5] = "GROUND";
  })(XPDRMode || (XPDRMode = {}));
  var Wait = class {
    static awaitDelay(delay) {
      return new Promise((resolve) => setTimeout(() => resolve(), delay));
    }
    static awaitCondition(predicate, interval = 0, timeout = 0) {
      const t0 = Date.now();
      if (interval <= 0) {
        const loopFunc = (resolve, reject) => {
          if (timeout > 0 && Date.now() - t0 >= timeout) {
            reject("Await condition timed out.");
          } else {
            predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(void 0, resolve, reject));
          }
        };
        return new Promise((resolve, reject) => {
          loopFunc(resolve, reject);
        });
      } else {
        return new Promise((resolve, reject) => {
          const timer = setInterval(() => {
            if (timeout > 0 && Date.now() - t0 > timeout) {
              clearInterval(timer);
              reject("Await condition timed out.");
            } else if (predicate()) {
              clearInterval(timer);
              resolve();
            }
          }, interval);
        });
      }
    }
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = subscribable.sub((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub.destroy();
            resolve(val);
          }
        }, false, true);
        sub.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = consumer.handle((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub.destroy();
            resolve(val);
          }
        }, true);
        sub.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    static awaitSubEvent(event, predicate, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = event.on((sender, data) => {
          if (predicate === void 0 || predicate(data, sender)) {
            sub.destroy();
            resolve(data);
          }
        }, true);
        sub.resume();
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
  };
  var TrafficContactClass = class {
    constructor(uid, contactTimeResetThreshold) {
      this.uid = uid;
      this.contactTimeResetThreshold = contactTimeResetThreshold;
      this._lastPosition = new GeoPoint(NaN, NaN);
      this.lastPosition = this._lastPosition.readonly;
      this._lastAltitude = UnitType.FOOT.createNumber(NaN);
      this.lastAltitude = this._lastAltitude.readonly;
      this._lastHeading = NaN;
      this._lastContactTime = NaN;
      this._groundSpeed = UnitType.KNOT.createNumber(NaN);
      this.groundSpeed = this._groundSpeed.readonly;
      this._groundTrack = NaN;
      this._verticalSpeed = UnitType.FPM.createNumber(NaN);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
    }
    get lastHeading() {
      return this._lastHeading;
    }
    get lastContactTime() {
      return this._lastContactTime;
    }
    get groundTrack() {
      return this._groundTrack;
    }
    predict(simTime, positionOut, altitudeOut) {
      if (this.groundSpeed.isNaN()) {
        positionOut.set(NaN, NaN);
        altitudeOut.set(NaN);
        return;
      }
      const dt = simTime - this.lastContactTime;
      const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 36e5), UnitType.GA_RADIAN);
      this._lastPosition.offset(this._groundTrack, distance, positionOut);
      const deltaAlt = this._verticalSpeed.number * (dt / 6e4);
      this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    update(lat, lon, altitude, heading, simTime) {
      const dt = simTime - this._lastContactTime;
      if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
        this.reset(lat, lon, altitude, heading, simTime);
        return;
      }
      if (!isNaN(dt) && dt > 0) {
        this.updateComputedValues(dt / 1e3, lat, lon, altitude);
      }
      this.setReportedValues(lat, lon, altitude, heading);
      if (this.areComputedValuesValid()) {
        this._lastContactTime = simTime;
      } else {
        this.reset(lat, lon, altitude, heading, simTime);
      }
    }
    reset(lat, lon, altitude, heading, simTime) {
      this.setReportedValues(lat, lon, altitude, heading);
      this._groundSpeed.set(NaN);
      this._groundTrack = NaN;
      this._verticalSpeed.set(NaN);
      this.groundSpeedSmoother.reset();
      this.groundTrackSmoother.reset();
      this.verticalSpeedSmoother.reset();
      this._lastContactTime = simTime;
    }
    setReportedValues(lat, lon, altitude, heading) {
      this._lastPosition.set(lat, lon);
      this._lastAltitude.set(altitude);
      this._lastHeading = heading;
    }
    updateComputedValues(dt, lat, lon, altitude) {
      const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
      const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
      const track = pos.bearingFrom(this._lastPosition);
      this.updateGroundSpeed(dt, distanceNM);
      this.updateGroundTrack(dt, track, distanceNM);
      this.updateVerticalSpeed(dt, altitude);
    }
    updateGroundSpeed(dt, distanceNM) {
      const dtHours = dt / 3600;
      const speedKnots = distanceNM / dtHours;
      this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    updateGroundTrack(dt, track, distanceNM) {
      const last = this.groundTrackSmoother.last();
      if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
        if (last !== null && !isNaN(last)) {
          let delta = track - last;
          if (delta > 180) {
            delta = delta - 360;
          } else if (delta < -180) {
            delta = delta + 360;
          }
          track = last + delta;
        }
      } else {
        track = last === null ? NaN : last;
      }
      const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
      this._groundTrack = (next + 360) % 360;
    }
    updateVerticalSpeed(dt, altitude) {
      const dtMin = dt / 60;
      const deltaAltFeet = altitude - this._lastAltitude.number;
      const vsFPM = deltaAltFeet / dtMin;
      this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    areComputedValuesValid() {
      const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
      const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
      return isGroundSpeedValid && isVerticalSpeedValid;
    }
  };
  TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500;
  TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 1e4;
  TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852;
  TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);
  var Easing = class {
    static linear() {
      return (x) => MathUtils.clamp(x, 0, 1);
    }
    static quad(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x;
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - (1 - x) * (1 - x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 2 * x * x : 1 - 2 * (1 - x) * (1 - x);
        default:
          throw new Error(`Easing.quad(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static cubic(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 4 * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 4 * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.cubic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static quart(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 8 * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 8 * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quart(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static quint(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 16 * x * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 16 * compl * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quint(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static polynomial(order, end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(x, order);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(1 - x, order);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2 * x, order) : 1 - 0.5 * Math.pow(2 * (1 - x), order);
        default:
          throw new Error(`Easing.polynomial(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static sin(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.cos(x * MathUtils.HALF_PI);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sin(x * MathUtils.HALF_PI);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : (1 - Math.cos(x * Math.PI)) * 0.5;
        default:
          throw new Error(`Easing.sin(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static circ(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.sqrt(1 - x * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sqrt(1 - (x - 1) * (x - 1));
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? (1 - Math.sqrt(1 - 4 * x * x)) * 0.5 : (Math.sqrt(1 - 4 * (1 - x) * (1 - x)) + 1) * 0.5;
        default:
          throw new Error(`Easing.circ(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static exp(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(2, 10 * (x - 1));
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(2, -10 * x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2, 20 * (x - 0.5)) : 1 - 0.5 * Math.pow(2, 20 * (0.5 - x));
        default:
          throw new Error(`Easing.exp(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static back(end) {
      const c1 = 2.70158;
      const c2 = 1.70158;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * x * x * x - c2 * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl + c2 * compl * compl;
            }
          };
        case "both": {
          const c3 = c2 * 1.525;
          const c4 = c3 + 1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 2 * (x * x * (2 * c4 * x - c3));
            } else {
              const compl = 1 - x;
              return 1 - 2 * compl * compl * (2 * c4 * compl - c3);
            }
          };
        }
        default:
          throw new Error(`Easing.back(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static elastic(end) {
      const c1 = MathUtils.TWO_PI / 3;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * Math.pow(2, 10 * (x - 1)) * Math.sin(10.75 - 10 * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - c1 * Math.pow(2, -10 * x) * Math.sin(0.75 - 10 * x);
        case "both": {
          const c2 = c1 * c1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 0.5 * Math.pow(2, 20 * (x - 0.5)) * Math.sin(c2 * (11.125 - 20 * x));
            } else {
              return 1 - 0.5 * Math.pow(2, 20 * (0.5 - x)) * Math.sin(c2 * (11.125 - 20 * x));
            }
          };
        }
        default:
          throw new Error(`Easing.elastic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static bezier(c1x, c1y, c2x, c2y, precompute = false, minXResolution, epsilon = 1e-3, maxDepth = 10) {
      c1x = MathUtils.clamp(c1x, 0, 1);
      c2x = MathUtils.clamp(c2x, 0, 1);
      if (precompute) {
        const minXRes = minXResolution !== null && minXResolution !== void 0 ? minXResolution : 0.1;
        const lookup = new LerpLookupTable(1);
        lookup.insertBreakpoint([0, 0]);
        lookup.insertBreakpoint([1, 1]);
        if (maxDepth > 0) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, 0, 0, 0, 1, 1, 1, 1);
        }
        return (x) => {
          return x <= 0 ? 0 : x >= 1 ? 1 : lookup.get(x);
        };
      } else {
        const minXRes = Math.max(minXResolution !== null && minXResolution !== void 0 ? minXResolution : 1e-4, 1e-6);
        return (x) => {
          if (x <= 0) {
            return 0;
          } else if (x >= 1) {
            return 1;
          }
          let t0 = 0, t1 = 1;
          let tquery = (t0 + t1) / 2;
          let xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          while (Math.abs(x - xquery) > minXRes) {
            if (x - xquery < 0) {
              t1 = tquery;
            } else {
              t0 = tquery;
            }
            tquery = (t0 + t1) / 2;
            xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          }
          return Easing.easingBezierFunc(tquery, c1y, c2y);
        };
      }
    }
    static precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, t1, x1, y1, depth) {
      const tmid = (t0 + t1) / 2;
      const xdelta = x1 - x0;
      const xmid = Easing.easingBezierFunc(tmid, c1x, c2x);
      const ymid = Easing.easingBezierFunc(tmid, c1y, c2y);
      const ylerp = MathUtils.lerp(xmid, x0, x1, y0, y1);
      let shouldContinue = false;
      shouldContinue = xdelta > minXRes || Math.abs(ylerp - ymid) > epsilon;
      if (shouldContinue) {
        lookup.insertBreakpoint([ymid, xmid]);
        if (depth < maxDepth) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, tmid, xmid, ymid, depth + 1);
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, tmid, xmid, ymid, t1, x1, y1, depth + 1);
        }
      }
    }
    static easingBezierFunc(t, c1, c2) {
      return 3 * (1 - t) * (1 - t) * t * c1 + 3 * (1 - t) * t * t * c2 + t * t * t;
    }
    static withEndpointParams(ease) {
      return (start, stop, progress) => {
        return start + (stop - start) * ease(progress);
      };
    }
    static withEndpoints(ease, start, stop) {
      const delta = stop - start;
      return (progress) => {
        return start + delta * ease(progress);
      };
    }
  };
  var Animator = class {
    constructor() {
      this._value = Subject.create(0);
      this._isAnimating = false;
      this.isAnimationLoopActive = false;
      this.animationEaseFunc = Animator.DEFAULT_EASE_FUNC;
      this.animationStart = 0;
      this.animationStop = 0;
      this.animationStartTime = 0;
      this.animationDuration = 0;
      this.animationLoop = () => {
        if (!this._isAnimating) {
          this.isAnimationLoopActive = false;
          return;
        }
        const progress = (Date.now() - this.animationStartTime) / this.animationDuration;
        if (progress < 1) {
          this._value.set(this.animationEaseFunc(this.animationStart, this.animationStop, progress));
          requestAnimationFrame(this.animationLoop);
        } else {
          this._isAnimating = false;
          this.isAnimationLoopActive = false;
          this._value.set(this.animationStop);
        }
      };
    }
    get value() {
      return this._value;
    }
    isAnimating() {
      return this._isAnimating;
    }
    start(target, duration, easeFunc) {
      if (duration <= 0) {
        this.set(target);
        return;
      }
      this._isAnimating = true;
      this.animationStart = this._value.get();
      this.animationStop = target;
      this.animationStartTime = Date.now();
      this.animationDuration = duration;
      this.animationEaseFunc = easeFunc !== null && easeFunc !== void 0 ? easeFunc : Animator.DEFAULT_EASE_FUNC;
      if (!this.isAnimationLoopActive) {
        this.isAnimationLoopActive = true;
        requestAnimationFrame(this.animationLoop);
      }
    }
    set(value) {
      this._isAnimating = false;
      this._value.set(value);
    }
    stop(setAnimationTarget = false) {
      if (!this._isAnimating) {
        return;
      }
      this._isAnimating = false;
      if (setAnimationTarget) {
        this._value.set(this.animationStop);
      }
    }
  };
  Animator.DEFAULT_EASE_FUNC = Easing.withEndpointParams(Easing.linear());
  var BacklightLevelController = class {
    constructor(bus, paused = false, minIntensity = BacklightLevelController.DEFAULT_MIN_INTENSITY, maxIntensity = BacklightLevelController.DEFAULT_MAX_INTENSITY) {
      this.simTime = ConsumerSubject.create(null, 0);
      this.ppos = new Float64Array(3);
      this.needRecalcAuto = true;
      this.lastSimTime = 0;
      this.paused = false;
      this._intensity = Subject.create(0);
      this.intensity = this._intensity;
      this._autoMinIntensity = minIntensity;
      this._autoMaxIntensity = maxIntensity;
      this._autoIntensityRange = this.autoMaxIntensity - this.autoMinIntensity;
      this.needRecalcAuto = true;
      const sub = bus.getSubscriber();
      this.simTime.setConsumer(sub.on("simTime"));
      this.pposSub = sub.on("gps-position").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onPPosChanged.bind(this));
      this.updateSub = sub.on("realTime").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));
      this.setPaused(paused);
    }
    get autoMaxIntensity() {
      return this._autoMaxIntensity;
    }
    set autoMaxIntensity(max_intensity) {
      this._autoMaxIntensity = max_intensity;
      this._autoIntensityRange = this._autoMaxIntensity - this._autoMinIntensity;
      this.needRecalcAuto = true;
    }
    get autoMinIntensity() {
      return this._autoMinIntensity;
    }
    set autoMinIntensity(min_intensity) {
      this._autoMinIntensity = min_intensity;
      this._autoIntensityRange = this._autoMinIntensity - min_intensity;
      this.needRecalcAuto = true;
    }
    setPaused(paused) {
      if (paused !== this.paused) {
        this.paused = paused;
        if (paused) {
          this.updateSub.pause();
          this.pposSub.pause();
          this.simTime.pause();
          this.needRecalcAuto = false;
        } else {
          this.needRecalcAuto = true;
          this.simTime.resume();
          this.pposSub.resume(true);
          this.updateSub.resume(true);
        }
      }
    }
    onPPosChanged(ppos) {
      const pposVec = GeoPoint.sphericalToCartesian(ppos.lat, ppos.long, BacklightLevelController.tempVec3);
      if (Vec3Math.dot(pposVec, this.ppos) >= 1 - 1e-4) {
        return;
      }
      Vec3Math.copy(pposVec, this.ppos);
      this.needRecalcAuto = true;
    }
    onUpdate() {
      const simTime = this.simTime.get();
      this.needRecalcAuto || (this.needRecalcAuto = Math.abs(simTime - this.lastSimTime) >= BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD);
      if (this.needRecalcAuto) {
        this.needRecalcAuto = false;
        this.updateAutoBacklightIntensity(simTime);
      }
    }
    updateAutoBacklightIntensity(simTime) {
      this.lastSimTime = simTime;
      const subSolarPoint = BacklightLevelController.calculateSubSolarPoint(simTime, BacklightLevelController.tempVec3);
      const sinSolarAngle = Vec3Math.dot(this.ppos, subSolarPoint);
      const sinSolarAngleClamped = Utils.Clamp(sinSolarAngle, BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN, BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN);
      const intensityFrac = (sinSolarAngleClamped - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN) / BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN;
      this._intensity.set(this._autoMinIntensity + intensityFrac * this._autoIntensityRange);
    }
    static calculateSubSolarPoint(time, out) {
      const PI2 = 2 * Math.PI;
      const days = (time - BacklightLevelController.EPOCH) / BacklightLevelController.DAY;
      const daysFrac = days - Math.floor(days);
      const L = 4.895055 + 0.01720279 * days;
      const g = 6.240041 + 0.01720197 * days;
      const lambda = L + 0.033423 * Math.sin(g) + 349e-6 * Math.sin(2 * g);
      const epsilon = 0.40910518 - 698e-11 * days;
      const rAscension = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
      const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
      const E = (((L - rAscension) % PI2 + 3 * Math.PI) % PI2 - Math.PI) * 0.159155;
      const lat = declination * Avionics.Utils.RAD2DEG;
      const lon = -15 * (daysFrac - 0.5 + E) * 24;
      return GeoPoint.sphericalToCartesian(lat, lon, out);
    }
  };
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE = 3;
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE = -8;
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MAX_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MIN_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN = BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN;
  BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ = 10;
  BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD = 6e4;
  BacklightLevelController.EPOCH = 9466848e5;
  BacklightLevelController.DAY = 864e5;
  BacklightLevelController.DEFAULT_MIN_INTENSITY = 0;
  BacklightLevelController.DEFAULT_MAX_INTENSITY = 1;
  BacklightLevelController.tempVec3 = new Float64Array(3);
  var LinearServo = class {
    constructor(rate) {
      this.rate = rate;
    }
    drive(currentValue, setValue) {
      if (this.currentTime === void 0) {
        this.currentTime = new Date().appTime();
        return currentValue;
      }
      const currentTime = new Date().appTime();
      const deltaTime = currentTime - this.currentTime;
      this.currentTime = currentTime;
      const deltaValue = setValue - currentValue;
      const maximumDrive = this.rate * (deltaTime / 1e3);
      const output = Math.abs(deltaValue) > maximumDrive ? currentValue + Math.sign(deltaValue) * maximumDrive : setValue;
      return output;
    }
    reset() {
      this.currentTime = void 0;
    }
  };
  var PidController = class {
    constructor(kP, kI, kD, maxOut, minOut, maxI = Number.MAX_SAFE_INTEGER, minI = Number.MIN_SAFE_INTEGER) {
      this.kP = kP;
      this.kI = kI;
      this.kD = kD;
      this.maxOut = maxOut;
      this.minOut = minOut;
      this.maxI = maxI;
      this.minI = minI;
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    getOutput(deltaTime, error) {
      var _a;
      const p = this.kP * error;
      if (this.previousError !== void 0 && Math.sign(error) === Math.sign(this.previousError)) {
        this.integral += (error * deltaTime + deltaTime * (error - this.previousError) / 2) * this.kI;
        this.integral = PidController.clamp(this.integral, this.maxI, this.minI);
      } else {
        this.integral = 0;
      }
      const i = this.integral;
      const d = this.kD * ((error - ((_a = this.previousError) !== null && _a !== void 0 ? _a : error)) / deltaTime);
      const output = PidController.clamp(p + i + d, this.maxOut, this.minOut);
      this.previousError = error;
      this.previousOutput = output;
      return output;
    }
    reset() {
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    static clamp(value, max, min) {
      return Math.min(Math.max(value, min), max);
    }
  };
  var ResourceModerator = class {
    constructor(resource) {
      this.resource = resource;
      this.pendingConsumer = null;
      this.assignedConsumer = null;
      this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    claim(consumer) {
      var _a;
      const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
      if (consumerToDisplace === consumer) {
        return;
      }
      if (this.queuedConsumers.has(consumer)) {
        return;
      }
      if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
        if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
          if (consumerToDisplace) {
            this.queuedConsumers.insert(consumerToDisplace);
            this.pendingConsumer = null;
          }
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        }
        this.assignedConsumer = null;
        this.pendingConsumer = consumer;
        this.queuedConsumers.insert(consumerToDisplace);
        consumerToDisplace.onCeded(this.resource);
        if (this.pendingConsumer === consumer) {
          this.pendingConsumer = null;
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        } else {
          return;
        }
      }
      this.queuedConsumers.insert(consumer);
    }
    forfeit(consumer) {
      var _a;
      if (this.pendingConsumer === consumer) {
        this.pendingConsumer = null;
        return;
      }
      if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
        this.queuedConsumers.remove(consumer);
        return;
      }
      const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
      this.pendingConsumer = next;
      this.assignedConsumer = null;
      consumer.onCeded(this.resource);
      if (next !== null && this.pendingConsumer === next) {
        this.pendingConsumer = null;
        this.assignedConsumer = next;
        this.assignedConsumer.onAcquired(this.resource);
      }
    }
  };
  var AuralAlertSystem = class {
    constructor(bus) {
      this.bus = bus;
      this.soundServerSub = this.bus.getSubscriber();
      this.controlSub = this.bus.getSubscriber();
      this.soundServerPublisher = this.bus.getPublisher();
      this.publisher = this.bus.getPublisher();
      this.registeredAlerts = /* @__PURE__ */ new Map();
      this.queueToPacketKeyMap = /* @__PURE__ */ new Map();
      this.packetKeyToQueueMap = /* @__PURE__ */ new Map();
      this.queues = /* @__PURE__ */ new Map();
      this.playing = /* @__PURE__ */ new Map();
      this.activeAliasToUuid = /* @__PURE__ */ new Map();
      this.triggeredAliasToUuid = /* @__PURE__ */ new Map();
      this.activeSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToActiveSuffixedIds = /* @__PURE__ */ new Map();
      this.triggeredSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToTriggeredSuffixedIds = /* @__PURE__ */ new Map();
      this.activeAlerts = /* @__PURE__ */ new Map();
      this.triggeredAlerts = /* @__PURE__ */ new Map();
      this.isSoundServerInit = false;
      this.isAwake = false;
      this.controlSub.on("aural_alert_register").handle(this.onAlertRegistered.bind(this));
      this.publisher.pub("aural_alert_request_all_registrations", void 0, true, false);
      this.soundServerSub.on("sound_server_packet_ended").handle(this.onPacketEnded.bind(this));
      this.controlSub.on("aural_alert_activate").handle(this.activateAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate").handle(this.deactivateAlert.bind(this));
      this.controlSub.on("aural_alert_trigger").handle(this.triggerAlert.bind(this));
      this.controlSub.on("aural_alert_untrigger").handle(this.untriggerAlert.bind(this));
      this.controlSub.on("aural_alert_kill").handle(this.killAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate_all").handle(this.deactivateAllAlerts.bind(this));
      this.controlSub.on("aural_alert_untrigger_all").handle(this.untriggerAllAlerts.bind(this));
      this.controlSub.on("aural_alert_kill_all").handle(this.killAllAlerts.bind(this));
      Wait.awaitConsumer(this.soundServerSub.on("sound_server_initialized"), (init2) => init2, true).then(() => {
        this.isSoundServerInit = true;
        for (const queue of this.queues.values()) {
          this.dequeueAlert(queue);
        }
      });
    }
    wake() {
      if (this.isAwake) {
        return;
      }
      this.isAwake = true;
      for (const alert of this.activeAlerts.values()) {
        if (alert.repeat || alert.packet.continuous) {
          this.queueAlert(alert);
        }
      }
    }
    sleep() {
      if (!this.isAwake) {
        return;
      }
      this.isAwake = false;
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const queueEntry of this.queues.values()) {
        queueEntry.queue.clear();
      }
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    onAlertRegistered(alert) {
      this.registeredAlerts.set(alert.uuid, alert);
      !this.queues.has(alert.queue) && this.createQueue(alert.queue);
    }
    createQueue(queueName) {
      const entry = {
        queue: new BinaryHeap(AuralAlertSystem.ALERT_COMPARATOR),
        debounceTimer: new DebounceTimer()
      };
      this.queues.set(queueName, entry);
      const packetKey = AuralAlertSystem.createPacketKey(queueName);
      this.queueToPacketKeyMap.set(queueName, packetKey);
      this.packetKeyToQueueMap.set(packetKey, queueName);
      return entry;
    }
    isAliasUnique(uuid, alias) {
      if (this.registeredAlerts.has(alias)) {
        return false;
      }
      const existingActive = this.activeAliasToUuid.get(alias);
      if (existingActive !== void 0 && existingActive !== uuid) {
        return false;
      }
      const existingTriggered = this.triggeredAliasToUuid.get(alias);
      if (existingTriggered !== void 0 && existingTriggered !== uuid) {
        return false;
      }
      return true;
    }
    isSuffixedIdUnique(id, suffixedId) {
      if (this.registeredAlerts.has(suffixedId) || this.activeAliasToUuid.has(suffixedId) || this.triggeredAliasToUuid.has(suffixedId)) {
        return false;
      }
      const existingActive = this.activeSuffixedIdToId.get(suffixedId);
      if (existingActive !== void 0 && existingActive !== id) {
        return false;
      }
      const existingTriggered = this.triggeredSuffixedIdToId.get(suffixedId);
      if (existingTriggered !== void 0 && existingTriggered !== id) {
        return false;
      }
      return true;
    }
    activateAlert(activation) {
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.activeAliasToUuid.set(alias, uuid);
      }
      this.activateSuffix(queuedId, suffixedId);
      if (this.activeAlerts.has(queuedId)) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.activeAlerts.set(queuedId, queuedAlert);
      if (this.isAwake) {
        this.queueAlert(queuedAlert);
      }
    }
    activateSuffix(id, suffixedId = id) {
      this.activeSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToActiveSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    triggerAlert(activation) {
      if (!this.isAwake) {
        return;
      }
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.triggeredAliasToUuid.set(alias, uuid);
      }
      this.triggerSuffix(queuedId, suffixedId);
      const existing = this.triggeredAlerts.get(queuedId);
      if (existing && this.playing.get(existing.definition.queue) === existing) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.triggeredAlerts.set(queuedId, queuedAlert);
      this.queueAlert(queuedAlert);
    }
    triggerSuffix(id, suffixedId = id) {
      this.triggeredSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToTriggeredSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    createQueuedAlert(definition, activation) {
      var _a, _b, _c, _d, _e;
      return {
        definition,
        id: (_a = activation === null || activation === void 0 ? void 0 : activation.alias) !== null && _a !== void 0 ? _a : definition.uuid,
        repeat: (_b = activation === null || activation === void 0 ? void 0 : activation.repeat) !== null && _b !== void 0 ? _b : definition.repeat,
        packet: {
          key: this.queueToPacketKeyMap.get(definition.queue),
          sequence: (_c = activation === null || activation === void 0 ? void 0 : activation.sequence) !== null && _c !== void 0 ? _c : definition.sequence,
          continuous: (_d = activation === null || activation === void 0 ? void 0 : activation.continuous) !== null && _d !== void 0 ? _d : definition.continuous,
          timeout: (_e = activation === null || activation === void 0 ? void 0 : activation.timeout) !== null && _e !== void 0 ? _e : definition.timeout
        },
        timestamp: Date.now()
      };
    }
    queueAlert(alert) {
      var _a;
      const queueName = alert.definition.queue;
      const queueEntry = (_a = this.queues.get(queueName)) !== null && _a !== void 0 ? _a : this.createQueue(queueName);
      queueEntry.queue.insert(alert);
      if (this.isSoundServerInit) {
        const playing = this.playing.get(queueName);
        if (!playing) {
          if (!queueEntry.debounceTimer.isPending()) {
            queueEntry.debounceTimer.schedule(this.dequeueAlert.bind(this, queueEntry), 0);
          }
        }
      }
    }
    dequeueAlert(entry) {
      if (this.isAwake) {
        let next = void 0;
        while (entry.queue.size > 0) {
          next = entry.queue.removeMin();
          if (this.activeAlerts.get(next.id) === next || this.triggeredAlerts.get(next.id) === next) {
            break;
          } else {
            next = void 0;
          }
        }
        if (next) {
          this.playing.set(next.definition.queue, next);
          this.soundServerPublisher.pub("sound_server_interrupt", next.packet, true, false);
        }
      } else {
        entry.queue.clear();
      }
    }
    deactivateAlert(id) {
      var _a;
      const deactivatedId = this.deactivateSuffix(id);
      if (deactivatedId === void 0) {
        return;
      }
      const deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
      if (deactivatedUuid !== deactivatedId) {
        this.activeAliasToUuid.delete(deactivatedId);
      }
      const alertDef = this.registeredAlerts.get(deactivatedUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    deactivateSuffix(suffixedId) {
      const id = this.activeSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.activeSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.activeAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.activeAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    untriggerAlert(uuid) {
      var _a;
      const untriggeredId = this.untriggerSuffix(uuid);
      if (untriggeredId === void 0) {
        return;
      }
      const untriggeredUuid = (_a = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _a !== void 0 ? _a : untriggeredId;
      if (untriggeredUuid !== untriggeredId) {
        this.triggeredAliasToUuid.delete(untriggeredId);
      }
      const alertDef = this.registeredAlerts.get(untriggeredUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    untriggerSuffix(suffixedId) {
      const id = this.triggeredSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.triggeredSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.triggeredAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.triggeredAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    killAlert(uuid) {
      var _a, _b;
      const deactivatedId = this.deactivateSuffix(uuid);
      const untriggeredId = this.untriggerSuffix(uuid);
      let deactivatedUuid = void 0;
      let untriggeredUuid = void 0;
      if (deactivatedId !== void 0) {
        deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
        if (deactivatedUuid !== deactivatedId) {
          this.activeAliasToUuid.delete(deactivatedId);
        }
      }
      if (untriggeredId !== void 0) {
        untriggeredUuid = (_b = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _b !== void 0 ? _b : untriggeredId;
        if (untriggeredUuid !== untriggeredId) {
          this.triggeredAliasToUuid.delete(untriggeredId);
        }
      }
      const deactivatedAlertDef = deactivatedUuid === void 0 ? void 0 : this.registeredAlerts.get(deactivatedUuid);
      const untriggeredAlertDef = untriggeredUuid === void 0 ? void 0 : this.registeredAlerts.get(untriggeredUuid);
      let killedPacketKey = void 0;
      if (deactivatedAlertDef) {
        const playing = this.playing.get(deactivatedAlertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
          killedPacketKey = playing.packet.key;
        }
      }
      if (untriggeredAlertDef) {
        const playing = this.playing.get(untriggeredAlertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing && killedPacketKey !== playing.packet.key) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
        }
      }
    }
    deactivateAllAlerts() {
      this.activeAlerts.clear();
      this.activeAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.triggeredAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    untriggerAllAlerts() {
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.activeAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    killAllAlerts() {
      this.activeAlerts.clear();
      this.triggeredAlerts.clear();
      this.activeAliasToUuid.clear();
      this.triggeredAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    onPacketEnded(key) {
      const queueName = this.packetKeyToQueueMap.get(key);
      if (queueName === void 0) {
        return;
      }
      const queueEntry = this.queues.get(queueName);
      if (!queueEntry) {
        this.packetKeyToQueueMap.delete(key);
        this.queueToPacketKeyMap.delete(queueName);
        return;
      }
      const finishedAlert = this.playing.get(queueName);
      if (finishedAlert) {
        if (this.triggeredAlerts.get(finishedAlert.id) === finishedAlert) {
          this.triggeredAlerts.delete(finishedAlert.id);
          if (finishedAlert.id !== finishedAlert.definition.uuid) {
            this.triggeredAliasToUuid.delete(finishedAlert.id);
          }
          const suffixedIds = this.idToTriggeredSuffixedIds.get(finishedAlert.id);
          if (suffixedIds) {
            for (const suffixedId of suffixedIds) {
              this.triggeredSuffixedIdToId.delete(suffixedId);
            }
            this.idToTriggeredSuffixedIds.delete(finishedAlert.id);
          }
        }
        if (finishedAlert.repeat && this.activeAlerts.get(finishedAlert.id) === finishedAlert) {
          this.queueAlert(finishedAlert);
        }
      }
      this.playing.delete(queueName);
      this.dequeueAlert(queueEntry);
    }
    static createPacketKey(queue) {
      return `$$aural-alert-system-queue-${queue}$$`;
    }
  };
  AuralAlertSystem.ALERT_COMPARATOR = (a, b) => {
    const priorityDiff = b.definition.priority - a.definition.priority;
    if (priorityDiff === 0) {
      return a.timestamp - b.timestamp;
    } else {
      return priorityDiff;
    }
  };
  var SoundServer = class {
    constructor(bus) {
      this.bus = bus;
      this.controlSub = this.bus.getSubscriber();
      this.publisher = this.bus.getPublisher();
      this.active = /* @__PURE__ */ new Map();
      this.queued = /* @__PURE__ */ new Map();
      this.publisher.pub("sound_server_initialized", false, true, true);
      this.init();
    }
    async init() {
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      await Wait.awaitDelay(500);
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      this.controlSub.on("sound_server_play").handle(this.playPacket.bind(this));
      this.controlSub.on("sound_server_queue").handle(this.queuePacket.bind(this));
      this.controlSub.on("sound_server_interrupt").handle(this.interruptPacket.bind(this));
      this.controlSub.on("sound_server_stop").handle(this.stopPacket.bind(this));
      this.controlSub.on("sound_server_kill").handle(this.killPacket.bind(this));
      this.controlSub.on("sound_server_stop_all").handle(this.stopAllPackets.bind(this));
      this.controlSub.on("sound_server_kill_all").handle(this.killAllPackets.bind(this));
      this.controlSub.on("sound_server_play_sound").handle(this.playSound.bind(this));
      this.controlSub.on("sound_server_start_sound").handle(this.startSound.bind(this));
      this.controlSub.on("sound_server_stop_sound").handle(this.stopPacket.bind(this));
      this.publisher.pub("sound_server_initialized", true, true, true);
    }
    onSoundEnd(id) {
      const activeEntries = Array.from(this.active.values());
      for (let i = 0; i < activeEntries.length; i++) {
        const entry = activeEntries[i];
        const entrySoundPlaying = entry.sequence[entry.currentIndexPlaying];
        if (!entrySoundPlaying) {
          this.cleanupPacket(entry);
        } else if (Name_Z.compare(entrySoundPlaying, id)) {
          this.advancePacket(entry);
        }
      }
    }
    playPacket(packet) {
      if (!this.active.get(packet.key)) {
        this.queuePacket(packet);
      }
    }
    interruptPacket(packet) {
      const active = this.active.get(packet.key);
      if (active) {
        active.alive = false;
      }
      this.queued.delete(packet.key);
      this.queuePacket(packet);
    }
    queuePacket(packet) {
      var _a;
      const sequence = SoundServer.getSoundSequence(packet);
      const entry = {
        key: packet.key,
        sequence,
        continuous: packet.continuous,
        currentIndexPlaying: 0,
        timeout: (_a = packet.timeout) !== null && _a !== void 0 ? _a : SoundServer.DEFAULT_TIMEOUT,
        alive: true,
        timer: new DebounceTimer(),
        timeoutCallback: () => {
          this.cleanupPacket(entry);
        }
      };
      if (this.active.get(packet.key)) {
        let queue = this.queued.get(entry.key);
        if (!queue) {
          this.queued.set(entry.key, queue = []);
        }
        queue.push(entry);
      } else {
        this.startPacket(entry);
      }
    }
    stopPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.continuous = false;
      }
    }
    killPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.alive = false;
      }
    }
    stopAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.continuous = false;
      }
    }
    killAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.alive = false;
      }
    }
    playSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: false });
    }
    startSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: true });
    }
    startPacket(entry) {
      this.active.set(entry.key, entry);
      this.publisher.pub("sound_server_packet_started", entry.key, true, false);
      if (entry.sequence.length === 0) {
        this.cleanupPacket(entry);
      } else {
        Coherent.call("PLAY_INSTRUMENT_SOUND", entry.sequence[0].originalStr);
        entry.currentIndexPlaying = 0;
        entry.timer.schedule(entry.timeoutCallback, entry.timeout);
      }
    }
    advancePacket(entry) {
      if (!entry.alive) {
        this.cleanupPacket(entry);
        return;
      }
      let nextSoundToPlayIndex = entry.currentIndexPlaying + 1;
      if (nextSoundToPlayIndex >= entry.sequence.length) {
        if (entry.continuous) {
          nextSoundToPlayIndex = 0;
          entry.timer.schedule(entry.timeoutCallback, entry.timeout);
        } else {
          this.cleanupPacket(entry);
          return;
        }
      }
      const soundToPlay = entry.sequence[nextSoundToPlayIndex];
      Coherent.call("PLAY_INSTRUMENT_SOUND", soundToPlay.originalStr);
      entry.currentIndexPlaying = nextSoundToPlayIndex;
    }
    cleanupPacket(entry) {
      entry.alive = false;
      entry.timer.clear();
      const deleted = this.active.delete(entry.key);
      if (!deleted) {
        return;
      }
      this.publisher.pub("sound_server_packet_ended", entry.key, true, false);
      const queue = this.queued.get(entry.key);
      if (queue) {
        const next = queue.shift();
        if (queue.length === 0) {
          this.queued.delete(entry.key);
        }
        if (next) {
          this.startPacket(next);
        }
      }
    }
    static getSoundSequence(packet) {
      const sequence = [];
      if (typeof packet.sequence === "string") {
        if (packet.sequence !== "") {
          sequence.push(new Name_Z(packet.sequence));
        }
      } else {
        for (let i = 0; i < packet.sequence.length; i++) {
          if (packet.sequence[i] !== "") {
            sequence.push(new Name_Z(packet.sequence[i]));
          }
        }
      }
      return sequence;
    }
  };
  SoundServer.DEFAULT_TIMEOUT = 1e4;
  var StringUtils = class {
    static useZeroSlash(text) {
      return text === null || text === void 0 ? void 0 : text.replace(StringUtils.ZERO_REGEX, "0\u0338");
    }
    static trimStart(str) {
      return str.replace(StringUtils.TRIM_START_REGEX, "");
    }
    static trimEnd(str) {
      return str.replace(StringUtils.TRIM_END_REGEX, "");
    }
  };
  StringUtils.DIRECT_TO = "\xD0";
  StringUtils.DEGREE = "\xB0";
  StringUtils.EN_DASH = "\u2013";
  StringUtils.ZERO_REGEX = /0/g;
  StringUtils.TRIM_START_REGEX = /^\s+/;
  StringUtils.TRIM_END_REGEX = /\s+$/;
  var AnnunciationType;
  (function(AnnunciationType2) {
    AnnunciationType2[AnnunciationType2["Warning"] = 0] = "Warning";
    AnnunciationType2[AnnunciationType2["Caution"] = 1] = "Caution";
    AnnunciationType2[AnnunciationType2["Advisory"] = 2] = "Advisory";
    AnnunciationType2[AnnunciationType2["SafeOp"] = 3] = "SafeOp";
  })(AnnunciationType || (AnnunciationType = {}));
  var RenderPosition;
  (function(RenderPosition2) {
    RenderPosition2[RenderPosition2["Before"] = 0] = "Before";
    RenderPosition2[RenderPosition2["After"] = 1] = "After";
    RenderPosition2[RenderPosition2["In"] = 2] = "In";
  })(RenderPosition || (RenderPosition = {}));
  var DisplayComponent = class {
    constructor(props) {
      this.context = void 0;
      this.contextType = void 0;
      this.props = props;
    }
    onBeforeRender() {
      return;
    }
    onAfterRender(node) {
      return;
    }
    destroy() {
      return;
    }
    getContext(context) {
      if (this.context !== void 0 && this.contextType !== void 0) {
        const index = this.contextType.indexOf(context);
        return this.context[index];
      }
      throw new Error("Could not find the provided context type.");
    }
  };
  var NodeReference = class {
    constructor() {
      this._instance = null;
    }
    get instance() {
      if (this._instance !== null) {
        return this._instance;
      }
      throw new Error("Instance was null.");
    }
    set instance(val) {
      this._instance = val;
    }
    getOrDefault() {
      return this._instance;
    }
  };
  var Context = class {
    constructor(defaultValue) {
      this.defaultValue = defaultValue;
      this.Provider = (props) => new ContextProvider(props, this);
    }
  };
  var ContextProvider = class extends DisplayComponent {
    constructor(props, parent) {
      super(props);
      this.parent = parent;
    }
    render() {
      var _a;
      const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
      return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
  };
  var FSComponent;
  (function(FSComponent2) {
    const svgTags = {
      "circle": true,
      "clipPath": true,
      "color-profile": true,
      "cursor": true,
      "defs": true,
      "desc": true,
      "ellipse": true,
      "g": true,
      "image": true,
      "line": true,
      "linearGradient": true,
      "marker": true,
      "mask": true,
      "path": true,
      "pattern": true,
      "polygon": true,
      "polyline": true,
      "radialGradient": true,
      "rect": true,
      "stop": true,
      "svg": true,
      "text": true
    };
    function Fragment2(props) {
      return props.children;
    }
    FSComponent2.Fragment = Fragment2;
    function buildComponent(type, props, ...children) {
      let vnode = null;
      if (typeof type === "string") {
        let element;
        if (svgTags[type] !== void 0) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
        if (props !== null) {
          for (const key in props) {
            if (key === "ref" && props.ref !== void 0) {
              props.ref.instance = element;
            } else {
              const prop = props[key];
              if (key === "class" && typeof prop === "object" && "isSubscribableSet" in prop) {
                prop.sub((set, eventType, modifiedKey) => {
                  if (eventType === SubscribableSetEventType.Added) {
                    element.classList.add(modifiedKey);
                  } else {
                    element.classList.remove(modifiedKey);
                  }
                }, true);
              } else if (typeof prop === "object" && "isSubscribable" in prop) {
                if (key === "style" && prop instanceof ObjectSubject) {
                  prop.sub((v, style, newValue) => {
                    element.style.setProperty(style.toString(), newValue);
                  }, true);
                } else {
                  prop.sub((v) => {
                    element.setAttribute(key, v);
                  }, true);
                }
              } else {
                element.setAttribute(key, prop);
              }
            }
          }
        }
        vnode = {
          instance: element,
          props,
          children: null
        };
        vnode.children = createChildNodes(vnode, children);
      } else if (typeof type === "function") {
        if (children !== null && props === null) {
          props = {
            children
          };
        } else if (props !== null) {
          props.children = children;
        }
        if (typeof type === "function" && type.name === Fragment2.name) {
          let childNodes = type(props);
          while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
            childNodes = childNodes[0];
          }
          vnode = {
            instance: null,
            props,
            children: childNodes
          };
        } else {
          let instance;
          const pluginSystem = window._pluginSystem;
          try {
            instance = type(props);
          } catch (_a) {
            let pluginInstance = void 0;
            if (pluginSystem !== void 0) {
              pluginInstance = pluginSystem.onComponentCreating(type, props);
            }
            if (pluginInstance !== void 0) {
              instance = pluginInstance;
            } else {
              instance = new type(props);
            }
          }
          if (props !== null && props.ref !== null && props.ref !== void 0) {
            props.ref.instance = instance;
          }
          if (instance.contextType !== void 0) {
            instance.context = instance.contextType.map((c) => Subject.create(c.defaultValue));
          }
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentCreated(instance);
          }
          vnode = {
            instance,
            props,
            children: [instance.render()]
          };
        }
      }
      return vnode;
    }
    FSComponent2.buildComponent = buildComponent;
    function createChildNodes(parent, children) {
      let vnodes = null;
      if (children !== null && children !== void 0 && children.length > 0) {
        vnodes = [];
        for (const child of children) {
          if (child !== null) {
            if (child instanceof Array) {
              const arrayNodes = createChildNodes(parent, child);
              if (arrayNodes !== null) {
                vnodes.push(...arrayNodes);
              }
            } else if (typeof child === "object") {
              if ("isSubscribable" in child) {
                const node = {
                  instance: child,
                  children: null,
                  props: null,
                  root: void 0
                };
                child.sub((v) => {
                  if (node.root !== void 0) {
                    node.root.nodeValue = v === "" || v === null || v === void 0 ? " " : v.toString();
                  }
                });
                vnodes.push(node);
              } else {
                vnodes.push(child);
              }
            } else if (typeof child === "string" || typeof child === "number") {
              vnodes.push(createStaticContentNode(child));
            }
          }
        }
      }
      return vnodes;
    }
    FSComponent2.createChildNodes = createChildNodes;
    function createStaticContentNode(content) {
      return {
        instance: content,
        children: null,
        props: null
      };
    }
    FSComponent2.createStaticContentNode = createStaticContentNode;
    function render2(node, element, position = RenderPosition.In) {
      if (node.children && node.children.length > 0 && element !== null) {
        const componentInstance = node.instance;
        if (componentInstance !== null && componentInstance.onBeforeRender !== void 0) {
          componentInstance.onBeforeRender();
        }
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
          insertNode(node, position, element);
        } else {
          if (position === RenderPosition.After) {
            for (let i = node.children.length - 1; i >= 0; i--) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          } else {
            for (let i = 0; i < node.children.length; i++) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          }
        }
        const instance = node.instance;
        if (instance instanceof ContextProvider) {
          visitNodes(node, (n) => {
            if (n === void 0 || n === null) {
              return false;
            }
            const nodeInstance = n.instance;
            if (nodeInstance !== null && nodeInstance.contextType !== void 0) {
              const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
              if (contextSlot >= 0) {
                if (nodeInstance.context === void 0) {
                  nodeInstance.context = [];
                }
                nodeInstance.context[contextSlot].set(instance.props.value);
              }
              if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                return true;
              }
            }
            return false;
          });
        }
        if (componentInstance !== null && componentInstance.onAfterRender !== void 0) {
          const pluginSystem = window._pluginSystem;
          componentInstance.onAfterRender(node);
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentRendered(node);
          }
        }
      }
    }
    FSComponent2.render = render2;
    function insertNode(node, position, element) {
      var _a, _b, _c, _d, _e, _f;
      if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
        switch (position) {
          case RenderPosition.In:
            element.appendChild(node.instance);
            node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentElement("beforebegin", node.instance);
            node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentElement("afterend", node.instance);
            node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : void 0;
            break;
        }
        if (node.children !== null) {
          for (const child of node.children) {
            insertNode(child, RenderPosition.In, node.instance);
          }
        }
      } else if (typeof node.instance === "string" || typeof node.instance === "object" && node.instance !== null && "isSubscribable" in node.instance) {
        let toRender;
        if (typeof node.instance === "string") {
          toRender = node.instance;
        } else {
          toRender = node.instance.get();
          if (toRender === "") {
            toRender = " ";
          }
        }
        switch (position) {
          case RenderPosition.In:
            element.insertAdjacentHTML("beforeend", toRender);
            node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentHTML("beforebegin", toRender);
            node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentHTML("afterend", toRender);
            node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : void 0;
            break;
        }
      } else if (Array.isArray(node)) {
        if (position === RenderPosition.After) {
          for (let i = node.length - 1; i >= 0; i--) {
            render2(node[i], element, position);
          }
        } else {
          for (let i = 0; i < node.length; i++) {
            render2(node[i], element, position);
          }
        }
      } else {
        render2(node, element, position);
      }
    }
    function renderBefore(node, element) {
      render2(node, element, RenderPosition.Before);
    }
    FSComponent2.renderBefore = renderBefore;
    function renderAfter(node, element) {
      render2(node, element, RenderPosition.After);
    }
    FSComponent2.renderAfter = renderAfter;
    function remove(element) {
      if (element !== null) {
        element.remove();
      }
    }
    FSComponent2.remove = remove;
    function createRef() {
      return new NodeReference();
    }
    FSComponent2.createRef = createRef;
    function createContext(defaultValue) {
      return new Context(defaultValue);
    }
    FSComponent2.createContext = createContext;
    function visitNodes(node, visitor) {
      if (node === void 0 || node === null) {
        return;
      }
      const stopVisitation = visitor(node);
      if (!stopVisitation && node.children !== void 0 && node.children !== null) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (Array.isArray(child)) {
            for (let childIndex = 0; childIndex < child.length; childIndex++) {
              visitNodes(child[childIndex], visitor);
            }
          } else {
            visitNodes(child, visitor);
          }
        }
      }
      return;
    }
    FSComponent2.visitNodes = visitNodes;
    function parseCssClassesFromString(classString, filter) {
      return classString.split(" ").filter((str) => str !== "" && (filter === void 0 || filter(str)));
    }
    FSComponent2.parseCssClassesFromString = parseCssClassesFromString;
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
      const reservedClassSet = new Set(reservedClasses);
      if (reservedClassSet.size === 0) {
        return classesToSubscribe.sub((set, type, key) => {
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      } else {
        return classesToSubscribe.sub((set, type, key) => {
          if (reservedClassSet.has(key)) {
            return;
          }
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      }
    }
    FSComponent2.bindCssClassSet = bindCssClassSet;
    function shallowDestroy(root) {
      FSComponent2.visitNodes(root, (node) => {
        if (node !== root && node.instance instanceof DisplayComponent) {
          node.instance.destroy();
          return true;
        }
        return false;
      });
    }
    FSComponent2.shallowDestroy = shallowDestroy;
    FSComponent2.EmptyHandler = () => {
      return;
    };
  })(FSComponent || (FSComponent = {}));
  var Fragment = FSComponent.Fragment;
  var BingComponent = class extends DisplayComponent {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
      this.isListenerRegistered = false;
      this.imgRef = FSComponent.createRef();
      this.uid = 0;
      this._isBound = false;
      this._isAwake = true;
      this.isDestroyed = false;
      this.pos = new LatLong(0, 0);
      this.radius = 10;
      this.resolution = (_a = this.props.resolution) !== null && _a !== void 0 ? _a : Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION));
      this.earthColors = (_b = this.props.earthColors) !== null && _b !== void 0 ? _b : ArraySubject.create(ArrayUtils.create(2, () => BingComponent.hexaToRGBColor("#000000")));
      this.earthColorsElevationRange = (_c = this.props.earthColorsElevationRange) !== null && _c !== void 0 ? _c : Vec2Subject.create(Vec2Math.create(0, 3e4));
      this.skyColor = (_d = this.props.skyColor) !== null && _d !== void 0 ? _d : Subject.create(BingComponent.hexaToRGBColor("#000000"));
      this.reference = (_e = this.props.reference) !== null && _e !== void 0 ? _e : Subject.create(EBingReference.SEA);
      this.wxrMode = (_f = this.props.wxrMode) !== null && _f !== void 0 ? _f : Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 });
      this.wxrColors = (_g = this.props.wxrColors) !== null && _g !== void 0 ? _g : ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this.isoLines = (_h = this.props.isoLines) !== null && _h !== void 0 ? _h : Subject.create(false);
      this.wxrColorsArray = [];
      this.wxrRateArray = [];
      this.resolutionHandler = (resolution) => {
        Coherent.call("SET_MAP_RESOLUTION", this.uid, resolution[0], resolution[1]);
        this.positionRadiusInhibitFramesRemaining = BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;
        if (!this.positionRadiusInhibitTimer.isPending()) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        }
      };
      this.earthColorsHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        Coherent.call("SET_MAP_HEIGHT_COLORS", this.uid, colors);
      };
      this.earthColorsElevationRangeHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        const range = this.earthColorsElevationRange.get();
        const terrainColorCount = colors.length - 1;
        const desiredElevationStep = (range[1] - range[0]) / Math.max(terrainColorCount - 1, 1);
        const requiredMin = range[0] - desiredElevationStep;
        const requiredMax = range[1] + desiredElevationStep;
        Coherent.call("SET_MAP_ALTITUDE_RANGE", this.uid, requiredMin, requiredMax);
      };
      this.skyColorHandler = (color) => {
        Coherent.call("SET_MAP_CLEAR_COLOR", this.uid, color);
      };
      this.referenceHandler = (reference) => {
        const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
        this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, flags);
      };
      this.wxrModeHandler = (wxrMode) => {
        Coherent.call("SHOW_MAP_WEATHER", this.uid, wxrMode.mode, wxrMode.arcRadians);
      };
      this.wxrColorsHandler = () => {
        const array = this.wxrColors.getArray();
        if (array.length === 0) {
          return;
        }
        this.wxrColorsArray.length = array.length;
        this.wxrRateArray.length = array.length;
        for (let i = 0; i < array.length; i++) {
          this.wxrColorsArray[i] = array[i][0];
          this.wxrRateArray[i] = array[i][1];
        }
        Coherent.call("SET_MAP_WEATHER_RADAR_COLORS", this.uid, this.wxrColorsArray, this.wxrRateArray);
      };
      this.isoLinesHandler = (showIsolines) => {
        Coherent.call("SHOW_MAP_ISOLINES", this.uid, showIsolines);
      };
      this.setCurrentMapParamsTimer = null;
      this.positionRadiusInhibitFramesRemaining = 0;
      this.isPositionRadiusPending = false;
      this.positionRadiusInhibitTimer = new DebounceTimer();
      this.processPendingPositionRadius = () => {
        if (this.isPositionRadiusPending) {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
        if (--this.positionRadiusInhibitFramesRemaining > 0) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        } else {
          this.isPositionRadiusPending = false;
        }
      };
      this.onListenerBound = (binder, uid) => {
        if (this.isDestroyed) {
          return;
        }
        if (binder.friendlyName === this.props.id) {
          this.binder = binder;
          this.uid = uid;
          if (this._isBound) {
            return;
          }
          this._isBound = true;
          Coherent.call("SHOW_MAP", uid, true);
          const pause = !this._isAwake;
          this.earthColorsSub = this.earthColors.sub(() => {
            this.earthColorsHandler();
            this.earthColorsElevationRangeHandler();
          }, true, pause);
          this.earthColorsElevationRangeSub = this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler, true, pause);
          this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true, pause);
          this.referenceSub = this.reference.sub(this.referenceHandler, true, pause);
          this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true, pause);
          this.wxrColorsSub = this.wxrColors.sub(this.wxrColorsHandler, true, pause);
          this.resolutionSub = this.resolution.sub(this.resolutionHandler, true, pause);
          this.isoLinesSub = this.isoLines.sub(this.isoLinesHandler, true, pause);
          if (this.modeFlags !== 4) {
            Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
          }
          this.props.onBoundCallback && this.props.onBoundCallback(this);
        }
      };
      this.onMapUpdate = (uid, imgSrc) => {
        if (this.binder !== void 0 && this.uid === uid && this.imgRef.instance !== null) {
          if (this.imgRef.instance.src !== imgSrc) {
            this.imgRef.instance.src = imgSrc;
          }
        }
      };
      this.setCurrentMapParams = () => {
        this.setPositionRadius(this.pos, this.radius);
      };
    }
    isBound() {
      return this._isBound;
    }
    isAwake() {
      return this._isAwake;
    }
    onAfterRender() {
      if (window["IsDestroying"]) {
        this.destroy();
        return;
      }
      const gameStateSubscribable = GameStateProvider.get();
      const gameState = gameStateSubscribable.get();
      if (gameState === GameState.briefing || gameState === GameState.ingame) {
        this.registerListener();
      } else {
        this.gameStateSub = gameStateSubscribable.sub((state) => {
          var _a;
          if (this.isDestroyed) {
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.registerListener();
          }
        });
      }
      window.addEventListener("OnDestroy", this.destroy.bind(this));
    }
    registerListener() {
      var _a;
      if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
        setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
        }, this.props.delay);
      } else {
        this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
      }
    }
    onListenerRegistered() {
      if (this.isDestroyed || this.isListenerRegistered) {
        return;
      }
      this.mapListener.on("MapBinded", this.onListenerBound);
      this.mapListener.on("MapUpdated", this.onMapUpdate);
      this.isListenerRegistered = true;
      this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, this.modeFlags);
    }
    wake() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = true;
      if (!this._isBound) {
        return;
      }
      this.setCurrentMapParams();
      if (this.modeFlags !== 4) {
        this.setCurrentMapParamsTimer = setInterval(this.setCurrentMapParams, 200);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.resume(true);
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.resume(true);
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.resume(true);
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.resume(true);
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.resume(true);
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.resume(true);
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.resume(true);
    }
    sleep() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = false;
      if (!this._isBound) {
        return;
      }
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.pause();
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.pause();
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.pause();
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.pause();
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.pause();
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.pause();
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.pause();
    }
    setPositionRadius(pos, radius) {
      this.pos = pos;
      this.radius = Math.max(radius, 10);
      if (this._isBound && this._isAwake) {
        if (this.positionRadiusInhibitFramesRemaining > 0) {
          this.isPositionRadiusPending = true;
        } else {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
      }
    }
    render() {
      var _a;
      return FSComponent.buildComponent("img", { ref: this.imgRef, src: "", style: "position: absolute; left: 0; top: 0; width: 100%; height: 100%;", class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      this.isDestroyed = true;
      this._isBound = false;
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.earthColorsSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.earthColorsElevationRangeSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.skyColorSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.referenceSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.wxrModeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.wxrColorsSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.resolutionSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.isoLinesSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.mapListener) === null || _k === void 0 ? void 0 : _k.off("MapBinded", this.onListenerBound);
      (_l = this.mapListener) === null || _l === void 0 ? void 0 : _l.off("MapUpdated", this.onMapUpdate);
      (_m = this.mapListener) === null || _m === void 0 ? void 0 : _m.trigger("JS_UNBIND_BINGMAP", this.props.id);
      this.isListenerRegistered = false;
      this.imgRef.instance.src = "";
      (_o = this.imgRef.instance.parentNode) === null || _o === void 0 ? void 0 : _o.removeChild(this.imgRef.instance);
      super.destroy();
    }
    resetImgSrc() {
      const imgRef = this.imgRef.getOrDefault();
      if (imgRef !== null) {
        const currentSrc = imgRef.src;
        imgRef.src = "";
        imgRef.src = currentSrc;
      }
    }
    static hexaToRGBColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      return BingComponent.rgbColor(r, g, b);
    }
    static rgbToHexaColor(rgb, poundPrefix = true) {
      const b = Math.floor(rgb % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgb % (256 * 256) / 256);
      const r = rgb % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
    }
    static rgbColor(r, g, b) {
      return 256 * 256 * b + 256 * g + r;
    }
    static hexaToRGBAColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      const a = parseInt(hexStringColor.substr(6 + offset, 2), 16);
      return BingComponent.rgbaColor(r, g, b, a);
    }
    static rgbaToHexaColor(rgba, poundPrefix = true) {
      const a = Math.floor(rgba % (256 * 256 * 256 * 256) / (256 * 256 * 256));
      const b = Math.floor(rgba % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgba % (256 * 256) / 256);
      const r = rgba % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}${a.toString(16).padStart(2, "0")}`;
    }
    static rgbaColor(r, g, b, a) {
      return 256 * 256 * 256 * a + 256 * 256 * b + 256 * g + r;
    }
    static createEarthColorsArray(waterColor, terrainColors, minElevation = 0, maxElevation = 3e4, stepCount = 61) {
      const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
      const curve = new Avionics.Curve();
      curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
      for (let i = 0; i < terrainColors.length; i++) {
        curve.add(terrainColors[i].elev, terrainColors[i].color);
      }
      const elevationStep = (maxElevation - minElevation) / Math.max(stepCount - 1, 1);
      for (let i = 0; i < stepCount; i++) {
        const color = curve.evaluate(minElevation + i * elevationStep);
        earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
      }
      return earthColors;
    }
  };
  BingComponent.DEFAULT_RESOLUTION = 1024;
  BingComponent.DEFAULT_WEATHER_COLORS = [
    [BingComponent.hexaToRGBAColor("#00000000"), 0.5],
    [BingComponent.hexaToRGBAColor("#004d00ff"), 2.75],
    [BingComponent.hexaToRGBAColor("#cb7300ff"), 12.5],
    [BingComponent.hexaToRGBAColor("#ff0000ff"), 12.5]
  ];
  BingComponent.POSITION_RADIUS_INHIBIT_FRAMES = 10;
  var DurationDisplayFormat;
  (function(DurationDisplayFormat2) {
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_ss"] = 0] = "hh_mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm"] = 1] = "hh_mm";
    DurationDisplayFormat2[DurationDisplayFormat2["mm_ss"] = 2] = "mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_or_mm_ss"] = 3] = "hh_mm_or_mm_ss";
  })(DurationDisplayFormat || (DurationDisplayFormat = {}));
  var DurationDisplayDelim;
  (function(DurationDisplayDelim2) {
    DurationDisplayDelim2[DurationDisplayDelim2["Colon"] = 0] = "Colon";
    DurationDisplayDelim2[DurationDisplayDelim2["ColonOrCross"] = 1] = "ColonOrCross";
    DurationDisplayDelim2[DurationDisplayDelim2["Space"] = 2] = "Space";
  })(DurationDisplayDelim || (DurationDisplayDelim = {}));
  var DurationDisplay = class extends DisplayComponent {
    constructor(props) {
      super(props);
      this.value = "isSubscribable" in this.props.value ? this.props.value : Subject.create(this.props.value);
      this.options = Object.assign({}, DurationDisplay.DEFAULT_OPTIONS, this.props.options);
      this.negativeSign = this.options.useMinusSign ? "\u2212" : "-";
      this.positiveSign = this.options.forceSign ? "+" : "";
      this.text = Subject.create("");
      switch (this.options.delim) {
        case DurationDisplayDelim.Colon:
          this.delim = ":";
          break;
        case DurationDisplayDelim.Space:
          this.delim = " ";
          break;
        default:
          this.delim = "";
      }
    }
    onAfterRender() {
      this.valueSub = this.value.sub(this.onValueChanged.bind(this), true);
    }
    onValueChanged(value) {
      this.setDisplay(value);
    }
    setDisplay(value) {
      let text;
      if (value.isNaN()) {
        text = this.options.nanString;
      } else {
        let hrText = "";
        let minText = "";
        let secText = "";
        let hrUnitText = "";
        let minUnitText = "";
        let secUnitText = "";
        let hrDelim = "";
        let minDelim = "";
        const valueAsSeconds = Math.abs(value.asUnit(UnitType.SECOND));
        const isNegative = value.number < 0;
        let hours = Math.floor(valueAsSeconds / 3600);
        if (this.options.format != DurationDisplayFormat.mm_ss && !(this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours == 0)) {
          hrText = hours.toFixed(0);
          if (this.options.delim === DurationDisplayDelim.ColonOrCross) {
            if (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss || this.options.format === DurationDisplayFormat.hh_mm) {
              hrDelim = "+";
            } else {
              hrDelim = ":";
            }
          } else {
            hrDelim = this.delim;
          }
        }
        const hoursInMinutes = hours * 60;
        let minutes;
        let seconds;
        if (this.options.format === DurationDisplayFormat.hh_mm || this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours !== 0) {
          minutes = valueAsSeconds / 60 - hoursInMinutes;
          minText = this.options.numberFormatter(minutes);
        } else {
          minutes = Math.floor(valueAsSeconds / 60 - hoursInMinutes);
          minText = minutes.toFixed(0);
          minDelim = this.options.delim === DurationDisplayDelim.ColonOrCross ? ":" : this.delim;
          seconds = valueAsSeconds - (hoursInMinutes + minutes) * 60;
          secText = this.options.numberFormatter(seconds);
        }
        if (secText && secText.replace(/\b0+/, "").substring(0, 2) === "60") {
          seconds = parseFloat(secText) - 60;
          minutes++;
          secText = this.options.numberFormatter(seconds);
          minText = `${minutes}`;
        }
        if (minText && minText.replace(/\b0+/, "").substring(0, 2) === "60" && hrText) {
          if (secText) {
            minutes = 0;
            minText = "00";
          } else {
            minutes = parseFloat(minText) - 60;
            minText = this.options.numberFormatter(minutes);
          }
          hours++;
          hrText = `${hours}`;
        }
        if (hrText) {
          hrText = hrText.padStart(this.options.pad, "0");
          if (secText) {
            minText = minText.padStart(2, "0");
            secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
          } else {
            minText = DurationDisplay.padIntegerPart(minText.replace(/^0+/, ""), 2, "0");
          }
        } else {
          minText = minText.padStart(this.options.pad, "0");
          secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
        }
        if (this.options.showUnits) {
          hrText && (hrUnitText = this.options.unitFormatter(parseFloat(hrText), UnitType.HOUR));
          minUnitText = this.options.unitFormatter(parseFloat(minText), UnitType.MINUTE);
          secText && (secUnitText = this.options.unitFormatter(parseFloat(secText), UnitType.SECOND));
        }
        const sign = isNegative ? this.negativeSign : this.positiveSign;
        text = `${sign}${hrText}${hrUnitText}${hrDelim}${minText}${minUnitText}${minDelim}${secText}${secUnitText}`;
      }
      this.text.set(text);
    }
    static padIntegerPart(str, maxLength, fillString) {
      const decimalIndex = str.indexOf(".");
      return str.padStart(decimalIndex < 0 ? maxLength : str.length - decimalIndex + maxLength, fillString);
    }
    render() {
      var _a;
      return FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: "white-space: nowrap;" }, this.text);
    }
    destroy() {
      var _a;
      (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  DurationDisplay.DEFAULT_OPTIONS = {
    pad: 0,
    format: DurationDisplayFormat.hh_mm_ss,
    delim: DurationDisplayDelim.Colon,
    showUnits: false,
    numberFormatter: (value) => value.toFixed(0),
    unitFormatter: (value, unit) => unit.name[0],
    useMinusSign: false,
    forceSign: false,
    nanString: ""
  };
  var DmsDirection;
  (function(DmsDirection2) {
    DmsDirection2["NORTH"] = "N";
    DmsDirection2["SOUTH"] = "S";
    DmsDirection2["WEST"] = "W";
    DmsDirection2["EAST"] = "E";
  })(DmsDirection || (DmsDirection = {}));
  var FocusPosition;
  (function(FocusPosition2) {
    FocusPosition2["MostRecent"] = "MostRecent";
    FocusPosition2["First"] = "First";
    FocusPosition2["Last"] = "Last";
    FocusPosition2["None"] = "None";
  })(FocusPosition || (FocusPosition = {}));
  var BlurReconciliation;
  (function(BlurReconciliation2) {
    BlurReconciliation2["First"] = "First";
    BlurReconciliation2["Last"] = "Last";
    BlurReconciliation2["Next"] = "Next";
    BlurReconciliation2["Prev"] = "Prev";
    BlurReconciliation2["None"] = "None";
  })(BlurReconciliation || (BlurReconciliation = {}));
  var HorizonProjectionChangeType;
  (function(HorizonProjectionChangeType2) {
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Position"] = 1] = "Position";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Altitude"] = 2] = "Altitude";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Heading"] = 4] = "Heading";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Pitch"] = 8] = "Pitch";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Roll"] = 16] = "Roll";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Offset"] = 32] = "Offset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedSize"] = 64] = "ProjectedSize";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Fov"] = 128] = "Fov";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["FovEndpoints"] = 256] = "FovEndpoints";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ScaleFactor"] = 512] = "ScaleFactor";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedOffset"] = 1024] = "ProjectedOffset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["OffsetCenterProjected"] = 2048] = "OffsetCenterProjected";
  })(HorizonProjectionChangeType || (HorizonProjectionChangeType = {}));
  var HorizonProjection = class {
    constructor(projectedWidth, projectedHeight, fov) {
      this.position = new GeoPoint(0, 0);
      this.altitude = 0;
      this.heading = 0;
      this.roll = 0;
      this.pitch = 0;
      this.offset = Vec3Math.create();
      this.fovEndpoints = VecNMath.create(4, 0.5, 0, 0.5, 1);
      this.scaleFactor = 1;
      this.projectedOffset = Vec2Math.create();
      this.offsetCenterProjected = Vec2Math.create();
      this.positionAngleTransforms = [new Transform3D(), new Transform3D()];
      this.altitudeTransform = new Transform3D();
      this.positionAltitudeTransforms = [...this.positionAngleTransforms, this.altitudeTransform];
      this.positionTransform = new Transform3D();
      this.planeAngles = Vec3Math.create();
      this.planeAngleTransforms = [new Transform3D(), new Transform3D(), new Transform3D()];
      this.planeTransform = new Transform3D();
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create();
      this.perspectiveTransform = new TransformPerspective();
      this.oldParameters = {
        position: new GeoPoint(0, 0),
        altitude: 0,
        heading: 0,
        pitch: 0,
        roll: 0,
        offset: Vec3Math.create(),
        projectedSize: Vec2Math.create(),
        fov: 0,
        fovEndpoints: VecNMath.create(4),
        scaleFactor: 1,
        projectedOffset: Vec2Math.create(),
        offsetCenterProjected: Vec2Math.create()
      };
      this.queuedParameters = {};
      this.updateQueued = false;
      this.changeEvent = new SubEvent();
      this.projectedSize = Vec2Math.create(projectedWidth, projectedHeight);
      this.fov = fov;
      this.recompute();
    }
    getPosition() {
      return this.position.readonly;
    }
    getAltitude() {
      return this.altitude;
    }
    getHeading() {
      return this.heading;
    }
    getPitch() {
      return this.pitch;
    }
    getRoll() {
      return this.roll;
    }
    getProjectedSize() {
      return this.projectedSize;
    }
    getFov() {
      return this.fov;
    }
    getFovEndpoints() {
      return this.fovEndpoints;
    }
    getFocalLength() {
      return this.surfacePos[2];
    }
    getScaleFactor() {
      return this.scaleFactor;
    }
    getProjectedOffset() {
      return this.projectedOffset;
    }
    getOffsetCenterProjected() {
      return this.offsetCenterProjected;
    }
    recompute() {
      Vec2Math.set(this.projectedSize[0] / 2 + this.projectedOffset[0], this.projectedSize[1] / 2 + this.projectedOffset[1], this.offsetCenterProjected);
      this.positionAngleTransforms[0].toRotationZ(-this.position.lon * Avionics.Utils.DEG2RAD);
      this.positionAngleTransforms[1].toRotationY(this.position.lat * Avionics.Utils.DEG2RAD);
      this.altitudeTransform.toTranslation(-(UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + this.altitude), 0, 0);
      Transform3D.concat(this.positionTransform, this.positionAltitudeTransforms);
      this.planeAngles[0] = -this.heading * Avionics.Utils.DEG2RAD;
      this.planeAngles[1] = this.pitch * Avionics.Utils.DEG2RAD;
      this.planeAngles[2] = this.roll * Avionics.Utils.DEG2RAD;
      this.planeAngleTransforms[0].toRotationZ(this.planeAngles[2]);
      this.planeAngleTransforms[1].toRotationY(this.planeAngles[1]);
      this.planeAngleTransforms[2].toRotationX(this.planeAngles[0]);
      Transform3D.concat(this.planeTransform, this.planeAngleTransforms);
      this.planeTransform.apply(this.offset, this.cameraPos);
      this.scaleFactor = Math.hypot(this.fovEndpoints[2] * this.projectedSize[0] - this.fovEndpoints[0] * this.projectedSize[0], this.fovEndpoints[3] * this.projectedSize[1] - this.fovEndpoints[1] * this.projectedSize[1]);
      this.surfacePos[2] = 1 / (2 * Math.tan(this.fov * 0.5 * Avionics.Utils.DEG2RAD));
      this.perspectiveTransform.set(this.cameraPos, this.planeTransform, this.surfacePos);
    }
    set(parameters) {
      var _a, _b, _c, _d, _e;
      this.storeParameters(this.oldParameters);
      parameters.position !== void 0 && this.position.set(parameters.position);
      this.altitude = (_a = parameters.altitude) !== null && _a !== void 0 ? _a : this.altitude;
      this.heading = (_b = parameters.heading) !== null && _b !== void 0 ? _b : this.heading;
      this.pitch = (_c = parameters.pitch) !== null && _c !== void 0 ? _c : this.pitch;
      this.roll = (_d = parameters.roll) !== null && _d !== void 0 ? _d : this.roll;
      parameters.offset !== void 0 && this.offset.set(parameters.offset);
      parameters.projectedSize !== void 0 && this.projectedSize.set(parameters.projectedSize);
      this.fov = (_e = parameters.fov) !== null && _e !== void 0 ? _e : this.fov;
      parameters.fovEndpoints !== void 0 && this.fovEndpoints.set(parameters.fovEndpoints);
      parameters.projectedOffset !== void 0 && this.projectedOffset.set(parameters.projectedOffset);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        this.changeEvent.notify(this, changeFlags);
      }
    }
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    storeParameters(record) {
      record.position.set(this.position);
      record.altitude = this.altitude;
      record.heading = this.heading;
      record.pitch = this.pitch;
      record.roll = this.roll;
      record.offset.set(this.offset);
      record.projectedSize.set(this.projectedSize);
      record.fov = this.fov;
      record.fovEndpoints.set(this.fovEndpoints);
      record.scaleFactor = this.scaleFactor;
      record.projectedOffset.set(this.projectedOffset);
      record.offsetCenterProjected.set(this.offsetCenterProjected);
    }
    computeChangeFlags(oldParameters) {
      return (oldParameters.position.equals(this.position) ? 0 : HorizonProjectionChangeType.Position) | (oldParameters.altitude === this.altitude ? 0 : HorizonProjectionChangeType.Altitude) | (oldParameters.heading === this.heading ? 0 : HorizonProjectionChangeType.Heading) | (oldParameters.pitch === this.pitch ? 0 : HorizonProjectionChangeType.Pitch) | (oldParameters.roll === this.roll ? 0 : HorizonProjectionChangeType.Roll) | (Vec3Math.equals(oldParameters.offset, this.offset) ? 0 : HorizonProjectionChangeType.Offset) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : HorizonProjectionChangeType.ProjectedSize) | (oldParameters.fov === this.fov ? 0 : HorizonProjectionChangeType.Fov) | (VecNMath.equals(oldParameters.fovEndpoints, this.fovEndpoints) ? 0 : HorizonProjectionChangeType.ProjectedOffset) | (Vec2Math.equals(oldParameters.projectedOffset, this.projectedOffset) ? 0 : HorizonProjectionChangeType.ProjectedOffset);
    }
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.scaleFactor === this.scaleFactor ? 0 : HorizonProjectionChangeType.ScaleFactor) | (Vec2Math.equals(oldParameters.offsetCenterProjected, this.offsetCenterProjected) ? 0 : HorizonProjectionChangeType.OffsetCenterProjected);
    }
    onChange(listener) {
      return this.changeEvent.on(listener);
    }
    project(position, altitude, out) {
      const vec = GeoPoint.sphericalToCartesian(position, HorizonProjection.vec3Cache[0]);
      Vec3Math.multScalar(vec, UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + altitude, vec);
      this.positionTransform.apply(vec, vec);
      return this.projectRelativeVec(vec, out);
    }
    projectRelativeSpherical(bearing, distance, height, out) {
      return this.project(this.position.offset(bearing, UnitType.METER.convertTo(distance, UnitType.GA_RADIAN), HorizonProjection.geoPointCache[0]), this.altitude + height, out);
    }
    projectRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    projectRelativeVec(vec, out) {
      this.perspectiveTransform.apply(vec, out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    projectCameraRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    projectCameraRelativeVec(vec, out) {
      this.perspectiveTransform.apply(Vec3Math.add(vec, this.perspectiveTransform.getCameraPosition(), HorizonProjection.cameraRelativeVec3Cache[0]), out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    isInProjectedBounds(point, arg2, arg3) {
      let bounds;
      if (point instanceof Float64Array) {
        bounds = arg2;
      } else {
        point = this.project(point, arg2, HorizonProjection.vec2Cache[0]);
        bounds = arg3;
      }
      const x = point[0];
      const y = point[1];
      if (!isFinite(x) || !isFinite(y)) {
        return false;
      }
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      return x >= left && x <= right && y >= top && y <= bottom;
    }
  };
  HorizonProjection.vec2Cache = [Vec2Math.create()];
  HorizonProjection.vec3Cache = [Vec3Math.create()];
  HorizonProjection.geoPointCache = [new GeoPoint(0, 0)];
  HorizonProjection.cameraRelativeVec3Cache = [Vec3Math.create()];
  var MapLayer = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this._isVisible = true;
    }
    isVisible() {
      return this._isVisible;
    }
    setVisible(val) {
      if (this._isVisible === val) {
        return;
      }
      this._isVisible = val;
      this.onVisibilityChanged(val);
    }
    onVisibilityChanged(isVisible) {
    }
    onAttached() {
    }
    onWake() {
    }
    onSleep() {
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    onUpdated(time, elapsed) {
    }
    onDetached() {
    }
  };
  var MapProjectionChangeType;
  (function(MapProjectionChangeType2) {
    MapProjectionChangeType2[MapProjectionChangeType2["Target"] = 1] = "Target";
    MapProjectionChangeType2[MapProjectionChangeType2["Center"] = 2] = "Center";
    MapProjectionChangeType2[MapProjectionChangeType2["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType2[MapProjectionChangeType2["Range"] = 8] = "Range";
    MapProjectionChangeType2[MapProjectionChangeType2["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType2[MapProjectionChangeType2["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType2[MapProjectionChangeType2["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedResolution"] = 256] = "ProjectedResolution";
  })(MapProjectionChangeType || (MapProjectionChangeType = {}));
  var MapProjection = class {
    constructor(projectedWidth, projectedHeight) {
      this.target = new GeoPoint(0, 0);
      this.targetProjectedOffset = new Float64Array(2);
      this.targetProjected = new Float64Array(2);
      this.range = 1;
      this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]);
      this.projectedSize = new Float64Array(2);
      this.center = new GeoPoint(0, 0);
      this.centerProjected = new Float64Array(2);
      this.projectedRange = 0;
      this.widthRange = 0;
      this.heightRange = 0;
      this.oldParameters = {
        target: new GeoPoint(0, 0),
        center: new GeoPoint(0, 0),
        targetProjected: new Float64Array(2),
        range: 1,
        rangeEndpoints: new Float64Array(4),
        scaleFactor: 1,
        rotation: 0,
        projectedSize: new Float64Array(2),
        projectedResolution: 0
      };
      this.queuedParameters = Object.assign({}, this.oldParameters);
      this.updateQueued = false;
      this.changeListeners = [];
      Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
      this.geoProjection = new MercatorProjection();
      Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
      this.targetProjected.set(this.centerProjected);
      this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
      this.recompute();
    }
    getGeoProjection() {
      return this.geoProjection;
    }
    getTarget() {
      return this.target.readonly;
    }
    getTargetProjectedOffset() {
      return this.targetProjectedOffset;
    }
    getTargetProjected() {
      return this.targetProjected;
    }
    getRange() {
      return this.range;
    }
    getRangeEndpoints() {
      return this.rangeEndpoints;
    }
    getWidthRange() {
      return this.widthRange;
    }
    getHeightRange() {
      return this.heightRange;
    }
    getScaleFactor() {
      return this.geoProjection.getScaleFactor();
    }
    getRotation() {
      return this.geoProjection.getPostRotation();
    }
    getProjectedSize() {
      return this.projectedSize;
    }
    getCenter() {
      return this.center.readonly;
    }
    getCenterProjected() {
      return this.centerProjected;
    }
    getProjectedResolution() {
      return this.range / this.projectedRange;
    }
    calculateRangeAtCenter(centerProjected) {
      const endpoints = this.rangeEndpoints;
      const projectedWidth = this.projectedSize[0];
      const projectedHeight = this.projectedSize[1];
      const endpoint1 = MapProjection.tempVec2_3;
      endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
      endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
      const endpoint2 = MapProjection.tempVec2_4;
      endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
      endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
      const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
      const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
      return top.distance(bottom);
    }
    recompute() {
      const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
      if (!isFinite(currentTargetProjected[0] + currentTargetProjected[1])) {
        const translation = this.geoProjection.getTranslation();
        if (isFinite(this.target.lat) && isFinite(this.target.lon) && isFinite(this.geoProjection.getPostRotation()) && isFinite(translation[0]) && isFinite(translation[1])) {
          this.geoProjection.setScaleFactor(MapProjection.DEFAULT_SCALE_FACTOR);
          this.geoProjection.setCenter(MapProjection.tempGeoPoint_1.set(0, 0));
          this.geoProjection.setPreRotation(Vec3Math.set(0, 0, 0, MapProjection.vec3Cache[0]));
        } else {
          return;
        }
      }
      const currentCenterProjected = MapProjection.tempVec2_2;
      currentCenterProjected.set(currentTargetProjected);
      currentCenterProjected[0] -= this.targetProjectedOffset[0];
      currentCenterProjected[1] -= this.targetProjectedOffset[1];
      let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
      let ratio = currentRange / this.range;
      if (!isFinite(ratio) || ratio === 0) {
        return;
      }
      let lastScaleFactor = this.geoProjection.getScaleFactor();
      let iterCount = 0;
      let ratioError = Math.abs(ratio - 1);
      let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
      while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
        this.geoProjection.setScaleFactor(ratio * lastScaleFactor);
        this.geoProjection.project(this.target, currentTargetProjected);
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        const newRatio = currentRange / this.range;
        const ratioDelta = newRatio - ratio;
        if (!isFinite(ratio) || ratio < 1 && ratioDelta <= 0 || ratio > 1 && ratioDelta >= 0) {
          this.geoProjection.setScaleFactor(lastScaleFactor);
        }
        lastScaleFactor = this.geoProjection.getScaleFactor();
        ratio = newRatio;
        const newRatioError = Math.abs(ratio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.invert(currentCenterProjected, this.center);
      this.geoProjection.setCenter(this.center);
      const preRotation = Vec3Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, 0, MapProjection.vec3Cache[0]);
      this.geoProjection.setPreRotation(preRotation);
      const width = this.projectedSize[0];
      const height = this.projectedSize[1];
      this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
      const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
      const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
      this.widthRange = this.geoDistance(left, right);
      const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
      const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
      this.heightRange = this.geoDistance(top, bottom);
    }
    set(parameters) {
      this.storeParameters(this.oldParameters);
      parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
      parameters.target && this.target.set(parameters.target);
      parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
      parameters.range !== void 0 && (this.range = parameters.range);
      parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
      parameters.rotation !== void 0 && this.geoProjection.setPostRotation(parameters.rotation);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        if (changeFlags !== 0) {
          this.notifyChangeListeners(changeFlags);
        }
      }
    }
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    setProjectedSize(size) {
      this.projectedSize.set(size);
      Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
      this.geoProjection.setTranslation(this.centerProjected);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    setTargetProjectedOffset(offset) {
      this.targetProjectedOffset.set(offset);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    storeParameters(record) {
      record.target.set(this.target);
      record.center.set(this.center);
      record.targetProjected.set(this.targetProjected);
      record.range = this.range;
      record.rangeEndpoints.set(this.rangeEndpoints);
      record.scaleFactor = this.geoProjection.getScaleFactor();
      record.rotation = this.getRotation();
      record.projectedSize.set(this.projectedSize);
      record.projectedResolution = this.getProjectedResolution();
    }
    computeChangeFlags(oldParameters) {
      return (oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target) | (Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected) | (oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range) | (VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints) | (oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize);
    }
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center) | (oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor) | (oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    project(point, out) {
      return this.geoProjection.project(point, out);
    }
    invert(vec, out) {
      return this.geoProjection.invert(vec, out);
    }
    isInProjectedBounds(point, bounds) {
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      if (!(point instanceof Float64Array)) {
        point = this.project(point, MapProjection.tempVec2_2);
      }
      const x = point[0];
      const y = point[1];
      return x >= left && x <= right && y >= top && y <= bottom;
    }
    geoDistance(point1, point2) {
      if (point1 instanceof Float64Array) {
        point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
      }
      if (point2 instanceof Float64Array) {
        point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
      }
      return point1.distance(point2);
    }
    projectedDistance(point1, point2) {
      if (!(point1 instanceof Float64Array)) {
        point1 = this.project(point1, MapProjection.tempVec2_1);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = this.project(point2, MapProjection.tempVec2_2);
      }
      return Vec2Math.distance(point1, point2);
    }
    notifyChangeListeners(changeFlags) {
      for (let i = 0; i < this.changeListeners.length; i++) {
        this.changeListeners[i](this, changeFlags);
      }
    }
    addChangeListener(listener) {
      this.changeListeners.push(listener);
    }
    removeChangeListener(listener) {
      const index = this.changeListeners.lastIndexOf(listener);
      if (index >= 0) {
        this.changeListeners.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
  };
  MapProjection.DEFAULT_SCALE_FACTOR = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
  MapProjection.SCALE_FACTOR_MAX_ITER = 20;
  MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
  MapProjection.tempVec2_1 = new Float64Array(2);
  MapProjection.tempVec2_2 = new Float64Array(2);
  MapProjection.tempVec2_3 = new Float64Array(2);
  MapProjection.tempVec2_4 = new Float64Array(2);
  MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
  MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);
  MapProjection.vec3Cache = [Vec3Math.create()];
  var MapComponent = class extends DisplayComponent {
    constructor(props) {
      var _a;
      super(props);
      this.layerEntries = [];
      this.lastUpdateTime = 0;
      this._isAwake = true;
      this.updateCycleHandler = this.update.bind(this);
      this.projectedSize = "isSubscribable" in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
      const initialSize = this.projectedSize.get();
      if (this.props.projection !== void 0) {
        this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
      }
      this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    getProjectedSize() {
      return this.mapProjection.getProjectedSize();
    }
    get isAwake() {
      return this._isAwake;
    }
    sleep() {
      this.setAwakeState(false);
    }
    wake() {
      this.setAwakeState(true);
    }
    setAwakeState(isAwake) {
      if (this._isAwake === isAwake) {
        return;
      }
      this._isAwake = isAwake;
      this._isAwake ? this.onWake() : this.onSleep();
    }
    onAfterRender(thisNode) {
      var _a;
      this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
      this.projectedSizeSub = this.projectedSize.sub((size) => {
        this.mapProjection.set({ projectedSize: size });
      });
      (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub((freq) => {
        var _a2;
        (_a2 = this.updateCycleSub) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.updateCycleSub = this.props.bus.getSubscriber().on("realTime").whenChanged().atFrequency(freq).handle(this.updateCycleHandler);
      }, true);
      this.attachLayers(thisNode);
    }
    attachLayers(thisNode) {
      FSComponent.visitNodes(thisNode, (node) => {
        if (node.instance instanceof MapLayer) {
          this.attachLayer(node.instance);
          return true;
        }
        return false;
      });
    }
    onWake() {
      this.wakeLayers();
    }
    wakeLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onWake();
      }
    }
    onSleep() {
      this.sleepLayers();
    }
    sleepLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onSleep();
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.onProjectedSizeChanged();
      }
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
      }
    }
    attachLayer(layer) {
      if (this.layerEntries.findIndex((entry2) => entry2.layer === layer) >= 0) {
        return;
      }
      const entry = new LayerEntry(layer);
      this.layerEntries.push(entry);
      entry.attach();
    }
    detachLayer(layer) {
      const index = this.layerEntries.findIndex((entry) => entry.layer === layer);
      if (index >= 0) {
        const entry = this.layerEntries[index];
        entry.detach();
        this.layerEntries.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    update(time) {
      if (!this._isAwake) {
        return;
      }
      this.onUpdated(time, time - this.lastUpdateTime);
      this.lastUpdateTime = time;
    }
    onUpdated(time, elapsed) {
      this.updateLayers(time, elapsed);
    }
    updateLayers(time, elapsed) {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].update(time);
      }
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].destroy();
      }
    }
  };
  var LayerEntry = class {
    constructor(layer) {
      this.layer = layer;
      this.updatePeriod = 0;
      this.lastUpdated = 0;
    }
    attach() {
      var _a, _b;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
        const clamped = Math.max(0, freq);
        this.updatePeriod = clamped === 0 ? 0 : 1e3 / clamped;
      }, true);
      this.layer.onAttached();
    }
    update(currentTime) {
      if (currentTime - this.lastUpdated >= this.updatePeriod) {
        this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
        this.lastUpdated = currentTime;
      }
    }
    detach() {
      var _a;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.layer.onDetached();
    }
    destroy() {
      this.detach();
      this.layer.destroy();
    }
  };
  var MapModel = class {
    constructor() {
      this.modules = /* @__PURE__ */ new Map();
    }
    getModule(nameOrModule) {
      if (typeof nameOrModule === "string") {
        return this.modules.get(nameOrModule);
      } else if (typeof nameOrModule === "function") {
        return this.modules.get(nameOrModule.name);
      }
      throw new Error("Invalid type supplied: must be a string key or a module constructor.");
    }
    addModule(name, module2) {
      if (this.modules.has(name)) {
        return;
      }
      this.modules.set(name, module2);
    }
  };
  var AbstractMapTextLabel = class {
    constructor(text, priority, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.text = SubscribableUtils.toSubscribable(text, true);
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
      this.font = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.font) !== null && _b !== void 0 ? _b : "", true);
      this.fontSize = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : 10, true);
      this.fontStr = MappedSubject.create(([s, f]) => {
        return `${s}px ${f}`;
      }, this.fontSize, this.font);
      this.fontColor = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _d !== void 0 ? _d : "white", true);
      this.fontOutlineWidth = SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _e !== void 0 ? _e : 0, true);
      this.fontOutlineColor = SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _f !== void 0 ? _f : "black", true);
      this.showBg = SubscribableUtils.toSubscribable((_g = options === null || options === void 0 ? void 0 : options.showBg) !== null && _g !== void 0 ? _g : false, true);
      this.bgColor = SubscribableUtils.toSubscribable((_h = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _h !== void 0 ? _h : "black", true);
      this.bgPadding = SubscribableUtils.toSubscribable((_j = options === null || options === void 0 ? void 0 : options.bgPadding) !== null && _j !== void 0 ? _j : VecNMath.create(4), true);
      this.bgBorderRadius = SubscribableUtils.toSubscribable((_k = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _k !== void 0 ? _k : 0, true);
      this.bgOutlineWidth = SubscribableUtils.toSubscribable((_l = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _l !== void 0 ? _l : 0, true);
      this.bgOutlineColor = SubscribableUtils.toSubscribable((_m = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _m !== void 0 ? _m : "white", true);
    }
    draw(context, mapProjection) {
      if (this.fontSize.get() !== 0) {
        this.setTextStyle(context);
        const width = context.measureText(this.text.get()).width;
        const height = this.fontSize.get();
        const showBg = this.showBg.get();
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        const bgExtraWidth = showBg ? bgPadding[1] + bgPadding[3] + bgOutlineWidth * 2 : 0;
        const bgExtraHeight = showBg ? bgPadding[0] + bgPadding[2] + bgOutlineWidth * 2 : 0;
        const anchor = this.anchor.get();
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (anchor[0] - 0.5) * (width + bgExtraWidth);
        const centerY = pos[1] - (anchor[1] - 0.5) * (height + bgExtraHeight);
        if (showBg) {
          this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
      }
    }
    setTextStyle(context) {
      context.font = this.fontStr.get();
      context.textBaseline = "middle";
      context.textAlign = "center";
    }
    drawText(context, centerX, centerY) {
      const text = this.text.get();
      const fontOutlineWidth = this.fontOutlineWidth.get();
      if (fontOutlineWidth > 0) {
        context.lineWidth = fontOutlineWidth * 2;
        context.strokeStyle = this.fontOutlineColor.get();
        context.strokeText(text, centerX, centerY);
      }
      context.fillStyle = this.fontColor.get();
      context.fillText(text, centerX, centerY);
    }
    drawBackground(context, centerX, centerY, width, height) {
      const bgPadding = this.bgPadding.get();
      const bgOutlineWidth = this.bgOutlineWidth.get();
      const bgBorderRadius = this.bgBorderRadius.get();
      const backgroundLeft = centerX - width / 2 - (bgPadding[3] + bgOutlineWidth);
      const backgroundTop = centerY - height / 2 - (bgPadding[0] + bgOutlineWidth);
      const backgroundWidth = width + (bgPadding[1] + bgPadding[3] + 2 * bgOutlineWidth);
      const backgroundHeight = height + (bgPadding[0] + bgPadding[2] + 2 * bgOutlineWidth);
      let isRounded = false;
      if (bgBorderRadius > 0) {
        isRounded = true;
        this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, bgBorderRadius);
      }
      if (bgOutlineWidth > 0) {
        context.lineWidth = bgOutlineWidth * 2;
        context.strokeStyle = this.bgOutlineColor.get();
        if (isRounded) {
          context.stroke();
        } else {
          context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
      }
      context.fillStyle = this.bgColor.get();
      if (isRounded) {
        context.fill();
      } else {
        context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
      }
    }
    loadBackgroundPath(context, left, top, width, height, radius) {
      const right = left + width;
      const bottom = top + height;
      context.beginPath();
      context.moveTo(left + radius, top);
      context.lineTo(right - radius, top);
      context.arcTo(right, top, right, top + radius, radius);
      context.lineTo(right, bottom - radius);
      context.arcTo(right, bottom, right - radius, bottom, radius);
      context.lineTo(left + radius, bottom);
      context.arcTo(left, bottom, left, bottom - radius, radius);
      context.lineTo(left, top + radius);
      context.arcTo(left, top, left + radius, top, radius);
    }
  };
  AbstractMapTextLabel.tempVec2 = new Float64Array(2);
  var MapLocationTextLabel = class extends AbstractMapTextLabel {
    constructor(text, priority, location, options) {
      var _a;
      super(text, priority, options);
      this.location = SubscribableUtils.toSubscribable(location, true);
      this.offset = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
    }
    getPosition(mapProjection, out) {
      mapProjection.project(this.location.get(), out);
      Vec2Math.add(out, this.offset.get(), out);
      return out;
    }
  };
  var MapCullableLocationTextLabel = class extends MapLocationTextLabel {
    constructor(text, priority, location, alwaysShow, options) {
      super(text, priority, location, options);
      this.bounds = new Float64Array(4);
      this.invalidation = new SubEvent();
      this.subs = [];
      this.alwaysShow = SubscribableUtils.toSubscribable(alwaysShow, true);
      this.subs.push(this.priority.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.alwaysShow.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.location.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.text.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.fontSize.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.anchor.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.offset.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgPadding.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgOutlineWidth.sub(() => {
        this.invalidation.notify(this);
      }));
    }
    updateBounds(mapProjection) {
      const fontSize = this.fontSize.get();
      const anchor = this.anchor.get();
      const width = 0.6 * fontSize * this.text.get().length;
      const height = fontSize;
      const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
      let left = pos[0] - anchor[0] * width;
      let right = left + width;
      let top = pos[1] - anchor[1] * height;
      let bottom = top + height;
      if (this.showBg.get()) {
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        left -= bgPadding[3] + bgOutlineWidth;
        right += bgPadding[1] + bgOutlineWidth;
        top -= bgPadding[0] + bgOutlineWidth;
        bottom += bgPadding[2] + bgOutlineWidth;
      }
      this.bounds[0] = left;
      this.bounds[1] = top;
      this.bounds[2] = right;
      this.bounds[3] = bottom;
    }
    destroy() {
      for (const sub of this.subs) {
        sub.destroy();
      }
    }
  };
  var MapCullableTextLabelManager = class {
    constructor(cullingEnabled = true) {
      this.cullingEnabled = cullingEnabled;
      this.registered = /* @__PURE__ */ new Map();
      this._visibleLabels = [];
      this.needUpdate = false;
      this.lastScaleFactor = 1;
      this.lastRotation = 0;
      this.invalidationHandler = () => {
        this.needUpdate = true;
      };
    }
    get visibleLabels() {
      return this._visibleLabels;
    }
    register(label) {
      if (this.registered.has(label)) {
        return;
      }
      this.registered.set(label, label.invalidation.on(this.invalidationHandler));
      this.needUpdate = true;
    }
    deregister(label) {
      const sub = this.registered.get(label);
      if (sub === void 0) {
        return;
      }
      sub.destroy();
      this.registered.delete(label);
      this.needUpdate = true;
    }
    setCullingEnabled(enabled) {
      this.cullingEnabled = enabled;
      this.needUpdate = true;
    }
    update(mapProjection) {
      if (!this.needUpdate) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
        if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
          const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
          if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
            return;
          }
        }
      }
      this._visibleLabels = [];
      if (this.cullingEnabled) {
        const labelArray = Array.from(this.registered.keys());
        const len = labelArray.length;
        for (let i = 0; i < len; i++) {
          labelArray[i].updateBounds(mapProjection);
        }
        labelArray.sort(MapCullableTextLabelManager.SORT_FUNC);
        const collisionArray = [];
        for (let i = 0; i < len; i++) {
          const label = labelArray[i];
          let show = true;
          if (!label.alwaysShow.get()) {
            const len2 = collisionArray.length;
            for (let j = 0; j < len2; j++) {
              const other = collisionArray[j];
              if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                show = false;
                break;
              }
            }
          }
          if (show) {
            collisionArray.push(label.bounds);
            this._visibleLabels.push(label);
          }
        }
      } else {
        this._visibleLabels.push(...this.registered.keys());
      }
      this.lastScaleFactor = mapProjection.getScaleFactor();
      this.lastRotation = mapProjection.getRotation();
      this.needUpdate = false;
    }
    static doesCollide(a, b) {
      return a[0] < b[2] && a[2] > b[0] && a[1] < b[3] && a[3] > b[1];
    }
  };
  MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
  MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;
  MapCullableTextLabelManager.SORT_FUNC = (a, b) => {
    const alwaysShowA = a.alwaysShow.get();
    const alwaysShowB = b.alwaysShow.get();
    if (alwaysShowA && !alwaysShowB) {
      return -1;
    } else if (alwaysShowB && !alwaysShowA) {
      return 1;
    } else {
      return b.priority.get() - a.priority.get();
    }
  };
  var AbstractMapWaypointIcon = class {
    constructor(waypoint, priority, size, options) {
      var _a, _b;
      this.waypoint = waypoint;
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.size = SubscribableUtils.toSubscribable(size, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(0.5, 0.5), true);
      this.offset = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.offset) !== null && _b !== void 0 ? _b : Vec2Math.create(), true);
    }
    draw(context, mapProjection) {
      const size = this.size.get();
      const offset = this.offset.get();
      const anchor = this.anchor.get();
      const projected = mapProjection.project(this.waypoint.location.get(), MapWaypointImageIcon.tempVec2);
      const left = projected[0] + offset[0] - anchor[0] * size[0];
      const top = projected[1] + offset[1] - anchor[1] * size[1];
      this.drawIconAt(context, mapProjection, left, top);
    }
  };
  AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
  var MapWaypointImageIcon = class extends AbstractMapWaypointIcon {
    constructor(waypoint, priority, img, size, options) {
      super(waypoint, priority, size, options);
      this.img = img;
    }
    drawIconAt(context, mapProjection, left, top) {
      const size = this.size.get();
      context.drawImage(this.img, left, top, size[0], size[1]);
    }
  };
  var MapWaypointRenderer = class {
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
      this.textManager = textManager;
      this.selectRoleToRender = selectRoleToRender;
      this.registered = /* @__PURE__ */ new Map();
      this.toCleanUp = /* @__PURE__ */ new Set();
      this.roleDefinitions = /* @__PURE__ */ new Map();
      this.onWaypointAdded = new SubEvent();
      this.onWaypointRemoved = new SubEvent();
    }
    hasRenderRole(role) {
      return this.roleDefinitions.has(role);
    }
    addRenderRole(role, def) {
      if (this.roleDefinitions.has(role)) {
        return false;
      }
      this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
      return true;
    }
    removeRenderRole(role) {
      return this.roleDefinitions.delete(role);
    }
    getRenderRoleDefinition(role) {
      return this.roleDefinitions.get(role);
    }
    renderRoles() {
      return this.roleDefinitions.keys();
    }
    clearRenderRoles() {
      this.roleDefinitions.clear();
    }
    setIconFactory(role, factory) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.iconFactory = factory;
      return true;
    }
    setLabelFactory(role, factory) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.labelFactory = factory;
      return true;
    }
    setCanvasContext(role, context) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.canvasContext = context;
      return true;
    }
    setVisibilityHandler(role, handler) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.visibilityHandler = handler;
      return true;
    }
    isRegistered(waypoint, role) {
      if (!waypoint) {
        return false;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return false;
      }
      if (role === void 0) {
        return true;
      }
      return entry.isAllRoles(role);
    }
    register(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      let entry = this.registered.get(waypoint.uid);
      if (!entry) {
        entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
        this.registered.set(waypoint.uid, entry);
        this.onWaypointAdded.notify(this, waypoint);
      }
      entry.addRole(role, sourceId);
    }
    deregister(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return;
      }
      entry.removeRole(role, sourceId);
      if (entry.roles === 0) {
        this.deleteEntry(entry);
        this.onWaypointRemoved.notify(this, waypoint);
      }
    }
    deleteEntry(entry) {
      this.registered.delete(entry.waypoint.uid);
      this.toCleanUp.add(entry);
    }
    update(mapProjection) {
      var _a;
      this.toCleanUp.forEach((entry) => {
        entry.destroy();
      });
      this.toCleanUp.clear();
      const entriesToDrawIcon = [];
      this.registered.forEach((entry) => {
        entry.update();
        if (entry.icon) {
          entriesToDrawIcon.push(entry);
        }
      });
      const projectedSize = mapProjection.getProjectedSize();
      for (const roleDef of this.roleDefinitions.values()) {
        const context = roleDef.canvasContext;
        if (context) {
          context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
        }
      }
      entriesToDrawIcon.sort(MapWaypointRenderer.ENTRY_SORT_FUNC);
      const len2 = entriesToDrawIcon.length;
      for (let i = 0; i < len2; i++) {
        const entry = entriesToDrawIcon[i];
        const icon = entry.icon;
        const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
        if (context) {
          icon.draw(context, mapProjection);
        }
      }
    }
    getNearestWaypoint(pos, first) {
      var _a, _b;
      const ordered = [...this.registered.values()].sort((a, b) => this.orderByDistance(a.waypoint, b.waypoint, pos)).filter((w) => {
        const roleDef = this.getRenderRoleDefinition(w.lastRenderedRole);
        if (roleDef !== void 0) {
          return roleDef.visibilityHandler(w.waypoint);
        }
        return false;
      });
      if (first !== void 0) {
        return (_a = ordered.find((entry) => first(entry.waypoint))) === null || _a === void 0 ? void 0 : _a.waypoint;
      }
      return (_b = ordered[0]) === null || _b === void 0 ? void 0 : _b.waypoint;
    }
    orderByDistance(a, b, pos) {
      const aDist = a.location.get().distance(pos);
      const bDist = b.location.get().distance(pos);
      return aDist - bDist;
    }
  };
  MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
  };
  MapWaypointRenderer.ENTRY_SORT_FUNC = (a, b) => {
    return a.icon.priority.get() - b.icon.priority.get();
  };
  MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
      if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
        return role;
      }
    }
    return 0;
  };
  var MapWaypointRendererEntry = class {
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
      this.waypoint = waypoint;
      this.textManager = textManager;
      this.roleDefinitions = roleDefinitions;
      this.selectRoleToRender = selectRoleToRender;
      this.registrations = {};
      this._roles = 0;
      this._icon = null;
      this._label = null;
      this._lastRenderedRole = 0;
    }
    get roles() {
      return this._roles;
    }
    get lastRenderedRole() {
      return this._lastRenderedRole;
    }
    get icon() {
      return this._icon;
    }
    get label() {
      return this._label;
    }
    isAnyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAny(toCompare, roles);
    }
    isOnlyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return toCompare === roles;
    }
    isAllRoles(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAll(toCompare, roles);
    }
    addRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        var _a;
        var _b, _c;
        ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : _b[_c] = /* @__PURE__ */ new Set()).add(sourceId);
      }, true);
      this._roles = this._roles | roles;
    }
    removeRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        const role = 1 << index;
        const registrations = this.registrations[role];
        if (registrations) {
          registrations.delete(sourceId);
          if (registrations.size === 0) {
            this._roles = this._roles & ~role;
          }
        }
      }, true);
    }
    prepareRender(showRole, iconFactory, labelFactory) {
      var _a, _b;
      if (showRole === this._lastRenderedRole) {
        return;
      }
      this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
      const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
      if (this._label && this._label !== label) {
        this.textManager.deregister(this._label);
      }
      if (label && label !== this._label) {
        this.textManager.register(label);
      }
      this._label = label;
      this._lastRenderedRole = showRole;
    }
    update() {
      var _a, _b;
      const showRole = this.selectRoleToRender(this, this.roleDefinitions);
      const roleDef = this.roleDefinitions.get(showRole);
      const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
      const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
      this.prepareRender(showRole, iconFactory, labelFactory);
    }
    destroy() {
      if (this._label) {
        this.textManager.deregister(this._label);
      }
    }
  };
  var NullPathStream = class {
    beginPath() {
    }
    moveTo() {
    }
    lineTo() {
    }
    bezierCurveTo() {
    }
    quadraticCurveTo() {
    }
    arc() {
    }
    closePath() {
    }
  };
  NullPathStream.INSTANCE = new NullPathStream();
  var AbstractTransformingPathStream = class {
    constructor(consumer) {
      this.consumer = consumer;
    }
    getConsumer() {
      return this.consumer;
    }
    setConsumer(consumer) {
      this.consumer = consumer;
    }
  };
  var Outcode;
  (function(Outcode2) {
    Outcode2[Outcode2["Inside"] = 0] = "Inside";
    Outcode2[Outcode2["Left"] = 1] = "Left";
    Outcode2[Outcode2["Top"] = 2] = "Top";
    Outcode2[Outcode2["Right"] = 4] = "Right";
    Outcode2[Outcode2["Bottom"] = 8] = "Bottom";
  })(Outcode || (Outcode = {}));
  var ClippedPathStream = class extends AbstractTransformingPathStream {
    constructor(consumer, bounds) {
      super(consumer);
      this.bounds = bounds;
      this.boundsHandler = this.onBoundsChanged.bind(this);
      this.boundsLines = [
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3)
      ];
      this.isBoundingRectNonZero = false;
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.prevPointOutcode = 0;
      bounds.sub(this.boundsHandler, true);
    }
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    moveTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
      if (this.prevPointOutcode === 0) {
        this.consumer.moveTo(x, y);
      }
    }
    lineTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      const outcode = this.getOutcode(x, y);
      if ((this.prevPointOutcode | outcode) === 0) {
        this.consumer.lineTo(x, y);
      } else if ((this.prevPointOutcode & outcode) === 0) {
        const bounds = this.bounds.get();
        const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
        let entryPoint, exitPoint;
        const outcodeOr = this.prevPointOutcode | outcode;
        if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              break;
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              break;
            }
          }
        } else {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                entryPoint = intersection;
                break;
              }
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                exitPoint = intersection;
                break;
              }
            }
          }
        }
        if (entryPoint) {
          this.consumer.moveTo(entryPoint[0], entryPoint[1]);
        }
        if (exitPoint) {
          this.consumer.lineTo(exitPoint[0], exitPoint[1]);
        } else if (outcode === Outcode.Inside) {
          this.consumer.lineTo(x, y);
        }
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = outcode;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const pi2 = 2 * Math.PI;
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
      const bounds = this.bounds.get();
      const radiusSq = radius * radius;
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
      const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
      const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const intersections = ClippedPathStream.intersectionCache;
      let intersectionCount = 0;
      for (let i = 0; i < 4; i++) {
        const axisCoordIndex = i % 2;
        const crossAxisCoordIndex = (i + 1) % 2;
        const centerAxisCoord = i % 2 === 0 ? x : y;
        const centerCrossAxisCoord = i % 2 === 0 ? y : x;
        const deltaToBound = bounds[i] - centerAxisCoord;
        if (Math.abs(deltaToBound) < radius) {
          const crossAxisBoundMin = bounds[crossAxisCoordIndex];
          const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
          const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
          let intersectionRadialOffset;
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
        }
      }
      let isOutside = startPointOutcode !== Outcode.Inside;
      const startAngleNormalized = (startAngle % pi2 + pi2) % pi2;
      let lastRadial = startAngleNormalized;
      let intersectionStartIndex = -1;
      let minAngularDiff = Infinity;
      for (let i = 0; i < intersectionCount; i++) {
        const angularDiff = ((intersections[i].radial - startAngleNormalized) * directionSign + pi2) % pi2;
        if (angularDiff < minAngularDiff) {
          intersectionStartIndex = i;
          minAngularDiff = angularDiff;
        }
      }
      if (intersectionStartIndex >= 0) {
        for (let i = 0; i < intersectionCount; i++) {
          const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
          const intersection = intersections[index];
          if (((intersection.radial - startAngleNormalized) * directionSign + pi2) % pi2 >= angularWidth) {
            break;
          }
          if (isOutside) {
            this.consumer.moveTo(intersection.point[0], intersection.point[1]);
          } else {
            const segmentAngularWidth = ((intersection.radial - lastRadial) * directionSign + pi2) % pi2;
            this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
          }
          isOutside = !isOutside;
          lastRadial = intersection.radial;
        }
      }
      const endAngleNormalized = (startAngleNormalized + angularWidth * directionSign + pi2) % pi2;
      if (!isOutside) {
        const segmentAngularWidth = ((endAngleNormalized - lastRadial) * directionSign + pi2) % pi2;
        this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
        if (Math.abs((endAngleNormalized - endAngle) % pi2) > 1e-14) {
          this.consumer.moveTo(endPoint[0], endPoint[1]);
        }
      }
      Vec2Math.copy(endPoint, this.prevPoint);
      this.prevPointOutcode = endPointOutcode;
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.prevPointOutcode = 0;
    }
    getOutcode(x, y) {
      const bounds = this.bounds.get();
      let code = 0;
      if (x < bounds[0]) {
        code |= Outcode.Left;
      } else if (x > bounds[2]) {
        code |= Outcode.Right;
      }
      if (y < bounds[1]) {
        code |= Outcode.Top;
      } else if (y > bounds[3]) {
        code |= Outcode.Bottom;
      }
      return code;
    }
    onBoundsChanged() {
      const bounds = this.bounds.get();
      Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
      Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
      Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
      Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
      this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
      this.beginPath();
    }
    destroy() {
      this.bounds.unsub(this.boundsHandler);
    }
    static getLineCoordinates(x1, y1, x2, y2, out) {
      const a = y1 - y2;
      const b = x2 - x1;
      const c = -(a * x1 + b * y1);
      return Vec3Math.set(a, b, c, out);
    }
    static findLineLineIntersection(line1, line2, out) {
      const cross = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
      const w = cross[2];
      if (w === 0) {
        return void 0;
      }
      return Vec2Math.set(cross[0] / w, cross[1] / w, out);
    }
  };
  ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: 0 };
  });
  var GeoProjectionPathStream = class extends AbstractTransformingPathStream {
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.projection = projection;
      this.firstPoint = new GeoPoint(NaN, NaN);
      this.prevPoint = new GeoPoint(NaN, NaN);
      this.prevPointProjected = new Float64Array(2);
      this.resampleHandler = this.onResampled.bind(this);
      if (arg1 instanceof GeoCircleResampler) {
        this.resampler = arg1;
      } else {
        this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
      }
    }
    getProjection() {
      return this.projection;
    }
    setProjection(projection) {
      this.projection = projection;
    }
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    moveTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (isNaN(this.firstPoint.lat)) {
        this.firstPoint.set(lat, lon);
      }
      this.prevPoint.set(lat, lon);
      const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
      this.consumer.moveTo(projected[0], projected[1]);
    }
    lineTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(lon, lat);
        return;
      }
      const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
      const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
      if (!isFinite(circle.center[0])) {
        throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
      }
      this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
      this.prevPoint.set(lat, lon);
    }
    bezierCurveTo() {
      throw new Error("GeodesicResamplerStream: bezierCurveTo() is not supported");
    }
    quadraticCurveTo() {
      throw new Error("GeodesicResamplerStream: quadraticCurveTo() is not supported");
    }
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        return;
      }
      if (MathUtils.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
        const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
        this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
        this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
        return;
      }
      const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
      const start = GeoProjectionPathStream.geoPointCache[2];
      const end = GeoProjectionPathStream.geoPointCache[3];
      if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        const circleLat = Math.sign(lat) * (MathUtils.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
        start.set(circleLat, startAngle);
        end.set(circleLat, endAngle);
      } else {
        center.offset(startAngle, radius, start);
        center.offset(endAngle, radius, end);
      }
      if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(start.lon, start.lat);
      } else if (!start.equals(this.prevPoint)) {
        this.lineTo(start.lon, start.lat);
      }
      const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
      if (!counterClockwise) {
        circle.reverse();
      }
      this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
      this.prevPoint.set(end);
    }
    closePath() {
      if (!isNaN(this.firstPoint.lat)) {
        this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
      }
    }
    reset() {
      this.firstPoint.set(NaN, NaN);
      this.prevPoint.set(NaN, NaN);
    }
    onResampled(vector) {
      switch (vector.type) {
        case "start":
          return;
        case "line":
          this.consumer.lineTo(vector.projected[0], vector.projected[1]);
          break;
        case "arc":
          this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
          break;
      }
      Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
  };
  GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var AffineTransformPathStream = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.transform = new Transform2D();
      this.concatCache = [];
      this.scale = 1;
      this.rotation = 0;
    }
    addTranslation(x, y, order = "after") {
      const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
      if (order === "before") {
        this.concatCache[0] = translation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = translation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      return this;
    }
    addScale(factor, order = "after") {
      const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
      if (order === "before") {
        this.concatCache[0] = scale;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = scale;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    addRotation(angle, order = "after") {
      const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
      if (order === "before") {
        this.concatCache[0] = rotation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = rotation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    resetTransform() {
      this.transform.toIdentity();
      this.updateScaleRotation();
      return this;
    }
    beginPath() {
      this.consumer.beginPath();
    }
    moveTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.moveTo(transformed[0], transformed[1]);
    }
    lineTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.lineTo(transformed[0], transformed[1]);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      const cp1Transformed = this.applyTransform(cp1x, cp1y);
      cp1x = cp1Transformed[0];
      cp1y = cp1Transformed[1];
      const cp2Transformed = this.applyTransform(cp2x, cp2y);
      cp2x = cp2Transformed[0];
      cp2y = cp2Transformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      const cpTransformed = this.applyTransform(cpx, cpy);
      cpx = cpTransformed[0];
      cpy = cpTransformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      const transformed = this.applyTransform(x, y);
      this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    closePath() {
      this.consumer.closePath();
    }
    updateScaleRotation() {
      const params = this.transform.getParameters();
      this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
      this.rotation = Math.atan2(params[3], params[0]);
    }
    applyTransform(x, y) {
      const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
      return this.transform.apply(vec, vec);
    }
  };
  AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
  AffineTransformPathStream.transformCache = [new Transform2D()];
  var PatternPathStream = class {
    constructor(consumer, pattern) {
      this.pattern = pattern;
      this.clipBounds = VecNSubject.createFromVector(new Float64Array([Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]));
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.distanceLeft = NaN;
      this.transformStream = new AffineTransformPathStream(consumer);
      this.clipStream = new ClippedPathStream(this.transformStream, this.clipBounds);
    }
    getPattern() {
      return this.pattern;
    }
    setPattern(pattern) {
      if (!isNaN(this.distanceLeft) && this.pattern) {
        this.distanceLeft = Math.max(0, this.distanceLeft - this.pattern.anchor * this.pattern.length);
      }
      this.pattern = pattern;
      if (pattern) {
        if (!isNaN(this.distanceLeft)) {
          this.distanceLeft += pattern.anchor * pattern.length;
        }
      } else {
        this.distanceLeft = NaN;
      }
    }
    getConsumer() {
      return this.transformStream.getConsumer();
    }
    setConsumer(consumer) {
      this.transformStream.setConsumer(consumer);
    }
    beginPath() {
      this.reset();
      this.getConsumer().beginPath();
    }
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.distanceLeft = NaN;
    }
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.pattern) {
        const x0 = this.prevPoint[0];
        const y0 = this.prevPoint[1];
        const dx = x - x0;
        const dy = y - y0;
        const distance = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        this.transformStream.resetTransform().addRotation(angle).addTranslation(x0, y0);
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            this.transformStream.addTranslation(distanceToNextAnchor, 0, "before");
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            this.transformStream.addTranslation(distanceToPatternEnd, 0, "before");
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().lineTo(x, y);
      }
      Vec2Math.set(x, y, this.prevPoint);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this.moveTo(x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, PatternPathStream.vec2Cache[1]), PatternPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      if (this.pattern) {
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
          const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
          endAngle = startAngle + angleDiff * directionSign;
        }
        const angularWidth = (endAngle - startAngle) * directionSign;
        const distance = angularWidth * radius;
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          let angle = startAngle;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            angle += distanceToNextAnchor / radius * directionSign;
            this.transformStream.resetTransform().addRotation(Math.PI / 2 * directionSign).addTranslation(radius, 0).addRotation(angle).addTranslation(x, y);
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            angle += distanceToPatternEnd / radius * directionSign;
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().arc(x, y, radius, startAngle, endAngle, counterClockwise);
      }
      Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, endAngle, PatternPathStream.vec2Cache[1]), this.prevPoint);
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.distanceLeft = NaN;
    }
  };
  PatternPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var TransformingPathStreamStack = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.stack = [];
    }
    push(stream) {
      var _a;
      stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
      this.stack.push(stream);
    }
    pop() {
      const removed = this.stack.pop();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      return removed;
    }
    unshift(stream) {
      const displaced = this.stack[0];
      displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
      stream.setConsumer(this.consumer);
      this.stack.unshift(stream);
    }
    shift() {
      var _a;
      const removed = this.stack.shift();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
      return removed;
    }
    setConsumer(consumer) {
      var _a;
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    beginPath() {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    moveTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    lineTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    closePath() {
      this.stack[this.stack.length - 1].closePath();
    }
  };
  var GeoProjectionPathStreamStack = class extends AbstractTransformingPathStream {
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.postStack = new TransformingPathStreamStack(consumer);
      if (arg1 instanceof GeoCircleResampler) {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
      } else {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
      }
      this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    getProjection() {
      return this.projectionStream.getProjection();
    }
    setProjection(projection) {
      this.projectionStream.setProjection(projection);
    }
    pushPreProjected(stream) {
      this.preStack.push(stream);
    }
    popPreProjected() {
      return this.preStack.pop();
    }
    unshiftPreProjected(stream) {
      this.preStack.unshift(stream);
    }
    shiftPreProjected() {
      return this.preStack.shift();
    }
    pushPostProjected(stream) {
      this.postStack.push(stream);
    }
    popPostProjected() {
      return this.postStack.pop();
    }
    unshiftPostProjected(stream) {
      this.postStack.unshift(stream);
    }
    shiftPostProjected() {
      return this.postStack.shift();
    }
    setConsumer(consumer) {
      this.postStack.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    beginPath() {
      this.preStack.beginPath();
    }
    moveTo(x, y) {
      this.preStack.moveTo(x, y);
    }
    lineTo(x, y) {
      this.preStack.lineTo(x, y);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    closePath() {
      this.preStack.closePath();
    }
  };
  var GeoCirclePathRenderer = class {
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
      if (!continuePath) {
        streamStack.beginPath();
        streamStack.moveTo(startLon, startLat);
      }
      if (circle.isGreatCircle()) {
        const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
        const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
          const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
          const midLat = midPoint.lat;
          const midLon = midPoint.lon;
          streamStack.lineTo(midLon, midLat);
          streamStack.lineTo(endLon, endLat);
        } else {
          streamStack.lineTo(endLon, endLat);
        }
      } else {
        const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
        const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
        let startAngle, endAngle;
        if (isCenterPole) {
          startAngle = startLon;
          endAngle = endLon;
        } else {
          startAngle = turnCenter.bearingTo(startLat, startLon);
          endAngle = turnCenter.bearingTo(endLat, endLon);
        }
        streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === "left");
      }
    }
  };
  GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
  GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];
  var GeoCircleLineRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
    }
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash, outlineWidth = 0, outlineStyle = "black") {
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
      if (outlineWidth > 0) {
        context.lineWidth = width + outlineWidth * 2;
        context.strokeStyle = outlineStyle;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
      context.stroke();
    }
  };
  GeoCircleLineRenderer.EMPTY_DASH = [];
  var GeoCirclePatternRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
      this.patternStream = new PatternPathStream(NullPathStream.INSTANCE, null);
    }
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, pattern, continuePath = false) {
      this.patternStream.setPattern(pattern);
      streamStack.unshiftPostProjected(this.patternStream);
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath);
      streamStack.shiftPostProjected();
    }
  };
  var AbstractFlightPathPlanRenderer = class {
    constructor(renderOrder = "forward", renderActiveLegLast = true) {
      this.renderOrder = renderOrder;
      this.renderActiveLegLast = renderActiveLegLast;
    }
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
      startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0;
      endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = plan.length - 1;
      const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
      const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : void 0;
      const isReverse = this.renderOrder === "reverse";
      if (isReverse) {
        const oldEndIndex = endIndex;
        endIndex = startIndex;
        startIndex = oldEndIndex;
      }
      let index = startIndex;
      const delta = isReverse ? -1 : 1;
      for (const leg of plan.legs(isReverse, startIndex)) {
        if ((index - endIndex) * delta > 0) {
          break;
        }
        if (this.renderActiveLegLast && index === activeLegIndex) {
          index += delta;
          continue;
        }
        this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
        index += delta;
      }
      if (this.renderActiveLegLast && activeLeg) {
        this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
      }
    }
  };
  var FlightPathLegRenderPart;
  (function(FlightPathLegRenderPart2) {
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["None"] = 0] = "None";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Ingress"] = 1] = "Ingress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Base"] = 2] = "Base";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Egress"] = 4] = "Egress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["All"] = 7] = "All";
  })(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
  var AbstractFlightPathLegRenderer = class {
    constructor() {
      this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    render(leg, context, streamStack, partsToRender, ...args) {
      const legCalc = leg.calculated;
      if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
        return;
      }
      const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
      const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
      const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
      let mainVectors = legCalc.ingressToEgress;
      let mainVectorStartIndex = 0;
      let mainVectorEndIndex = legCalc.ingressToEgress.length;
      if (excludeIngress || excludeEgress) {
        mainVectors = legCalc.flightPath;
        mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
      }
      if (!excludeIngress) {
        for (let i = 0; i < legCalc.ingress.length; i++) {
          this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
        }
        if (excludeEgress && !excludeBase) {
          mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
          const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
          const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
          if (lastIngressVector && ingressJoinVector) {
            const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            if (!ingressEnd.equals(vectorEnd)) {
              const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
            mainVectorStartIndex++;
          }
        }
      }
      if (!excludeBase) {
        const len = Math.min(mainVectorEndIndex, mainVectors.length);
        for (let i = mainVectorStartIndex; i < len; i++) {
          this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
        }
      }
      if (!excludeEgress) {
        if (excludeIngress && !excludeBase) {
          const firstEgressVector = legCalc.egress[0];
          const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
          if (firstEgressVector && egressJoinVector) {
            const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
            const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
            if (!egressStart.equals(egressJoinVectorStart)) {
              const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
          }
        }
        for (let i = 0; i < legCalc.egress.length; i++) {
          this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
        }
      }
    }
  };
  AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathLegLineRenderer = class extends AbstractFlightPathLegRenderer {
    constructor(styleSelector) {
      super();
      this.styleSelector = styleSelector;
      this.pathRenderer = new GeoCirclePathRenderer();
      this.styleBuffer = [
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        },
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        }
      ];
      this.activeStyleIndex = 0;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = false;
    }
    render(leg, context, streamStack, partsToRender, ...args) {
      this.isAtLegStart = true;
      this.needStrokeLineAtLegEnd = false;
      super.render(leg, context, streamStack, partsToRender, ...args);
      if (this.needStrokeLineAtLegEnd) {
        this.strokeLine(context, this.styleBuffer[(this.activeStyleIndex + 1) % 2]);
        this.needStrokeLineAtLegEnd = false;
      }
    }
    renderVector(vector, isIngress, isEgress, leg, context, streamStack, ...args) {
      const style = this.styleSelector(vector, isIngress, isEgress, leg, streamStack.getProjection(), this.styleBuffer[this.activeStyleIndex], ...args);
      const previousStyle = this.styleBuffer[(this.activeStyleIndex + 1) % 2];
      const didStyleChange = !this.isAtLegStart && !FlightPathLegLineRenderer.areStylesEqual(style, previousStyle);
      const continuePath = !this.isAtLegStart && style.isContinuous && !didStyleChange;
      if (didStyleChange) {
        this.strokeLine(context, previousStyle);
        this.needStrokeLineAtLegEnd = false;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathLegLineRenderer.geoCircleCache[1]);
      this.pathRenderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, streamStack, continuePath);
      this.activeStyleIndex = (this.activeStyleIndex + 1) % 2;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = true;
    }
    strokeLine(context, style) {
      var _a, _b;
      if (style.outlineWidth > 0) {
        const outlineWidth = style.strokeWidth + 2 * style.outlineWidth;
        context.lineWidth = outlineWidth;
        context.strokeStyle = style.outlineStyle;
        context.setLineDash((_a = style.outlineDash) !== null && _a !== void 0 ? _a : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      if (style.strokeWidth > 0) {
        context.lineWidth = style.strokeWidth;
        context.strokeStyle = style.strokeStyle;
        context.setLineDash((_b = style.strokeDash) !== null && _b !== void 0 ? _b : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
    }
    static areStylesEqual(style1, style2) {
      return (style1.strokeWidth === 0 && style2.strokeWidth === 0 || style1.strokeWidth === style2.strokeWidth && style1.strokeStyle === style2.strokeStyle && style1.strokeDash === style2.strokeDash) && (style1.outlineWidth === 0 && style2.outlineWidth === 0 || style1.outlineWidth === style2.outlineWidth && style1.outlineStyle === style2.outlineStyle && style1.outlineDash === style2.outlineDash);
    }
  };
  FlightPathLegLineRenderer.EMPTY_DASH = [];
  FlightPathLegLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorPatternRenderer = class {
    constructor() {
      this.renderer = new GeoCirclePatternRenderer();
    }
    render(vector, context, streamStack, pattern, continuePath = false) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorPatternRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, pattern, continuePath);
    }
  };
  FlightPathVectorPatternRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorLineRenderer = class {
    constructor() {
      this.renderer = new GeoCircleLineRenderer();
    }
    render(vector, context, streamStack, width, style, dash, outlineWidth, outlineStyle) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash, outlineWidth, outlineStyle);
    }
  };
  FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MapAbstractAirspaceRenderer = class {
    render(airspace, projection, context, lod = 0, stream) {
      const shapes = airspace.lods[lod];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        this.renderShape(shapes[i], projection, context, stream);
      }
    }
  };
  var MapSingleLineAirspaceRenderer = class extends MapAbstractAirspaceRenderer {
    constructor(lineWidth, strokeStyle, dash) {
      super();
      this.lineWidth = lineWidth;
      this.strokeStyle = strokeStyle;
      this.dash = dash;
    }
    renderShape(shape, projection, context, stream) {
      if (shape.length < 2) {
        return;
      }
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const firstProjected = projection.project(shape[0].end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.moveTo(firstProjected[0], firstProjected[1]);
      let start = shape[0].end;
      const len = shape.length;
      for (let i = 1; i < len; i++) {
        const vector = shape[i];
        const circle = vector.circle;
        if (circle) {
          if (circle.isGreatCircle()) {
            this.pathGreatCircle(circle, start, vector.end, projection, stream);
          } else {
            this.pathSmallCircle(circle, start, vector.end, projection, stream);
          }
        } else {
          const endProjected = projection.project(vector.end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
          stream.moveTo(endProjected[0], endProjected[1]);
        }
        start = vector.end;
      }
      context.lineWidth = this.lineWidth;
      context.strokeStyle = this.strokeStyle;
      context.setLineDash(this.dash);
      context.stroke();
    }
    pathGreatCircle(circle, start, end, projection, stream) {
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.lineTo(endProjected[0], endProjected[1]);
    }
    pathSmallCircle(circle, start, end, projection, stream) {
      const center = MapSingleLineAirspaceRenderer.geoPointCache[0].setFromCartesian(circle.radius < Math.PI / 2 ? circle.center : Vec3Math.multScalar(circle.center, -1, MapSingleLineAirspaceRenderer.vec3Cache[0]));
      const centerProjected = projection.project(center, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[1]);
      if (start.equals(end)) {
        const radius = Vec2Math.distance(endProjected, centerProjected);
        const startAngle = Math.atan2(endProjected[1] - centerProjected[1], endProjected[0] - centerProjected[0]);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, startAngle + 2 * Math.PI);
        stream.moveTo(endProjected[0], endProjected[1]);
      } else {
        const startProjected = projection.project(start, MapSingleLineAirspaceRenderer.vec2Cache[2]);
        const startDelta = Vec2Math.sub(startProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[3]);
        const startDeltaMag = Vec2Math.abs(startDelta);
        const endDelta = Vec2Math.sub(endProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[4]);
        const endDeltaMag = Vec2Math.abs(endDelta);
        const radius = (startDeltaMag + endDeltaMag) / 2;
        const startAngle = Vec2Math.theta(startDelta);
        const arcStartX = centerProjected[0] + radius / startDeltaMag * startDelta[0];
        const arcStartY = centerProjected[1] + radius / startDeltaMag * startDelta[1];
        const endAngle = Vec2Math.theta(endDelta);
        const arcEndX = centerProjected[0] + radius / endDeltaMag * endDelta[0];
        const arcEndY = centerProjected[1] + radius / endDeltaMag * endDelta[1];
        stream.lineTo(arcStartX, arcStartY);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, endAngle, circle.radius < Math.PI / 2);
        stream.lineTo(arcEndX, arcEndY);
      }
    }
  };
  MapSingleLineAirspaceRenderer.geoPointCache = [new GeoPoint(0, 0)];
  MapSingleLineAirspaceRenderer.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  MapSingleLineAirspaceRenderer.vec3Cache = [new Float64Array(3)];
  var Shape = class {
    constructor() {
      this.segments = [];
      this.length = 0;
      this.isClosed = false;
      this.windingOrder = 1;
    }
    build(shape, projection) {
      if (shape.length < 2) {
        return;
      }
      this.buildSegments(shape, projection);
      let signedArea = 0;
      let prev = this.segments[0];
      for (let i = 1; i < this.length; i++) {
        const segment = this.segments[i];
        signedArea += this.calculateSignedArea(segment, prev);
        prev = segment;
      }
      const first = this.segments[0].end;
      const last = this.segments[this.length - 1].end;
      this.isClosed = Vec2Math.equals(first, last);
      if (!this.isClosed) {
        signedArea += last[0] * first[1] - first[0] * last[1];
      }
      this.windingOrder = signedArea >= 0 ? 1 : -1;
      this.calculateVertices();
    }
    buildSegments(shape, projection) {
      this.buildStartSegment(projection, 0, shape[0]);
      let start = shape[0].end;
      this.length = shape.length;
      for (let i = 1; i < this.length; i++) {
        const vector = shape[i];
        this.buildSegment(projection, i, vector, start);
        start = vector.end;
      }
    }
    buildSegment(projection, index, vector, start) {
      const circle = vector.circle;
      if (circle) {
        if (circle.isGreatCircle()) {
          this.buildSegmentFromGreatCircle(projection, index, circle, start, vector.end);
        } else {
          this.buildSegmentFromSmallCircle(projection, index, circle, start, vector.end);
        }
      } else {
        this.buildStartSegment(projection, index, vector);
      }
    }
    buildStartSegment(projection, index, vector) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "start";
      projection.project(vector.end, segment.end);
    }
    buildSegmentFromGreatCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "line";
      projection.project(end, segment.end);
      const delta = Vec2Math.sub(segment.end, this.segments[index - 1].end, Shape.vec2Cache[0]);
      Vec2Math.normalize(Vec2Math.normal(delta, segment.endNormal), segment.endNormal);
    }
    buildSegmentFromSmallCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const isClockwise = circle.radius > Math.PI / 2;
      const center = Shape.geoPointCache[0].setFromCartesian(isClockwise ? Vec3Math.multScalar(circle.center, -1, Shape.vec3Cache[0]) : circle.center);
      const startProjected = this.segments[index - 1].end;
      const centerProjected = projection.project(center, Shape.vec2Cache[0]);
      const endProjected = projection.project(end, Shape.vec2Cache[1]);
      const startRadial = Vec2Math.sub(startProjected, centerProjected, Shape.vec2Cache[2]);
      const startRadialMag = Vec2Math.abs(startRadial);
      const endRadial = Vec2Math.sub(endProjected, centerProjected, Shape.vec2Cache[3]);
      const endRadialMag = Vec2Math.abs(endRadial);
      const radius = (startRadialMag + endRadialMag) / 2;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "arc";
      segment.radius = radius;
      segment.isClockwise = isClockwise;
      Vec2Math.copy(centerProjected, segment.center);
      Vec2Math.copy(endProjected, segment.end);
      Vec2Math.normalize(startRadial, segment.startNormal);
      Vec2Math.normalize(endRadial, segment.endNormal);
    }
    calculateSignedArea(segment, prevSegment) {
      if (segment.type === "start") {
        return 0;
      }
      if (segment.type === "line") {
        return prevSegment.end[0] * segment.end[1] - segment.end[0] * prevSegment.end[1];
      }
      const startRadial = Vec2Math.sub(prevSegment.end, segment.center, Shape.vec2Cache[0]);
      const startTheta = Vec2Math.theta(startRadial);
      const endRadial = Vec2Math.sub(segment.end, segment.center, Shape.vec2Cache[1]);
      const endTheta = Vec2Math.theta(endRadial);
      const angularWidth = Shape.getAngularWidth(startTheta, endTheta, segment.isClockwise, true);
      return prevSegment.end[0] * segment.center[1] - segment.center[0] * prevSegment.end[1] + segment.center[0] * segment.end[1] - segment.end[0] * segment.center[1] + angularWidth * segment.radius * segment.radius * (segment.isClockwise ? 1 : -1);
    }
    calculateVertices() {
      const max = this.isClosed ? this.length - 1 : this.length;
      for (let i = 0; i < this.length; i++) {
        const next = this.isClosed ? i % max + 1 : (i + 1) % max;
        this.calculateVertex(i, next);
      }
    }
    calculateVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      if (curr.type === "start" && next.type === "start") {
        curr.vertex.type = "null";
        curr.vertex.fromIndex = currIndex;
        curr.vertex.toIndex = nextIndex;
      } else if (curr.type === "start" && next.type === "line") {
        this.calculateLineStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "line" && next.type === "start") {
        this.calculateLineStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "start" && next.type === "arc") {
        this.calculateArcStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "arc" && next.type === "start") {
        this.calculateArcStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "line" && next.type === "line") {
        this.calculateLineLineVertex(currIndex, nextIndex);
      } else if (curr.type === "line" && next.type === "arc") {
        this.calculateLineArcVertex(currIndex, nextIndex, false);
      } else if (curr.type === "arc" && next.type === "line") {
        this.calculateLineArcVertex(currIndex, nextIndex, true);
      } else {
        this.calculateArcArcVertex(currIndex, nextIndex);
      }
    }
    calculateLineStartVertex(currIndex, nextIndex, isStartFirst) {
      const line = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "line-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.multScalar(line.endNormal, this.windingOrder, vertex.normal);
    }
    calculateArcStartVertex(currIndex, nextIndex, isStartFirst) {
      const arc = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "arc-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const arcNormal = isStartFirst ? arc.startNormal : arc.endNormal;
      Vec2Math.multScalar(arcNormal, this.windingOrder * (arc.isClockwise ? 1 : -1), vertex.normal);
    }
    calculateLineLineVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "line-line";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.normalize(Vec2Math.multScalar(Vec2Math.add(curr.endNormal, next.endNormal, vertex.normal), this.windingOrder, vertex.normal), vertex.normal);
      const deltaUnit = Vec2Math.normalize(Vec2Math.sub(next.end, curr.end, Shape.vec2Cache[0]), Shape.vec2Cache[0]);
      const scaleFactor = Math.abs(1 / (vertex.normal[0] * deltaUnit[1] - vertex.normal[1] * deltaUnit[0]));
      Vec2Math.multScalar(vertex.normal, scaleFactor, vertex.normal);
    }
    calculateLineArcVertex(currIndex, nextIndex, isArcFirst) {
      const curr = this.segments[currIndex];
      const line = this.segments[isArcFirst ? nextIndex : currIndex];
      const arc = this.segments[isArcFirst ? currIndex : nextIndex];
      const end = curr.end;
      const vertex = curr.vertex;
      vertex.type = "line-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      vertex.arcOffsetSign = this.windingOrder * (arc.isClockwise ? 1 : -1);
      const centerEndDelta = Vec2Math.sub(isArcFirst ? arc.end : line.end, arc.center, Shape.vec2Cache[0]);
      const dot = centerEndDelta[1] * line.endNormal[0] - centerEndDelta[0] * line.endNormal[1];
      const theta = Vec2Math.theta(line.endNormal) + (dot >= 0 ? Math.PI / 2 : -Math.PI / 2);
      Shape.transformCache[0].toTranslation(-arc.center[0], -arc.center[1]);
      const rotation = Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.r0 = arc.radius;
      vertex.y0 = vertex.transform.apply(end, Shape.vec2Cache[0])[1];
      vertex.lineOffsetSign = rotation.apply(line.endNormal, Shape.vec2Cache[0])[1] >= 0 ? this.windingOrder : -this.windingOrder;
      vertex.transform.invert();
    }
    calculateArcArcVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "arc-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const centerDelta = Vec2Math.sub(next.center, curr.center, Shape.vec2Cache[0]);
      const centerEndDelta = Vec2Math.sub(curr.end, curr.center, Shape.vec2Cache[1]);
      const dot = centerDelta[0] * centerEndDelta[1] - centerDelta[1] * centerEndDelta[0];
      const theta = Vec2Math.theta(centerDelta) + (dot >= 0 ? 0 : Math.PI);
      Shape.transformCache[0].toTranslation(-curr.center[0], -curr.center[1]);
      Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.d = vertex.transform.apply(next.center, Shape.vec2Cache[0])[0];
      vertex.arcOffsetSign = this.windingOrder * (curr.isClockwise ? 1 : -1);
      vertex.arc2OffsetSign = this.windingOrder * (next.isClockwise ? 1 : -1);
      vertex.transform.invert();
    }
    renderLine(context, offset, lineWidth, strokeStyle, dash, stream) {
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const startPoint = Vec2Math.set(0, 0, Shape.vec2Cache[0]);
      if (this.isClosed) {
        if (offset === 0) {
          Vec2Math.copy(this.segments[0].end, startPoint);
        } else {
          const lastIndex = this.length - 1;
          const result = this.calculateOffsetVertex(lastIndex, offset, startPoint);
          if (!result || Shape.isPointInSegmentBounds(this.segments[lastIndex], this.segments[lastIndex - 1].end, result)) {
            this.calculateOffsetEndPoint(lastIndex, offset, startPoint);
          }
        }
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      for (let i = this.isClosed ? 1 : 0; i < this.length; i++) {
        const segment = this.segments[i];
        let newStartPoint;
        switch (segment.type) {
          case "start":
            newStartPoint = this.pathStartSegment(stream, i, offset);
            break;
          case "line":
            newStartPoint = this.pathLineSegment(stream, i, startPoint, offset);
            break;
          case "arc":
            newStartPoint = this.pathArcSegment(stream, i, startPoint, offset);
            break;
        }
        Vec2Math.copy(newStartPoint, startPoint);
      }
      context.lineWidth = lineWidth;
      context.strokeStyle = strokeStyle;
      context.setLineDash(dash);
      context.stroke();
    }
    pathStartSegment(stream, index, offset) {
      const segment = this.segments[index];
      if (offset === 0) {
        stream.moveTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd) {
          stream.moveTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          stream.moveTo(segment.end[0], segment.end[1]);
          return segment.end;
        }
      }
    }
    pathLineSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      if (offset === 0) {
        stream.lineTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          stream.lineTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
          stream.lineTo(endPoint[0], endPoint[1]);
          const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
          stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
          return nextStartPoint;
        }
      }
    }
    pathArcSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      let startAngle;
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
        startAngle = Math.atan2(startPoint[1] - segment.center[1], startPoint[0] - segment.center[0]);
      } else {
        startAngle = Math.atan2(start[1] - segment.center[1], start[0] - segment.center[0]);
      }
      if (offset === 0) {
        const endAngle = Vec2Math.theta(segment.endNormal);
        const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
        stream.arc(segment.center[0], segment.center[1], segment.radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), !segment.isClockwise);
        return segment.end;
      } else {
        const baseEndAngle = Vec2Math.theta(segment.endNormal);
        const baseAngularWidth = Shape.getAngularWidth(startAngle, baseEndAngle, segment.isClockwise, true);
        const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
        const radius = segment.radius + offset * sign;
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          const endAngle = Math.atan2(offsetEnd[1] - segment.center[1], offsetEnd[0] - segment.center[0]);
          const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
          const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
          stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
          return offsetEnd;
        } else {
          if (radius > 0) {
            const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
            const endAngle = Math.atan2(endPoint[1] - segment.center[1], endPoint[0] - segment.center[0]);
            const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
            const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
            stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
            const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
            stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
            return nextStartPoint;
          } else {
            stream.moveTo(segment.center[0], segment.center[1]);
            return segment.center;
          }
        }
      }
    }
    calculateOffsetVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      switch (vertex.type) {
        case "line-start":
        case "arc-start":
        case "line-line":
          return this.calculateOffsetVertexFromNormal(index, offset, out);
        case "line-arc":
          return this.calculateOffsetLineArcVertex(index, offset, out);
        case "arc-arc":
          return this.calculateOffsetArcArcVertex(index, offset, out);
        default:
          return Vec2Math.copy(this.segments[vertex.fromIndex].end, out);
      }
    }
    calculateOffsetVertexFromNormal(index, offset, out) {
      const segment = this.segments[index];
      const vertex = segment.vertex;
      return Vec2Math.add(segment.end, Vec2Math.multScalar(vertex.normal, offset, out), out);
    }
    calculateOffsetLineArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      const radius = vertex.r0 + offset * vertex.arcOffsetSign;
      if (radius <= 0) {
        return void 0;
      }
      const y = vertex.y0 + offset * vertex.lineOffsetSign;
      const xSq = radius * radius - y * y;
      if (xSq < 0) {
        return void 0;
      }
      const x = Math.sqrt(xSq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    calculateOffsetArcArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      if (vertex.d === 0) {
        return void 0;
      }
      const segment1 = this.segments[vertex.fromIndex];
      const segment2 = this.segments[vertex.toIndex];
      const radius1 = segment1.radius + offset * vertex.arcOffsetSign;
      const radius2 = segment2.radius + offset * vertex.arc2OffsetSign;
      if (radius1 <= 0 || radius2 <= 0) {
        return void 0;
      }
      const dSq = vertex.d * vertex.d;
      const radius1Sq = radius1 * radius1;
      const radius2Sq = radius2 * radius2;
      const x = (dSq - radius2Sq + radius1Sq) / (2 * vertex.d);
      const ySq = radius1Sq - x * x;
      if (ySq < 0) {
        return void 0;
      }
      const y = Math.sqrt(ySq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    calculateOffsetStartPoint(index, offset, out) {
      const prevSegment = this.segments[index - 1];
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(prevSegment.end[0] + segment.endNormal[0] * this.windingOrder * offset, prevSegment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(prevSegment.end[0] + segment.startNormal[0] * sign * offset, prevSegment.end[1] + segment.startNormal[1] * sign * offset, out);
        }
      }
    }
    calculateOffsetEndPoint(index, offset, out) {
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * this.windingOrder * offset, segment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * sign * offset, segment.end[1] + segment.endNormal[1] * sign * offset, out);
        }
      }
    }
    static isPointInSegmentBounds(segment, start, point) {
      if (segment.type === "start") {
        return true;
      }
      if (segment.type === "line") {
        const lineDeltaX = segment.end[0] - start[0];
        const lineDeltaY = segment.end[1] - start[1];
        const startDeltaX = point[0] - start[0];
        const startDeltaY = point[1] - start[1];
        const endDeltaX = point[0] - segment.end[0];
        const endDeltaY = point[1] - segment.end[1];
        const startDot = startDeltaX * lineDeltaX + startDeltaY * lineDeltaY;
        const endDot = endDeltaX * lineDeltaX + endDeltaY * lineDeltaY;
        return startDot >= 0 && endDot <= 0;
      }
      const startAngle = Vec2Math.theta(segment.startNormal);
      const endAngle = Vec2Math.theta(segment.endNormal);
      const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
      const pointAngle = Math.atan2(point[1] - segment.center[1], point[0] - segment.center[0]);
      const angleDiff = Shape.getAngularWidth(startAngle, pointAngle, segment.isClockwise);
      return angleDiff <= angularWidth;
    }
    static getAngularWidth(startAngle, endAngle, isClockwise, zeroIsCircle = false, zeroTolerance = 1e-6) {
      const width = ((isClockwise ? endAngle - startAngle : startAngle - endAngle) + 2 * Math.PI) % (2 * Math.PI);
      return zeroIsCircle && Math.min(width, 2 * Math.PI - width) < zeroTolerance ? 2 * Math.PI : width;
    }
    static createSegment() {
      return {
        type: "arc",
        center: new Float64Array(2),
        radius: 0,
        isClockwise: false,
        end: new Float64Array(2),
        endNormal: new Float64Array(2),
        startNormal: new Float64Array(2),
        vertex: {
          type: "null",
          fromIndex: -1,
          toIndex: -1,
          normal: new Float64Array(2),
          transform: new Transform2D(),
          r0: 0,
          y0: 0,
          lineOffsetSign: 1,
          arcOffsetSign: 1,
          arc2OffsetSign: 1,
          d: 0
        }
      };
    }
  };
  Shape.geoPointCache = [new GeoPoint(0, 0)];
  Shape.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  Shape.vec3Cache = [new Float64Array(3)];
  Shape.transformCache = [new Transform2D(), new Transform2D()];
  var MapFieldOfViewCalculator = class {
    constructor(maxIter = MapFieldOfViewCalculator.DEFAULT_MAX_ITER, rangeTolerance = MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE) {
      this.maxIter = maxIter;
      this.rangeTolerance = rangeTolerance;
      this.tempProjection = new MapProjection(100, 100);
    }
    calculateFov(mapProjection, focus, margins, out) {
      out.range = NaN;
      out.target.set(NaN, NaN);
      if (focus.length === 0) {
        return out;
      }
      const projectedSize = mapProjection.getProjectedSize();
      const targetWidth = projectedSize[0] - margins[0] - margins[2];
      const targetHeight = projectedSize[1] - margins[1] - margins[3];
      if (targetWidth * targetHeight <= 0) {
        return out;
      }
      const mean = Vec3Math.set(0, 0, 0, MapFieldOfViewCalculator.vec3Cache[0]);
      for (let i = 0; i < focus.length; i++) {
        Vec3Math.add(mean, GeoPoint.sphericalToCartesian(focus[i], MapFieldOfViewCalculator.vec3Cache[1]), mean);
      }
      Vec3Math.multScalar(mean, 1 / focus.length, mean);
      this.tempProjection.set({
        projectedSize: mapProjection.getProjectedSize(),
        rotation: mapProjection.getRotation(),
        target: MapFieldOfViewCalculator.geoPointCache[0].setFromCartesian(mean),
        targetProjectedOffset: Vec2Math.set(margins[0] + (targetWidth - projectedSize[0]) / 2, margins[1] + (targetHeight - projectedSize[1]) / 2, MapFieldOfViewCalculator.vec2Cache[0]),
        rangeEndpoints: mapProjection.getRangeEndpoints(),
        range: mapProjection.getRange()
      });
      let minX;
      let minY;
      let maxX;
      let maxY;
      for (let i = 0; i < focus.length; i++) {
        const projected = this.tempProjection.project(focus[i], MapFieldOfViewCalculator.vec2Cache[0]);
        minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
        minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
        maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
        maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
      }
      if (minX === void 0 || minY === void 0 || maxX === void 0 || maxY === void 0) {
        return out;
      }
      let focusWidth = maxX - minX;
      let focusHeight = maxY - minY;
      if (focusWidth === 0 && focusHeight === 0) {
        out.target.set(focus[0]);
        out.range = 0;
        return out;
      }
      this.tempProjection.invert(Vec2Math.set((minX + maxX) / 2, (minY + maxY) / 2, MapFieldOfViewCalculator.vec2Cache[0]), out.target);
      this.tempProjection.set({
        target: out.target
      });
      let widthRatio = focusWidth / targetWidth;
      let heightRatio = focusHeight / targetHeight;
      let constrainedRatio = Math.max(widthRatio, heightRatio);
      const range = out.range = this.tempProjection.getRange();
      const topLeft = this.tempProjection.invert(Vec2Math.set(minX, minY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[0]);
      const bottomRight = this.tempProjection.invert(Vec2Math.set(maxX, maxY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[1]);
      let iterCount = 0;
      const rangeParam = { range };
      let ratioError = Math.abs(constrainedRatio - 1);
      let deltaRatioError = this.rangeTolerance + 1;
      while (iterCount++ < this.maxIter && ratioError > this.rangeTolerance && deltaRatioError > this.rangeTolerance) {
        rangeParam.range = out.range = this.tempProjection.getRange() * constrainedRatio;
        if (out.range <= GeoPoint.EQUALITY_TOLERANCE) {
          out.range = GeoPoint.EQUALITY_TOLERANCE;
          return out;
        }
        this.tempProjection.set(rangeParam);
        const topLeftProjected = this.tempProjection.project(topLeft, MapFieldOfViewCalculator.vec2Cache[0]);
        const bottomRightProjected = this.tempProjection.project(bottomRight, MapFieldOfViewCalculator.vec2Cache[1]);
        focusWidth = bottomRightProjected[0] - topLeftProjected[0];
        focusHeight = bottomRightProjected[1] - topLeftProjected[1];
        widthRatio = focusWidth / targetWidth;
        heightRatio = focusHeight / targetHeight;
        constrainedRatio = Math.max(widthRatio, heightRatio);
        const newRatioError = Math.abs(constrainedRatio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.tempProjection.invert(mapProjection.getTargetProjected(), out.target);
      return out;
    }
  };
  MapFieldOfViewCalculator.DEFAULT_MAX_ITER = 20;
  MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE = 0.01;
  MapFieldOfViewCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  MapFieldOfViewCalculator.vec2Cache = [Vec2Math.create(), Vec2Math.create()];
  MapFieldOfViewCalculator.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
  var MapOwnAirplaneIconOrientation;
  (function(MapOwnAirplaneIconOrientation2) {
    MapOwnAirplaneIconOrientation2["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation2["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation2["MapUp"] = "MapUp";
  })(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));
  var MapOwnAirplaneIconModule = class {
    constructor() {
      this.show = Subject.create(true);
      this.orientation = Subject.create(MapOwnAirplaneIconOrientation.HeadingUp);
    }
  };
  var MapOwnAirplanePropsModule = class {
    constructor() {
      this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
      this.hdgTrue = Subject.create(0);
      this.turnRate = Subject.create(0);
      this.altitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.verticalSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
      this.trackTrue = Subject.create(0);
      this.groundSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0));
      this.isOnGround = Subject.create(true);
      this.magVar = Subject.create(0);
    }
  };
  var MapAutopilotPropsModule = class {
    constructor() {
      this.selectedAltitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.apSelectedAltitudeHandler = (alt) => {
        this.selectedAltitude.set(alt);
      };
    }
  };
  var MapAirspaceModule = class {
    constructor(showTypes) {
      this.showTypes = showTypes;
      this.show = {};
      for (const type in showTypes) {
        this.show[type] = Subject.create(false);
      }
    }
  };
  var AbstractCssTransform = class {
    constructor(initialParams) {
      this.params = new Float64Array(initialParams);
      this.cachedParams = new Float64Array(initialParams);
    }
    resolve() {
      if (this.stringValue !== void 0 && VecNMath.equals(this.params, this.cachedParams)) {
        return this.stringValue;
      }
      VecNMath.copy(this.params, this.cachedParams);
      this.stringValue = this.buildString(this.params);
      return this.stringValue;
    }
  };
  var CssMatrixTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
      let scaleX;
      if (typeof arg1 === "number") {
        scaleX = arg1;
      } else {
        [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
      }
      this.params[0] = scaleX;
      this.params[1] = skewY;
      this.params[2] = skewX;
      this.params[3] = scaleY;
      this.params[4] = translateX;
      this.params[5] = translateY;
    }
    buildString(params) {
      return `matrix(${params.join(", ")})`;
    }
  };
  CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
  var CssRotateTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssRotateTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(angle, precision = 0) {
      this.params[0] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    buildString(params) {
      return `rotate(${params[0]}${this.unit})`;
    }
  };
  CssRotateTransform.DEFAULT_PARAMS = [0];
  var CssRotate3dTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssRotate3dTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(x, y, z, angle, precision = 0) {
      this.params[0] = x;
      this.params[1] = y;
      this.params[2] = z;
      this.params[3] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    buildString(params) {
      return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
  };
  CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
  var CssTranslateXTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateXTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    buildString(params) {
      return `translateX(${params[0]}${this.unit})`;
    }
  };
  CssTranslateXTransform.DEFAULT_PARAMS = [0];
  var CssTranslateYTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateYTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    buildString(params) {
      return `translateY(${params[0]}${this.unit})`;
    }
  };
  CssTranslateYTransform.DEFAULT_PARAMS = [0];
  var CssTranslateZTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateZTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    buildString(params) {
      return `translateZ(${params[0]}${this.unit})`;
    }
  };
  CssTranslateZTransform.DEFAULT_PARAMS = [0];
  var CssTranslateTransform = class extends AbstractCssTransform {
    constructor(unitX, unitY = unitX) {
      super(CssTranslateTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
    }
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    buildString(params) {
      return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
  };
  CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
  var CssTranslate3dTransform = class extends AbstractCssTransform {
    constructor(unitX, unitY = unitX, unitZ = unitX) {
      super(CssTranslate3dTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
      this.unitZ = unitZ;
    }
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils.round(z, precisionZ);
    }
    buildString(params) {
      return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
  };
  CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
  var CssScaleXTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    buildString(params) {
      return `scaleX(${params[0]})`;
    }
  };
  CssScaleXTransform.DEFAULT_PARAMS = [1];
  var CssScaleYTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    buildString(params) {
      return `scaleY(${params[0]})`;
    }
  };
  CssScaleYTransform.DEFAULT_PARAMS = [1];
  var CssScaleZTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    buildString(params) {
      return `scaleZ(${params[0]})`;
    }
  };
  CssScaleZTransform.DEFAULT_PARAMS = [1];
  var CssScaleTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleTransform.DEFAULT_PARAMS);
    }
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    buildString(params) {
      return `scale(${params[0]}, ${params[1]})`;
    }
  };
  CssScaleTransform.DEFAULT_PARAMS = [1, 1];
  var CssScale3dTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils.round(y, precisionZ);
    }
    buildString(params) {
      return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
  };
  CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
  var CssTransformChain = class {
    constructor(...transforms) {
      this.stringValues = [];
      this.transforms = transforms;
    }
    getChild(index) {
      if (index < 0 || index >= this.transforms.length) {
        throw new RangeError();
      }
      return this.transforms[index];
    }
    resolve() {
      let needRebuildString = false;
      for (let i = 0; i < this.transforms.length; i++) {
        const stringValue = this.transforms[i].resolve();
        if (this.stringValues[i] !== stringValue) {
          this.stringValues[i] = stringValue;
          needRebuildString = true;
        }
      }
      if (needRebuildString || this.chainedStringValue === void 0) {
        this.chainedStringValue = this.stringValues.join(" ");
      }
      return this.chainedStringValue;
    }
  };
  var CssTransformSubject = class extends AbstractSubscribable {
    constructor(transform) {
      super();
      this._transform = transform;
      this.stringValue = transform.resolve();
      this.transform = transform;
    }
    get() {
      return this.stringValue;
    }
    resolve() {
      const stringValue = this._transform.resolve();
      if (stringValue !== this.stringValue) {
        this.stringValue = stringValue;
        this.notify();
      }
    }
    static create(transform) {
      return new CssTransformSubject(transform);
    }
  };
  var CssTransformBuilder = class {
    static matrix() {
      return new CssMatrixTransform();
    }
    static rotate(unit) {
      return new CssRotateTransform(unit);
    }
    static rotate3d(unit) {
      return new CssRotate3dTransform(unit);
    }
    static translateX(unit) {
      return new CssTranslateXTransform(unit);
    }
    static translateY(unit) {
      return new CssTranslateYTransform(unit);
    }
    static translateZ(unit) {
      return new CssTranslateZTransform(unit);
    }
    static translate(unitX, unitY) {
      return new CssTranslateTransform(unitX, unitY);
    }
    static translate3d(unitX, unitY, unitZ) {
      return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    static scaleX() {
      return new CssScaleXTransform();
    }
    static scaleY() {
      return new CssScaleYTransform();
    }
    static scaleZ() {
      return new CssScaleZTransform();
    }
    static scale() {
      return new CssScaleTransform();
    }
    static scale3d() {
      return new CssScale3dTransform();
    }
    static concat(...transforms) {
      return new CssTransformChain(...transforms);
    }
  };
  var NumberFormatter = class {
    static formatNumber(number, opts) {
      if (isNaN(number)) {
        return opts.nanString;
      }
      const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
      const sign = number < 0 ? -1 : 1;
      const abs = Math.abs(number);
      let rounded = abs;
      if (precision !== 0) {
        rounded = roundFunc(abs / precision) * precision;
      }
      if (cache) {
        if (opts.cachedString !== void 0 && opts.cachedNumber === rounded) {
          return opts.cachedString;
        }
        opts.cachedNumber = rounded;
      }
      const signText = sign === -1 ? useMinusSign ? "\u2212" : "-" : "+";
      let formatted;
      if (precision != 0) {
        const precisionString = `${precision}`;
        const decimalIndex2 = precisionString.indexOf(".");
        if (decimalIndex2 >= 0) {
          formatted = rounded.toFixed(precisionString.length - decimalIndex2 - 1);
        } else {
          formatted = `${rounded}`;
        }
      } else {
        formatted = `${abs}`;
      }
      let decimalIndex = formatted.indexOf(".");
      if (!forceDecimalZeroes && decimalIndex >= 0) {
        formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, "");
        if (formatted.indexOf(".") == formatted.length - 1) {
          formatted = formatted.substring(0, formatted.length - 1);
        }
      }
      decimalIndex = formatted.indexOf(".");
      if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
        const shift = Math.max(maxDigits - decimalIndex, 0);
        const shiftPrecision = Math.pow(0.1, shift);
        formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
      }
      if (pad === 0) {
        formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, ".");
      } else if (pad > 1) {
        decimalIndex = formatted.indexOf(".");
        if (decimalIndex < 0) {
          decimalIndex = formatted.length;
        }
        formatted = formatted.padStart(pad + formatted.length - decimalIndex, "0");
      }
      if (showCommas) {
        const parts = formatted.split(".");
        parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ",");
        formatted = parts.join(".");
      }
      formatted = (forceSign || signText !== "+" ? signText : "") + formatted;
      if (cache) {
        opts.cachedString = formatted;
      }
      return formatted;
    }
    static create(options) {
      const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
      optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
      return (number) => {
        return NumberFormatter.formatNumber(number, optsToUse);
      };
    }
  };
  NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: "NaN",
    cache: false
  };
  NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
  };
  NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
  NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
  NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;
  var SvgPathStream = class {
    constructor(precision = 0) {
      this.svgPath = "";
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.precision = precision;
      this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    getSvgPath() {
      return this.svgPath.trim();
    }
    getPrecision() {
      return this.precision;
    }
    setPrecision(precision) {
      this.precision = Math.abs(precision);
      this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    beginPath() {
      this.reset();
    }
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = counterClockwise ? MathUtils.diffAngle(endAngle, startAngle) : MathUtils.diffAngle(startAngle, endAngle);
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(MathUtils.TWO_PI, (endAngle - startAngle) * directionSign);
      if (angularWidth === MathUtils.TWO_PI) {
        const midAngle = startAngle + Math.PI * directionSign;
        this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
        this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
      const radiusString = this.formatter(radius);
      this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
      Vec2Math.copy(endPoint, this.prevPoint);
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.svgPath = "";
    }
  };
  SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var MapSystemKeys = class {
  };
  MapSystemKeys.TargetControl = "targetControlModerator";
  MapSystemKeys.RotationControl = "rotationControlModerator";
  MapSystemKeys.RangeControl = "rangeControlModerator";
  MapSystemKeys.ClockUpdate = "clockUpdate";
  MapSystemKeys.OwnAirplaneProps = "ownAirplaneProps";
  MapSystemKeys.AutopilotProps = "autopilotProps";
  MapSystemKeys.AltitudeArc = "altitudeArc";
  MapSystemKeys.TerrainColors = "terrainColors";
  MapSystemKeys.Weather = "weather";
  MapSystemKeys.FollowAirplane = "followAirplane";
  MapSystemKeys.Rotation = "rotation";
  MapSystemKeys.OwnAirplaneIcon = "ownAirplaneIcon";
  MapSystemKeys.OwnAirplaneIconOrientation = "ownAirplaneIconOrientation";
  MapSystemKeys.TextLayer = "text";
  MapSystemKeys.TextManager = "textManager";
  MapSystemKeys.Bing = "bing";
  MapSystemKeys.WaypointRenderer = "waypointRenderer";
  MapSystemKeys.IconFactory = "iconFactory";
  MapSystemKeys.LabelFactory = "labelFactory";
  MapSystemKeys.NearestWaypoints = "nearestWaypoints";
  MapSystemKeys.FlightPlan = "flightPlan";
  MapSystemKeys.FlightPlanner = "flightPlanner";
  MapSystemKeys.FlightPathRenderer = "flightPathRenderer";
  MapSystemKeys.Airspace = "airspace";
  MapSystemKeys.AirspaceManager = "airspaceRenderManager";
  MapSystemKeys.Traffic = "traffic";
  MapSystemKeys.DataIntegrity = "dataIntegrity";
  var MapCanvasLayerCanvasInstanceClass = class {
    constructor(canvas, context, isDisplayed) {
      this.canvas = canvas;
      this.context = context;
      this.isDisplayed = isDisplayed;
    }
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    reset() {
      const width = this.canvas.width;
      this.canvas.width = 0;
      this.canvas.width = width;
    }
  };
  var MapCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.displayCanvasRef = FSComponent.createRef();
      this.width = 0;
      this.height = 0;
      this.displayCanvasContext = null;
      this.isInit = false;
    }
    get display() {
      if (!this._display) {
        throw new Error("MapCanvasLayer: attempted to access display before it was initialized");
      }
      return this._display;
    }
    get buffer() {
      if (!this._buffer) {
        throw new Error("MapCanvasLayer: attempted to access buffer before it was initialized");
      }
      return this._buffer;
    }
    tryGetDisplay() {
      return this._display;
    }
    tryGetBuffer() {
      return this._buffer;
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    setWidth(width) {
      if (width === this.width) {
        return;
      }
      this.width = width;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    setHeight(height) {
      if (height === this.height) {
        return;
      }
      this.height = height;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    copyBufferToDisplay() {
      if (!this.isInit || !this.props.useBuffer) {
        return;
      }
      this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    onAfterRender() {
      this.displayCanvasContext = this.displayCanvasRef.instance.getContext("2d");
    }
    onVisibilityChanged(isVisible) {
      if (this.isInit) {
        this.updateCanvasVisibility();
      }
    }
    updateFromVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    onAttached() {
      this.initCanvasInstances();
      this.isInit = true;
      this.updateCanvasVisibility();
      this.updateCanvasSize();
    }
    initCanvasInstances() {
      this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
      if (this.props.useBuffer) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        this._buffer = this.createCanvasInstance(canvas, context, false);
      }
    }
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    updateCanvasSize() {
      const displayCanvas = this.display.canvas;
      displayCanvas.width = this.width;
      displayCanvas.height = this.height;
      displayCanvas.style.width = `${this.width}px`;
      displayCanvas.style.height = `${this.height}px`;
      if (this._buffer) {
        const bufferCanvas = this._buffer.canvas;
        bufferCanvas.width = this.width;
        bufferCanvas.height = this.height;
      }
    }
    updateCanvasVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    render() {
      var _a;
      return FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", width: "0", height: "0", style: "position: absolute;" });
    }
  };
  var MapSyncedCanvasLayer = class extends MapCanvasLayer {
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    updateFromProjectedSize(projectedSize) {
      this.setWidth(projectedSize[0]);
      this.setHeight(projectedSize[1]);
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = "0px";
      displayCanvas.style.top = "0px";
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
    }
  };
  var MapAltitudeArcLayer = class extends MapLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.layerRef = FSComponent.createRef();
      this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
      this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
      this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
      this.strokeLineCap = (_e = this.props.strokeLineCap) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;
      this.outlineWidth = (_f = this.props.outlineWidth) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_g = this.props.outlineStyle) !== null && _g !== void 0 ? _g : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineLineCap = (_h = this.props.outlineLineCap) !== null && _h !== void 0 ? _h : MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;
      this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.autopilotModule = this.props.model.getModule(MapSystemKeys.AutopilotProps);
      this.vsPrecisionFpm = "isSubscribable" in this.props.verticalSpeedPrecision ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));
      this.vsThresholdFpm = "isSubscribable" in this.props.verticalSpeedThreshold ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));
      this.altDevThresholdFeet = "isSubscribable" in this.props.altitudeDeviationThreshold ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map((v) => v.asUnit(UnitType.FOOT)) : Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));
      this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map((vs) => vs.asUnit(UnitType.FPM));
      this.vsFpmQuantized = MappedSubject.create(([vsFpm, precision]) => {
        return Math.round(vsFpm / precision) * precision;
      }, this.vsFpm, this.vsPrecisionFpm);
      this.projectedPlanePosition = Vec2Subject.create(Vec2Math.create());
      this.projectPlanePositionHandler = () => {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
        this.projectedPlanePosition.set(projected);
      };
      this.isArcVisibleDynamic = MappedSubject.create(([vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
        if (Math.abs(vsFpm) < vsThreshold) {
          return false;
        }
        const altDevFeet = selectedAlt.asUnit(UnitType.FOOT) - alt.asUnit(UnitType.FOOT);
        return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
      }, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet).pause();
      this.projectedArcPosition = Vec2Subject.create(Vec2Math.create());
      this.projectedArcAngle = Subject.create(0);
      this.needUpdate = false;
      this.subscriptions = [];
    }
    onVisibilityChanged(isVisible) {
      var _a;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(isVisible);
      if (isVisible) {
        this.needUpdate = true;
      }
    }
    onAttached() {
      var _a, _b;
      this.layerRef.instance.onAttached();
      this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      const altitudeArcModule = this.props.model.getModule(MapSystemKeys.AltitudeArc);
      const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
      this.isArcVisibleStatic = MappedSubject.create(([show, isGpsValid, isAdcValid]) => {
        return show && isGpsValid && isAdcValid;
      }, altitudeArcModule.show, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true));
      const isArcVisibleDynamicSub = this.isArcVisibleDynamic.sub((isVisible) => {
        this.setVisible(isVisible);
      }, false, true);
      this.isArcVisibleStatic.sub((isVisible) => {
        if (isVisible) {
          this.isArcVisibleDynamic.resume();
          isArcVisibleDynamicSub.resume(true);
        } else {
          this.isArcVisibleDynamic.pause();
          isArcVisibleDynamicSub.pause();
          this.setVisible(false);
        }
      }, true);
      this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
      this.vsFpmQuantized.sub(scheduleUpdate);
      this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
      this.layerRef.instance.setVisible(this.isVisible());
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.layerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.projectPlanePositionHandler();
      this.needUpdate = true;
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const track = this.ownAirplanePropsModule.trackTrue.get();
      const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
      const altitude = this.ownAirplanePropsModule.altitude.get();
      const selectedAltitude = this.autopilotModule.selectedAltitude.get();
      const vsFpm = this.vsFpmQuantized.get();
      const timeToAltitudeMinute = (selectedAltitude.asUnit(UnitType.FOOT) - altitude.asUnit(UnitType.FOOT)) / vsFpm;
      const distanceToAltitudeFeet = groundSpeed.asUnit(UnitType.FPM) * timeToAltitudeMinute;
      const distancePx = UnitType.FOOT.convertTo(distanceToAltitudeFeet, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
      const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - MathUtils.HALF_PI;
      const projectedPlanePos = this.projectedPlanePosition.get();
      const projectedArcPos = Vec2Math.add(Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
      this.projectedArcPosition.set(projectedArcPos);
      this.projectedArcAngle.set(projectedTrackAngle);
      this.layerRef.instance.onUpdated();
      this.needUpdate = false;
    }
    render() {
      const props = {
        ref: this.layerRef,
        model: this.props.model,
        mapProjection: this.props.mapProjection,
        arcAngularWidth: this.arcAngularWidth,
        arcRadius: this.arcRadius,
        strokeWidth: this.strokeWidth,
        strokeStyle: this.strokeStyle,
        strokeLineCap: this.strokeLineCap,
        outlineWidth: this.outlineWidth,
        outlineStyle: this.outlineStyle,
        outlineLineCap: this.outlineLineCap,
        projectedArcPosition: this.projectedArcPosition,
        projectedArcAngle: this.projectedArcAngle
      };
      return this.props.renderMethod === "canvas" ? FSComponent.buildComponent(MapAltitudeArcCanvasLayer, Object.assign({}, props)) : FSComponent.buildComponent(MapAltitudeArcSvgLayer, Object.assign({}, props));
    }
    destroy() {
      var _a, _b, _c, _d, _e;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.vsPrecisionMap) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.vsThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.altDevThresholdMap) === null || _d === void 0 ? void 0 : _d.destroy();
      this.vsFpm.destroy();
      (_e = this.isArcVisibleStatic) === null || _e === void 0 ? void 0 : _e.destroy();
      this.isArcVisibleDynamic.destroy();
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60;
  MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64;
  MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2;
  MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = "cyan";
  MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP = "butt";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1;
  MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = "#505050";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP = "butt";
  MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.canvasLayerRef = FSComponent.createRef();
      this.subscriptions = [];
      this.needUpdate = false;
    }
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (isVisible) {
        this.needUpdate = true;
      } else {
        (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
      this.needUpdate = true;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const display = this.canvasLayerRef.instance.display;
      display.clear();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        return;
      }
      display.context.beginPath();
      const projectedArcAngle = this.props.projectedArcAngle.get();
      const center = Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius, projectedArcAngle, MapAltitudeArcCanvasLayer.vec2Cache[0]), arcPos, MapAltitudeArcCanvasLayer.vec2Cache[0]);
      const arcStart = Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, MapAltitudeArcCanvasLayer.vec2Cache[1]), center, MapAltitudeArcCanvasLayer.vec2Cache[1]);
      display.context.moveTo(arcStart[0], arcStart[1]);
      display.context.arc(center[0], center[1], this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, projectedArcAngle + this.arcHalfAngularWidth);
      if (this.props.outlineWidth > 0) {
        display.context.lineWidth = this.totalArcThickness;
        display.context.strokeStyle = this.props.outlineStyle;
        display.context.lineCap = this.props.outlineLineCap;
        display.context.stroke();
      }
      if (this.props.strokeWidth > 0) {
        display.context.lineWidth = this.props.strokeWidth;
        display.context.strokeStyle = this.props.strokeStyle;
        display.context.lineCap = this.props.strokeLineCap;
        display.context.stroke();
      }
      this.needUpdate = false;
    }
    render() {
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection });
    }
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcCanvasLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcSvgLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.width = this.props.arcRadius * (1 - Math.cos(this.arcHalfAngularWidth)) + this.totalArcThickness + 2;
      this.height = 2 * this.props.arcRadius * Math.sin(Math.min(this.arcHalfAngularWidth, MathUtils.HALF_PI)) + this.totalArcThickness + 2;
      this.svgStyle = ObjectSubject.create({
        "display": "",
        "position": "absolute",
        "left": `${this.totalArcThickness / 2 + 1 - this.width}px`,
        "top": `${-this.height / 2}px`,
        "width": `${this.width}px`,
        "height": `${this.height}px`,
        "transform": "translate3d(0px, 0px, 0px) rotate(0rad)",
        "transform-origin": `${this.width - (this.totalArcThickness / 2 + 1)}px ${this.height / 2}px`
      });
      this.svgTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("rad"));
      this.needUpdate = false;
      this.subscriptions = [];
    }
    onVisibilityChanged(isVisible) {
      if (isVisible) {
        this.needUpdate = true;
      } else {
        this.svgStyle.set("display", "none");
      }
    }
    onAttached() {
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        this.svgStyle.set("display", "none");
      } else {
        this.svgStyle.set("display", "");
        this.svgTransform.getChild(0).set(arcX, arcY, 0, 0.1);
        this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(), 1e-4);
        this.svgStyle.set("transform", this.svgTransform.resolve());
      }
      this.needUpdate = false;
    }
    render() {
      const svgPathStream = new SvgPathStream(0.01);
      const transformPathStream = new AffineTransformPathStream(svgPathStream);
      transformPathStream.beginPath();
      transformPathStream.addRotation(-this.arcHalfAngularWidth).addTranslation(-this.props.arcRadius, 0);
      transformPathStream.moveTo(this.props.arcRadius, 0);
      transformPathStream.arc(0, 0, this.props.arcRadius, 0, this.props.arcAngularWidth);
      const path = svgPathStream.getSvgPath();
      return FSComponent.buildComponent(
        "svg",
        { viewBox: `${this.totalArcThickness / 2 + 1 - this.width} ${-this.height / 2} ${this.width} ${this.height}`, style: this.svgStyle },
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.outlineStyle, "stroke-width": this.totalArcThickness, "stroke-linecap": this.props.outlineLineCap }),
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.strokeStyle, "stroke-width": this.props.strokeWidth, "stroke-linecap": this.props.strokeLineCap })
      );
    }
    destroy() {
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  var MapBingLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.bingRef = FSComponent.createRef();
      this.wrapperStyle = ObjectSubject.create({
        "position": "absolute",
        "left": "0px",
        "top": "0px",
        "width": "0px",
        "height": "0px",
        "display": "",
        "transform": ""
      });
      this.resolution = Vec2Subject.create(Vec2Math.create(1024, 1024));
      this.rotationTransform = CssTransformBuilder.rotate("rad");
      this.size = 0;
      this.needUpdate = false;
    }
    onVisibilityChanged(isVisible) {
      this.wrapperStyle.set("display", isVisible ? "" : "none");
    }
    onAttached() {
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      if (this.props.wxrMode !== void 0) {
        this.props.wxrMode.sub(() => {
          this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
          this.needUpdate = true;
        });
      }
    }
    onWake() {
      this.bingRef.instance.wake();
    }
    onSleep() {
      this.bingRef.instance.sleep();
    }
    updateFromProjectedSize(projectedSize) {
      let offsetX, offsetY;
      if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
        const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
        const offset = this.props.mapProjection.getTargetProjectedOffset();
        offsetSize[0] += offset[0];
        offsetSize[1] += offset[1];
        this.size = this.getSize(offsetSize);
        offsetX = (projectedSize[0] - this.size) / 2 + offset[0];
        offsetY = (projectedSize[1] - this.size) / 2 + offset[1];
      } else {
        this.size = this.getSize(projectedSize);
        offsetX = (projectedSize[0] - this.size) / 2;
        offsetY = (projectedSize[1] - this.size) / 2;
      }
      this.wrapperStyle.set("left", `${offsetX}px`);
      this.wrapperStyle.set("top", `${offsetY}px`);
      this.wrapperStyle.set("width", `${this.size}px`);
      this.wrapperStyle.set("height", `${this.size}px`);
      this.resolution.set(this.size, this.size);
    }
    getSize(projectedSize) {
      return Vec2Math.abs(projectedSize);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.TargetProjected)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
      if (this.bingRef.instance.isBound()) {
        this.needUpdate = true;
      }
    }
    onBingBound() {
      this.needUpdate = true;
    }
    onUpdated(time, elapsed) {
      if (!this.needUpdate) {
        return;
      }
      this.updatePositionRadius();
      this.needUpdate = false;
    }
    resetImgSrc() {
      this.bingRef.instance.resetImgSrc();
    }
    updatePositionRadius() {
      const center = this.props.mapProjection.getCenter();
      const radius = this.calculateDesiredRadius(this.props.mapProjection);
      this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
      if (!this.props.wxrMode || this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL) {
        this.rotationTransform.set(this.props.mapProjection.getRotation(), 1e-3);
      } else {
        this.rotationTransform.set(0);
      }
      this.wrapperStyle.set("transform", this.rotationTransform.resolve());
    }
    calculateDesiredRadius(mapProjection) {
      const scaleFactor = mapProjection.getScaleFactor();
      const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
      const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
      return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        "div",
        { style: this.wrapperStyle, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" },
        FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolution, mode: (_b = this.props.mode) !== null && _b !== void 0 ? _b : EBingMode.PLANE, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, reference: this.props.reference, wxrMode: this.props.wxrMode, wxrColors: this.props.wxrColors, isoLines: this.props.isoLines, delay: this.props.delay })
      );
    }
  };
  var MapCachedCanvasLayerReferenceClass = class {
    constructor() {
      this._center = new GeoPoint(0, 0);
      this._scaleFactor = 1;
      this._rotation = 0;
    }
    get center() {
      return this._center.readonly;
    }
    get scaleFactor() {
      return this._scaleFactor;
    }
    get rotation() {
      return this._rotation;
    }
    syncWithMapProjection(mapProjection) {
      this._center.set(mapProjection.getCenter());
      this._scaleFactor = mapProjection.getScaleFactor();
      this._rotation = mapProjection.getRotation();
    }
    syncWithReference(reference) {
      this._center.set(reference.center);
      this._scaleFactor = reference.scaleFactor;
      this._rotation = reference.rotation;
    }
  };
  var MapCachedCanvasLayerTransformClass = class {
    constructor() {
      this._scale = 0;
      this._rotation = 0;
      this._translation = new Float64Array(2);
      this._margin = 0;
      this._marginRemaining = 0;
    }
    get scale() {
      return this._scale;
    }
    get rotation() {
      return this._rotation;
    }
    get translation() {
      return this._translation;
    }
    get margin() {
      return this._margin;
    }
    get marginRemaining() {
      return this._marginRemaining;
    }
    update(mapProjection, reference, referenceMargin) {
      this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
      this._rotation = mapProjection.getRotation() - reference.rotation;
      mapProjection.project(reference.center, this._translation);
      Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
      this._margin = referenceMargin * this._scale;
      this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    copyFrom(other) {
      this._scale = other.scale;
      this._rotation = other.rotation;
      this._translation.set(other.translation);
      this._margin = other.margin;
    }
  };
  var MapCachedCanvasLayerCanvasInstanceClass = class extends MapCanvasLayerCanvasInstanceClass {
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
      super(canvas, context, isDisplayed);
      this.getReferenceMargin = getReferenceMargin;
      this._reference = new MapCachedCanvasLayerReferenceClass();
      this._transform = new MapCachedCanvasLayerTransformClass();
      this._isInvalid = false;
      this._geoProjection = new MercatorProjection();
      this.canvasTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(), CssTransformBuilder.translate("px"), CssTransformBuilder.rotate("rad")));
      this.canvasTransform.sub((transform) => {
        this.canvas.style.transform = transform;
      }, true);
    }
    get reference() {
      return this._reference;
    }
    get transform() {
      return this._transform;
    }
    get isInvalid() {
      return this._isInvalid;
    }
    get geoProjection() {
      return this._geoProjection;
    }
    syncWithMapProjection(mapProjection) {
      const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
      this._reference.syncWithMapProjection(mapProjection);
      this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      this._isInvalid = false;
      if (this.isDisplayed) {
        this.transformCanvasElement();
      }
    }
    syncWithCanvasInstance(other) {
      this._reference.syncWithReference(other.reference);
      this._geoProjection.copyParametersFrom(other.geoProjection);
      this._transform.copyFrom(other.transform);
      this._isInvalid = other.isInvalid;
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    updateTransform(mapProjection) {
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      if (!this._isInvalid) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
        this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || this._transform.marginRemaining < 0;
      }
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    transformCanvasElement() {
      const transform = this.transform;
      const offsetX = transform.translation[0] / transform.scale;
      const offsetY = transform.translation[1] / transform.scale;
      this.canvasTransform.transform.getChild(0).set(transform.scale, transform.scale, 1e-3);
      this.canvasTransform.transform.getChild(1).set(offsetX, offsetY, 0.1);
      this.canvasTransform.transform.getChild(2).set(transform.rotation, 1e-4);
      this.canvasTransform.resolve();
    }
    invalidate() {
      this._isInvalid = true;
      this.clear();
    }
  };
  MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
  MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
  var MapCachedCanvasLayer = class extends MapCanvasLayer {
    constructor(props) {
      super(props);
      this.size = 0;
      this.referenceMargin = 0;
      this.needUpdateTransforms = false;
      this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    getSize() {
      return this.size;
    }
    getReferenceMargin() {
      return this.referenceMargin;
    }
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      this.needUpdateTransforms = true;
    }
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    updateFromProjectedSize(projectedSize) {
      const projectedWidth = projectedSize[0];
      const projectedHeight = projectedSize[1];
      const diag = Math.hypot(projectedWidth, projectedHeight);
      this.size = diag * this.props.overdrawFactor;
      this.referenceMargin = (this.size - diag) / 2;
      this.setWidth(this.size);
      this.setHeight(this.size);
      const posX = (projectedWidth - this.size) / 2;
      const posY = (projectedHeight - this.size) / 2;
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = `${posX}px`;
      displayCanvas.style.top = `${posY}px`;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      var _a;
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
        this.display.invalidate();
        (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.invalidate();
      }
      this.needUpdateTransforms = true;
    }
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (!this.needUpdateTransforms) {
        return;
      }
      this.updateTransforms();
    }
    updateTransforms() {
      var _a;
      const mapProjection = this.props.mapProjection;
      this.display.updateTransform(mapProjection);
      (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.updateTransform(mapProjection);
      this.needUpdateTransforms = false;
    }
  };
  var MapLabeledRingLabelClass = class {
    constructor(content, wrapper) {
      this.content = content;
      this.wrapper = wrapper;
      this.center = new Float64Array(2);
      this.radius = 0;
      this.anchor = new Float64Array(2);
      this.radialAngle = 0;
      this.radialOffset = 0;
    }
    getAnchor() {
      return this.anchor;
    }
    getRadialAngle() {
      return this.radialAngle;
    }
    getRadialOffset() {
      return this.radialOffset;
    }
    setAnchor(anchor) {
      this.anchor.set(anchor);
      this.wrapper.style.transform = `translate(${-anchor[0] * 100}%, ${-anchor[1] * 100}%)`;
    }
    setRadialAngle(angle) {
      if (this.radialAngle === angle) {
        return;
      }
      this.radialAngle = angle;
      this.updatePosition();
    }
    setRadialOffset(offset) {
      if (this.radialOffset === offset) {
        return;
      }
      this.radialOffset = offset;
      this.updatePosition();
    }
    setRingPosition(center, radius) {
      if (Vec2Math.equals(this.center, center) && radius === this.radius) {
        return;
      }
      this.center.set(center);
      this.radius = radius;
      this.updatePosition();
    }
    updatePosition() {
      const pos = MapLabeledRingLabelClass.tempVec2_1;
      Vec2Math.setFromPolar(this.radius + this.radialOffset, this.radialAngle, pos);
      Vec2Math.add(this.center, pos, pos);
      this.wrapper.style.left = `${pos[0]}px`;
      this.wrapper.style.top = `${pos[1]}px`;
    }
  };
  MapLabeledRingLabelClass.tempVec2_1 = new Float64Array(2);
  var MapOwnAirplaneLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.imageFilePath = SubscribableUtils.isSubscribable(this.props.imageFilePath) ? this.props.imageFilePath.map(SubscribableMapFunctions.identity()) : this.props.imageFilePath;
      this.style = ObjectSubject.create({
        display: "",
        position: "absolute",
        left: "0px",
        top: "0px",
        width: "0px",
        height: "0px",
        transform: "translate3d(0, 0, 0) rotate(0deg)",
        "transform-origin": "50% 50%"
      });
      this.ownAirplanePropsModule = this.props.model.getModule("ownAirplaneProps");
      this.ownAirplaneIconModule = this.props.model.getModule("ownAirplaneIcon");
      this.iconSize = SubscribableUtils.toSubscribable(this.props.iconSize, true);
      this.iconAnchor = SubscribableUtils.toSubscribable(this.props.iconAnchor, true);
      this.iconOffset = Vec2Math.create();
      this.visibilityBounds = VecNMath.create(4);
      this.iconTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("deg"));
      this.isGsAboveTrackThreshold = this.ownAirplanePropsModule.groundSpeed.map((gs) => gs.asUnit(UnitType.KNOT) >= 5).pause();
      this.showIcon = true;
      this.isInsideVisibilityBounds = true;
      this.planeRotation = 0;
      this.needUpdateVisibility = false;
      this.needUpdatePositionRotation = false;
    }
    onVisibilityChanged(isVisible) {
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    onAttached() {
      this.showSub = this.ownAirplaneIconModule.show.sub((show) => {
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = this.showIcon = show && this.isVisible();
      });
      this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
        this.needUpdatePositionRotation = this.showIcon;
      });
      this.headingSub = this.ownAirplanePropsModule.hdgTrue.sub((hdg) => {
        this.planeRotation = hdg;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackSub = this.ownAirplanePropsModule.trackTrue.sub((track) => {
        this.planeRotation = track;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackThresholdSub = this.isGsAboveTrackThreshold.sub((isAboveThreshold) => {
        if (isAboveThreshold) {
          this.headingSub.pause();
          this.trackSub.resume(true);
        } else {
          this.trackSub.pause();
          this.headingSub.resume(true);
        }
      }, false, true);
      this.iconSizeSub = this.iconSize.sub((size) => {
        this.style.set("width", `${size}px`);
        this.style.set("height", `${size}px`);
        this.updateOffset();
      }, true);
      this.iconAnchorSub = this.iconAnchor.sub(() => {
        this.updateOffset();
      });
      this.orientationSub = this.ownAirplaneIconModule.orientation.sub((orientation) => {
        switch (orientation) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.trackSub.pause();
            this.headingSub.resume(true);
            break;
          case MapOwnAirplaneIconOrientation.TrackUp:
            this.headingSub.pause();
            this.trackSub.pause();
            this.isGsAboveTrackThreshold.resume();
            this.trackThresholdSub.resume(true);
            break;
          default:
            this.needUpdatePositionRotation = this.showIcon;
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.headingSub.pause();
            this.trackSub.pause();
            this.planeRotation = 0;
        }
      }, true);
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = true;
    }
    updateOffset() {
      const anchor = this.iconAnchor.get();
      this.iconOffset.set(anchor);
      Vec2Math.multScalar(this.iconOffset, -this.iconSize.get(), this.iconOffset);
      this.style.set("left", `${this.iconOffset[0]}px`);
      this.style.set("top", `${this.iconOffset[1]}px`);
      this.style.set("transform-origin", `${anchor[0] * 100}% ${anchor[1] * 100}%`);
      this.updateVisibilityBounds();
    }
    updateVisibilityBounds() {
      const size = this.iconSize.get();
      const maxProtrusion = Math.max(
        Math.hypot(this.iconOffset[0], this.iconOffset[1]),
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1]),
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1] + size),
        Math.hypot(this.iconOffset[0], this.iconOffset[1] + size)
      );
      const boundsOffset = maxProtrusion + 50;
      const projectedSize = this.props.mapProjection.getProjectedSize();
      this.visibilityBounds[0] = -boundsOffset;
      this.visibilityBounds[1] = -boundsOffset;
      this.visibilityBounds[2] = projectedSize[0] + boundsOffset;
      this.visibilityBounds[3] = projectedSize[1] + boundsOffset;
      this.needUpdatePositionRotation = this.showIcon;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateVisibilityBounds();
      }
      this.needUpdatePositionRotation = this.showIcon;
    }
    onUpdated(time, elapsed) {
      if (this.needUpdatePositionRotation) {
        this.updateIconPositionRotation();
        this.needUpdatePositionRotation = false;
        this.needUpdateVisibility = false;
      } else if (this.needUpdateVisibility) {
        this.updateIconVisibility();
        this.needUpdateVisibility = false;
      }
    }
    updateIconVisibility() {
      this.style.set("display", this.isInsideVisibilityBounds && this.showIcon ? "" : "none");
    }
    updateIconPositionRotation() {
      const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.vec2Cache[0]);
      this.isInsideVisibilityBounds = this.props.mapProjection.isInProjectedBounds(projected, this.visibilityBounds);
      if (this.isInsideVisibilityBounds) {
        let rotation;
        switch (this.ownAirplaneIconModule.orientation.get()) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
          case MapOwnAirplaneIconOrientation.TrackUp:
            rotation = this.planeRotation + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
            break;
          default:
            rotation = 0;
        }
        this.iconTransform.getChild(0).set(projected[0], projected[1], 0, 0.1);
        this.iconTransform.getChild(1).set(rotation, 0.1);
        this.style.set("transform", this.iconTransform.resolve());
      }
      this.updateIconVisibility();
    }
    render() {
      var _a;
      return FSComponent.buildComponent("img", { src: this.imageFilePath, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: this.style });
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (SubscribableUtils.isSubscribable(this.imageFilePath)) {
        this.imageFilePath.destroy();
      }
      this.isGsAboveTrackThreshold.destroy();
      (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.headingSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.trackSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.trackThresholdSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.iconSizeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.iconAnchorSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.orientationSub) === null || _h === void 0 ? void 0 : _h.destroy();
      super.destroy();
    }
  };
  MapOwnAirplaneLayer.vec2Cache = [Vec2Math.create()];
  var MapCullableTextLayer = class extends MapSyncedCanvasLayer {
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      this.props.manager.update(this.props.mapProjection);
      this.redrawLabels();
    }
    redrawLabels() {
      const labels = this.props.manager.visibleLabels;
      const display = this.display;
      display.clear();
      for (let i = labels.length - 1; i >= 0; i--) {
        labels[i].draw(display.context, this.props.mapProjection);
      }
    }
  };
  var MapAirspaceLayer = class extends MapLayer {
    constructor() {
      var _a, _b;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
        this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
        this.isAttached && this.scheduleSearch(0, true);
      });
      this.searchedAirspaces = /* @__PURE__ */ new Map();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
      this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
      this.activeRenderProcess = null;
      this.renderTaskQueueHandler = {
        renderTimeBudget: this.renderTimeBudget,
        onStarted() {
        },
        canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
          return timeElapsed < this.renderTimeBudget;
        },
        onPaused: this.onRenderPaused.bind(this),
        onFinished: this.onRenderFinished.bind(this),
        onAborted: this.onRenderAborted.bind(this)
      };
      this.searchDebounceTimer = 0;
      this.isSearchScheduled = false;
      this.needRefilter = false;
      this.isSearchBusy = false;
      this.lastDesiredSearchRadius = 0;
      this.lastSearchRadius = 0;
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
      this.isDisplayInvalidated = true;
      this.isAttached = false;
    }
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      this.updateClipBounds();
      this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
      this.props.maxSearchRadius.sub((radius) => {
        const radiusMeters = radius.asUnit(UnitType.METER);
        if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
          this.scheduleSearch(0, false);
        }
      });
      this.props.maxSearchItemCount.sub(() => {
        this.scheduleSearch(0, false);
      });
      this.initModuleListeners();
      this.isAttached = true;
      this.searchSession && this.scheduleSearch(0, true);
    }
    initModuleListeners() {
      const airspaceModule = this.props.model.getModule("airspace");
      for (const type of Object.values(airspaceModule.show)) {
        type.sub(this.onAirspaceTypeShowChanged.bind(this));
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateClipBounds();
      }
    }
    updateClipBounds() {
      const size = this.canvasLayerRef.instance.getSize();
      this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    scheduleSearch(delay, refilter) {
      if (!this.searchSession) {
        return;
      }
      this.searchDebounceTimer = delay;
      this.isSearchScheduled = true;
      this.needRefilter || (this.needRefilter = refilter);
    }
    scheduleRender() {
      this.isRenderScheduled = true;
    }
    async searchAirspaces(refilter) {
      this.isSearchBusy = true;
      const center = this.props.mapProjection.getCenter();
      const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
      this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
      this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
      const session = this.searchSession;
      refilter && session.setFilter(this.getBoundaryFilter());
      const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
      for (let i = 0; i < results.added.length; i++) {
        const airspace = results.added[i];
        this.searchedAirspaces.set(airspace.facility.id, airspace);
      }
      for (let i = 0; i < results.removed.length; i++) {
        this.searchedAirspaces.delete(results.removed[i]);
      }
      this.isSearchBusy = false;
      this.scheduleRender();
    }
    getBoundaryFilter() {
      const module2 = this.props.model.getModule("airspace");
      const show = module2.show;
      let filter = 0;
      for (const type in show) {
        if (show[type].get()) {
          filter |= module2.showTypes[type];
        }
      }
      return filter;
    }
    onUpdated(time, elapsed) {
      this.canvasLayerRef.instance.onUpdated(time, elapsed);
      this.updateFromInvalidation();
      this.updateScheduledRender();
      this.updateScheduledSearch(elapsed);
    }
    updateFromInvalidation() {
      const canvasLayer = this.canvasLayerRef.instance;
      const display = canvasLayer.display;
      const buffer = canvasLayer.buffer;
      const needBackgroundRender = !this.isBackgroundRenderScheduled && !this.activeRenderProcess && display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD;
      const shouldScheduleSearch = needBackgroundRender || display.isInvalid || buffer.isInvalid && this.activeRenderProcess;
      this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
      if (display.isInvalid) {
        this.isDisplayInvalidated = true;
        this.isBackgroundRenderScheduled = false;
        display.clear();
        display.syncWithMapProjection(this.props.mapProjection);
      }
      if (buffer.isInvalid) {
        if (this.activeRenderProcess) {
          this.activeRenderProcess.abort();
          this.cleanUpRender();
        }
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
      }
      if (shouldScheduleSearch) {
        this.scheduleSearch(this.searchDebounceDelay, false);
      }
    }
    updateScheduledSearch(elapsed) {
      if (!this.isSearchScheduled) {
        return;
      }
      this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
      if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
        this.searchAirspaces(this.needRefilter);
        this.isSearchScheduled = false;
        this.needRefilter = false;
      }
    }
    updateScheduledRender() {
      if (!this.isRenderScheduled) {
        return;
      }
      this.startRenderProcess();
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
    }
    startRenderProcess() {
      const canvasLayer = this.canvasLayerRef.instance;
      if (this.activeRenderProcess) {
        this.activeRenderProcess.abort();
      }
      const buffer = canvasLayer.buffer;
      buffer.clear();
      buffer.syncWithMapProjection(this.props.mapProjection);
      this.props.airspaceRenderManager.clearRegisteredAirspaces();
      for (const airspace of this.searchedAirspaces.values()) {
        if (this.isAirspaceInBounds(airspace, buffer)) {
          this.props.airspaceRenderManager.registerAirspace(airspace);
        }
      }
      const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
      this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
      this.activeRenderProcess.start();
    }
    isAirspaceInBounds(airspace, canvas) {
      const corner = MapAirspaceLayer.geoPointCache[0];
      const cornerProjected = MapAirspaceLayer.vec2Cache[0];
      let minX, maxX, minY, maxY;
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = maxX = cornerProjected[0];
      minY = maxY = cornerProjected[1];
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      const width = canvas.canvas.width;
      const height = canvas.canvas.height;
      return minX < width && maxX > 0 && minY < height && maxY > 0;
    }
    selectLod(resolution) {
      const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
      let i = thresholds.length - 1;
      while (i >= 0) {
        if (resolution * 2 >= thresholds[i]) {
          break;
        }
        i--;
      }
      return i;
    }
    cleanUpRender() {
      this.canvasLayerRef.instance.buffer.reset();
      this.activeRenderProcess = null;
    }
    renderAirspacesToDisplay() {
      const display = this.canvasLayerRef.instance.display;
      const buffer = this.canvasLayerRef.instance.buffer;
      display.clear();
      display.syncWithCanvasInstance(buffer);
      this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    onRenderPaused() {
      if (this.isDisplayInvalidated) {
        this.renderAirspacesToDisplay();
      }
    }
    onRenderFinished() {
      this.renderAirspacesToDisplay();
      this.cleanUpRender();
      this.isDisplayInvalidated = false;
    }
    onRenderAborted() {
      this.cleanUpRender();
    }
    onAirspaceTypeShowChanged() {
      this.scheduleSearch(0, true);
    }
    render() {
      return FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 });
    }
  };
  MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500;
  MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2;
  MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1;
  MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10;
  MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
  MapAirspaceLayer.vec2Cache = [new Float64Array(2)];
  var MapNearestWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
      this.searchRadius = 0;
      this.searchMargin = 0;
      this.userFacilityHasChanged = false;
      this.icaosToRender = /* @__PURE__ */ new Set();
      this.cachedRenderedWaypoints = /* @__PURE__ */ new Map();
      this.isInit = false;
      this.facilityRepoSubs = [];
    }
    onFacilityLoaderInitialized() {
      Promise.all([
        this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),
        this.facLoader.startNearestSearchSession(FacilitySearchType.User)
      ]).then((value) => {
        const [airportSession, vorSession, ndbSession, intSession, userSession] = value;
        this.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      });
    }
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession) {
      const callback = this.processSearchResults.bind(this);
      this.facilitySearches = {
        [FacilitySearchType.Airport]: new MapNearestWaypointsLayerSearch(airportSession, callback),
        [FacilitySearchType.Vor]: new MapNearestWaypointsLayerSearch(vorSession, callback),
        [FacilitySearchType.Ndb]: new MapNearestWaypointsLayerSearch(ndbSession, callback),
        [FacilitySearchType.Intersection]: new MapNearestWaypointsLayerSearch(intSession, callback),
        [FacilitySearchType.User]: new MapNearestWaypointsLayerSearch(userSession, callback)
      };
      const sub = this.props.bus.getSubscriber();
      this.facilityRepoSubs.push(sub.on("facility_added").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub.on("facility_changed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub.on("facility_removed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }));
      this.props.onSessionsStarted && this.props.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      if (this.isInit) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    onAttached() {
      super.onAttached();
      this.canvasLayerRef.instance.onAttached();
      this.doInit();
      this.isInit = true;
      this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    doInit() {
      this.initWaypointRenderer();
      this.updateSearchRadius();
    }
    getSearchCenter() {
      return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    initWaypointRenderer() {
      this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    refreshWaypoints() {
      this.tryRefreshAllSearches(void 0, void 0, true);
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.deregisterWaypoint(w, this.props.waypointRenderer);
      });
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.registerWaypoint(w, this.props.waypointRenderer);
      });
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
        this.updateSearchRadius();
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      } else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    updateSearchRadius() {
      let mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
      mapHalfDiagRange = Math.max(mapHalfDiagRange, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
      this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
      this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    onUpdated(time, elapsed) {
      var _a;
      if (this.userFacilityHasChanged) {
        const search = (_a = this.facilitySearches) === null || _a === void 0 ? void 0 : _a[FacilitySearchType.User];
        if (search !== void 0) {
          this.userFacilityHasChanged = false;
          this.scheduleSearchRefresh(FacilitySearchType.User, search, this.getSearchCenter(), this.searchRadius);
        }
      }
      this.updateSearches(elapsed);
    }
    updateSearches(elapsed) {
      if (!this.facilitySearches) {
        return;
      }
      this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
      this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
      this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
      this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
      this.facilitySearches[FacilitySearchType.User].update(elapsed);
    }
    tryRefreshAllSearches(center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshAllSearches(center, radius, force);
    }
    tryRefreshSearch(type, center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshSearch(type, center, radius, force);
    }
    _tryRefreshAllSearches(center, radius, force) {
      this._tryRefreshSearch(FacilitySearchType.Airport, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Vor, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.User, center, radius, force);
    }
    _tryRefreshSearch(type, center, radius, force) {
      const search = this.facilitySearches && this.facilitySearches[type];
      if (!search || !force && !this.shouldRefreshSearch(type, center, radius)) {
        return;
      }
      const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : void 0;
      if (radiusLimit !== void 0 && isFinite(radiusLimit)) {
        radius = Math.min(radius, Math.max(0, radiusLimit));
      }
      if (force || search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
        this.scheduleSearchRefresh(type, search, center, radius);
      }
    }
    shouldRefreshSearch(type, center, radius) {
      return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    scheduleSearchRefresh(type, search, center, radius) {
      const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
      search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    processSearchResults(results) {
      if (!results) {
        return;
      }
      const numAdded = results.added.length;
      for (let i = 0; i < numAdded; i++) {
        const icao = results.added[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.registerIcao(icao);
      }
      const numRemoved = results.removed.length;
      for (let i = 0; i < numRemoved; i++) {
        const icao = results.removed[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.deregisterIcao(icao);
      }
    }
    async registerIcao(icao) {
      this.icaosToRender.add(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (!this.icaosToRender.has(icao)) {
          return;
        }
        this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
      }
    }
    registerWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.set(facility.icao, waypoint);
      this.props.registerWaypoint(waypoint, renderer);
    }
    async deregisterIcao(icao) {
      this.icaosToRender.delete(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (this.icaosToRender.has(icao)) {
          return;
        }
        this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
        if (this.icaosToRender.has(icao)) {
          return;
        }
        const cachedWaypoint = this.cachedRenderedWaypoints.get(icao);
        if (cachedWaypoint !== void 0) {
          this.cachedRenderedWaypoints.delete(icao);
          this.props.deregisterWaypoint(cachedWaypoint, this.props.waypointRenderer);
        }
      }
    }
    deregisterWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.delete(facility.icao);
      this.props.deregisterWaypoint(waypoint, renderer);
    }
    setVisible(val) {
      super.setVisible(val);
      this.canvasLayerRef.instance.setVisible(val);
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.facilityRepoSubs.forEach((sub) => {
        sub.destroy();
      });
      super.destroy();
    }
  };
  MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
  var MapNearestWaypointsLayerSearch = class {
    constructor(session, refreshCallback) {
      this.session = session;
      this.refreshCallback = refreshCallback;
      this._lastCenter = new GeoPoint(0, 0);
      this._lastRadius = 0;
      this.maxItemCount = 0;
      this.refreshDebounceTimer = 0;
      this.isRefreshScheduled = false;
    }
    get lastCenter() {
      return this._lastCenter.readonly;
    }
    get lastRadius() {
      return this._lastRadius;
    }
    scheduleRefresh(center, radius, maxItemCount, delay) {
      this._lastCenter.set(center);
      this._lastRadius = radius;
      this.maxItemCount = maxItemCount;
      if (!this.isRefreshScheduled) {
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
      }
    }
    update(elapsed) {
      if (!this.isRefreshScheduled) {
        return;
      }
      this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
      if (this.refreshDebounceTimer === 0) {
        this.refresh();
        this.isRefreshScheduled = false;
      }
    }
    async refresh() {
      const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
      this.refreshCallback(results);
    }
  };
  var MapLineLayer = class extends MapSyncedCanvasLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(...arguments);
      this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapLineLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapLineLayer.DEFAULT_STROKE_STYLE;
      this.strokeDash = (_c = this.props.strokeDash) !== null && _c !== void 0 ? _c : MapLineLayer.DEFAULT_STROKE_DASH;
      this.outlineWidth = (_d = this.props.outlineWidth) !== null && _d !== void 0 ? _d : MapLineLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_e = this.props.outlineStyle) !== null && _e !== void 0 ? _e : MapLineLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineDash = (_f = this.props.outlineDash) !== null && _f !== void 0 ? _f : MapLineLayer.DEFAULT_OUTLINE_DASH;
      this.vec = new Float64Array([0, 0]);
      this.isUpdateScheduled = false;
    }
    onAttached() {
      super.onAttached();
      this.props.start.sub(() => {
        this.scheduleUpdate();
      });
      this.props.end.sub(() => {
        this.scheduleUpdate();
      });
      this.scheduleUpdate();
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.scheduleUpdate();
    }
    scheduleUpdate() {
      this.isUpdateScheduled = true;
    }
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (this.isUpdateScheduled) {
        this.display.clear();
        const start = this.props.start.get();
        const end = this.props.end.get();
        if (start !== null && end !== null) {
          const [x1, y1] = start instanceof Float64Array ? start : this.props.mapProjection.project(start, this.vec);
          const [x2, y2] = end instanceof Float64Array ? end : this.props.mapProjection.project(end, this.vec);
          this.drawLine(x1, y1, x2, y2);
        }
        this.isUpdateScheduled = false;
      }
    }
    drawLine(x1, y1, x2, y2) {
      const context = this.display.context;
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      if (this.outlineWidth > 0) {
        this.stroke(context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
      }
      if (this.strokeWidth > 0) {
        this.stroke(context, this.strokeWidth, this.strokeStyle, this.strokeDash);
      }
    }
    stroke(context, width, style, dash) {
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash);
      context.stroke();
    }
  };
  MapLineLayer.DEFAULT_STROKE_WIDTH = 2;
  MapLineLayer.DEFAULT_STROKE_STYLE = "white";
  MapLineLayer.DEFAULT_STROKE_DASH = [];
  MapLineLayer.DEFAULT_OUTLINE_WIDTH = 0;
  MapLineLayer.DEFAULT_OUTLINE_STYLE = "black";
  MapLineLayer.DEFAULT_OUTLINE_DASH = [];
  var MapSystemController = class {
    constructor(context) {
      this._isAlive = true;
      this.context = context;
    }
    get isAlive() {
      return this._isAlive;
    }
    onAfterMapRender(ref) {
    }
    onDeadZoneChanged(deadZone) {
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    onBeforeUpdated(time, elapsed) {
    }
    onAfterUpdated(time, elapsed) {
    }
    onWake() {
    }
    onSleep() {
    }
    onMapDestroyed() {
    }
    destroy() {
      this._isAlive = false;
    }
  };
  var MapBindingsController = class extends MapSystemController {
    constructor(context, bindings, onDestroy) {
      super(context);
      this.bindings = bindings;
      this.onDestroy = onDestroy;
      this.maps = [];
      this.pipes = [];
    }
    onAfterMapRender() {
      for (const binding of this.bindings) {
        if ("map" in binding) {
          if ("sources" in binding) {
            const map = MappedSubject.create(...binding.sources);
            this.maps.push(map);
            this.pipes.push(map.pipe(binding.target, binding.map));
          } else {
            this.pipes.push(binding.source.pipe(binding.target, binding.map));
          }
        } else {
          this.pipes.push(binding.source.pipe(binding.target));
        }
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    onWake() {
      this.maps.forEach((map) => {
        map.resume();
      });
      this.pipes.forEach((pipe) => {
        pipe.resume(true);
      });
    }
    onSleep() {
      this.maps.forEach((map) => {
        map.pause();
      });
      this.pipes.forEach((pipe) => {
        pipe.pause();
      });
    }
    destroy() {
      this.onDestroy && this.onDestroy();
      this.maps.forEach((map) => {
        map.destroy();
      });
      this.pipes.forEach((pipe) => {
        pipe.destroy();
      });
      super.destroy();
    }
  };
  var MapClockUpdateController = class extends MapSystemController {
    onAfterMapRender(ref) {
      this.freqSub = this.context.updateFreq.sub((freq) => {
        var _a;
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.clockSub = this.context.bus.getSubscriber().on("realTime").atFrequency(freq).handle((realTime) => {
          ref.update(realTime);
        });
      }, true);
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var MapFlightPlanController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
      this.planCopiedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
      };
      this.planCreatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
      };
      this.planDeletedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(void 0);
      };
      this.planChangeHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
      };
      this.planCalculatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
      };
      this.activeLegChangedHandler = (evt) => {
        if (evt.type === ActiveLegType.Lateral) {
          this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.index);
        }
      };
    }
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      this.fplCopiedSub = sub.on("fplCopied").handle(this.planCopiedHandler);
      this.fplCreatedSub = sub.on("fplCreated").handle(this.planCreatedHandler);
      this.fplDeletedSub = sub.on("fplDeleted").handle(this.planDeletedHandler);
      this.fplDirectToDataChangedSub = sub.on("fplDirectToDataChanged").handle(this.planChangeHandler);
      this.fplLoadedSub = sub.on("fplLoaded").handle(this.planCreatedHandler);
      this.fplOriginDestChangedSub = sub.on("fplOriginDestChanged").handle(this.planChangeHandler);
      this.fplProcDetailsChangedSub = sub.on("fplProcDetailsChanged").handle(this.planChangeHandler);
      this.fplSegmentChangeSub = sub.on("fplSegmentChange").handle(this.planChangeHandler);
      this.fplUserDataDeleteSub = sub.on("fplUserDataDelete").handle(this.planChangeHandler);
      this.fplUserDataSetSub = sub.on("fplUserDataSet").handle(this.planChangeHandler);
      this.fplActiveLegChangeSub = sub.on("fplActiveLegChange").handle(this.activeLegChangedHandler);
      this.fplCalculatedSub = sub.on("fplCalculated").handle(this.planCalculatedHandler);
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      super.destroy();
      (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
      (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
      (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
  };
  var MapFollowAirplaneController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
      this.mapProjectionParams = {
        target: new GeoPoint(0, 0)
      };
      this.targetControl = this.context[MapSystemKeys.TargetControl];
      this.targetControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.isFollowingAirplane.set(true);
        },
        onCeded: () => {
          this.isFollowingAirplane.set(false);
        }
      };
    }
    onAfterMapRender() {
      this.targetControl.claim(this.targetControlConsumer);
    }
    onBeforeUpdated() {
      if (this.isFollowingAirplane.get()) {
        this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
        this.context.projection.setQueued(this.mapProjectionParams);
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      super.destroy();
      this.targetControl.forfeit(this.targetControlConsumer);
    }
  };
  var MapRotation;
  (function(MapRotation2) {
    MapRotation2["Undefined"] = "Undefined";
    MapRotation2["NorthUp"] = "NorthUp";
    MapRotation2["TrackUp"] = "TrackUp";
    MapRotation2["HeadingUp"] = "HeadingUp";
    MapRotation2["DtkUp"] = "DtkUp";
  })(MapRotation || (MapRotation = {}));
  var MapRotationModule = class {
    constructor() {
      this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
  };
  var MapOwnAirplaneIconOrientationController = class extends MapSystemController {
    constructor(context, desiredOrientation) {
      super(context);
      this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
      this.needUpdateIconOrientation = false;
      this.desiredIconOrientation = SubscribableUtils.toSubscribable(desiredOrientation, true);
      this.orientationState = MappedSubject.create(this.desiredIconOrientation, this.context.model.getModule(MapSystemKeys.Rotation).rotationType);
    }
    onAfterMapRender() {
      var _a;
      (_a = this.orientationState) === null || _a === void 0 ? void 0 : _a.sub(() => {
        this.needUpdateIconOrientation = true;
      }, true);
    }
    onBeforeUpdated() {
      if (this.needUpdateIconOrientation) {
        const [desiredOrientation, rotation] = this.orientationState.get();
        if (desiredOrientation === MapOwnAirplaneIconOrientation.HeadingUp && rotation === MapRotation.HeadingUp || desiredOrientation === MapOwnAirplaneIconOrientation.TrackUp && rotation === MapRotation.TrackUp) {
          this.ownAirplaneIconModule.orientation.set(MapOwnAirplaneIconOrientation.MapUp);
        } else {
          this.ownAirplaneIconModule.orientation.set(desiredOrientation);
        }
        this.needUpdateIconOrientation = false;
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      this.orientationState.destroy();
      super.destroy();
    }
  };
  var MapOwnAirplanePropsController = class extends MapSystemController {
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.subs = {};
    }
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      this.updateFreqSub = this.updateFreq.sub((freq) => {
        var _a;
        for (const property of this.properties) {
          (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
          this.subs[property] = this.bindProperty(sub, property, freq);
        }
      }, true);
    }
    bindProperty(sub, property, updateFreq) {
      switch (property) {
        case "position":
          return sub.on("gps-position").atFrequency(updateFreq).handle((lla) => {
            this.module.position.set(lla.lat, lla.long);
          });
        case "altitude":
          return sub.on("indicated_alt").atFrequency(updateFreq).handle((alt) => {
            this.module.altitude.set(alt, UnitType.FOOT);
          });
        case "groundSpeed":
          return sub.on("ground_speed").atFrequency(updateFreq).handle((gs) => {
            this.module.groundSpeed.set(gs, UnitType.KNOT);
          });
        case "hdgTrue":
          return sub.on("hdg_deg_true").atFrequency(updateFreq).handle((hdg) => {
            this.module.hdgTrue.set(hdg);
          });
        case "trackTrue":
          return sub.on("track_deg_true").atFrequency(updateFreq).handle((track) => {
            this.module.trackTrue.set(track);
          });
        case "verticalSpeed":
          return sub.on("vertical_speed").atFrequency(updateFreq).handle((vs) => {
            this.module.verticalSpeed.set(vs, UnitType.FPM);
          });
        case "turnRate":
          return sub.on("delta_heading_rate").atFrequency(updateFreq).handle((turnRate) => {
            this.module.turnRate.set(turnRate);
          });
        case "isOnGround":
          return sub.on("on_ground").atFrequency(updateFreq).handle((isOnGround) => {
            this.module.isOnGround.set(isOnGround);
          });
        case "magVar":
          return sub.on("magvar").atFrequency(updateFreq).handle((magVar) => {
            this.module.magVar.set(magVar);
          });
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapRotationController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.rotationParam = {
        rotation: 0
      };
      this.hasRotationControl = false;
      this.rotationControl = this.context[MapSystemKeys.RotationControl];
      this.rotationControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.hasRotationControl = true;
        },
        onCeded: () => {
          this.hasRotationControl = false;
        }
      };
      this.rotationFuncs = {
        [MapRotation.NorthUp]: () => 0,
        [MapRotation.HeadingUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.TrackUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => this.ownAirplanePropsModule.groundSpeed.get().asUnit(UnitType.KNOT) < 5 ? -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD : -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.DtkUp]: () => 0
      };
    }
    onAfterMapRender() {
      this.rotationSub = this.rotationModule.rotationType.sub((type) => {
        this.rotationFunc = this.rotationFuncs[type];
      }, true);
      this.rotationControl.claim(this.rotationControlConsumer);
    }
    onBeforeUpdated() {
      if (this.hasRotationControl && this.rotationFunc !== void 0) {
        this.rotationParam.rotation = this.rotationFunc();
        this.context.projection.setQueued(this.rotationParam);
      }
    }
    onMapDestroyed() {
      super.onMapDestroyed();
      this.destroy();
    }
    destroy() {
      var _a;
      super.destroy();
      (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.rotationControl.forfeit(this.rotationControlConsumer);
    }
  };
  var MapSystemWaypointRoles;
  (function(MapSystemWaypointRoles2) {
    MapSystemWaypointRoles2["Normal"] = "Normal";
    MapSystemWaypointRoles2["FlightPlan"] = "FlightPlan";
  })(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));
  var MapSystemFlightPlanLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.instanceId = MapSystemFlightPlanLayer.instanceId++;
      this.flightPathLayerRef = FSComponent.createRef();
      this.waypointLayerRef = FSComponent.createRef();
      this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
      this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
      this.waypointPrefix = `${MapSystemFlightPlanLayer.WAYPOINT_PREFIX}_${this.instanceId}`;
      this.legWaypoints = /* @__PURE__ */ new Map();
      this.waypointsUpdating = false;
      this.waypointId = 0;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
      this.facWaypointCache = DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.clipBounds = VecNSubject.create(new Float64Array(4));
      this.clippedPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.clipBounds);
      this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
      this.updateScheduled = false;
    }
    onAttached() {
      this.flightPathLayerRef.instance.onAttached();
      this.waypointLayerRef.instance.onAttached();
      this.pathStreamStack.pushPostProjected(this.clippedPathStream);
      this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
      this.initWaypointRenderer();
      this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
      this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
      super.onAttached();
    }
    initWaypointRenderer() {
      let hasDefaultRole = false;
      const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
      for (let i = 0; i < flightPlanRoles.length; i++) {
        const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
        if (roleId !== void 0) {
          this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
          this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
          this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
          if (!hasDefaultRole) {
            this.props.flightPathRenderer.defaultRoleId = roleId;
            hasDefaultRole = true;
          }
        }
      }
    }
    onUpdated(time, elapsed) {
      this.flightPathLayerRef.instance.onUpdated(time, elapsed);
      this.waypointLayerRef.instance.onUpdated(time, elapsed);
      if (this.isVisible()) {
        const display = this.flightPathLayerRef.instance.display;
        if (display.isInvalid) {
          display.clear();
          display.syncWithMapProjection(this.props.mapProjection);
          this.updateScheduled = true;
        }
        if (this.updateScheduled) {
          if (!this.waypointsUpdating) {
            this.updateWaypoints();
          }
          const context = display.context;
          display.clear();
          const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
          if (plan !== void 0) {
            this.pathStreamStack.setProjection(display.geoProjection);
            this.props.flightPathRenderer.render(plan, void 0, void 0, context, this.pathStreamStack);
          }
          this.updateScheduled = false;
        }
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      const size = this.flightPathLayerRef.instance.getSize();
      this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);
    }
    setVisible(val) {
      super.setVisible(val);
      this.waypointLayerRef.instance.setVisible(val);
      this.flightPathLayerRef.instance.setVisible(val);
    }
    async updateWaypoints() {
      if (this.waypointsUpdating) {
        throw new Error("A flight plan waypoint update is already in progress.");
      }
      this.waypointsUpdating = true;
      const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
      const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
      if (flightPlan === void 0) {
        for (const legWaypoint of this.legWaypoints.values()) {
          const [waypoint, roleId] = legWaypoint;
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
        this.legWaypoints.clear();
        this.waypointsUpdating = false;
        return;
      }
      const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
      const legsToDisplay = /* @__PURE__ */ new Map();
      let legIndex = 0;
      for (const leg of flightPlan.legs()) {
        let roleId = this.defaultRoleId;
        const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
        if (handler !== void 0) {
          roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
        }
        if (roleId !== 0) {
          legsToDisplay.set(leg, roleId);
        }
        legIndex++;
      }
      for (const leg of this.legWaypoints) {
        const [legDefinition, legWaypoint] = leg;
        const [waypoint, roleId] = legWaypoint;
        if (!legsToDisplay.has(legDefinition)) {
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.delete(legDefinition);
        }
      }
      const waypointRefreshes = [];
      for (const leg of legsToDisplay) {
        waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
      }
      await Promise.all(waypointRefreshes);
      this.waypointsUpdating = false;
    }
    async buildPlanWaypoint(leg, roleId) {
      switch (leg.leg.type) {
        case LegType.CD:
        case LegType.VD:
        case LegType.CR:
        case LegType.VR:
        case LegType.FC:
        case LegType.FD:
        case LegType.FA:
        case LegType.CA:
        case LegType.VA:
        case LegType.FM:
        case LegType.VM:
        case LegType.CI:
        case LegType.VI:
          await this.buildTerminatorWaypoint(leg, roleId);
          break;
        case LegType.Discontinuity:
        case LegType.ThruDiscontinuity:
          break;
        default:
          await this.buildFixWaypoint(leg, roleId);
          break;
      }
    }
    async buildTerminatorWaypoint(leg, roleId) {
      var _a, _b, _c, _d, _e, _f;
      const currentLeg = this.legWaypoints.get(leg);
      if (currentLeg !== void 0) {
        const [waypoint, currentRoleId] = currentLeg;
        const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
        if (lastVector !== void 0) {
          if (!waypoint.location.get().equals(lastVector.endLat, lastVector.endLon)) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            const ident = (_c = leg.name) !== null && _c !== void 0 ? _c : "";
            const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
            this.legWaypoints.set(leg, [newWaypoint, roleId]);
            this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          } else if (currentRoleId !== roleId) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            this.legWaypoints.set(leg, [waypoint, roleId]);
          }
        } else {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
        }
      } else {
        const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
        if (lastVector !== void 0) {
          const ident = (_f = leg.name) !== null && _f !== void 0 ? _f : "";
          const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
      }
    }
    async buildFixWaypoint(leg, roleId) {
      var _a;
      const legWaypoint = this.legWaypoints.get(leg);
      if (legWaypoint === void 0) {
        const facIcao = leg.leg.fixIcao;
        let facility;
        try {
          facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
        } catch (err) {
        }
        if (facility !== void 0) {
          const waypoint = this.facWaypointCache.get(facility);
          const ident = (_a = leg.name) !== null && _a !== void 0 ? _a : "";
          const newWaypoint = new FlightPathWaypoint(waypoint.location, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
        }
      } else {
        const [waypoint, currentRoleId] = legWaypoint;
        if (currentRoleId !== roleId) {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
          this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [waypoint, roleId]);
        }
      }
    }
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        FSComponent.Fragment,
        null,
        FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, overdrawFactor: Math.SQRT2, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }),
        FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_b = this.props.class) !== null && _b !== void 0 ? _b : "" })
      );
    }
  };
  MapSystemFlightPlanLayer.WAYPOINT_PREFIX = "MapSystemFplLayer";
  MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10;
  MapSystemFlightPlanLayer.instanceId = 0;
  var AdsbOperatingMode;
  (function(AdsbOperatingMode2) {
    AdsbOperatingMode2["Standby"] = "Standby";
    AdsbOperatingMode2["Surface"] = "Surface";
    AdsbOperatingMode2["Airborne"] = "Airborne";
  })(AdsbOperatingMode || (AdsbOperatingMode = {}));
  var TcasOperatingMode;
  (function(TcasOperatingMode2) {
    TcasOperatingMode2["Off"] = "Off";
    TcasOperatingMode2["Standby"] = "Standby";
    TcasOperatingMode2["TAOnly"] = "TAOnly";
    TcasOperatingMode2["TA_RA"] = "TA/RA";
    TcasOperatingMode2["Test"] = "Test";
    TcasOperatingMode2["Failed"] = "Failed";
  })(TcasOperatingMode || (TcasOperatingMode = {}));
  var TcasAlertLevel;
  (function(TcasAlertLevel2) {
    TcasAlertLevel2[TcasAlertLevel2["None"] = 0] = "None";
    TcasAlertLevel2[TcasAlertLevel2["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
  })(TcasAlertLevel || (TcasAlertLevel = {}));
  var TcasResolutionAdvisoryFlags;
  (function(TcasResolutionAdvisoryFlags2) {
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Corrective"] = 1] = "Corrective";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["UpSense"] = 2] = "UpSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DownSense"] = 4] = "DownSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Crossing"] = 8] = "Crossing";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Climb"] = 16] = "Climb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Descend"] = 32] = "Descend";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Increase"] = 64] = "Increase";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Reversal"] = 128] = "Reversal";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceClimb"] = 256] = "ReduceClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceDescent"] = 512] = "ReduceDescent";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotClimb"] = 1024] = "DoNotClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotDescend"] = 2048] = "DoNotDescend";
  })(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
  var TcasResolutionAdvisoryType;
  (function(TcasResolutionAdvisoryType2) {
    TcasResolutionAdvisoryType2["Climb"] = "Climb";
    TcasResolutionAdvisoryType2["CrossingClimb"] = "CrossingClimb";
    TcasResolutionAdvisoryType2["MaintainClimb"] = "MaintainClimb";
    TcasResolutionAdvisoryType2["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    TcasResolutionAdvisoryType2["IncreaseClimb"] = "IncreaseClimb";
    TcasResolutionAdvisoryType2["ReversalClimb"] = "ReversalClimb";
    TcasResolutionAdvisoryType2["ReduceDescent"] = "ReduceDescent";
    TcasResolutionAdvisoryType2["DoNotDescend0"] = "DoNotDescend0";
    TcasResolutionAdvisoryType2["DoNotDescend500"] = "DoNotDescend500";
    TcasResolutionAdvisoryType2["DoNotDescend1000"] = "DoNotDescend1000";
    TcasResolutionAdvisoryType2["DoNotDescend1500"] = "DoNotDescend1500";
    TcasResolutionAdvisoryType2["DoNotDescend2000"] = "DoNotDescend2000";
    TcasResolutionAdvisoryType2["Descend"] = "Descend";
    TcasResolutionAdvisoryType2["CrossingDescend"] = "CrossingDescend";
    TcasResolutionAdvisoryType2["MaintainDescend"] = "MaintainDescend";
    TcasResolutionAdvisoryType2["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    TcasResolutionAdvisoryType2["IncreaseDescend"] = "IncreaseDescend";
    TcasResolutionAdvisoryType2["ReversalDescend"] = "ReversalDescend";
    TcasResolutionAdvisoryType2["ReduceClimb"] = "ReduceClimb";
    TcasResolutionAdvisoryType2["DoNotClimb0"] = "DoNotClimb0";
    TcasResolutionAdvisoryType2["DoNotClimb500"] = "DoNotClimb500";
    TcasResolutionAdvisoryType2["DoNotClimb1000"] = "DoNotClimb1000";
    TcasResolutionAdvisoryType2["DoNotClimb1500"] = "DoNotClimb1500";
    TcasResolutionAdvisoryType2["DoNotClimb2000"] = "DoNotClimb2000";
    TcasResolutionAdvisoryType2["Clear"] = "Clear";
  })(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
  var Tcas = class {
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.bus = bus;
      this.tfcInstrument = tfcInstrument;
      this.maxIntruderCount = maxIntruderCount;
      this.realTimeUpdateFreq = realTimeUpdateFreq;
      this.simTimeUpdateFreq = simTimeUpdateFreq;
      this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
      this.intrudersSorted = [];
      this.intrudersFiltered = [];
      this.intrudersRA = /* @__PURE__ */ new Set();
      this.contactCreatedHandler = this.onContactAdded.bind(this);
      this.contactRemovedHandler = this.onContactRemoved.bind(this);
      this.ownAirplaneSubs = {
        position: GeoPointSubject.create(new GeoPoint(0, 0)),
        altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        groundTrack: ConsumerSubject.create(null, 0),
        groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
        verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
        radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        isOnGround: ConsumerSubject.create(null, false)
      };
      this.simTime = ConsumerSubject.create(null, 0);
      this.lastUpdateSimTime = 0;
      this.lastUpdateRealTime = 0;
      this.alertLevelSubs = /* @__PURE__ */ new Map();
      this.eventPublisher = this.bus.getPublisher();
      this.eventSubscriber = this.bus.getSubscriber();
      this.paSeparationCache = {
        horizontal: UnitType.NMILE.createNumber(0),
        vertical: UnitType.FOOT.createNumber(0)
      };
      this.sensitivity = this.createSensitivity();
      this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
      const fullRAOptions = {
        initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
        initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
        subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
        subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
        allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : () => true,
        allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : () => true,
        allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100,
        allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450
      };
      this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    getOperatingMode() {
      return this.operatingModeSub.get();
    }
    setOperatingMode(mode) {
      this.operatingModeSub.set(mode);
    }
    getIntruders() {
      return this.intrudersFiltered;
    }
    getResolutionAdvisoryHost() {
      return this.resolutionAdvisoryHost;
    }
    getEventSubscriber() {
      return this.eventSubscriber;
    }
    init() {
      const sub = this.bus.getSubscriber();
      this.contactCreatedConsumer = sub.on("traffic_contact_added");
      this.contactRemovedConsumer = sub.on("traffic_contact_removed");
      this.contactCreatedConsumer.handle(this.contactCreatedHandler);
      this.contactRemovedConsumer.handle(this.contactRemovedHandler);
      this.tfcInstrument.forEachContact((contact) => {
        this.onContactAdded(contact.uid);
      });
      sub.on("gps-position").atFrequency(this.realTimeUpdateFreq).handle((lla) => {
        this.ownAirplaneSubs.position.set(lla.lat, lla.long);
        this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
      });
      sub.on("ground_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((gs) => {
        this.ownAirplaneSubs.groundSpeed.set(gs);
      });
      sub.on("vertical_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((vs) => {
        this.ownAirplaneSubs.verticalSpeed.set(vs);
      });
      sub.on("radio_alt").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((alt) => {
        this.ownAirplaneSubs.radarAltitude.set(alt);
      });
      this.ownAirplaneSubs.groundTrack.setConsumer(sub.on("track_deg_true"));
      this.ownAirplaneSubs.isOnGround.setConsumer(sub.on("on_ground"));
      this.simTime.setConsumer(sub.on("simTime"));
      this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
      sub.on("simTime").whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    onOperatingModeChanged(mode) {
      this.bus.pub("tcas_operating_mode", mode, false, true);
      if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.cancel(this.simTime.get());
        for (let i = 0; i < this.intrudersFiltered.length; i++) {
          this.cleanUpIntruder(this.intrudersFiltered[i]);
        }
        this.intrudersFiltered = [];
      }
    }
    intruderComparator(a, b) {
      if (a.isPredictionValid && !b.isPredictionValid) {
        return -1;
      } else if (!a.isPredictionValid && b.isPredictionValid) {
        return 1;
      } else if (a.isPredictionValid) {
        let tcaPredictionA, tcaPredictionB;
        const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || a.tcaRA.isValid && a.tcaRA.isThreat;
        const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || b.tcaRA.isValid && b.tcaRA.isThreat;
        if (aRA && !bRA) {
          return -1;
        } else if (!aRA && bRA) {
          return 1;
        } else if (aRA && bRA) {
          tcaPredictionA = a.tcaRA;
          tcaPredictionB = b.tcaRA;
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || a.tcaTA.isValid && a.tcaTA.isThreat;
          const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || b.tcaTA.isValid && b.tcaTA.isThreat;
          if (aTA && !bTA) {
            return -1;
          } else if (!aTA && bTA) {
            return 1;
          } else if (aTA && bTA) {
            tcaPredictionA = a.tcaTA;
            tcaPredictionB = b.tcaTA;
          }
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
            return -1;
          } else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
            return 1;
          } else {
            return 0;
          }
        }
        const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
        const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
        let firstComparison;
        let secondComparison;
        if (tcaPredictionA.isThreat) {
          firstComparison = tcaComparison;
          secondComparison = normComparison;
        } else {
          firstComparison = normComparison;
          secondComparison = tcaComparison;
        }
        if (firstComparison === 0) {
          return secondComparison;
        } else {
          return firstComparison;
        }
      } else {
        return 0;
      }
    }
    onContactAdded(uid) {
      const contact = this.tfcInstrument.getContact(uid);
      const intruder = this.createIntruderEntry(contact);
      this.intrudersSorted.push(intruder);
    }
    onContactRemoved(uid) {
      const sortedIndex = this.intrudersSorted.findIndex((intruder) => intruder.contact.uid === uid);
      const culledIndex = this.intrudersFiltered.findIndex((intruder) => intruder.contact.uid === uid);
      if (sortedIndex >= 0) {
        this.intrudersSorted.splice(sortedIndex, 1);
      }
      if (culledIndex >= 0) {
        const removed = this.intrudersFiltered[culledIndex];
        this.intrudersFiltered.splice(culledIndex, 1);
        this.cleanUpIntruder(removed);
      }
    }
    onSimTimeChanged(simTime) {
      switch (this.operatingModeSub.get()) {
        case TcasOperatingMode.Off:
        case TcasOperatingMode.Standby:
        case TcasOperatingMode.Failed:
        case TcasOperatingMode.Test:
          return;
      }
      const realTime = Date.now();
      if (Math.abs(simTime - this.lastUpdateSimTime) < 1e3 / this.simTimeUpdateFreq || Math.abs(realTime - this.lastUpdateRealTime) < 1e3 / this.realTimeUpdateFreq) {
        return;
      }
      this.doUpdate(simTime);
      this.lastUpdateSimTime = simTime;
      this.lastUpdateRealTime = realTime;
    }
    doUpdate(simTime) {
      this.updateSensitivity();
      this.updateIntruderPredictions(simTime);
      this.updateIntruderArrays();
      this.updateFilteredIntruderAlertLevels(simTime);
      this.updateResolutionAdvisory(simTime);
    }
    updateIntruderPredictions(simTime) {
      this.ownAirplane.update(simTime);
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersSorted[i];
        const sensitivity = this.sensitivity.selectParameters(intruder);
        intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
      }
    }
    updateIntruderArrays() {
      this.intrudersSorted.sort(this.intruderComparator.bind(this));
      const oldCulled = this.intrudersFiltered;
      this.intrudersFiltered = [];
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
        const intruder = this.intrudersSorted[i];
        if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
          this.intrudersFiltered.push(intruder);
          if (!oldCulled.includes(intruder)) {
            this.initIntruder(intruder);
          }
        } else {
          if (oldCulled.includes(intruder)) {
            this.cleanUpIntruder(intruder);
          }
        }
      }
    }
    filterIntruder(intruder) {
      return true;
    }
    updateFilteredIntruderAlertLevels(simTime) {
      let taCount = 0, raCount = 0;
      const len = this.intrudersFiltered.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersFiltered[i];
        this.updateIntruderAlertLevel(simTime, intruder);
        switch (intruder.alertLevel.get()) {
          case TcasAlertLevel.TrafficAdvisory:
            taCount++;
            break;
          case TcasAlertLevel.ResolutionAdvisory:
            raCount++;
            break;
        }
      }
      this.eventPublisher.pub("tcas_ta_intruder_count", taCount, false, true);
      this.eventPublisher.pub("tcas_ra_intruder_count", raCount, false, true);
    }
    updateIntruderAlertLevel(simTime, intruder) {
      const currentAlertLevel = intruder.alertLevel.get();
      if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
        if (this.canIssueResolutionAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat) && !this.canCancelResolutionAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
        if (this.canIssueTrafficAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat) && !this.canCancelTrafficAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.isPredictionValid) {
        const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
        const radius = parametersPA.protectedRadius;
        const height = parametersPA.protectedHeight;
        if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
          intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
          if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0 && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
            intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
            return;
          }
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
        return;
      }
      intruder.alertLevel.set(TcasAlertLevel.None);
    }
    canIssueResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() === TcasOperatingMode.TA_RA && intruder.tcaRA.isValid && intruder.tcaRA.tcpa.number > 0 && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    canCancelResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    canIssueTrafficAdvisory(simTime, intruder) {
      return true;
    }
    canCancelTrafficAdvisory(simTime, intruder) {
      return true;
    }
    canIssueProximityAdvisory(simTime, intruder) {
      return true;
    }
    canCancelProximityAdvisory(simTime, intruder) {
      return true;
    }
    updateResolutionAdvisory(simTime) {
      if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
      } else {
        this.resolutionAdvisoryHost.cancel(simTime);
      }
    }
    initIntruder(intruder) {
      this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
      this.eventPublisher.pub("tcas_intruder_added", intruder, false, false);
    }
    cleanUpIntruder(intruder) {
      var _a;
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.delete(intruder);
      }
      (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
      this.eventPublisher.pub("tcas_intruder_removed", intruder, false, false);
    }
    onAlertLevelChanged(intruder) {
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.add(intruder);
      } else {
        this.intrudersRA.delete(intruder);
      }
      this.eventPublisher.pub("tcas_intruder_alert_changed", intruder, false, false);
    }
  };
  Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
  };
  var TcasAirplane = class {
    constructor() {
      this._position = new GeoPoint(0, 0);
      this.position = this._position.readonly;
      this._altitude = UnitType.FOOT.createNumber(0);
      this.altitude = this._altitude.readonly;
      this._groundTrack = 0;
      this._groundSpeed = UnitType.KNOT.createNumber(0);
      this.groundSpeed = this._groundSpeed.readonly;
      this._verticalSpeed = UnitType.FPM.createNumber(0);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.positionVec = new Float64Array(3);
      this.velocityVec = new Float64Array(3);
      this.lastUpdateTime = 0;
    }
    get groundTrack() {
      return this._groundTrack;
    }
  };
  var OwnAirplane = class extends TcasAirplane {
    constructor(subs) {
      super();
      this.subs = subs;
      this._radarAltitude = UnitType.FOOT.createNumber(0);
      this.radarAltitude = this._radarAltitude.readonly;
      this._isOnGround = false;
    }
    get isOnGround() {
      return this._isOnGround;
    }
    predictPosition(simTime, out) {
      const dt = (simTime - this.lastUpdateTime) / 1e3;
      return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    update(simTime) {
      this.updateParameters();
      this.updateVectors();
      this.lastUpdateTime = simTime;
    }
    updateParameters() {
      this._position.set(this.subs.position.get());
      this._altitude.set(this.subs.altitude.get());
      this._groundTrack = this.subs.groundTrack.get();
      this._groundSpeed.set(this.subs.groundSpeed.get());
      this._verticalSpeed.set(this.subs.verticalSpeed.get());
      this._radarAltitude.set(this.subs.radarAltitude.get());
      this._isOnGround = this.subs.isOnGround.get();
    }
    updateVectors() {
      Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
    }
  };
  var AbstractTcasIntruder = class extends TcasAirplane {
    constructor(contact) {
      super();
      this.contact = contact;
      this.alertLevel = Subject.create(TcasAlertLevel.None);
      this.relativePositionVec = new Float64Array(3);
      this.relativeVelocityVec = new Float64Array(3);
      this._isPredictionValid = false;
      this.tcaTA = new TcasTcaPredictionClass(this);
      this.tcaRA = new TcasTcaPredictionClass(this);
    }
    get isPredictionValid() {
      return this._isPredictionValid;
    }
    predictDisplacement(simTime, out) {
      if (!this._isPredictionValid) {
        return Vec3Math.set(NaN, NaN, NaN, out);
      }
      const dt = (simTime - this.contact.lastContactTime) / 1e3;
      return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    predictSeparation(simTime, horizontalOut, verticalOut) {
      if (!this._isPredictionValid) {
        horizontalOut.set(NaN);
        verticalOut.set(NaN);
        return;
      }
      const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
      AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
      AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    updatePrediction(simTime, ownAirplane, sensitivity) {
      this.updateParameters(simTime, ownAirplane);
      if (this.isPredictionValid) {
        const taParams = sensitivity.parametersTA;
        const raParams = sensitivity.parametersRA;
        this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
        this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
      } else {
        this.invalidatePredictions();
      }
      this.lastUpdateTime = simTime;
    }
    updateParameters(simTime, ownAirplane) {
      if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
        this._isPredictionValid = false;
        this._position.set(NaN, NaN);
        this._altitude.set(NaN);
        this._groundTrack = NaN;
        this._groundSpeed.set(NaN);
        this._verticalSpeed.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.positionVec);
        Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
      } else {
        this.updatePosition(simTime, ownAirplane);
        this.updateVelocity(ownAirplane);
        this._groundSpeed.set(this.contact.groundSpeed);
        this._verticalSpeed.set(this.contact.verticalSpeed);
        this._isPredictionValid = true;
      }
    }
    updatePosition(simTime, ownAirplane) {
      this.contact.predict(simTime, this._position, this._altitude);
      this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
      const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
      const bearing = ownAirplane.position.bearingTo(this._position);
      Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
      const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
      this.positionVec[2] = verticalPosition;
      Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    updateVelocity(ownAirplane) {
      Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
      Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    invalidatePredictions() {
      this.tcaTA.invalidate();
      this.tcaRA.invalidate();
    }
    static displacementToHorizontalSeparation(displacement, out) {
      return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    static displacementToVerticalSeparation(displacement, out) {
      return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
  };
  AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
  AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  var TcasTcaPredictionClass = class {
    constructor(intruder) {
      this.intruder = intruder;
      this._isValid = false;
      this._time = NaN;
      this._tcpa = UnitType.SECOND.createNumber(NaN);
      this.tcpa = this._tcpa.readonly;
      this._tcoa = UnitType.SECOND.createNumber(NaN);
      this.tcoa = this._tcoa.readonly;
      this._isThreat = false;
      this.cpaDisplacement = new Float64Array(3);
      this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
      this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
      this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
      this.cpaVerticalSep = this._cpaVerticalSep.readonly;
      this._cpaNorm = NaN;
    }
    get isValid() {
      return this._isValid;
    }
    get time() {
      return this._time;
    }
    get isThreat() {
      return this._isThreat;
    }
    get cpaNorm() {
      return this._cpaNorm;
    }
    update(simTime, tau, dmod, zthr, hmd) {
      var _a;
      this._time = simTime;
      if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
        this.invalidate();
        return;
      }
      const tauSeconds = tau.asUnit(UnitType.SECOND);
      const s = this.intruder.relativePositionVec;
      const v = this.intruder.relativeVelocityVec;
      const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
      const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
      const h = zthr.asUnit(UnitType.METER);
      const r = dmod.asUnit(UnitType.METER);
      const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
      const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
      const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
      const rSquared = r * r;
      const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
      const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
      const tcoa = -s[2] / v[2];
      const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
      const isVerticalThreat = Math.abs(s[2]) <= h || tcoa >= 0 && tcoa <= tauSeconds;
      let passHmdFilter = true;
      if (hmd !== void 0 && isHorizontalThreat && isVerticalThreat) {
        const d = hmd.asUnit(UnitType.METER);
        const dSquared = d * d;
        if (vHorizSquared === 0) {
          passHmdFilter = sHorizSquared <= dSquared;
        } else {
          const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
          if (delta < 0) {
            passHmdFilter = false;
          } else {
            const a = vHorizSquared;
            const b = 2 * dotSHorizVHoriz;
            const c = sHorizSquared - dSquared;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) {
              passHmdFilter = false;
            } else {
              passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
            }
          }
        }
      }
      this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
      this._tcpa.set(tcpa);
      this._tcoa.set(tcoa);
      TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
      AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
      AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
      this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
      this._isValid = true;
    }
    invalidate() {
      this._isValid = false;
      this._isThreat = false;
      this._tcpa.set(NaN);
      this._tcoa.set(NaN);
      Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
      this._cpaHorizontalSep.set(NaN);
      this._cpaVerticalSep.set(NaN);
      this._cpaNorm = NaN;
    }
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
      return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    static calculateCylindricalNorm(vector, radius, halfHeight) {
      const horizLength = Math.hypot(vector[0], vector[1]);
      return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
  };
  TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var TcasResolutionAdvisoryHostClass = class {
    constructor(bus, options, ownAirplane) {
      this.options = options;
      this.ownAirplane = ownAirplane;
      this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
      this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
      this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.intruders = /* @__PURE__ */ new Set();
      this.intruderArray = [];
      this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
      this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.minVerticalSpeed = this._minVerticalSpeed.readonly;
      this._flags = 0;
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._secondaryType = null;
      this._primaryFlags = 0;
      this._secondaryFlags = 0;
      this.vsConstraints = [];
      this.lastStateChangeTime = 0;
      this.stateChangeDelay = 0;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher = bus.getPublisher();
    }
    get flags() {
      return this._flags;
    }
    get primaryType() {
      return this._primaryType;
    }
    get secondaryType() {
      return this._secondaryType;
    }
    get primaryFlags() {
      return this._primaryFlags;
    }
    get secondaryFlags() {
      return this._secondaryFlags;
    }
    canIssueResolutionAdvisory(simTime, intruder) {
      if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
        return false;
      }
      if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    canCancelResolutionAdvisory(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    update(simTime, alim, intruders) {
      if (this.intruderArray.length === 0 && intruders.size === 0) {
        return;
      }
      if (simTime < this.lastStateChangeTime) {
        this.lastStateChangeTime = simTime;
      }
      if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
        return;
      }
      if (intruders.size === 0) {
        this.cancel(simTime);
      } else {
        const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        const alimMeters = alim.asUnit(UnitType.METER);
        const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
        const responseTimeSecondsRemaining = isInitial ? responseTimeSeconds : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1e3, 0, responseTimeSeconds);
        const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
        this.updateIntruders(intruders);
        this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
        if (isInitial) {
          this.selectInitialState(simTime, ownAirplaneVsMps);
        } else {
          if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
            this.updatePositive(simTime);
          } else if (this._secondaryType === null) {
            this.updateNegative(simTime, ownAirplaneVsMps);
          } else {
            this.updateComposite(simTime, ownAirplaneVsMps);
          }
        }
      }
    }
    updateIntruders(intruders) {
      for (let i = 0; i < this.intruderArray.length; i++) {
        if (!intruders.has(this.intruderArray[i])) {
          this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
        }
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      for (const intruder of intruders) {
        this.intruders.add(intruder);
        this.intruderArray.push(intruder);
      }
      this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
      var _a;
      var _b;
      const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
      for (let i = 0; i < this.intruderArray.length; i++) {
        const intruder = this.intruderArray[i];
        let above = -Infinity;
        let below = Infinity;
        if (intruder.tcaRA.isValid) {
          const t0 = intruder.tcaRA.time;
          const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
          const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1e3;
          const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
          const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
          const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
          const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
          const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
          if (aboveAlimSense === 1) {
            above = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters) : NaN;
            if (isNaN(above)) {
              above = Infinity;
            }
          } else {
            above = tcpaSeconds > 0 ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : -Infinity;
          }
          if (belowAlimSense === -1) {
            below = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters) : NaN;
            if (isNaN(below)) {
              below = -Infinity;
            }
          } else {
            below = tcpaSeconds > 0 ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : Infinity;
          }
        }
        const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : _b[i] = { above: 0, below: 0 };
        constraint.above = above;
        constraint.below = below;
      }
      this.vsConstraints.length = this.intruderArray.length;
    }
    selectInitialState(simTime, ownAirplaneVsMps) {
      let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
      let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
      let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
      const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
      const canClimb = this.options.allowClimb(simTime);
      const canDescend = this.options.allowDescend(simTime);
      const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
      const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
      minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
      maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
      let sense;
      let senseIsCrossing = false;
      let doesSenseAchieveAlim = false;
      let senseRequiredVs = 0;
      if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
        sense = 1;
      } else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
        sense = -1;
      } else {
        const closestIntruder = this.intruderArray[0];
        const t0 = closestIntruder.tcaRA.time;
        const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
        const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
        const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
        const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
        if (crossingSense === -1 && !isUpSenseInhibited) {
          sense = 1;
        } else if (crossingSense === 1 && !isDownSenseInhibited) {
          sense = -1;
        } else {
          if (!isUpSenseInhibited && isDownSenseInhibited) {
            sense = 1;
          } else if (isUpSenseInhibited && !isDownSenseInhibited) {
            sense = -1;
          } else {
            if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
              sense = 1;
            } else {
              sense = -1;
            }
          }
          senseIsCrossing = sense === crossingSense;
        }
      }
      doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
      doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
      doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
      senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
      if (this.intruderArray.length > 1) {
        const doesCompositeAchieveAlim = this.vsConstraints.every((constraint) => constraint.above <= 0 || constraint.below >= 0);
        if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
          sense = 0;
          doesSenseAchieveAlim = doesCompositeAchieveAlim;
        } else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
          if (senseIsCrossing) {
            sense = 0;
            doesSenseAchieveAlim = doesCompositeAchieveAlim;
          } else {
            if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
              sense = 0;
              doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
          }
        }
      }
      let primaryType;
      let secondaryType = null;
      switch (sense) {
        case 0:
          if (doesSenseAchieveAlim) {
            const maxVsMps = this.getCompositeRequiredMaxVs();
            const minVsMps = this.getCompositeRequiredMinVs();
            if (ownAirplaneVsMps > maxVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
            } else if (ownAirplaneVsMps < minVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            }
          } else {
            primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
          }
          break;
        case 1:
          if (ownAirplaneVsMps < minUpSenseVsMps) {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            }
          } else {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
            }
          }
          break;
        case -1:
          if (ownAirplaneVsMps > maxDownSenseVsMps) {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
            }
          } else {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
            }
          }
          break;
      }
      this.setState(simTime, primaryType, secondaryType, true);
    }
    updatePositive(simTime) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
      const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
      if (isInhibited) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
        return;
      }
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        if (requiredVsMps * sense <= 0) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
      } else {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
        let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
        }
      }
    }
    updateNegative(simTime, ownAirplaneVsMps) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        return;
      }
      const requirePositive = requiredVsMps * sense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
      } else {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
      }
    }
    updateComposite(simTime, ownAirplaneVsMps) {
      if (this._secondaryType === null) {
        throw new Error("TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active");
      }
      const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
      const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredMinVsMps = this.getCompositeRequiredMinVs();
      const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
      const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
      if (primarySense === 1) {
        primaryCurrentVsMps = currentMinVsMps;
        primaryRequiredVsMps = requiredMinVsMps;
        secondaryCurrentVsMps = currentMaxVsMps;
        secondaryRequiredVsMps = requiredMaxVsMps;
      } else {
        primaryCurrentVsMps = currentMaxVsMps;
        primaryRequiredVsMps = requiredMaxVsMps;
        secondaryCurrentVsMps = currentMinVsMps;
        secondaryRequiredVsMps = requiredMinVsMps;
      }
      const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
      const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
      const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0 || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      let primaryType;
      if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
      } else {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
      }
      const secondaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
      this.setState(simTime, primaryType, secondaryType);
    }
    setState(simTime, primaryType, secondaryType, isInitial = false) {
      if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
        return;
      }
      let minSpeed, maxSpeed;
      const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
      this._primaryType = primaryType;
      this._primaryFlags = primaryTypeDef.flags;
      this._secondaryType = secondaryType;
      if (secondaryType !== null) {
        const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
        this._secondaryFlags = secondaryTypeDef.flags;
        minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
        maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
      } else {
        this._secondaryFlags = 0;
        minSpeed = primaryTypeDef.minVerticalSpeed;
        maxSpeed = primaryTypeDef.maxVerticalSpeed;
      }
      this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
      this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
      this.isInitial = isInitial;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1e3;
      if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
        this.senseReversalCount++;
      }
      if (isInitial) {
        this.publisher.pub("tcas_ra_issued", this, false, false);
      } else {
        this.publisher.pub("tcas_ra_updated", this, false, false);
      }
    }
    cancel(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
        return;
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      this._maxVerticalSpeed.set(NaN);
      this._minVerticalSpeed.set(NaN);
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._primaryFlags = 0;
      this._secondaryType = null;
      this._secondaryFlags = 0;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher.pub("tcas_ra_canceled", void 0, false, false);
    }
    getUpSenseRequiredMinVs() {
      return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    getDownSenseRequiredMaxVs() {
      return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    getCompositeRequiredMinVs() {
      return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    getCompositeRequiredMaxVs() {
      return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
      const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
      if (signedAccel === 0) {
        return vs;
      }
      const y0 = currentAlt + vs * responseTime;
      const tc = tcpa - responseTime;
      const a = signedAccel / 2;
      const b = -signedAccel * tc;
      const c = targetAlt - y0 - vs * tc;
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) {
        return NaN;
      }
      const sqrtDiscr = Math.sqrt(discriminant);
      const t1 = (-b + sqrtDiscr) / (2 * a);
      const t2 = (-b - sqrtDiscr) / (2 * a);
      if (t1 <= tc && t1 >= 0) {
        return vs + signedAccel * t1;
      }
      if (t2 <= tc && t2 >= 0) {
        return vs + signedAccel * t2;
      }
      return NaN;
    }
    static getDoNotDescendType(minVsMps) {
      if (minVsMps > -500) {
        return TcasResolutionAdvisoryType.DoNotDescend0;
      } else if (minVsMps > -1e3) {
        return TcasResolutionAdvisoryType.DoNotDescend500;
      } else if (minVsMps > -1500) {
        return TcasResolutionAdvisoryType.DoNotDescend1000;
      } else if (minVsMps > -2e3) {
        return TcasResolutionAdvisoryType.DoNotDescend1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotDescend2000;
      }
    }
    static getDoNotClimbType(maxVsMps) {
      if (maxVsMps < 500) {
        return TcasResolutionAdvisoryType.DoNotClimb0;
      } else if (maxVsMps < 1e3) {
        return TcasResolutionAdvisoryType.DoNotClimb500;
      } else if (maxVsMps < 1500) {
        return TcasResolutionAdvisoryType.DoNotClimb1000;
      } else if (maxVsMps < 2e3) {
        return TcasResolutionAdvisoryType.DoNotClimb1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotClimb2000;
      }
    }
  };
  TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5e3;
  TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
      return -1;
    } else if (tcpaComparison > 0) {
      return 1;
    } else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
      return -1;
    } else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
      return 1;
    } else {
      return 0;
    }
  };
  TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
      flags: 0,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 2500,
      maxVerticalSpeed: 3e3
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -3e3,
      maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1e3
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 2e3
    }
  };
  TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];
  var TcasIISensitivityParameters = class {
    selectLevel(altitude, radarAltitude) {
      const altFeet = altitude.asUnit(UnitType.FOOT);
      const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
      let level;
      if (radarAltFeet > 2350) {
        if (altFeet > 42e3) {
          level = 6;
        } else if (altFeet > 2e4) {
          level = 5;
        } else if (altFeet > 1e4) {
          level = 4;
        } else if (altFeet > 5e3) {
          level = 3;
        } else {
          level = 2;
        }
      } else if (radarAltFeet > 1e3) {
        level = 1;
      } else {
        level = 0;
      }
      return level;
    }
    selectPA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.PA;
    }
    selectTA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    selectRA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    selectRAAlim(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    getPA(level) {
      return TcasIISensitivityParameters.PA;
    }
    getTA(level) {
      return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    getRA(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    getRAAlim(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
  };
  TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
  };
  TcasIISensitivityParameters.TA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.33),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.48),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(40),
      protectedRadius: UnitType.NMILE.createNumber(0.75),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(45),
      protectedRadius: UnitType.NMILE.createNumber(1),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(1200)
    }
  ];
  TcasIISensitivityParameters.RA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.35),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.55),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(350),
      hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.8),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(400),
      hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(700),
      alim: UnitType.FOOT.createNumber(600),
      hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(800),
      alim: UnitType.FOOT.createNumber(700),
      hmd: UnitType.NMILE.createNumber(0.98)
    }
  ];
  var MapTrafficAlertLevelVisibility;
  (function(MapTrafficAlertLevelVisibility2) {
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["All"] = 15] = "All";
  })(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
  var MapTrafficModule = class {
    constructor(tcas) {
      this.tcas = tcas;
      this.show = Subject.create(true);
      this.operatingMode = Subject.create(TcasOperatingMode.Standby);
      this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
      this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
      this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.isAltitudeRelative = Subject.create(true);
      this.tcas.getEventSubscriber().on("tcas_operating_mode").whenChanged().handle((mode) => {
        this.operatingMode.set(mode);
      });
    }
  };
  var MapSystemTrafficLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.iconLayerRef = FSComponent.createRef();
      this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
      this.intruderIcons = {
        [TcasAlertLevel.None]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ProximityAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.TrafficAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ResolutionAdvisory]: /* @__PURE__ */ new Map()
      };
      this.needHandleOffscaleOob = this.props.offScaleIntruders !== void 0 || this.props.oobIntruders !== void 0;
      this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
      this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
      this.isInit = false;
    }
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (!isVisible) {
        if (this.isInit) {
          this.iconLayerRef.instance.display.clear();
        }
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    onAttached() {
      this.iconLayerRef.instance.onAttached();
      this.oobOffset.sub(this.updateOobBounds.bind(this), true);
      this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
      this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
      this.initCanvasStyles();
      this.initIntruders();
      this.initTCASHandlers();
      this.isInit = true;
    }
    initCanvasStyles() {
      this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    initIntruders() {
      const intruders = this.trafficModule.tcas.getIntruders();
      const len = intruders.length;
      for (let i = 0; i < len; i++) {
        this.onIntruderAdded(intruders[i]);
      }
    }
    initTCASHandlers() {
      const tcasSub = this.props.context.bus.getSubscriber();
      tcasSub.on("tcas_intruder_added").handle(this.onIntruderAdded.bind(this));
      tcasSub.on("tcas_intruder_removed").handle(this.onIntruderRemoved.bind(this));
      tcasSub.on("tcas_intruder_alert_changed").handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.initCanvasStyles();
        this.updateOobBounds();
      }
    }
    updateOobBounds() {
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const oobOffset = this.oobOffset.get();
      this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    onUpdated(time, elapsed) {
      if (!this.isVisible()) {
        return;
      }
      this.redrawIntruders();
    }
    redrawIntruders() {
      const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
      const offScaleRange = this.trafficModule.offScaleRange.get();
      const oobBounds = this.oobBounds.get();
      const iconDisplay = this.iconLayerRef.instance.display;
      iconDisplay.clear();
      for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
        const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
        if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b, _c, _d, _e, _f;
            icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
            if (this.needHandleOffscaleOob) {
              if (icon.isOffScale) {
                (_a = this.props.oobIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                (_b = this.props.offScaleIntruders) === null || _b === void 0 ? void 0 : _b.add(icon.intruder);
              } else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
              } else {
                (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
              }
            }
          });
        } else if (this.needHandleOffscaleOob) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b;
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
          });
        }
      }
    }
    updateVisibility() {
      const operatingMode = this.trafficModule.tcas.getOperatingMode();
      this.setVisible(this.trafficModule.show.get() && (operatingMode === TcasOperatingMode.TAOnly || operatingMode === TcasOperatingMode.TA_RA || operatingMode === TcasOperatingMode.Test));
    }
    onIntruderAdded(intruder) {
      const icon = this.props.iconFactory(intruder, this.props.context);
      this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    onIntruderRemoved(intruder) {
      var _a, _b;
      (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
      (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
      this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    onIntruderAlertLevelChanged(intruder) {
      let oldAlertLevel;
      let view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.None].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ProximityAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.TrafficAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ResolutionAdvisory].get(intruder);
      if (view) {
        this.intruderIcons[oldAlertLevel].delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
      }
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
  };
  MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TcasAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TcasAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TcasAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TcasAlertLevel.ResolutionAdvisory }
  ];
  var AbstractMapTrafficIntruderIcon = class {
    constructor(intruder, trafficModule, ownshipModule) {
      this.intruder = intruder;
      this.trafficModule = trafficModule;
      this.ownshipModule = ownshipModule;
      this.projectedPos = new Float64Array(2);
      this.isOffScale = false;
    }
    draw(projection, context, offScaleRange) {
      this.updatePosition(projection, offScaleRange);
      this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    updatePosition(projection, offScaleRange) {
      const ownAirplanePos = this.ownshipModule.position.get();
      if (offScaleRange.isNaN()) {
        projection.project(this.intruder.position, this.projectedPos);
        this.isOffScale = false;
      } else {
        this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
      }
    }
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
      const intruderPos = this.intruder.position;
      const horizontalSeparation = intruderPos.distance(ownAirplanePos);
      const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
      if (horizontalSeparation > offscaleRangeRad) {
        this.isOffScale = true;
        projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
      } else {
        this.isOffScale = false;
        projection.project(intruderPos, this.projectedPos);
      }
    }
  };
  AbstractMapTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];
  var MapSystemWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.waypointsLayer = FSComponent.createRef();
      this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
      this.waypointCache = (_a = this.props.waypointCache) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.searchItemLimits = {
        [FacilitySearchType.Airport]: 500,
        [FacilitySearchType.Vor]: 250,
        [FacilitySearchType.Ndb]: 250,
        [FacilitySearchType.Intersection]: 500,
        [FacilitySearchType.User]: 100
      };
      this.searchRadiusLimits = {
        [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.User]: Number.POSITIVE_INFINITY
      };
    }
    onAttached() {
      super.onAttached();
      this.waypointsLayer.instance.onAttached();
      this.initEventHandlers();
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    onUpdated(time, elapsed) {
      if (this.isVisible()) {
        this.waypointsLayer.instance.onUpdated(time, elapsed);
      }
    }
    initEventHandlers() {
      this.displayModule.numAirports.sub((num) => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
      this.displayModule.numIntersections.sub((num) => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
      this.displayModule.numVors.sub((num) => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
      this.displayModule.numNdbs.sub((num) => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
      this.displayModule.airportsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.intersectionsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.vorsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.ndbsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.refreshWaypoints.on(() => this.waypointsLayer.instance.refreshWaypoints());
    }
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession) {
      this.displayModule.intersectionsFilter.sub((filters) => intSession.setIntersectionFilter(filters.typeMask));
      this.displayModule.vorsFilter.sub((filters) => vorSession.setVorFilter(filters.classMask, filters.typeMask));
      this.displayModule.airportsFilter.sub((filters) => {
        airportSession.setAirportFilter(filters.showClosed, filters.classMask);
      });
      this.displayModule.extendedAirportsFilter.sub((filters) => {
        airportSession.setExtendedAirportFilters(filters.runwaySurfaceTypeMask, filters.approachTypeMask, filters.toweredMask, filters.minimumRunwayLength);
      });
    }
    initWaypointRenderer(renderer, canvasLayer) {
      this.defineRenderRole(renderer, canvasLayer);
      renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    defineRenderRole(renderer, canvasLayer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.setCanvasContext(roleId, canvasLayer.display.context);
          renderer.setIconFactory(roleId, this.props.iconFactory);
          renderer.setLabelFactory(roleId, this.props.labelFactory);
          renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
        }
      });
    }
    setVisible(val) {
      super.setVisible(val);
      this.waypointsLayer.instance.setVisible(val);
    }
    isWaypointVisible(waypoint) {
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        switch (waypoint.type) {
          case WaypointTypes.Airport:
            return this.displayModule.showAirports.get()(waypoint);
          case WaypointTypes.Intersection:
            return this.displayModule.showIntersections.get()(waypoint);
          case WaypointTypes.VOR:
            return this.displayModule.showVors.get()(waypoint);
          case WaypointTypes.NDB:
            return this.displayModule.showNdbs.get()(waypoint);
        }
      }
      return false;
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: this.registerWaypoint.bind(this), deregisterWaypoint: this.deregisterWaypoint.bind(this), searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : void 0, onSessionsStarted: this.onSessionsStarted.bind(this), class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    registerWaypoint(waypoint, renderer) {
      const selector = this.displayModule.waypointRoleSelector.get();
      if (selector) {
        const id = selector(waypoint);
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.register(waypoint, roleId, "waypoints-layer");
        }
      } else {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach((id) => {
          const roleId = renderer.getRoleFromName(id);
          if (roleId !== void 0) {
            renderer.register(waypoint, roleId, "waypoints-layer");
          }
        });
      }
    }
    deregisterWaypoint(waypoint, renderer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.deregister(waypoint, roleId, "waypoints-layer");
        }
      });
    }
  };
  var MapTerrainColorsModule = class {
    constructor() {
      this.reference = Subject.create(EBingReference.SEA);
      this.showIsoLines = Subject.create(false);
      this.colors = ArraySubject.create(BingComponent.createEarthColorsArray("#0000FF", [
        {
          elev: 0,
          color: "#000000"
        }
      ], 0, 3e4, 1));
      this.colorsElevationRange = Vec2Subject.create(Vec2Math.create(0, 3e4));
    }
  };
  var MapFlightPlanModule = class {
    constructor() {
      this.plans = [];
    }
    getPlanSubjects(index) {
      let planSubject = this.plans[index];
      if (planSubject === void 0) {
        planSubject = new PlanSubjects();
        this.plans[index] = planSubject;
      }
      return planSubject;
    }
  };
  var PlanSubjects = class {
    constructor() {
      this.flightPlan = Subject.create(void 0);
      this.planChanged = new SubEvent();
      this.planCalculated = new SubEvent();
      this.activeLeg = Subject.create(0);
    }
  };
  var MapFollowAirplaneModule = class {
    constructor() {
      this.isFollowing = Subject.create(false);
    }
  };
  var MapWaypointDisplayModule = class {
    constructor() {
      this.showAirports = Subject.create(() => true);
      this.showIntersections = Subject.create(() => false);
      this.showNdbs = Subject.create(() => true);
      this.showVors = Subject.create(() => true);
      this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.numAirports = Subject.create(40);
      this.numIntersections = Subject.create(40);
      this.numNdbs = Subject.create(40);
      this.numVors = Subject.create(40);
      this.intersectionsFilter = Subject.create({
        typeMask: NearestIntersectionSearchSession.Defaults.TypeMask,
        showTerminalWaypoints: true
      });
      this.vorsFilter = Subject.create({
        typeMask: NearestVorSearchSession.Defaults.TypeMask,
        classMask: NearestVorSearchSession.Defaults.ClassMask
      });
      this.airportsFilter = Subject.create({
        classMask: NearestAirportSearchSession.Defaults.ClassMask,
        showClosed: NearestAirportSearchSession.Defaults.ShowClosed
      });
      this.extendedAirportsFilter = Subject.create({
        runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
        approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
        minimumRunwayLength: NearestAirportSearchSession.Defaults.MinimumRunwayLength,
        toweredMask: NearestAirportSearchSession.Defaults.ToweredMask
      });
      this.waypointRoleSelector = Subject.create(void 0);
      this.refreshWaypoints = new SubEvent();
    }
  };
  var MapWxrModule = class {
    constructor() {
      this.isEnabled = Subject.create(false);
      this.weatherRadarArc = NumberUnitSubject.create(UnitType.DEGREE.createNumber(90));
      this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
      this.weatherRadarColors = ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this._wxrMode = MappedSubject.create(([isEnabled, arc, mode]) => {
        return {
          mode: isEnabled ? mode : EWeatherRadar.OFF,
          arcRadians: arc.asUnit(UnitType.RADIAN)
        };
      }, this.isEnabled, this.weatherRadarArc, this.weatherRadarMode);
    }
    get wxrMode() {
      return this._wxrMode;
    }
  };
  var WaypointDisplayBuilder = class {
    constructor(iconFactory, labelFactory, waypointRenderer) {
      this.iconFactory = iconFactory;
      this.labelFactory = labelFactory;
      this.waypointRenderer = waypointRenderer;
      this.roleGroup = MapSystemWaypointRoles.Normal;
      this.isCenterTarget = false;
    }
    addIcon(role, type, config) {
      this.iconFactory.addIconFactory(this.determineRoleId(role), type, config);
      return this;
    }
    addDefaultIcon(role, config) {
      this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config);
      return this;
    }
    addLabel(role, type, config) {
      this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config);
      return this;
    }
    addDefaultLabel(role, config) {
      this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config);
      return this;
    }
    determineRoleId(role) {
      let roleId = 0;
      if (typeof role === "string") {
        const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
        if (roleIdFromName !== void 0) {
          roleId = roleIdFromName;
        }
      } else {
        roleId = role;
      }
      return roleId;
    }
    registerRole(name) {
      this.waypointRenderer.addRenderRole(name, void 0, this.roleGroup);
      return this;
    }
    getRoleId(role) {
      const roleId = this.waypointRenderer.getRoleFromName(role);
      if (roleId === void 0) {
        throw new Error(`The role with name ${role} was not defined and could not be found.`);
      }
      return roleId;
    }
    withSearchCenter(center) {
      if (center === "center") {
        this.isCenterTarget = false;
      } else {
        this.isCenterTarget = true;
      }
      return this;
    }
    getIsCenterTarget() {
      return this.isCenterTarget;
    }
    withWaypointCache(cache) {
      this.facilityWaypointCache = cache;
      return this;
    }
    getWaypointCache() {
      return this.facilityWaypointCache;
    }
  };
  var FlightPlanDisplayBuilder = class extends WaypointDisplayBuilder {
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
      super(iconFactory, labelFactory, waypointRenderer);
      this.flightPlanRenderer = flightPlanRenderer;
      this.planIndex = planIndex;
      this.roleGroup = MapSystemWaypointRoles.FlightPlan;
      this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
      flightPlanRenderer.legStyleHandlers;
    }
    registerRole(name) {
      this.waypointRenderer.insertRenderRole(name, MapSystemWaypointRoles.Normal, void 0, this.roleGroup);
      return this;
    }
    withLegPathStyles(handler) {
      this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
      return this;
    }
    withLegWaypointRoles(handler) {
      this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
      return this;
    }
    withAnticipationTurns(visible) {
      const visibleSub = SubscribableUtils.toSubscribable(visible, true);
      this.flightPlanRenderer.renderEgress = visibleSub;
      this.flightPlanRenderer.renderIngress = visibleSub;
      return this;
    }
  };
  var GenericAirspaceRenderManager = class {
    constructor(renderOrder, selectRenderer) {
      this.renderOrder = renderOrder;
      this.selectRenderer = selectRenderer;
      this.airspaces = /* @__PURE__ */ new Map();
    }
    getRegisteredAirspaces() {
      return Array.from(this.airspaces.values());
    }
    registerAirspace(airspace) {
      if (this.airspaces.has(airspace.facility.id)) {
        return false;
      }
      this.airspaces.set(airspace.facility.id, airspace);
      return true;
    }
    deregisterAirspace(airspace) {
      return this.airspaces.delete(airspace.facility.id);
    }
    replaceRegisteredAirspaces(airspaces) {
      let changed = false;
      let numMatched = 0;
      for (const airspace of airspaces) {
        changed || (changed = !this.airspaces.has(airspace.facility.id));
        if (changed) {
          break;
        } else {
          numMatched++;
        }
      }
      changed || (changed = numMatched !== this.airspaces.size);
      if (!changed) {
        return false;
      }
      this.airspaces.clear();
      for (const airspace of airspaces) {
        this.registerAirspace(airspace);
      }
      return true;
    }
    clearRegisteredAirspaces() {
      if (this.airspaces.size === 0) {
        return false;
      }
      this.airspaces.clear();
      return true;
    }
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
      const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
      const tasks = sorted.map((airspace) => {
        const renderer = this.selectRenderer(airspace);
        return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
      });
      return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
  };
  var MapAutopilotPropsController = class extends MapSystemController {
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
      this.subs = {};
    }
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      if (this.updateFreq) {
        this.updateFreqSub = this.updateFreq.sub((freq) => {
          var _a;
          for (const property of this.properties) {
            (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
            this.subs[property] = this.bindProperty(sub, property, freq);
          }
        }, true);
      } else {
        for (const property of this.properties) {
          this.subs[property] = this.bindProperty(sub, property);
        }
      }
    }
    bindProperty(sub, property, updateFreq) {
      switch (property) {
        case "selectedAltitude":
          return (updateFreq === void 0 ? sub.on("ap_altitude_selected") : sub.on("ap_altitude_selected").atFrequency(updateFreq)).handle((alt) => {
            this.module.selectedAltitude.set(alt, UnitType.FOOT);
          });
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapSystemComponent = class extends MapComponent {
    constructor(props) {
      var _a;
      super(props);
      this.rootStyles = ObjectSubject.create({
        width: "0px",
        height: "0px"
      });
      this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
      this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    onAfterRender(thisNode) {
      super.onAfterRender(thisNode);
      this.onProjectedSizeChanged();
      this.props.onAfterRender();
    }
    onDeadZoneChanged(deadZone) {
      this.props.onDeadZoneChanged(deadZone);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    setRootSize(size) {
      this.rootStyles.set("width", `${size[0]}px`);
      this.rootStyles.set("height", `${size[1]}px`);
    }
    onProjectedSizeChanged() {
      this.setRootSize(this.mapProjection.getProjectedSize());
    }
    onUpdated(time, elapsed) {
      this.props.onBeforeUpdated(time, elapsed);
      super.onUpdated(time, elapsed);
      this.props.onAfterUpdated(time, elapsed);
    }
    onWake() {
      super.onWake();
      this.props.onWake();
    }
    onSleep() {
      super.onSleep();
      this.props.onSleep();
    }
    render() {
      var _a;
      return FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }, this.props.children);
    }
    destroy() {
      super.destroy();
      this.props.onDestroy();
    }
  };
  var DefaultMapSystemContext = class {
    constructor(bus, projection, projectedSize, deadZone) {
      this.bus = bus;
      this.projection = projection;
      this.projectedSize = projectedSize;
      this.deadZone = deadZone;
      this.model = new MapModel();
      this.layers = /* @__PURE__ */ new Map();
      this.controllers = /* @__PURE__ */ new Map();
    }
    getLayer(key) {
      return this.layers.get(key);
    }
    getController(key) {
      return this.controllers.get(key);
    }
    setLayer(key, layer) {
      this.layers.set(key, layer);
    }
    setController(key, controller) {
      this.controllers.set(key, controller);
    }
  };
  var MapSystemGenericController = class extends MapSystemController {
    constructor(context, callbacks) {
      super(context);
      this.callbacks = callbacks;
    }
    onAfterMapRender() {
      this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    onDeadZoneChanged(deadZone) {
      this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    onBeforeUpdated(time, elapsed) {
      this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    onAfterUpdated(time, elapsed) {
      this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    onWake() {
      this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    onSleep() {
      this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    onMapDestroyed() {
      this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    destroy() {
      super.destroy();
      this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
  };
  var MapSystemPlanRenderer = class extends AbstractFlightPathPlanRenderer {
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
      super(renderOrder, renderActiveLegLast);
      this.defaultRoleId = defaultRoleId;
      this.legRenderer = new MapSystemLegRenderer();
      this.legStyleHandlers = /* @__PURE__ */ new Map();
      this.legWaypointHandlers = /* @__PURE__ */ new Map();
      this.renderIngress = Subject.create(false);
      this.renderEgress = Subject.create(false);
    }
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
      this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
      const handler = this.legStyleHandlers.get(plan.planIndex);
      if (handler !== void 0) {
        this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
      }
      let partsToRender = FlightPathLegRenderPart.Base | (this.renderIngress.get() ? FlightPathLegRenderPart.Ingress : 0) | (this.renderEgress.get() ? FlightPathLegRenderPart.Egress : 0);
      if (this.legRenderer.currentRenderStyle.partsToRender !== void 0) {
        partsToRender = this.legRenderer.currentRenderStyle.partsToRender;
      }
      this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
  };
  var MapSystemLegRenderer = class extends AbstractFlightPathLegRenderer {
    constructor() {
      super(...arguments);
      this.vectorRenderer = new FlightPathVectorLineRenderer();
      this.currentRenderStyle = new FlightPathRenderStyle();
    }
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
      if ("styleBuilder" in this.currentRenderStyle) {
        const currentRenderStyle = this.currentRenderStyle.styleBuilder(vector, isIngress, isEgress);
        this.vectorRenderer.render(vector, context, streamStack, currentRenderStyle.width, currentRenderStyle.style, currentRenderStyle.dash, currentRenderStyle.outlineWidth, currentRenderStyle.outlineStyle);
      } else {
        if (this.currentRenderStyle.isDisplayed) {
          this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash, this.currentRenderStyle.outlineWidth, this.currentRenderStyle.outlineStyle);
        }
      }
    }
  };
  var FlightPathRenderStyle = class {
    constructor(isDisplayed = true) {
      this.isDisplayed = isDisplayed;
      this.width = 2;
      this.style = "";
    }
  };
  FlightPathRenderStyle.Default = new FlightPathRenderStyle();
  FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);
  var MapSystemUtils = class {
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
      return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
      return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    static nominalToTrueRelativeXY(nominal, size, deadZone, out) {
      return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size[1], deadZone), out);
    }
  };
  var MapSystemWaypointsRenderer = class extends MapWaypointRenderer {
    constructor(textManager) {
      super(textManager, (entry, roleDefinitions) => {
        var _a;
        for (let i = 0; i < this.rolePriorityOrder.length; i++) {
          const role = this.rolePriorityOrder[i];
          if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
            return role;
          }
        }
        return 0;
      });
      this.rolePriorityOrder = [];
      this.rolesByGroup = /* @__PURE__ */ new Map();
      this.roleIdMap = /* @__PURE__ */ new Map();
      this.currentBit = 1;
      this.onRolesAdded = new SubEvent();
    }
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      if (typeof arg1 === "number") {
        return false;
      }
      this.roleIdMap.set(arg1, this.currentBit);
      super.addRenderRole(this.currentBit, def);
      this.rolePriorityOrder.push(this.currentBit);
      let roleGroup = this.rolesByGroup.get(group);
      if (roleGroup === void 0) {
        roleGroup = [];
        this.rolesByGroup.set(group, roleGroup);
      }
      roleGroup.push(arg1);
      this.currentBit *= 2;
      this.onRolesAdded.notify(this);
      return true;
    }
    insertRenderRole(name, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      const role = this.currentBit;
      this.addRenderRole(name, def, group);
      const roleToInsertBefore = this.roleIdMap.get(insertBefore);
      if (roleToInsertBefore !== void 0) {
        const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
        if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
          this.rolePriorityOrder.pop();
          this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
        }
      }
      return true;
    }
    getRoleFromName(name) {
      return this.roleIdMap.get(name);
    }
    getRoleNamesByGroup(group) {
      const roleNames = this.rolesByGroup.get(group);
      if (roleNames !== void 0) {
        return roleNames;
      }
      return [];
    }
  };
  MapSystemWaypointsRenderer.DefaultGroup = "DEFAULT_GROUP";
  var MapSystemIconFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.iconFactories = /* @__PURE__ */ new Map();
      this.defaultIconFactories = /* @__PURE__ */ new Map();
    }
    addIconFactory(role, iconType, factory) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      roleFactories.set(iconType, factory);
    }
    addDefaultIconFactory(role, factory) {
      this.defaultIconFactories.set(role, factory);
    }
    getIcon(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let icon = roleCache.get(waypoint.uid);
      if (icon === void 0) {
        icon = this.createIcon(role, waypoint);
        roleCache.set(waypoint.uid, icon);
      }
      return icon;
    }
    createIcon(role, waypoint) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      const factory = roleFactories.get(waypoint.type);
      if (factory !== void 0) {
        return factory(waypoint);
      } else {
        const defaultFactory = this.defaultIconFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      const imageEl = document.createElement("img");
      imageEl.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC";
      return new MapWaypointImageIcon(waypoint, 0, imageEl, Vec2Math.create(24, 24));
    }
  };
  var MapSystemLabelFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.labelFactories = /* @__PURE__ */ new Map();
      this.defaultLabelFactories = /* @__PURE__ */ new Map();
    }
    addLabelFactory(role, iconType, factory) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      roleFactories.set(iconType, factory);
    }
    addDefaultLabelFactory(role, factory) {
      this.defaultLabelFactories.set(role, factory);
    }
    getLabel(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let label = roleCache.get(waypoint.uid);
      if (label === void 0) {
        label = this.createLabel(role, waypoint);
        roleCache.set(waypoint.uid, label);
      }
      return label;
    }
    createLabel(role, waypoint) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      const factory = roleFactories.get(waypoint.type);
      if (factory !== void 0) {
        return factory(waypoint);
      } else {
        const defaultFactory = this.defaultLabelFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      let text = "";
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        text = ICAO.getIdent(waypoint.facility.get().icao);
      }
      return new MapCullableLocationTextLabel(text, 0, waypoint.location, false, { fontSize: 22, font: "monospace", anchor: new Float64Array([-0.25, 0.4]) });
    }
  };
  var MapSystemBuilder = class {
    constructor(bus) {
      this.bus = bus;
      this.moduleFactories = /* @__PURE__ */ new Map();
      this.layerFactories = /* @__PURE__ */ new Map();
      this.controllerFactories = /* @__PURE__ */ new Map();
      this.contextFactories = /* @__PURE__ */ new Map();
      this.initCallbacks = /* @__PURE__ */ new Map();
      this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    get moduleCount() {
      return this.moduleFactories.size;
    }
    get layerCount() {
      return this.layerFactories.size;
    }
    get controllerCount() {
      return this.controllerFactories.size;
    }
    static create(bus) {
      return new MapSystemBuilder(bus);
    }
    withProjectedSize(size) {
      this.projectedSize = "isSubscribable" in size ? size : Subject.create(size);
      return this;
    }
    withDeadZone(deadZone) {
      this.deadZone = "isSubscribable" in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
      return this;
    }
    withTargetOffset(offset) {
      this.targetOffset = offset;
      return this;
    }
    withRangeEndpoints(endpoints) {
      this.nominalRangeEndpoints = endpoints;
      return this;
    }
    withRange(range) {
      this.range = range.asUnit(UnitType.GA_RADIAN);
      return this;
    }
    withModule(key, factory) {
      this.moduleFactories.set(key, { key, factory });
      return this;
    }
    withLayer(key, factory, order) {
      const wasDeleted = this.layerFactories.delete(key);
      this.layerFactories.set(key, { key, factory, order: order !== null && order !== void 0 ? order : this.layerFactories.size + (wasDeleted ? 1 : 0) });
      return this;
    }
    withController(key, factory) {
      this.controllerFactories.set(key, { factory });
      return this;
    }
    withContext(key, factory) {
      var _a;
      if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
        const existing = this.contextFactories.get(key);
        const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
        this.contextFactories.set(key, { key, factory, order });
      }
      return this;
    }
    withInit(key, callback) {
      this.initCallbacks.set(key, callback);
      return this;
    }
    withLayerOrder(key, order) {
      const factory = this.layerFactories.get(key);
      if (factory) {
        this.layerFactories.delete(key);
        factory.order = order;
        this.layerFactories.set(key, factory);
      }
      return this;
    }
    withBindings(key, bindings, onDestroy) {
      return this.withController(key, (context) => new MapBindingsController(context, bindings(context), onDestroy));
    }
    withClockUpdate(updateFreq) {
      return this.withContext("updateFreq", () => typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq).withController(MapSystemKeys.ClockUpdate, (context) => new MapClockUpdateController(context));
    }
    withTargetControlModerator() {
      return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(void 0));
    }
    withRotationControlModerator() {
      return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(void 0));
    }
    withRangeControlModerator() {
      return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(void 0));
    }
    withFollowAirplane() {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule()).withTargetControlModerator().withController(MapSystemKeys.FollowAirplane, (context) => new MapFollowAirplaneController(context));
    }
    withRotation() {
      return this.withModule(MapSystemKeys.Rotation, () => new MapRotationModule()).withRotationControlModerator().withController(MapSystemKeys.Rotation, (context) => new MapRotationController(context));
    }
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule()).withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
        return FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: iconFilePath, iconSize, iconAnchor, class: cssClass });
      }, order);
    }
    withOwnAirplaneIconOrientation(desiredOrientation) {
      return this.withController(MapSystemKeys.OwnAirplaneIconOrientation, (context) => new MapOwnAirplaneIconOrientationController(context, desiredOrientation));
    }
    withOwnAirplanePropBindings(properties, updateFreq) {
      return this.withController(MapSystemKeys.OwnAirplaneProps, (context) => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
    }
    withAutopilotProps(propertiesToBind, updateFreq) {
      this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
      if (propertiesToBind !== void 0) {
        this.withController(MapSystemKeys.AutopilotProps, (context) => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
      }
      return this;
    }
    withTextLayer(enableCulling, order, cssClass) {
      return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling)).withLayer(MapSystemKeys.TextLayer, (context) => {
        return FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager, class: cssClass });
      }, order);
    }
    withBing(bingId, delay = 0, mode, order, cssClass) {
      return this.withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule()).withModule(MapSystemKeys.Weather, () => new MapWxrModule()).withLayer(MapSystemKeys.Bing, (context) => {
        const terrainColors = context.model.getModule("terrainColors");
        const weather = context.model.getModule("weather");
        return FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, earthColorsElevationRange: terrainColors.colorsElevationRange, isoLines: terrainColors.showIsoLines, wxrMode: weather.wxrMode, wxrColors: weather.weatherRadarColors, mode, delay, class: cssClass });
      }, order);
    }
    withWaypoints() {
      return this.withContext(MapSystemKeys.WaypointRenderer, (context) => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager])).withController("waypointRendererUpdate", (context) => new MapSystemGenericController(context, {
        onAfterUpdated: (contextArg) => {
          contextArg[MapSystemKeys.WaypointRenderer].update(context.projection);
        }
      }));
    }
    withNearestWaypoints(configure, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling).withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule()).withWaypoints().withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory());
      let facilityWaypointCache = void 0;
      this.withContext("useTargetAsWaypointSearchCenter", (context) => {
        context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, void 0, MapSystemWaypointRoles.Normal);
        const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
        configure(builder);
        facilityWaypointCache = builder.getWaypointCache();
        return builder.getIsCenterTarget();
      });
      const layerCount = this.layerCount;
      return this.withLayer(MapSystemKeys.NearestWaypoints, (context) => {
        return FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter, waypointCache: facilityWaypointCache, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling, void 0, "flight-plan-text-layer").withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule()).withWaypoints().withContext(MapSystemKeys.FlightPlanner, () => flightPlanner).withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory()).withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1)).withController(MapSystemKeys.FlightPlan, (context) => new MapFlightPlanController(context)).withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
        context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, void 0, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
        configure(builder);
      });
      const layerCount = this.layerCount;
      return this.withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        return FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
      return this.withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes)).withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer)).withLayer(MapSystemKeys.Airspace, (context) => {
        var _a, _b;
        const optionsToUse = Object.assign({}, options);
        (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10));
        (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : optionsToUse.maxSearchItemCount = Subject.create(100);
        return FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse));
      }, order);
    }
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order, cssClass) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas)).withLayer("traffic", (context) => {
        const options = offScaleOobOptions !== void 0 ? Object.assign({}, offScaleOobOptions(context)) : {};
        if (options.oobOffset !== void 0 && !("isSubscribable" in options.oobOffset)) {
          options.oobOffset = Subject.create(options.oobOffset);
        }
        return FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context, model: context.model, mapProjection: context.projection, iconFactory, initCanvasStyles, class: cssClass }, options));
      }, order);
    }
    with(builder, ...args) {
      return builder(this, ...args);
    }
    build(cssClass) {
      const context = this.buildContext();
      const controllers = [];
      const ref = FSComponent.createRef();
      const onAfterRender = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterMapRender(ref.instance);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDeadZoneChanged = (deadZone) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onDeadZoneChanged(deadZone);
          } catch (e) {
            console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onMapProjectionChanged = (mapProjection, changeFlags) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onBeforeUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onBeforeUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
        context.projection.applyQueued();
      };
      const onAfterUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onWake = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onWake();
          } catch (e) {
            console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onSleep = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onSleep();
          } catch (e) {
            console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDestroy = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapDestroyed();
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const map = FSComponent.buildComponent(MapSystemComponent, { ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender, onDeadZoneChanged, onMapProjectionChanged, onBeforeUpdated, onAfterUpdated, onWake, onSleep, onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map((factory) => {
        const node = factory.factory(context);
        context.setLayer(factory.key, node.instance);
        return node;
      }));
      const controllerEntries = Array.from(this.controllerFactories).map(([key, factory]) => [key, factory.factory(context)]);
      for (const [key, controller] of controllerEntries) {
        context.setController(key, controller);
      }
      controllers.push(...controllerEntries.map(([, controller]) => controller));
      for (const callback of this.initCallbacks.values()) {
        callback(context);
      }
      return { context, map, ref };
    }
    buildContext() {
      var _a;
      const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
      context.projection.set({
        targetProjectedOffset: this.targetOffset,
        rangeEndpoints: this.nominalRangeEndpoints !== void 0 ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create()) : void 0,
        range: this.range
      });
      for (const factory of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
        context[factory.key] = factory.factory(context);
      }
      for (const factory of this.moduleFactories.values()) {
        context.model.addModule(factory.key, factory.factory());
      }
      return context;
    }
  };
  MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = /* @__PURE__ */ new Set([
    "bus",
    "model",
    "projection",
    "projectedSize",
    "deadZone",
    "getLayer",
    "setLayer",
    "getController",
    "setController"
  ]);
  var WarningType;
  (function(WarningType2) {
    WarningType2[WarningType2["Warning"] = 0] = "Warning";
    WarningType2[WarningType2["Caution"] = 1] = "Caution";
    WarningType2[WarningType2["Test"] = 2] = "Test";
    WarningType2[WarningType2["SoundOnly"] = 3] = "SoundOnly";
  })(WarningType || (WarningType = {}));
  var XMLCircularGaugeCursor;
  (function(XMLCircularGaugeCursor2) {
    XMLCircularGaugeCursor2[XMLCircularGaugeCursor2["Triangle"] = 1] = "Triangle";
  })(XMLCircularGaugeCursor || (XMLCircularGaugeCursor = {}));
  var XMLCircularGaugeValuePos;
  (function(XMLCircularGaugeValuePos2) {
    XMLCircularGaugeValuePos2[XMLCircularGaugeValuePos2["End"] = 1] = "End";
  })(XMLCircularGaugeValuePos || (XMLCircularGaugeValuePos = {}));
  var XMLHorizontalGaugeValuePos;
  (function(XMLHorizontalGaugeValuePos2) {
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["End"] = 1] = "End";
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLHorizontalGaugeValuePos || (XMLHorizontalGaugeValuePos = {}));
  var XMLVerticalGaugeValuePos;
  (function(XMLVerticalGaugeValuePos2) {
    XMLVerticalGaugeValuePos2[XMLVerticalGaugeValuePos2["None"] = 1] = "None";
  })(XMLVerticalGaugeValuePos || (XMLVerticalGaugeValuePos = {}));
  var XMLDoubleHorizontalGaugeValuePos;
  (function(XMLDoubleHorizontalGaugeValuePos2) {
    XMLDoubleHorizontalGaugeValuePos2[XMLDoubleHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLDoubleHorizontalGaugeValuePos || (XMLDoubleHorizontalGaugeValuePos = {}));
  var XMLGaugeType;
  (function(XMLGaugeType2) {
    XMLGaugeType2["Circular"] = "Circular";
    XMLGaugeType2["Horizontal"] = "Horizontal";
    XMLGaugeType2["DoubleHorizontal"] = "DoubleHorizontal";
    XMLGaugeType2["Vertical"] = "Vertical";
    XMLGaugeType2["DoubleVertical"] = "DoubleVertical";
    XMLGaugeType2["Text"] = "Text";
    XMLGaugeType2["ColumnGroup"] = "ColumnGroup";
    XMLGaugeType2["Column"] = "Column";
    XMLGaugeType2["Cylinder"] = "Cylinder";
    XMLGaugeType2["TwinCylinder"] = "TwinCylinder";
  })(XMLGaugeType || (XMLGaugeType = {}));
  var AlertState;
  (function(AlertState2) {
    AlertState2[AlertState2["New"] = 0] = "New";
    AlertState2[AlertState2["Acked"] = 1] = "Acked";
  })(AlertState || (AlertState = {}));
  var APVerticalModes;
  (function(APVerticalModes2) {
    APVerticalModes2[APVerticalModes2["NONE"] = 0] = "NONE";
    APVerticalModes2[APVerticalModes2["PITCH"] = 1] = "PITCH";
    APVerticalModes2[APVerticalModes2["VS"] = 2] = "VS";
    APVerticalModes2[APVerticalModes2["FLC"] = 3] = "FLC";
    APVerticalModes2[APVerticalModes2["ALT"] = 4] = "ALT";
    APVerticalModes2[APVerticalModes2["PATH"] = 5] = "PATH";
    APVerticalModes2[APVerticalModes2["GP"] = 6] = "GP";
    APVerticalModes2[APVerticalModes2["GS"] = 7] = "GS";
    APVerticalModes2[APVerticalModes2["CAP"] = 8] = "CAP";
    APVerticalModes2[APVerticalModes2["TO"] = 9] = "TO";
    APVerticalModes2[APVerticalModes2["GA"] = 10] = "GA";
    APVerticalModes2[APVerticalModes2["FPA"] = 11] = "FPA";
    APVerticalModes2[APVerticalModes2["FLARE"] = 12] = "FLARE";
  })(APVerticalModes || (APVerticalModes = {}));
  var APLateralModes;
  (function(APLateralModes2) {
    APLateralModes2[APLateralModes2["NONE"] = 0] = "NONE";
    APLateralModes2[APLateralModes2["ROLL"] = 1] = "ROLL";
    APLateralModes2[APLateralModes2["LEVEL"] = 2] = "LEVEL";
    APLateralModes2[APLateralModes2["GPSS"] = 3] = "GPSS";
    APLateralModes2[APLateralModes2["HEADING"] = 4] = "HEADING";
    APLateralModes2[APLateralModes2["VOR"] = 5] = "VOR";
    APLateralModes2[APLateralModes2["LOC"] = 6] = "LOC";
    APLateralModes2[APLateralModes2["BC"] = 7] = "BC";
    APLateralModes2[APLateralModes2["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes2[APLateralModes2["NAV"] = 9] = "NAV";
    APLateralModes2[APLateralModes2["TO"] = 10] = "TO";
    APLateralModes2[APLateralModes2["GA"] = 11] = "GA";
    APLateralModes2[APLateralModes2["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes2[APLateralModes2["TRACK"] = 13] = "TRACK";
    APLateralModes2[APLateralModes2["TRACK_HOLD"] = 14] = "TRACK_HOLD";
  })(APLateralModes || (APLateralModes = {}));
  var APAltitudeModes;
  (function(APAltitudeModes2) {
    APAltitudeModes2[APAltitudeModes2["NONE"] = 0] = "NONE";
    APAltitudeModes2[APAltitudeModes2["ALTS"] = 1] = "ALTS";
    APAltitudeModes2[APAltitudeModes2["ALTV"] = 2] = "ALTV";
  })(APAltitudeModes || (APAltitudeModes = {}));
  var APStates;
  (function(APStates2) {
    APStates2[APStates2["None"] = 0] = "None";
    APStates2[APStates2["APActive"] = 1] = "APActive";
    APStates2[APStates2["YawDamper"] = 2] = "YawDamper";
    APStates2[APStates2["Heading"] = 4] = "Heading";
    APStates2[APStates2["Nav"] = 8] = "Nav";
    APStates2[APStates2["NavArmed"] = 16] = "NavArmed";
    APStates2[APStates2["Approach"] = 32] = "Approach";
    APStates2[APStates2["ApproachArmed"] = 64] = "ApproachArmed";
    APStates2[APStates2["Backcourse"] = 128] = "Backcourse";
    APStates2[APStates2["BackcourseArmed"] = 256] = "BackcourseArmed";
    APStates2[APStates2["Alt"] = 512] = "Alt";
    APStates2[APStates2["AltS"] = 1024] = "AltS";
    APStates2[APStates2["AltV"] = 2048] = "AltV";
    APStates2[APStates2["VS"] = 4096] = "VS";
    APStates2[APStates2["FLC"] = 8192] = "FLC";
    APStates2[APStates2["GP"] = 16384] = "GP";
    APStates2[APStates2["GPArmed"] = 32768] = "GPArmed";
    APStates2[APStates2["GS"] = 65536] = "GS";
    APStates2[APStates2["GSArmed"] = 131072] = "GSArmed";
    APStates2[APStates2["Path"] = 262144] = "Path";
    APStates2[APStates2["PathArmed"] = 524288] = "PathArmed";
    APStates2[APStates2["PathInvalid"] = 1048576] = "PathInvalid";
    APStates2[APStates2["Pitch"] = 2097152] = "Pitch";
    APStates2[APStates2["Roll"] = 4194304] = "Roll";
    APStates2[APStates2["VNAV"] = 8388608] = "VNAV";
    APStates2[APStates2["ATSpeed"] = 16777216] = "ATSpeed";
    APStates2[APStates2["ATMach"] = 33554432] = "ATMach";
    APStates2[APStates2["ATArmed"] = 67108864] = "ATArmed";
    APStates2[APStates2["FD"] = 134217728] = "FD";
  })(APStates || (APStates = {}));
  var DirectorState;
  (function(DirectorState2) {
    DirectorState2["Inactive"] = "Inactive";
    DirectorState2["Armed"] = "Armed";
    DirectorState2["Active"] = "Active";
  })(DirectorState || (DirectorState = {}));
  var EmptyDirector = class {
    constructor() {
      this.onActivate = () => {
      };
      this.onArm = () => {
      };
      this.state = DirectorState.Inactive;
    }
    activate() {
    }
    deactivate() {
    }
    update() {
    }
    arm() {
    }
  };
  EmptyDirector.instance = new EmptyDirector();
  var VNavState;
  (function(VNavState2) {
    VNavState2[VNavState2["Disabled"] = 0] = "Disabled";
    VNavState2[VNavState2["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    VNavState2[VNavState2["Enabled_Active"] = 2] = "Enabled_Active";
  })(VNavState || (VNavState = {}));
  var VNavPathMode;
  (function(VNavPathMode2) {
    VNavPathMode2[VNavPathMode2["None"] = 0] = "None";
    VNavPathMode2[VNavPathMode2["PathArmed"] = 1] = "PathArmed";
    VNavPathMode2[VNavPathMode2["PathActive"] = 2] = "PathActive";
    VNavPathMode2[VNavPathMode2["PathInvalid"] = 3] = "PathInvalid";
  })(VNavPathMode || (VNavPathMode = {}));
  var ApproachGuidanceMode;
  (function(ApproachGuidanceMode2) {
    ApproachGuidanceMode2[ApproachGuidanceMode2["None"] = 0] = "None";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSArmed"] = 1] = "GSArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSActive"] = 2] = "GSActive";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPArmed"] = 3] = "GPArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPActive"] = 4] = "GPActive";
  })(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
  var VNavAltCaptureType;
  (function(VNavAltCaptureType2) {
    VNavAltCaptureType2[VNavAltCaptureType2["None"] = 0] = "None";
    VNavAltCaptureType2[VNavAltCaptureType2["Selected"] = 1] = "Selected";
    VNavAltCaptureType2[VNavAltCaptureType2["VNAV"] = 2] = "VNAV";
  })(VNavAltCaptureType || (VNavAltCaptureType = {}));
  var VNavAvailability;
  (function(VNavAvailability2) {
    VNavAvailability2["Available"] = "Available";
    VNavAvailability2["InvalidLegs"] = "InvalidLegs";
  })(VNavAvailability || (VNavAvailability = {}));
  var VNavUtils = class {
    static isUserConstraint(lateralLeg) {
      if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1 || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
        return true;
      }
      return false;
    }
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
      const delta = targetAltitude - currentAltitude;
      const minutesToConstraint = distance / groundSpeed * 60;
      return delta / minutesToConstraint;
    }
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
      return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    static getFpaFromVerticalSpeed(vs, groundspeed) {
      return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    static getFpa(distance, altitude) {
      return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    static altitudeForDistance(fpa, distance) {
      return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    static distanceForAltitude(fpa, altitude) {
      return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    static getMissedApproachLegIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
            return l;
          }
        }
      }
      return Math.max(0, plan.length - 1);
    }
    static getFafIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
            return l;
          }
        }
      }
      return void 0;
    }
    static getFafIndexReverse(lateralPlan, iterator) {
      let fafIndex = -1;
      iterator.iterateReverse(lateralPlan, (cursor) => {
        if (fafIndex === -1 && cursor.legDefinition && cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF) {
          fafIndex = cursor.legIndex + cursor.segment.offset;
        }
      });
      fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
      return fafIndex;
    }
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
        if (verticalPlan.constraints[c].index >= globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        if (verticalPlan.constraints[c].index < globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    static getIsPathEnd(verticalPlan, globalLegIndex) {
      const constraintIndex = verticalPlan.constraints.findIndex((c) => c.index === globalLegIndex);
      if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
        return true;
      }
      return false;
    }
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
      var _a, _b;
      return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    static getConstraintDistanceFromConstraint(constraint) {
      let distance = 0;
      for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
        distance += constraint.legs[legIndex].distance;
      }
      return distance;
    }
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
      let distance = 0;
      const startGlobalIndex = previousConstraint !== void 0 ? previousConstraint.index + 1 : 0;
      for (let i = startGlobalIndex; i <= constraint.index; i++) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
        distance += verticalLeg.distance;
      }
      return distance;
    }
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
      if (activeLegIndex > constraint.index) {
        return 0;
      }
      let distance = 0;
      let index = activeLegIndex;
      for (const leg of lateralPlan.legs(false, activeLegIndex)) {
        if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
          return Number.POSITIVE_INFINITY;
        } else if (leg.calculated !== void 0) {
          distance += leg.calculated.distanceWithTransitions;
        }
        if (++index > constraint.index) {
          break;
        }
      }
      distance -= distanceAlongLeg;
      return distance;
    }
    static getConstraintDetails(constraint, out) {
      if (constraint.maxAltitude === constraint.minAltitude) {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      } else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
        switch (constraint.type) {
          case "climb":
          case "missed":
            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            }
            break;
          default:
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            }
        }
      } else {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      }
      return out;
    }
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
      if (verticalPlan.constraints.length > 0) {
        if (selectedGlobalLegIndex < activeLegIndex) {
          return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
        }
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
          const constraint = verticalPlan.constraints[c];
          if (constraint.index === selectedGlobalLegIndex || c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index) {
            return constraint;
          } else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
            return verticalPlan.constraints[c + 1];
          }
        }
      }
      return void 0;
    }
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if ((constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.minAltitude : void 0;
    }
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint) {
        if (currentConstraint.type === "climb" && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return currentConstraint;
        } else if (currentConstraint.type === "climb" && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
          const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== void 0 ? VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
          for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === "climb" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              return constraint;
            }
          }
        }
      }
      return void 0;
    }
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if (constraint.type === "missed" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint.targetAltitude;
      }
      const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
      return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    static getFafAltitude(verticalPlan) {
      if (verticalPlan.fafLegIndex !== void 0) {
        return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
      }
      return void 0;
    }
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
      var _a;
      out.todLegIndex = -1;
      out.bodLegIndex = -1;
      out.todLegDistance = 0;
      out.distanceFromTod = 0;
      out.distanceFromBod = 0;
      out.currentConstraintLegIndex = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (!activeConstraint || (activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== void 0 && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex) {
        return out;
      }
      out.currentConstraintLegIndex = activeConstraint.index;
      const altitude = currentAltitude - currentVS / 20;
      let bodConstraintIndex, bodConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
          bodConstraintIndex = i;
          bodConstraint = constraint;
          break;
        }
      }
      if (!bodConstraint) {
        return out;
      }
      out.bodLegIndex = bodConstraint.index;
      let todConstraintIndex = bodConstraintIndex;
      for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const prevConstraint = verticalPlan.constraints[i + 1];
        if (!prevConstraint || prevConstraint.index < activeLegIndex || prevConstraint.type === "climb" || prevConstraint.type === "missed" || prevConstraint.targetAltitude > altitude || prevConstraint.fpa <= 0 || prevConstraint.isPathEnd) {
          todConstraintIndex = i;
          break;
        }
      }
      const todConstraint = verticalPlan.constraints[todConstraintIndex];
      let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
      let constraintIndex = todConstraintIndex;
      let todLegIndex = todConstraint.index;
      let todLegDistance = 0;
      let todLeg = todConstraint.legs[0];
      while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
        const constraint = verticalPlan.constraints[constraintIndex];
        for (let i = 0; i < constraint.legs.length; i++) {
          if (!constraint.legs[i].isEligible) {
            constraintIndex = verticalPlan.constraints.length;
            break;
          }
          todLeg = constraint.legs[i];
          distance -= todLeg.distance;
          if (distance <= 0) {
            todLegIndex = constraint.index - i;
            todLegDistance = todLeg.distance + distance;
            break;
          }
        }
        constraintIndex++;
      }
      if (distance > 0) {
        todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
        todLegDistance = todLeg.distance;
      }
      out.todLegIndex = todLegIndex;
      out.todLegDistance = todLegDistance;
      let globalLegIndex = bodConstraint.index;
      let distanceToBOD = 0, distanceToTOD = 0;
      let hasReachedTOD = false;
      let isDone = false;
      for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const constraint = verticalPlan.constraints[i];
        for (let j = 0; j < constraint.legs.length; j++) {
          const leg = constraint.legs[j];
          if (globalLegIndex === todLegIndex) {
            distanceToTOD -= todLegDistance;
            hasReachedTOD = true;
          }
          if (globalLegIndex > activeLegIndex) {
            distanceToBOD += leg.distance;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance;
            }
          } else if (globalLegIndex === activeLegIndex) {
            distanceToBOD += leg.distance - distanceAlongLeg;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance - distanceAlongLeg;
              isDone = true;
            } else {
              distanceToTOD -= distanceAlongLeg;
            }
          } else {
            if (hasReachedTOD) {
              isDone = true;
            } else {
              distanceToTOD -= leg.distance;
            }
          }
          if (isDone) {
            break;
          } else {
            globalLegIndex--;
          }
        }
        if (isDone) {
          break;
        }
      }
      out.distanceFromBod = distanceToBOD;
      out.distanceFromTod = distanceToTOD;
      return out;
    }
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
      var _a, _b;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (!activeConstraint || activeConstraint.type !== "climb" && activeConstraint.type !== "missed") {
        return out;
      }
      let tocConstraintIndex, tocConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (isFinite(constraint.maxAltitude)) {
          tocConstraintIndex = i;
          tocConstraint = constraint;
          break;
        }
      }
      if (!tocConstraint) {
        return out;
      }
      out.tocConstraintIndex = tocConstraintIndex;
      out.tocAltitude = tocConstraint.maxAltitude;
      const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
      let tocLegIndex;
      let currentConstraintIndex = activeConstraintIndex;
      let currentConstraint;
      let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
      let currentLeg = activeLeg;
      const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
      if (distanceRemaining > activeLegDistanceRemaining) {
        distanceRemaining -= activeLegDistanceRemaining;
        if (currentConstraintLegIndex <= 0) {
          --currentConstraintIndex;
        } else {
          currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
        }
        while (currentConstraintIndex >= tocConstraintIndex) {
          currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          currentLeg = currentConstraint.legs[currentConstraintLegIndex];
          if (currentLeg !== void 0) {
            if (distanceRemaining > currentLeg.distance) {
              out.distanceFromToc += currentLeg.distance;
              distanceRemaining -= currentLeg.distance;
            } else {
              out.distanceFromToc += distanceRemaining;
              tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
              distanceRemaining -= currentLeg.distance;
              break;
            }
          }
          if (currentConstraintLegIndex <= 0) {
            --currentConstraintIndex;
          } else {
            currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
          }
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = tocConstraint.index;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      let lastClimbConstraintIndex = tocConstraintIndex;
      let bocConstraintIndex, bocConstraint;
      for (let i = tocConstraintIndex - 1; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (constraint.maxAltitude > tocConstraint.maxAltitude) {
          bocConstraintIndex = i;
          bocConstraint = constraint;
          break;
        }
        lastClimbConstraintIndex = i;
      }
      let bocDistanceStopConstraintIndex = void 0;
      if (bocConstraint) {
        out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
        bocDistanceStopConstraintIndex = bocConstraintIndex;
      } else {
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
          out.bocLegIndex = lastClimbConstraint.index + 1;
          bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
        }
      }
      if (bocDistanceStopConstraintIndex !== void 0) {
        let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
          distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
        }
        out.distanceFromBoc = distanceToEndOfActiveConstraint;
        for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
          out.distanceFromBoc += verticalPlan.constraints[i].distance;
        }
      }
      return out;
    }
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
      const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
      const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
      const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
      if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
        return out;
      }
      const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
      const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
      if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
        const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
        out.bocLegIndex = lastClimbConstraint.index + 1;
        out.distanceFromBoc = activeLegDistanceRemaining + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
      }
      const deltaAltitude = cruiseAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      let tocLegIndex;
      const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
      if (distanceRemaining > activeLegDistanceRemaining) {
        let legIndex = activeLegIndex + 1;
        for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
          const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
          if (distanceRemaining > legDistance) {
            out.distanceFromToc += legDistance;
            distanceRemaining -= legDistance;
          } else {
            out.distanceFromToc += distanceRemaining;
            tocLegIndex = legIndex;
            distanceRemaining -= legDistance;
            break;
          }
          legIndex++;
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = lastLegIndex;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      out.tocAltitude = cruiseAltitude;
      return out;
    }
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset] !== void 0;
        }
      }
      return false;
    }
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset];
        }
      }
      throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
      const segment = verticalPlan.segments[segmentIndex];
      const leg = segment.legs[legIndex];
      if (segment && leg) {
        return leg;
      } else {
        throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
      }
    }
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
      return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    static getVerticalSegmentsFromPlan(verticalPlan) {
      return verticalPlan.segments;
    }
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
      if (lateralLeg.leg !== void 0) {
        switch (lateralLeg.leg.type) {
          case LegType.HA:
          case LegType.HF:
          case LegType.HM:
          case LegType.PI:
            return true;
        }
      }
      return false;
    }
    static createConstraint(index, minAltitude, maxAltitude, name, type = "descent") {
      return {
        index,
        minAltitude,
        maxAltitude,
        targetAltitude: 0,
        name,
        isTarget: false,
        isPathEnd: false,
        distance: 0,
        fpa: 0,
        legs: [],
        type,
        isBeyondFaf: false
      };
    }
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
      return {
        segmentIndex,
        legIndex,
        fpa: 0,
        altitude: 0,
        isUserDefined: false,
        isDirectToTarget: false,
        distance,
        isEligible: true,
        isBod: false,
        isAdvisory: true,
        name
      };
    }
    static getFirstClimbConstraintIndex(verticalPlan) {
      for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    static getLastClimbConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    static getFirstDescentConstraintIndex(verticalPlan) {
      let index = -1;
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        const type = verticalPlan.constraints[c].type;
        if (type === "descent" || type === "manual") {
          index = c;
        }
        if (type === "direct") {
          return c;
        }
      }
      return index;
    }
    static getLastDescentConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        const type = verticalPlan.constraints[i].type;
        if (type === "descent" || type === "direct" || type === "manual") {
          return i;
        }
      }
      return -1;
    }
    static speedConstraintEquals(a, b) {
      return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    static altitudeConstraintDetailsEquals(a, b) {
      return a.type === b.type && a.altitude === b.altitude;
    }
    static speedConstraintDetailsEquals(a, b) {
      return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint) && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    static getPathErrorDistance(groundSpeed) {
      if (groundSpeed <= 190) {
        return 100;
      } else if (groundSpeed >= 210) {
        return 250;
      } else {
        return 100 + (groundSpeed - 190) / 20 * 150;
      }
    }
  };
  var LNavTransitionMode;
  (function(LNavTransitionMode2) {
    LNavTransitionMode2[LNavTransitionMode2["None"] = 0] = "None";
    LNavTransitionMode2[LNavTransitionMode2["Ingress"] = 1] = "Ingress";
    LNavTransitionMode2[LNavTransitionMode2["Egress"] = 2] = "Egress";
    LNavTransitionMode2[LNavTransitionMode2["Unsuspend"] = 3] = "Unsuspend";
  })(LNavTransitionMode || (LNavTransitionMode = {}));
  var LNavVars;
  (function(LNavVars2) {
    LNavVars2["DTK"] = "L:WTAP_LNav_DTK";
    LNavVars2["XTK"] = "L:WTAP_LNav_XTK";
    LNavVars2["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    LNavVars2["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    LNavVars2["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    LNavVars2["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    LNavVars2["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    LNavVars2["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    LNavVars2["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    LNavVars2["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    LNavVars2["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    LNavVars2["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    LNavVars2["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    LNavVars2["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
  })(LNavVars || (LNavVars = {}));
  var LNavSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(LNavSimVarPublisher.simvars, bus);
    }
  };
  LNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnav_dtk", { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ["lnav_xtk", { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ["lnav_is_tracking", { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ["lnav_tracked_leg_index", { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ["lnav_transition_mode", { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ["lnav_tracked_vector_index", { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ["lnav_course_to_steer", { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ["lnav_is_suspended", { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ["lnav_leg_distance_along", { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_leg_distance_remaining", { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_distance_along", { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_vector_distance_remaining", { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_anticipation_distance", { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ["lnav_along_track_speed", { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
  ]);
  var LNavUtils = class {
    static getVectorsForTransitionMode(calc, mode, isSuspended) {
      switch (mode) {
        case LNavTransitionMode.None:
          return isSuspended ? calc.flightPath : calc.ingressToEgress;
        case LNavTransitionMode.Ingress:
          return calc.ingress;
        case LNavTransitionMode.Egress:
          return calc.egress;
        case LNavTransitionMode.Unsuspend:
          return calc.flightPath;
      }
    }
    static lnavTrackingStateEquals(a, b) {
      return a.isTracking === b.isTracking && a.globalLegIndex === b.globalLegIndex && a.transitionMode === b.transitionMode && a.vectorIndex === b.vectorIndex && a.isSuspended === b.isSuspended;
    }
  };
  var VNavVars;
  (function(VNavVars2) {
    VNavVars2["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    VNavVars2["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    VNavVars2["PathMode"] = "L:WTAP_VNav_Path_Mode";
    VNavVars2["VNAVState"] = "L:WTAP_VNav_State";
    VNavVars2["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    VNavVars2["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    VNavVars2["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    VNavVars2["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    VNavVars2["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    VNavVars2["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    VNavVars2["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    VNavVars2["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    VNavVars2["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    VNavVars2["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    VNavVars2["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    VNavVars2["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    VNavVars2["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    VNavVars2["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    VNavVars2["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    VNavVars2["FPA"] = "L:WTAP_VNav_FPA";
    VNavVars2["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    VNavVars2["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    VNavVars2["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    VNavVars2["GPDistance"] = "L:WTAP_GP_Distance";
    VNavVars2["GPFpa"] = "L:WTAP_GP_FPA";
    VNavVars2["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    VNavVars2["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
  })(VNavVars || (VNavVars = {}));
  var VNavSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(VNavSimVarPublisher.simvars, bus);
    }
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
  };
  VNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["vnav_vertical_deviation", { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ["vnav_target_altitude", { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ["vnav_path_mode", { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ["vnav_path_available", { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ["vnav_state", { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ["vnav_altitude_capture_type", { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ["vnav_tod_distance", { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_leg_distance", { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_bod_distance", { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_global_leg_index", { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ["vnav_bod_global_leg_index", { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ["vnav_toc_distance", { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_leg_distance", { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_boc_distance", { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_global_leg_index", { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_boc_global_leg_index", { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_global_leg_index", { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_altitude", { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_next_constraint_altitude", { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_fpa", { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ["vnav_required_vs", { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ["gp_approach_mode", { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ["gp_vertical_deviation", { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ["gp_distance", { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ["gp_fpa", { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ["gp_required_vs", { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ["gp_service_level", { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
  ]);
  var APHdgDirector = class {
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.toGaHeading = 0;
      this.bankServo = new LinearServo(APHdgDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaHeading = this.currentHeading;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaHeading = this.currentHeading;
          }
          this.setBank(this.desiredBank(this.toGaHeading));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgDirector.BANK_SERVO_RATE = 10;
  var APHdgHoldDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APHdgHoldDirector.BANK_SERVO_RATE);
      this.capturedHeading = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentHeadingSub = this.bus.getSubscriber().on("hdg_deg").withPrecision(0).handle((h) => this.currentHeading = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentHeadingSub.resume();
      this.capturedHeading = null;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentHeadingSub.pause();
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedHeading === null && Math.abs(this.currentBank) < APHdgHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedHeading = this.currentHeading;
        }
        this.setBank(this.capturedHeading !== null ? this.desiredBank(this.capturedHeading) : 0);
      }
    }
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgHoldDirector.BANK_SERVO_RATE = 10;
  APHdgHoldDirector.MIN_BANK_THRESHOLD = 1;
  var APNavDirector = class {
    constructor(bus, apValues, mode, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APNavDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      this.isNavLock = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.disableArming = (_b = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _b !== void 0 ? _b : false;
      this.forceNavSource = options === null || options === void 0 ? void 0 : options.forceNavSource;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        this.setNavLock(true);
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.setNavLock(false);
    }
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.disableArming || this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    canArm() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (this.mode === APLateralModes.LOC && typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      if (this.mode === APLateralModes.VOR && typeIsCorrect) {
        const indexIsCorrect = index == ((_f = this.cdi) === null || _f === void 0 ? void 0 : _f.source.index) && !((_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) && index == ((_h = this.obs) === null || _h === void 0 ? void 0 : _h.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(false);
          return true;
        }
      }
      if (this.mode === APLateralModes.LOC && this.apValues.navToNavLocArm && this.apValues.navToNavLocArm()) {
        this.isApproachMode.set(true);
        return true;
      }
      this.isApproachMode.set(false);
      return false;
    }
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index) || !((_f = this.loc) === null || _f === void 0 ? void 0 : _f.isValid) && index == ((_g = this.obs) === null || _g === void 0 ? void 0 : _g.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && (((_h = this.obs) === null || _h === void 0 ? void 0 : _h.heading) || ((_j = this.loc) === null || _j === void 0 ? void 0 : _j.course))) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? this.loc.course * Avionics.Utils.RAD2DEG : (_k = this.obs) === null || _k === void 0 ? void 0 : _k.heading;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_m = (_l = this.loc) === null || _l === void 0 ? void 0 : _l.isValid) !== null && _m !== void 0 ? _m : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    desiredBank() {
      var _a, _b, _c, _d, _e, _f, _g;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      const hasValidObs = this.obs !== void 0 && this.obs.heading !== null;
      let zoneOfConfusion = false;
      if (isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (!isLoc && (!hasValidDeviation || !hasValidObs)) {
        if (!this.checkForZoneOfConfusion()) {
          this.deactivate();
          return NaN;
        } else {
          zoneOfConfusion = true;
        }
      }
      if (zoneOfConfusion || this.cdi && this.cdi.deviation !== null) {
        const xtk = zoneOfConfusion ? 0 : this.cdi && this.cdi.deviation !== null ? this.getXtk(this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? this.loc.course * Avionics.Utils.RAD2DEG : (_d = this.obs) === null || _d === void 0 ? void 0 : _d.heading;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_f = (_e = this.cdi) === null || _e === void 0 ? void 0 : _e.deviation) !== null && _f !== void 0 ? _f : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_g = this.magVar) !== null && _g !== void 0 ? _g : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    monitorEvents() {
      const sub = this.bus.getSubscriber();
      if (this.forceNavSource) {
        this.navSource = {
          index: this.forceNavSource,
          type: NavSourceType.Nav
        };
        sub.on(`nav_radio_cdi_${this.forceNavSource}`).handle((cdi) => this.cdi = cdi);
        sub.on(`nav_radio_obs_${this.forceNavSource}`).handle((obs) => this.obs = obs);
        sub.on(`nav_radio_localizer_${this.forceNavSource}`).handle((loc) => this.loc = loc);
        sub.on(`nav_radio_nav_location_${this.forceNavSource}`).handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub.on(`nav_radio_magvar_${this.forceNavSource}`).handle((magVar) => {
          this.magVar = magVar;
        });
      } else {
        sub.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
        sub.on("nav_radio_active_obs_setting").handle((obs) => this.obs = obs);
        sub.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
        sub.on("cdi_select").handle((source) => {
          this.navSource = source;
          if (this.state === DirectorState.Active) {
            this.deactivate();
          }
        });
        sub.on("nav_radio_active_nav_location").handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub.on("nav_radio_active_magvar").handle((magVar) => {
          this.magVar = magVar;
        });
      }
      sub.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub.on("tas").handle((s) => this.tas = s);
      sub.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APNavDirector.BANK_SERVO_RATE = 10;
  var APRollDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.actualBank = 0;
      this.bankServo = new LinearServo(APRollDirector.BANK_SERVO_RATE);
      const minBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.minBankAngle) !== null && _a !== void 0 ? _a : 0;
      if (typeof minBankAngleOpt === "number") {
        this.minBankAngleFunc = () => minBankAngleOpt;
      } else {
        this.minBankAngleFunc = minBankAngleOpt;
      }
      const maxBankAngleOpt = options === null || options === void 0 ? void 0 : options.maxBankAngle;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
      const sub = this.bus.getSubscriber();
      sub.on("roll_deg").withPrecision(1).handle((roll) => {
        this.actualBank = roll;
      });
    }
    activate() {
      this.state = DirectorState.Active;
      const maxBank = this.maxBankAngleFunc();
      const minBank = this.minBankAngleFunc();
      if (Math.abs(this.actualBank) < minBank) {
        this.desiredBank = 0;
      } else {
        this.desiredBank = MathUtils.clamp(this.actualBank, -maxBank, maxBank);
      }
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", false);
    }
    update() {
      if (this.state === DirectorState.Active) {
        const maxBank = this.maxBankAngleFunc();
        const minBank = this.minBankAngleFunc();
        if (Math.abs(this.actualBank) < minBank) {
          this.desiredBank = 0;
        } else {
          this.desiredBank = MathUtils.clamp(this.actualBank, -maxBank, maxBank);
        }
        this.setBank(this.desiredBank);
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APRollDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APRollDirector.BANK_SERVO_RATE = 10;
  var APTrkDirector = class {
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.toGaTrack = 0;
      this.bankServo = new LinearServo(APTrkDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("track_deg_magnetic").withPrecision(0).handle((h) => {
        this.currentTrack = h;
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaTrack = this.currentTrack;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaTrack = this.currentTrack;
          }
          this.setBank(this.desiredBank(this.toGaTrack));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkDirector.BANK_SERVO_RATE = 10;
  var APTrkHoldDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APTrkHoldDirector.BANK_SERVO_RATE);
      this.capturedTrack = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentTrackSub = this.bus.getSubscriber().on("track_deg_magnetic").withPrecision(0).handle((h) => this.currentTrack = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentTrackSub.resume();
      this.capturedTrack = null;
      this.currentBankRef = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentTrackSub.pause();
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedTrack === null && Math.abs(this.currentBank) < APTrkHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedTrack = this.currentTrack;
        }
        this.setBank(this.capturedTrack !== null ? this.desiredBank(this.capturedTrack) : 0);
      }
    }
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkHoldDirector.BANK_SERVO_RATE = 10;
  APTrkHoldDirector.MIN_BANK_THRESHOLD = 1;
  var ArcTurnController = class {
    constructor() {
      this.bankController = new PidController(1.5, 0, 0, 15, -15);
      this.precessionController = new PidController(0.025, 0, 0, 300, -300);
      this.filter = new ExpSmoother(500);
    }
    getOutput(radiusError) {
      var _a;
      const currentTime = new Date().appTime();
      let bankAngle = 0;
      if (this.previousRadiusError !== void 0 && this.previousTime !== void 0) {
        const dTime = currentTime - this.previousTime;
        const input = (radiusError - this.previousRadiusError) / dTime * 1e3;
        const precessionRate = isNaN((_a = this.filter.last()) !== null && _a !== void 0 ? _a : NaN) ? this.filter.reset(input) : this.filter.next(input, dTime);
        const targetPrecessionRate = -this.precessionController.getOutput(dTime, radiusError);
        const precessionError = targetPrecessionRate - precessionRate;
        bankAngle = this.bankController.getOutput(dTime, precessionError);
      }
      this.previousTime = currentTime;
      this.previousRadiusError = radiusError;
      return -bankAngle;
    }
    reset() {
      this.previousTime = void 0;
      this.previousRadiusError = void 0;
      this.precessionController.reset();
      this.bankController.reset();
      this.filter.reset();
    }
  };
  var LNavDirector = class {
    constructor(bus, apValues, flightPlanner, obsDirector, options) {
      var _a, _b, _c;
      this.bus = bus;
      this.apValues = apValues;
      this.flightPlanner = flightPlanner;
      this.obsDirector = obsDirector;
      this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.publisher = this.bus.getPublisher();
      this.aircraftState = {
        tas: 0,
        gs: 0,
        track: 0,
        magvar: 0,
        windSpeed: 0,
        windDirection: 0,
        planePos: new GeoPoint(0, 0),
        hdgTrue: 0,
        altAgl: 0,
        bank: 0
      };
      this.currentLeg = void 0;
      this.currentVector = void 0;
      this.dtk = 0;
      this.xtk = 0;
      this.bearingToVectorEnd = 0;
      this.courseToSteer = 0;
      this.alongVectorDistance = 0;
      this.vectorDistanceRemaining = 0;
      this.vectorAnticipationDistance = 0;
      this.alongTrackSpeed = 0;
      this.anticipationVector = void 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      this.inhibitNextSequence = false;
      this.currentBankRef = 0;
      this.bankServo = new LinearServo(LNavDirector.BANK_SERVO_RATE);
      this.currentState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.anticipationState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.currentBankAngleState = {
        arcController: new ArcTurnController(),
        isInterceptingFromArmedState: false,
        trackAtActivation: 0,
        desiredBankAngle: 0
      };
      this.lnavData = ObjectSubject.create({
        dtk: 0,
        xtk: 0,
        trackingState: {
          isTracking: false,
          globalLegIndex: 0,
          transitionMode: LNavTransitionMode.None,
          vectorIndex: 0,
          isSuspended: false
        },
        isTracking: false,
        legIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        courseToSteer: 0,
        isSuspended: false,
        alongLegDistance: 0,
        legDistanceRemaining: 0,
        alongVectorDistance: 0,
        vectorDistanceRemaining: 0,
        vectorAnticipationDistance: 0,
        alongTrackSpeed: 0
      });
      this.isObsDirectorTracking = false;
      this.canArm = false;
      this.awaitCalculateId = 0;
      this.isAwaitingCalculate = false;
      this.isNavLock = Subject.create(false);
      this.lnavDataHandler = (obj, key, value) => {
        switch (key) {
          case "dtk":
            SimVar.SetSimVarValue(LNavVars.DTK, SimVarValueType.Degree, value);
            break;
          case "xtk":
            SimVar.SetSimVarValue(LNavVars.XTK, SimVarValueType.NM, value);
            break;
          case "isTracking":
            SimVar.SetSimVarValue(LNavVars.IsTracking, SimVarValueType.Bool, value);
            break;
          case "legIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number, value);
            break;
          case "transitionMode":
            SimVar.SetSimVarValue(LNavVars.TransitionMode, SimVarValueType.Number, value);
            break;
          case "vectorIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedVectorIndex, SimVarValueType.Number, value);
            break;
          case "courseToSteer":
            SimVar.SetSimVarValue(LNavVars.CourseToSteer, SimVarValueType.Degree, value);
            break;
          case "isSuspended":
            SimVar.SetSimVarValue(LNavVars.IsSuspended, SimVarValueType.Bool, value);
            break;
          case "alongLegDistance":
            SimVar.SetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM, value);
            break;
          case "legDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "alongVectorDistance":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceAlong, SimVarValueType.NM, value);
            break;
          case "vectorDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "vectorAnticipationDistance":
            SimVar.SetSimVarValue(LNavVars.VectorAnticipationDistance, SimVarValueType.NM, value);
            break;
          case "alongTrackSpeed":
            SimVar.SetSimVarValue(LNavVars.AlongTrackSpeed, SimVarValueType.Knots, value);
            break;
          case "trackingState":
            this.publisher.pub("lnav_tracking_state", value, true, true);
            break;
        }
      };
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.hasVectorAnticipation = (_b = options === null || options === void 0 ? void 0 : options.hasVectorAnticipation) !== null && _b !== void 0 ? _b : false;
      this.minimumActivationAltitude = options === null || options === void 0 ? void 0 : options.minimumActivationAltitude;
      this.disableArming = (_c = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _c !== void 0 ? _c : false;
      const sub = bus.getSubscriber();
      this.lnavData.sub(this.lnavDataHandler, true);
      sub.on("ambient_wind_velocity").handle((w) => this.aircraftState.windSpeed = w);
      sub.on("ambient_wind_direction").handle((wd) => this.aircraftState.windDirection = wd);
      sub.on("tas").handle((tas) => this.aircraftState.tas = tas);
      sub.on("hdg_deg_true").handle((hdg) => this.aircraftState.hdgTrue = hdg);
      sub.on("ground_speed").handle((gs) => this.aircraftState.gs = gs);
      sub.on("radio_alt").handle((alt) => this.aircraftState.altAgl = alt);
      sub.on("roll_deg").handle((roll) => this.aircraftState.bank = roll);
      const nav = this.bus.getSubscriber();
      nav.on("cdi_select").handle((src) => {
        if (this.state !== DirectorState.Inactive && src.type !== NavSourceType.Gps) {
          this.deactivate();
        }
      });
      sub.on("suspend_sequencing").handle((suspend) => {
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
        if (flightPlan) {
          if (suspend) {
            this.currentState.inhibitedSuspendLegIndex = -1;
          }
          this.trySetSuspended(flightPlan, this.currentState, suspend, this.currentState, false, false);
        }
      });
      sub.on("activate_missed_approach").handle((v) => {
        this.currentState.isMissedApproachActive = v;
      });
      sub.on("lnav_inhibit_next_sequence").handle((inhibit) => {
        this.inhibitNextSequence = inhibit;
        if (inhibit) {
          this.currentState.inhibitedSuspendLegIndex = -1;
        }
      });
      sub.on("fplActiveLegChange").handle((e) => {
        if (e.planIndex === this.flightPlanner.activePlanIndex && e.type === ActiveLegType.Lateral) {
          this.currentState.inhibitedSuspendLegIndex = -1;
          this.resetVectors();
        }
      });
      sub.on("fplIndexChanged").handle(() => {
        this.resetVectors();
      });
      sub.on("fplCopied").handle((e) => {
        if (e.targetPlanIndex === this.flightPlanner.activePlanIndex) {
          this.resetVectors();
        }
      });
      sub.on("gps-position").handle((lla) => {
        this.aircraftState.planePos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => this.aircraftState.track = t);
      sub.on("magvar").handle((m) => this.aircraftState.magvar = m);
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
      this.state = DirectorState.Inactive;
    }
    resetVectors() {
      this.currentState.vectorIndex = 0;
      this.currentState.transitionMode = LNavTransitionMode.Ingress;
      this.inhibitNextSequence = false;
      this.awaitCalculate();
    }
    activate() {
      this.currentBankAngleState.isInterceptingFromArmedState = !this.disableArming;
      this.currentBankAngleState.trackAtActivation = this.aircraftState.track;
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.currentBankAngleState.isInterceptingFromArmedState = false;
        if (this.canArm) {
          this.state = DirectorState.Armed;
          if (this.onArm !== void 0) {
            this.onArm();
          }
          this.setNavLock(true);
        }
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      if (this.obsDirector && this.obsDirector.state !== DirectorState.Inactive) {
        this.obsDirector.deactivate();
      }
      this.currentBankAngleState.isInterceptingFromArmedState = false;
      this.setNavLock(false);
    }
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    update() {
      var _a;
      let clearInhibitNextSequence = false;
      const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
      this.currentState.globalLegIndex = flightPlan ? flightPlan.activeLateralLeg : 0;
      let isTracking = !!flightPlan && this.currentState.globalLegIndex <= flightPlan.length - 1;
      if (flightPlan && isTracking) {
        if (this.isAwaitingCalculate) {
          return;
        }
        this.currentLeg = flightPlan.getLeg(this.currentState.globalLegIndex);
        clearInhibitNextSequence = !!this.currentLeg.calculated;
        this.calculateTracking(flightPlan);
        if (this.isAwaitingCalculate) {
          return;
        }
        if (this.hasVectorAnticipation) {
          this.updateVectorAnticipation(flightPlan);
        }
        isTracking = this.currentState.globalLegIndex < flightPlan.length && this.currentVector !== void 0 && this.currentVector.radius > LNavDirector.ANGULAR_TOLERANCE && this.currentVector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
        if (isTracking) {
          const calcs = this.currentLeg.calculated;
          if (this.obsDirector) {
            this.obsDirector.setLeg(this.currentState.globalLegIndex, this.currentLeg);
            if (this.obsDirector.obsActive) {
              this.currentState.isSuspended = true;
              this.currentState.inhibitedSuspendLegIndex = this.currentState.globalLegIndex;
              if (!this.isObsDirectorTracking) {
                this.lnavData.unsub(this.lnavDataHandler);
                this.isObsDirectorTracking = true;
                this.obsDirector.startTracking();
              }
              if (this.state === DirectorState.Active && this.obsDirector.state !== DirectorState.Active) {
                this.obsDirector.activate();
                this.setNavLock(true);
              }
              if (this.state === DirectorState.Armed && this.obsDirector.canActivate()) {
                this.obsDirector.activate();
                this.state = DirectorState.Active;
                if (this.onActivate !== void 0) {
                  this.onActivate();
                }
                this.setNavLock(true);
              }
              this.obsDirector.update();
              return;
            }
          }
          isTracking = calcs !== void 0;
          if (this.state !== DirectorState.Inactive) {
            this.navigateFlightPath();
          }
        }
      } else {
        this.currentState.isSuspended = false;
        clearInhibitNextSequence = true;
      }
      if (this.isObsDirectorTracking) {
        this.currentState.isSuspended = false;
      }
      this.canArm = isTracking;
      this.lnavData.set("isTracking", isTracking);
      this.lnavData.set("isSuspended", this.currentState.isSuspended);
      if (isTracking) {
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking !== isTracking || trackingState.globalLegIndex !== this.currentState.globalLegIndex || trackingState.transitionMode !== this.currentState.transitionMode || trackingState.vectorIndex !== this.currentState.vectorIndex || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking,
            globalLegIndex: this.currentState.globalLegIndex,
            transitionMode: this.currentState.transitionMode,
            vectorIndex: this.currentState.vectorIndex,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", this.dtk);
        this.lnavData.set("xtk", this.xtk);
        this.lnavData.set("legIndex", this.currentState.globalLegIndex);
        this.lnavData.set("vectorIndex", this.currentState.vectorIndex);
        this.lnavData.set("transitionMode", this.currentState.transitionMode);
        this.lnavData.set("courseToSteer", this.courseToSteer);
        this.lnavData.set("alongVectorDistance", this.alongVectorDistance);
        this.lnavData.set("vectorDistanceRemaining", this.vectorDistanceRemaining);
        this.lnavData.set("vectorAnticipationDistance", this.vectorAnticipationDistance);
        this.lnavData.set("alongTrackSpeed", this.alongTrackSpeed);
        this.lnavData.set("alongLegDistance", this.getAlongLegDistance(flightPlan, this.currentState, this.alongVectorDistance));
        this.lnavData.set("legDistanceRemaining", this.getLegDistanceRemaining(flightPlan, this.currentState, this.vectorDistanceRemaining));
      } else {
        this.currentLeg = void 0;
        this.currentVector = void 0;
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking || trackingState.globalLegIndex !== 0 || trackingState.transitionMode !== LNavTransitionMode.None || trackingState.vectorIndex !== 0 || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking: false,
            globalLegIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", 0);
        this.lnavData.set("xtk", 0);
        this.lnavData.set("legIndex", 0);
        this.lnavData.set("vectorIndex", 0);
        this.lnavData.set("transitionMode", LNavTransitionMode.None);
        this.lnavData.set("courseToSteer", 0);
        this.lnavData.set("alongLegDistance", 0);
        this.lnavData.set("vectorDistanceRemaining", 0);
        this.lnavData.set("alongVectorDistance", 0);
        this.lnavData.set("legDistanceRemaining", 0);
        this.lnavData.set("vectorAnticipationDistance", 0);
        this.lnavData.set("alongTrackSpeed", 0);
      }
      if (this.isObsDirectorTracking) {
        (_a = this.obsDirector) === null || _a === void 0 ? void 0 : _a.stopTracking();
        this.lnavData.sub(this.lnavDataHandler, true);
        this.isObsDirectorTracking = false;
      }
      if (this.state === DirectorState.Armed) {
        this.tryActivate();
      }
      this.inhibitNextSequence && (this.inhibitNextSequence = !clearInhibitNextSequence);
    }
    navigateFlightPath() {
      let bankAngle;
      if (this.anticipationVector && this.vectorAnticipationDistance > 0 && this.vectorDistanceRemaining <= this.vectorAnticipationDistance && Math.abs(this.xtk) < UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)) {
        this.updateBankAngle(this.anticipationVector, this.anticipationDtk, this.anticipationXtk, this.anticipationBearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (bankAngle === void 0) {
        if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
          return;
        }
        this.updateBankAngle(this.currentVector, this.dtk, this.xtk, this.bearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (this.state === DirectorState.Active) {
        this.setBank(bankAngle);
      }
    }
    updateBankAngle(vector, dtk, xtk, bearingToVectorEnd, bankAngleState) {
      let absInterceptAngle;
      let naturalAbsInterceptAngle = 0;
      if (this.lateralInterceptCurve !== void 0) {
        naturalAbsInterceptAngle = this.lateralInterceptCurve(dtk, xtk, this.aircraftState.tas);
      } else {
        naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
        if (naturalAbsInterceptAngle <= 2.5) {
          naturalAbsInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
        }
      }
      if (bankAngleState.isInterceptingFromArmedState) {
        absInterceptAngle = Math.abs(NavMath.diffAngle(bankAngleState.trackAtActivation, dtk));
        if (absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5 || absInterceptAngle < Math.abs(NavMath.diffAngle(dtk, bearingToVectorEnd))) {
          absInterceptAngle = naturalAbsInterceptAngle;
          bankAngleState.isInterceptingFromArmedState = false;
        }
      } else {
        absInterceptAngle = naturalAbsInterceptAngle;
      }
      const interceptAngle = xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
      const courseToSteer = NavMath.normalizeHeading(dtk + interceptAngle);
      bankAngleState.desiredBankAngle = this.desiredBank(courseToSteer);
      if (vector !== void 0 && !FlightPathUtils.isVectorGreatCircle(vector)) {
        this.adjustBankAngleForArc(vector, bankAngleState);
      }
      return bankAngleState;
    }
    desiredBank(desiredTrack) {
      const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
      const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    adjustBankAngleForArc(vector, bankAngleState) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
      const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const radius = UnitType.GA_RADIAN.convertTo(FlightPathUtils.getTurnRadiusFromCircle(circle), UnitType.METER);
      const relativeWindHeading = NavMath.normalizeHeading(this.aircraftState.windDirection - this.aircraftState.hdgTrue);
      const headwind = this.aircraftState.windSpeed * Math.cos(relativeWindHeading * Avionics.Utils.DEG2RAD);
      const distance = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.METER);
      const bankAdjustment = bankAngleState.arcController.getOutput(distance);
      const turnBankAngle = NavMath.bankAngle(this.aircraftState.tas - headwind, radius) * (turnDirection === "left" ? 1 : -1);
      const turnRadius = NavMath.turnRadius(this.aircraftState.tas - headwind, 25);
      const bankBlendFactor = Math.max(1 - Math.abs(UnitType.NMILE.convertTo(this.xtk, UnitType.METER)) / turnRadius, 0);
      const maxBank = this.maxBankAngleFunc();
      bankAngleState.desiredBankAngle = MathUtils.clamp(bankAngleState.desiredBankAngle * (1 - bankBlendFactor) + turnBankAngle * bankBlendFactor + bankAdjustment, -maxBank, maxBank);
      return bankAngleState;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = LNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    calculateTracking(plan) {
      var _a, _b;
      let didAdvance;
      do {
        didAdvance = false;
        if (!this.currentLeg) {
          break;
        }
        if (this.currentLeg.leg.type === LegType.IF && this.currentState.globalLegIndex === 0 && plan.length > 1) {
          this.currentLeg = plan.getLeg(++this.currentState.globalLegIndex);
          plan.setCalculatingLeg(this.currentState.globalLegIndex);
          plan.setLateralLeg(this.currentState.globalLegIndex);
          continue;
        }
        const transitionMode = this.currentState.transitionMode;
        const legIndex = this.currentState.globalLegIndex;
        const vectorIndex = this.currentState.vectorIndex;
        const isSuspended = this.currentState.isSuspended;
        const calcs = this.currentLeg.calculated;
        if (calcs) {
          const vectors = LNavUtils.getVectorsForTransitionMode(calcs, this.currentState.transitionMode, this.currentState.isSuspended);
          const vector = vectors[this.currentState.vectorIndex];
          const isVectorValid = vector && vector.radius > LNavDirector.ANGULAR_TOLERANCE && vector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
          const isUnsuspendInvalid = this.currentState.transitionMode === LNavTransitionMode.Unsuspend && (calcs.ingress.length === 0 || calcs.flightPath[calcs.ingressJoinIndex] === void 0);
          if (isVectorValid && !isUnsuspendInvalid) {
            const planePos = this.aircraftState.planePos;
            const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
            let endLat, endLon;
            let end;
            let vectorDistanceNM;
            if (transitionMode === LNavTransitionMode.Unsuspend && vectorIndex === calcs.ingressJoinIndex && calcs.ingress.length > 0) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              endLat = lastIngressVector.endLat;
              endLon = lastIngressVector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.NMILE);
            } else {
              endLat = vector.endLat;
              endLon = vector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.METER.convertTo(vector.distance, UnitType.NMILE);
            }
            this.xtk = UnitType.GA_RADIAN.convertTo(circle.distance(planePos), UnitType.NMILE);
            this.dtk = circle.bearingAt(planePos, Math.PI);
            this.bearingToVectorEnd = planePos.bearingTo(endLat, endLon);
            const alongTrackSpeed = FlightPathUtils.projectVelocityToCircle(this.aircraftState.gs, planePos, this.aircraftState.track, circle);
            this.alongTrackSpeed = isNaN(alongTrackSpeed) ? this.aircraftState.gs : alongTrackSpeed;
            const normDist = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, planePos);
            this.alongVectorDistance = normDist * vectorDistanceNM;
            this.vectorDistanceRemaining = (1 - normDist) * vectorDistanceNM;
            if (normDist > 1) {
              this.advanceToNextVector(plan, this.currentState, true, this.currentState);
            }
          } else {
            this.alongVectorDistance = 0;
            this.vectorDistanceRemaining = 0;
            this.vectorAnticipationDistance = 0;
            this.advanceToNextVector(plan, this.currentState, true, this.currentState);
          }
          didAdvance = transitionMode !== this.currentState.transitionMode || legIndex !== this.currentState.globalLegIndex || vectorIndex !== this.currentState.vectorIndex || isSuspended !== this.currentState.isSuspended;
          if (legIndex !== this.currentState.globalLegIndex) {
            this.currentLeg = (_a = plan.tryGetLeg(this.currentState.globalLegIndex)) !== null && _a !== void 0 ? _a : void 0;
            plan.setCalculatingLeg(this.currentState.globalLegIndex);
            plan.setLateralLeg(this.currentState.globalLegIndex);
          }
        }
      } while (!this.isAwaitingCalculate && didAdvance && this.currentState.globalLegIndex <= plan.length - 1);
      if (this.currentState.transitionMode === LNavTransitionMode.Egress && this.currentState.globalLegIndex + 1 < plan.length && plan.activeCalculatingLeg !== this.currentState.globalLegIndex + 1) {
        plan.setCalculatingLeg(this.currentState.globalLegIndex + 1);
      }
      this.currentVector = ((_b = this.currentLeg) === null || _b === void 0 ? void 0 : _b.calculated) ? LNavUtils.getVectorsForTransitionMode(this.currentLeg.calculated, this.currentState.transitionMode, this.currentState.isSuspended)[this.currentState.vectorIndex] : void 0;
    }
    updateVectorAnticipation(plan) {
      var _a;
      this.anticipationVector = void 0;
      this.vectorAnticipationDistance = 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        return;
      }
      this.advanceToNextVector(plan, this.currentState, false, this.anticipationState);
      const anticipationCalcs = (_a = plan.tryGetLeg(this.anticipationState.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!anticipationCalcs) {
        return;
      }
      const anticipationVectors = LNavUtils.getVectorsForTransitionMode(anticipationCalcs, this.anticipationState.transitionMode, this.anticipationState.isSuspended);
      this.anticipationVector = anticipationVectors[this.anticipationState.vectorIndex];
      if (!this.anticipationVector || this.anticipationVector === this.currentVector || this.anticipationVector.radius === 0 || this.anticipationVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        this.anticipationVector = void 0;
        return;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(this.anticipationVector, this.geoCircleCache[0]);
      this.anticipationXtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.NMILE);
      this.anticipationDtk = circle.bearingAt(this.aircraftState.planePos, Math.PI);
      this.anticipationBearingToVectorEnd = this.aircraftState.planePos.bearingTo(this.anticipationVector.endLat, this.anticipationVector.endLon);
      const maxBankAngle = this.maxBankAngleFunc();
      const currentVectorIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.currentVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const anticipationIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.anticipationVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const deltaBank = Math.abs(currentVectorIdealBankAngle - anticipationIdealBankAngle);
      const rollTimeSeconds = deltaBank / LNavDirector.VECTOR_ANTICIPATION_BANK_RATE;
      this.vectorAnticipationDistance = Math.min(
        rollTimeSeconds / 3600 * this.alongTrackSpeed,
        UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)
      );
    }
    applyEndOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      const inhibitNextSequence = this.inhibitNextSequence && leg.leg.type !== LegType.ThruDiscontinuity;
      if (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM || leg.leg.type === LegType.Discontinuity) {
        return this.trySetSuspended(plan, state, true, out, true, false);
      } else if (inhibitNextSequence) {
        return this.trySetSuspended(plan, state, true, out, false, true);
      } else if (state.globalLegIndex < plan.length - 1) {
        const nextLeg = plan.getLeg(state.globalLegIndex + 1);
        if (!state.isMissedApproachActive && (leg.leg.fixTypeFlags === FixTypeFlags.MAP || !BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach) && BitFlags.isAll(nextLeg.flags, LegDefinitionFlags.MissedApproach))) {
          return this.trySetSuspended(plan, state, true, out, true, false);
        }
      }
      return out;
    }
    applyStartOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.getLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      if (leg.leg.type === LegType.HM || state.globalLegIndex === plan.length - 1) {
        return this.trySetSuspended(plan, state, true, out, false, false);
      }
      return out;
    }
    advanceToNextVector(plan, state, awaitCalculateOnNextLeg, out) {
      var _a, _b, _c, _d, _e, _f;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      let leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      let legIndex = state.globalLegIndex;
      let transitionMode = state.transitionMode;
      let isSuspended = state.isSuspended;
      let vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
      let vectorIndex = state.vectorIndex + 1;
      let vectorEndIndex = (_a = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _a !== void 0 ? _a : 0;
      let didAdvance = false;
      let isDone = false;
      if (transitionMode === LNavTransitionMode.Unsuspend && leg.calculated) {
        if (leg.calculated.ingressJoinIndex < 0) {
          vectorEndIndex = 0;
        } else {
          const ingress = leg.calculated.ingress;
          const ingressJoinVector = leg.calculated.flightPath[leg.calculated.ingressJoinIndex];
          if (ingress.length > 0 && ingressJoinVector && GeoPoint.equals(ingress[ingress.length - 1].endLat, ingress[ingress.length - 1].endLon, ingressJoinVector.startLat, ingressJoinVector.startLon)) {
            vectorEndIndex = leg.calculated.ingressJoinIndex;
          } else {
            vectorEndIndex = leg.calculated.ingressJoinIndex + 1;
          }
        }
      }
      while (!vectors || vectorIndex >= vectorEndIndex || vectors[vectorIndex].radius === 0 || vectors[vectorIndex].distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        switch (transitionMode) {
          case LNavTransitionMode.Ingress:
            transitionMode = LNavTransitionMode.None;
            vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
            vectorIndex = Math.max(0, isSuspended ? (_c = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.ingressJoinIndex) !== null && _c !== void 0 ? _c : 0 : 0);
            didAdvance = true;
            break;
          case LNavTransitionMode.Unsuspend:
            transitionMode = LNavTransitionMode.None;
            vectors = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.ingressToEgress;
            vectorIndex = 0;
            didAdvance = true;
            break;
          case LNavTransitionMode.None:
            if (!isSuspended) {
              transitionMode = LNavTransitionMode.Egress;
              vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
              vectorIndex = 0;
              didAdvance = true;
            } else if (leg.leg.type === LegType.HM) {
              vectors = (_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath;
              vectorIndex = 0;
              didAdvance = true;
            } else {
              if (!didAdvance && vectors) {
                vectorIndex = Math.max(0, vectors.length - 1);
              }
              isDone = true;
            }
            break;
          case LNavTransitionMode.Egress:
            out.globalLegIndex = legIndex;
            out.transitionMode = transitionMode;
            out.vectorIndex = vectorIndex;
            out.isSuspended = isSuspended;
            this.advanceToNextLeg(plan, out, out);
            if (awaitCalculateOnNextLeg || out.globalLegIndex === legIndex) {
              return out;
            }
            leg = plan.tryGetLeg(out.globalLegIndex);
            if (!(leg === null || leg === void 0 ? void 0 : leg.calculated)) {
              return out;
            } else {
              legIndex = out.globalLegIndex;
              transitionMode = out.transitionMode;
              vectors = LNavUtils.getVectorsForTransitionMode(leg.calculated, out.transitionMode, out.isSuspended);
              vectorIndex = out.vectorIndex;
              isSuspended = out.isSuspended;
              didAdvance = false;
            }
        }
        if (isDone) {
          break;
        }
        vectorEndIndex = (_f = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _f !== void 0 ? _f : 0;
      }
      out.globalLegIndex = legIndex;
      out.transitionMode = transitionMode;
      out.vectorIndex = vectorIndex;
      out.isSuspended = isSuspended;
      return out;
    }
    advanceToNextLeg(plan, state, out) {
      var _a, _b, _c;
      this.applyEndOfLegSuspends(plan, state, out);
      if (!out.isSuspended) {
        if (out.globalLegIndex + 1 >= plan.length) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = Math.max(0, ((_c = (_b = (_a = plan.tryGetLeg(out.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) !== null && _c !== void 0 ? _c : 0) - 1);
          return out;
        }
        out.globalLegIndex++;
        out.transitionMode = LNavTransitionMode.Ingress;
        out.vectorIndex = 0;
        out.inhibitedSuspendLegIndex = -1;
        this.applyStartOfLegSuspends(plan, out, out);
      }
      return out;
    }
    trySetSuspended(plan, state, suspend, out, inhibitResuspend = false, resetVectorsOnSuspendEnd = false) {
      var _a;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      if (suspend && state.globalLegIndex === state.inhibitedSuspendLegIndex) {
        return out;
      }
      if (suspend) {
        out.inhibitedSuspendLegIndex = inhibitResuspend ? state.globalLegIndex : -1;
        out.resetVectorsOnSuspendEnd = resetVectorsOnSuspendEnd;
      }
      if (state.isSuspended !== suspend) {
        out.isSuspended = suspend;
        if (!suspend && state.resetVectorsOnSuspendEnd) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = 0;
          out.resetVectorsOnSuspendEnd = false;
        } else {
          const leg = plan.tryGetLeg(state.globalLegIndex);
          const legCalc = leg === null || leg === void 0 ? void 0 : leg.calculated;
          const ingressJoinVector = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath[legCalc.ingressJoinIndex];
          if (legCalc && state.transitionMode === LNavTransitionMode.None && legCalc.ingressJoinIndex >= 0 && ingressJoinVector && legCalc.ingress.length > 0) {
            const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
            let vectors;
            let offset;
            if (suspend) {
              vectors = legCalc.flightPath;
              if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                offset = legCalc.ingressJoinIndex + 1;
              } else {
                offset = legCalc.ingressJoinIndex;
              }
            } else {
              let pastIngressJoin = state.vectorIndex > legCalc.ingressJoinIndex;
              if (!pastIngressJoin && state.vectorIndex === legCalc.ingressJoinIndex && legCalc.flightPath[legCalc.ingressJoinIndex]) {
                const vector = legCalc.flightPath[legCalc.ingressJoinIndex];
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                const end = GeoPoint.sphericalToCartesian(ingressJoinVector.endLat, ingressJoinVector.endLon, this.vec3Cache[1]);
                pastIngressJoin = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.aircraftState.planePos) >= 1;
              }
              if (pastIngressJoin) {
                vectors = legCalc.ingressToEgress;
                if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                  offset = -(legCalc.ingressJoinIndex + 1);
                } else {
                  offset = -legCalc.ingressJoinIndex;
                }
              } else {
                vectors = legCalc.flightPath;
                offset = 0;
                out.transitionMode = LNavTransitionMode.Unsuspend;
              }
            }
            out.vectorIndex = Math.max(0, Math.min(state.vectorIndex + offset, vectors.length - 1));
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Unsuspend) {
            out.transitionMode = LNavTransitionMode.None;
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Egress) {
            out.transitionMode = LNavTransitionMode.None;
            out.vectorIndex = Math.max(0, ((_a = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath.length) !== null && _a !== void 0 ? _a : 1) - 1);
          }
        }
      }
      return out;
    }
    tryActivate() {
      if (this.disableArming) {
        this.activate();
        return;
      }
      if (this.minimumActivationAltitude === void 0 || this.aircraftState.altAgl >= this.minimumActivationAltitude) {
        const headingDiff = NavMath.diffAngle(this.aircraftState.track, this.dtk);
        if (Math.abs(this.xtk) < 0.6 && Math.abs(headingDiff) < 110) {
          this.activate();
        }
      }
    }
    async awaitCalculate() {
      if (!this.flightPlanner.hasActiveFlightPlan()) {
        return;
      }
      this.isAwaitingCalculate = true;
      const id = ++this.awaitCalculateId;
      const plan = this.flightPlanner.getActiveFlightPlan();
      try {
        await plan.calculate();
      } catch (_a) {
      }
      if (id !== this.awaitCalculateId) {
        return;
      }
      this.isAwaitingCalculate = false;
    }
    getAlongLegDistance(plan, state, alongVectorDistance) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, false);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let distanceAlong = 0;
      for (let i = state.vectorIndex - 1; i >= 0; i--) {
        distanceAlong += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Egress:
          vectors = calcs.ingressToEgress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          vectors = calcs.ingress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
      }
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex; i < calcs.ingressJoinIndex; i++) {
            distanceAlong -= vectors[i].distance;
          }
          if (state.vectorIndex <= calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceAlong -= UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
        }
      }
      return UnitType.METER.convertTo(distanceAlong, UnitType.NMILE) + alongVectorDistance;
    }
    getLegDistanceRemaining(plan, state, vectorDistanceRemaining) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, state.isSuspended);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let vectorIndex = state.vectorIndex;
      let distanceRemaining = 0;
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex + 1; i < calcs.ingressJoinIndex; i++) {
            distanceRemaining += vectors[i].distance;
          }
          if (state.vectorIndex < calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
          vectorIndex = -1;
        }
        vectors = calcs.ingressToEgress;
      }
      for (let i = vectorIndex + 1; i < vectors.length; i++) {
        distanceRemaining += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Ingress:
          vectors = LNavUtils.getVectorsForTransitionMode(calcs, LNavTransitionMode.None, state.isSuspended);
          for (let i = Math.max(0, state.isSuspended ? calcs.ingressJoinIndex : 0); i < vectors.length; i++) {
            const currentVector = vectors[i];
            if (state.isSuspended && i === calcs.ingressJoinIndex) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              if (lastIngressVector) {
                const circle = FlightPathUtils.setGeoCircleFromVector(currentVector, this.geoCircleCache[0]);
                distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(this.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon), this.geoPointCache[1].set(currentVector.endLat, currentVector.endLon), Math.PI), UnitType.METER);
                continue;
              }
            }
            distanceRemaining += currentVector.distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          if (!state.isSuspended) {
            vectors = calcs.egress;
            for (let i = 0; i < vectors.length; i++) {
              distanceRemaining += vectors[i].distance;
            }
          }
      }
      return UnitType.METER.convertTo(distanceRemaining, UnitType.NMILE) + vectorDistanceRemaining;
    }
    static copyStateInfo(source, target) {
      target.globalLegIndex = source.globalLegIndex;
      target.transitionMode = source.transitionMode;
      target.vectorIndex = source.vectorIndex;
      target.isSuspended = source.isSuspended;
      target.inhibitedSuspendLegIndex = source.inhibitedSuspendLegIndex;
      target.resetVectorsOnSuspendEnd = source.resetVectorsOnSuspendEnd;
      target.isMissedApproachActive = source.isMissedApproachActive;
      return target;
    }
    static getVectorIdealBankAngle(vector, groundSpeed) {
      if (FlightPathUtils.isVectorGreatCircle(vector)) {
        return 0;
      }
      if (vector.radius < MathUtils.HALF_PI) {
        return NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(vector.radius, UnitType.METER));
      } else {
        return -NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(Math.PI - vector.radius, UnitType.METER));
      }
    }
  };
  LNavDirector.ANGULAR_TOLERANCE = GeoCircle.ANGULAR_TOLERANCE;
  LNavDirector.ANGULAR_TOLERANCE_METERS = UnitType.GA_RADIAN.convertTo(GeoCircle.ANGULAR_TOLERANCE, UnitType.METER);
  LNavDirector.BANK_SERVO_RATE = 10;
  LNavDirector.VECTOR_ANTICIPATION_BANK_RATE = 5;
  var APBackCourseDirector = class {
    constructor(bus, apValues, mode, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APBackCourseDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", false);
    }
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    canArm() {
      var _a, _b, _c, _d, _e;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      this.isApproachMode.set(false);
      return false;
    }
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && ((_f = this.loc) === null || _f === void 0 ? void 0 : _f.course)) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_h = (_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) !== null && _h !== void 0 ? _h : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    desiredBank() {
      var _a, _b, _c, _d, _e, _f;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      if (!isLoc || isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (this.cdi && this.cdi.deviation !== null) {
        const xtk = this.cdi && this.cdi.deviation !== null ? this.getXtk(-this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_e = -((_d = this.cdi) === null || _d === void 0 ? void 0 : _d.deviation)) !== null && _e !== void 0 ? _e : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_f = this.magVar) !== null && _f !== void 0 ? _f : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APBackCourseDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    monitorEvents() {
      const sub = this.bus.getSubscriber();
      sub.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
      sub.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
      sub.on("cdi_select").handle((source) => {
        this.navSource = source;
        if (this.state === DirectorState.Active) {
          this.deactivate();
        }
      });
      sub.on("nav_radio_active_nav_location").handle((loc) => {
        this.navLocation.set(loc.lat, loc.long);
      });
      sub.on("nav_radio_active_magvar").handle((magVar) => {
        this.magVar = magVar;
      });
      sub.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub.on("tas").handle((s) => this.tas = s);
      sub.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APBackCourseDirector.BANK_SERVO_RATE = 10;
  var APLvlDirector = class {
    constructor(bus, isToGaMode = false) {
      this.bus = bus;
      this.isToGaMode = isToGaMode;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.bankServo = new LinearServo(APLvlDirector.BANK_SERVO_RATE);
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.desiredBank = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", true);
      }
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", false);
      }
    }
    update() {
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank);
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APLvlDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APLvlDirector.BANK_SERVO_RATE = 10;
  var SmoothingPathCalculator = class {
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.primaryPlanIndex = primaryPlanIndex;
      this.verticalFlightPlans = [];
      this.planBuilt = new SubEvent();
      this.vnavCalculated = new SubEvent();
      this.legAltitudes = [0, 0];
      this.applyPathValuesResult = [void 0, 0];
      this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
      this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
      this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
      this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
      this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
      this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
      this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : () => true;
      this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
      this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
      const fpl = this.bus.getSubscriber();
      fpl.on("fplCreated").handle((e) => this.createVerticalPlan(e.planIndex));
      fpl.on("fplCopied").handle((e) => this.onPlanChanged(e.targetPlanIndex));
      fpl.on("fplLoaded").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplLegChange").handle((e) => this.onPlanChanged(e.planIndex, e));
      fpl.on("fplSegmentChange").handle((e) => this.onPlanChanged(e.planIndex, void 0, e));
      fpl.on("fplIndexChanged").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplCalculated").handle((e) => this.onPlanCalculated(e));
      bus.getSubscriber().on("vnav_set_default_fpa").handle(this.setDefaultFpa.bind(this));
      bus.getSubscriber().on("vnav_set_vnav_direct_to").handle((data) => {
        if (data.globalLegIndex < 0) {
          this.cancelVerticalDirect(data.planIndex);
        } else {
          this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
        }
      });
    }
    getVerticalFlightPlan(planIndex) {
      var _a;
      var _b;
      return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : _b[planIndex] = this.createVerticalPlan(planIndex);
    }
    createVerticalPlan(planIndex) {
      const verticalFlightPlan = {
        planIndex,
        length: 0,
        constraints: [],
        segments: [],
        destLegIndex: void 0,
        fafLegIndex: void 0,
        firstDescentConstraintLegIndex: void 0,
        lastDescentConstraintLegIndex: void 0,
        missedApproachStartIndex: void 0,
        currentAlongLegDistance: void 0,
        verticalDirectIndex: void 0,
        verticalDirectFpa: void 0,
        planChanged: true
      };
      this.verticalFlightPlans[planIndex] = verticalFlightPlan;
      return verticalFlightPlan;
    }
    requestPathCompute(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== void 0) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        this.computePathAndNotify(lateralPlan, verticalPlan);
        return true;
      }
      return false;
    }
    getTargetConstraintIndex(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
          const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
          if (priorConstraint && priorConstraint.type !== "climb" && priorConstraint.type !== "missed") {
            return priorConstraintIndex;
          } else {
            return -1;
          }
        }
        let i = verticalPlan.constraints.length - 1;
        while (i >= 0) {
          const constraint = verticalPlan.constraints[i];
          if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== "climb" && constraint.type !== "missed") {
            return i;
          }
          i--;
        }
      } else {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraintIndex >= 0) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isMissed = currentConstraint.type === "missed";
          for (let i = currentConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === "climb" || isMissed && constraint.type === "missed") {
              if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return i;
              }
            } else {
              return -1;
            }
          }
        }
      }
      return -1;
    }
    getTargetConstraint(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    getTargetAltitude(planIndex, globalLegIndex) {
      var _a, _b;
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
      } else {
        return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
      }
    }
    getFlightPhase(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex)) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
        if (globalLegIndex > -1) {
          const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
          switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
            case "climb":
            case "missed":
              return VerticalFlightPhase.Climb;
          }
        }
      }
      return VerticalFlightPhase.Descent;
    }
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return void 0;
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
      } else {
        return currentConstraint.targetAltitude;
      }
    }
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return { type: AltitudeRestrictionType.Unused, altitude: 0 };
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        if (priorConstraint) {
          return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        } else {
          return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
      } else {
        return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
      }
    }
    getNextConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint !== void 0) {
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
          if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
            return currentConstraint.maxAltitude;
          } else {
            return currentConstraint.minAltitude;
          }
        } else {
          if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
            return currentConstraint.minAltitude;
          } else {
            return currentConstraint.maxAltitude;
          }
        }
      }
      return void 0;
    }
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
      if (currentConstraint) {
        const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
        if (currentConstraintIndex > -1) {
          if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "climb" || constraint.type === "missed") {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          } else {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
                if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          }
        }
      }
      return void 0;
    }
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
      if (constraintGlobalLegIndex < 0) {
        return;
      }
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
      verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    cancelVerticalDirect(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex === void 0) {
        return;
      }
      verticalPlan.verticalDirectIndex = void 0;
      verticalPlan.verticalDirectFpa = void 0;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    setDefaultFpa(fpa) {
      const newFpa = Math.max(0, fpa);
      if (newFpa !== this.flightPathAngle) {
        this.flightPathAngle = newFpa;
        for (let i = 0; i < this.verticalFlightPlans.length; i++) {
          const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : void 0;
          const verticalPlan = this.verticalFlightPlans[i];
          if (lateralPlan && verticalPlan) {
            if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
              verticalPlan.planChanged = true;
              this.notifyCalculated(i);
            }
          }
        }
      }
    }
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
      const plan = this.flightPlanner.getFlightPlan(planIndex);
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex !== void 0) {
        if (legChangeEvent !== void 0) {
          const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
          if (globalIndex <= verticalPlan.verticalDirectIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        } else if (segmentChangeEvent !== void 0) {
          const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
          if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        }
      }
      verticalPlan.planChanged = true;
      verticalPlan.currentAlongLegDistance = void 0;
    }
    onPlanCalculated(event) {
      const lateralPlan = this.flightPlanner.getFlightPlan(event.planIndex);
      const verticalPlan = this.getVerticalFlightPlan(event.planIndex);
      if (verticalPlan.planChanged) {
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      } else {
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      }
    }
    notifyBuilt(planIndex) {
      this.planBuilt.notify(this, planIndex);
    }
    notifyCalculated(planIndex) {
      this.vnavCalculated.notify(this, planIndex);
    }
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
      this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
      this.notifyBuilt(verticalPlan.planIndex);
    }
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
      this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
      SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
      verticalPlan.planChanged = false;
    }
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
      var _a, _b, _c, _d, _e, _f, _g;
      verticalPlan.constraints.length = 0;
      verticalPlan.segments.length = 0;
      verticalPlan.destLegIndex = void 0;
      verticalPlan.firstDescentConstraintLegIndex = void 0;
      verticalPlan.lastDescentConstraintLegIndex = void 0;
      verticalPlan.missedApproachStartIndex = void 0;
      verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
      const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
      let firstApproachGlobalLegIndex;
      for (const segment of lateralPlan.segments()) {
        verticalPlan.segments[segment.segmentIndex] = {
          offset: segment.offset,
          legs: []
        };
        if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === void 0) {
          firstApproachGlobalLegIndex = segment.offset;
        }
        for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
          const globalLegIndex = segment.offset + segmentLegIndex;
          const lateralLeg = segment.legs[segmentLegIndex];
          const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : "", (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : void 0);
          if (verticalPlan.missedApproachStartIndex === void 0 && segment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            verticalPlan.missedApproachStartIndex = globalLegIndex;
          }
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
          verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
          const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== void 0 && globalLegIndex < verticalPlan.verticalDirectIndex;
          const legPrecedesDirectTo = directToTargetLegIndex !== void 0 && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
          if (constraintAltitudes !== void 0 && !legPrecedesVerticalDirectIndex && !legPrecedesDirectTo && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
            verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
            const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.unshift(verticalConstraint);
          }
          verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
        }
      }
      verticalPlan.length = lateralPlan.length;
      if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== void 0) {
        const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
        if (firstApproachConstraint && firstApproachConstraint.type !== "climb" && firstApproachConstraint.type !== "missed") {
          SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
        }
      }
      verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
      verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
      var _a;
      const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? "missed" : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? "descent" : "climb");
      constraint.isBeyondFaf = verticalPlan.fafLegIndex === void 0 ? false : globalLegIndex > verticalPlan.fafLegIndex;
      if (verticalPlan.verticalDirectIndex === globalLegIndex) {
        constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
        constraint.type = "direct";
      }
      const userFpa = lateralLeg.verticalData.fpa;
      if (userFpa !== void 0 && constraint.type !== "climb" && constraint.type !== "missed") {
        constraint.fpa = userFpa;
        constraint.type = "manual";
      }
      return constraint;
    }
    computePathAndNotify(lateralPlan, verticalPlan) {
      if (this.computePath(lateralPlan, verticalPlan)) {
        this.notifyCalculated(lateralPlan.planIndex);
        return true;
      } else {
        return false;
      }
    }
    computePath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return false;
      }
      this.computeDescentPath(lateralPlan, verticalPlan);
      return true;
    }
    computeDescentPath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return;
      }
      this.fillLegDistances(lateralPlan, verticalPlan);
      this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
      this.findAndRemoveInvalidConstraints(verticalPlan);
      this.populateConstraints(verticalPlan);
      if (this.computeFlightPathAngles(verticalPlan)) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
          const constraint = verticalPlan.constraints[constraintIndex];
          if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
            let altitude = constraint.targetAltitude;
            let constraintIsBod = true;
            if (constraintIndex > 0) {
              const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
              if (nextConstraint !== void 0 && nextConstraint.type !== "climb") {
                const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                if (nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25 || constraint.fpa === 0) {
                  constraintIsBod = false;
                }
              }
            }
            if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
              constraint.isPathEnd = true;
              constraint.isTarget = true;
              constraintIsBod = true;
            }
            for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
              const leg = constraint.legs[legIndex];
              leg.fpa = constraint.fpa;
              leg.altitude = altitude;
              altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
              if (legIndex === 0) {
                leg.isAdvisory = false;
              } else {
                leg.isAdvisory = true;
              }
              if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                leg.isBod = true;
              } else {
                leg.isBod = false;
              }
            }
          }
        }
      }
    }
    fillLegDistances(lateralPlan, verticalPlan) {
      var _a, _b, _c;
      if (lateralPlan.length > 0) {
        for (const segment of lateralPlan.segments()) {
          if (segment) {
            const vnavSegment = verticalPlan.segments[segment.segmentIndex];
            for (let l = 0; l < segment.legs.length; l++) {
              const leg = segment.legs[l];
              if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
              } else if (leg && leg.calculated && leg.calculated.endLat !== void 0 && leg.calculated.endLon !== void 0) {
                let prevLeg;
                for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                  if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== void 0 && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== void 0) {
                    prevLeg = checkLeg;
                    break;
                  }
                }
                if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                  vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                }
              } else {
                vnavSegment.legs[l].distance = 0;
              }
            }
          }
        }
      }
    }
    findAndRemoveInvalidConstraints(verticalPlan) {
      var _a, _b, _c;
      let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? firstDescentConstraintIndex : verticalPlan.constraints.length - 1;
      let phase = "climb";
      let priorMinAltitude = -Infinity;
      let priorMaxAltitude = Infinity;
      let distanceFromPriorMinAltitude = 0;
      let requiredFpa = 0;
      for (let i = startIndex; i >= 0; i--) {
        const currentConstraint = verticalPlan.constraints[i];
        const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
        let currentPhase;
        switch (currentConstraint.type) {
          case "climb":
          case "missed":
            currentPhase = currentConstraint.type;
            break;
          default:
            currentPhase = "descent";
        }
        if (currentPhase !== phase) {
          phase = currentPhase;
          priorMinAltitude = -Infinity;
          priorMaxAltitude = Infinity;
          distanceFromPriorMinAltitude = currentConstraintDistance;
        } else {
          distanceFromPriorMinAltitude += currentConstraintDistance;
        }
        let isDescentConstraint;
        let shouldInvalidate;
        switch (phase) {
          case "climb":
          case "missed":
            isDescentConstraint = false;
            shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
            break;
          default:
            isDescentConstraint = true;
            if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
              requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
            } else {
              requiredFpa = 0;
            }
            shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
        }
        const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
        if (shouldInvalidate) {
          constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
          verticalPlan.constraints.splice(i, 1);
          distanceFromPriorMinAltitude -= currentConstraintDistance;
          if (isDescentConstraint && i === firstDescentConstraintIndex) {
            firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
            verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
          }
        } else {
          constraintLeg.invalidConstraintAltitude = void 0;
          if (isFinite(currentConstraint.minAltitude)) {
            priorMinAltitude = currentConstraint.minAltitude;
            distanceFromPriorMinAltitude = 0;
          }
          if (isFinite(currentConstraint.maxAltitude)) {
            priorMaxAltitude = currentConstraint.maxAltitude;
          }
        }
      }
      verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
      var _a;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? verticalPlan.firstDescentConstraintLegIndex + 1 : 0;
      let globalLegIndex = startIndex;
      for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        if (verticalLeg.invalidConstraintAltitude !== void 0) {
          const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          if (constraintAltitudes !== void 0) {
            const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
            if (proposedConstraint.type === "descent" || proposedConstraint.type === "manual" || proposedConstraint.type === "direct" || proposedConstraint.type === "dest") {
              if (verticalPlan.firstDescentConstraintLegIndex === void 0 || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
              }
              if (verticalPlan.lastDescentConstraintLegIndex === void 0 || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
              }
            }
          }
        }
        globalLegIndex++;
      }
    }
    populateConstraints(verticalPlan) {
      for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
        const constraint = verticalPlan.constraints[constraintIndex];
        const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
        constraint.legs.length = 0;
        constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
        let eligibleLegIndex;
        let ineligibleLegIndex;
        for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== void 0 ? previousConstraint.index : -1); globalLegIndex--) {
          const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
          constraint.legs.push(verticalLeg);
          if (ineligibleLegIndex === void 0 && verticalLeg.isEligible) {
            eligibleLegIndex = globalLegIndex;
          }
          if (ineligibleLegIndex === void 0 && !verticalLeg.isEligible) {
            ineligibleLegIndex = globalLegIndex;
          }
        }
        if (ineligibleLegIndex !== void 0 && eligibleLegIndex !== void 0) {
          constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
        }
      }
    }
    computeFlightPathAngles(verticalPlan) {
      let currentTargetConstraint;
      let currentPathSegmentDistance = 0;
      let currentPathSegmentMinFpa = this.minFlightPathAngle;
      let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
      let currentTargetConstraintHasFixedFpa = false;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
      if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
        return false;
      }
      for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
        const constraint = verticalPlan.constraints[targetConstraintIndex];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (!currentTargetConstraint) {
          if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
            currentTargetConstraint = constraint;
            currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
            currentTargetConstraint.isTarget = true;
          } else {
            continue;
          }
        }
        currentPathSegmentMinFpa = this.minFlightPathAngle;
        currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        currentPathSegmentDistance = currentTargetConstraint.distance;
        const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
        if (currentTargetConstraintIsFirstDescentConstraint) {
          if (currentTargetConstraint.type === "descent") {
            currentTargetConstraint.fpa = this.flightPathAngle;
          }
          return true;
        }
        if (currentTargetConstraint.type === "manual") {
          currentPathSegmentMinFpa = currentTargetConstraint.fpa;
          currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
          currentTargetConstraintHasFixedFpa = true;
        } else {
          currentTargetConstraintHasFixedFpa = false;
        }
        let pathSegmentIsFlat = false;
        for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
          const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
          const isCurrentConstraintClimb = currentConstraint.type === "climb" || currentConstraint.type === "missed";
          const isCurrentConstraintManual = currentConstraint.type === "manual";
          const isCurrentConstraintDirect = currentConstraint.type === "direct";
          if (isCurrentConstraintClimb) {
            if (currentConstraintIndex - 1 > targetConstraintIndex) {
              currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
              const maxAltitude2 = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
              const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude2, false);
              if (terminatedIndex < currentConstraintIndex) {
                targetConstraintIndex = terminatedIndex - 1;
                currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                break;
              }
            } else {
              currentTargetConstraint.fpa = this.flightPathAngle;
            }
            targetConstraintIndex = currentConstraintIndex;
            currentTargetConstraint = void 0;
            break;
          }
          const minAltitude = currentConstraint.minAltitude;
          const maxAltitude = currentConstraint.maxAltitude;
          if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
            const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
            const newTargetConstraintIndex = currentConstraintIndex - 1;
            SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
            targetConstraintIndex = newTargetConstraintIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            currentTargetConstraint.targetAltitude = flatSegmentAltitude;
            currentTargetConstraint.isTarget = true;
            break;
          } else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
            pathSegmentIsFlat = true;
            currentTargetConstraint.fpa = 0;
            if (isCurrentConstraintFirstDescent) {
              const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
              SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
              targetConstraintIndex = currentConstraintIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
              currentTargetConstraint.targetAltitude = flatSegmentAltitude;
              currentTargetConstraint.isTarget = true;
              break;
            }
            continue;
          }
          const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
          const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
          const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
          if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
            if (isFpaOutOfBounds) {
              if (minFpa > currentPathSegmentMaxFpa) {
                currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
              } else {
                currentTargetConstraint.fpa = currentPathSegmentMinFpa;
              }
            } else {
              currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
              currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
              currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            }
            const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
            targetConstraintIndex = terminatedIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
            break;
          } else if (isCurrentConstraintFirstDescent) {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
            if (terminatedIndex < currentConstraintIndex + 1) {
              targetConstraintIndex = terminatedIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
              break;
            } else {
              return true;
            }
          } else {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentPathSegmentDistance += currentConstraint.distance;
          }
        }
      }
      return true;
    }
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
      const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
      if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== void 0) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
        const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
        const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
        newTargetConstraint.isTarget = true;
        newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
      }
      return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    getFirstDescentConstraintAltitude(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.constraints.length > 0) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
          const constraint = verticalPlan.constraints[i];
          if (constraint.type !== "climb") {
            return constraint.targetAltitude;
          }
        }
      }
      return void 0;
    }
    static getConstraintAltitudes(leg, out) {
      if (leg.verticalData !== void 0) {
        switch (leg.verticalData.altDesc) {
          case AltitudeRestrictionType.At:
            out[0] = leg.verticalData.altitude1;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.AtOrAbove:
            out[0] = leg.verticalData.altitude1;
            out[1] = Number.POSITIVE_INFINITY;
            return out;
          case AltitudeRestrictionType.AtOrBelow:
            out[0] = Number.NEGATIVE_INFINITY;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.Between:
            out[0] = leg.verticalData.altitude2;
            out[1] = leg.verticalData.altitude1;
            return out;
        }
      }
      return void 0;
    }
    static forceAtConstraint(constraint) {
      if (constraint.minAltitude !== constraint.maxAltitude) {
        if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          constraint.maxAltitude = constraint.minAltitude;
        } else {
          constraint.minAltitude = constraint.maxAltitude;
        }
      }
    }
    static getDirectToTargetLegIndex(lateralPlan) {
      const directToData = lateralPlan.directToData;
      if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
        const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
        if (segment !== null) {
          return segment.offset + directToData.segmentLegIndex;
        }
      }
      return void 0;
    }
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
      if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
        const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
        if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
          const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
          directVerticalLeg.isDirectToTarget = true;
          const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
          if (segment !== void 0) {
            const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type !== "climb" && constraint.type !== "missed" && constraint.index >= globalLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                return;
              }
            }
            verticalPlan.firstDescentConstraintLegIndex = void 0;
          }
        }
      }
    }
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
      if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
        return true;
      }
      return false;
    }
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
      const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
      const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
      if (currentMinWithPrecision > priorMaxWithPrecision) {
        return true;
      }
      return false;
    }
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
      if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
        const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
        const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
        if (minFpaTempValue > maxFpa) {
          return true;
        }
      }
      return false;
    }
    static isLegVnavEligible(lateralLeg) {
      switch (lateralLeg.leg.type) {
        case LegType.VM:
        case LegType.FM:
        case LegType.Discontinuity:
        case LegType.ThruDiscontinuity:
          return false;
        default:
          return true;
      }
    }
    static invalidateClimbConstraint() {
      return false;
    }
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
      return isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10) || requiredFpa > maxFpa;
    }
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
      for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.maxAltitude < Infinity) {
          return constraint.maxAltitude;
        }
        if (i === firstDescentConstraintIndex && constraint.type === "direct") {
          if (constraint.minAltitude > -Infinity) {
            return constraint.minAltitude;
          }
        }
      }
      return Infinity;
    }
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
      const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
      let distance = currentTargetConstraint.distance;
      for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
        const smoothedConstraint = verticalPlan.constraints[i];
        const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
        if (targetAltitude < maxAltitude) {
          smoothedConstraint.fpa = currentTargetConstraint.fpa;
          smoothedConstraint.targetAltitude = targetAltitude;
          distance += smoothedConstraint.distance;
        } else {
          out[0] = i;
          out[1] = distance;
          return out;
        }
      }
      out[0] = void 0;
      out[1] = distance;
      return out;
    }
  };
  SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
  SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
  SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
  SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;
  var LNavDataVars;
  (function(LNavDataVars2) {
    LNavDataVars2["DTKTrue"] = "L:WT_LNavData_DTK_True";
    LNavDataVars2["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    LNavDataVars2["XTK"] = "L:WT_LNavData_XTK";
    LNavDataVars2["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    LNavDataVars2["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    LNavDataVars2["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    LNavDataVars2["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    LNavDataVars2["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
  })(LNavDataVars || (LNavDataVars = {}));
  var LNavDataSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(LNavDataSimVarPublisher.simvars, bus);
    }
  };
  LNavDataSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnavdata_dtk_true", { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ["lnavdata_dtk_mag", { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_xtk", { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ["lnavdata_cdi_scale", { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ["lnavdata_waypoint_bearing_true", { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_bearing_mag", { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_distance", { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ["lnavdata_destination_distance", { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
  ]);
  var AltitudeSelectManager = class {
    constructor(bus, settingsManager, options, stops) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.stops = new SortedArray((a, b) => a - b);
      this.isEnabled = true;
      this.isInitialized = false;
      this.isPaused = false;
      this.isLocked = false;
      this.lockDebounceTimer = new DebounceTimer();
      this.consecIncrSmallCount = 0;
      this.lastIncrSmallDirection = 1;
      this.lastIncrSmallInputTime = 0;
      this.selectedAltitudeChangedHandler = () => {
        setTimeout(() => {
          this.isLocked = false;
          this.lockDebounceTimer.clear();
        });
      };
      this.altitudeHoldSlotIndex = (_a = options.altitudeHoldSlotIndex) !== null && _a !== void 0 ? _a : 1;
      this.altitudeHoldSlotSimVar = `AUTOPILOT ALTITUDE LOCK VAR:${this.altitudeHoldSlotIndex}`;
      this.minValue = Math.round(options.minValue.asUnit(UnitType.FOOT));
      this.maxValue = Math.round(options.maxValue.asUnit(UnitType.FOOT));
      this.minValueMetric = Math.round(((_b = options.minValueMetric) !== null && _b !== void 0 ? _b : options.minValue).asUnit(UnitType.METER));
      this.maxValueMetric = Math.round(((_c = options.maxValueMetric) !== null && _c !== void 0 ? _c : options.maxValue).asUnit(UnitType.METER));
      this.inputIncrLargeThreshold = options.inputIncrLargeThreshold;
      this.incrSmall = Math.round(options.incrSmall.asUnit(UnitType.FOOT));
      this.incrLarge = Math.round(options.incrLarge.asUnit(UnitType.FOOT));
      this.incrSmallMetric = Math.round(((_d = options.incrSmallMetric) !== null && _d !== void 0 ? _d : options.incrSmall).asUnit(UnitType.METER));
      this.incrLargeMetric = Math.round(((_e = options.incrLargeMetric) !== null && _e !== void 0 ? _e : options.incrLarge).asUnit(UnitType.METER));
      this.lockAltToStepOnIncr = (_f = options.lockAltToStepOnIncr) !== null && _f !== void 0 ? _f : true;
      this.lockAltToStepOnIncrMetric = (_g = options.lockAltToStepOnIncrMetric) !== null && _g !== void 0 ? _g : this.lockAltToStepOnIncr;
      this.accelInputCountThreshold = (_h = options.accelInputCountThreshold) !== null && _h !== void 0 ? _h : 0;
      this.accelResetOnDirectionChange = (_j = options.accelResetOnDirectionChange) !== null && _j !== void 0 ? _j : false;
      this.initToIndicatedAlt = (_k = options.initToIndicatedAlt) !== null && _k !== void 0 ? _k : false;
      this.transformSetToIncDec = (_l = options.transformSetToIncDec) !== null && _l !== void 0 ? _l : true;
      this.altimeterMetricSetting = options.supportMetric ? settingsManager.getSetting("altMetric") : void 0;
      if (stops !== void 0) {
        if ("isSubscribableSet" in stops) {
          stops.sub((set, type, key) => {
            if (type === SubscribableSetEventType.Added) {
              this.stops.insert(key);
            } else {
              this.stops.remove(key);
            }
          }, true);
        } else {
          this.stops.insertAll(new Set(stops));
        }
      }
      this.isInitialized = !((_m = options.initOnInput) !== null && _m !== void 0 ? _m : false);
      KeyEventManager.getManager(bus).then((manager) => {
        this.keyEventManager = manager;
        manager.interceptKey("AP_ALT_VAR_SET_ENGLISH", false);
        manager.interceptKey("AP_ALT_VAR_SET_METRIC", false);
        manager.interceptKey("AP_ALT_VAR_INC", false);
        manager.interceptKey("AP_ALT_VAR_DEC", false);
        const sub = this.bus.getSubscriber();
        if (this.transformSetToIncDec) {
          sub.on(`ap_altitude_selected_${this.altitudeHoldSlotIndex}`).whenChanged().handle(this.selectedAltitudeChangedHandler);
        }
        sub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        this.publisher.pub("alt_select_is_initialized", !this.isEnabled || this.isInitialized, true);
      });
    }
    setEnabled(isEnabled) {
      this.isEnabled = isEnabled;
      this.publisher.pub("alt_select_is_initialized", !isEnabled || this.isInitialized, true);
    }
    resume() {
      this.isPaused = false;
    }
    pause() {
      this.isPaused = true;
    }
    reset(altitude, resetInitialized = false) {
      if (!this.isEnabled) {
        return;
      }
      SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, altitude);
      if (resetInitialized) {
        this.isInitialized = false;
        this.publisher.pub("alt_select_is_initialized", false, true);
      }
    }
    onKeyIntercepted({ key, value0: value, value1: index }) {
      switch (key) {
        case "AP_ALT_VAR_INC":
        case "AP_ALT_VAR_DEC":
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          break;
        default:
          return;
      }
      index !== null && index !== void 0 ? index : index = 1;
      index = Math.max(1, index);
      if (!this.isEnabled || index !== this.altitudeHoldSlotIndex) {
        this.passThroughKeyEvent(key, index, value);
        return;
      }
      if (!this.isPaused && !this.isLocked) {
        this.handleKeyEvent(key, value);
      }
    }
    handleKeyEvent(key, value) {
      const currentValue = SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet);
      let startValue = currentValue;
      if (!this.isInitialized) {
        if (this.initToIndicatedAlt) {
          startValue = SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet);
        } else {
          startValue = 0;
        }
        this.publisher.pub("alt_select_is_initialized", true, true);
        this.isInitialized = true;
      }
      let direction = 0;
      let useLargeIncrement = false;
      let setAltitude = void 0;
      switch (key) {
        case "AP_ALT_VAR_INC":
          direction = 1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_DEC":
          direction = -1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC": {
          if (value !== void 0 && value !== currentValue) {
            if (this.transformSetToIncDec) {
              const delta = value - currentValue;
              direction = delta < 0 ? -1 : 1;
              useLargeIncrement = Math.abs(delta) > this.inputIncrLargeThreshold;
            } else {
              setAltitude = value;
            }
          }
          break;
        }
      }
      if (setAltitude !== void 0) {
        this.setSelectedAltitude(setAltitude);
        return;
      }
      if (this.accelInputCountThreshold > 0) {
        const time = Date.now();
        let isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (useLargeIncrement || direction === 0 || this.consecIncrSmallCount > 0 && time - this.lastIncrSmallInputTime > AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD || (isAccelActive ? this.accelResetOnDirectionChange : this.consecIncrSmallCount > 0) && this.lastIncrSmallDirection !== direction) {
          this.consecIncrSmallCount = 0;
        }
        if (!useLargeIncrement) {
          this.consecIncrSmallCount++;
          this.lastIncrSmallDirection = direction;
          this.lastIncrSmallInputTime = time;
        }
        isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (isAccelActive) {
          useLargeIncrement = true;
        }
      }
      if (direction !== 0) {
        this.changeSelectedAltitude(startValue, direction, useLargeIncrement);
      }
    }
    setSelectedAltitude(altitudeFeet) {
      var _a, _b;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min, max, unit;
      if (isMetric) {
        min = this.minValueMetric;
        max = this.maxValueMetric;
        unit = UnitType.METER;
      } else {
        min = this.minValue;
        max = this.maxValue;
        unit = UnitType.FOOT;
      }
      const valueToSet = UnitType.FOOT.convertFrom(MathUtils.clamp(UnitType.FOOT.convertTo(altitudeFeet, unit), min, max), unit);
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
      }
    }
    changeSelectedAltitude(startValue, direction, useLargeIncrement = false) {
      var _a, _b;
      const roundFunc = direction === 1 ? Math.floor : Math.ceil;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min, max, incrSmall, incrLarge, units, lockAlt;
      if (isMetric) {
        min = this.minValueMetric;
        max = this.maxValueMetric;
        incrSmall = this.incrSmallMetric;
        incrLarge = this.incrLargeMetric;
        units = UnitType.METER;
        lockAlt = this.lockAltToStepOnIncrMetric;
      } else {
        min = this.minValue;
        max = this.maxValue;
        incrSmall = this.incrSmall;
        incrLarge = this.incrLarge;
        units = UnitType.FOOT;
        lockAlt = this.lockAltToStepOnIncr;
      }
      const startValueConverted = Math.round(UnitType.FOOT.convertTo(startValue, units));
      useLargeIncrement && (useLargeIncrement = !lockAlt || startValueConverted % incrSmall === 0);
      let valueToSet = UnitType.FOOT.convertFrom(Utils.Clamp((lockAlt ? roundFunc(startValueConverted / incrSmall) * incrSmall : startValueConverted) + direction * (useLargeIncrement ? incrLarge : incrSmall), min, max), units);
      if (this.stops.length > 0) {
        let nextStopIndex = this.stops.matchIndex(startValue);
        if (direction === 1) {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 1;
          } else {
            nextStopIndex++;
          }
        } else {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 2;
          } else {
            nextStopIndex--;
          }
        }
        const nextStop = this.stops.peek(nextStopIndex);
        if (nextStop !== void 0 && Math.abs(valueToSet - startValue) > Math.abs(nextStop - startValue)) {
          valueToSet = nextStop;
        }
      }
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
        if (this.transformSetToIncDec) {
          this.isLocked = true;
          this.lockDebounceTimer.schedule(() => {
            this.isLocked = false;
          }, 250);
        }
      }
    }
    passThroughKeyEvent(key, index, value) {
      index = Math.max(1, index);
      const currentValue = SimVar.GetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet);
      let valueToSet = currentValue;
      switch (key) {
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          if (value !== void 0) {
            valueToSet = value;
          }
          break;
        case "AP_ALT_VAR_INC":
          valueToSet += value === 0 || value === void 0 ? 100 : value;
          break;
        case "AP_ALT_VAR_DEC":
          valueToSet -= value === 0 || value === void 0 ? 100 : value;
          break;
      }
      SimVar.SetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet, valueToSet);
    }
  };
  AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD = 300;
  var APModeType;
  (function(APModeType2) {
    APModeType2[APModeType2["LATERAL"] = 0] = "LATERAL";
    APModeType2[APModeType2["VERTICAL"] = 1] = "VERTICAL";
    APModeType2[APModeType2["APPROACH"] = 2] = "APPROACH";
  })(APModeType || (APModeType = {}));
  var AutothrottleTargetMode;
  (function(AutothrottleTargetMode2) {
    AutothrottleTargetMode2["None"] = "None";
    AutothrottleTargetMode2["Speed"] = "Speed";
    AutothrottleTargetMode2["Power"] = "Power";
    AutothrottleTargetMode2["ThrottlePos"] = "ThrottlePos";
  })(AutothrottleTargetMode || (AutothrottleTargetMode = {}));
  var AbstractAutothrottle = class {
    constructor(bus, airspeedIndex, throttleInfos, options, throttleLeverManager) {
      var _a, _b, _c, _d, _e, _f;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.isOverspeedProtActive = Subject.create(false);
      this.isUnderspeedProtActive = Subject.create(false);
      this.isOverpowerProtActive = Subject.create(false);
      this.targetMode = Subject.create(AutothrottleTargetMode.None);
      this.selectedSpeedIsMach = Subject.create(false);
      this.selectedIas = Subject.create(0);
      this.selectedMach = Subject.create(0);
      this.selectedPower = Subject.create(0);
      this.selectedThrottlePos = Subject.create(0);
      this.maxIas = Subject.create(0);
      this.minIas = Subject.create(0);
      this.maxMach = Subject.create(0);
      this.minMach = Subject.create(0);
      this.maxPower = Subject.create(0);
      this.maxThrottlePos = Subject.create(1);
      this.minThrottlePos = Subject.create(0);
      this.lastSmoothedIas = void 0;
      this.realTime = ConsumerSubject.create(this.bus.getSubscriber().on("realTime"), 0);
      this.updateTimer = null;
      this.lastUpdateTime = 0;
      this.updateHandler = this.update.bind(this);
      this.speedCommand = {
        selectedSpeedPowerTarget: void 0,
        overspeedProtPowerTarget: void 0,
        underspeedProtPowerTarget: void 0,
        isOverspeed: false,
        isUnderspeed: false
      };
      this.powerCommand = {
        speed: void 0,
        targetPos: void 0,
        isOverspeedProtEngaged: false,
        isUnderspeedProtEngaged: false,
        isOverpowerProtEngaged: false
      };
      this.isAlive = true;
      this.airspeedIndex = SubscribableUtils.toSubscribable(airspeedIndex, true);
      this.airspeedIndex.sub((index) => {
        this.airspeedSimVar = `AIRSPEED INDICATED:${index}`;
      }, true);
      this.powerLookahead = SubscribableUtils.toSubscribable(options.powerLookahead, true);
      this.throttles = throttleInfos.map((info) => {
        return this.createThrottle(bus, info, options.servoSpeed, options.powerSmoothingConstant, this.powerLookahead, throttleLeverManager);
      });
      this.machToKiasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.iasLookahead = SubscribableUtils.toSubscribable(options.speedLookahead, true);
      this.iasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lookaheadIasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lastIasLookahead = this.iasLookahead.get();
      this.selectedSpeedPid = AbstractAutothrottle.createPidFromParams(options.speedTargetPid);
      this.overspeedPid = AbstractAutothrottle.createPidFromParams((_a = options.overspeedPid) !== null && _a !== void 0 ? _a : options.speedTargetPid);
      this.underspeedPid = AbstractAutothrottle.createPidFromParams((_b = options.underspeedPid) !== null && _b !== void 0 ? _b : options.speedTargetPid);
      this.selectedPowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid)
      };
      this.overpowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams((_c = options.overpowerPid) !== null && _c !== void 0 ? _c : options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams((_d = options.overpowerPid) !== null && _d !== void 0 ? _d : options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams((_e = options.overpowerPid) !== null && _e !== void 0 ? _e : options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams((_f = options.overpowerPid) !== null && _f !== void 0 ? _f : options.powerTargetPid)
      };
      this.selectedSpeedPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.overspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.underspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.hysteresis = Math.max(0, options.hysteresis);
      this.hysteresisRecord = {
        [1]: 0,
        [2]: 0,
        [3]: 0,
        [4]: 0
      };
      this.publisher.pub("at_master_is_active", false, true, true);
      this.isOverspeedProtActive.sub((val) => this.publisher.pub("at_overspeed_prot_is_active", val, true, true), true);
      this.isUnderspeedProtActive.sub((val) => this.publisher.pub("at_underspeed_prot_is_active", val, true, true), true);
      this.isOverpowerProtActive.sub((val) => this.publisher.pub("at_overpower_prot_is_active", val, true, true), true);
      this.targetMode.sub((val) => this.publisher.pub("at_target_mode", val, true, true), true);
      this.selectedIas.sub((val) => this.publisher.pub("at_selected_ias", val, true, true), true);
      this.selectedMach.sub((val) => this.publisher.pub("at_selected_mach", val, true, true), true);
      this.selectedSpeedIsMach.sub((val) => this.publisher.pub("at_selected_speed_is_mach", val, true, true), true);
      this.selectedPower.sub((val) => this.publisher.pub("at_selected_power", val, true, true), true);
      this.selectedThrottlePos.sub((val) => this.publisher.pub("at_selected_throttle_pos", val, true, true), true);
      this.maxIas.sub((val) => this.publisher.pub("at_max_ias", val, true, true), true);
      this.maxMach.sub((val) => this.publisher.pub("at_max_mach", val, true, true), true);
      this.minIas.sub((val) => this.publisher.pub("at_min_ias", val, true, true), true);
      this.minMach.sub((val) => this.publisher.pub("at_min_mach", val, true, true), true);
      this.maxPower.sub((val) => this.publisher.pub("at_max_power", val, true, true), true);
      this.maxThrottlePos.sub((val) => this.publisher.pub("at_max_throttle_pos", val, true, true), true);
      this.minThrottlePos.sub((val) => this.publisher.pub("at_min_throttle_pos", val, true, true), true);
    }
    setOverspeedProtActive(val) {
      this.isOverspeedProtActive.set(val);
    }
    setUnderspeedProtActive(val) {
      this.isUnderspeedProtActive.set(val);
    }
    setOverpowerProtActive(val) {
      this.isOverpowerProtActive.set(val);
    }
    setTargetMode(mode) {
      this.targetMode.set(mode);
    }
    setSelectedSpeedIsMach(val) {
      this.selectedSpeedIsMach.set(val);
    }
    setSelectedIas(ias) {
      this.selectedIas.set(ias);
    }
    setSelectedMach(mach) {
      this.selectedMach.set(mach);
    }
    setSelectedPower(power) {
      this.selectedPower.set(power);
    }
    setSelectedThrottlePos(pos) {
      this.selectedThrottlePos.set(pos);
    }
    setMaxIas(ias) {
      this.maxIas.set(ias);
    }
    setMinIas(ias) {
      this.minIas.set(ias);
    }
    setMaxMach(mach) {
      this.maxMach.set(mach);
    }
    setMinMach(mach) {
      this.minMach.set(mach);
    }
    setMaxPower(power) {
      this.maxPower.set(power);
    }
    setMaxThrottlePos(pos) {
      this.maxThrottlePos.set(pos);
    }
    setMinThrottlePos(pos) {
      this.minThrottlePos.set(pos);
    }
    setServoActive(index, active) {
      const throttle = this.throttles.find((query) => query.index === index);
      if (throttle !== void 0) {
        throttle.isServoActive = active;
      }
    }
    start(frequency) {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot start a dead autothrottle");
      }
      this.stop();
      this.publisher.pub("at_master_is_active", true, true, true);
      this.updateTimer = setInterval(this.updateHandler, 1e3 / frequency);
    }
    stop() {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot stop a dead autothrottle");
      }
      if (this.updateTimer === null) {
        return;
      }
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      this.machToKiasSmoother.reset();
      this.iasSmoother.reset();
      this.lookaheadIasSmoother.reset();
      this.lastSmoothedIas = void 0;
      this.selectedSpeedPid.reset();
      this.overspeedPid.reset();
      this.underspeedPid.reset();
      this.selectedSpeedPowerTargetSmoother.reset();
      this.overspeedProtPowerTargetSmoother.reset();
      this.underspeedProtPowerTargetSmoother.reset();
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].resetPowerSmoothing();
      }
      for (const index of AbstractAutothrottle.ALL_THROTTLE_INDEXES) {
        this.selectedPowerPids[index].reset();
        this.overpowerPids[index].reset();
        this.hysteresisRecord[index] = 0;
      }
      this.publisher.pub("at_master_is_active", false, true, true);
    }
    update() {
      const realTime = Date.now();
      const dt = (realTime - this.lastUpdateTime) / 1e3;
      if (dt <= 0) {
        return;
      }
      this.lastUpdateTime = realTime;
      if (realTime - this.realTime.get() >= 1e3) {
        return;
      }
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].update(dt);
      }
      const targetMode = this.targetMode.get();
      const speedCommand = this.calculateSpeedTargetPower(dt, this.speedCommand);
      const isOverpowerProtActive = this.isOverpowerProtActive.get();
      const isPowerTargetActive = targetMode === AutothrottleTargetMode.Power;
      const isThrottlePosTargetActive = targetMode === AutothrottleTargetMode.ThrottlePos;
      const minThrottlePos = this.minThrottlePos.get();
      const maxThrottlePos = this.maxThrottlePos.get();
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          const powerCommand = this.calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, this.powerCommand);
          let targetPos = powerCommand.targetPos;
          let speed = powerCommand.speed;
          const isThrottlePosOob = throttle.normPosition < minThrottlePos || throttle.normPosition > maxThrottlePos;
          const isTargetPosOob = targetPos !== void 0 && (targetPos < minThrottlePos || targetPos > maxThrottlePos);
          if (isTargetPosOob) {
            targetPos = MathUtils.clamp(targetPos, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          } else if (isThrottlePosOob && targetPos === void 0) {
            targetPos = MathUtils.clamp(throttle.normPosition, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          }
          if (targetPos !== void 0 && speed !== void 0) {
            const lastCommandedSpeed = this.hysteresisRecord[throttle.index];
            if (isThrottlePosOob || lastCommandedSpeed === 0 || Math.sign(lastCommandedSpeed) === Math.sign(speed) || Math.abs(speed) > this.hysteresis) {
              throttle.drive(targetPos, dt);
              this.hysteresisRecord[throttle.index] = speed;
            }
          } else {
            this.hysteresisRecord[throttle.index] = 0;
          }
        } else {
          this.selectedPowerPids[throttle.index].reset();
          this.overpowerPids[throttle.index].reset();
          this.hysteresisRecord[throttle.index] = 0;
        }
      }
    }
    calculateSpeedTargetPower(dt, out) {
      out.selectedSpeedPowerTarget = void 0;
      out.overspeedProtPowerTarget = void 0;
      out.underspeedProtPowerTarget = void 0;
      out.isOverspeed = false;
      out.isUnderspeed = false;
      const ias = SimVar.GetSimVarValue(this.airspeedSimVar, SimVarValueType.Knots);
      const mach = SimVar.GetSimVarValue("AIRSPEED MACH", SimVarValueType.Number);
      const currentMachToKias = ias > 1 && mach > 0 ? ias / mach : Simplane.getMachToKias(1);
      const machToKias = this.machToKiasSmoother.next(isFinite(currentMachToKias) ? currentMachToKias : 1, dt);
      const lookahead = Math.max(0, this.iasLookahead.get());
      const smoothedIas = this.iasSmoother.next(ias, dt);
      if (lookahead !== this.lastIasLookahead) {
        this.lookaheadIasSmoother.reset();
        this.lastIasLookahead = lookahead;
      }
      let effectiveIas;
      if (lookahead > 0 && this.lastSmoothedIas !== void 0) {
        const delta = smoothedIas - this.lastSmoothedIas;
        const last = this.lookaheadIasSmoother.last();
        effectiveIas = last === null || isFinite(last) ? this.lookaheadIasSmoother.next(ias + delta * lookahead / dt, dt) : this.lookaheadIasSmoother.reset(ias + delta * lookahead / dt);
      } else {
        effectiveIas = smoothedIas;
      }
      this.lastSmoothedIas = smoothedIas;
      const isTargetSpeed = this.targetMode.get() === AutothrottleTargetMode.Speed;
      const isOverspeedProtActive = this.isOverspeedProtActive.get();
      const isUnderspeedProtActive = this.isUnderspeedProtActive.get();
      let overspeedProtDelta;
      let underspeedProtDelta;
      let selectedSpeedDelta;
      if (isOverspeedProtActive) {
        const maxIas = Math.min(this.maxMach.get() * machToKias, this.maxIas.get());
        overspeedProtDelta = this.overspeedPid.getOutput(dt, maxIas - effectiveIas);
        out.isOverspeed = effectiveIas > maxIas;
      } else {
        this.overspeedPid.reset();
      }
      if (isUnderspeedProtActive) {
        const minIas = Math.max(this.minMach.get() * machToKias, this.minIas.get());
        underspeedProtDelta = this.underspeedPid.getOutput(dt, minIas - effectiveIas);
        out.isUnderspeed = effectiveIas < minIas;
      } else {
        this.underspeedPid.reset();
      }
      if (isTargetSpeed) {
        const targetIas = this.selectedSpeedIsMach.get() ? this.selectedMach.get() * machToKias : this.selectedIas.get();
        selectedSpeedDelta = this.selectedSpeedPid.getOutput(dt, targetIas - effectiveIas);
      } else {
        this.selectedSpeedPid.reset();
      }
      let throttlePowerSum = 0;
      let throttlePowerCount = 0;
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          throttlePowerSum += throttle.effectivePower;
          throttlePowerCount++;
        }
      }
      if (throttlePowerCount === 0) {
        this.overspeedProtPowerTargetSmoother.reset();
        this.underspeedProtPowerTargetSmoother.reset();
        this.selectedSpeedPowerTargetSmoother.reset();
        return out;
      }
      if (selectedSpeedDelta !== void 0) {
        out.selectedSpeedPowerTarget = this.selectedSpeedPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + selectedSpeedDelta, dt);
      } else {
        this.selectedSpeedPowerTargetSmoother.reset();
      }
      if (overspeedProtDelta !== void 0) {
        out.overspeedProtPowerTarget = this.overspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + overspeedProtDelta, dt);
      } else {
        this.overspeedProtPowerTargetSmoother.reset();
      }
      if (underspeedProtDelta !== void 0) {
        out.underspeedProtPowerTarget = this.underspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + underspeedProtDelta, dt);
      } else {
        this.underspeedProtPowerTargetSmoother.reset();
      }
      return out;
    }
    calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, out) {
      out.speed = void 0;
      out.targetPos = void 0;
      out.isOverspeedProtEngaged = false;
      out.isUnderspeedProtEngaged = false;
      out.isOverpowerProtEngaged = false;
      const targetPid = this.selectedPowerPids[throttle.index];
      const overpowerPid = this.overpowerPids[throttle.index];
      const power = throttle.power;
      const effectivePower = throttle.effectivePower;
      let overpowerProtDelta;
      let isOverpower = false;
      if (isOverpowerProtActive) {
        const maxPower = this.maxPower.get();
        overpowerProtDelta = overpowerPid.getOutput(dt, maxPower - effectivePower);
        isOverpower = power > maxPower;
      } else {
        overpowerPid.reset();
      }
      let targetDelta;
      let delta;
      let isUsingOverspeedProtCommand = false;
      let isUsingUnderspeedProtCommand = false;
      let isUsingOverpowerProtCommand = false;
      let powerTarget;
      if (isPowerTargetActive) {
        powerTarget = this.selectedPower.get();
      } else {
        powerTarget = speedCommand.selectedSpeedPowerTarget;
      }
      if (powerTarget === void 0) {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isOverspeed && speedCommand.overspeedProtPowerTarget < effectivePower)) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isUnderspeed && speedCommand.underspeedProtPowerTarget > effectivePower)) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      } else {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && speedCommand.overspeedProtPowerTarget < powerTarget) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && speedCommand.underspeedProtPowerTarget > powerTarget) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      }
      if (powerTarget !== void 0) {
        targetDelta = targetPid.getOutput(dt, powerTarget - effectivePower);
      } else {
        targetPid.reset();
      }
      if (targetDelta === void 0) {
        if (overpowerProtDelta !== void 0 && (isThrottlePosTargetActive || isOverpower && overpowerProtDelta < 0)) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        }
      } else {
        if (overpowerProtDelta !== void 0 && overpowerProtDelta < targetDelta) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        } else {
          delta = targetDelta;
        }
      }
      if (isThrottlePosTargetActive) {
        const selectedTarget = this.selectedThrottlePos.get();
        const selectedTargetDelta = MathUtils.clamp((selectedTarget - throttle.normPosition) / dt, -throttle.servoSpeed, throttle.servoSpeed);
        if (delta === void 0 || (isUsingOverspeedProtCommand || isUsingOverpowerProtCommand) && selectedTargetDelta < delta || isUsingUnderspeedProtCommand && selectedTargetDelta > delta) {
          delta = selectedTargetDelta;
          isUsingOverspeedProtCommand = false;
          isUsingUnderspeedProtCommand = false;
          isUsingOverpowerProtCommand = false;
        }
      }
      if (delta === void 0) {
        return out;
      }
      out.speed = delta;
      out.targetPos = throttle.normPosition + delta * dt;
      out.isOverspeedProtEngaged = isUsingOverspeedProtCommand;
      out.isUnderspeedProtEngaged = isUsingUnderspeedProtCommand;
      out.isOverpowerProtEngaged = isUsingOverpowerProtCommand;
      return out;
    }
    destroy() {
      this.isAlive = false;
      this.stop();
      this.realTime.destroy();
      this.throttles.forEach((throttle) => {
        throttle.destroy();
      });
    }
    static createPidFromParams(params) {
      return new PidController(params.kP, params.kI, params.kD, params.maxOut, params.minOut, params.maxI, params.minI);
    }
  };
  AbstractAutothrottle.ALL_THROTTLE_INDEXES = [1, 2, 3, 4];
  var AutothrottleThrottle = class {
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      this.servoSpeed = servoSpeed;
      this.powerLookahead = powerLookahead;
      this._position = 0;
      this._power = 0;
      this._effectivePower = 0;
      this._isServoActive = Subject.create(false);
      this.lastPowerLookahead = this.powerLookahead.get();
      this.lastSmoothedPower = void 0;
      this.initKeyManager(bus);
      ({ index: this.index, idlePosition: this.idlePosition, maxThrustPosition: this.maxThrustPosition } = info);
      if (info.isVirtual) {
        this.virtualPos = ConsumerSubject.create(bus.getSubscriber().on(`v_throttle_lever_pos_${this.index}`), 0), this.getPosition = () => {
          return this.virtualPos.get();
        };
      } else {
        this.throttlePosSimVar = `GENERAL ENG THROTTLE LEVER POSITION:${this.index}`;
        this.getPosition = () => {
          return SimVar.GetSimVarValue(this.throttlePosSimVar, SimVarValueType.Percent) / 100;
        };
      }
      this.normRange = this.maxThrustPosition - this.idlePosition;
      this.throttleSetKVar = `THROTTLE${this.index}_SET`;
      this.throttleLeverManager = info.isVirtual ? throttleLeverManager : void 0;
      const isServoActiveTopic = `at_servo_${this.index}_is_active`;
      this._isServoActive.sub((val) => {
        bus.getPublisher().pub(isServoActiveTopic, val, true, true);
      });
      this.powerSmoother = new ExpSmoother(powerSmoothingConstant);
      this.lookaheadPowerSmoother = new ExpSmoother(powerSmoothingConstant);
    }
    get position() {
      return this._position;
    }
    get normPosition() {
      return (this._position - this.idlePosition) / this.normRange;
    }
    get power() {
      return this._power;
    }
    get effectivePower() {
      return this._effectivePower;
    }
    get isServoActive() {
      return this._isServoActive.get();
    }
    set isServoActive(val) {
      this._isServoActive.set(val);
    }
    async initKeyManager(bus) {
      this.keyEventManager = await KeyEventManager.getManager(bus);
    }
    update(dt) {
      this._position = this.getPosition();
      this._power = this.getPower();
      const lookahead = Math.max(0, this.powerLookahead.get());
      const smoothedPower = this.powerSmoother.next(this._power, dt);
      if (lookahead !== this.lastPowerLookahead) {
        this.lookaheadPowerSmoother.reset();
        this.lastPowerLookahead = lookahead;
      }
      if (lookahead > 0 && this.lastSmoothedPower !== void 0) {
        const delta = smoothedPower - this.lastSmoothedPower;
        this._effectivePower = this.lookaheadPowerSmoother.next(this._power + delta * lookahead / dt, dt);
      } else {
        this._effectivePower = smoothedPower;
      }
      this.lastSmoothedPower = smoothedPower;
    }
    drive(targetNormPos, dt) {
      var _a;
      const current = this.normPosition;
      const delta = targetNormPos - current;
      if (delta === 0) {
        return;
      }
      const deltaSign = Math.sign(delta);
      const toDrive = Math.min(dt * this.servoSpeed, (targetNormPos - current) * deltaSign) * deltaSign;
      const finalPos = this.idlePosition + (current + toDrive) * this.normRange;
      if (Math.abs(finalPos - this._position) < 0.5 / AutothrottleThrottle.RAW_AXIS_MAX) {
        return;
      }
      if (this.throttleLeverManager !== void 0) {
        this.throttleLeverManager.setThrottleLeverPosRaw(this.index, finalPos * AutothrottleThrottle.RAW_AXIS_MAX);
      } else {
        (_a = this.keyEventManager) === null || _a === void 0 ? void 0 : _a.triggerKey(this.throttleSetKVar, false, Math.round(finalPos * AutothrottleThrottle.RAW_AXIS_MAX));
      }
    }
    resetPowerSmoothing() {
      this.powerSmoother.reset();
      this.lookaheadPowerSmoother.reset();
      this.lastSmoothedPower = void 0;
    }
    destroy() {
      var _a;
      (_a = this.virtualPos) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  AutothrottleThrottle.RAW_AXIS_MAX = 16384;
  var CasAlertTransporter = class {
    constructor(bus, uuid, priority, suffix) {
      this.bus = bus;
      this.uuid = uuid;
      this.priority = priority;
      this.suffix = suffix;
      this.currentValue = false;
      this.subs = [];
      this.updateEntries = [];
      this.isAlive = true;
      this.isPaused = false;
    }
    set(active) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot change an alert with a dead transporter");
      }
      if (this.currentValue !== active) {
        if (active) {
          this.bus.getPublisher().pub("cas_activate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        } else {
          this.bus.getPublisher().pub("cas_deactivate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        }
        this.currentValue = active;
      }
    }
    bind(toWatch, predicate) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      this.subs.push(toWatch.sub((v) => this.set(predicate(v)), true, this.isPaused));
      return this;
    }
    bindUpdate(predicate) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: false,
        func: (deltaTime) => this.set(predicate(deltaTime))
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    bindStateUpdate(predicate, state) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: true,
        func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
        state
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    resume() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot resume a dead transporter");
      }
      if (!this.isPaused) {
        return this;
      }
      this.isPaused = false;
      this.subs.forEach((sub) => {
        sub.resume(true);
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = false;
      });
      return this;
    }
    pause() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot pause a dead transporter");
      }
      if (this.isPaused) {
        return this;
      }
      this.isPaused = true;
      this.subs.forEach((sub) => {
        sub.pause();
      });
      if (CasAlertTransporter.updateEntries) {
        this.updateEntries.forEach((entry) => {
          const index = CasAlertTransporter.updateEntries.indexOf(entry);
          if (index >= 0) {
            CasAlertTransporter.updateEntries.splice(index, 1);
          }
        });
      }
      return this;
    }
    destroy() {
      this.isAlive = false;
      this.subs.forEach((sub) => {
        sub.destroy();
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = true;
      });
    }
    static create(bus, uuid, priority, suffix) {
      return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    initUpdateFuncs() {
      if (CasAlertTransporter.updateEntries === void 0) {
        CasAlertTransporter.updateEntries = [];
        this.bus.getSubscriber().on("simTime").handle((timestamp) => {
          if (CasAlertTransporter.previousTimestamp === -1) {
            CasAlertTransporter.previousTimestamp = timestamp;
          }
          const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 1e4);
          if (CasAlertTransporter.updateEntries !== void 0) {
            for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
              const entry = CasAlertTransporter.updateEntries[i];
              if (entry.isPaused) {
                continue;
              }
              if (entry.hasState) {
                entry.func(deltaTime, entry.state);
              } else {
                entry.func(deltaTime);
              }
            }
          }
          CasAlertTransporter.previousTimestamp = timestamp;
        });
      }
    }
  };
  CasAlertTransporter.previousTimestamp = -1;
  var ThrottleLeverManager = class {
    constructor(bus, onInitCallback, throttleLeverHandler) {
      this.bus = bus;
      this.throttleLeverHandler = throttleLeverHandler;
      this.publisher = this.bus.getPublisher();
      this.throttleLevers = ArrayUtils.create(ThrottleLeverManager.THROTTLE_COUNT, (index) => {
        return {
          index: index + 1,
          topic: `v_throttle_lever_pos_${index + 1}`,
          rawPosition: 0
        };
      });
      const sub = bus.getSubscriber();
      const virtualPositions = this.throttleLevers.map((lever) => {
        return ConsumerValue.create(sub.on(lever.topic), NaN);
      });
      KeyEventManager.getManager(bus).then((manager) => {
        for (let i = 0; i < this.throttleLevers.length; i++) {
          const lever = this.throttleLevers[i];
          const virtualPosition = virtualPositions[i].get();
          const initialPosition = isNaN(virtualPosition) ? MathUtils.clamp(SimVar.GetSimVarValue(`GENERAL ENG THROTTLE LEVER POSITION:${lever.index}`, "Percent") / 100, 0, 1) : virtualPosition;
          virtualPositions[i].destroy();
          this.setRawThrottleLeverPosition(initialPosition * ThrottleLeverManager.RAW_MAX, i + 1);
        }
        this.keyEventManager = manager;
        manager.interceptKey("AXIS_THROTTLE_SET", false);
        manager.interceptKey("AXIS_THROTTLE1_SET", false);
        manager.interceptKey("AXIS_THROTTLE2_SET", false);
        manager.interceptKey("AXIS_THROTTLE3_SET", false);
        manager.interceptKey("AXIS_THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE1_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE2_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE3_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE4_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE_SET", false);
        manager.interceptKey("THROTTLE1_SET", false);
        manager.interceptKey("THROTTLE2_SET", false);
        manager.interceptKey("THROTTLE3_SET", false);
        manager.interceptKey("THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_FULL", false);
        manager.interceptKey("THROTTLE1_FULL", false);
        manager.interceptKey("THROTTLE2_FULL", false);
        manager.interceptKey("THROTTLE3_FULL", false);
        manager.interceptKey("THROTTLE4_FULL", false);
        manager.interceptKey("THROTTLE_INCR", false);
        manager.interceptKey("THROTTLE1_INCR", false);
        manager.interceptKey("THROTTLE2_INCR", false);
        manager.interceptKey("THROTTLE3_INCR", false);
        manager.interceptKey("THROTTLE4_INCR", false);
        manager.interceptKey("THROTTLE_DECR", false);
        manager.interceptKey("THROTTLE1_DECR", false);
        manager.interceptKey("THROTTLE2_DECR", false);
        manager.interceptKey("THROTTLE3_DECR", false);
        manager.interceptKey("THROTTLE4_DECR", false);
        manager.interceptKey("THROTTLE_CUT", false);
        manager.interceptKey("THROTTLE1_CUT", false);
        manager.interceptKey("THROTTLE2_CUT", false);
        manager.interceptKey("THROTTLE3_CUT", false);
        manager.interceptKey("THROTTLE4_CUT", false);
        manager.interceptKey("INCREASE_THROTTLE", false);
        manager.interceptKey("DECREASE_THROTTLE", false);
        manager.interceptKey("THROTTLE_10", false);
        manager.interceptKey("THROTTLE_20", false);
        manager.interceptKey("THROTTLE_30", false);
        manager.interceptKey("THROTTLE_40", false);
        manager.interceptKey("THROTTLE_50", false);
        manager.interceptKey("THROTTLE_60", false);
        manager.interceptKey("THROTTLE_70", false);
        manager.interceptKey("THROTTLE_80", false);
        manager.interceptKey("THROTTLE_90", false);
        sub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        onInitCallback && onInitCallback();
      });
    }
    setThrottleLeverPos(index, pos) {
      return this.setThrottleLeverPosRaw(index, pos * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    changeThrottleLeverPos(index, delta) {
      return this.changeThrottleLeverPosRaw(index, delta * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    setThrottleLeverPosRaw(index, pos) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.setRawThrottleLeverPosition(pos, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    changeThrottleLeverPosRaw(index, delta) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.changeRawThrottleLeverPosition(delta, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    onKeyIntercepted({ key, value0 }) {
      switch (key) {
        case "AXIS_THROTTLE_SET":
        case "THROTTLE_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, void 0, key);
          }
          break;
        case "AXIS_THROTTLE1_SET":
        case "THROTTLE1_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 1, key);
          }
          break;
        case "AXIS_THROTTLE2_SET":
        case "THROTTLE2_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 2, key);
          }
          break;
        case "AXIS_THROTTLE3_SET":
        case "THROTTLE3_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 3, key);
          }
          break;
        case "AXIS_THROTTLE4_SET":
        case "THROTTLE4_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 4, key);
          }
          break;
        case "THROTTLE_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, void 0, key);
          }
          break;
        case "THROTTLE1_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 1, key);
          }
          break;
        case "THROTTLE2_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 2, key);
          }
          break;
        case "THROTTLE3_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 3, key);
          }
          break;
        case "THROTTLE4_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 4, key);
          }
          break;
        case "THROTTLE_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, void 0, key);
          break;
        case "THROTTLE1_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 1, key);
          break;
        case "THROTTLE2_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 2, key);
          break;
        case "THROTTLE3_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 3, key);
          break;
        case "THROTTLE4_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 4, key);
          break;
        case "THROTTLE_CUT":
          this.setRawThrottleLeverPosition(0, void 0, key);
          break;
        case "THROTTLE1_CUT":
          this.setRawThrottleLeverPosition(0, 1, key);
          break;
        case "THROTTLE2_CUT":
          this.setRawThrottleLeverPosition(0, 2, key);
          break;
        case "THROTTLE3_CUT":
          this.setRawThrottleLeverPosition(0, 3, key);
          break;
        case "THROTTLE4_CUT":
          this.setRawThrottleLeverPosition(0, 4, key);
          break;
        case "THROTTLE_INCR":
        case "INCREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_DECR":
        case "DECREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_10":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.1, void 0, key);
          break;
        case "THROTTLE_20":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.2, void 0, key);
          break;
        case "THROTTLE_30":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.3, void 0, key);
          break;
        case "THROTTLE_40":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.4, void 0, key);
          break;
        case "THROTTLE_50":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.5, void 0, key);
          break;
        case "THROTTLE_60":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.6, void 0, key);
          break;
        case "THROTTLE_70":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.7, void 0, key);
          break;
        case "THROTTLE_80":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.8, void 0, key);
          break;
        case "THROTTLE_90":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.9, void 0, key);
          break;
      }
    }
    setRawThrottleLeverPosition(rawPosition, index, keyEvent) {
      rawPosition = MathUtils.clamp(Math.round(rawPosition), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        const lever = this.throttleLevers[i - 1];
        if (this.throttleLeverHandler) {
          rawPosition = MathUtils.clamp(Math.round(this.throttleLeverHandler(lever.index, lever.rawPosition / ThrottleLeverManager.RAW_MAX, rawPosition / ThrottleLeverManager.RAW_MAX, keyEvent) * ThrottleLeverManager.RAW_MAX), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
        }
        if (rawPosition !== lever.rawPosition) {
          lever.rawPosition = rawPosition;
          this.publishThrottleLeverPosition(lever);
        }
      }
    }
    changeRawThrottleLeverPosition(delta, index, keyEvent) {
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        this.setRawThrottleLeverPosition(this.throttleLevers[i - 1].rawPosition + delta, i, keyEvent);
      }
    }
    publishThrottleLeverPosition(lever) {
      this.publisher.pub(lever.topic, lever.rawPosition / ThrottleLeverManager.RAW_MAX, true, true);
    }
  };
  ThrottleLeverManager.THROTTLE_COUNT = 4;
  ThrottleLeverManager.RAW_MAX = 16384;
  ThrottleLeverManager.RAW_STEP = 256;
  var Binding = class {
    constructor(input, valueHandler) {
      this.input = input;
      this.valueHandler = valueHandler;
      this.canInitialNotify = false;
      if ("isConsumer" in this.input) {
        this.sub = this.input.handle((data) => this.valueHandler(data));
      } else {
        this.canInitialNotify = true;
        this.sub = this.input.sub((data) => this.valueHandler(data), this.canInitialNotify, true);
      }
    }
    get isPaused() {
      return this.sub.isPaused;
    }
    get isAlive() {
      return this.sub.isAlive;
    }
    pause() {
      this.sub.pause();
      return this;
    }
    resume() {
      this.sub.resume(true);
      return this;
    }
    destroy() {
      this.sub.destroy();
    }
  };
  var FmcComponent = class {
    constructor(page, options) {
      this.page = page;
      this.options = options;
    }
    invalidate() {
      this.page.invalidate();
    }
    async handleSelectKey(event) {
      var _a, _b;
      if (this.options.disabled) {
        return false;
      }
      if (event.isDelete) {
        if (this.options.onDelete) {
          const result = await this.options.onDelete();
          if (result === true || typeof result === "string") {
            if ((_a = this.options.clearScratchpadOnSelectedHandled) !== null && _a !== void 0 ? _a : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        }
      }
      if (this.options.onSelected) {
        try {
          const result = await this.options.onSelected(event.scratchpadContents);
          if (result === true || typeof result === "string") {
            if ((_b = this.options.clearScratchpadOnSelectedHandled) !== null && _b !== void 0 ? _b : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        } catch (error) {
          return Promise.reject(error);
        }
      }
      return this.onHandleSelectKey(event);
    }
    getOptions() {
      return this.options;
    }
  };
  var FmcPageLifecyclePolicy;
  (function(FmcPageLifecyclePolicy2) {
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Singleton"] = 0] = "Singleton";
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Transient"] = 1] = "Transient";
  })(FmcPageLifecyclePolicy || (FmcPageLifecyclePolicy = {}));
  var AbstractFmcPage = class {
    constructor(bus, screen) {
      this.bus = bus;
      this.screen = screen;
      this.memorizedComponents = [];
      this.bindings = [];
      this.params = /* @__PURE__ */ new Map();
      this.isDirty = false;
      this.clockHandler = (d) => {
        if (this.isDirty) {
          this.isDirty = false;
          this.initialRender();
        }
      };
      this.isInitialized = false;
      this.currentOutput = [];
      this.screen = screen;
      this.clockConsumer = this.bus.getSubscriber().on("realTime").atFrequency(10, false);
    }
    init() {
      this.onInit();
      this.addBinding(new Binding(this.screen.currentSubpageIndex, () => this.invalidate()));
    }
    onInit() {
    }
    pause() {
      for (const binding of this.bindings) {
        binding.pause();
      }
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      this.onPause();
    }
    onPause() {
    }
    resume() {
      for (const binding of this.bindings) {
        binding.resume(true);
      }
      this.onResume();
      this.isDirty = true;
      this.clockConsumer.handle(this.clockHandler);
    }
    onResume() {
    }
    onPageButtonPressed() {
    }
    destroy() {
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      for (const binding of this.bindings) {
        binding.destroy();
      }
      this.onDestroy();
    }
    onDestroy() {
    }
    invalidate() {
      this.isDirty = true;
    }
    initialRender() {
      if (!this.isInitialized) {
        return;
      }
      const templates = this.render();
      this.screen.currentSubpageCount.set(templates.length);
      const template = templates[this.screen.currentSubpageIndex.get() - 1];
      const render2 = [];
      this.memorizedComponents.length = 0;
      for (let i = 0; i < template.length; i++) {
        if (!render2[i]) {
          render2[i] = [];
        }
        const row = template[i];
        const renderRow = render2[i];
        for (let j = 0; j < row.length; j++) {
          const col = row[j];
          if (col instanceof FmcComponent) {
            if (!this.memorizedComponents[i]) {
              this.memorizedComponents[i] = [null, null, null];
            }
            this.memorizedComponents[i][j] = col;
            const componentRender = col.render();
            if (Array.isArray(componentRender)) {
              for (let k = 0; k < componentRender.length; k++) {
                const componentRenderRow = componentRender[k];
                for (let l = 0; l < componentRenderRow.length; l++) {
                  if (!render2[i + k]) {
                    render2[i + k] = [];
                  }
                  render2[i + k][l] = componentRenderRow[l];
                }
              }
            } else {
              renderRow[row.indexOf(col)] = componentRender;
            }
          } else {
            renderRow[j] = col;
          }
        }
      }
      this.currentOutput = render2;
      this.renderCallback(this.currentOutput, template, 0);
    }
    addBinding(binding) {
      this.bindings.push(binding);
    }
    async handleLineSelectKey(event) {
      var _a;
      const componentAtSk = (_a = this.memorizedComponents[event.row]) === null || _a === void 0 ? void 0 : _a[event.col];
      if (componentAtSk) {
        const selectKeyHandled = await componentAtSk.handleSelectKey(event);
        if (selectKeyHandled !== false) {
          return selectKeyHandled;
        }
      }
      const handledByPage = await this.onHandleSelectKey(event);
      if (!handledByPage) {
        return Promise.reject("KEY NOT ACTIVE");
      }
      return handledByPage;
    }
    async onHandleSelectKey(event) {
      return false;
    }
    async handleScrolling(event) {
      return this.onHandleScrolling(event);
    }
    async onHandleScrolling(event) {
      return false;
    }
  };
  AbstractFmcPage.lifecyclePolicy = FmcPageLifecyclePolicy.Singleton;
  var ImageCache = class {
    static addToCache(key, url) {
      if (this.cache[key] === void 0) {
        const img = new Image();
        img.src = url;
        this.cache[key] = img;
      }
    }
    static get(key) {
      return this.cache[key];
    }
  };
  ImageCache.cache = {};
  var DmsFormatter2 = class {
    static create(format, unit, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format, precision, unit);
      return (angle) => {
        if (isNaN(angle)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle, unit), "");
      };
    }
    static createForNumberUnit(format, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format, precision.number, precision.unit);
      return (angle) => {
        if (angle.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle.number, angle.unit), "");
      };
    }
    static createBuilder(format, precision, precisionUnit) {
      const split = format.split(DmsFormatter2.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DmsFormatter2.FORMAT_REGEXP)) {
          return DmsFormatter2.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DmsFormatter2.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          posStringMatch,
          negStringMatch
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DmsFormatter2.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        unitMatch,
        leftOptionalMatch,
        rightMatch,
        rightForcedMatch,
        rightOptionalMatch
      ] = numericMatch;
      const unitInfo = DmsFormatter2.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (angle, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
      } : (angle, unit, epsilon) => {
        return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(angle), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (angle, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (angle, unit) => {
          const converted = convertFunc(angle, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (angle, unit) => {
          return formatLeftFunc(convertFunc(angle, unit, epsilon));
        };
      }
    }
  };
  DmsFormatter2.FORMAT_REGEXP = /({[^{}]*})/;
  DmsFormatter2.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DmsFormatter2.NUM_FRAGMENT_REGEXP = /^(([DMSdms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DmsFormatter2.NUM_FRAGMENT_UNIT_INFO = {
    ["d"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["m"]: { unit: UnitType.ARC_MIN, mod: 60 },
    ["s"]: { unit: UnitType.ARC_SEC, mod: 60 },
    ["D"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["M"]: { unit: UnitType.ARC_MIN, mod: Infinity },
    ["S"]: { unit: UnitType.ARC_SEC, mod: Infinity }
  };
  var DurationFormatter = class {
    static create(format, unit, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format, precision, unit);
      return (duration) => {
        if (isNaN(duration)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration, unit), "");
      };
    }
    static createForNumberUnit(format, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format, precision.number, precision.unit);
      return (duration) => {
        if (duration.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration.number, duration.unit), "");
      };
    }
    static createBuilder(format, precision, precisionUnit) {
      const split = format.split(DurationFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DurationFormatter.FORMAT_REGEXP)) {
          return DurationFormatter.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          posStringMatch,
          negStringMatch
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        unitMatch,
        leftOptionalMatch,
        rightMatch,
        rightForcedMatch,
        rightOptionalMatch
      ] = numericMatch;
      const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (duration, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
      } : (duration, unit, epsilon) => {
        return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(duration), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (duration, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (duration, unit) => {
          const converted = convertFunc(duration, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (duration, unit) => {
          return formatLeftFunc(convertFunc(duration, unit, epsilon));
        };
      }
    }
  };
  DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DurationFormatter.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ["h"]: { unit: UnitType.HOUR, mod: Infinity },
    ["m"]: { unit: UnitType.MINUTE, mod: 60 },
    ["s"]: { unit: UnitType.SECOND, mod: 60 },
    ["H"]: { unit: UnitType.HOUR, mod: Infinity },
    ["M"]: { unit: UnitType.MINUTE, mod: Infinity },
    ["S"]: { unit: UnitType.SECOND, mod: Infinity }
  };
  DurationFormatter.NUM_FRAGMENT_ROUND_FUNCS = {
    ["+"]: Math.ceil,
    ["-"]: Math.floor,
    ["~"]: Math.round
  };
  var DateTimeFormatter = class {
    static create(format, options) {
      const optsToUse = Object.assign({}, DateTimeFormatter.DEFAULT_OPTIONS, options);
      const builder = DateTimeFormatter.createBuilder(format, optsToUse);
      const date = new Date();
      return (time) => {
        if (isNaN(time)) {
          return optsToUse.nanString;
        }
        date.setTime(time);
        return builder.reduce((string, part) => string + part(date), "");
      };
    }
    static createBuilder(format, options) {
      const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
          return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, options) {
      const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
      if (match) {
        if (match[1]) {
          return DateTimeFormatter.parseNumFragment(match);
        } else if (match[4]) {
          return DateTimeFormatter.parseYearFragment(match);
        } else if (match[5]) {
          return DateTimeFormatter.parseMonthFragment(match, options);
        } else if (match[6]) {
          return DateTimeFormatter.parseDayFragment(match, options);
        } else if (match[7]) {
          return DateTimeFormatter.parseAMPMFragment(match);
        }
      }
      return () => "";
    }
    static parseNumFragment(match) {
      const numGetter = DateTimeFormatter.NUM_GETTERS[match[3]];
      const pad = match[2].length;
      return (date) => {
        return numGetter(date).toString().padStart(pad, "0");
      };
    }
    static parseYearFragment(match) {
      if (match[4].length === 2) {
        return (date) => (date.getUTCFullYear() % 100).toString();
      } else {
        return (date) => date.getUTCFullYear().toString();
      }
    }
    static parseMonthFragment(match, options) {
      const isUpperCase = match[5][0] === "M";
      if (match[5].length === 3) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => text[date.getUTCMonth()];
      } else if (match[5].length === 4) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => {
          const month = date.getUTCMonth();
          return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.monthNames.map((str) => str.toUpperCase()) : options.monthNames;
        return (date) => text[date.getUTCMonth()];
      }
    }
    static parseDayFragment(match, options) {
      const isUpperCase = match[6][0] === "D";
      if (match[6] === "dy") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => text[date.getUTCDay()];
      } else if (match[6] === "dy.") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => {
          const day = date.getUTCDay();
          return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.dayNames.map((str) => str.toUpperCase()) : options.dayNames;
        return (date) => text[date.getUTCDay()];
      }
    }
    static parseAMPMFragment(match) {
      const isUpperCase = match[7][0] === "A";
      const usePeriod = match[7].length > 2;
      let text = usePeriod ? ["a.m.", "p.m."] : ["am", "pm"];
      if (isUpperCase) {
        text = text.map((str) => str.toUpperCase());
      }
      return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
  };
  DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DateTimeFormatter.FRAGMENT_REGEXP = /^(?:((([MdwHhms])+))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
  DateTimeFormatter.NUM_GETTERS = {
    ["s"]: (date) => date.getUTCSeconds(),
    ["m"]: (date) => date.getUTCMinutes(),
    ["h"]: (date) => date.getUTCHours() % 12,
    ["H"]: (date) => date.getUTCHours(),
    ["w"]: (date) => date.getUTCDay() + 1,
    ["d"]: (date) => date.getUTCDate(),
    ["M"]: (date) => date.getUTCMonth() + 1
  };
  DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    nanString: "NaN"
  };
  var UserSettingSaveManager = class {
    constructor(settings, bus) {
      this.autoSaveKeys = /* @__PURE__ */ new Set();
      this.isAlive = true;
      const subscriber = bus.getSubscriber();
      this.entries = Array.from(settings, (setting) => {
        const autoSaveDataStoreKeys = [];
        return {
          setting,
          subscription: subscriber.on(setting.definition.name).whenChanged().handle(this.onSettingChanged.bind(this, autoSaveDataStoreKeys), true),
          autoSaveDataStoreKeys
        };
      });
    }
    onSettingChanged(autoSaveDataStoreKeys, value) {
      const len = autoSaveDataStoreKeys.length;
      for (let i = 0; i < len; i++) {
        DataStore.set(autoSaveDataStoreKeys[i], value);
      }
    }
    load(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot load using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        const storedValue = DataStore.get(dataStoreKey);
        if (storedValue !== void 0) {
          entry.setting.value = storedValue;
        }
      }
    }
    save(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot save using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        DataStore.set(dataStoreKey, entry.setting.value);
      }
    }
    startAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot start autosave using a destroyed manager.");
      }
      if (this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.push(UserSettingSaveManager.getDataStoreKey(entry.setting, key));
        if (entry.autoSaveDataStoreKeys.length === 1) {
          entry.subscription.resume();
        }
      }
    }
    stopAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot stop autosave using a destroyed manager.");
      }
      if (!this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.splice(entry.autoSaveDataStoreKeys.indexOf(UserSettingSaveManager.getDataStoreKey(entry.setting, key)), 1);
        if (entry.autoSaveDataStoreKeys.length === 0) {
          entry.subscription.pause();
        }
      }
    }
    destroy() {
      const len = this.entries.length;
      for (let i = 0; i < len; i++) {
        this.entries[i].subscription.destroy();
      }
      this.entries.length = 0;
      this.isAlive = false;
    }
    static getDataStoreKey(setting, saveKey) {
      return `${UserSettingSaveManager.DATASTORE_PREFIX}.${saveKey}.${setting.definition.name}`;
    }
  };
  UserSettingSaveManager.DATASTORE_PREFIX = "persistent-setting";
  var AvionicsSystemState;
  (function(AvionicsSystemState2) {
    AvionicsSystemState2["Off"] = "Off";
    AvionicsSystemState2["Initializing"] = "Initializing";
    AvionicsSystemState2["On"] = "On";
    AvionicsSystemState2["Failed"] = "Failed";
  })(AvionicsSystemState || (AvionicsSystemState = {}));
  var FsBaseInstrument = class extends BaseInstrument {
    connectedCallback() {
      super.connectedCallback();
      this.fsInstrument = this.constructInstrument();
    }
    Update() {
      super.Update();
      if (this.fsInstrument) {
        this.fsInstrument.Update();
      }
    }
    onInteractionEvent(_args) {
      if (this.fsInstrument) {
        this.fsInstrument.onInteractionEvent(_args);
      }
    }
    onGameStateChanged(oldState, newState) {
      super.onGameStateChanged(oldState, newState);
      if (this.fsInstrument) {
        this.fsInstrument.onGameStateChanged(oldState, newState);
      }
    }
    onFlightStart() {
      super.onFlightStart();
      if (this.fsInstrument) {
        this.fsInstrument.onFlightStart();
      }
    }
    onSoundEnd(soundEventId) {
      super.onSoundEnd(soundEventId);
      if (this.fsInstrument) {
        this.fsInstrument.onSoundEnd(soundEventId);
      }
    }
    get isInteractive() {
      return false;
    }
  };

  // src/systems/instruments/src/Common/simVars.tsx
  var import_react2 = __toESM(require_react());

  // src/systems/instruments/src/Common/hooks.tsx
  var import_react = __toESM(require_react());

  // src/systems/instruments/src/Common/defaults.ts
  var reactMount = document.getElementById("MSFS_REACT_MOUNT");
  var getRenderTarget = () => reactMount;
  var getRootElement = () => {
    if (reactMount == null ? void 0 : reactMount.parentElement) {
      return reactMount.parentElement;
    }
    throw new Error("Could not find rootElement");
  };

  // src/systems/instruments/src/Common/hooks.tsx
  var useUpdate = (handler) => {
    const savedHandler = import_react.default.useRef(handler);
    import_react.default.useEffect(() => {
      savedHandler.current = handler;
    }, [handler]);
    import_react.default.useEffect(() => {
      const wrappedHandler = (event) => {
        savedHandler.current(event.detail);
      };
      getRootElement().addEventListener("update", wrappedHandler);
      return () => {
        getRootElement().removeEventListener("update", wrappedHandler);
      };
    }, []);
  };
  var useInteractionEvents = (events, handler) => {
    const savedHandler = import_react.default.useRef(handler);
    import_react.default.useEffect(() => {
      savedHandler.current = handler;
    }, [handler]);
    import_react.default.useEffect(() => {
      const wrappedHandler = () => {
        savedHandler.current();
      };
      events.forEach((event) => getRootElement().addEventListener(event, wrappedHandler));
      return () => {
        events.forEach((event) => getRootElement().removeEventListener(event, wrappedHandler));
      };
    }, [
      ...events
    ]);
  };

  // src/systems/instruments/src/Common/simVars.tsx
  var useSimVar = (name, unit, refreshInterval = 0) => {
    const lastUpdate = (0, import_react2.useRef)(Date.now() - refreshInterval - 1);
    const [stateValue, setStateValue] = (0, import_react2.useState)(() => SimVar.GetSimVarValue(name, unit));
    const updateCallback = (0, import_react2.useCallback)(() => {
      const delta = Date.now() - lastUpdate.current;
      if (delta >= refreshInterval) {
        lastUpdate.current = Date.now();
        const newValue = SimVar.GetSimVarValue(name, unit);
        setStateValue(newValue);
      }
    }, [name, unit, refreshInterval]);
    useUpdate(updateCallback);
    const setter = (0, import_react2.useCallback)((valueOrSetter) => {
      const executedValue = typeof valueOrSetter === "function" ? valueOrSetter(stateValue) : valueOrSetter;
      SimVar.SetSimVarValue(name, unit, executedValue);
      setStateValue(executedValue);
      return stateValue;
    }, [name, unit, stateValue]);
    return [stateValue, setter];
  };

  // ../fbw-common/src/systems/datalink/common/src/components/Convert.ts
  function wordWrap(text, maxLength) {
    const result = [];
    let line = [];
    let length = 0;
    const words = text.match(/[-.:*@_A-Z0-9]+|\[\s+\]|\n/g);
    for (const word of words) {
      if (length + word.length >= maxLength || word === "\n") {
        result.push(line.join(" ").toUpperCase());
        line = [];
        length = 0;
        if (word === "\n") {
          continue;
        }
      }
      length += word.length + 1;
      line.push(word);
    }
    if (line.length > 0) {
      result.push(line.join(" ").toUpperCase());
    }
    return result;
  }
  function timestampToString(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds / 60) % 60;
    return `${hours.toString().padStart(2, "0")}${minutes.toString().padStart(2, "0")}`;
  }
  function decimalToDms(deg, lng) {
    const M = 0 | deg % 1 * 6e8;
    let degree;
    if (lng) {
      degree = (0 | (deg < 0 ? -deg : deg)).toString().padStart(3, "0");
    } else {
      degree = 0 | (deg < 0 ? -deg : deg);
    }
    let dir = "";
    if (deg < 0) {
      dir = lng ? "W" : "S";
    } else {
      dir = lng ? "E" : "N";
    }
    return {
      dir,
      deg: degree,
      min: Math.abs(0 | M / 1e7),
      sec: Math.abs((0 | M / 1e6 % 1 * 6e4) / 100)
    };
  }
  function coordinateToString(coordinate, shortVersion) {
    const dmsLat = decimalToDms(coordinate.lat, false);
    const dmsLon = decimalToDms(coordinate.lon, true);
    dmsLon.deg = Number(dmsLon.deg);
    dmsLat.sec = Math.ceil(Number(dmsLat.sec / 100));
    dmsLon.sec = Math.ceil(Number(dmsLon.sec / 100));
    if (shortVersion) {
      if (dmsLat.dir === "N") {
        if (dmsLon.dir === "E") {
          return `${dmsLat.deg}N${dmsLon.deg}`;
        }
        return `${dmsLat.deg}${dmsLon.deg}N`;
      }
      if (dmsLon.dir === "E") {
        return `${dmsLat.deg}${dmsLon.deg}S`;
      }
      return `${dmsLat.deg}W${dmsLon.deg}`;
    }
    const lat = `${dmsLat.deg}\xB0${dmsLat.min}.${dmsLat.sec}${dmsLat.dir}`;
    const lon = `${dmsLon.deg}\xB0${dmsLon.min}.${dmsLon.sec}${dmsLon.dir}`;
    return `${lat}/${lon}`;
  }

  // ../fbw-common/src/systems/datalink/common/src/components/InputValidationFansA.ts
  var InputValidationFansA = class {
    static validateScratchpadAltitude(value) {
      if (!/^[0-9]{1,5}(FT|M)*$/.test(value)) {
        return 15 /* FormatError */;
      }
      const feet = !value.endsWith("M");
      const altitude = parseInt(value.match(/([0-9]+)/)[0]);
      if (feet) {
        if (altitude >= 0 && altitude <= 1e3 && !value.endsWith("FT")) {
          return 15 /* FormatError */;
        }
        if (altitude >= 0 && altitude <= 25e3) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (altitude >= 0 && altitude <= 12500) {
        return 0 /* Ok */;
      }
      return 14 /* EntryOutOfRange */;
    }
    static validateScratchpadSpeed(value) {
      if (/^((M*)\.[0-9]{1,2})$/.test(value)) {
        let mach = parseInt(value.match(/([0-9]+)/)[0]);
        if (mach < 10)
          mach *= 10;
        if (mach >= 61 && mach <= 92) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (/^([0-9]{1,3}(KT)*)$/.test(value)) {
        const knots = parseInt(value.match(/([0-9]+)/)[0]);
        if (knots >= 70 && knots <= 350) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/components/InputValidationFansB.ts
  var InputValidationFansB = class {
    static validateScratchpadAltitude(value) {
      if (!/^-*[0-9]{1,5}(FT|M)*$/.test(value)) {
        return 15 /* FormatError */;
      }
      const feet = !value.endsWith("M");
      const altitude = parseInt(value.match(/(-*[0-9]+)/)[0]);
      if (feet) {
        if (altitude >= 0 && altitude <= 410 && !value.endsWith("FT")) {
          return 15 /* FormatError */;
        }
        if (altitude >= -600 && altitude <= 41e3) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (altitude >= -30 && altitude <= 12500) {
        return 0 /* Ok */;
      }
      return 14 /* EntryOutOfRange */;
    }
    static validateScratchpadSpeed(value) {
      if (/^((M*)\.[0-9]{1,2})$/.test(value)) {
        let mach = parseInt(value.match(/([0-9]+)/)[0]);
        if (mach < 10)
          mach *= 10;
        if (mach >= 50 && mach <= 92) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (/^([0-9]{1,3}(KT)*)$/.test(value)) {
        const knots = parseInt(value.match(/([0-9]+)/)[0]);
        if (knots >= 0 && knots <= 350) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/components/InputValidation.ts
  var _InputValidation = class {
    static validateScratchpadWaypoint(value) {
      if (value.match(/^(N|S)?([0-9]{2,4}\.[0-9])(N|S)?\/(E|W)?([0-9]{2,5}\.[0-9])(E|W)?$/) !== null) {
        return 0 /* Ok */;
      }
      if (/^[A-Z0-9]{1,5}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadPosition(value) {
      if (/^[A-Z0-9]{1,10}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadProcedure(value) {
      if (/^[A-Z0-9]{1,7}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadTime(value, expectZulu = true) {
      if (expectZulu && /^[0-9]{4}Z$/.test(value) || !expectZulu && /^[0-9]{4}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadAtis(value) {
      if (/^[A-Z]{1}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadDegree(value) {
      if (/^[0-9]{1,3}$/.test(value)) {
        const heading = parseInt(value);
        if (heading >= 0 && heading <= 360) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadSquawk(value) {
      if (/^[0-9]{4}$/.test(value)) {
        const squawk = parseInt(value);
        if (squawk >= 0 && squawk < 7777) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    static isLatLonFormat(waypoint) {
      return waypoint.match(/^(N|S)?([0-9]{2,4}\.[0-9])(N|S)?\/(E|W)?([0-9]{2,5}\.[0-9])(E|W)?$/) !== null;
    }
    static classifyScratchpadWaypointType(waypoint, allowTime) {
      if (_InputValidation.isLatLonFormat(waypoint)) {
        return [1 /* GeoCoordinate */, 0 /* Ok */];
      }
      if (allowTime && /^([0-2][0-4][0-5][0-9]Z?)$/.test(waypoint)) {
        return [2 /* Timepoint */, 0 /* Ok */];
      }
      if (/^[A-Z0-9]{2,7}/.test(waypoint)) {
        return [3 /* Place */, 0 /* Ok */];
      }
      return [0 /* Invalid */, 15 /* FormatError */];
    }
    static validateVhfFrequency(value) {
      if (!/^1[1-3][0-9].[0-9]{2}[0|5]$/.test(value)) {
        return 15 /* FormatError */;
      }
      const elements = value.split(".");
      const before = parseInt(elements[0]);
      if (before < 118 || before > 136) {
        return 14 /* EntryOutOfRange */;
      }
      const frequencySpacingOther = ["00", "05", "10", "15", "25", "30", "35", "40", "50", "55", "60", "65", "75", "80", "85", "90"];
      const frequencySpacingEnd = ["00", "05", "10", "15", "25", "30", "35", "40", "50", "55", "60", "65", "75"];
      const twoDigitFraction = elements[1].substring(1, elements[1].length);
      if (before === 136) {
        if (frequencySpacingEnd.findIndex((entry) => entry === twoDigitFraction) === -1) {
          return 14 /* EntryOutOfRange */;
        }
      } else if (frequencySpacingOther.findIndex((entry) => entry === twoDigitFraction) === -1) {
        return 14 /* EntryOutOfRange */;
      }
      return 0 /* Ok */;
    }
    static validateScratchpadAltitude(value) {
      if (/^((FL)*[0-9]{1,3})$/.test(value)) {
        const flightlevel = parseInt(value.match(/([0-9]+)/)[0]);
        if (flightlevel >= 30 && flightlevel <= 410) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (_InputValidation.FANS === 2 /* FansB */) {
        return InputValidationFansB.validateScratchpadAltitude(value);
      }
      return InputValidationFansA.validateScratchpadAltitude(value);
    }
    static validateScratchpadDistance(distance) {
      if (/^[0-9]{1,3}(NM|KM)$/.test(distance) || /^[0-9]{1,3}$/.test(distance)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadOffset(offset) {
      let nmUnit = true;
      let distance = 0;
      if (/^[LR][0-9]{1,3}(NM|KM)$/.test(offset) || /^[LR][0-9]{1,3}$/.test(offset)) {
        distance = parseInt(offset.match(/([0-9]+)/)[0]);
        nmUnit = !offset.endsWith("KM");
      } else if (/^[0-9]{1,3}(NM|KM)[LR]$/.test(offset) || /^[0-9]{1,3}[LR]$/.test(offset)) {
        distance = parseInt(offset.match(/([0-9]+)/)[0]);
        nmUnit = !(offset.endsWith("KML") || offset.endsWith("KMR"));
      } else {
        return 15 /* FormatError */;
      }
      if (nmUnit) {
        if (distance >= 1 && distance <= 128) {
          return 0 /* Ok */;
        }
      } else if (distance >= 1 && distance <= 256) {
        return 0 /* Ok */;
      }
      return 14 /* EntryOutOfRange */;
    }
    static validateScratchpadSpeed(value) {
      if (_InputValidation.FANS === 2 /* FansB */) {
        return InputValidationFansB.validateScratchpadSpeed(value);
      }
      return InputValidationFansA.validateScratchpadSpeed(value);
    }
    static validateScratchpadVerticalSpeed(value) {
      if (/^(\+|-|M)?[0-9]{1,4}(FT\/MIN|FT|FTM|M\/MIN|MM|M){1}$/.test(value)) {
        let verticalSpeed = parseInt(value.match(/([0-9]+)/)[0]);
        if (value.startsWith("-") || value.startsWith("M")) {
          verticalSpeed *= -1;
        }
        if (!/(FT){1}/.test(value)) {
          if (verticalSpeed >= -2e3 && verticalSpeed <= 2e3) {
            return 0 /* Ok */;
          }
        } else if (verticalSpeed >= -6e3 && verticalSpeed <= 6e3) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    static sameSpeedType(lower, higher) {
      if (lower[0] === "M" && higher[0] === "M") {
        return true;
      }
      if (lower[0] === "M" || higher[0] === "M") {
        return false;
      }
      return true;
    }
    static validateScratchpadSpeedRanges(value) {
      const entries = value.split("/");
      if (entries.length !== 2) {
        return [15 /* FormatError */, []];
      }
      if (_InputValidation.validateScratchpadSpeed(entries[0]) || _InputValidation.validateScratchpadSpeed(entries[1])) {
        let error = _InputValidation.validateScratchpadSpeed(entries[0]);
        if (error) {
          return [error, []];
        }
        error = this.validateScratchpadSpeed(entries[1]);
        return [error, []];
      }
      const lower = _InputValidation.formatScratchpadSpeed(entries[0]);
      const higher = _InputValidation.formatScratchpadSpeed(entries[1]);
      if (!_InputValidation.sameSpeedType(lower, higher)) {
        return [15 /* FormatError */, []];
      }
      if (parseInt(lower.match(/([0-9]+)/)[0]) >= parseInt(higher.match(/([0-9]+)/)[0])) {
        return [14 /* EntryOutOfRange */, []];
      }
      return [0 /* Ok */, [lower, higher]];
    }
    static formatScratchpadAltitude(value) {
      if (value.startsWith("FL") || value.endsWith("M") || value.endsWith("FT")) {
        return value;
      }
      const altitude = parseInt(value);
      if (altitude >= 30 && altitude <= 410) {
        return `FL${value}`;
      }
      return `${value}FT`;
    }
    static formatScratchpadSpeed(value) {
      if (value[0] === "M" || value[0] === ".") {
        return `M.${value.match(/([0-9]+)/)[0]}`;
      }
      return value.replace("KT", "");
    }
    static formatScratchpadVerticalSpeed(value) {
      let verticalSpeed = parseInt(value.match(/([0-9]+)/)[0]);
      if (value.startsWith("-") || value.startsWith("M")) {
        verticalSpeed *= -1;
      }
      if (!/(FT){1}/.test(value)) {
        return `${verticalSpeed}MM`;
      }
      return `${verticalSpeed}FTM`;
    }
    static sameAltitudeType(lower, higher) {
      if (lower.startsWith("FL") && higher.startsWith("FL")) {
        return true;
      }
      if (lower.startsWith("FL") || higher.startsWith("FL")) {
        return false;
      }
      if (lower[lower.length - 1] === "M" && higher[higher.length - 1] === "M" || lower[lower.length - 1] !== "M" && higher[higher.length - 1] !== "M") {
        return true;
      }
      return false;
    }
    static convertToFeet(value) {
      const height = parseInt(value.match(/([0-9]+)/)[0]);
      if (value.startsWith("FL")) {
        return height * 100;
      }
      if (value[value.length - 1] === "M") {
        return height * 3.28;
      }
      if (value.endsWith("FT")) {
        return height;
      }
      if (height < 1e3)
        return height * 100;
      return height;
    }
    static validateAltitudeRange(lower, higher) {
      if (!_InputValidation.sameAltitudeType(lower, higher))
        return 15 /* FormatError */;
      const errorLower = _InputValidation.validateScratchpadAltitude(lower);
      if (errorLower !== 0 /* Ok */)
        return errorLower;
      const errorHigher = _InputValidation.validateScratchpadAltitude(higher);
      if (errorHigher !== 0 /* Ok */)
        return errorHigher;
      const lowerFt = _InputValidation.convertToFeet(lower);
      const higherFt = _InputValidation.convertToFeet(higher);
      if (lowerFt >= higherFt)
        return 14 /* EntryOutOfRange */;
      return 0 /* Ok */;
    }
    static validateScratchpadPersonsOnBoard(value) {
      if (/^[0-9]{1,4}$/.test(value)) {
        const pob = parseInt(value.match(/([0-9]+)/)[0]);
        if (pob >= 1 && pob <= 1024) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadEndurance(value) {
      if (/^([0-9]{1}H|[0-9]{2}(H)*)[0-9]{2}(M|MIN|MN)*$/.test(value)) {
        const matches = value.match(/[0-9]{1,2}/g);
        const hours = parseInt(matches[0]);
        if (hours < 0 || hours >= 24) {
          return 14 /* EntryOutOfRange */;
        }
        const minutes = parseInt(matches[1]);
        if (minutes < 0 || minutes >= 60) {
          return 14 /* EntryOutOfRange */;
        }
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadTemperature(value) {
      if (/^[-+M]?[0-9]{1,3}[CF]?$/.test(value)) {
        const negative = value.startsWith("-") || value.startsWith("M");
        const fahrenheit = value.endsWith("F");
        let temperature = parseInt(value.match(/([0-9]+)/)[0]);
        if (negative) {
          temperature *= -1;
        }
        if (fahrenheit && temperature >= -105 && temperature <= 150) {
          return 0 /* Ok */;
        }
        if (!fahrenheit && (temperature >= 80 || temperature < 47)) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    static validateScratchpadWind(value) {
      if (/^[0-9]{1,3}\/[0-9]{1,3}(KT|KM)?$/.test(value)) {
        const numbers = value.match(/([0-9]+)/g);
        const direction = parseInt(numbers[0]);
        const speed = parseInt(numbers[1]);
        if (direction < 1 || direction > 360 || speed < 0 || speed > 255) {
          return 14 /* EntryOutOfRange */;
        }
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    static decodeOffsetString(offset) {
      let nmUnit = true;
      let left = false;
      let distance;
      if (/^[LR][0-9]{1,3}(NM|KM)$/.test(offset) || /^[LR][0-9]{1,3}$/.test(offset)) {
        distance = offset.replace(/NM|KM/, "").replace(/L|R/, "");
        if (/(?!^\d+$)^.+$/.test(distance)) {
          return [];
        }
        distance = parseInt(distance);
        nmUnit = !offset.endsWith("KM");
        left = offset[0] === "L";
      } else if (/[0-9]{1,3}(NM|KM)[LR]/.test(offset) || /[0-9]{1,3}[LR]/.test(offset)) {
        distance = offset.replace(/NM|KM/, "").replace(/L|R/, "");
        if (/(?!^\d+$)^.+$/.test(distance)) {
          return null;
        }
        distance = parseInt(distance);
        nmUnit = !(offset.endsWith("KML") || offset.endsWith("KMR"));
        left = offset[offset.length - 1] === "L";
      }
      return [distance.toString(), nmUnit ? "NM" : "KM", left ? "L" : "R"];
    }
    static formatScratchpadTemperature(value) {
      const negative = value.startsWith("-") || value.startsWith("M");
      const fahrenheit = value.endsWith("F");
      let temperature = parseInt(value.match(/([0-9]+)/)[0]);
      if (negative) {
        temperature *= -1;
      }
      return `${temperature}${fahrenheit ? "F" : "C"}`;
    }
    static formatScratchpadWind(value) {
      const numbers = value.match(/([0-9]+)/g);
      const direction = parseInt(numbers[0]);
      const speed = parseInt(numbers[1]);
      const kilometers = value.endsWith("M");
      return `${direction.toString().padStart(3, "0")}/${speed.toString().padStart(3, "0")}${kilometers ? "KM" : "KT"}`;
    }
    static formatScratchpadOffset(value) {
      const entries = _InputValidation.decodeOffsetString(value);
      return `${entries[0]}${entries[1]}${entries[2]}`;
    }
    static formatScratchpadEndurance(value) {
      const matches = value.match(/[0-9]{1,2}/g);
      const hours = parseInt(matches[0]);
      const minutes = parseInt(matches[1]);
      return `${hours}H${minutes}`;
    }
    static expandLateralOffset(offset) {
      const entries = _InputValidation.decodeOffsetString(offset);
      return `${entries[0]}${entries[1]} ${entries[2] === "L" ? "LEFT" : "RIGHT"}`;
    }
    static formatScratchpadDistance(distance) {
      if (distance.endsWith("NM") || distance.endsWith("KM")) {
        return distance;
      }
      return `${distance}NM`;
    }
  };
  var InputValidation = _InputValidation;
  __publicField(InputValidation, "FANS", 0 /* FansNone */);

  // ../fbw-common/src/systems/datalink/common/src/messages/CpdlcMessageElements.ts
  var CpdlcMessageContent = class {
    constructor(type, ...args) {
      __publicField(this, "Type", 0 /* Unknown */);
      __publicField(this, "IndexStart", -1);
      __publicField(this, "IndexEnd", -1);
      __publicField(this, "Monitoring", false);
      __publicField(this, "Value", "");
      this.Type = type;
      args.forEach((arg) => {
        if (typeof arg === "number") {
          if (this.IndexStart === -1) {
            this.IndexStart = arg;
          } else {
            this.IndexEnd = arg;
          }
        } else if (typeof arg === "boolean") {
          this.Monitoring = arg;
        } else if (typeof arg === "string") {
          this.Value = arg;
        }
      });
    }
    static createInstance(type) {
      switch (type) {
        case 1 /* Level */:
          return new CpdlcMessageContentLevel(0);
        case 2 /* Position */:
          return new CpdlcMessageContentPosition(0);
        case 3 /* Time */:
          return new CpdlcMessageContentTime(0);
        case 4 /* Direction */:
          return new CpdlcMessageContentDirection(0);
        case 5 /* Distance */:
          return new CpdlcMessageContentDistance(0);
        case 6 /* Speed */:
          return new CpdlcMessageContentSpeed(0);
        case 7 /* Frequency */:
          return new CpdlcMessageContentFrequency(0);
        case 8 /* Procedure */:
          return new CpdlcMessageContentProcedure(0);
        case 9 /* Degree */:
          return new CpdlcMessageContentDegree(0);
        case 10 /* VerticalRate */:
          return new CpdlcMessageContentVerticalRate(0);
        case 11 /* LegType */:
          return new CpdlcMessageContentLegType(0);
        case 12 /* LegTypeDistance */:
          return new CpdlcMessageContentLegTypeDistance(0);
        case 13 /* LegTypeTime */:
          return new CpdlcMessageContentLegTypeTime(0);
        case 14 /* AtcUnit */:
          return new CpdlcMessageContentAtcUnit(0);
        case 15 /* Squawk */:
          return new CpdlcMessageContentSquawk(0);
        case 16 /* Altimeter */:
          return new CpdlcMessageContentAltimeter(0);
        case 17 /* Atis */:
          return new CpdlcMessageContentAtis(0);
        case 18 /* Fuel */:
          return new CpdlcMessageContentFuel(0);
        case 19 /* PersonsOnBoard */:
          return new CpdlcMessageContentPersonsOnBoard(0);
        case 20 /* Freetext */:
          return new CpdlcMessageContentFreetext(0, 0);
        default:
          return null;
      }
    }
    static deserialize(jsonData) {
      const retval = CpdlcMessageContent.createInstance(jsonData.Type);
      retval.Type = jsonData.Type;
      retval.IndexStart = jsonData.IndexStart;
      retval.IndexEnd = jsonData.IndexEnd;
      retval.Value = jsonData.Value;
      retval.Monitoring = jsonData.Monitoring;
      return retval;
    }
  };
  var CpdlcMessageContentLevel = class extends CpdlcMessageContent {
    constructor(...args) {
      super(1 /* Level */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        retval = InputValidation.validateScratchpadAltitude(value[this.IndexStart]) === 0 /* Ok */;
        if (retval) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
        }
      }
      if (!retval && this.IndexEnd < value.length && this.IndexEnd > -1) {
        retval = InputValidation.validateScratchpadAltitude(value[this.IndexEnd]) === 0 /* Ok */;
        if (retval) {
          this.Value = value[this.IndexEnd];
          value[this.IndexEnd] = "%s";
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentPosition = class extends CpdlcMessageContent {
    constructor(...args) {
      super(2 /* Position */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadWaypoint(value[this.IndexStart]) === 0 /* Ok */ && InputValidation.validateScratchpadTime(value[this.IndexStart], true) !== 0 /* Ok */ && InputValidation.validateScratchpadTime(value[this.IndexStart], false) !== 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentTime = class extends CpdlcMessageContent {
    constructor(...args) {
      super(3 /* Time */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadTime(value[this.IndexStart], true) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        } else if (InputValidation.validateScratchpadTime(value[this.IndexStart], false) === 0 /* Ok */) {
          this.Value = `${value[this.IndexStart]}Z`;
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentDirection = class extends CpdlcMessageContent {
    constructor(...args) {
      super(4 /* Direction */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (value[this.IndexStart] === "LEFT" || value[this.IndexStart] === "RIGHT") {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentDistance = class extends CpdlcMessageContent {
    constructor(...args) {
      super(5 /* Distance */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadDistance(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentSpeed = class extends CpdlcMessageContent {
    constructor(...args) {
      super(6 /* Speed */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadSpeed(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentFrequency = class extends CpdlcMessageContent {
    constructor(...args) {
      super(7 /* Frequency */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateVhfFrequency(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentProcedure = class extends CpdlcMessageContent {
    constructor(...args) {
      super(8 /* Procedure */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadProcedure(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentDegree = class extends CpdlcMessageContent {
    constructor(...args) {
      super(9 /* Degree */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadDegree(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentVerticalRate = class extends CpdlcMessageContent {
    constructor(...args) {
      super(10 /* VerticalRate */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart + 3 < value.length && this.IndexStart > -1) {
        if (value[this.IndexStart + 1] === "FEET" && value[this.IndexStart + 2] === "PER" && value[this.IndexStart + 3] === "MINUTE") {
          this.Value = `${value[this.IndexStart]} FEET PER MINUTE`;
          value[this.IndexStart] = "%s";
          value.slice(this.IndexStart + 1, 3);
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentAtcUnit = class extends CpdlcMessageContent {
    constructor(...args) {
      super(14 /* AtcUnit */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (this.IndexStart + 1 < value.length && value[this.IndexStart + 1] === "CTR") {
          this.Value = `${value[this.IndexStart]} ${value[this.IndexStart + 1]}`;
          value.splice(this.IndexStart + 1, 1);
        } else {
          this.Value = value[this.IndexStart];
        }
        value[this.IndexStart] = "%s";
        retval = true;
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentSquawk = class extends CpdlcMessageContent {
    constructor(...args) {
      super(15 /* Squawk */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1 && /^[0-9]{4}$/.test(value[this.IndexStart])) {
        const squawk = parseInt(value[this.IndexStart]);
        if (squawk >= 0 && squawk < 7777) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentFreetext = class extends CpdlcMessageContent {
    constructor(...args) {
      super(20 /* Freetext */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        this.Value = value.slice(this.IndexStart, this.IndexEnd === -1 ? value.length : this.IndexEnd + 1).join(" ");
        value = value.slice(0, this.IndexStart);
        value.push("%s");
        retval = true;
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentLegTypeDistance = class extends CpdlcMessageContent {
    constructor(...args) {
      super(12 /* LegTypeDistance */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[0-9]{1,2}$/.test(value[this.IndexStart])) {
          const distance = parseInt(value[this.IndexStart]);
          if (distance >= 1 && distance < 100) {
            this.Value = value[this.IndexStart];
            value[this.IndexStart] = "%s";
            retval = true;
          }
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentLegTypeTime = class extends CpdlcMessageContent {
    constructor(...args) {
      super(13 /* LegTypeTime */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart + 1 < value.length && this.IndexStart > -1 && /^[0-9]{1}$/.test(value[this.IndexStart])) {
        if (value[this.IndexStart + 1] === "MIN" || value[this.IndexStart + 1] === "MINS" || value[this.IndexStart + 1] === "MINUTES") {
          const minutes = parseInt(value[this.IndexStart]);
          if (minutes >= 1 && minutes < 10) {
            this.Value = value[this.IndexStart];
            value[this.IndexStart] = "%s";
            retval = true;
          }
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentLegType = class extends CpdlcMessageContent {
    constructor(...args) {
      super(11 /* LegType */, ...args);
      __publicField(this, "legDistance");
      __publicField(this, "legTime");
      this.legDistance = new CpdlcMessageContentLegTypeDistance(...args);
      this.legTime = new CpdlcMessageContentLegTypeTime(...args);
    }
    validateAndReplaceContent(value) {
      const legTimeRetval = this.legTime.validateAndReplaceContent(value);
      if (legTimeRetval.matched === true) {
        return legTimeRetval;
      }
      return this.legDistance.validateAndReplaceContent(value);
    }
  };
  var CpdlcMessageContentAltimeter = class extends CpdlcMessageContent {
    constructor(...args) {
      super(16 /* Altimeter */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart >= 1 && this.IndexStart < value.length && this.IndexStart > -1) {
        if (value[this.IndexStart - 1] === "ALTIMETER" && /^[0-9]{2}\.[0-9]{2}$/.test(value[this.IndexStart])) {
          retval = true;
        } else if (value[this.IndexStart - 1] === "QNH" && /^[0-9]{3,4}$/.test(value[this.IndexStart])) {
          retval = true;
        }
        if (retval === true) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentAtis = class extends CpdlcMessageContent {
    constructor(...args) {
      super(17 /* Atis */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[A-Z]{1}$/.test(value[this.IndexStart])) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentFuel = class extends CpdlcMessageContent {
    constructor(...args) {
      super(18 /* Fuel */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[0-9]{1,6}$/.test(value[this.IndexStart])) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentPersonsOnBoard = class extends CpdlcMessageContent {
    constructor(...args) {
      super(19 /* PersonsOnBoard */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[0-9]{1,3}$/.test(value[this.IndexStart])) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageElement = class {
    constructor(typeId, ...args) {
      __publicField(this, "TypeId", "");
      __publicField(this, "FansModes", []);
      __publicField(this, "Urgent", false);
      __publicField(this, "Content", []);
      __publicField(this, "ExpectedResponse", "N" /* No */);
      this.TypeId = typeId;
      args.forEach((arg) => {
        if (arg instanceof Array && arg[0] instanceof CpdlcMessageContent)
          this.Content = arg;
        else if (typeof arg === "boolean")
          this.Urgent = arg;
        else if (arg instanceof Array)
          this.FansModes = arg;
        else if (typeof arg === "string")
          this.ExpectedResponse = arg;
        else
          console.log(`Unknown arg: ${arg}, type: ${typeof arg}`);
      });
    }
    deepCopy() {
      const instance = new CpdlcMessageElement(this.TypeId, this.FansModes, this.Urgent, this.ExpectedResponse);
      this.Content.forEach((entry) => {
        instance.Content.push(CpdlcMessageContent.createInstance(entry.Type));
        instance.Content[instance.Content.length - 1].IndexStart = entry.IndexStart;
        instance.Content[instance.Content.length - 1].IndexEnd = entry.IndexEnd;
        instance.Content[instance.Content.length - 1].Value = entry.Value;
        instance.Content[instance.Content.length - 1].Monitoring = entry.Monitoring;
      });
      return instance;
    }
    static deserialize(jsonData) {
      const retval = new CpdlcMessageElement(jsonData.TypeId);
      retval.TypeId = jsonData.TypeId;
      retval.FansModes = jsonData.FansModes;
      retval.Urgent = jsonData.Urgent;
      jsonData.Content.forEach((entry) => retval.Content.push(CpdlcMessageContent.deserialize(entry)));
      retval.ExpectedResponse = jsonData.ExpectedResponse;
      return retval;
    }
  };
  var CpdlcMessagesDownlink = {
    DM0: [["WILCO"], new CpdlcMessageElement("DM0", [1 /* FansA */, 2 /* FansB */])],
    DM1: [["UNABLE"], new CpdlcMessageElement("DM1", [1 /* FansA */, 2 /* FansB */])],
    DM2: [["STANDBY"], new CpdlcMessageElement("DM2", [1 /* FansA */, 2 /* FansB */])],
    DM3: [["ROGER"], new CpdlcMessageElement("DM3", [1 /* FansA */, 2 /* FansB */])],
    DM4: [["AFFIRM"], new CpdlcMessageElement("DM4", [1 /* FansA */, 2 /* FansB */])],
    DM5: [["NEGATIVE"], new CpdlcMessageElement("DM5", [1 /* FansA */, 2 /* FansB */])],
    DM6: [["REQUEST %s"], new CpdlcMessageElement("DM6", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(1)], "Y" /* Yes */)],
    DM7: [["REQUEST BLOCK %s TO %s"], new CpdlcMessageElement(
      "DM7",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2), new CpdlcMessageContentLevel(4)],
      "Y" /* Yes */
    )],
    DM8: [["REQUEST CRUISE CLIMB TO %s"], new CpdlcMessageElement("DM8", [1 /* FansA */], [new CpdlcMessageContentLevel(4)], "Y" /* Yes */)],
    DM9: [["REQUEST CLIMB TO %s"], new CpdlcMessageElement("DM9", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(3)], "Y" /* Yes */)],
    DM10: [["REQUEST DESCEND TO %s"], new CpdlcMessageElement("DM10", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(3)], "Y" /* Yes */)],
    DM11: [["AT %s REQUEST CLIMB TO %s"], new CpdlcMessageElement(
      "DM11",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM12: [["AT %s REQUEST DESCEND TO %s"], new CpdlcMessageElement(
      "DM12",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM13: [["AT %s REQUEST CLIMB TO %s"], new CpdlcMessageElement(
      "DM13",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM14: [["AT %s REQUEST DESCEND TO %s"], new CpdlcMessageElement(
      "DM14",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM15: [["REQUEST OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM15",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(2), new CpdlcMessageContentDirection(3)],
      "Y" /* Yes */
    )],
    DM16: [["AT %s REQUEST OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM16",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentDistance(4), new CpdlcMessageContentDirection(5)],
      "Y" /* Yes */
    )],
    DM17: [["AT %s REQUEST OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM17",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentDistance(4), new CpdlcMessageContentDirection(5)],
      "Y" /* Yes */
    )],
    DM18: [["REQUEST %s"], new CpdlcMessageElement("DM18", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "Y" /* Yes */)],
    DM19: [["REQUEST %s TO %s"], new CpdlcMessageElement("DM19", [1 /* FansA */], [new CpdlcMessageContentSpeed(1), new CpdlcMessageContentSpeed(3)], "Y" /* Yes */)],
    DM20: [["REQUEST VOICE CONTACT"], new CpdlcMessageElement("DM20", [1 /* FansA */], "Y" /* Yes */)],
    DM21: [["REQUEST VOICE CONTACT %s"], new CpdlcMessageElement("DM21", [1 /* FansA */], [new CpdlcMessageContentFrequency(3)], "Y" /* Yes */)],
    DM22: [["REQUEST DIRECT TO %s"], new CpdlcMessageElement("DM22", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentPosition(3)], "Y" /* Yes */)],
    DM23: [["REQUEST %s"], new CpdlcMessageElement("DM23", [1 /* FansA */], [new CpdlcMessageContentProcedure(1)], "Y" /* Yes */)],
    DM25: [["REQUEST %s CLEARANCE"], new CpdlcMessageElement("DM25", [1 /* FansA */], [new CpdlcMessageContentFreetext(1, 2)], "Y" /* Yes */)],
    DM26: [["REQUEST WEATHER DEVIATION TO %s VIA %s"], new CpdlcMessageElement(
      "DM26",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(4), new CpdlcMessageContentFreetext(6, -1)],
      "Y" /* Yes */
    )],
    DM27: [["REQUEST WEATHER DEVIATION UP TO %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM27",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDistance(5), new CpdlcMessageContentDirection(6)],
      "Y" /* Yes */
    )],
    DM28: [["LEAVING %s"], new CpdlcMessageElement("DM28", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "N" /* No */)],
    DM29: [["CLIMBING TO %s"], new CpdlcMessageElement("DM29", [1 /* FansA */], [new CpdlcMessageContentLevel(2)], "N" /* No */)],
    DM30: [["DESCENDING TO %s"], new CpdlcMessageElement("DM30", [1 /* FansA */], [new CpdlcMessageContentLevel(2)], "N" /* No */)],
    DM31: [["PASSING %s"], new CpdlcMessageElement("DM31", [1 /* FansA */], [new CpdlcMessageContentPosition(1)], "N" /* No */)],
    DM32: [["PRESENT LEVEL %s"], new CpdlcMessageElement(
      "DM32",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2)],
      "N" /* No */
    )],
    DM33: [["PRESENT POSITION %s"], new CpdlcMessageElement("DM33", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM34: [["PRESENT SPEED %s"], new CpdlcMessageElement("DM34", [1 /* FansA */], [new CpdlcMessageContentSpeed(2)], "N" /* No */)],
    DM35: [["PRESENT HEADING %s"], new CpdlcMessageElement("DM35", [1 /* FansA */], [new CpdlcMessageContentDegree(2)], "N" /* No */)],
    DM36: [["PRESENT GROUND TRACK %s"], new CpdlcMessageElement("DM36", [1 /* FansA */], [new CpdlcMessageContentDegree(3)], "N" /* No */)],
    DM37: [["MAINTAINING %s", "LEVEL %s"], new CpdlcMessageElement("DM37", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "N" /* No */)],
    DM38: [["ASSIGNED LEVEL %s"], new CpdlcMessageElement(
      "DM38",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2)],
      "N" /* No */
    )],
    DM39: [["ASSIGNED SPEED %s"], new CpdlcMessageElement("DM39", [1 /* FansA */], [new CpdlcMessageContentSpeed(2)], "N" /* No */)],
    DM40: [["ASSIGNED ROUTE %s"], new CpdlcMessageElement("DM40", [1 /* FansA */], [new CpdlcMessageContentFreetext(2, -1)], "N" /* No */)],
    DM41: [["BACK ON ROUTE"], new CpdlcMessageElement("DM41", [1 /* FansA */], "N" /* No */)],
    DM42: [["NEXT WAYPOINT %s"], new CpdlcMessageElement("DM42", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM43: [["NEXT WAYPOINT ETA %s"], new CpdlcMessageElement("DM43", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "N" /* No */)],
    DM44: [["ENSUING WAYPOINT %s"], new CpdlcMessageElement("DM44", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM45: [["REPORTED WAYPOINT %s"], new CpdlcMessageElement("DM45", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM46: [["REPORTED WAYPOINT %s"], new CpdlcMessageElement("DM46", [1 /* FansA */], [new CpdlcMessageContentTime(2)], "N" /* No */)],
    DM47: [["SQUAWKING %s"], new CpdlcMessageElement("DM47", [1 /* FansA */], [new CpdlcMessageContentSquawk(1)], "N" /* No */)],
    DM48: [["POSITION REPORT"], new CpdlcMessageElement("DM48", [1 /* FansA */], "R" /* Roger */)],
    DM49: [["WHEN CAN WE EXPECT %s"], new CpdlcMessageElement("DM49", [1 /* FansA */], [new CpdlcMessageContentSpeed(4)], "Y" /* Yes */)],
    DM50: [["WHEN CAN WE EXPECT %s TO %s"], new CpdlcMessageElement(
      "DM50",
      [1 /* FansA */],
      [new CpdlcMessageContentSpeed(4), new CpdlcMessageContentSpeed(6)],
      "Y" /* Yes */
    )],
    DM51: [["WHEN CAN WE EXPECT BACK ON ROUTE"], new CpdlcMessageElement("DM51", [1 /* FansA */], "Y" /* Yes */)],
    DM52: [["WHEN CAN WE EXPECT LOWER LEVEL"], new CpdlcMessageElement("DM52", [1 /* FansA */], "Y" /* Yes */)],
    DM53: [["WHEN CAN WE EXPECT HIGHER LEVEL"], new CpdlcMessageElement("DM53", [1 /* FansA */], "Y" /* Yes */)],
    DM54: [["WHEN CAN WE EXPECT CRUISE CLIMB TO %s"], new CpdlcMessageElement("DM54", [1 /* FansA */], [new CpdlcMessageContentLevel(7)], "Y" /* Yes */)],
    DM55: [["PAN PAN PAN"], new CpdlcMessageElement("DM55", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */, true)],
    DM56: [["MAYDAY MAYDAY MAYDAY"], new CpdlcMessageElement("DM56", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */, true)],
    DM57: [["%s FUEL REMAINING AND %s PERSONS ON BOARD"], new CpdlcMessageElement(
      "DM57",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentFuel(0), new CpdlcMessageContentPersonsOnBoard(4)],
      "Y" /* Yes */,
      true
    )],
    DM58: [["CANCEL EMERGENCY"], new CpdlcMessageElement("DM58", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */, true)],
    DM59: [["DIVERTING TO %s VIA %s"], new CpdlcMessageElement(
      "DM59",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentFreetext(4, -1)],
      "Y" /* Yes */,
      true
    )],
    DM60: [["OFFSETTING %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM60",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDistance(1), new CpdlcMessageContentDirection(2)],
      "Y" /* Yes */,
      true
    )],
    DM61: [["DESCENDING TO %s"], new CpdlcMessageElement("DM61", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(2)], "Y" /* Yes */, true)],
    DM62: [["ERROR %s"], new CpdlcMessageElement("DM62", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "Y" /* Yes */, true)],
    DM63: [["NOT CURRENT DATA AUTHORITY"], new CpdlcMessageElement("DM63", [1 /* FansA */, 2 /* FansB */], "N" /* No */)],
    DM65: [["DUE TO WEATHER"], new CpdlcMessageElement("DM65", [1 /* FansA */, 2 /* FansB */], "N" /* No */)],
    DM66: [["DUE TO AIRCRAFT PERFORMANCE"], new CpdlcMessageElement("DM66", [1 /* FansA */, 2 /* FansB */], "N" /* No */)],
    DM67: [["%s"], new CpdlcMessageElement("DM67", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(0, -1)], "N" /* No */)],
    DM68: [["%s"], new CpdlcMessageElement("DM68", [1 /* FansA */], true, [new CpdlcMessageContentFreetext(0, -1)], "Y" /* Yes */)],
    DM69: [["REQUEST VMC DESCEND"], new CpdlcMessageElement("DM69", [1 /* FansA */], "Y" /* Yes */)],
    DM70: [["REQUEST HEADING %s"], new CpdlcMessageElement("DM70", [1 /* FansA */], [new CpdlcMessageContentDegree(2)], "Y" /* Yes */)],
    DM71: [["REQUEST GROUND TRACK %s"], new CpdlcMessageElement("DM71", [1 /* FansA */], [new CpdlcMessageContentDegree(3)], "Y" /* Yes */)],
    DM72: [["REACHING %s"], new CpdlcMessageElement("DM72", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "Y" /* Yes */)],
    DM74: [["REQUEST TO MAINTAIN OWN SEPARATION AND VMC"], new CpdlcMessageElement("DM74", [1 /* FansA */], "Y" /* Yes */)],
    DM75: [["AT PILOTS DISCRETION"], new CpdlcMessageElement("DM75", [1 /* FansA */], "Y" /* Yes */)],
    DM76: [["REACHING BLOCK %s TO %s"], new CpdlcMessageElement(
      "DM76",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2), new CpdlcMessageContentLevel(4)],
      "N" /* No */
    )],
    DM78: [["AT %s %s TO %s", "AT %s %s FROM %s"], new CpdlcMessageElement(
      "DM78",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentDistance(2), new CpdlcMessageContentPosition(4)],
      "N" /* No */
    )],
    DM79: [["ATIS %s"], new CpdlcMessageElement("DM79", [1 /* FansA */], [new CpdlcMessageContentAtis(1)], "N" /* No */)],
    DM80: [["DEVIATING UP TO %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM80",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "Y" /* Yes */,
      true
    )],
    DM81: [["WE CAN ACCEPT %s AT %s"], new CpdlcMessageElement(
      "DM81",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "N" /* No */
    )],
    DM82: [["WE CANNOT ACCEPT %s"], new CpdlcMessageElement("DM82", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(3)], "N" /* No */)],
    DM83: [["WE CAN ACCEPT %s AT %s"], new CpdlcMessageElement(
      "DM83",
      [1 /* FansA */],
      [new CpdlcMessageContentSpeed(3), new CpdlcMessageContentTime(5)],
      "N" /* No */
    )],
    DM84: [["WE CANNOT ACCEPT %s"], new CpdlcMessageElement("DM84", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "N" /* No */)],
    DM85: [["WE CAN ACCEPT %s %s AT %s"], new CpdlcMessageElement(
      "DM85",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4), new CpdlcMessageContentTime(6)],
      "N" /* No */
    )],
    DM86: [["WE CANNOT ACCEPT %s %s"], new CpdlcMessageElement(
      "DM86",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "N" /* No */
    )],
    DM87: [["WHEN CAN WE EXPECT CLIMB TO %s"], new CpdlcMessageElement("DM87", [1 /* FansA */], [new CpdlcMessageContentLevel(6)], "Y" /* Yes */)],
    DM88: [["WHEN CAN WE EXPECT DESCEND TO %s"], new CpdlcMessageElement("DM88", [1 /* FansA */], [new CpdlcMessageContentLevel(6)], "Y" /* Yes */)],
    DM89: [["MONITORING %s %s"], new CpdlcMessageElement(
      "DM89",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentAtcUnit(1), new CpdlcMessageContentFrequency(2)],
      "N" /* No */
    )],
    DM98: [["%s"], new CpdlcMessageElement("DM98", [2 /* FansB */], [new CpdlcMessageContentFreetext(0, -1)], "N" /* No */)],
    DM99: [["CURRENT DATA AUTHORITY"], new CpdlcMessageElement("DM99", [1 /* FansA */, 2 /* FansB */], "N" /* No */, true)],
    DM100: [["LOGICAL ACKNOWLEDGEMENT"], new CpdlcMessageElement("DM100", [2 /* FansB */], "N" /* No */)],
    DM104: [["ETA %s %s"], new CpdlcMessageElement("DM104", [1 /* FansA */], [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(2)], "N" /* No */)],
    DM106: [["PREFERRED LEVEL %s"], new CpdlcMessageElement("DM106", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(2)], "N" /* No */)],
    DM107: [["NOT AUTHORIZED NEXT DATA AUTHORITY"], new CpdlcMessageElement("DM107", [2 /* FansB */], "N" /* No */)],
    DM109: [["TOP OF DESCENT %s"], new CpdlcMessageElement("DM109", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentTime(3)], "N" /* No */)],
    DM113: [["SPEED %s"], new CpdlcMessageElement("DM113", [1 /* FansA */], [new CpdlcMessageContentSpeed(1)], "N" /* No */)],
    DM9998: [["REQUEST LOGON"], new CpdlcMessageElement("DM9998", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    DM9999: [["LOGOFF"], new CpdlcMessageElement("DM9999", [1 /* FansA */, 2 /* FansB */], "N" /* No */)]
  };
  var CpdlcMessagesUplink = {
    UM0: [["UNABLE"], new CpdlcMessageElement("UM0", [1 /* FansA */, 2 /* FansB */])],
    UM1: [["STANDBY"], new CpdlcMessageElement("UM1", [1 /* FansA */, 2 /* FansB */])],
    UM3: [["ROGER"], new CpdlcMessageElement("UM3", [1 /* FansA */, 2 /* FansB */])],
    UM4: [["AFFIRM"], new CpdlcMessageElement("UM4", [1 /* FansA */, 2 /* FansB */])],
    UM5: [["NEGATIVE"], new CpdlcMessageElement("UM5", [1 /* FansA */, 2 /* FansB */])],
    UM6: [["EXPECT %s"], new CpdlcMessageElement("UM6", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "R" /* Roger */)],
    UM7: [["EXPECT CLIMB AT %s"], new CpdlcMessageElement("UM7", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "R" /* Roger */)],
    UM8: [["EXPECT CLIMB AT %s"], new CpdlcMessageElement("UM8", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "R" /* Roger */)],
    UM9: [["EXPECT DESCENT AT %s"], new CpdlcMessageElement("UM9", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "R" /* Roger */)],
    UM10: [["EXPECT DESCENT AT %s"], new CpdlcMessageElement("UM10", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "R" /* Roger */)],
    UM11: [["EXPECT CRUISE CLIMB AT %s"], new CpdlcMessageElement("UM11", [1 /* FansA */], [new CpdlcMessageContentTime(4)], "R" /* Roger */)],
    UM12: [["EXPECT CRUISE CLIMB AT %s"], new CpdlcMessageElement("UM12", [1 /* FansA */], [new CpdlcMessageContentPosition(4)], "R" /* Roger */)],
    UM19: [["MAINTAIN %s"], new CpdlcMessageElement(
      "UM19",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(1)],
      "WU" /* WilcoUnable */
    )],
    UM20: [["CLIMB TO %s", "CLIMB TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM20",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2, 4)],
      "WU" /* WilcoUnable */
    )],
    UM21: [["AT %s CLIMB TO %s", "AT %s CLIMB TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM21",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM22: [["AT %s CLIMB TO %s", "AT %s CLIMB TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM22",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM23: [["DESCEND TO %s", "DESCEND TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM23",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2, 4)],
      "WU" /* WilcoUnable */
    )],
    UM24: [["AT %s DESCEND TO %s", "AT %s DESCEND TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM24",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM25: [["AT %s DESCEND TO %s", "AT %s DESCEND TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM25",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM26: [["CLIMB TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM26",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM27: [["CLIMB TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM27",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM28: [["DESCEND TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM28",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM29: [["DESCEND TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM29",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM30: [["MAINTAIN BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM30",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2), new CpdlcMessageContentLevel(4)],
      "WU" /* WilcoUnable */
    )],
    UM31: [["CLIMB TO MAINTAIN BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM31",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(4), new CpdlcMessageContentLevel(6)],
      "WU" /* WilcoUnable */
    )],
    UM32: [["DESCEND TO MAINTAIN BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM32",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(4), new CpdlcMessageContentLevel(6)],
      "WU" /* WilcoUnable */
    )],
    UM34: [["CRUISE CLIMB TO %s"], new CpdlcMessageElement("UM34", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */)],
    UM35: [["WHEN ABOVE %s COMMENCE CRUISE CLIMB", "CRUISE CLIMB ABOVE %s"], new CpdlcMessageElement(
      "UM35",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2, 3)],
      "WU" /* WilcoUnable */
    )],
    UM36: [["EXPEDITE CLIMB TO %s"], new CpdlcMessageElement("UM36", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM37: [["EXPEDITE DESCENT TO %s"], new CpdlcMessageElement("UM37", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM38: [["IMMEDIATELY CLIMB TO %s"], new CpdlcMessageElement("UM38", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM39: [["IMMEDIATELY DESCEND TO %s"], new CpdlcMessageElement("UM39", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM46: [["CROSS %s AT %s"], new CpdlcMessageElement(
      "UM46",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(3)],
      "WU" /* WilcoUnable */
    )],
    UM47: [["CROSS %s AT OR ABOVE %s"], new CpdlcMessageElement(
      "UM47",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM48: [["CROSS %s AT OR BELOW %s"], new CpdlcMessageElement(
      "UM48",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM49: [["CROSS %s AT AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM49",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM50: [["CROSS %s BETWEEN %s AND %s"], new CpdlcMessageElement(
      "UM50",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(3), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM51: [["CROSS %s AT %s"], new CpdlcMessageElement(
      "UM51",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(3)],
      "WU" /* WilcoUnable */
    )],
    UM52: [["CROSS %s AT OR BEFORE %s"], new CpdlcMessageElement(
      "UM52",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM53: [["CROSS %s AT OR AFTER %s"], new CpdlcMessageElement(
      "UM53",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM54: [["CROSS %s BETWEEN %s AND %s"], new CpdlcMessageElement(
      "UM54",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(3), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM55: [["CROSS %s AT %s"], new CpdlcMessageElement(
      "UM55",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(3)],
      "WU" /* WilcoUnable */
    )],
    UM56: [["CROSS %s AT OR LESS THAN %s"], new CpdlcMessageElement(
      "UM56",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(6)],
      "WU" /* WilcoUnable */
    )],
    UM57: [["CROSS %s AT OR GREATER THAN %s"], new CpdlcMessageElement(
      "UM57",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(6)],
      "WU" /* WilcoUnable */
    )],
    UM58: [["CROSS %s AT %s AT %s"], new CpdlcMessageElement(
      "UM58",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(3), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM59: [["CROSS %s AT OR BEFORE %s AT %s"], new CpdlcMessageElement(
      "UM59",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5), new CpdlcMessageContentLevel(7)],
      "WU" /* WilcoUnable */
    )],
    UM60: [["CROSS %s AT OR AFTER %s AT %s"], new CpdlcMessageElement(
      "UM60",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5), new CpdlcMessageContentLevel(7)],
      "WU" /* WilcoUnable */
    )],
    UM61: [["CROSS %s AT AND MAINTAIN %s AT %s"], new CpdlcMessageElement(
      "UM61",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5), new CpdlcMessageContentSpeed(7)],
      "WU" /* WilcoUnable */
    )],
    UM62: [["AT %s CROSS %s AT AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM62",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentPosition(3), new CpdlcMessageContentLevel(7)],
      "WU" /* WilcoUnable */
    )],
    UM63: [["AT %s CROSS %s AT AND MAINTAIN %s AT %s"], new CpdlcMessageElement(
      "UM63",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentPosition(3), new CpdlcMessageContentLevel(7), new CpdlcMessageContentSpeed(9)],
      "WU" /* WilcoUnable */
    )],
    UM64: [["OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM64",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDistance(1), new CpdlcMessageContentDirection(2)],
      "WU" /* WilcoUnable */
    )],
    UM65: [["AT %s OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM65",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "WU" /* WilcoUnable */
    )],
    UM66: [["AT %s OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM66",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "WU" /* WilcoUnable */
    )],
    UM67: [["PROCEED BACK ON ROUTE"], new CpdlcMessageElement("UM67", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM68: [["REJOIN ROUTE BY %s"], new CpdlcMessageElement("UM68", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "WU" /* WilcoUnable */)],
    UM69: [["REJOIN ROUTE BY %s"], new CpdlcMessageElement("UM69", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "WU" /* WilcoUnable */)],
    UM70: [["EXPECT BACK ON ROUTE BY %s"], new CpdlcMessageElement("UM70", [1 /* FansA */], [new CpdlcMessageContentPosition(5)], "WU" /* WilcoUnable */)],
    UM71: [["EXPECT BACK ON ROUTE BY %s"], new CpdlcMessageElement("UM71", [1 /* FansA */], [new CpdlcMessageContentTime(5)], "WU" /* WilcoUnable */)],
    UM72: [["RESUME OWN NAVIGATION"], new CpdlcMessageElement("UM72", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM74: [["PROCEED DIRECT TO %s"], new CpdlcMessageElement("UM74", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentPosition(3)], "WU" /* WilcoUnable */)],
    UM75: [["WHEN ABLE PROCEED DIRECT TO %s"], new CpdlcMessageElement("UM75", [1 /* FansA */], [new CpdlcMessageContentPosition(5)], "WU" /* WilcoUnable */)],
    UM76: [["AT %s PROCEED DIRECT TO %s"], new CpdlcMessageElement(
      "UM76",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM77: [["AT %s PROCEED DIRECT TO %s"], new CpdlcMessageElement(
      "UM77",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM78: [["AT %s PROCEED DIRECT TO %s"], new CpdlcMessageElement(
      "UM78",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1, true), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM79: [["CLEARED TO %s VIA %s"], new CpdlcMessageElement(
      "UM79",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentFreetext(4, -1)],
      "WU" /* WilcoUnable */
    )],
    UM80: [["CLEARED %s"], new CpdlcMessageElement("UM80", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "WU" /* WilcoUnable */)],
    UM81: [["CLEARED %s"], new CpdlcMessageElement("UM81", [1 /* FansA */], [new CpdlcMessageContentProcedure(1)], "WU" /* WilcoUnable */)],
    UM82: [["CLEARED TO DEVIATE UP TO %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM82",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDirection(5), new CpdlcMessageContentDistance(6)],
      "WU" /* WilcoUnable */
    )],
    UM83: [["AT %s CLEARED %s"], new CpdlcMessageElement(
      "UM83",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentFreetext(3, -1)],
      "WU" /* WilcoUnable */
    )],
    UM84: [["AT %s CLEARED %s"], new CpdlcMessageElement(
      "UM84",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentProcedure(3)],
      "WU" /* WilcoUnable */
    )],
    UM85: [["EXPECT %s"], new CpdlcMessageElement("UM85", [1 /* FansA */], [new CpdlcMessageContentFreetext(1, -1)], "R" /* Roger */)],
    UM86: [["AT %s EXPECT %s"], new CpdlcMessageElement(
      "UM86",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentFreetext(3, -1)],
      "R" /* Roger */
    )],
    UM87: [["EXPECT DIRECT TO %s"], new CpdlcMessageElement("UM87", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "R" /* Roger */)],
    UM88: [["AT %s EXPECT DIRECT TO %s"], new CpdlcMessageElement(
      "UM88",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentPosition(5)],
      "R" /* Roger */
    )],
    UM89: [["AT %s EXPECT DIRECT TO %s"], new CpdlcMessageElement(
      "UM89",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentPosition(5)],
      "R" /* Roger */
    )],
    UM90: [["AT %s EXPECT DIRECT TO %s"], new CpdlcMessageElement(
      "UM90",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1), new CpdlcMessageContentPosition(5)],
      "R" /* Roger */
    )],
    UM91: [["HOLD AT %s MAINTAIN %s INBOUND TRACK %s %s TURNS %s", "HOLD AT %s MAINTAIN %s INBOUND TRACK %s %s TURN LEG TIME %s"], new CpdlcMessageElement(
      "UM91",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentLevel(4), new CpdlcMessageContentDegree(7), new CpdlcMessageContentDirection(8), new CpdlcMessageContentLegType(12)],
      "WU" /* WilcoUnable */
    )],
    UM92: [["HOLD AT %s AS PUBLISHED MAINTAIN %s"], new CpdlcMessageElement(
      "UM92",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentLevel(6)],
      "WU" /* WilcoUnable */
    )],
    UM93: [["EXPECT FURTHER CLEARANCE AT %s"], new CpdlcMessageElement("UM93", [1 /* FansA */], [new CpdlcMessageContentTime(4)], "R" /* Roger */)],
    UM94: [["TURN %s HEADING %s"], new CpdlcMessageElement(
      "UM94",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDirection(1), new CpdlcMessageContentDegree(3)],
      "WU" /* WilcoUnable */
    )],
    UM95: [["TURN %s GROUND TRACK %s"], new CpdlcMessageElement(
      "UM95",
      [1 /* FansA */],
      [new CpdlcMessageContentDirection(1), new CpdlcMessageContentDegree(4)],
      "WU" /* WilcoUnable */
    )],
    UM96: [["CONTINUE PRESENT HEADING", "FLY PRESENT HEADING"], new CpdlcMessageElement("UM96", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM97: [["AT %s FLY HEADING %s"], new CpdlcMessageElement(
      "UM97",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentDegree(4)],
      "WU" /* WilcoUnable */
    )],
    UM98: [["IMMEDIATELY TURN %s HEADING %s"], new CpdlcMessageElement(
      "UM98",
      [1 /* FansA */],
      [new CpdlcMessageContentDirection(2), new CpdlcMessageContentDegree(4)],
      "WU" /* WilcoUnable */,
      true
    )],
    UM99: [["EXPECT %s"], new CpdlcMessageElement("UM99", [1 /* FansA */], [new CpdlcMessageContentProcedure(1)], "R" /* Roger */)],
    UM100: [["AT %s EXPECT %s"], new CpdlcMessageElement("UM100", [1 /* FansA */], [new CpdlcMessageContentTime(1), new CpdlcMessageContentSpeed(3)], "R" /* Roger */)],
    UM101: [["AT %s EXPECT %s"], new CpdlcMessageElement(
      "UM101",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(3)],
      "R" /* Roger */
    )],
    UM102: [["AT %s EXPECT %s"], new CpdlcMessageElement(
      "UM102",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1), new CpdlcMessageContentSpeed(3)],
      "R" /* Roger */
    )],
    UM103: [["AT %s EXPECT %s TO %s"], new CpdlcMessageElement(
      "UM103",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentSpeed(3), new CpdlcMessageContentSpeed(5)],
      "R" /* Roger */
    )],
    UM104: [["AT %s EXPECT %s TO %s"], new CpdlcMessageElement(
      "UM104",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(3), new CpdlcMessageContentSpeed(5)],
      "R" /* Roger */
    )],
    UM105: [["AT %s EXPECT %s TO %s"], new CpdlcMessageElement(
      "UM105",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1), new CpdlcMessageContentSpeed(3), new CpdlcMessageContentSpeed(5)],
      "R" /* Roger */
    )],
    UM106: [["MAINTAIN %s"], new CpdlcMessageElement("UM106", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "WU" /* WilcoUnable */)],
    UM107: [["MAINTAIN PRESENT SPEED"], new CpdlcMessageElement("UM107", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM108: [["MAINTAIN %s OR GREATER"], new CpdlcMessageElement("UM108", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "WU" /* WilcoUnable */)],
    UM109: [["MAINTAIN %s OR LESS"], new CpdlcMessageElement("UM109", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "WU" /* WilcoUnable */)],
    UM110: [["MAINTAIN %s TO %s"], new CpdlcMessageElement(
      "UM110",
      [1 /* FansA */],
      [new CpdlcMessageContentSpeed(1), new CpdlcMessageContentSpeed(3)],
      "WU" /* WilcoUnable */
    )],
    UM111: [["INCREASE SPEED TO %s"], new CpdlcMessageElement("UM111", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM112: [["INCREASE SPEED TO %s OR GREATER"], new CpdlcMessageElement("UM112", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM113: [["REDUCE SPEED TO %s"], new CpdlcMessageElement("UM113", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM114: [["REDUCE SPEED TO %s OR LESS"], new CpdlcMessageElement("UM114", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM115: [["DO NOT EXCEED %s"], new CpdlcMessageElement("UM115", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM116: [["RESUME NORMAL SPEED"], new CpdlcMessageElement("UM116", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM117: [["CONTACT %s %s"], new CpdlcMessageElement(
      "UM117",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentAtcUnit(1), new CpdlcMessageContentFrequency(2)],
      "WU" /* WilcoUnable */
    )],
    UM118: [["AT %s CONTACT %s %s"], new CpdlcMessageElement(
      "UM118",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM119: [["AT %s CONTACT %s %s"], new CpdlcMessageElement(
      "UM119",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM120: [["MONITOR %s %s"], new CpdlcMessageElement(
      "UM120",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentAtcUnit(1), new CpdlcMessageContentFrequency(2)],
      "WU" /* WilcoUnable */
    )],
    UM121: [["AT %s MONITOR %s %s"], new CpdlcMessageElement(
      "UM121",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM122: [["AT %s MONITOR %s %s"], new CpdlcMessageElement(
      "UM122",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM123: [["SQUAWK %s"], new CpdlcMessageElement("UM123", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSquawk(1)], "WU" /* WilcoUnable */)],
    UM124: [["STOP SQUAWK"], new CpdlcMessageElement("UM124", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM125: [["SQUAWK MODE CHARLIE", "SQUAWK ALTITUDE"], new CpdlcMessageElement("UM125", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM126: [["STOP SQUAWK MODE CHARLIE", "STOP SQUAWK ALTITUDE"], new CpdlcMessageElement("UM126", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM127: [["REPORT BACK ON ROUTE"], new CpdlcMessageElement("UM127", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM128: [["REPORT LEAVING %s"], new CpdlcMessageElement("UM128", [1 /* FansA */], [new CpdlcMessageContentLevel(2, true)], "WU" /* WilcoUnable */)],
    UM129: [["REPORT MAINTAINING %s", "REPORT LEVEL %s"], new CpdlcMessageElement(
      "UM129",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2, true)],
      "WU" /* WilcoUnable */
    )],
    UM130: [["REPORT PASSING %s"], new CpdlcMessageElement("UM130", [1 /* FansA */], [new CpdlcMessageContentPosition(2, true)], "WU" /* WilcoUnable */)],
    UM131: [["REPORT REMAINING FUEL AND PERSONS ON BOARD", "REPORT REMAINING FUEL AND SOULS ON BOARD"], new CpdlcMessageElement(
      "UM131",
      [1 /* FansA */],
      "Y" /* Yes */,
      true
    )],
    UM132: [["REPORT POSITION", "CONFIRM POSITION"], new CpdlcMessageElement("UM132", [1 /* FansA */], "Y" /* Yes */)],
    UM133: [["REPORT PRESENT LEVEL"], new CpdlcMessageElement("UM133", [1 /* FansA */], "Y" /* Yes */)],
    UM134: [["REPORT SPEED", "CONFIRM SPEED"], new CpdlcMessageElement("UM134", [1 /* FansA */], "Y" /* Yes */)],
    UM135: [["CONFIRM ASSIGNED LEVEL"], new CpdlcMessageElement("UM135", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    UM136: [["CONFIRM ASSIGNED SPEED"], new CpdlcMessageElement("UM136", [1 /* FansA */], "Y" /* Yes */)],
    UM137: [["CONFIRM ASSIGNED ROUTE"], new CpdlcMessageElement("UM137", [1 /* FansA */], "Y" /* Yes */)],
    UM138: [["CONFIRM TIME OVER REPORTED WAYPOINT"], new CpdlcMessageElement("UM138", [1 /* FansA */], "Y" /* Yes */)],
    UM139: [["CONFIRM REPORTED WAYPOINT"], new CpdlcMessageElement("UM139", [1 /* FansA */], "Y" /* Yes */)],
    UM140: [["CONFIRM NEXT WAYPOINT"], new CpdlcMessageElement("UM140", [1 /* FansA */], "Y" /* Yes */)],
    UM141: [["CONFIRM NEXT WAYPOINT ETA"], new CpdlcMessageElement("UM141", [1 /* FansA */], "Y" /* Yes */)],
    UM142: [["CONFIRM ENSUING WAYPOINT"], new CpdlcMessageElement("UM142", [1 /* FansA */], "Y" /* Yes */)],
    UM143: [["CONFIRM REQUEST"], new CpdlcMessageElement("UM143", [1 /* FansA */], "Y" /* Yes */)],
    UM144: [["CONFIRM SQUAWK"], new CpdlcMessageElement("UM144", [1 /* FansA */], "Y" /* Yes */)],
    UM145: [["REPORT HEADING", "CONFIRM HEADING"], new CpdlcMessageElement("UM145", [1 /* FansA */], "Y" /* Yes */)],
    UM146: [["REPORT GROUND TRACK", "CONFIRM GROUND TRACK"], new CpdlcMessageElement("UM146", [1 /* FansA */], "Y" /* Yes */)],
    UM147: [["REQUEST POSITION REPORT"], new CpdlcMessageElement("UM147", [1 /* FansA */], "Y" /* Yes */)],
    UM148: [["WHEN CAN YOU ACCEPT %s"], new CpdlcMessageElement("UM148", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(4)], "Y" /* Yes */)],
    UM149: [["CAN YOU ACCEPT %s AT %s"], new CpdlcMessageElement(
      "UM149",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentPosition(5)],
      "AN" /* AffirmNegative */
    )],
    UM150: [["CAN YOU ACCEPT %s AT %s"], new CpdlcMessageElement(
      "UM150",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "AN" /* AffirmNegative */
    )],
    UM151: [["WHEN CAN YOU ACCEPT %s"], new CpdlcMessageElement("UM151", [1 /* FansA */], [new CpdlcMessageContentSpeed(4)], "Y" /* Yes */)],
    UM152: [["WHEN CAN YOU ACCEPT %s %s OFFSET"], new CpdlcMessageElement(
      "UM152",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(4), new CpdlcMessageContentDirection(5)],
      "Y" /* Yes */
    )],
    UM153: [["ALTIMETER %s", "QNH %s"], new CpdlcMessageElement("UM153", [1 /* FansA */], [new CpdlcMessageContentAltimeter(1)], "R" /* Roger */)],
    UM154: [["RADAR SERVICE TERMINATED", "RADAR SERVICES TERMINATED"], new CpdlcMessageElement("UM154", [1 /* FansA */], "R" /* Roger */)],
    UM155: [["RADAR CONTACT %s"], new CpdlcMessageElement("UM155", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "R" /* Roger */)],
    UM156: [["RADAR CONTACT LOST"], new CpdlcMessageElement("UM156", [1 /* FansA */], "R" /* Roger */)],
    UM157: [["CHECK STUCK MICROPHONE %s"], new CpdlcMessageElement(
      "UM157",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentFrequency(3)],
      "R" /* Roger */,
      true
    )],
    UM158: [["ATIS %s"], new CpdlcMessageElement("UM158", [1 /* FansA */], [new CpdlcMessageContentAtis(1)], "R" /* Roger */)],
    UM159: [["ERROR %s"], new CpdlcMessageElement("UM159", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "NE" /* NotRequired */)],
    UM160: [["NEXT DATA AUTHORITY %s"], new CpdlcMessageElement("UM160", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentAtcUnit(3)], "NE" /* NotRequired */)],
    UM161: [["END SERVICE"], new CpdlcMessageElement("UM161", [1 /* FansA */], "NE" /* NotRequired */)],
    UM162: [["MESSAGE NOT SUPPORTED BY THIS ATS UNIT", "SERVICE UNAVAILABLE"], new CpdlcMessageElement(
      "UM162",
      [1 /* FansA */, 2 /* FansB */],
      "NE" /* NotRequired */
    )],
    UM168: [["DISREGARD"], new CpdlcMessageElement("UM168", [1 /* FansA */], "R" /* Roger */)],
    UM169: [["%s"], new CpdlcMessageElement("UM169", [1 /* FansA */], [new CpdlcMessageContentFreetext(0, -1)], "R" /* Roger */)],
    UM171: [["CLIMB AT %s MINIMUM"], new CpdlcMessageElement(
      "UM171",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM172: [["CLIMB AT %s MAXIMUM"], new CpdlcMessageElement(
      "UM172",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM173: [["DESCEND AT %s MINIMUM"], new CpdlcMessageElement(
      "UM173",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM174: [["DESCEND AT %s MAXIMUM"], new CpdlcMessageElement(
      "UM174",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM175: [["REPORT REACHING %s"], new CpdlcMessageElement("UM175", [1 /* FansA */], [new CpdlcMessageContentLevel(2, true)], "WU" /* WilcoUnable */)],
    UM176: [["MAINTAIN OWN SEPARATION AND VMC"], new CpdlcMessageElement("UM176", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM177: [["AT PILOTS DISCRETION"], new CpdlcMessageElement("UM177", [1 /* FansA */], "N" /* No */)],
    UM179: [["SQUAWK IDENT"], new CpdlcMessageElement("UM179", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM180: [["REPORT REACHING BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM180",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(3, true), new CpdlcMessageContentLevel(5, true)],
      "WU" /* WilcoUnable */
    )],
    UM181: [["REPORT DISTANCE TO %s", "REPORT DISTANCE FROM %s"], new CpdlcMessageElement(
      "UM181",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(3)],
      "Y" /* Yes */
    )],
    UM182: [["CONFIRM ATIS CODE"], new CpdlcMessageElement("UM182", [1 /* FansA */], "Y" /* Yes */)],
    UM183: [["%s"], new CpdlcMessageElement("UM183", [2 /* FansB */], [new CpdlcMessageContentFreetext(0, -1)], "R" /* Roger */)],
    UM184: [["AT TIME %s REPORT DISTANCE TO %s", "AT TIME %s REPORT DISTANCE FROM %s"], new CpdlcMessageElement(
      "UM184",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(2, true), new CpdlcMessageContentPosition(6)],
      "Y" /* Yes */
    )],
    UM190: [["FLY HEADING %s"], new CpdlcMessageElement("UM190", [2 /* FansB */], [new CpdlcMessageContentDegree(2)], "WU" /* WilcoUnable */)],
    UM213: [["%s ALTIMETER %s", "%s QNH %s"], new CpdlcMessageElement(
      "UM213",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(0), new CpdlcMessageContentAltimeter(2)],
      "R" /* Roger */
    )],
    UM215: [["TURN %s %s DEGREES"], new CpdlcMessageElement(
      "UM215",
      [2 /* FansB */],
      [new CpdlcMessageContentDirection(1), new CpdlcMessageContentDegree(2)],
      "WU" /* WilcoUnable */
    )],
    UM222: [["NO SPEED RESTRICTION"], new CpdlcMessageElement("UM222", [1 /* FansA */, 2 /* FansB */], "R" /* Roger */)],
    UM227: [["LOGICAL ACKNOWLEDGEMENT"], new CpdlcMessageElement("UM227", [2 /* FansB */], "R" /* Roger */)],
    UM228: [["REPORT ETA %s"], new CpdlcMessageElement("UM228", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "Y" /* Yes */)],
    UM231: [["STATE PREFERRED LEVEL"], new CpdlcMessageElement("UM231", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    UM232: [["STATE TOP OF DESCENT"], new CpdlcMessageElement("UM232", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    UM242: [["TRANSMIT ADS-B IDENT"], new CpdlcMessageElement("UM242", [1 /* FansA */], "R" /* Roger */)],
    UM244: [["IDENTIFICATION TERMINATED"], new CpdlcMessageElement("UM244", [1 /* FansA */], "R" /* Roger */)],
    UM9995: [["LOGOFF"], new CpdlcMessageElement("UM9995", [1 /* FansA */, 2 /* FansB */], "NE" /* NotRequired */)],
    UM9996: [["UNABLE %s"], new CpdlcMessageElement("UM9996", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "NE" /* NotRequired */)],
    UM9997: [["LOGON ACCEPTED"], new CpdlcMessageElement("UM9997", [1 /* FansA */, 2 /* FansB */], "NE" /* NotRequired */)],
    UM9998: [["HANDOVER %s"], new CpdlcMessageElement("UM9998", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentAtcUnit(1)], "NE" /* NotRequired */)],
    UM9999: [["CURRENT ATC %s"], new CpdlcMessageElement("UM9999", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(2, -1)], "NE" /* NotRequired */)]
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/AtsuTimestamp.ts
  var AtsuTimestamp = class {
    constructor() {
      __publicField(this, "Year", 0);
      __publicField(this, "Month", 0);
      __publicField(this, "Day", 0);
      __publicField(this, "Seconds", 0);
    }
    static deserialize(jsonData) {
      const retval = new AtsuTimestamp();
      if (jsonData !== null) {
        retval.Year = jsonData.Year;
        retval.Month = jsonData.Month;
        retval.Day = jsonData.Day;
        retval.Seconds = jsonData.Seconds;
      }
      return retval;
    }
    mailboxTimestamp() {
      return `${timestampToString(this.Seconds)}Z`;
    }
    fmsTimestamp() {
      return timestampToString(this.Seconds);
    }
    static fromClock(clock) {
      const timestamp = new AtsuTimestamp();
      timestamp.Year = clock.year;
      timestamp.Month = clock.month;
      timestamp.Day = clock.dayOfMonth;
      timestamp.Seconds = clock.secondsOfDay;
      return timestamp;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/AtsuMessage.ts
  var AtsuMessage = class {
    constructor() {
      __publicField(this, "Network", 0 /* Hoppie */);
      __publicField(this, "UniqueMessageID", -1);
      __publicField(this, "Timestamp", new AtsuTimestamp());
      __publicField(this, "Station", "");
      __publicField(this, "ComStatus", 0 /* Open */);
      __publicField(this, "Type", null);
      __publicField(this, "Direction", null);
      __publicField(this, "Confirmed", false);
      __publicField(this, "Message", "");
    }
    serialize(_format) {
      throw new Error("No valid implementation");
    }
    static deserialize(jsonData, message = null) {
      if (message === null)
        message = new AtsuMessage();
      message.Network = jsonData.Network;
      message.UniqueMessageID = jsonData.UniqueMessageID;
      if (jsonData.Timestamp) {
        message.Timestamp = AtsuTimestamp.deserialize(jsonData.Timestamp);
      }
      message.Station = jsonData.Station;
      message.ComStatus = jsonData.ComStatus;
      message.Type = jsonData.Type;
      message.Direction = jsonData.Direction;
      message.Confirmed = jsonData.Confirmed;
      message.Message = jsonData.Message;
      return message;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/CpdlcMessage.ts
  var CpdlcMessage = class extends AtsuMessage {
    constructor() {
      super();
      __publicField(this, "Content", []);
      __publicField(this, "Response", null);
      __publicField(this, "CurrentTransmissionId", -1);
      __publicField(this, "PreviousTransmissionId", -1);
      __publicField(this, "MailboxRelevantMessage", true);
      __publicField(this, "CloseAutomatically", true);
      __publicField(this, "MessageMonitoring", 0 /* Ignored */);
      __publicField(this, "SemanticResponseRequired", false);
      __publicField(this, "ReminderTimestamp", null);
      this.Type = 5 /* CPDLC */;
      this.Network = 0 /* Hoppie */;
      this.Direction = 1 /* Downlink */;
    }
    static deserialize(jsonData, message = null) {
      if (message === null)
        message = new CpdlcMessage();
      AtsuMessage.deserialize(jsonData, message);
      jsonData.Content.forEach((element) => message.Content.push(CpdlcMessageElement.deserialize(element)));
      if (jsonData.Response) {
        message.Response = CpdlcMessage.deserialize(jsonData.Response);
      }
      message.CurrentTransmissionId = jsonData.CurrentTransmissionId;
      message.PreviousTransmissionId = jsonData.PreviousTransmissionId;
      message.MailboxRelevantMessage = jsonData.MailboxRelevantMessage;
      message.CloseAutomatically = jsonData.CloseAutomatically;
      message.MessageMonitoring = jsonData.MessageMonitoring;
      message.SemanticResponseRequired = jsonData.SemanticResponseRequired;
      if (jsonData.ReminderTimestamp) {
        message.ReminderTimestamp = AtsuTimestamp.deserialize(jsonData.ReminderTimestamp);
      }
      return message;
    }
    serializeContent(format, template, element) {
      let content = "";
      content = template;
      element.Content.forEach((entry) => {
        const idx = content.indexOf("%s");
        if (format === 4 /* Network */) {
          content = `${content.substring(0, idx)}${entry.Value}${content.substring(idx + 2)}`;
        } else if (entry.Value !== "") {
          if (this.MessageMonitoring === 2 /* Monitoring */ && format === 1 /* FmsDisplayMonitored */) {
            content = `${content.substring(0, idx)}{magenta}${entry.Value}{end}${content.substring(idx + 2)}`;
          } else {
            content = `${content.substring(0, idx)}@${entry.Value}@${content.substring(idx + 2)}`;
          }
        } else {
          content = `${content.substring(0, idx)}[      ]${content.substring(idx + 2)}`;
        }
      });
      return content;
    }
    extendSerializationWithResponse() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!this.Response || this.Response.Content.length === 0) {
        return false;
      }
      return ((_a = this.Response.Content[0]) == null ? void 0 : _a.TypeId) !== "DM0" && ((_b = this.Response.Content[0]) == null ? void 0 : _b.TypeId) !== "DM1" && ((_c = this.Response.Content[0]) == null ? void 0 : _c.TypeId) !== "DM2" && ((_d = this.Response.Content[0]) == null ? void 0 : _d.TypeId) !== "DM3" && ((_e = this.Response.Content[0]) == null ? void 0 : _e.TypeId) !== "DM4" && ((_f = this.Response.Content[0]) == null ? void 0 : _f.TypeId) !== "DM5" && ((_g = this.Response.Content[0]) == null ? void 0 : _g.TypeId) !== "UM0" && ((_h = this.Response.Content[0]) == null ? void 0 : _h.TypeId) !== "UM1" && ((_i = this.Response.Content[0]) == null ? void 0 : _i.TypeId) !== "UM3" && ((_j = this.Response.Content[0]) == null ? void 0 : _j.TypeId) !== "UM4" && ((_k = this.Response.Content[0]) == null ? void 0 : _k.TypeId) !== "UM5";
    }
    serialize(format) {
      var _a;
      const lineLength = format === 2 /* Mailbox */ ? 30 : 25;
      const lines = [];
      let message = "";
      if (this.Content.length !== 0) {
        for (const element of this.Content) {
          if (this.Direction === 1 /* Downlink */) {
            lines.push(...wordWrap(this.serializeContent(format, CpdlcMessagesDownlink[element.TypeId][0][0], element), lineLength));
          } else {
            lines.push(...wordWrap(this.serializeContent(format, CpdlcMessagesUplink[element.TypeId][0][0], element), lineLength));
          }
        }
      } else {
        this.Message.split("_").forEach((entry) => {
          lines.push(...wordWrap(entry, lineLength));
        });
      }
      if (format === 4 /* Network */) {
        message = `/data2/${this.CurrentTransmissionId}/${this.PreviousTransmissionId !== -1 ? this.PreviousTransmissionId : ""}/${(_a = this.Content[0]) == null ? void 0 : _a.ExpectedResponse}/${lines.join(" ")}`;
      } else if (format === 2 /* Mailbox */) {
        message = lines.join("\n");
      } else if (format === 0 /* FmsDisplay */ || format === 1 /* FmsDisplayMonitored */) {
        if (this.Direction === 0 /* Uplink */) {
          message += `{cyan}${this.Timestamp.mailboxTimestamp()} FROM ${this.Station}{end}
`;
        } else {
          message += `{cyan}${this.Timestamp.mailboxTimestamp()} TO ${this.Station}{end}
`;
        }
        lines.forEach((line) => {
          line = line.replace(/@/gi, "");
          if (format === 1 /* FmsDisplayMonitored */) {
            message += line;
          } else {
            message += `{green}${line}{end}
`;
          }
        });
        message += "{white}------------------------{end}\n";
        if (this.extendSerializationWithResponse()) {
          message += this.Response.serialize(format);
        }
      } else if (format === 3 /* Printer */) {
        message += `${this.Timestamp.mailboxTimestamp()} ${this.Direction === 0 /* Uplink */ ? "FROM" : "TO"} ${this.Station}}
`;
        lines.forEach((line) => {
          line = line.replace(/@/gi, "");
          message += `${line}
`;
        });
        message += "------------------------\n";
        if (this.extendSerializationWithResponse()) {
          message += this.Response.serialize(format);
        }
      } else {
        message = this.Message;
      }
      return message;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/components/UplinkMessageInterpretation.ts
  var _UplinkMessageInterpretation = class {
    static MessageRemainsOnMailbox(message) {
      return _UplinkMessageInterpretation.NonAutomaticClosingMessage.findIndex((elem) => message.Content[0].TypeId === elem) !== -1;
    }
    static SemanticAnswerRequired(message) {
      return message.Content[0].TypeId === "UM143" || message.Content[0].TypeId in _UplinkMessageInterpretation.SemanticAnswerTable;
    }
    static FillPresentData(atc, message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM132":
          if (atc.digitalInputs.PresentPosition.latitude.isNormalOperation() && atc.digitalInputs.PresentPosition.longitude.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = coordinateToString({
              lat: atc.digitalInputs.PresentPosition.latitude.value,
              lon: atc.digitalInputs.PresentPosition.longitude.value
            }, false);
            return true;
          }
          return false;
        case "UM133":
          if (atc.digitalInputs.PresentPosition.altitude.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadAltitude(Math.round(atc.digitalInputs.PresentPosition.altitude.value / 100).toString());
            return true;
          }
          return false;
        case "UM134":
          if (atc.digitalInputs.PresentDynamics.computedAirspeed.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadSpeed(Math.round(atc.digitalInputs.PresentDynamics.computedAirspeed.value).toString());
            return true;
          }
          return false;
        case "UM144":
          message.Response.Content[0].Content[0].Value = String(atc.digitalInputs.TransponderCode).padStart(4, "0");
          return true;
        case "UM145":
          if (atc.digitalInputs.PresentPosition.heading.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadSpeed(Math.round(atc.digitalInputs.PresentPosition.heading.value).toString());
            return true;
          }
          return false;
        case "UM146":
          if (atc.digitalInputs.PresentPosition.track.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadSpeed(Math.round(atc.digitalInputs.PresentPosition.track.value).toString());
            return true;
          }
          return false;
        case "UM228":
          if (atc.digitalInputs.FlightRoute.destination) {
            message.Response.Content[0].Content[0].Value = `${timestampToString(atc.digitalInputs.FlightRoute.destination.utc)}Z`;
            return true;
          }
          return false;
        default:
          return false;
      }
    }
    static FillAssignedData(atc, message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM135":
          message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadAltitude(Math.round(Math.round(atc.digitalInputs.AutopilotData.selectedAltitude) / 100).toString());
          return true;
        case "UM136":
          if (atc.digitalInputs.AutopilotData.autothrustMode.isNormalOperation() && atc.digitalInputs.AutopilotData.autothrustMode.value !== 0) {
            let content = "";
            if (atc.digitalInputs.AutopilotData.machMode) {
              content = InputValidation.formatScratchpadAltitude(atc.digitalInputs.AutopilotData.selectedMach.value.toString());
            } else {
              content = InputValidation.formatScratchpadAltitude(Math.round(atc.digitalInputs.AutopilotData.selectedSpeed.value).toString());
            }
            message.Response.Content[0].Content[0].Value = content;
            return true;
          }
          return false;
        default:
          return false;
      }
    }
    static FillPositionReportRelatedData(atc, message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM138":
          if (atc.digitalInputs.FlightRoute.lastWaypoint) {
            message.Response.Content[0].Content[0].Value = `${timestampToString(atc.digitalInputs.FlightRoute.lastWaypoint.utc)}Z`;
          }
          return true;
        case "UM139":
          if (atc.digitalInputs.FlightRoute.lastWaypoint) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.lastWaypoint.ident;
          }
          return true;
        case "UM140":
          if (atc.digitalInputs.FlightRoute.activeWaypoint) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.activeWaypoint.ident;
          }
          return true;
        case "UM141":
          if (atc.digitalInputs.FlightRoute.activeWaypoint) {
            message.Response.Content[0].Content[0].Value = `${timestampToString(atc.digitalInputs.FlightRoute.activeWaypoint.utc)}Z`;
          }
          return true;
        case "UM142":
          if (atc.digitalInputs.FlightRoute.nextWaypoint) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.nextWaypoint.ident;
          }
          return true;
        case "UM147":
          message.Response = atc.createPositionReport();
          return true;
        case "UM148":
        case "UM151":
          message.Response.Content[0].Content[0].Value = message.Content[0].Content[0].Value;
          return true;
        case "UM152":
          message.Response.Content[0].Content[0].Value = message.Content[0].Content[0].Value;
          message.Response.Content[0].Content[1].Value = message.Content[0].Content[1].Value;
          return true;
        case "UM228":
          if (atc.digitalInputs.FlightRoute.destination) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.destination.ident;
            message.Response.Content[0].Content[1].Value = `${timestampToString(atc.digitalInputs.FlightRoute.destination.utc)}Z`;
          }
          return true;
        default:
          return false;
      }
    }
    static FillReportingRelatedData(message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM128":
        case "UM129":
        case "UM130":
        case "UM175":
          message.Response.Content[0].Content[0].Value = message.Content[0].Content[0].Value;
          return true;
        case "UM180":
          for (let i = 0; i < message.Response.Content[0].Content.length; ++i) {
            message.Response.Content[0].Content[i].Value = message.Content[0].Content[i].Value;
          }
          return true;
        default:
          return false;
      }
    }
    static AppendSemanticAnswer(atc, positiveAnswer, message) {
      var _a, _b;
      if (((_a = message.Content[0]) == null ? void 0 : _a.TypeId) === "UM143") {
        for (const atcMessage of atc.messages()) {
          const cpdlc = atcMessage;
          if (_UplinkMessageInterpretation.RequestMessages.findIndex((elem) => elem === cpdlc.Content[0].TypeId) !== -1) {
            const response = new CpdlcMessage();
            response.Station = atcMessage.Station;
            response.PreviousTransmissionId = message.CurrentTransmissionId;
            for (const entry of cpdlc.Content) {
              response.Content.push(entry.deepCopy());
            }
            message.Response = response;
            return true;
          }
        }
        if (!message.Response) {
          const response = new CpdlcMessage();
          response.Station = message.Station;
          response.PreviousTransmissionId = message.CurrentTransmissionId;
          response.Content.push(CpdlcMessagesDownlink.DM67[1].deepCopy());
          response.Content[0].Content[0].Value = "NO REQUEST TRANSMITTED";
          message.Response = response;
        }
      } else if (((_b = message.Content[0]) == null ? void 0 : _b.TypeId) in _UplinkMessageInterpretation.SemanticAnswerTable) {
        const lutEntry = _UplinkMessageInterpretation.SemanticAnswerTable[message.Content[0].TypeId];
        if (lutEntry.positiveOrNegative) {
          const response = new CpdlcMessage();
          response.Station = message.Station;
          response.PreviousTransmissionId = message.CurrentTransmissionId;
          if (positiveAnswer) {
            response.Content.push(CpdlcMessagesDownlink[lutEntry.messages[0]][1].deepCopy());
          } else {
            response.Content.push(CpdlcMessagesDownlink[lutEntry.messages[1]][1].deepCopy());
          }
          message.Response = response;
        } else if (lutEntry.messages[0] in CpdlcMessagesDownlink) {
          const response = new CpdlcMessage();
          response.Station = message.Station;
          response.PreviousTransmissionId = message.CurrentTransmissionId;
          response.Content.push(CpdlcMessagesDownlink[lutEntry.messages[0]][1].deepCopy());
          message.Response = response;
        }
      }
      if (!_UplinkMessageInterpretation.FillPresentData(atc, message) && !_UplinkMessageInterpretation.FillAssignedData(atc, message)) {
        if (!_UplinkMessageInterpretation.FillPositionReportRelatedData(atc, message)) {
          _UplinkMessageInterpretation.FillReportingRelatedData(message);
        }
      }
      return false;
    }
    static HasNegativeResponse(message) {
      var _a, _b;
      if (((_a = message.Content[0]) == null ? void 0 : _a.TypeId) in _UplinkMessageInterpretation.SemanticAnswerTable) {
        const lutEntry = _UplinkMessageInterpretation.SemanticAnswerTable[(_b = message.Content[0]) == null ? void 0 : _b.TypeId];
        if (lutEntry.positiveOrNegative) {
          return message.Response.Content[0].TypeId !== lutEntry.messages[1];
        }
      }
      return false;
    }
    static IsModifiable(message) {
      var _a, _b;
      if (((_a = message.Content[0]) == null ? void 0 : _a.TypeId) in _UplinkMessageInterpretation.SemanticAnswerTable) {
        const lutEntry = _UplinkMessageInterpretation.SemanticAnswerTable[(_b = message.Content[0]) == null ? void 0 : _b.TypeId];
        return lutEntry.modifiable;
      }
      return false;
    }
  };
  var UplinkMessageInterpretation = _UplinkMessageInterpretation;
  __publicField(UplinkMessageInterpretation, "NonAutomaticClosingMessage", [
    "UM127",
    "UM128",
    "UM129",
    "UM130",
    "UM131",
    "UM132",
    "UM133",
    "UM134",
    "UM135",
    "UM136",
    "UM137",
    "UM138",
    "UM139",
    "UM140",
    "UM141",
    "UM142",
    "UM143",
    "UM144",
    "UM145",
    "UM146",
    "UM147",
    "UM148",
    "UM151",
    "UM152",
    "UM180",
    "UM181",
    "UM182",
    "UM228",
    "UM231",
    "UM232"
  ]);
  __publicField(UplinkMessageInterpretation, "RequestMessages", [
    "DM15",
    "DM16",
    "DM17",
    "DM18",
    "DM19",
    "DM20",
    "DM21",
    "DM22",
    "DM23",
    "DM24",
    "DM25",
    "DM26",
    "DM27",
    "DM51",
    "DM52",
    "DM53",
    "DM54",
    "DM69",
    "DM70",
    "DM71",
    "DM72",
    "DM73",
    "DM74"
  ]);
  __publicField(UplinkMessageInterpretation, "SemanticAnswerTable", {
    UM128: { positiveOrNegative: false, modifiable: false, messages: ["DM28"] },
    UM129: { positiveOrNegative: false, modifiable: false, messages: ["DM37"] },
    UM130: { positiveOrNegative: false, modifiable: false, messages: ["DM31"] },
    UM131: { positiveOrNegative: false, modifiable: true, messages: ["DM57"] },
    UM132: { positiveOrNegative: false, modifiable: true, messages: ["DM33"] },
    UM133: { positiveOrNegative: false, modifiable: true, messages: ["DM32"] },
    UM134: { positiveOrNegative: false, modifiable: true, messages: ["DM34"] },
    UM135: { positiveOrNegative: false, modifiable: true, messages: ["DM38"] },
    UM136: { positiveOrNegative: false, modifiable: true, messages: ["DM39"] },
    UM137: { positiveOrNegative: false, modifiable: true, messages: ["DM40"] },
    UM138: { positiveOrNegative: false, modifiable: true, messages: ["DM46"] },
    UM139: { positiveOrNegative: false, modifiable: true, messages: ["DM45"] },
    UM140: { positiveOrNegative: false, modifiable: true, messages: ["DM42"] },
    UM141: { positiveOrNegative: false, modifiable: true, messages: ["DM43"] },
    UM142: { positiveOrNegative: false, modifiable: true, messages: ["DM44"] },
    UM144: { positiveOrNegative: false, modifiable: true, messages: ["DM47"] },
    UM145: { positiveOrNegative: false, modifiable: true, messages: ["DM35"] },
    UM146: { positiveOrNegative: false, modifiable: true, messages: ["DM36"] },
    UM147: { positiveOrNegative: false, modifiable: true, messages: ["DM48"] },
    UM148: { positiveOrNegative: true, modifiable: true, messages: ["DM81", "DM82"] },
    UM151: { positiveOrNegative: false, modifiable: true, messages: ["DM83"] },
    UM152: { positiveOrNegative: true, modifiable: true, messages: ["DM85", "DM86"] },
    UM175: { positiveOrNegative: false, modifiable: false, messages: ["DM72"] },
    UM180: { positiveOrNegative: false, modifiable: false, messages: ["DM76"] },
    UM181: { positiveOrNegative: false, modifiable: true, messages: ["DM67"] },
    UM182: { positiveOrNegative: false, modifiable: true, messages: ["DM79"] },
    UM184: { positiveOrNegative: false, modifiable: true, messages: ["DM67"] },
    UM228: { positiveOrNegative: false, modifiable: true, messages: ["DM104"] },
    UM231: { positiveOrNegative: false, modifiable: true, messages: ["DM106"] },
    UM232: { positiveOrNegative: false, modifiable: true, messages: ["DM109"] }
  });

  // ../fbw-common/src/systems/datalink/common/src/types/Clock.ts
  var Clock = class {
    constructor(year, month, dayOfMonth, hour, minute, second, secondsOfDay) {
      this.year = year;
      this.month = month;
      this.dayOfMonth = dayOfMonth;
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.secondsOfDay = secondsOfDay;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/components/UplinkMonitor.ts
  var _UplinkMonitor = class {
    constructor(message) {
      __publicField(this, "type");
      __publicField(this, "messageId", -1);
      this.messageId = message.UniqueMessageID;
    }
    static relevantMessage(message) {
      if (_UplinkMonitor.positionMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) === -1 && _UplinkMonitor.timeMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) === -1 && _UplinkMonitor.levelMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) === -1) {
        return false;
      }
      return true;
    }
    static createMessageMonitor(message) {
      if (_UplinkMonitor.positionMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) !== -1) {
        return new PositionMonitor(message);
      }
      if (_UplinkMonitor.timeMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) !== -1) {
        return new TimeMonitor(message);
      }
      if (_UplinkMonitor.levelMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) !== -1) {
        return new LevelMonitor(message);
      }
      return null;
    }
  };
  var UplinkMonitor = _UplinkMonitor;
  __publicField(UplinkMonitor, "positionMonitoringMessageIds", ["UM22", "UM25", "UM65", "UM77", "UM83", "UM84", "UM97", "UM118", "UM121", "UM130"]);
  __publicField(UplinkMonitor, "timeMonitoringMessageIds", ["UM21", "UM24", "UM66", "UM76", "UM119", "UM122", "UM184"]);
  __publicField(UplinkMonitor, "levelMonitoringMessageIds", ["UM78", "UM128", "UM129", "UM130", "UM175", "UM180"]);
  var PositionMonitor = class extends UplinkMonitor {
    constructor(message) {
      var _a, _b;
      super(message);
      __publicField(this, "positionMonitor", "");
      this.type = 2 /* Position */;
      this.positionMonitor = (_b = (_a = message.Content[0]) == null ? void 0 : _a.Content[0]) == null ? void 0 : _b.Value;
    }
    conditionsMet(condition) {
      if (typeof condition !== "number" && "ident" in condition) {
        const lastPosition = condition.ident;
        return this.positionMonitor === lastPosition;
      }
      return false;
    }
  };
  var _TimeMonitor = class extends UplinkMonitor {
    constructor(message) {
      var _a, _b;
      super(message);
      __publicField(this, "timeOffset", 0);
      __publicField(this, "timeMonitor", -1);
      this.type = 0 /* Time */;
      if (_TimeMonitor.deferredMessageIDs.findIndex((id) => {
        var _a2;
        return id === ((_a2 = message.Content[0]) == null ? void 0 : _a2.TypeId);
      }) !== -1) {
        this.timeOffset = 30;
      }
      this.timeMonitor = _TimeMonitor.extractSeconds((_b = (_a = message.Content[0]) == null ? void 0 : _a.Content[0]) == null ? void 0 : _b.Value);
    }
    static extractSeconds(value) {
      const matches = value.match(/[0-9]{2}/g);
      const hours = parseInt(matches[0]);
      const minutes = parseInt(matches[1]);
      return (hours * 60 + minutes) * 60;
    }
    conditionsMet(condition) {
      if (condition instanceof Clock) {
        if (condition.secondsOfDay + this.timeOffset >= this.timeMonitor) {
          return condition.secondsOfDay - this.timeMonitor < 30;
        }
      }
      return false;
    }
  };
  var TimeMonitor = _TimeMonitor;
  __publicField(TimeMonitor, "deferredMessageIDs", ["UM66", "UM69", "UM119", "UM122"]);
  var LevelMonitor = class extends UplinkMonitor {
    constructor(message) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      super(message);
      __publicField(this, "lowerLevel", -1);
      __publicField(this, "upperLevel", -1);
      __publicField(this, "reachingLevel", false);
      __publicField(this, "leavingLevel", false);
      __publicField(this, "reachedLevel", false);
      this.type = 1 /* Altitude */;
      this.lowerLevel = LevelMonitor.extractAltitude((_b = (_a = message.Content[0]) == null ? void 0 : _a.Content[0]) == null ? void 0 : _b.Value);
      if (((_c = message.Content[0]) == null ? void 0 : _c.TypeId) === "UM180") {
        this.upperLevel = LevelMonitor.extractAltitude((_d = message.Content[0]) == null ? void 0 : _d.Content[1].Value);
        this.reachingLevel = true;
      } else if (((_e = message.Content[0]) == null ? void 0 : _e.TypeId) === "UM78" || ((_f = message.Content[0]) == null ? void 0 : _f.TypeId) === "UM129" || ((_g = message.Content[0]) == null ? void 0 : _g.TypeId) === "UM175") {
        this.reachingLevel = true;
      } else if (((_h = message.Content[0]) == null ? void 0 : _h.TypeId) === "UM128") {
        this.reachingLevel = false;
      } else if (((_i = message.Content[0]) == null ? void 0 : _i.TypeId) === "UM130") {
        this.reachingLevel = true;
        this.leavingLevel = true;
      }
    }
    static extractAltitude(value) {
      let altitude = parseInt(value.match(/[0-9]+/)[0]);
      if (value.startsWith("FL")) {
        altitude *= 100;
      } else if (value.endsWith("M")) {
        altitude *= 3.28084;
      }
      return altitude;
    }
    conditionsMet(condition) {
      if (typeof condition === "number") {
        if (this.reachingLevel && this.leavingLevel) {
          if (!this.reachedLevel) {
            this.reachedLevel = Math.abs(condition - this.lowerLevel) <= 100;
          } else {
            return Math.abs(condition - this.lowerLevel) > 100;
          }
        }
        if (!this.reachingLevel) {
          return Math.abs(condition - this.lowerLevel) > 100;
        }
        if (this.upperLevel > -1) {
          return this.lowerLevel <= condition && this.upperLevel >= condition;
        }
        return Math.abs(condition - this.lowerLevel) <= 100;
      }
      return false;
    }
  };

  // src/systems/shared/src/persistence.ts
  var _NXDataStore = class {
    static get listener() {
      if (this.mListener === void 0) {
        this.mListener = RegisterViewListener("JS_LISTENER_SIMVARS", null, true);
      }
      return this.mListener;
    }
    static get(key, defaultVal) {
      const val = GetStoredData(`A32NX_${key}`);
      if (val === null || val.length === 0) {
        return defaultVal;
      }
      return val;
    }
    static set(key, val) {
      SetStoredData(`A32NX_${key}`, val);
      this.listener.triggerToAllSubscribers("A32NX_NXDATASTORE_UPDATE", key, val);
    }
    static subscribe(key, callback) {
      return Coherent.on("A32NX_NXDATASTORE_UPDATE", (updatedKey, value) => {
        if (key === "*" || key === updatedKey) {
          callback(updatedKey, value);
        }
      }).clear;
    }
    static getAndSubscribe(key, callback, defaultVal) {
      callback(key, _NXDataStore.get(key, defaultVal));
      return _NXDataStore.subscribe(key, callback);
    }
  };
  var NXDataStore = _NXDataStore;
  __publicField(NXDataStore, "mListener");

  // ../fbw-common/src/systems/datalink/common/src/messages/WeatherMessage.ts
  var WeatherMessage = class extends AtsuMessage {
    constructor() {
      super();
      __publicField(this, "Reports", []);
      this.Direction = 0 /* Uplink */;
    }
    serialize(format) {
      let type = "";
      switch (this.Type) {
        case 1 /* METAR */:
          type = "METAR";
          break;
        case 2 /* TAF */:
          type = "TAF";
          break;
        default:
          type = "ATIS";
          break;
      }
      let message = "";
      if (format === 0 /* FmsDisplay */ || format === 1 /* FmsDisplayMonitored */) {
        this.Reports.forEach((report) => {
          message += `{cyan}${type} ${report.airport}{end}
`;
          wordWrap(report.report, 25).forEach((line) => {
            if (line.startsWith("D-ATIS")) {
              message += `{amber}${line}{end}
`;
            } else if (line === "NO METAR AVAILABLE" || line === "NO TAF AVAILABLE") {
              message += `{amber}${line}{end}
`;
            } else {
              message += `{green}${line}{end}
`;
            }
          });
          message += "{white}------------------------{end}\n";
        });
      } else {
        this.Reports.forEach((report) => {
          message += `${type} ${report.airport}
`;
          message += `${report.report}
`;
          message += "------------------------\n";
        });
      }
      return message;
    }
    static deserialize(jsonData, message = null) {
      if (message === null)
        message = new WeatherMessage();
      AtsuMessage.deserialize(jsonData, message);
      jsonData.Reports.forEach((report) => {
        message.Reports.push({ airport: report.airport, report: report.report });
      });
      return message;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/AtisMessage.ts
  var AtisMessage = class extends WeatherMessage {
    constructor() {
      super();
      __publicField(this, "Information", "");
      this.Type = 3 /* ATIS */;
      this.Station = NXDataStore.get("CONFIG_ATIS_SRC", "MSFS");
    }
    parseInformation() {
      let foundInfo = false;
      this.Reports.forEach((report) => {
        report.report.split(" ").forEach((word) => {
          if (foundInfo === false) {
            if (word === "INFORMATION" || word === "INFO") {
              foundInfo = true;
            }
          } else {
            this.Information = word;
            if (this.Information.length > 1) {
              this.Information = this.Information[0];
            }
            foundInfo = false;
          }
        });
      });
    }
    static deserialize(jsonData) {
      const retval = new AtisMessage();
      WeatherMessage.deserialize(jsonData, retval);
      retval.Information = jsonData.Information;
      return retval;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/DclMessage.ts
  var DclMessage = class extends CpdlcMessage {
    constructor() {
      super();
      __publicField(this, "Callsign", "");
      __publicField(this, "Origin", "");
      __publicField(this, "Destination", "");
      __publicField(this, "AcType", "");
      __publicField(this, "Atis", "");
      __publicField(this, "Gate", "");
      __publicField(this, "Freetext", []);
      this.Type = 6 /* DCL */;
      this.Direction = 1 /* Downlink */;
      this.CloseAutomatically = false;
    }
    serialize(format) {
      let dclMessage = "";
      if (format === 4 /* Network */) {
        dclMessage = "REQUEST PREDEP CLEARANCE \n";
        dclMessage += `${this.Callsign} ${this.AcType} TO ${this.Destination} 
`;
        dclMessage += `AT ${this.Origin}${this.Gate !== "" ? ` STAND ${this.Gate}` : ""} 
`;
        dclMessage += `ATIS ${this.Atis}`;
      } else {
        if (format !== 2 /* Mailbox */) {
          dclMessage = `${this.Timestamp.mailboxTimestamp()} TO ${this.Station}
`;
        }
        dclMessage += `DEPART REQUEST
${this.Callsign}
`;
        dclMessage += `FROM:${this.Origin}${this.Gate.length !== 0 ? ` GATE:${this.Gate}` : ""}
`;
        dclMessage += `TO:${this.Destination} ATIS:${this.Atis}
`;
        dclMessage += `A/C TYPE:${this.AcType}`;
        const freetext = this.Freetext.join("\n").replace(/^\s*\n/gm, "");
        if (freetext.length !== 0) {
          dclMessage += `
${freetext}`;
        }
      }
      return dclMessage;
    }
    static deserialize(jsonData) {
      const retval = new DclMessage();
      CpdlcMessage.deserialize(jsonData, retval);
      retval.Callsign = jsonData.Callsign;
      retval.Origin = jsonData.Origin;
      retval.Destination = jsonData.Destination;
      retval.AcType = jsonData.AcType;
      retval.Gate = jsonData.Gate;
      retval.Atis = jsonData.Atis;
      retval.Freetext = jsonData.Freetext;
      return retval;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/FreetextMessage.ts
  var FreetextMessage = class extends AtsuMessage {
    constructor() {
      super();
      this.Type = 0 /* Freetext */;
      this.Direction = 1 /* Downlink */;
    }
    serialize(format) {
      let message = "";
      if (format === 0 /* FmsDisplay */ || format === 1 /* FmsDisplayMonitored */) {
        wordWrap(this.Message, 25).forEach((line) => {
          message += `{green}${line}{end}
`;
        });
        message += "{white}------------------------{end}\n";
      } else {
        message = this.Message;
      }
      return message;
    }
    static deserialize(jsonData) {
      const retval = new FreetextMessage();
      AtsuMessage.deserialize(jsonData, retval);
      return retval;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/MetarMessage.ts
  var MetarMessage = class extends WeatherMessage {
    constructor() {
      super();
      this.Type = 1 /* METAR */;
      this.Station = NXDataStore.get("CONFIG_METAR_SRC", "MSFS");
    }
    static deserialize(jsonData) {
      const retval = new MetarMessage();
      WeatherMessage.deserialize(jsonData, retval);
      return retval;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/OclMessage.ts
  var OclMessage = class extends CpdlcMessage {
    constructor() {
      super();
      __publicField(this, "Callsign", "");
      __publicField(this, "Destination", "");
      __publicField(this, "EntryPoint", "");
      __publicField(this, "EntryTime", "");
      __publicField(this, "RequestedMach", "");
      __publicField(this, "RequestedFlightlevel", "");
      __publicField(this, "Freetext", []);
      this.Type = 7 /* OCL */;
      this.Direction = 1 /* Downlink */;
      this.CloseAutomatically = false;
    }
    serialize(format) {
      let oclMessage = `OCEANIC REQUEST
${this.Callsign} 
`;
      oclMessage += `ENTRY POINT:${this.EntryPoint}
AT:${this.EntryTime} 
`;
      oclMessage += `REQ:${this.RequestedMach} ${this.RequestedFlightlevel}`;
      const freetext = this.Freetext.join("\n").replace(/^\s*\n/gm, "");
      if (freetext.length !== 0) {
        oclMessage += `
${freetext}`;
      }
      if (format === 4 /* Network */) {
        oclMessage = `/data2/${this.CurrentTransmissionId}//N/${oclMessage}`;
      } else if (format !== 2 /* Mailbox */) {
        oclMessage = `${this.Timestamp.mailboxTimestamp()} TO ${this.Station}
${oclMessage}`;
      }
      return oclMessage;
    }
    static deserialize(jsonData) {
      const retval = new OclMessage();
      CpdlcMessage.deserialize(jsonData, retval);
      retval.Callsign = jsonData.Callsign;
      retval.Destination = jsonData.Destination;
      retval.EntryPoint = jsonData.EntryPoint;
      retval.EntryTime = jsonData.EntryTime;
      retval.RequestedMach = jsonData.RequestedMach;
      retval.RequestedFlightlevel = jsonData.RequestedFlightlevel;
      retval.Freetext = jsonData.Freetext;
      return retval;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/TafMessage.ts
  var TafMessage = class extends WeatherMessage {
    constructor() {
      super();
      this.Type = 2 /* TAF */;
      this.Station = NXDataStore.get("CONFIG_TAF_SRC", "MSFS");
    }
    static deserialize(jsonData) {
      const retval = new TafMessage();
      WeatherMessage.deserialize(jsonData, retval);
      return retval;
    }
  };

  // ../fbw-common/src/systems/datalink/common/src/messages/Conversion.ts
  var Conversion = class {
    static messageDataToMessage(data) {
      switch (data.Type) {
        case 3 /* ATIS */:
          return AtisMessage.deserialize(data);
        case 5 /* CPDLC */:
          return CpdlcMessage.deserialize(data);
        case 6 /* DCL */:
          return DclMessage.deserialize(data);
        case 0 /* Freetext */:
          return FreetextMessage.deserialize(data);
        case 1 /* METAR */:
          return MetarMessage.deserialize(data);
        case 7 /* OCL */:
          return OclMessage.deserialize(data);
        case 2 /* TAF */:
          return TafMessage.deserialize(data);
        default:
          return null;
      }
    }
  };

  // src/systems/shared/src/arinc429.ts
  var _Arinc429Word = class {
    constructor(word) {
      __publicField(this, "ssm");
      __publicField(this, "value");
      _Arinc429Word.u32View[0] = (word & 4294967295) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 3;
      this.value = _Arinc429Word.f32View[0];
    }
    static empty() {
      return new _Arinc429Word(0);
    }
    static fromSimVarValue(name) {
      return new _Arinc429Word(SimVar.GetSimVarValue(name, "number"));
    }
    static async toSimVarValue(name, value, ssm) {
      _Arinc429Word.f32View[0] = value;
      const simVal = _Arinc429Word.u32View[0] + Math.trunc(ssm) * 2 ** 32;
      return SimVar.SetSimVarValue(name, "string", simVal.toString());
    }
    isFailureWarning() {
      return this.ssm === 0 /* FailureWarning */;
    }
    isNoComputedData() {
      return this.ssm === 1 /* NoComputedData */;
    }
    isFunctionalTest() {
      return this.ssm === 2 /* FunctionalTest */;
    }
    isNormalOperation() {
      return this.ssm === 3 /* NormalOperation */;
    }
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    getBitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    getBitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
    setBitValue(bit, value) {
      if (value) {
        this.value |= 1 << bit - 1;
      } else {
        this.value &= ~(1 << bit - 1);
      }
    }
  };
  var Arinc429Word = _Arinc429Word;
  __publicField(Arinc429Word, "u32View", new Uint32Array(1));
  __publicField(Arinc429Word, "f32View", new Float32Array(_Arinc429Word.u32View.buffer));

  // ../fbw-common/src/systems/datalink/common/src/msfs/SimVarHandling.ts
  var _SimVarHandling = class extends SimVarPublisher {
    constructor(eventBus) {
      super(_SimVarHandling.simvars, eventBus);
      this.eventBus = eventBus;
      __publicField(this, "subscriber", null);
      __publicField(this, "datalinkPublisher", null);
    }
    connectedCallback() {
      super.subscribe("msfsUtcYear");
      super.subscribe("msfsUtcMonth");
      super.subscribe("msfsUtcDayOfMonth");
      super.subscribe("msfsUtcSeconds");
      super.subscribe("msfsPresentPositionLatitude");
      super.subscribe("msfsPresentPositionLongitude");
      super.subscribe("msfsPresentAltitude");
      super.subscribe("msfsPresentHeading");
      super.subscribe("msfsPresentTrack");
      super.subscribe("msfsComputedAirspeed");
      super.subscribe("msfsPresentMach");
      super.subscribe("msfsGroundSpeed");
      super.subscribe("msfsVerticalSpeed");
      super.subscribe("msfsAutopilotActive");
      super.subscribe("msfsAutothrustMode");
      super.subscribe("msfsAutothrustSelectedMach");
      super.subscribe("msfsAutothrustSelectedKnots");
      super.subscribe("msfsWindDirection");
      super.subscribe("msfsWindSpeed");
      super.subscribe("msfsStaticAirTemperature");
      super.subscribe("msfsFlightPhase");
      super.subscribe("msfsVhf3Powered");
      super.subscribe("msfsVhf3Frequency");
      super.subscribe("msfsTransponderCode");
      super.subscribe("msfsCompanyMessageCount");
      super.subscribe("msfsAtcMessageButtonActive");
      super.subscribe("msfsAtcMessageButtonPressed");
    }
    initialize() {
      this.datalinkPublisher = this.eventBus.getPublisher();
      this.subscriber = this.eventBus.getSubscriber();
      this.subscriber.on("msfsUtcYear").handle((year) => this.datalinkPublisher.pub("utcYear", year, false, false));
      this.subscriber.on("msfsUtcMonth").handle((month) => this.datalinkPublisher.pub("utcMonth", month, false, false));
      this.subscriber.on("msfsUtcDayOfMonth").handle((day) => this.datalinkPublisher.pub("utcDayOfMonth", day, false, false));
      this.subscriber.on("msfsUtcSeconds").handle((seconds) => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor(seconds / 60) % 60;
        const secondsOfMinute = Math.floor(seconds) - hours * 3600 + minutes * 60;
        this.datalinkPublisher.pub("utcHour", hours, false, false);
        this.datalinkPublisher.pub("utcMinute", minutes, false, false);
        this.datalinkPublisher.pub("utcSecond", secondsOfMinute, false, false);
        this.datalinkPublisher.pub("utcSecondsOfDay", seconds, false, false);
      });
      this.subscriber.on("msfsPresentPositionLatitude").handle((latitude) => {
        this.datalinkPublisher.pub("presentPositionLatitude", new Arinc429Word(latitude), false, false);
      });
      this.subscriber.on("msfsPresentPositionLongitude").handle((longitude) => {
        this.datalinkPublisher.pub("presentPositionLongitude", new Arinc429Word(longitude), false, false);
      });
      this.subscriber.on("msfsPresentAltitude").handle((altitude) => {
        this.datalinkPublisher.pub("presentAltitude", new Arinc429Word(altitude), false, false);
      });
      this.subscriber.on("msfsPresentHeading").handle((heading) => {
        this.datalinkPublisher.pub("presentHeading", new Arinc429Word(heading), false, false);
      });
      this.subscriber.on("msfsPresentTrack").handle((track) => {
        this.datalinkPublisher.pub("presentTrack", new Arinc429Word(track), false, false);
      });
      this.subscriber.on("msfsComputedAirspeed").handle((cas) => {
        this.datalinkPublisher.pub("computedAirspeed", new Arinc429Word(cas), false, false);
      });
      this.subscriber.on("msfsPresentMach").handle((mach) => {
        this.datalinkPublisher.pub("presentMach", new Arinc429Word(mach), false, false);
      });
      this.subscriber.on("msfsGroundSpeed").handle((groundSpeed) => {
        this.datalinkPublisher.pub("groundSpeed", new Arinc429Word(groundSpeed), false, false);
      });
      this.subscriber.on("msfsVerticalSpeed").handle((verticalSpeed) => {
        this.datalinkPublisher.pub("verticalSpeed", new Arinc429Word(verticalSpeed), false, false);
      });
      this.subscriber.on("msfsAutopilotActive").handle((active) => {
        this.datalinkPublisher.pub("autopilotActive", new Arinc429Word(active === true ? 1 : 0), false, false);
      });
      this.subscriber.on("msfsAutothrustMode").handle((mode) => {
        this.datalinkPublisher.pub("autothrustMode", new Arinc429Word(mode), false, false);
      });
      this.subscriber.on("msfsAutothrustSelectedMach").handle((mach) => {
        const word = new Arinc429Word(0);
        word.ssm = 3 /* NormalOperation */;
        word.value = mach;
        this.datalinkPublisher.pub("autothrustSelectedMach", word, false, false);
      });
      this.subscriber.on("msfsAutothrustSelectedKnots").handle((knots) => {
        const word = new Arinc429Word(0);
        word.ssm = 3 /* NormalOperation */;
        word.value = knots;
        this.datalinkPublisher.pub("autothrustSelectedKnots", word, false, false);
      });
      this.subscriber.on("msfsWindDirection").handle((direction) => {
        this.datalinkPublisher.pub("windDirection", new Arinc429Word(direction), false, false);
      });
      this.subscriber.on("msfsWindSpeed").handle((speed) => {
        this.datalinkPublisher.pub("windSpeed", new Arinc429Word(speed), false, false);
      });
      this.subscriber.on("msfsStaticAirTemperature").handle((sat) => {
        this.datalinkPublisher.pub("staticAirTemperature", new Arinc429Word(sat), false, false);
      });
      this.subscriber.on("msfsFlightPhase").handle((phase) => {
        this.datalinkPublisher.pub("flightPhase", new Arinc429Word(phase), false, false);
      });
      this.subscriber.on("msfsVhf3Powered").handle((powered) => this.datalinkPublisher.pub("vhf3Powered", powered !== 0, false, false));
      this.subscriber.on("msfsVhf3Frequency").handle((frequency) => this.datalinkPublisher.pub("vhf3DataMode", frequency === 0, false, false));
      this.subscriber.on("msfsTransponderCode").handle((code) => this.datalinkPublisher.pub("transponderCode", code, false, false));
      this.subscriber.on("msfsCompanyMessageCount").handle((count) => this.datalinkPublisher.pub("companyMessageCount", count, false, false));
      this.subscriber.on("msfsAtcMessageButtonActive").handle((active) => this.datalinkPublisher.pub("atcMessageButtonActive", active, false, false));
      this.subscriber.on("msfsAtcMessageButtonPressed").handle((pressed) => this.datalinkPublisher.pub("atcMessageButtonPressed", pressed !== 0, false, false));
      this.connectedCallback();
    }
    startPublish() {
      super.startPublish();
    }
    update() {
      super.onUpdate();
    }
  };
  var SimVarHandling = _SimVarHandling;
  __publicField(SimVarHandling, "simvars", /* @__PURE__ */ new Map([
    ["msfsUtcYear", { name: "E:ZULU YEAR" /* utcYear */, type: SimVarValueType.Number }],
    ["msfsUtcMonth", { name: "E:ZULU MONTH OF YEAR" /* utcMonth */, type: SimVarValueType.Number }],
    ["msfsUtcDayOfMonth", { name: "E:ZULU DAY OF MONTH" /* utcDayOfMonth */, type: SimVarValueType.Number }],
    ["msfsUtcSeconds", { name: "E:ZULU TIME" /* utcSeconds */, type: SimVarValueType.Number }],
    ["msfsPresentPositionLatitude", { name: "L:A32NX_ADIRS_IR_1_LATITUDE" /* presentPositionLatitude */, type: SimVarValueType.Number }],
    ["msfsPresentPositionLongitude", { name: "L:A32NX_ADIRS_IR_1_LONGITUDE" /* presentPositionLongitude */, type: SimVarValueType.Number }],
    ["msfsPresentAltitude", { name: "L:A32NX_ADIRS_ADR_1_ALTITUDE" /* presentAltitude */, type: SimVarValueType.Number }],
    ["msfsPresentHeading", { name: "L:A32NX_ADIRS_IR_1_HEADING" /* presentHeading */, type: SimVarValueType.Number }],
    ["msfsPresentTrack", { name: "L:A32NX_ADIRS_IR_1_TRACK" /* presentTrack */, type: SimVarValueType.Number }],
    ["msfsComputedAirspeed", { name: "L:A32NX_ADIRS_ADR_1_COMPUTED_AIRSPEED" /* computedAirspeed */, type: SimVarValueType.Number }],
    ["msfsPresentMach", { name: "L:A32NX_ADIRS_ADR_1_MACH" /* presentMach */, type: SimVarValueType.Number }],
    ["msfsGroundSpeed", { name: "L:A32NX_ADIRS_IR_1_GROUND_SPEED" /* groundSpeed */, type: SimVarValueType.Number }],
    ["msfsAutopilotActive", { name: "L:A32NX_AUTOPILOT_ACTIVE" /* autopilotActive */, type: SimVarValueType.Number }],
    ["msfsAutothrustMode", { name: "L:A32NX_AUTOTHRUST_MODE" /* autothrustMode */, type: SimVarValueType.Number }],
    ["msfsAutothrustSelectedMach", { name: "L:A32NX_MachPreselVal" /* autothrustSelectedMach */, type: SimVarValueType.Number }],
    ["msfsAutothrustSelectedKnots", { name: "L:A32NX_SpeedPreselVal" /* autothrustSelectedKnots */, type: SimVarValueType.Knots }],
    ["msfsWindDirection", { name: "L:A32NX_ADIRS_IR_1_WIND_DIRECTION" /* windDirection */, type: SimVarValueType.Number }],
    ["msfsWindSpeed", { name: "L:A32NX_ADIRS_IR_1_WIND_SPEED" /* windSpeed */, type: SimVarValueType.Number }],
    ["msfsStaticAirTemperature", { name: "L:A32NX_ADIRS_ADR_1_STATIC_AIR_TEMPERATURE" /* staticAirTemperature */, type: SimVarValueType.Number }],
    ["msfsFlightPhase", { name: "L:A32NX_FMGC_FLIGHT_PHASE" /* flightPhase */, type: SimVarValueType.Number }],
    ["msfsVhf3Powered", { name: "L:A32NX_ELEC_DC_1_BUS_IS_POWERED" /* vhf3Powered */, type: SimVarValueType.Number }],
    ["msfsVhf3Frequency", { name: "A:COM ACTIVE FREQUENCY:3" /* vhf3Frequency */, type: SimVarValueType.MHz }],
    ["msfsTransponderCode", { name: "TRANSPONDER CODE:1" /* transponderCode */, type: SimVarValueType.Number }],
    ["msfsCompanyMessageCount", { name: "L:A32NX_COMPANY_MSG_COUNT" /* companyMessageCount */, type: SimVarValueType.Number }],
    ["msfsAtcMessageButtonActive", { name: "L:A32NX_DCDU_ATC_MSG_WAITING" /* atcMessageButtonActive */, type: SimVarValueType.Bool }],
    ["msfsAtcMessageButtonPressed", { name: "L:A32NX_DCDU_ATC_MSG_ACK" /* atcMessageButtonPressed */, type: SimVarValueType.Number }]
  ]));

  // src/systems/instruments/src/DCDU/elements/SemanticResponseButtons.tsx
  var import_react5 = __toESM(require_react());

  // src/systems/instruments/src/DCDU/elements/Button.tsx
  var import_react4 = __toESM(require_react());

  // src/systems/instruments/src/DCDU/elements/Checkerboard.tsx
  var import_react3 = __toESM(require_react());
  function createCells(x, y, yIndex, lineCount, cellWidth, color, even, odd) {
    if (yIndex >= lineCount) {
      return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null);
    }
    const coordinates = yIndex % 2 ? odd : even;
    return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, coordinates.map((coordinate) => /* @__PURE__ */ import_react3.default.createElement("rect", { x: x + coordinate, y: y + yIndex * cellWidth, width: cellWidth, height: cellWidth, style: { fill: color } })), createCells(x, y, yIndex + 1, lineCount, cellWidth, color, even, odd));
  }
  var Checkerboard = (0, import_react3.memo)(({ x, y, width, height, cellSize, fill: fill2 }) => {
    const lines = Math.round(height / cellSize);
    const columns = Math.round(width / cellSize);
    const evenCoordinates = [];
    const oddCoordinates = [];
    for (let i = 0; i < columns; i += 2) {
      evenCoordinates.push(i * cellSize + cellSize);
      oddCoordinates.push(i * cellSize);
    }
    return /* @__PURE__ */ import_react3.default.createElement("g", null, createCells(x, y, 0, lines, cellSize, fill2, evenCoordinates, oddCoordinates));
  });

  // src/systems/instruments/src/DCDU/elements/Button.tsx
  var Button = ({ index, content, active, onClick }) => {
    const [clicked, setClicked] = (0, import_react4.useState)(false);
    if (content.length === 0) {
      return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null);
    }
    useInteractionEvents([`A32NX_DCDU_BTN_MPL_${index}`, `A32NX_DCDU_BTN_MPR_${index}`], () => {
      if (active) {
        setClicked(true);
        setTimeout(() => {
          setClicked(false);
          onClick(index);
        }, 1e3);
      }
    });
    let leftButton = false;
    const textDefinition = { x: 0, y: 0, style: "button " };
    const backgroundDefinition = { x: 0, y: 0, style: "button " };
    switch (index) {
      case "L2":
        textDefinition.y = 480;
      case "L1":
        backgroundDefinition.x = 0;
        textDefinition.x = 168;
        textDefinition.y += 2240;
        textDefinition.style += "button-left ";
        backgroundDefinition.style += "button-left ";
        leftButton = true;
        break;
      case "R2":
        textDefinition.y = 480;
      default:
        backgroundDefinition.x = 2904;
        textDefinition.x = 3760;
        textDefinition.y += 2240;
        textDefinition.style += "button-right ";
        backgroundDefinition.style += "button-right ";
        break;
    }
    const backgroundWidth = 1032;
    const backgroundHeight = 240;
    backgroundDefinition.y = textDefinition.y - 176;
    if (clicked) {
      textDefinition.style += "button-color-clicked";
      backgroundDefinition.style = "button-color";
    } else {
      textDefinition.style += "button-color";
      backgroundDefinition.style = "button-color-clicked";
    }
    const textWidth = (content.length - 1) * 86;
    const textFillRatio = 1 - textWidth / backgroundWidth;
    const activeBtnOffset = active ? 86 : 0;
    const offset = Math.round(backgroundWidth * textFillRatio * 0.5);
    if (leftButton) {
      textDefinition.x = offset - activeBtnOffset;
    } else {
      textDefinition.x = backgroundDefinition.x + backgroundWidth - offset + activeBtnOffset;
    }
    let text;
    if (active) {
      if (leftButton) {
        text = `*${content}`;
      } else {
        text = `${content}*`;
      }
    } else {
      text = content;
    }
    return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, clicked && content.length !== 0 && /* @__PURE__ */ import_react4.default.createElement(
      Checkerboard,
      {
        x: backgroundDefinition.x,
        y: backgroundDefinition.y,
        width: backgroundWidth,
        height: backgroundHeight,
        cellSize: 10,
        fill: "rgb(0,255,255)"
      }
    ), content.length !== 0 && /* @__PURE__ */ import_react4.default.createElement("text", { className: textDefinition.style, x: textDefinition.x, y: textDefinition.y }, text));
  };

  // src/systems/instruments/src/DCDU/elements/SemanticResponseButtons.tsx
  var SemanticResponseButtons = ({
    message,
    reachedEndOfMessage,
    dataIncomplete,
    messageUnderModification,
    invertResponse,
    modifyResponse,
    sendMessage,
    closeMessage
  }) => {
    var _a;
    const showAnswers = !message.Response || message.Response.ComStatus !== 1 /* Sending */ && message.Response.ComStatus !== 2 /* Sent */;
    const buttonsBlocked = ((_a = message.Response) == null ? void 0 : _a.ComStatus) === 1 /* Sending */ || messageUnderModification || reachedEndOfMessage === false;
    const clicked = (index) => {
      if (message.UniqueMessageID === -1 || buttonsBlocked) {
        return;
      }
      if (showAnswers) {
        if (index === "L1") {
          invertResponse(message.UniqueMessageID);
        } else if (index === "R1") {
          modifyResponse(message.UniqueMessageID);
        } else if (index === "R2" && message.Response) {
          sendMessage(message.UniqueMessageID);
        }
      } else if (index === "R2") {
        closeMessage(message.UniqueMessageID);
      }
    };
    return /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, showAnswers && /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, UplinkMessageInterpretation.HasNegativeResponse(message) && /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, /* @__PURE__ */ import_react5.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "CANNOT",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), UplinkMessageInterpretation.IsModifiable(message) && /* @__PURE__ */ import_react5.default.createElement(import_react5.default.Fragment, null, /* @__PURE__ */ import_react5.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R1",
        content: "MODIFY",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), /* @__PURE__ */ import_react5.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "SEND",
        active: !dataIncomplete && !buttonsBlocked,
        onClick: clicked
      }
    )), !showAnswers && /* @__PURE__ */ import_react5.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "CLOSE",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/OutputButtons.tsx
  var import_react6 = __toESM(require_react());
  var OutputButtons = ({ message, reachedEndOfMessage, sendMessage, deleteMessage, closeMessage }) => {
    const buttonsBlocked = message.ComStatus === 1 /* Sending */ || reachedEndOfMessage === false;
    let showAnswers = false;
    if (message.ComStatus === 0 /* Open */ || message.ComStatus === 4 /* Failed */) {
      showAnswers = true;
    }
    const clicked = (index) => {
      if (message.UniqueMessageID === -1) {
        return;
      }
      if (showAnswers) {
        if (index === "L1") {
          deleteMessage(message.UniqueMessageID);
        } else if (index === "R2") {
          sendMessage(message.UniqueMessageID);
        }
      } else if (index === "R2") {
        closeMessage(message.UniqueMessageID);
      }
    };
    return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, showAnswers && /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "CANCEL",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), /* @__PURE__ */ import_react6.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "SEND",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), !showAnswers && /* @__PURE__ */ import_react6.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "CLOSE",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/AffirmNegativeButtons.tsx
  var import_react7 = __toESM(require_react());
  var AffirmNegativeButtons = ({
    message,
    reachedEndOfMessage,
    selectedResponse,
    setMessageStatus,
    sendResponse,
    closeMessage,
    monitorMessage,
    cancelMessageMonitoring
  }) => {
    var _a;
    const buttonsBlocked = ((_a = message.Response) == null ? void 0 : _a.ComStatus) === 1 /* Sending */ || reachedEndOfMessage === false;
    let showAnswers = false;
    let showSend = false;
    if (selectedResponse === -1 && !message.Response) {
      showAnswers = true;
    } else if (!message.Response) {
      showSend = true;
    }
    const clicked = (index) => {
      if (message.UniqueMessageID === -1 || buttonsBlocked) {
        return;
      }
      if (showAnswers) {
        if (index === "L1") {
          setMessageStatus(message.UniqueMessageID, 5);
        } else if (index === "R2") {
          setMessageStatus(message.UniqueMessageID, 4);
          if (UplinkMonitor.relevantMessage(message)) {
            monitorMessage(message.UniqueMessageID);
          }
        }
      } else if (showSend) {
        if (index === "L1") {
          if (UplinkMonitor.relevantMessage(message)) {
            cancelMessageMonitoring(message.UniqueMessageID);
          }
          setMessageStatus(message.UniqueMessageID, -1);
        } else if (index === "R2") {
          sendResponse(message.UniqueMessageID, selectedResponse);
        }
      } else if (index === "R2") {
        closeMessage(message.UniqueMessageID);
      }
    };
    return /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, showAnswers && /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, /* @__PURE__ */ import_react7.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "NEGATV",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), /* @__PURE__ */ import_react7.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "AFFIRM",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), showSend && /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, /* @__PURE__ */ import_react7.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "CANCEL",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), /* @__PURE__ */ import_react7.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "SEND",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), !showAnswers && !showSend && /* @__PURE__ */ import_react7.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "CLOSE",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/WilcoUnableButtons.tsx
  var import_react8 = __toESM(require_react());
  var WilcoUnableButtons = ({
    message,
    reachedEndOfMessage,
    selectedResponse,
    setMessageStatus,
    sendResponse,
    closeMessage,
    monitorMessage,
    cancelMessageMonitoring
  }) => {
    var _a;
    const buttonsBlocked = ((_a = message.Response) == null ? void 0 : _a.ComStatus) === 1 /* Sending */ || reachedEndOfMessage === false;
    let showAnswers = false;
    let showStandby = false;
    let showSend = false;
    if (selectedResponse === -1) {
      if (!message.Response) {
        showStandby = true;
        showAnswers = true;
      } else if (message.Response.Content[0].TypeId === "DM2") {
        showAnswers = true;
      }
    } else if (selectedResponse !== -1) {
      showSend = true;
    }
    const clicked = (index) => {
      if (message.UniqueMessageID === -1 || buttonsBlocked) {
        return;
      }
      if (showAnswers) {
        if (index === "L1") {
          setMessageStatus(message.UniqueMessageID, 1);
        } else if (index === "R1") {
          setMessageStatus(message.UniqueMessageID, 2);
        } else if (index === "R2") {
          setMessageStatus(message.UniqueMessageID, 0);
          if (UplinkMonitor.relevantMessage(message)) {
            monitorMessage(message.UniqueMessageID);
          }
        }
      } else if (showSend) {
        if (index === "L1") {
          setMessageStatus(message.UniqueMessageID, -1);
          if (UplinkMonitor.relevantMessage(message)) {
            cancelMessageMonitoring(message.UniqueMessageID);
          }
        } else {
          sendResponse(message.UniqueMessageID, selectedResponse);
        }
      } else if (index === "R2") {
        closeMessage(message.UniqueMessageID);
      }
    };
    return /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, null, showAnswers && /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, null, /* @__PURE__ */ import_react8.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "UNABLE",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), showStandby && /* @__PURE__ */ import_react8.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R1",
        content: "STBY",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), /* @__PURE__ */ import_react8.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "WILCO",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), showSend && /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, null, /* @__PURE__ */ import_react8.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "CANCEL",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), /* @__PURE__ */ import_react8.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "SEND",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), !showAnswers && !showSend && /* @__PURE__ */ import_react8.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "CLOSE",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/RogerButtons.tsx
  var import_react9 = __toESM(require_react());
  var RogerButtons = ({
    message,
    reachedEndOfMessage,
    selectedResponse,
    setMessageStatus,
    sendResponse,
    closeMessage,
    monitorMessage,
    cancelMessageMonitoring
  }) => {
    var _a;
    const buttonsBlocked = ((_a = message.Response) == null ? void 0 : _a.ComStatus) === 1 /* Sending */ || reachedEndOfMessage === false;
    let showAnswers = false;
    let showSend = false;
    if (selectedResponse === -1 && !message.Response) {
      showAnswers = true;
    } else if (!message.Response) {
      showSend = true;
    }
    const clicked = (index) => {
      if (message.UniqueMessageID === -1 || buttonsBlocked) {
        return;
      }
      if (showAnswers) {
        if (index === "R2") {
          setMessageStatus(message.UniqueMessageID, 3);
          if (UplinkMonitor.relevantMessage(message)) {
            monitorMessage(message.UniqueMessageID);
          }
        }
      } else if (showSend) {
        if (index === "L1") {
          if (UplinkMonitor.relevantMessage(message)) {
            cancelMessageMonitoring(message.UniqueMessageID);
          }
          setMessageStatus(message.UniqueMessageID, -1);
        } else if (index === "R2") {
          sendResponse(message.UniqueMessageID, selectedResponse);
        }
      } else if (index === "R2") {
        closeMessage(message.UniqueMessageID);
      }
    };
    return /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, showAnswers && /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "ROGER",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), showSend && /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "L1",
        content: "CANCEL",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ), /* @__PURE__ */ import_react9.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "SEND",
        active: !buttonsBlocked,
        onClick: clicked
      }
    )), !showAnswers && !showSend && /* @__PURE__ */ import_react9.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "CLOSE",
        active: !buttonsBlocked,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/CloseButtons.tsx
  var import_react10 = __toESM(require_react());
  var CloseButtons = ({ message, closeMessage }) => {
    const clicked = (index) => {
      if (message.UniqueMessageID === -1) {
        return;
      }
      if (index === "R2") {
        closeMessage(message.UniqueMessageID);
      }
    };
    return /* @__PURE__ */ import_react10.default.createElement(import_react10.default.Fragment, null, /* @__PURE__ */ import_react10.default.createElement(
      Button,
      {
        messageId: message.UniqueMessageID,
        index: "R2",
        content: "CLOSE",
        active: true,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/RecallButtons.tsx
  var import_react11 = __toESM(require_react());
  var RecallButtons = ({ recallMessage }) => {
    const clicked = (_index) => {
      recallMessage();
    };
    return /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, /* @__PURE__ */ import_react11.default.createElement(
      Button,
      {
        messageId: -1,
        index: "R2",
        content: "RECALL",
        active: true,
        onClick: clicked
      }
    ));
  };

  // src/systems/instruments/src/Common/index.tsx
  var import_react_dom = __toESM(require_react_dom());

  // src/systems/shared/src/popup.ts
  var PopUpDialog = class {
    constructor() {
      __publicField(this, "params");
      __publicField(this, "popupListener");
      const title = "A32NX POPUP";
      const time = new Date().getTime();
      this.popupListener = void 0;
      this.params = {
        __Type: "SNotificationParams",
        buttons: [new NotificationButton("TT:MENU.YES", `A32NX_POP_${title}_${time}_YES`), new NotificationButton("TT:MENU.NO", `A32NX_POP_${title}_${time}_NO`)],
        style: "normal",
        displayGlobalPopup: true,
        contentData: "Default Message",
        contentUrl: "",
        contentTemplate: "",
        id: `${title}_${time}`,
        title,
        time
      };
    }
    _showPopUp(params = {}) {
      Coherent.trigger("SHOW_POP_UP", params);
    }
    showPopUp(title, message, style, callbackYes, callbackNo) {
      if (title) {
        this.params.title = title;
      }
      if (message) {
        this.params.contentData = message;
      }
      if (style) {
        this.params.style = style;
      }
      if (callbackYes) {
        const yes = typeof callbackYes === "function" ? callbackYes : () => callbackYes;
        Coherent.on(`A32NX_POP_${this.params.id}_YES`, () => {
          Coherent.off(`A32NX_POP_${this.params.id}_YES`, null, null);
          yes();
        });
      }
      if (callbackNo) {
        const no = typeof callbackNo === "function" ? callbackNo : () => callbackNo;
        Coherent.on(`A32NX_POP_${this.params.id}_NO`, () => {
          Coherent.off(`A32NX_POP_${this.params.id}_NO`, null, null);
          no();
        });
      }
      if (!this.popupListener) {
        this.popupListener = RegisterViewListener("JS_LISTENER_POPUP", this._showPopUp.bind(null, this.params));
      } else {
        this._showPopUp(this.params);
      }
    }
    showInformation(title, message, style, callback) {
      if (title) {
        this.params.title = title;
      }
      if (message) {
        this.params.contentData = message;
      }
      if (style) {
        this.params.style = style;
      }
      if (callback) {
        const yes = typeof callback === "function" ? callback : () => callback;
        Coherent.on(`A32NX_POP_${this.params.id}_YES`, () => {
          Coherent.off(`A32NX_POP_${this.params.id}_YES`, null, null);
          yes();
        });
      }
      this.params.buttons = [new NotificationButton("TT:MENU.OK", `A32NX_POP_${this.params.id}_YES`)];
      if (!this.popupListener) {
        this.popupListener = RegisterViewListener("JS_LISTENER_POPUP", this._showPopUp.bind(null, this.params));
      } else {
        this._showPopUp(this.params);
      }
    }
  };

  // ../node_modules/@sentry/browser/node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // ../node_modules/@sentry/types/esm/severity.js
  var Severity;
  (function(Severity2) {
    Severity2["Fatal"] = "fatal";
    Severity2["Error"] = "error";
    Severity2["Warning"] = "warning";
    Severity2["Log"] = "log";
    Severity2["Info"] = "info";
    Severity2["Debug"] = "debug";
    Severity2["Critical"] = "critical";
  })(Severity || (Severity = {}));

  // ../node_modules/@sentry/minimal/node_modules/tslib/modules/index.js
  var import_tslib2 = __toESM(require_tslib2(), 1);
  var {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter2,
    __generator: __generator2,
    __exportStar: __exportStar2,
    __createBinding: __createBinding2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2
  } = import_tslib2.default;

  // ../node_modules/@sentry/hub/node_modules/tslib/modules/index.js
  var import_tslib3 = __toESM(require_tslib3(), 1);
  var {
    __extends: __extends3,
    __assign: __assign3,
    __rest: __rest3,
    __decorate: __decorate3,
    __param: __param3,
    __metadata: __metadata3,
    __awaiter: __awaiter3,
    __generator: __generator3,
    __exportStar: __exportStar3,
    __createBinding: __createBinding3,
    __values: __values3,
    __read: __read3,
    __spread: __spread3,
    __spreadArrays: __spreadArrays3,
    __await: __await3,
    __asyncGenerator: __asyncGenerator3,
    __asyncDelegator: __asyncDelegator3,
    __asyncValues: __asyncValues3,
    __makeTemplateObject: __makeTemplateObject3,
    __importStar: __importStar3,
    __importDefault: __importDefault3,
    __classPrivateFieldGet: __classPrivateFieldGet3,
    __classPrivateFieldSet: __classPrivateFieldSet3
  } = import_tslib3.default;

  // ../node_modules/@sentry/utils/esm/async.js
  function forget(promise) {
    void promise.then(null, function(e) {
      console.error(e);
    });
  }

  // ../node_modules/@sentry/utils/esm/env.js
  function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
  }

  // ../node_modules/@sentry/utils/esm/node.js
  function isNodeEnv() {
    return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  }
  function dynamicRequire(mod, request) {
    return mod.require(request);
  }
  function loadModule(moduleName) {
    var mod;
    try {
      mod = dynamicRequire(module, moduleName);
    } catch (e) {
    }
    try {
      var cwd = dynamicRequire(module, "process").cwd;
      mod = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
    } catch (e) {
    }
    return mod;
  }

  // ../node_modules/@sentry/utils/esm/global.js
  var fallbackGlobalObject = {};
  function getGlobalObject() {
    return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
  }
  function getGlobalSingleton(name, creator, obj) {
    var global12 = obj || getGlobalObject();
    var __SENTRY__ = global12.__SENTRY__ = global12.__SENTRY__ || {};
    var singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
    return singleton;
  }

  // ../node_modules/@sentry/utils/esm/is.js
  var objectToString = Object.prototype.toString;
  function isError(wat) {
    switch (objectToString.call(wat)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
  function isBuiltin(wat, ty) {
    return objectToString.call(wat) === "[object " + ty + "]";
  }
  function isErrorEvent(wat) {
    return isBuiltin(wat, "ErrorEvent");
  }
  function isDOMError(wat) {
    return isBuiltin(wat, "DOMError");
  }
  function isDOMException(wat) {
    return isBuiltin(wat, "DOMException");
  }
  function isString(wat) {
    return isBuiltin(wat, "String");
  }
  function isPrimitive(wat) {
    return wat === null || typeof wat !== "object" && typeof wat !== "function";
  }
  function isPlainObject(wat) {
    return isBuiltin(wat, "Object");
  }
  function isEvent(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  }
  function isElement(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  }
  function isRegExp(wat) {
    return isBuiltin(wat, "RegExp");
  }
  function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  function isSyntheticEvent(wat) {
    return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  }
  function isNaN2(wat) {
    return typeof wat === "number" && wat !== wat;
  }
  function isInstanceOf(wat, base) {
    try {
      return wat instanceof base;
    } catch (_e) {
      return false;
    }
  }

  // ../node_modules/@sentry/utils/esm/browser.js
  function htmlTreeAsString(elem, keyAttrs) {
    try {
      var currentElem = elem;
      var MAX_TRAVERSE_HEIGHT = 5;
      var MAX_OUTPUT_LEN = 80;
      var out = [];
      var height = 0;
      var len = 0;
      var separator = " > ";
      var sepLength = separator.length;
      var nextStr = void 0;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem, keyAttrs);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function _htmlElementAsString(el, keyAttrs) {
    var elem = el;
    var out = [];
    var className;
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
      return "";
    }
    out.push(elem.tagName.toLowerCase());
    var keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter(function(keyAttr) {
      return elem.getAttribute(keyAttr);
    }).map(function(keyAttr) {
      return [keyAttr, elem.getAttribute(keyAttr)];
    }) : null;
    if (keyAttrPairs && keyAttrPairs.length) {
      keyAttrPairs.forEach(function(keyAttrPair) {
        out.push("[" + keyAttrPair[0] + '="' + keyAttrPair[1] + '"]');
      });
    } else {
      if (elem.id) {
        out.push("#" + elem.id);
      }
      className = elem.className;
      if (className && isString(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
          out.push("." + classes[i]);
        }
      }
    }
    var allowedAttrs = ["type", "name", "title", "alt"];
    for (i = 0; i < allowedAttrs.length; i++) {
      key = allowedAttrs[i];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push("[" + key + '="' + attr + '"]');
      }
    }
    return out.join("");
  }
  function getLocationHref() {
    var global12 = getGlobalObject();
    try {
      return global12.document.location.href;
    } catch (oO) {
      return "";
    }
  }

  // ../node_modules/@sentry/utils/node_modules/tslib/modules/index.js
  var import_tslib4 = __toESM(require_tslib4(), 1);
  var {
    __extends: __extends4,
    __assign: __assign4,
    __rest: __rest4,
    __decorate: __decorate4,
    __param: __param4,
    __metadata: __metadata4,
    __awaiter: __awaiter4,
    __generator: __generator4,
    __exportStar: __exportStar4,
    __createBinding: __createBinding4,
    __values: __values4,
    __read: __read4,
    __spread: __spread4,
    __spreadArrays: __spreadArrays4,
    __await: __await4,
    __asyncGenerator: __asyncGenerator4,
    __asyncDelegator: __asyncDelegator4,
    __asyncValues: __asyncValues4,
    __makeTemplateObject: __makeTemplateObject4,
    __importStar: __importStar4,
    __importDefault: __importDefault4,
    __classPrivateFieldGet: __classPrivateFieldGet4,
    __classPrivateFieldSet: __classPrivateFieldSet4
  } = import_tslib4.default;

  // ../node_modules/@sentry/utils/esm/polyfill.js
  var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }

  // ../node_modules/@sentry/utils/esm/error.js
  var SentryError = function(_super) {
    __extends4(SentryError2, _super);
    function SentryError2(message) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.name = _newTarget.prototype.constructor.name;
      setPrototypeOf(_this, _newTarget.prototype);
      return _this;
    }
    return SentryError2;
  }(Error);

  // ../node_modules/@sentry/utils/esm/flags.js
  var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/utils/esm/dsn.js
  var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  function isValidProtocol(protocol) {
    return protocol === "http" || protocol === "https";
  }
  function dsnToString(dsn, withPassword) {
    if (withPassword === void 0) {
      withPassword = false;
    }
    var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
    return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path ? path + "/" : path) + projectId);
  }
  function dsnFromString(str) {
    var match = DSN_REGEX.exec(str);
    if (!match) {
      throw new SentryError("Invalid Sentry Dsn: " + str);
    }
    var _a = __read4(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? "" : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? "" : _c, lastPath = _a[5];
    var path = "";
    var projectId = lastPath;
    var split = projectId.split("/");
    if (split.length > 1) {
      path = split.slice(0, -1).join("/");
      projectId = split.pop();
    }
    if (projectId) {
      var projectMatch = projectId.match(/^\d+/);
      if (projectMatch) {
        projectId = projectMatch[0];
      }
    }
    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
  }
  function dsnFromComponents(components) {
    if ("user" in components && !("publicKey" in components)) {
      components.publicKey = components.user;
    }
    return {
      user: components.publicKey || "",
      protocol: components.protocol,
      publicKey: components.publicKey || "",
      pass: components.pass || "",
      host: components.host,
      port: components.port || "",
      path: components.path || "",
      projectId: components.projectId
    };
  }
  function validateDsn(dsn) {
    if (!IS_DEBUG_BUILD) {
      return;
    }
    var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
    var requiredComponents = ["protocol", "publicKey", "host", "projectId"];
    requiredComponents.forEach(function(component) {
      if (!dsn[component]) {
        throw new SentryError("Invalid Sentry Dsn: " + component + " missing");
      }
    });
    if (!projectId.match(/^\d+$/)) {
      throw new SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
    }
    if (!isValidProtocol(protocol)) {
      throw new SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
    }
    if (port && isNaN(parseInt(port, 10))) {
      throw new SentryError("Invalid Sentry Dsn: Invalid port " + port);
    }
    return true;
  }
  function makeDsn(from) {
    var components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
    validateDsn(components);
    return components;
  }

  // ../node_modules/@sentry/utils/esm/enums.js
  var SeverityLevels = ["fatal", "error", "warning", "log", "info", "debug", "critical"];

  // ../node_modules/@sentry/utils/esm/logger.js
  var global2 = getGlobalObject();
  var PREFIX = "Sentry Logger ";
  var CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert"];
  function consoleSandbox(callback) {
    var global12 = getGlobalObject();
    if (!("console" in global12)) {
      return callback();
    }
    var originalConsole = global12.console;
    var wrappedLevels = {};
    CONSOLE_LEVELS.forEach(function(level) {
      var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
      if (level in global12.console && originalWrappedFunc) {
        wrappedLevels[level] = originalConsole[level];
        originalConsole[level] = originalWrappedFunc;
      }
    });
    try {
      return callback();
    } finally {
      Object.keys(wrappedLevels).forEach(function(level) {
        originalConsole[level] = wrappedLevels[level];
      });
    }
  }
  function makeLogger() {
    var enabled = false;
    var logger2 = {
      enable: function() {
        enabled = true;
      },
      disable: function() {
        enabled = false;
      }
    };
    if (IS_DEBUG_BUILD) {
      CONSOLE_LEVELS.forEach(function(name) {
        logger2[name] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (enabled) {
            consoleSandbox(function() {
              var _a;
              (_a = global2.console)[name].apply(_a, __spread4([PREFIX + "[" + name + "]:"], args));
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach(function(name) {
        logger2[name] = function() {
          return void 0;
        };
      });
    }
    return logger2;
  }
  var logger;
  if (IS_DEBUG_BUILD) {
    logger = getGlobalSingleton("logger", makeLogger);
  } else {
    logger = makeLogger();
  }

  // ../node_modules/@sentry/utils/esm/string.js
  function truncate(str, max) {
    if (max === void 0) {
      max = 0;
    }
    if (typeof str !== "string" || max === 0) {
      return str;
    }
    return str.length <= max ? str : str.substr(0, max) + "...";
  }
  function safeJoin(input, delimiter) {
    if (!Array.isArray(input)) {
      return "";
    }
    var output = [];
    for (var i = 0; i < input.length; i++) {
      var value = input[i];
      try {
        output.push(String(value));
      } catch (e) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter);
  }
  function isMatchingPattern(value, pattern) {
    if (!isString(value)) {
      return false;
    }
    if (isRegExp(pattern)) {
      return pattern.test(value);
    }
    if (typeof pattern === "string") {
      return value.indexOf(pattern) !== -1;
    }
    return false;
  }

  // ../node_modules/@sentry/utils/esm/object.js
  function fill(source, name, replacementFactory) {
    if (!(name in source)) {
      return;
    }
    var original = source[name];
    var wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      try {
        markFunctionWrapped(wrapped, original);
      } catch (_Oo) {
      }
    }
    source[name] = wrapped;
  }
  function addNonEnumerableProperty(obj, name, value) {
    Object.defineProperty(obj, name, {
      value,
      writable: true,
      configurable: true
    });
  }
  function markFunctionWrapped(wrapped, original) {
    var proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  }
  function getOriginalFunction(func) {
    return func.__sentry_original__;
  }
  function urlEncode(object) {
    return Object.keys(object).map(function(key) {
      return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
    }).join("&");
  }
  function convertToPlainObject(value) {
    var newObj = value;
    if (isError(value)) {
      newObj = __assign4({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
    } else if (isEvent(value)) {
      var event_1 = value;
      newObj = __assign4({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
      if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
        newObj.detail = event_1.detail;
      }
    }
    return newObj;
  }
  function serializeEventTarget(target) {
    try {
      return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function getOwnProperties(obj) {
    var extractedProps = {};
    for (var property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  }
  function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) {
      maxLength = 40;
    }
    var keys = Object.keys(convertToPlainObject(exception));
    keys.sort();
    if (!keys.length) {
      return "[object has no keys]";
    }
    if (keys[0].length >= maxLength) {
      return truncate(keys[0], maxLength);
    }
    for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
      var serialized = keys.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys.length) {
        return serialized;
      }
      return truncate(serialized, maxLength);
    }
    return "";
  }
  function dropUndefinedKeys(val) {
    var e_1, _a;
    if (isPlainObject(val)) {
      var rv = {};
      try {
        for (var _b = __values4(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          if (typeof val[key] !== "undefined") {
            rv[key] = dropUndefinedKeys(val[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return rv;
    }
    if (Array.isArray(val)) {
      return val.map(dropUndefinedKeys);
    }
    return val;
  }

  // ../node_modules/@sentry/utils/esm/stacktrace.js
  var STACKTRACE_LIMIT = 50;
  function createStackParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      parsers[_i] = arguments[_i];
    }
    var sortedParsers = parsers.sort(function(a, b) {
      return a[0] - b[0];
    }).map(function(p) {
      return p[1];
    });
    return function(stack, skipFirst) {
      var e_1, _a, e_2, _b;
      if (skipFirst === void 0) {
        skipFirst = 0;
      }
      var frames = [];
      try {
        for (var _c = __values4(stack.split("\n").slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var line = _d.value;
          try {
            for (var sortedParsers_1 = (e_2 = void 0, __values4(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
              var parser = sortedParsers_1_1.value;
              var frame = parser(line);
              if (frame) {
                frames.push(frame);
                break;
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return))
                _b.call(sortedParsers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return stripSentryFramesAndReverse(frames);
    };
  }
  function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
      return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].function || "";
    var lastFrameFunction = localStack[localStack.length - 1].function || "";
    if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
      localStack = localStack.slice(1);
    }
    if (lastFrameFunction.indexOf("sentryWrapped") !== -1) {
      localStack = localStack.slice(0, -1);
    }
    return localStack.slice(0, STACKTRACE_LIMIT).map(function(frame) {
      return __assign4(__assign4({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || "?" });
    }).reverse();
  }
  var defaultFunctionName = "<anonymous>";
  function getFunctionName(fn) {
    try {
      if (!fn || typeof fn !== "function") {
        return defaultFunctionName;
      }
      return fn.name || defaultFunctionName;
    } catch (e) {
      return defaultFunctionName;
    }
  }

  // ../node_modules/@sentry/utils/esm/supports.js
  function supportsFetch() {
    if (!("fetch" in getGlobalObject())) {
      return false;
    }
    try {
      new Headers();
      new Request("");
      new Response();
      return true;
    } catch (e) {
      return false;
    }
  }
  function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  }
  function supportsNativeFetch() {
    if (!supportsFetch()) {
      return false;
    }
    var global12 = getGlobalObject();
    if (isNativeFetch(global12.fetch)) {
      return true;
    }
    var result = false;
    var doc = global12.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        var sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        IS_DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result;
  }
  function supportsReferrerPolicy() {
    if (!supportsFetch()) {
      return false;
    }
    try {
      new Request("_", {
        referrerPolicy: "origin"
      });
      return true;
    } catch (e) {
      return false;
    }
  }
  function supportsHistory() {
    var global12 = getGlobalObject();
    var chrome2 = global12.chrome;
    var isChromePackagedApp = chrome2 && chrome2.app && chrome2.app.runtime;
    var hasHistoryApi = "history" in global12 && !!global12.history.pushState && !!global12.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  }

  // ../node_modules/@sentry/utils/esm/instrument.js
  var global3 = getGlobalObject();
  var handlers = {};
  var instrumented = {};
  function instrument(type) {
    if (instrumented[type]) {
      return;
    }
    instrumented[type] = true;
    switch (type) {
      case "console":
        instrumentConsole();
        break;
      case "dom":
        instrumentDOM();
        break;
      case "xhr":
        instrumentXHR();
        break;
      case "fetch":
        instrumentFetch();
        break;
      case "history":
        instrumentHistory();
        break;
      case "error":
        instrumentError();
        break;
      case "unhandledrejection":
        instrumentUnhandledRejection();
        break;
      default:
        IS_DEBUG_BUILD && logger.warn("unknown instrumentation type:", type);
        return;
    }
  }
  function addInstrumentationHandler(type, callback) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(callback);
    instrument(type);
  }
  function triggerHandlers(type, data) {
    var e_1, _a;
    if (!type || !handlers[type]) {
      return;
    }
    try {
      for (var _b = __values4(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
        var handler = _c.value;
        try {
          handler(data);
        } catch (e) {
          IS_DEBUG_BUILD && logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError:", e);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  function instrumentConsole() {
    if (!("console" in global3)) {
      return;
    }
    CONSOLE_LEVELS.forEach(function(level) {
      if (!(level in global3.console)) {
        return;
      }
      fill(global3.console, level, function(originalConsoleMethod) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          triggerHandlers("console", { args, level });
          if (originalConsoleMethod) {
            originalConsoleMethod.apply(global3.console, args);
          }
        };
      });
    });
  }
  function instrumentFetch() {
    if (!supportsNativeFetch()) {
      return;
    }
    fill(global3, "fetch", function(originalFetch) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var handlerData = {
          args,
          fetchData: {
            method: getFetchMethod(args),
            url: getFetchUrl(args)
          },
          startTimestamp: Date.now()
        };
        triggerHandlers("fetch", __assign4({}, handlerData));
        return originalFetch.apply(global3, args).then(function(response) {
          triggerHandlers("fetch", __assign4(__assign4({}, handlerData), { endTimestamp: Date.now(), response }));
          return response;
        }, function(error) {
          triggerHandlers("fetch", __assign4(__assign4({}, handlerData), { endTimestamp: Date.now(), error }));
          throw error;
        });
      };
    });
  }
  function getFetchMethod(fetchArgs) {
    if (fetchArgs === void 0) {
      fetchArgs = [];
    }
    if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
      return String(fetchArgs[0].method).toUpperCase();
    }
    if (fetchArgs[1] && fetchArgs[1].method) {
      return String(fetchArgs[1].method).toUpperCase();
    }
    return "GET";
  }
  function getFetchUrl(fetchArgs) {
    if (fetchArgs === void 0) {
      fetchArgs = [];
    }
    if (typeof fetchArgs[0] === "string") {
      return fetchArgs[0];
    }
    if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request)) {
      return fetchArgs[0].url;
    }
    return String(fetchArgs[0]);
  }
  function instrumentXHR() {
    if (!("XMLHttpRequest" in global3)) {
      return;
    }
    var xhrproto = XMLHttpRequest.prototype;
    fill(xhrproto, "open", function(originalOpen) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var xhr = this;
        var url = args[1];
        var xhrInfo = xhr.__sentry_xhr__ = {
          method: isString(args[0]) ? args[0].toUpperCase() : args[0],
          url: args[1]
        };
        if (isString(url) && xhrInfo.method === "POST" && url.match(/sentry_key/)) {
          xhr.__sentry_own_request__ = true;
        }
        var onreadystatechangeHandler = function() {
          if (xhr.readyState === 4) {
            try {
              xhrInfo.status_code = xhr.status;
            } catch (e) {
            }
            triggerHandlers("xhr", {
              args,
              endTimestamp: Date.now(),
              startTimestamp: Date.now(),
              xhr
            });
          }
        };
        if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
          fill(xhr, "onreadystatechange", function(original) {
            return function() {
              var readyStateArgs = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                readyStateArgs[_i2] = arguments[_i2];
              }
              onreadystatechangeHandler();
              return original.apply(xhr, readyStateArgs);
            };
          });
        } else {
          xhr.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        return originalOpen.apply(xhr, args);
      };
    });
    fill(xhrproto, "send", function(originalSend) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.__sentry_xhr__ && args[0] !== void 0) {
          this.__sentry_xhr__.body = args[0];
        }
        triggerHandlers("xhr", {
          args,
          startTimestamp: Date.now(),
          xhr: this
        });
        return originalSend.apply(this, args);
      };
    });
  }
  var lastHref;
  function instrumentHistory() {
    if (!supportsHistory()) {
      return;
    }
    var oldOnPopState = global3.onpopstate;
    global3.onpopstate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var to = global3.location.href;
      var from = lastHref;
      lastHref = to;
      triggerHandlers("history", {
        from,
        to
      });
      if (oldOnPopState) {
        try {
          return oldOnPopState.apply(this, args);
        } catch (_oO) {
        }
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var url = args.length > 2 ? args[2] : void 0;
        if (url) {
          var from = lastHref;
          var to = String(url);
          lastHref = to;
          triggerHandlers("history", {
            from,
            to
          });
        }
        return originalHistoryFunction.apply(this, args);
      };
    }
    fill(global3.history, "pushState", historyReplacementFunction);
    fill(global3.history, "replaceState", historyReplacementFunction);
  }
  var debounceDuration = 1e3;
  var debounceTimerID;
  var lastCapturedEvent;
  function shouldShortcircuitPreviousDebounce(previous, current) {
    if (!previous) {
      return true;
    }
    if (previous.type !== current.type) {
      return true;
    }
    try {
      if (previous.target !== current.target) {
        return true;
      }
    } catch (e) {
    }
    return false;
  }
  function shouldSkipDOMEvent(event) {
    if (event.type !== "keypress") {
      return false;
    }
    try {
      var target = event.target;
      if (!target || !target.tagName) {
        return true;
      }
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return false;
      }
    } catch (e) {
    }
    return true;
  }
  function makeDOMEventHandler(handler, globalListener) {
    if (globalListener === void 0) {
      globalListener = false;
    }
    return function(event) {
      if (!event || lastCapturedEvent === event) {
        return;
      }
      if (shouldSkipDOMEvent(event)) {
        return;
      }
      var name = event.type === "keypress" ? "input" : event.type;
      if (debounceTimerID === void 0) {
        handler({
          event,
          name,
          global: globalListener
        });
        lastCapturedEvent = event;
      } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
        handler({
          event,
          name,
          global: globalListener
        });
        lastCapturedEvent = event;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = global3.setTimeout(function() {
        debounceTimerID = void 0;
      }, debounceDuration);
    };
  }
  function instrumentDOM() {
    if (!("document" in global3)) {
      return;
    }
    var triggerDOMHandler = triggerHandlers.bind(null, "dom");
    var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    global3.document.addEventListener("click", globalDOMEventHandler, false);
    global3.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach(function(target) {
      var proto = global3[target] && global3[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              var el = this;
              var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers_1[type] = handlers_1[type] || { refCount: 0 };
              if (!handlerForType.handler) {
                var handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount += 1;
            } catch (e) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      fill(proto, "removeEventListener", function(originalRemoveEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              var el = this;
              var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers_2[type];
              if (handlerForType) {
                handlerForType.refCount -= 1;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = void 0;
                  delete handlers_2[type];
                }
                if (Object.keys(handlers_2).length === 0) {
                  delete el.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options);
        };
      });
    });
  }
  var _oldOnErrorHandler = null;
  function instrumentError() {
    _oldOnErrorHandler = global3.onerror;
    global3.onerror = function(msg, url, line, column, error) {
      triggerHandlers("error", {
        column,
        error,
        line,
        msg,
        url
      });
      if (_oldOnErrorHandler) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
  }
  var _oldOnUnhandledRejectionHandler = null;
  function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = global3.onunhandledrejection;
    global3.onunhandledrejection = function(e) {
      triggerHandlers("unhandledrejection", e);
      if (_oldOnUnhandledRejectionHandler) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
  }

  // ../node_modules/@sentry/utils/esm/memo.js
  function memoBuilder() {
    var hasWeakSet = typeof WeakSet === "function";
    var inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
    function memoize(obj) {
      if (hasWeakSet) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }
      for (var i = 0; i < inner.length; i++) {
        var value = inner[i];
        if (value === obj) {
          return true;
        }
      }
      inner.push(obj);
      return false;
    }
    function unmemoize(obj) {
      if (hasWeakSet) {
        inner.delete(obj);
      } else {
        for (var i = 0; i < inner.length; i++) {
          if (inner[i] === obj) {
            inner.splice(i, 1);
            break;
          }
        }
      }
    }
    return [memoize, unmemoize];
  }

  // ../node_modules/@sentry/utils/esm/misc.js
  function uuid4() {
    var global12 = getGlobalObject();
    var crypto = global12.crypto || global12.msCrypto;
    if (!(crypto === void 0) && crypto.getRandomValues) {
      var arr = new Uint16Array(8);
      crypto.getRandomValues(arr);
      arr[3] = arr[3] & 4095 | 16384;
      arr[4] = arr[4] & 16383 | 32768;
      var pad = function(num) {
        var v = num.toString(16);
        while (v.length < 4) {
          v = "0" + v;
        }
        return v;
      };
      return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function parseUrl(url) {
    if (!url) {
      return {};
    }
    var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
      return {};
    }
    var query = match[6] || "";
    var fragment = match[8] || "";
    return {
      host: match[4],
      path: match[5],
      protocol: match[2],
      relative: match[5] + query + fragment
    };
  }
  function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : void 0;
  }
  function getEventDescription(event) {
    var message = event.message, eventId = event.event_id;
    if (message) {
      return message;
    }
    var firstException = getFirstException(event);
    if (firstException) {
      if (firstException.type && firstException.value) {
        return firstException.type + ": " + firstException.value;
      }
      return firstException.type || firstException.value || eventId || "<unknown>";
    }
    return eventId || "<unknown>";
  }
  function addExceptionTypeValue(event, value, type) {
    var exception = event.exception = event.exception || {};
    var values = exception.values = exception.values || [];
    var firstException = values[0] = values[0] || {};
    if (!firstException.value) {
      firstException.value = value || "";
    }
    if (!firstException.type) {
      firstException.type = type || "Error";
    }
  }
  function addExceptionMechanism(event, newMechanism) {
    var firstException = getFirstException(event);
    if (!firstException) {
      return;
    }
    var defaultMechanism = { type: "generic", handled: true };
    var currentMechanism = firstException.mechanism;
    firstException.mechanism = __assign4(__assign4(__assign4({}, defaultMechanism), currentMechanism), newMechanism);
    if (newMechanism && "data" in newMechanism) {
      var mergedData = __assign4(__assign4({}, currentMechanism && currentMechanism.data), newMechanism.data);
      firstException.mechanism.data = mergedData;
    }
  }
  function checkOrSetAlreadyCaught(exception) {
    if (exception && exception.__sentry_captured__) {
      return true;
    }
    try {
      addNonEnumerableProperty(exception, "__sentry_captured__", true);
    } catch (err) {
    }
    return false;
  }

  // ../node_modules/@sentry/utils/esm/normalize.js
  function normalize(input, depth, maxProperties) {
    if (depth === void 0) {
      depth = Infinity;
    }
    if (maxProperties === void 0) {
      maxProperties = Infinity;
    }
    try {
      return visit("", input, depth, maxProperties);
    } catch (err) {
      return { ERROR: "**non-serializable** (" + err + ")" };
    }
  }
  function normalizeToSize(object, depth, maxSize) {
    if (depth === void 0) {
      depth = 3;
    }
    if (maxSize === void 0) {
      maxSize = 100 * 1024;
    }
    var normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
      return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
  }
  function visit(key, value, depth, maxProperties, memo3) {
    if (depth === void 0) {
      depth = Infinity;
    }
    if (maxProperties === void 0) {
      maxProperties = Infinity;
    }
    if (memo3 === void 0) {
      memo3 = memoBuilder();
    }
    var _a = __read4(memo3, 2), memoize = _a[0], unmemoize = _a[1];
    var valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
      try {
        return valueWithToJSON.toJSON();
      } catch (err) {
      }
    }
    if (value === null || ["number", "boolean", "string"].includes(typeof value) && !isNaN2(value)) {
      return value;
    }
    var stringified = stringifyValue(key, value);
    if (!stringified.startsWith("[object ")) {
      return stringified;
    }
    if (depth === 0) {
      return stringified.replace("object ", "");
    }
    if (memoize(value)) {
      return "[Circular ~]";
    }
    var normalized = Array.isArray(value) ? [] : {};
    var numAdded = 0;
    var visitable = isError(value) || isEvent(value) ? convertToPlainObject(value) : value;
    for (var visitKey in visitable) {
      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
        continue;
      }
      if (numAdded >= maxProperties) {
        normalized[visitKey] = "[MaxProperties ~]";
        break;
      }
      var visitValue = visitable[visitKey];
      normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo3);
      numAdded += 1;
    }
    unmemoize(value);
    return normalized;
  }
  function stringifyValue(key, value) {
    try {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (value === void 0) {
        return "[undefined]";
      }
      if (typeof value === "function") {
        return "[Function: " + getFunctionName(value) + "]";
      }
      if (typeof value === "symbol") {
        return "[" + String(value) + "]";
      }
      if (typeof value === "bigint") {
        return "[BigInt: " + String(value) + "]";
      }
      return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
    } catch (err) {
      return "**non-serializable** (" + err + ")";
    }
  }
  function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  }
  function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
  }

  // ../node_modules/@sentry/utils/esm/syncpromise.js
  function resolvedSyncPromise(value) {
    return new SyncPromise(function(resolve) {
      resolve(value);
    });
  }
  function rejectedSyncPromise(reason) {
    return new SyncPromise(function(_, reject) {
      reject(reason);
    });
  }
  var SyncPromise = function() {
    function SyncPromise2(executor) {
      var _this = this;
      this._state = 0;
      this._handlers = [];
      this._resolve = function(value) {
        _this._setResult(1, value);
      };
      this._reject = function(reason) {
        _this._setResult(2, reason);
      };
      this._setResult = function(state, value) {
        if (_this._state !== 0) {
          return;
        }
        if (isThenable(value)) {
          void value.then(_this._resolve, _this._reject);
          return;
        }
        _this._state = state;
        _this._value = value;
        _this._executeHandlers();
      };
      this._executeHandlers = function() {
        if (_this._state === 0) {
          return;
        }
        var cachedHandlers = _this._handlers.slice();
        _this._handlers = [];
        cachedHandlers.forEach(function(handler) {
          if (handler[0]) {
            return;
          }
          if (_this._state === 1) {
            handler[1](_this._value);
          }
          if (_this._state === 2) {
            handler[2](_this._value);
          }
          handler[0] = true;
        });
      };
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        _this._handlers.push([
          false,
          function(result) {
            if (!onfulfilled) {
              resolve(result);
            } else {
              try {
                resolve(onfulfilled(result));
              } catch (e) {
                reject(e);
              }
            }
          },
          function(reason) {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e) {
                reject(e);
              }
            }
          }
        ]);
        _this._executeHandlers();
      });
    };
    SyncPromise2.prototype.catch = function(onrejected) {
      return this.then(function(val) {
        return val;
      }, onrejected);
    };
    SyncPromise2.prototype.finally = function(onfinally) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        var val;
        var isRejected;
        return _this.then(function(value) {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        }, function(reason) {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }).then(function() {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    };
    return SyncPromise2;
  }();

  // ../node_modules/@sentry/utils/esm/promisebuffer.js
  function makePromiseBuffer(limit) {
    var buffer = [];
    function isReady() {
      return limit === void 0 || buffer.length < limit;
    }
    function remove(task) {
      return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    function add(taskProducer) {
      if (!isReady()) {
        return rejectedSyncPromise(new SentryError("Not adding Promise due to buffer limit reached."));
      }
      var task = taskProducer();
      if (buffer.indexOf(task) === -1) {
        buffer.push(task);
      }
      void task.then(function() {
        return remove(task);
      }).then(null, function() {
        return remove(task).then(null, function() {
        });
      });
      return task;
    }
    function drain(timeout) {
      return new SyncPromise(function(resolve, reject) {
        var counter = buffer.length;
        if (!counter) {
          return resolve(true);
        }
        var capturedSetTimeout = setTimeout(function() {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        buffer.forEach(function(item) {
          void resolvedSyncPromise(item).then(function() {
            if (!--counter) {
              clearTimeout(capturedSetTimeout);
              resolve(true);
            }
          }, reject);
        });
      });
    }
    return {
      $: buffer,
      add,
      drain
    };
  }

  // ../node_modules/@sentry/utils/esm/severity.js
  function isSupportedSeverity(level) {
    return SeverityLevels.indexOf(level) !== -1;
  }
  function severityFromString(level) {
    if (level === "warn")
      return Severity.Warning;
    if (isSupportedSeverity(level)) {
      return level;
    }
    return Severity.Log;
  }

  // ../node_modules/@sentry/utils/esm/status.js
  function eventStatusFromHttpCode(code) {
    if (code >= 200 && code < 300) {
      return "success";
    }
    if (code === 429) {
      return "rate_limit";
    }
    if (code >= 400 && code < 500) {
      return "invalid";
    }
    if (code >= 500) {
      return "failed";
    }
    return "unknown";
  }

  // ../node_modules/@sentry/utils/esm/time.js
  var dateTimestampSource = {
    nowSeconds: function() {
      return Date.now() / 1e3;
    }
  };
  function getBrowserPerformance() {
    var performance2 = getGlobalObject().performance;
    if (!performance2 || !performance2.now) {
      return void 0;
    }
    var timeOrigin = Date.now() - performance2.now();
    return {
      now: function() {
        return performance2.now();
      },
      timeOrigin
    };
  }
  function getNodePerformance() {
    try {
      var perfHooks = dynamicRequire(module, "perf_hooks");
      return perfHooks.performance;
    } catch (_) {
      return void 0;
    }
  }
  var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
  var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
    nowSeconds: function() {
      return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
    }
  };
  var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
  var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
  var timestampWithMs = timestampInSeconds;
  var _browserPerformanceTimeOriginMode;
  var browserPerformanceTimeOrigin = function() {
    var performance2 = getGlobalObject().performance;
    if (!performance2 || !performance2.now) {
      _browserPerformanceTimeOriginMode = "none";
      return void 0;
    }
    var threshold = 3600 * 1e3;
    var performanceNow = performance2.now();
    var dateNow = Date.now();
    var timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    var navigationStart = performance2.timing && performance2.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === "number";
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        _browserPerformanceTimeOriginMode = "timeOrigin";
        return performance2.timeOrigin;
      } else {
        _browserPerformanceTimeOriginMode = "navigationStart";
        return navigationStart;
      }
    }
    _browserPerformanceTimeOriginMode = "dateNow";
    return dateNow;
  }();

  // ../node_modules/@sentry/utils/esm/tracing.js
  var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
  function extractTraceparentData(traceparent) {
    var matches = traceparent.match(TRACEPARENT_REGEXP);
    if (matches) {
      var parentSampled = void 0;
      if (matches[3] === "1") {
        parentSampled = true;
      } else if (matches[3] === "0") {
        parentSampled = false;
      }
      return {
        traceId: matches[1],
        parentSampled,
        parentSpanId: matches[2]
      };
    }
    return void 0;
  }

  // ../node_modules/@sentry/utils/esm/envelope.js
  function createEnvelope(headers, items) {
    if (items === void 0) {
      items = [];
    }
    return [headers, items];
  }
  function getEnvelopeType(envelope) {
    var _a = __read4(envelope, 2), _b = __read4(_a[1], 1), _c = __read4(_b[0], 1), firstItemHeader = _c[0];
    return firstItemHeader.type;
  }
  function serializeEnvelope(envelope) {
    var _a = __read4(envelope, 2), headers = _a[0], items = _a[1];
    var serializedHeaders = JSON.stringify(headers);
    return items.reduce(function(acc, item) {
      var _a2 = __read4(item, 2), itemHeaders = _a2[0], payload = _a2[1];
      var serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
      return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
    }, serializedHeaders);
  }

  // ../node_modules/@sentry/utils/esm/clientreport.js
  function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    var clientReportItem = [
      { type: "client_report" },
      {
        timestamp: timestamp || dateTimestampInSeconds(),
        discarded_events
      }
    ];
    return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
  }

  // ../node_modules/@sentry/utils/esm/ratelimit.js
  var DEFAULT_RETRY_AFTER = 60 * 1e3;
  function parseRetryAfterHeader(header, now) {
    if (now === void 0) {
      now = Date.now();
    }
    var headerDelay = parseInt("" + header, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1e3;
    }
    var headerDate = Date.parse("" + header);
    if (!isNaN(headerDate)) {
      return headerDate - now;
    }
    return DEFAULT_RETRY_AFTER;
  }
  function disabledUntil(limits, category) {
    return limits[category] || limits.all || 0;
  }
  function isRateLimited(limits, category, now) {
    if (now === void 0) {
      now = Date.now();
    }
    return disabledUntil(limits, category) > now;
  }
  function updateRateLimits(limits, headers, now) {
    var e_1, _a, e_2, _b;
    if (now === void 0) {
      now = Date.now();
    }
    var updatedRateLimits = __assign4({}, limits);
    var rateLimitHeader = headers["x-sentry-rate-limits"];
    var retryAfterHeader = headers["retry-after"];
    if (rateLimitHeader) {
      try {
        for (var _c = __values4(rateLimitHeader.trim().split(",")), _d = _c.next(); !_d.done; _d = _c.next()) {
          var limit = _d.value;
          var parameters = limit.split(":", 2);
          var headerDelay = parseInt(parameters[0], 10);
          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
          if (!parameters[1]) {
            updatedRateLimits.all = now + delay;
          } else {
            try {
              for (var _e = (e_2 = void 0, __values4(parameters[1].split(";"))), _f = _e.next(); !_f.done; _f = _e.next()) {
                var category = _f.value;
                updatedRateLimits[category] = now + delay;
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return))
                  _b.call(_e);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    } else if (retryAfterHeader) {
      updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    }
    return updatedRateLimits;
  }

  // ../node_modules/@sentry/hub/esm/scope.js
  var MAX_BREADCRUMBS = 100;
  var Scope = function() {
    function Scope2() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
    }
    Scope2.clone = function(scope) {
      var newScope = new Scope2();
      if (scope) {
        newScope._breadcrumbs = __spread3(scope._breadcrumbs);
        newScope._tags = __assign3({}, scope._tags);
        newScope._extra = __assign3({}, scope._extra);
        newScope._contexts = __assign3({}, scope._contexts);
        newScope._user = scope._user;
        newScope._level = scope._level;
        newScope._span = scope._span;
        newScope._session = scope._session;
        newScope._transactionName = scope._transactionName;
        newScope._fingerprint = scope._fingerprint;
        newScope._eventProcessors = __spread3(scope._eventProcessors);
        newScope._requestSession = scope._requestSession;
      }
      return newScope;
    };
    Scope2.prototype.addScopeListener = function(callback) {
      this._scopeListeners.push(callback);
    };
    Scope2.prototype.addEventProcessor = function(callback) {
      this._eventProcessors.push(callback);
      return this;
    };
    Scope2.prototype.setUser = function(user) {
      this._user = user || {};
      if (this._session) {
        this._session.update({ user });
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getUser = function() {
      return this._user;
    };
    Scope2.prototype.getRequestSession = function() {
      return this._requestSession;
    };
    Scope2.prototype.setRequestSession = function(requestSession) {
      this._requestSession = requestSession;
      return this;
    };
    Scope2.prototype.setTags = function(tags) {
      this._tags = __assign3(__assign3({}, this._tags), tags);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTag = function(key, value) {
      var _a;
      this._tags = __assign3(__assign3({}, this._tags), (_a = {}, _a[key] = value, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtras = function(extras) {
      this._extra = __assign3(__assign3({}, this._extra), extras);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtra = function(key, extra) {
      var _a;
      this._extra = __assign3(__assign3({}, this._extra), (_a = {}, _a[key] = extra, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setFingerprint = function(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setLevel = function(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransactionName = function(name) {
      this._transactionName = name;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransaction = function(name) {
      return this.setTransactionName(name);
    };
    Scope2.prototype.setContext = function(key, context) {
      var _a;
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts = __assign3(__assign3({}, this._contexts), (_a = {}, _a[key] = context, _a));
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setSpan = function(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSpan = function() {
      return this._span;
    };
    Scope2.prototype.getTransaction = function() {
      var span = this.getSpan();
      return span && span.transaction;
    };
    Scope2.prototype.setSession = function(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSession = function() {
      return this._session;
    };
    Scope2.prototype.update = function(captureContext) {
      if (!captureContext) {
        return this;
      }
      if (typeof captureContext === "function") {
        var updatedScope = captureContext(this);
        return updatedScope instanceof Scope2 ? updatedScope : this;
      }
      if (captureContext instanceof Scope2) {
        this._tags = __assign3(__assign3({}, this._tags), captureContext._tags);
        this._extra = __assign3(__assign3({}, this._extra), captureContext._extra);
        this._contexts = __assign3(__assign3({}, this._contexts), captureContext._contexts);
        if (captureContext._user && Object.keys(captureContext._user).length) {
          this._user = captureContext._user;
        }
        if (captureContext._level) {
          this._level = captureContext._level;
        }
        if (captureContext._fingerprint) {
          this._fingerprint = captureContext._fingerprint;
        }
        if (captureContext._requestSession) {
          this._requestSession = captureContext._requestSession;
        }
      } else if (isPlainObject(captureContext)) {
        captureContext = captureContext;
        this._tags = __assign3(__assign3({}, this._tags), captureContext.tags);
        this._extra = __assign3(__assign3({}, this._extra), captureContext.extra);
        this._contexts = __assign3(__assign3({}, this._contexts), captureContext.contexts);
        if (captureContext.user) {
          this._user = captureContext.user;
        }
        if (captureContext.level) {
          this._level = captureContext.level;
        }
        if (captureContext.fingerprint) {
          this._fingerprint = captureContext.fingerprint;
        }
        if (captureContext.requestSession) {
          this._requestSession = captureContext.requestSession;
        }
      }
      return this;
    };
    Scope2.prototype.clear = function() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._requestSession = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
      var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      var mergedBreadcrumb = __assign3({ timestamp: dateTimestampInSeconds() }, breadcrumb);
      this._breadcrumbs = __spread3(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.clearBreadcrumbs = function() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.applyToEvent = function(event, hint) {
      if (this._extra && Object.keys(this._extra).length) {
        event.extra = __assign3(__assign3({}, this._extra), event.extra);
      }
      if (this._tags && Object.keys(this._tags).length) {
        event.tags = __assign3(__assign3({}, this._tags), event.tags);
      }
      if (this._user && Object.keys(this._user).length) {
        event.user = __assign3(__assign3({}, this._user), event.user);
      }
      if (this._contexts && Object.keys(this._contexts).length) {
        event.contexts = __assign3(__assign3({}, this._contexts), event.contexts);
      }
      if (this._level) {
        event.level = this._level;
      }
      if (this._transactionName) {
        event.transaction = this._transactionName;
      }
      if (this._span) {
        event.contexts = __assign3({ trace: this._span.getTraceContext() }, event.contexts);
        var transactionName = this._span.transaction && this._span.transaction.name;
        if (transactionName) {
          event.tags = __assign3({ transaction: transactionName }, event.tags);
        }
      }
      this._applyFingerprint(event);
      event.breadcrumbs = __spread3(event.breadcrumbs || [], this._breadcrumbs);
      event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
      event.sdkProcessingMetadata = this._sdkProcessingMetadata;
      return this._notifyEventProcessors(__spread3(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    Scope2.prototype.setSDKProcessingMetadata = function(newData) {
      this._sdkProcessingMetadata = __assign3(__assign3({}, this._sdkProcessingMetadata), newData);
      return this;
    };
    Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
      var _this = this;
      if (index === void 0) {
        index = 0;
      }
      return new SyncPromise(function(resolve, reject) {
        var processor = processors[index];
        if (event === null || typeof processor !== "function") {
          resolve(event);
        } else {
          var result = processor(__assign3({}, event), hint);
          if (isThenable(result)) {
            void result.then(function(final) {
              return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
            }).then(null, reject);
          } else {
            void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
          }
        }
      });
    };
    Scope2.prototype._notifyScopeListeners = function() {
      var _this = this;
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach(function(callback) {
          callback(_this);
        });
        this._notifyingListeners = false;
      }
    };
    Scope2.prototype._applyFingerprint = function(event) {
      event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
      if (this._fingerprint) {
        event.fingerprint = event.fingerprint.concat(this._fingerprint);
      }
      if (event.fingerprint && !event.fingerprint.length) {
        delete event.fingerprint;
      }
    };
    return Scope2;
  }();
  function getGlobalEventProcessors() {
    return getGlobalSingleton("globalEventProcessors", function() {
      return [];
    });
  }
  function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
  }

  // ../node_modules/@sentry/hub/esm/session.js
  var Session = function() {
    function Session2(context) {
      this.errors = 0;
      this.sid = uuid4();
      this.duration = 0;
      this.status = "ok";
      this.init = true;
      this.ignoreDuration = false;
      var startingTime = timestampInSeconds();
      this.timestamp = startingTime;
      this.started = startingTime;
      if (context) {
        this.update(context);
      }
    }
    Session2.prototype.update = function(context) {
      if (context === void 0) {
        context = {};
      }
      if (context.user) {
        if (!this.ipAddress && context.user.ip_address) {
          this.ipAddress = context.user.ip_address;
        }
        if (!this.did && !context.did) {
          this.did = context.user.id || context.user.email || context.user.username;
        }
      }
      this.timestamp = context.timestamp || timestampInSeconds();
      if (context.ignoreDuration) {
        this.ignoreDuration = context.ignoreDuration;
      }
      if (context.sid) {
        this.sid = context.sid.length === 32 ? context.sid : uuid4();
      }
      if (context.init !== void 0) {
        this.init = context.init;
      }
      if (!this.did && context.did) {
        this.did = "" + context.did;
      }
      if (typeof context.started === "number") {
        this.started = context.started;
      }
      if (this.ignoreDuration) {
        this.duration = void 0;
      } else if (typeof context.duration === "number") {
        this.duration = context.duration;
      } else {
        var duration = this.timestamp - this.started;
        this.duration = duration >= 0 ? duration : 0;
      }
      if (context.release) {
        this.release = context.release;
      }
      if (context.environment) {
        this.environment = context.environment;
      }
      if (!this.ipAddress && context.ipAddress) {
        this.ipAddress = context.ipAddress;
      }
      if (!this.userAgent && context.userAgent) {
        this.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        this.errors = context.errors;
      }
      if (context.status) {
        this.status = context.status;
      }
    };
    Session2.prototype.close = function(status) {
      if (status) {
        this.update({ status });
      } else if (this.status === "ok") {
        this.update({ status: "exited" });
      } else {
        this.update();
      }
    };
    Session2.prototype.toJSON = function() {
      return dropUndefinedKeys({
        sid: "" + this.sid,
        init: this.init,
        started: new Date(this.started * 1e3).toISOString(),
        timestamp: new Date(this.timestamp * 1e3).toISOString(),
        status: this.status,
        errors: this.errors,
        did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
        duration: this.duration,
        attrs: {
          release: this.release,
          environment: this.environment,
          ip_address: this.ipAddress,
          user_agent: this.userAgent
        }
      });
    };
    return Session2;
  }();

  // ../node_modules/@sentry/hub/esm/flags.js
  var IS_DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/hub/esm/hub.js
  var API_VERSION = 4;
  var DEFAULT_BREADCRUMBS = 100;
  var Hub = function() {
    function Hub2(client, scope, _version) {
      if (scope === void 0) {
        scope = new Scope();
      }
      if (_version === void 0) {
        _version = API_VERSION;
      }
      this._version = _version;
      this._stack = [{}];
      this.getStackTop().scope = scope;
      if (client) {
        this.bindClient(client);
      }
    }
    Hub2.prototype.isOlderThan = function(version) {
      return this._version < version;
    };
    Hub2.prototype.bindClient = function(client) {
      var top = this.getStackTop();
      top.client = client;
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    };
    Hub2.prototype.pushScope = function() {
      var scope = Scope.clone(this.getScope());
      this.getStack().push({
        client: this.getClient(),
        scope
      });
      return scope;
    };
    Hub2.prototype.popScope = function() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    };
    Hub2.prototype.withScope = function(callback) {
      var scope = this.pushScope();
      try {
        callback(scope);
      } finally {
        this.popScope();
      }
    };
    Hub2.prototype.getClient = function() {
      return this.getStackTop().client;
    };
    Hub2.prototype.getScope = function() {
      return this.getStackTop().scope;
    };
    Hub2.prototype.getStack = function() {
      return this._stack;
    };
    Hub2.prototype.getStackTop = function() {
      return this._stack[this._stack.length - 1];
    };
    Hub2.prototype.captureException = function(exception, hint) {
      var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error("Sentry syntheticException");
        } catch (exception2) {
          syntheticException = exception2;
        }
        finalHint = {
          originalException: exception,
          syntheticException
        };
      }
      this._invokeClient("captureException", exception, __assign3(__assign3({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureMessage = function(message, level, hint) {
      var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error(message);
        } catch (exception) {
          syntheticException = exception;
        }
        finalHint = {
          originalException: message,
          syntheticException
        };
      }
      this._invokeClient("captureMessage", message, level, __assign3(__assign3({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureEvent = function(event, hint) {
      var eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (event.type !== "transaction") {
        this._lastEventId = eventId;
      }
      this._invokeClient("captureEvent", event, __assign3(__assign3({}, hint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.lastEventId = function() {
      return this._lastEventId;
    };
    Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope || !client)
        return;
      var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
      if (maxBreadcrumbs <= 0)
        return;
      var timestamp = dateTimestampInSeconds();
      var mergedBreadcrumb = __assign3({ timestamp }, breadcrumb);
      var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(function() {
        return beforeBreadcrumb(mergedBreadcrumb, hint);
      }) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    Hub2.prototype.setUser = function(user) {
      var scope = this.getScope();
      if (scope)
        scope.setUser(user);
    };
    Hub2.prototype.setTags = function(tags) {
      var scope = this.getScope();
      if (scope)
        scope.setTags(tags);
    };
    Hub2.prototype.setExtras = function(extras) {
      var scope = this.getScope();
      if (scope)
        scope.setExtras(extras);
    };
    Hub2.prototype.setTag = function(key, value) {
      var scope = this.getScope();
      if (scope)
        scope.setTag(key, value);
    };
    Hub2.prototype.setExtra = function(key, extra) {
      var scope = this.getScope();
      if (scope)
        scope.setExtra(key, extra);
    };
    Hub2.prototype.setContext = function(name, context) {
      var scope = this.getScope();
      if (scope)
        scope.setContext(name, context);
    };
    Hub2.prototype.configureScope = function(callback) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (scope && client) {
        callback(scope);
      }
    };
    Hub2.prototype.run = function(callback) {
      var oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    };
    Hub2.prototype.getIntegration = function(integration) {
      var client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        IS_DEBUG_BUILD2 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
        return null;
      }
    };
    Hub2.prototype.startSpan = function(context) {
      return this._callExtensionMethod("startSpan", context);
    };
    Hub2.prototype.startTransaction = function(context, customSamplingContext) {
      return this._callExtensionMethod("startTransaction", context, customSamplingContext);
    };
    Hub2.prototype.traceHeaders = function() {
      return this._callExtensionMethod("traceHeaders");
    };
    Hub2.prototype.captureSession = function(endSession) {
      if (endSession === void 0) {
        endSession = false;
      }
      if (endSession) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    };
    Hub2.prototype.endSession = function() {
      var layer = this.getStackTop();
      var scope = layer && layer.scope;
      var session = scope && scope.getSession();
      if (session) {
        session.close();
      }
      this._sendSessionUpdate();
      if (scope) {
        scope.setSession();
      }
    };
    Hub2.prototype.startSession = function(context) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
      var global12 = getGlobalObject();
      var userAgent = (global12.navigator || {}).userAgent;
      var session = new Session(__assign3(__assign3(__assign3({
        release,
        environment
      }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
      if (scope) {
        var currentSession = scope.getSession && scope.getSession();
        if (currentSession && currentSession.status === "ok") {
          currentSession.update({ status: "exited" });
        }
        this.endSession();
        scope.setSession(session);
      }
      return session;
    };
    Hub2.prototype._sendSessionUpdate = function() {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope)
        return;
      var session = scope.getSession && scope.getSession();
      if (session) {
        if (client && client.captureSession) {
          client.captureSession(session);
        }
      }
    };
    Hub2.prototype._invokeClient = function(method) {
      var _a;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
      if (client && client[method]) {
        (_a = client)[method].apply(_a, __spread3(args, [scope]));
      }
    };
    Hub2.prototype._callExtensionMethod = function(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var carrier = getMainCarrier();
      var sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      IS_DEBUG_BUILD2 && logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub2;
  }();
  function getMainCarrier() {
    var carrier = getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return carrier;
  }
  function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  }
  function getCurrentHub() {
    var registry = getMainCarrier();
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
      setHubOnCarrier(registry, new Hub());
    }
    if (isNodeEnv()) {
      return getHubFromActiveDomain(registry);
    }
    return getHubFromCarrier(registry);
  }
  function getHubFromActiveDomain(registry) {
    try {
      var sentry = getMainCarrier().__SENTRY__;
      var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
      if (!activeDomain) {
        return getHubFromCarrier(registry);
      }
      if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
        var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
        setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
      }
      return getHubFromCarrier(activeDomain);
    } catch (_Oo) {
      return getHubFromCarrier(registry);
    }
  }
  function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier(carrier) {
    return getGlobalSingleton("hub", function() {
      return new Hub();
    }, carrier);
  }
  function setHubOnCarrier(carrier, hub) {
    if (!carrier)
      return false;
    var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }

  // ../node_modules/@sentry/minimal/esm/index.js
  function callOnHub(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var hub = getCurrentHub();
    if (hub && hub[method]) {
      return hub[method].apply(hub, __spread2(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
  }
  function captureException(exception, captureContext) {
    var syntheticException = new Error("Sentry syntheticException");
    return callOnHub("captureException", exception, {
      captureContext,
      originalException: exception,
      syntheticException
    });
  }
  function setTag(key, value) {
    callOnHub("setTag", key, value);
  }
  function withScope(callback) {
    callOnHub("withScope", callback);
  }

  // ../node_modules/@sentry/core/esm/api.js
  var SENTRY_API_VERSION = "7";
  var API = function() {
    function API2(dsn, metadata, tunnel) {
      if (metadata === void 0) {
        metadata = {};
      }
      this.dsn = dsn;
      this._dsnObject = makeDsn(dsn);
      this.metadata = metadata;
      this._tunnel = tunnel;
    }
    API2.prototype.getDsn = function() {
      return this._dsnObject;
    };
    API2.prototype.forceEnvelope = function() {
      return !!this._tunnel;
    };
    API2.prototype.getBaseApiEndpoint = function() {
      return getBaseApiEndpoint(this._dsnObject);
    };
    API2.prototype.getStoreEndpoint = function() {
      return getStoreEndpoint(this._dsnObject);
    };
    API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
      return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
    };
    API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
      return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
    };
    return API2;
  }();
  function initAPIDetails(dsn, metadata, tunnel) {
    return {
      initDsn: dsn,
      metadata: metadata || {},
      dsn: makeDsn(dsn),
      tunnel
    };
  }
  function getBaseApiEndpoint(dsn) {
    var protocol = dsn.protocol ? dsn.protocol + ":" : "";
    var port = dsn.port ? ":" + dsn.port : "";
    return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
  }
  function _getIngestEndpoint(dsn, target) {
    return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
  }
  function _encodedAuth(dsn) {
    return urlEncode({
      sentry_key: dsn.publicKey,
      sentry_version: SENTRY_API_VERSION
    });
  }
  function getStoreEndpoint(dsn) {
    return _getIngestEndpoint(dsn, "store");
  }
  function getStoreEndpointWithUrlEncodedAuth(dsn) {
    return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
  }
  function _getEnvelopeEndpoint(dsn) {
    return _getIngestEndpoint(dsn, "envelope");
  }
  function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
    return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
  }
  function getReportDialogEndpoint(dsnLike, dialogOptions) {
    var dsn = makeDsn(dsnLike);
    var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
    var encodedOptions = "dsn=" + dsnToString(dsn);
    for (var key in dialogOptions) {
      if (key === "dsn") {
        continue;
      }
      if (key === "user") {
        if (!dialogOptions.user) {
          continue;
        }
        if (dialogOptions.user.name) {
          encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
        }
        if (dialogOptions.user.email) {
          encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
        }
      } else {
        encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
      }
    }
    return endpoint + "?" + encodedOptions;
  }

  // ../node_modules/@sentry/core/node_modules/tslib/modules/index.js
  var import_tslib18 = __toESM(require_tslib5(), 1);
  var {
    __extends: __extends5,
    __assign: __assign5,
    __rest: __rest5,
    __decorate: __decorate5,
    __param: __param5,
    __metadata: __metadata5,
    __awaiter: __awaiter5,
    __generator: __generator5,
    __exportStar: __exportStar5,
    __createBinding: __createBinding5,
    __values: __values5,
    __read: __read5,
    __spread: __spread5,
    __spreadArrays: __spreadArrays5,
    __await: __await5,
    __asyncGenerator: __asyncGenerator5,
    __asyncDelegator: __asyncDelegator5,
    __asyncValues: __asyncValues5,
    __makeTemplateObject: __makeTemplateObject5,
    __importStar: __importStar5,
    __importDefault: __importDefault5,
    __classPrivateFieldGet: __classPrivateFieldGet5,
    __classPrivateFieldSet: __classPrivateFieldSet5
  } = import_tslib18.default;

  // ../node_modules/@sentry/core/esm/flags.js
  var IS_DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/core/esm/integration.js
  var installedIntegrations = [];
  function filterDuplicates(integrations) {
    return integrations.reduce(function(acc, integrations2) {
      if (acc.every(function(accIntegration) {
        return integrations2.name !== accIntegration.name;
      })) {
        acc.push(integrations2);
      }
      return acc;
    }, []);
  }
  function getIntegrationsToSetup(options) {
    var defaultIntegrations2 = options.defaultIntegrations && __spread5(options.defaultIntegrations) || [];
    var userIntegrations = options.integrations;
    var integrations = __spread5(filterDuplicates(defaultIntegrations2));
    if (Array.isArray(userIntegrations)) {
      integrations = __spread5(integrations.filter(function(integrations2) {
        return userIntegrations.every(function(userIntegration) {
          return userIntegration.name !== integrations2.name;
        });
      }), filterDuplicates(userIntegrations));
    } else if (typeof userIntegrations === "function") {
      integrations = userIntegrations(integrations);
      integrations = Array.isArray(integrations) ? integrations : [integrations];
    }
    var integrationsNames = integrations.map(function(i) {
      return i.name;
    });
    var alwaysLastToRun = "Debug";
    if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
      integrations.push.apply(integrations, __spread5(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
    }
    return integrations;
  }
  function setupIntegration(integration) {
    if (installedIntegrations.indexOf(integration.name) !== -1) {
      return;
    }
    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
    installedIntegrations.push(integration.name);
    IS_DEBUG_BUILD3 && logger.log("Integration installed: " + integration.name);
  }
  function setupIntegrations(options) {
    var integrations = {};
    getIntegrationsToSetup(options).forEach(function(integration) {
      integrations[integration.name] = integration;
      setupIntegration(integration);
    });
    addNonEnumerableProperty(integrations, "initialized", true);
    return integrations;
  }

  // ../node_modules/@sentry/core/esm/baseclient.js
  var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
  var BaseClient = function() {
    function BaseClient2(backendClass, options) {
      this._integrations = {};
      this._numProcessing = 0;
      this._backend = new backendClass(options);
      this._options = options;
      if (options.dsn) {
        this._dsn = makeDsn(options.dsn);
      }
    }
    BaseClient2.prototype.captureException = function(exception, hint, scope) {
      var _this = this;
      if (checkOrSetAlreadyCaught(exception)) {
        IS_DEBUG_BUILD3 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      var eventId = hint && hint.event_id;
      this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
      var _this = this;
      var eventId = hint && hint.event_id;
      var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
      this._process(promisedEvent.then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureEvent = function(event, hint, scope) {
      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
        IS_DEBUG_BUILD3 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      var eventId = hint && hint.event_id;
      this._process(this._captureEvent(event, hint, scope).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureSession = function(session) {
      if (!this._isEnabled()) {
        IS_DEBUG_BUILD3 && logger.warn("SDK not enabled, will not capture session.");
        return;
      }
      if (!(typeof session.release === "string")) {
        IS_DEBUG_BUILD3 && logger.warn("Discarded session because of missing or non-string release");
      } else {
        this._sendSession(session);
        session.update({ init: false });
      }
    };
    BaseClient2.prototype.getDsn = function() {
      return this._dsn;
    };
    BaseClient2.prototype.getOptions = function() {
      return this._options;
    };
    BaseClient2.prototype.getTransport = function() {
      return this._getBackend().getTransport();
    };
    BaseClient2.prototype.flush = function(timeout) {
      var _this = this;
      return this._isClientDoneProcessing(timeout).then(function(clientFinished) {
        return _this.getTransport().close(timeout).then(function(transportFlushed) {
          return clientFinished && transportFlushed;
        });
      });
    };
    BaseClient2.prototype.close = function(timeout) {
      var _this = this;
      return this.flush(timeout).then(function(result) {
        _this.getOptions().enabled = false;
        return result;
      });
    };
    BaseClient2.prototype.setupIntegrations = function() {
      if (this._isEnabled() && !this._integrations.initialized) {
        this._integrations = setupIntegrations(this._options);
      }
    };
    BaseClient2.prototype.getIntegration = function(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        IS_DEBUG_BUILD3 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
        return null;
      }
    };
    BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
      var e_1, _a;
      var crashed = false;
      var errored = false;
      var exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        try {
          for (var exceptions_1 = __values5(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
            var ex = exceptions_1_1.value;
            var mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return))
              _a.call(exceptions_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      var sessionNonTerminal = session.status === "ok";
      var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
      if (shouldUpdateAndSend) {
        session.update(__assign5(__assign5({}, crashed && { status: "crashed" }), { errors: session.errors || Number(errored || crashed) }));
        this.captureSession(session);
      }
    };
    BaseClient2.prototype._sendSession = function(session) {
      this._getBackend().sendSession(session);
    };
    BaseClient2.prototype._isClientDoneProcessing = function(timeout) {
      var _this = this;
      return new SyncPromise(function(resolve) {
        var ticked = 0;
        var tick = 1;
        var interval = setInterval(function() {
          if (_this._numProcessing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    };
    BaseClient2.prototype._getBackend = function() {
      return this._backend;
    };
    BaseClient2.prototype._isEnabled = function() {
      return this.getOptions().enabled !== false && this._dsn !== void 0;
    };
    BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
      var _this = this;
      var _a = this.getOptions(), _b = _a.normalizeDepth, normalizeDepth = _b === void 0 ? 3 : _b, _c = _a.normalizeMaxBreadth, normalizeMaxBreadth = _c === void 0 ? 1e3 : _c;
      var prepared = __assign5(__assign5({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()), timestamp: event.timestamp || dateTimestampInSeconds() });
      this._applyClientOptions(prepared);
      this._applyIntegrationsMetadata(prepared);
      var finalScope = scope;
      if (hint && hint.captureContext) {
        finalScope = Scope.clone(finalScope).update(hint.captureContext);
      }
      var result = resolvedSyncPromise(prepared);
      if (finalScope) {
        result = finalScope.applyToEvent(prepared, hint);
      }
      return result.then(function(evt) {
        if (evt) {
          evt.sdkProcessingMetadata = __assign5(__assign5({}, evt.sdkProcessingMetadata), { normalizeDepth: normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")" });
        }
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
        }
        return evt;
      });
    };
    BaseClient2.prototype._normalizeEvent = function(event, depth, maxBreadth) {
      if (!event) {
        return null;
      }
      var normalized = __assign5(__assign5(__assign5(__assign5(__assign5({}, event), event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map(function(b) {
          return __assign5(__assign5({}, b), b.data && {
            data: normalize(b.data, depth, maxBreadth)
          });
        })
      }), event.user && {
        user: normalize(event.user, depth, maxBreadth)
      }), event.contexts && {
        contexts: normalize(event.contexts, depth, maxBreadth)
      }), event.extra && {
        extra: normalize(event.extra, depth, maxBreadth)
      });
      if (event.contexts && event.contexts.trace) {
        normalized.contexts.trace = event.contexts.trace;
      }
      normalized.sdkProcessingMetadata = __assign5(__assign5({}, normalized.sdkProcessingMetadata), { baseClientNormalized: true });
      return normalized;
    };
    BaseClient2.prototype._applyClientOptions = function(event) {
      var options = this.getOptions();
      var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : "production";
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = truncate(event.message, maxValueLength);
      }
      var exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = truncate(exception.value, maxValueLength);
      }
      var request = event.request;
      if (request && request.url) {
        request.url = truncate(request.url, maxValueLength);
      }
    };
    BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
      var integrationsArray = Object.keys(this._integrations);
      if (integrationsArray.length > 0) {
        event.sdk = event.sdk || {};
        event.sdk.integrations = __spread5(event.sdk.integrations || [], integrationsArray);
      }
    };
    BaseClient2.prototype._sendEvent = function(event) {
      this._getBackend().sendEvent(event);
    };
    BaseClient2.prototype._captureEvent = function(event, hint, scope) {
      return this._processEvent(event, hint, scope).then(function(finalEvent) {
        return finalEvent.event_id;
      }, function(reason) {
        IS_DEBUG_BUILD3 && logger.error(reason);
        return void 0;
      });
    };
    BaseClient2.prototype._processEvent = function(event, hint, scope) {
      var _this = this;
      var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
      var transport = this.getTransport();
      function recordLostEvent(outcome, category) {
        if (transport.recordLostEvent) {
          transport.recordLostEvent(outcome, category);
        }
      }
      if (!this._isEnabled()) {
        return rejectedSyncPromise(new SentryError("SDK not enabled, will not capture event."));
      }
      var isTransaction = event.type === "transaction";
      if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
        recordLostEvent("sample_rate", "event");
        return rejectedSyncPromise(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
      }
      return this._prepareEvent(event, scope, hint).then(function(prepared) {
        if (prepared === null) {
          recordLostEvent("event_processor", event.type || "event");
          throw new SentryError("An event processor returned null, will not send event.");
        }
        var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
        if (isInternalException || isTransaction || !beforeSend) {
          return prepared;
        }
        var beforeSendResult = beforeSend(prepared, hint);
        return _ensureBeforeSendRv(beforeSendResult);
      }).then(function(processedEvent) {
        if (processedEvent === null) {
          recordLostEvent("before_send", event.type || "event");
          throw new SentryError("`beforeSend` returned `null`, will not send event.");
        }
        var session = scope && scope.getSession && scope.getSession();
        if (!isTransaction && session) {
          _this._updateSessionFromEvent(session, processedEvent);
        }
        _this._sendEvent(processedEvent);
        return processedEvent;
      }).then(null, function(reason) {
        if (reason instanceof SentryError) {
          throw reason;
        }
        _this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
      });
    };
    BaseClient2.prototype._process = function(promise) {
      var _this = this;
      this._numProcessing += 1;
      void promise.then(function(value) {
        _this._numProcessing -= 1;
        return value;
      }, function(reason) {
        _this._numProcessing -= 1;
        return reason;
      });
    };
    return BaseClient2;
  }();
  function _ensureBeforeSendRv(rv) {
    var nullErr = "`beforeSend` method has to return `null` or a valid event.";
    if (isThenable(rv)) {
      return rv.then(function(event) {
        if (!(isPlainObject(event) || event === null)) {
          throw new SentryError(nullErr);
        }
        return event;
      }, function(e) {
        throw new SentryError("beforeSend rejected with " + e);
      });
    } else if (!(isPlainObject(rv) || rv === null)) {
      throw new SentryError(nullErr);
    }
    return rv;
  }

  // ../node_modules/@sentry/core/esm/request.js
  function getSdkMetadataForEnvelopeHeader(api) {
    if (!api.metadata || !api.metadata.sdk) {
      return;
    }
    var _a = api.metadata.sdk, name = _a.name, version = _a.version;
    return { name, version };
  }
  function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = __spread5(event.sdk.integrations || [], sdkInfo.integrations || []);
    event.sdk.packages = __spread5(event.sdk.packages || [], sdkInfo.packages || []);
    return event;
  }
  function createSessionEnvelope(session, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var envelopeHeaders = __assign5(__assign5({ sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
    var type = "aggregates" in session ? "sessions" : "session";
    var envelopeItem = [{ type }, session];
    var envelope = createEnvelope(envelopeHeaders, [envelopeItem]);
    return [envelope, type];
  }
  function sessionToSentryRequest(session, api) {
    var _a = __read5(createSessionEnvelope(session, api), 2), envelope = _a[0], type = _a[1];
    return {
      body: serializeEnvelope(envelope),
      type,
      url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
    };
  }
  function createEventEnvelope(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || "event";
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
      event.tags.skippedNormalization = true;
      event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
    }
    delete event.sdkProcessingMetadata;
    var envelopeHeaders = __assign5(__assign5({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
    var eventItem = [
      {
        type: eventType,
        sample_rates: [{ id: samplingMethod, rate: sampleRate }]
      },
      event
    ];
    return createEnvelope(envelopeHeaders, [eventItem]);
  }
  function eventToSentryRequest(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || "event";
    var useEnvelope = eventType === "transaction" || !!api.tunnel;
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
      event.tags.skippedNormalization = true;
      event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
    }
    delete event.sdkProcessingMetadata;
    var body;
    try {
      body = JSON.stringify(event);
    } catch (err) {
      event.tags.JSONStringifyError = true;
      event.extra.JSONStringifyError = err;
      try {
        body = JSON.stringify(normalize(event));
      } catch (newErr) {
        var innerErr = newErr;
        body = JSON.stringify({
          message: "JSON.stringify error after renormalization",
          extra: { message: innerErr.message, stack: innerErr.stack }
        });
      }
    }
    var req = {
      body,
      type: eventType,
      url: useEnvelope ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel) : getStoreEndpointWithUrlEncodedAuth(api.dsn)
    };
    if (useEnvelope) {
      var envelopeHeaders = __assign5(__assign5({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
      var eventItem = [
        {
          type: eventType,
          sample_rates: [{ id: samplingMethod, rate: sampleRate }]
        },
        req.body
      ];
      var envelope = createEnvelope(envelopeHeaders, [eventItem]);
      req.body = serializeEnvelope(envelope);
    }
    return req;
  }

  // ../node_modules/@sentry/core/esm/transports/noop.js
  var NoopTransport = function() {
    function NoopTransport2() {
    }
    NoopTransport2.prototype.sendEvent = function(_) {
      return resolvedSyncPromise({
        reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
        status: "skipped"
      });
    };
    NoopTransport2.prototype.close = function(_) {
      return resolvedSyncPromise(true);
    };
    return NoopTransport2;
  }();

  // ../node_modules/@sentry/core/esm/basebackend.js
  var BaseBackend = function() {
    function BaseBackend2(options) {
      this._options = options;
      if (!this._options.dsn) {
        IS_DEBUG_BUILD3 && logger.warn("No DSN provided, backend will not do anything.");
      }
      this._transport = this._setupTransport();
    }
    BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
      throw new SentryError("Backend has to implement `eventFromException` method");
    };
    BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
      throw new SentryError("Backend has to implement `eventFromMessage` method");
    };
    BaseBackend2.prototype.sendEvent = function(event) {
      if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
        var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
        var env = createEventEnvelope(event, api);
        void this._newTransport.send(env).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending event:", reason);
        });
      } else {
        void this._transport.sendEvent(event).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending event:", reason);
        });
      }
    };
    BaseBackend2.prototype.sendSession = function(session) {
      if (!this._transport.sendSession) {
        IS_DEBUG_BUILD3 && logger.warn("Dropping session because custom transport doesn't implement sendSession");
        return;
      }
      if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
        var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
        var _a = __read5(createSessionEnvelope(session, api), 1), env = _a[0];
        void this._newTransport.send(env).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending session:", reason);
        });
      } else {
        void this._transport.sendSession(session).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending session:", reason);
        });
      }
    };
    BaseBackend2.prototype.getTransport = function() {
      return this._transport;
    };
    BaseBackend2.prototype._setupTransport = function() {
      return new NoopTransport();
    };
    return BaseBackend2;
  }();

  // ../node_modules/@sentry/core/esm/sdk.js
  function initAndBind(clientClass, options) {
    if (options.debug === true) {
      if (IS_DEBUG_BUILD3) {
        logger.enable();
      } else {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      }
    }
    var hub = getCurrentHub();
    var scope = hub.getScope();
    if (scope) {
      scope.update(options.initialScope);
    }
    var client = new clientClass(options);
    hub.bindClient(client);
  }

  // ../node_modules/@sentry/core/esm/transports/base.js
  var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
  function createTransport(options, makeRequest, buffer) {
    if (buffer === void 0) {
      buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);
    }
    var rateLimits = {};
    var flush2 = function(timeout) {
      return buffer.drain(timeout);
    };
    function send(envelope) {
      var envCategory = getEnvelopeType(envelope);
      var category = envCategory === "event" ? "error" : envCategory;
      var request = {
        category,
        body: serializeEnvelope(envelope)
      };
      if (isRateLimited(rateLimits, category)) {
        return rejectedSyncPromise({
          status: "rate_limit",
          reason: getRateLimitReason(rateLimits, category)
        });
      }
      var requestTask = function() {
        return makeRequest(request).then(function(_a) {
          var body = _a.body, headers = _a.headers, reason = _a.reason, statusCode = _a.statusCode;
          var status = eventStatusFromHttpCode(statusCode);
          if (headers) {
            rateLimits = updateRateLimits(rateLimits, headers);
          }
          if (status === "success") {
            return resolvedSyncPromise({ status, reason });
          }
          return rejectedSyncPromise({
            status,
            reason: reason || body || (status === "rate_limit" ? getRateLimitReason(rateLimits, category) : "Unknown transport error")
          });
        });
      };
      return buffer.add(requestTask);
    }
    return {
      send,
      flush: flush2
    };
  }
  function getRateLimitReason(rateLimits, category) {
    return "Too many " + category + " requests, backing off until: " + new Date(disabledUntil(rateLimits, category)).toISOString();
  }

  // ../node_modules/@sentry/core/esm/version.js
  var SDK_VERSION = "6.19.7";

  // ../node_modules/@sentry/core/esm/integrations/index.js
  var integrations_exports = {};
  __export(integrations_exports, {
    FunctionToString: () => FunctionToString,
    InboundFilters: () => InboundFilters
  });

  // ../node_modules/@sentry/core/esm/integrations/functiontostring.js
  var originalFunctionToString;
  var FunctionToString = function() {
    function FunctionToString2() {
      this.name = FunctionToString2.id;
    }
    FunctionToString2.prototype.setupOnce = function() {
      originalFunctionToString = Function.prototype.toString;
      Function.prototype.toString = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var context = getOriginalFunction(this) || this;
        return originalFunctionToString.apply(context, args);
      };
    };
    FunctionToString2.id = "FunctionToString";
    return FunctionToString2;
  }();

  // ../node_modules/@sentry/core/esm/integrations/inboundfilters.js
  var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
  var InboundFilters = function() {
    function InboundFilters2(_options) {
      if (_options === void 0) {
        _options = {};
      }
      this._options = _options;
      this.name = InboundFilters2.id;
    }
    InboundFilters2.prototype.setupOnce = function(addGlobalEventProcessor2, getCurrentHub2) {
      addGlobalEventProcessor2(function(event) {
        var hub = getCurrentHub2();
        if (hub) {
          var self_1 = hub.getIntegration(InboundFilters2);
          if (self_1) {
            var client = hub.getClient();
            var clientOptions = client ? client.getOptions() : {};
            var options = _mergeOptions(self_1._options, clientOptions);
            return _shouldDropEvent(event, options) ? null : event;
          }
        }
        return event;
      });
    };
    InboundFilters2.id = "InboundFilters";
    return InboundFilters2;
  }();
  function _mergeOptions(internalOptions, clientOptions) {
    if (internalOptions === void 0) {
      internalOptions = {};
    }
    if (clientOptions === void 0) {
      clientOptions = {};
    }
    return {
      allowUrls: __spread5(internalOptions.whitelistUrls || [], internalOptions.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
      denyUrls: __spread5(internalOptions.blacklistUrls || [], internalOptions.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
      ignoreErrors: __spread5(internalOptions.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
      ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
    };
  }
  function _shouldDropEvent(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
      return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
      return true;
    }
    return false;
  }
  function _isIgnoredError(event, ignoreErrors) {
    if (!ignoreErrors || !ignoreErrors.length) {
      return false;
    }
    return _getPossibleEventMessages(event).some(function(message) {
      return ignoreErrors.some(function(pattern) {
        return isMatchingPattern(message, pattern);
      });
    });
  }
  function _isDeniedUrl(event, denyUrls) {
    if (!denyUrls || !denyUrls.length) {
      return false;
    }
    var url = _getEventFilterUrl(event);
    return !url ? false : denyUrls.some(function(pattern) {
      return isMatchingPattern(url, pattern);
    });
  }
  function _isAllowedUrl(event, allowUrls) {
    if (!allowUrls || !allowUrls.length) {
      return true;
    }
    var url = _getEventFilterUrl(event);
    return !url ? true : allowUrls.some(function(pattern) {
      return isMatchingPattern(url, pattern);
    });
  }
  function _getPossibleEventMessages(event) {
    if (event.message) {
      return [event.message];
    }
    if (event.exception) {
      try {
        var _a = event.exception.values && event.exception.values[0] || {}, _b = _a.type, type = _b === void 0 ? "" : _b, _c = _a.value, value = _c === void 0 ? "" : _c;
        return ["" + value, type + ": " + value];
      } catch (oO) {
        IS_DEBUG_BUILD3 && logger.error("Cannot extract message for event " + getEventDescription(event));
        return [];
      }
    }
    return [];
  }
  function _isSentryError(event) {
    try {
      return event.exception.values[0].type === "SentryError";
    } catch (e) {
    }
    return false;
  }
  function _getLastValidUrl(frames) {
    if (frames === void 0) {
      frames = [];
    }
    for (var i = frames.length - 1; i >= 0; i--) {
      var frame = frames[i];
      if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
        return frame.filename || null;
      }
    }
    return null;
  }
  function _getEventFilterUrl(event) {
    try {
      if (event.stacktrace) {
        return _getLastValidUrl(event.stacktrace.frames);
      }
      var frames_1;
      try {
        frames_1 = event.exception.values[0].stacktrace.frames;
      } catch (e) {
      }
      return frames_1 ? _getLastValidUrl(frames_1) : null;
    } catch (oO) {
      IS_DEBUG_BUILD3 && logger.error("Cannot extract url for event " + getEventDescription(event));
      return null;
    }
  }

  // ../node_modules/@sentry/browser/esm/stack-parsers.js
  var UNKNOWN_FUNCTION = "?";
  var OPERA10_PRIORITY = 10;
  var OPERA11_PRIORITY = 20;
  var CHROME_PRIORITY = 30;
  var WINJS_PRIORITY = 40;
  var GECKO_PRIORITY = 50;
  function createFrame(filename, func, lineno, colno) {
    var frame = {
      filename,
      function: func,
      in_app: true
    };
    if (lineno !== void 0) {
      frame.lineno = lineno;
    }
    if (colno !== void 0) {
      frame.colno = colno;
    }
    return frame;
  }
  var chromeRegex = /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var chrome = function(line) {
    var parts = chromeRegex.exec(line);
    if (parts) {
      var isEval = parts[2] && parts[2].indexOf("eval") === 0;
      if (isEval) {
        var subMatch = chromeEvalRegex.exec(parts[2]);
        if (subMatch) {
          parts[2] = subMatch[1];
          parts[3] = subMatch[2];
          parts[4] = subMatch[3];
        }
      }
      var _a = __read(extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]), 2), func = _a[0], filename = _a[1];
      return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
    }
    return;
  };
  var chromeStackParser = [CHROME_PRIORITY, chrome];
  var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var gecko = function(line) {
    var _a;
    var parts = geckoREgex.exec(line);
    if (parts) {
      var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      if (isEval) {
        var subMatch = geckoEvalRegex.exec(parts[3]);
        if (subMatch) {
          parts[1] = parts[1] || "eval";
          parts[3] = subMatch[1];
          parts[4] = subMatch[2];
          parts[5] = "";
        }
      }
      var filename = parts[3];
      var func = parts[1] || UNKNOWN_FUNCTION;
      _a = __read(extractSafariExtensionDetails(func, filename), 2), func = _a[0], filename = _a[1];
      return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
    }
    return;
  };
  var geckoStackParser = [GECKO_PRIORITY, gecko];
  var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var winjs = function(line) {
    var parts = winjsRegex.exec(line);
    return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
  };
  var winjsStackParser = [WINJS_PRIORITY, winjs];
  var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
  var opera10 = function(line) {
    var parts = opera10Regex.exec(line);
    return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : void 0;
  };
  var opera10StackParser = [OPERA10_PRIORITY, opera10];
  var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;
  var opera11 = function(line) {
    var parts = opera11Regex.exec(line);
    return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : void 0;
  };
  var opera11StackParser = [OPERA11_PRIORITY, opera11];
  var extractSafariExtensionDetails = function(func, filename) {
    var isSafariExtension = func.indexOf("safari-extension") !== -1;
    var isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
    return isSafariExtension || isSafariWebExtension ? [
      func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
      isSafariExtension ? "safari-extension:" + filename : "safari-web-extension:" + filename
    ] : [func, filename];
  };

  // ../node_modules/@sentry/browser/esm/eventbuilder.js
  function exceptionFromError(ex) {
    var frames = parseStackFrames(ex);
    var exception = {
      type: ex && ex.name,
      value: extractMessage(ex)
    };
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    if (exception.type === void 0 && exception.value === "") {
      exception.value = "Unrecoverable error caught";
    }
    return exception;
  }
  function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {
    var event = {
      exception: {
        values: [
          {
            type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
            value: "Non-Error " + (isUnhandledRejection ? "promise rejection" : "exception") + " captured with keys: " + extractExceptionKeysForMessage(exception)
          }
        ]
      },
      extra: {
        __serialized__: normalizeToSize(exception)
      }
    };
    if (syntheticException) {
      var frames_1 = parseStackFrames(syntheticException);
      if (frames_1.length) {
        event.stacktrace = { frames: frames_1 };
      }
    }
    return event;
  }
  function eventFromError(ex) {
    return {
      exception: {
        values: [exceptionFromError(ex)]
      }
    };
  }
  function parseStackFrames(ex) {
    var stacktrace = ex.stacktrace || ex.stack || "";
    var popSize = getPopSize(ex);
    try {
      return createStackParser(opera10StackParser, opera11StackParser, chromeStackParser, winjsStackParser, geckoStackParser)(stacktrace, popSize);
    } catch (e) {
    }
    return [];
  }
  var reactMinifiedRegexp = /Minified React error #\d+;/i;
  function getPopSize(ex) {
    if (ex) {
      if (typeof ex.framesToPop === "number") {
        return ex.framesToPop;
      }
      if (reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }
    }
    return 0;
  }
  function extractMessage(ex) {
    var message = ex && ex.message;
    if (!message) {
      return "No error message";
    }
    if (message.error && typeof message.error.message === "string") {
      return message.error.message;
    }
    return message;
  }
  function eventFromException(exception, hint, attachStacktrace) {
    var syntheticException = hint && hint.syntheticException || void 0;
    var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);
    addExceptionMechanism(event);
    event.level = Severity.Error;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromMessage(message, level, hint, attachStacktrace) {
    if (level === void 0) {
      level = Severity.Info;
    }
    var syntheticException = hint && hint.syntheticException || void 0;
    var event = eventFromString(message, syntheticException, attachStacktrace);
    event.level = level;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {
    var event;
    if (isErrorEvent(exception) && exception.error) {
      var errorEvent = exception;
      return eventFromError(errorEvent.error);
    }
    if (isDOMError(exception) || isDOMException(exception)) {
      var domException = exception;
      if ("stack" in exception) {
        event = eventFromError(exception);
      } else {
        var name_1 = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
        var message = domException.message ? name_1 + ": " + domException.message : name_1;
        event = eventFromString(message, syntheticException, attachStacktrace);
        addExceptionTypeValue(event, message);
      }
      if ("code" in domException) {
        event.tags = __assign(__assign({}, event.tags), { "DOMException.code": "" + domException.code });
      }
      return event;
    }
    if (isError(exception)) {
      return eventFromError(exception);
    }
    if (isPlainObject(exception) || isEvent(exception)) {
      var objectException = exception;
      event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);
      addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    event = eventFromString(exception, syntheticException, attachStacktrace);
    addExceptionTypeValue(event, "" + exception, void 0);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  function eventFromString(input, syntheticException, attachStacktrace) {
    var event = {
      message: input
    };
    if (attachStacktrace && syntheticException) {
      var frames_2 = parseStackFrames(syntheticException);
      if (frames_2.length) {
        event.stacktrace = { frames: frames_2 };
      }
    }
    return event;
  }

  // ../node_modules/@sentry/browser/esm/flags.js
  var IS_DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/browser/esm/transports/utils.js
  var global4 = getGlobalObject();
  var cachedFetchImpl;
  function getNativeFetchImplementation() {
    if (cachedFetchImpl) {
      return cachedFetchImpl;
    }
    if (isNativeFetch(global4.fetch)) {
      return cachedFetchImpl = global4.fetch.bind(global4);
    }
    var document2 = global4.document;
    var fetchImpl = global4.fetch;
    if (document2 && typeof document2.createElement === "function") {
      try {
        var sandbox = document2.createElement("iframe");
        sandbox.hidden = true;
        document2.head.appendChild(sandbox);
        var contentWindow = sandbox.contentWindow;
        if (contentWindow && contentWindow.fetch) {
          fetchImpl = contentWindow.fetch;
        }
        document2.head.removeChild(sandbox);
      } catch (e) {
        IS_DEBUG_BUILD4 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
      }
    }
    return cachedFetchImpl = fetchImpl.bind(global4);
  }
  function sendReport(url, body) {
    var isRealNavigator = Object.prototype.toString.call(global4 && global4.navigator) === "[object Navigator]";
    var hasSendBeacon = isRealNavigator && typeof global4.navigator.sendBeacon === "function";
    if (hasSendBeacon) {
      var sendBeacon = global4.navigator.sendBeacon.bind(global4.navigator);
      return sendBeacon(url, body);
    }
    if (supportsFetch()) {
      var fetch_1 = getNativeFetchImplementation();
      return forget(fetch_1(url, {
        body,
        method: "POST",
        credentials: "omit",
        keepalive: true
      }));
    }
  }

  // ../node_modules/@sentry/browser/esm/transports/base.js
  function requestTypeToCategory(ty) {
    var tyStr = ty;
    return tyStr === "event" ? "error" : tyStr;
  }
  var global5 = getGlobalObject();
  var BaseTransport = function() {
    function BaseTransport2(options) {
      var _this = this;
      this.options = options;
      this._buffer = makePromiseBuffer(30);
      this._rateLimits = {};
      this._outcomes = {};
      this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);
      this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);
      if (this.options.sendClientReports && global5.document) {
        global5.document.addEventListener("visibilitychange", function() {
          if (global5.document.visibilityState === "hidden") {
            _this._flushOutcomes();
          }
        });
      }
    }
    BaseTransport2.prototype.sendEvent = function(event) {
      return this._sendRequest(eventToSentryRequest(event, this._api), event);
    };
    BaseTransport2.prototype.sendSession = function(session) {
      return this._sendRequest(sessionToSentryRequest(session, this._api), session);
    };
    BaseTransport2.prototype.close = function(timeout) {
      return this._buffer.drain(timeout);
    };
    BaseTransport2.prototype.recordLostEvent = function(reason, category) {
      var _a;
      if (!this.options.sendClientReports) {
        return;
      }
      var key = requestTypeToCategory(category) + ":" + reason;
      IS_DEBUG_BUILD4 && logger.log("Adding outcome: " + key);
      this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;
    };
    BaseTransport2.prototype._flushOutcomes = function() {
      if (!this.options.sendClientReports) {
        return;
      }
      var outcomes = this._outcomes;
      this._outcomes = {};
      if (!Object.keys(outcomes).length) {
        IS_DEBUG_BUILD4 && logger.log("No outcomes to flush");
        return;
      }
      IS_DEBUG_BUILD4 && logger.log("Flushing outcomes:\n" + JSON.stringify(outcomes, null, 2));
      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);
      var discardedEvents = Object.keys(outcomes).map(function(key) {
        var _a = __read(key.split(":"), 2), category = _a[0], reason = _a[1];
        return {
          reason,
          category,
          quantity: outcomes[key]
        };
      });
      var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));
      try {
        sendReport(url, serializeEnvelope(envelope));
      } catch (e) {
        IS_DEBUG_BUILD4 && logger.error(e);
      }
    };
    BaseTransport2.prototype._handleResponse = function(_a) {
      var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;
      var status = eventStatusFromHttpCode(response.status);
      this._rateLimits = updateRateLimits(this._rateLimits, headers);
      if (this._isRateLimited(requestType)) {
        IS_DEBUG_BUILD4 && logger.warn("Too many " + requestType + " requests, backing off until: " + this._disabledUntil(requestType));
      }
      if (status === "success") {
        resolve({ status });
        return;
      }
      reject(response);
    };
    BaseTransport2.prototype._disabledUntil = function(requestType) {
      var category = requestTypeToCategory(requestType);
      return new Date(disabledUntil(this._rateLimits, category));
    };
    BaseTransport2.prototype._isRateLimited = function(requestType) {
      var category = requestTypeToCategory(requestType);
      return isRateLimited(this._rateLimits, category);
    };
    return BaseTransport2;
  }();

  // ../node_modules/@sentry/browser/esm/transports/fetch.js
  var FetchTransport = function(_super) {
    __extends(FetchTransport2, _super);
    function FetchTransport2(options, fetchImpl) {
      if (fetchImpl === void 0) {
        fetchImpl = getNativeFetchImplementation();
      }
      var _this = _super.call(this, options) || this;
      _this._fetch = fetchImpl;
      return _this;
    }
    FetchTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
      var _this = this;
      if (this._isRateLimited(sentryRequest.type)) {
        this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
        return Promise.reject({
          event: originalPayload,
          type: sentryRequest.type,
          reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
          status: 429
        });
      }
      var options = {
        body: sentryRequest.body,
        method: "POST",
        referrerPolicy: supportsReferrerPolicy() ? "origin" : ""
      };
      if (this.options.fetchParameters !== void 0) {
        Object.assign(options, this.options.fetchParameters);
      }
      if (this.options.headers !== void 0) {
        options.headers = this.options.headers;
      }
      return this._buffer.add(function() {
        return new SyncPromise(function(resolve, reject) {
          void _this._fetch(sentryRequest.url, options).then(function(response) {
            var headers = {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            };
            _this._handleResponse({
              requestType: sentryRequest.type,
              response,
              headers,
              resolve,
              reject
            });
          }).catch(reject);
        });
      }).then(void 0, function(reason) {
        if (reason instanceof SentryError) {
          _this.recordLostEvent("queue_overflow", sentryRequest.type);
        } else {
          _this.recordLostEvent("network_error", sentryRequest.type);
        }
        throw reason;
      });
    };
    return FetchTransport2;
  }(BaseTransport);

  // ../node_modules/@sentry/browser/esm/transports/xhr.js
  var XHRTransport = function(_super) {
    __extends(XHRTransport2, _super);
    function XHRTransport2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    XHRTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
      var _this = this;
      if (this._isRateLimited(sentryRequest.type)) {
        this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
        return Promise.reject({
          event: originalPayload,
          type: sentryRequest.type,
          reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
          status: 429
        });
      }
      return this._buffer.add(function() {
        return new SyncPromise(function(resolve, reject) {
          var request = new XMLHttpRequest();
          request.onreadystatechange = function() {
            if (request.readyState === 4) {
              var headers = {
                "x-sentry-rate-limits": request.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": request.getResponseHeader("Retry-After")
              };
              _this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });
            }
          };
          request.open("POST", sentryRequest.url);
          for (var header in _this.options.headers) {
            if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {
              request.setRequestHeader(header, _this.options.headers[header]);
            }
          }
          request.send(sentryRequest.body);
        });
      }).then(void 0, function(reason) {
        if (reason instanceof SentryError) {
          _this.recordLostEvent("queue_overflow", sentryRequest.type);
        } else {
          _this.recordLostEvent("network_error", sentryRequest.type);
        }
        throw reason;
      });
    };
    return XHRTransport2;
  }(BaseTransport);

  // ../node_modules/@sentry/browser/esm/transports/new-fetch.js
  function makeNewFetchTransport(options, nativeFetch) {
    if (nativeFetch === void 0) {
      nativeFetch = getNativeFetchImplementation();
    }
    function makeRequest(request) {
      var requestOptions = __assign({ body: request.body, method: "POST", referrerPolicy: "origin" }, options.requestOptions);
      return nativeFetch(options.url, requestOptions).then(function(response) {
        return response.text().then(function(body) {
          return {
            body,
            headers: {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            },
            reason: response.statusText,
            statusCode: response.status
          };
        });
      });
    }
    return createTransport({ bufferSize: options.bufferSize }, makeRequest);
  }

  // ../node_modules/@sentry/browser/esm/transports/new-xhr.js
  var XHR_READYSTATE_DONE = 4;
  function makeNewXHRTransport(options) {
    function makeRequest(request) {
      return new SyncPromise(function(resolve, _reject) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === XHR_READYSTATE_DONE) {
            var response = {
              body: xhr.response,
              headers: {
                "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": xhr.getResponseHeader("Retry-After")
              },
              reason: xhr.statusText,
              statusCode: xhr.status
            };
            resolve(response);
          }
        };
        xhr.open("POST", options.url);
        for (var header in options.headers) {
          if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
            xhr.setRequestHeader(header, options.headers[header]);
          }
        }
        xhr.send(request.body);
      });
    }
    return createTransport({ bufferSize: options.bufferSize }, makeRequest);
  }

  // ../node_modules/@sentry/browser/esm/backend.js
  var BrowserBackend = function(_super) {
    __extends(BrowserBackend2, _super);
    function BrowserBackend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserBackend2.prototype.eventFromException = function(exception, hint) {
      return eventFromException(exception, hint, this._options.attachStacktrace);
    };
    BrowserBackend2.prototype.eventFromMessage = function(message, level, hint) {
      if (level === void 0) {
        level = Severity.Info;
      }
      return eventFromMessage(message, level, hint, this._options.attachStacktrace);
    };
    BrowserBackend2.prototype._setupTransport = function() {
      if (!this._options.dsn) {
        return _super.prototype._setupTransport.call(this);
      }
      var transportOptions = __assign(__assign({}, this._options.transportOptions), { dsn: this._options.dsn, tunnel: this._options.tunnel, sendClientReports: this._options.sendClientReports, _metadata: this._options._metadata });
      var api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
      var url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);
      if (this._options.transport) {
        return new this._options.transport(transportOptions);
      }
      if (supportsFetch()) {
        var requestOptions = __assign({}, transportOptions.fetchParameters);
        this._newTransport = makeNewFetchTransport({ requestOptions, url });
        return new FetchTransport(transportOptions);
      }
      this._newTransport = makeNewXHRTransport({
        url,
        headers: transportOptions.headers
      });
      return new XHRTransport(transportOptions);
    };
    return BrowserBackend2;
  }(BaseBackend);

  // ../node_modules/@sentry/browser/esm/helpers.js
  var global6 = getGlobalObject();
  var ignoreOnError = 0;
  function shouldIgnoreOnError() {
    return ignoreOnError > 0;
  }
  function ignoreNextOnError() {
    ignoreOnError += 1;
    setTimeout(function() {
      ignoreOnError -= 1;
    });
  }
  function wrap(fn, options, before) {
    if (options === void 0) {
      options = {};
    }
    if (typeof fn !== "function") {
      return fn;
    }
    try {
      var wrapper = fn.__sentry_wrapped__;
      if (wrapper) {
        return wrapper;
      }
      if (getOriginalFunction(fn)) {
        return fn;
      }
    } catch (e) {
      return fn;
    }
    var sentryWrapped = function() {
      var args = Array.prototype.slice.call(arguments);
      try {
        if (before && typeof before === "function") {
          before.apply(this, arguments);
        }
        var wrappedArguments = args.map(function(arg) {
          return wrap(arg, options);
        });
        return fn.apply(this, wrappedArguments);
      } catch (ex) {
        ignoreNextOnError();
        withScope(function(scope) {
          scope.addEventProcessor(function(event) {
            if (options.mechanism) {
              addExceptionTypeValue(event, void 0, void 0);
              addExceptionMechanism(event, options.mechanism);
            }
            event.extra = __assign(__assign({}, event.extra), { arguments: args });
            return event;
          });
          captureException(ex);
        });
        throw ex;
      }
    };
    try {
      for (var property in fn) {
        if (Object.prototype.hasOwnProperty.call(fn, property)) {
          sentryWrapped[property] = fn[property];
        }
      }
    } catch (_oO) {
    }
    markFunctionWrapped(sentryWrapped, fn);
    addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
    try {
      var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
      if (descriptor.configurable) {
        Object.defineProperty(sentryWrapped, "name", {
          get: function() {
            return fn.name;
          }
        });
      }
    } catch (_oO) {
    }
    return sentryWrapped;
  }
  function injectReportDialog(options) {
    if (options === void 0) {
      options = {};
    }
    if (!global6.document) {
      return;
    }
    if (!options.eventId) {
      IS_DEBUG_BUILD4 && logger.error("Missing eventId option in showReportDialog call");
      return;
    }
    if (!options.dsn) {
      IS_DEBUG_BUILD4 && logger.error("Missing dsn option in showReportDialog call");
      return;
    }
    var script = global6.document.createElement("script");
    script.async = true;
    script.src = getReportDialogEndpoint(options.dsn, options);
    if (options.onLoad) {
      script.onload = options.onLoad;
    }
    var injectionPoint = global6.document.head || global6.document.body;
    if (injectionPoint) {
      injectionPoint.appendChild(script);
    }
  }

  // ../node_modules/@sentry/browser/esm/integrations/globalhandlers.js
  var GlobalHandlers = function() {
    function GlobalHandlers2(options) {
      this.name = GlobalHandlers2.id;
      this._installFunc = {
        onerror: _installGlobalOnErrorHandler,
        onunhandledrejection: _installGlobalOnUnhandledRejectionHandler
      };
      this._options = __assign({ onerror: true, onunhandledrejection: true }, options);
    }
    GlobalHandlers2.prototype.setupOnce = function() {
      Error.stackTraceLimit = 50;
      var options = this._options;
      for (var key in options) {
        var installFunc = this._installFunc[key];
        if (installFunc && options[key]) {
          globalHandlerLog(key);
          installFunc();
          this._installFunc[key] = void 0;
        }
      }
    };
    GlobalHandlers2.id = "GlobalHandlers";
    return GlobalHandlers2;
  }();
  function _installGlobalOnErrorHandler() {
    addInstrumentationHandler(
      "error",
      function(data) {
        var _a = __read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
        if (!hub.getIntegration(GlobalHandlers)) {
          return;
        }
        var msg = data.msg, url = data.url, line = data.line, column = data.column, error = data.error;
        if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
          return;
        }
        var event = error === void 0 && isString(msg) ? _eventFromIncompleteOnError(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(error || msg, void 0, attachStacktrace, false), url, line, column);
        event.level = Severity.Error;
        addMechanismAndCapture(hub, error, event, "onerror");
      }
    );
  }
  function _installGlobalOnUnhandledRejectionHandler() {
    addInstrumentationHandler(
      "unhandledrejection",
      function(e) {
        var _a = __read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
        if (!hub.getIntegration(GlobalHandlers)) {
          return;
        }
        var error = e;
        try {
          if ("reason" in e) {
            error = e.reason;
          } else if ("detail" in e && "reason" in e.detail) {
            error = e.detail.reason;
          }
        } catch (_oO) {
        }
        if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
          return true;
        }
        var event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(error, void 0, attachStacktrace, true);
        event.level = Severity.Error;
        addMechanismAndCapture(hub, error, event, "onunhandledrejection");
        return;
      }
    );
  }
  function _eventFromRejectionWithPrimitive(reason) {
    return {
      exception: {
        values: [
          {
            type: "UnhandledRejection",
            value: "Non-Error promise rejection captured with value: " + String(reason)
          }
        ]
      }
    };
  }
  function _eventFromIncompleteOnError(msg, url, line, column) {
    var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    var message = isErrorEvent(msg) ? msg.message : msg;
    var name = "Error";
    var groups = message.match(ERROR_TYPES_RE);
    if (groups) {
      name = groups[1];
      message = groups[2];
    }
    var event = {
      exception: {
        values: [
          {
            type: name,
            value: message
          }
        ]
      }
    };
    return _enhanceEventWithInitialFrame(event, url, line, column);
  }
  function _enhanceEventWithInitialFrame(event, url, line, column) {
    var e = event.exception = event.exception || {};
    var ev = e.values = e.values || [];
    var ev0 = ev[0] = ev[0] || {};
    var ev0s = ev0.stacktrace = ev0.stacktrace || {};
    var ev0sf = ev0s.frames = ev0s.frames || [];
    var colno = isNaN(parseInt(column, 10)) ? void 0 : column;
    var lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
    var filename = isString(url) && url.length > 0 ? url : getLocationHref();
    if (ev0sf.length === 0) {
      ev0sf.push({
        colno,
        filename,
        function: "?",
        in_app: true,
        lineno
      });
    }
    return event;
  }
  function globalHandlerLog(type) {
    IS_DEBUG_BUILD4 && logger.log("Global Handler attached: " + type);
  }
  function addMechanismAndCapture(hub, error, event, type) {
    addExceptionMechanism(event, {
      handled: false,
      type
    });
    hub.captureEvent(event, {
      originalException: error
    });
  }
  function getHubAndAttachStacktrace() {
    var hub = getCurrentHub();
    var client = hub.getClient();
    var attachStacktrace = client && client.getOptions().attachStacktrace;
    return [hub, attachStacktrace];
  }

  // ../node_modules/@sentry/browser/esm/integrations/trycatch.js
  var DEFAULT_EVENT_TARGET = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload"
  ];
  var TryCatch = function() {
    function TryCatch2(options) {
      this.name = TryCatch2.id;
      this._options = __assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
    }
    TryCatch2.prototype.setupOnce = function() {
      var global12 = getGlobalObject();
      if (this._options.setTimeout) {
        fill(global12, "setTimeout", _wrapTimeFunction);
      }
      if (this._options.setInterval) {
        fill(global12, "setInterval", _wrapTimeFunction);
      }
      if (this._options.requestAnimationFrame) {
        fill(global12, "requestAnimationFrame", _wrapRAF);
      }
      if (this._options.XMLHttpRequest && "XMLHttpRequest" in global12) {
        fill(XMLHttpRequest.prototype, "send", _wrapXHR);
      }
      var eventTargetOption = this._options.eventTarget;
      if (eventTargetOption) {
        var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
        eventTarget.forEach(_wrapEventTarget);
      }
    };
    TryCatch2.id = "TryCatch";
    return TryCatch2;
  }();
  function _wrapTimeFunction(original) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var originalCallback = args[0];
      args[0] = wrap(originalCallback, {
        mechanism: {
          data: { function: getFunctionName(original) },
          handled: true,
          type: "instrument"
        }
      });
      return original.apply(this, args);
    };
  }
  function _wrapRAF(original) {
    return function(callback) {
      return original.apply(this, [
        wrap(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: getFunctionName(original)
            },
            handled: true,
            type: "instrument"
          }
        })
      ]);
    };
  }
  function _wrapXHR(originalSend) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var xhr = this;
      var xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
      xmlHttpRequestProps.forEach(function(prop) {
        if (prop in xhr && typeof xhr[prop] === "function") {
          fill(xhr, prop, function(original) {
            var wrapOptions = {
              mechanism: {
                data: {
                  function: prop,
                  handler: getFunctionName(original)
                },
                handled: true,
                type: "instrument"
              }
            };
            var originalFunction = getOriginalFunction(original);
            if (originalFunction) {
              wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
            }
            return wrap(original, wrapOptions);
          });
        }
      });
      return originalSend.apply(this, args);
    };
  }
  function _wrapEventTarget(target) {
    var global12 = getGlobalObject();
    var proto = global12[target] && global12[target].prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(original) {
      return function(eventName, fn, options) {
        try {
          if (typeof fn.handleEvent === "function") {
            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {
              mechanism: {
                data: {
                  function: "handleEvent",
                  handler: getFunctionName(fn),
                  target
                },
                handled: true,
                type: "instrument"
              }
            });
          }
        } catch (err) {
        }
        return original.apply(this, [
          eventName,
          wrap(fn, {
            mechanism: {
              data: {
                function: "addEventListener",
                handler: getFunctionName(fn),
                target
              },
              handled: true,
              type: "instrument"
            }
          }),
          options
        ]);
      };
    });
    fill(proto, "removeEventListener", function(originalRemoveEventListener) {
      return function(eventName, fn, options) {
        var wrappedEventHandler = fn;
        try {
          var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
          if (originalEventHandler) {
            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
          }
        } catch (e) {
        }
        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
      };
    });
  }

  // ../node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
  var Breadcrumbs = function() {
    function Breadcrumbs2(options) {
      this.name = Breadcrumbs2.id;
      this._options = __assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
    }
    Breadcrumbs2.prototype.addSentryBreadcrumb = function(event) {
      if (!this._options.sentry) {
        return;
      }
      getCurrentHub().addBreadcrumb({
        category: "sentry." + (event.type === "transaction" ? "transaction" : "event"),
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      }, {
        event
      });
    };
    Breadcrumbs2.prototype.setupOnce = function() {
      if (this._options.console) {
        addInstrumentationHandler("console", _consoleBreadcrumb);
      }
      if (this._options.dom) {
        addInstrumentationHandler("dom", _domBreadcrumb(this._options.dom));
      }
      if (this._options.xhr) {
        addInstrumentationHandler("xhr", _xhrBreadcrumb);
      }
      if (this._options.fetch) {
        addInstrumentationHandler("fetch", _fetchBreadcrumb);
      }
      if (this._options.history) {
        addInstrumentationHandler("history", _historyBreadcrumb);
      }
    };
    Breadcrumbs2.id = "Breadcrumbs";
    return Breadcrumbs2;
  }();
  function _domBreadcrumb(dom) {
    function _innerDomBreadcrumb(handlerData) {
      var target;
      var keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
      if (typeof keyAttrs === "string") {
        keyAttrs = [keyAttrs];
      }
      try {
        target = handlerData.event.target ? htmlTreeAsString(handlerData.event.target, keyAttrs) : htmlTreeAsString(handlerData.event, keyAttrs);
      } catch (e) {
        target = "<unknown>";
      }
      if (target.length === 0) {
        return;
      }
      getCurrentHub().addBreadcrumb({
        category: "ui." + handlerData.name,
        message: target
      }, {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global
      });
    }
    return _innerDomBreadcrumb;
  }
  function _consoleBreadcrumb(handlerData) {
    var breadcrumb = {
      category: "console",
      data: {
        arguments: handlerData.args,
        logger: "console"
      },
      level: severityFromString(handlerData.level),
      message: safeJoin(handlerData.args, " ")
    };
    if (handlerData.level === "assert") {
      if (handlerData.args[0] === false) {
        breadcrumb.message = "Assertion failed: " + (safeJoin(handlerData.args.slice(1), " ") || "console.assert");
        breadcrumb.data.arguments = handlerData.args.slice(1);
      } else {
        return;
      }
    }
    getCurrentHub().addBreadcrumb(breadcrumb, {
      input: handlerData.args,
      level: handlerData.level
    });
  }
  function _xhrBreadcrumb(handlerData) {
    if (handlerData.endTimestamp) {
      if (handlerData.xhr.__sentry_own_request__) {
        return;
      }
      var _a = handlerData.xhr.__sentry_xhr__ || {}, method = _a.method, url = _a.url, status_code = _a.status_code, body = _a.body;
      getCurrentHub().addBreadcrumb({
        category: "xhr",
        data: {
          method,
          url,
          status_code
        },
        type: "http"
      }, {
        xhr: handlerData.xhr,
        input: body
      });
      return;
    }
  }
  function _fetchBreadcrumb(handlerData) {
    if (!handlerData.endTimestamp) {
      return;
    }
    if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
      return;
    }
    if (handlerData.error) {
      getCurrentHub().addBreadcrumb({
        category: "fetch",
        data: handlerData.fetchData,
        level: Severity.Error,
        type: "http"
      }, {
        data: handlerData.error,
        input: handlerData.args
      });
    } else {
      getCurrentHub().addBreadcrumb({
        category: "fetch",
        data: __assign(__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
        type: "http"
      }, {
        input: handlerData.args,
        response: handlerData.response
      });
    }
  }
  function _historyBreadcrumb(handlerData) {
    var global12 = getGlobalObject();
    var from = handlerData.from;
    var to = handlerData.to;
    var parsedLoc = parseUrl(global12.location.href);
    var parsedFrom = parseUrl(from);
    var parsedTo = parseUrl(to);
    if (!parsedFrom.path) {
      parsedFrom = parsedLoc;
    }
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
      to = parsedTo.relative;
    }
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
      from = parsedFrom.relative;
    }
    getCurrentHub().addBreadcrumb({
      category: "navigation",
      data: {
        from,
        to
      }
    });
  }

  // ../node_modules/@sentry/browser/esm/integrations/linkederrors.js
  var DEFAULT_KEY = "cause";
  var DEFAULT_LIMIT = 5;
  var LinkedErrors = function() {
    function LinkedErrors2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = LinkedErrors2.id;
      this._key = options.key || DEFAULT_KEY;
      this._limit = options.limit || DEFAULT_LIMIT;
    }
    LinkedErrors2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event, hint) {
        var self2 = getCurrentHub().getIntegration(LinkedErrors2);
        return self2 ? _handler(self2._key, self2._limit, event, hint) : event;
      });
    };
    LinkedErrors2.id = "LinkedErrors";
    return LinkedErrors2;
  }();
  function _handler(key, limit, event, hint) {
    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
      return event;
    }
    var linkedErrors = _walkErrorTree(limit, hint.originalException, key);
    event.exception.values = __spread(linkedErrors, event.exception.values);
    return event;
  }
  function _walkErrorTree(limit, error, key, stack) {
    if (stack === void 0) {
      stack = [];
    }
    if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
      return stack;
    }
    var exception = exceptionFromError(error[key]);
    return _walkErrorTree(limit, error[key], key, __spread([exception], stack));
  }

  // ../node_modules/@sentry/browser/esm/integrations/useragent.js
  var global7 = getGlobalObject();
  var UserAgent = function() {
    function UserAgent2() {
      this.name = UserAgent2.id;
    }
    UserAgent2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event) {
        if (getCurrentHub().getIntegration(UserAgent2)) {
          if (!global7.navigator && !global7.location && !global7.document) {
            return event;
          }
          var url = event.request && event.request.url || global7.location && global7.location.href;
          var referrer = (global7.document || {}).referrer;
          var userAgent = (global7.navigator || {}).userAgent;
          var headers = __assign(__assign(__assign({}, event.request && event.request.headers), referrer && { Referer: referrer }), userAgent && { "User-Agent": userAgent });
          var request = __assign(__assign({}, url && { url }), { headers });
          return __assign(__assign({}, event), { request });
        }
        return event;
      });
    };
    UserAgent2.id = "UserAgent";
    return UserAgent2;
  }();

  // ../node_modules/@sentry/browser/esm/integrations/dedupe.js
  var Dedupe = function() {
    function Dedupe2() {
      this.name = Dedupe2.id;
    }
    Dedupe2.prototype.setupOnce = function(addGlobalEventProcessor2, getCurrentHub2) {
      addGlobalEventProcessor2(function(currentEvent) {
        var self2 = getCurrentHub2().getIntegration(Dedupe2);
        if (self2) {
          try {
            if (_shouldDropEvent2(currentEvent, self2._previousEvent)) {
              IS_DEBUG_BUILD4 && logger.warn("Event dropped due to being a duplicate of previously captured event.");
              return null;
            }
          } catch (_oO) {
            return self2._previousEvent = currentEvent;
          }
          return self2._previousEvent = currentEvent;
        }
        return currentEvent;
      });
    };
    Dedupe2.id = "Dedupe";
    return Dedupe2;
  }();
  function _shouldDropEvent2(currentEvent, previousEvent) {
    if (!previousEvent) {
      return false;
    }
    if (_isSameMessageEvent(currentEvent, previousEvent)) {
      return true;
    }
    if (_isSameExceptionEvent(currentEvent, previousEvent)) {
      return true;
    }
    return false;
  }
  function _isSameMessageEvent(currentEvent, previousEvent) {
    var currentMessage = currentEvent.message;
    var previousMessage = previousEvent.message;
    if (!currentMessage && !previousMessage) {
      return false;
    }
    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
      return false;
    }
    if (currentMessage !== previousMessage) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameExceptionEvent(currentEvent, previousEvent) {
    var previousException = _getExceptionFromEvent(previousEvent);
    var currentException = _getExceptionFromEvent(currentEvent);
    if (!previousException || !currentException) {
      return false;
    }
    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameStacktrace(currentEvent, previousEvent) {
    var currentFrames = _getFramesFromEvent(currentEvent);
    var previousFrames = _getFramesFromEvent(previousEvent);
    if (!currentFrames && !previousFrames) {
      return true;
    }
    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
      return false;
    }
    currentFrames = currentFrames;
    previousFrames = previousFrames;
    if (previousFrames.length !== currentFrames.length) {
      return false;
    }
    for (var i = 0; i < previousFrames.length; i++) {
      var frameA = previousFrames[i];
      var frameB = currentFrames[i];
      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
        return false;
      }
    }
    return true;
  }
  function _isSameFingerprint(currentEvent, previousEvent) {
    var currentFingerprint = currentEvent.fingerprint;
    var previousFingerprint = previousEvent.fingerprint;
    if (!currentFingerprint && !previousFingerprint) {
      return true;
    }
    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
      return false;
    }
    currentFingerprint = currentFingerprint;
    previousFingerprint = previousFingerprint;
    try {
      return !!(currentFingerprint.join("") === previousFingerprint.join(""));
    } catch (_oO) {
      return false;
    }
  }
  function _getExceptionFromEvent(event) {
    return event.exception && event.exception.values && event.exception.values[0];
  }
  function _getFramesFromEvent(event) {
    var exception = event.exception;
    if (exception) {
      try {
        return exception.values[0].stacktrace.frames;
      } catch (_oO) {
        return void 0;
      }
    } else if (event.stacktrace) {
      return event.stacktrace.frames;
    }
    return void 0;
  }

  // ../node_modules/@sentry/browser/esm/client.js
  var BrowserClient = function(_super) {
    __extends(BrowserClient2, _super);
    function BrowserClient2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = this;
      options._metadata = options._metadata || {};
      options._metadata.sdk = options._metadata.sdk || {
        name: "sentry.javascript.browser",
        packages: [
          {
            name: "npm:@sentry/browser",
            version: SDK_VERSION
          }
        ],
        version: SDK_VERSION
      };
      _this = _super.call(this, BrowserBackend, options) || this;
      return _this;
    }
    BrowserClient2.prototype.showReportDialog = function(options) {
      if (options === void 0) {
        options = {};
      }
      var document2 = getGlobalObject().document;
      if (!document2) {
        return;
      }
      if (!this._isEnabled()) {
        IS_DEBUG_BUILD4 && logger.error("Trying to call showReportDialog with Sentry Client disabled");
        return;
      }
      injectReportDialog(__assign(__assign({}, options), { dsn: options.dsn || this.getDsn() }));
    };
    BrowserClient2.prototype._prepareEvent = function(event, scope, hint) {
      event.platform = event.platform || "javascript";
      return _super.prototype._prepareEvent.call(this, event, scope, hint);
    };
    BrowserClient2.prototype._sendEvent = function(event) {
      var integration = this.getIntegration(Breadcrumbs);
      if (integration) {
        integration.addSentryBreadcrumb(event);
      }
      _super.prototype._sendEvent.call(this, event);
    };
    return BrowserClient2;
  }(BaseClient);

  // ../node_modules/@sentry/browser/esm/sdk.js
  var defaultIntegrations = [
    new integrations_exports.InboundFilters(),
    new integrations_exports.FunctionToString(),
    new TryCatch(),
    new Breadcrumbs(),
    new GlobalHandlers(),
    new LinkedErrors(),
    new Dedupe(),
    new UserAgent()
  ];
  function init(options) {
    if (options === void 0) {
      options = {};
    }
    if (options.defaultIntegrations === void 0) {
      options.defaultIntegrations = defaultIntegrations;
    }
    if (options.release === void 0) {
      var window_1 = getGlobalObject();
      if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
        options.release = window_1.SENTRY_RELEASE.id;
      }
    }
    if (options.autoSessionTracking === void 0) {
      options.autoSessionTracking = true;
    }
    if (options.sendClientReports === void 0) {
      options.sendClientReports = true;
    }
    initAndBind(BrowserClient, options);
    if (options.autoSessionTracking) {
      startSessionTracking();
    }
  }
  function close(timeout) {
    var client = getCurrentHub().getClient();
    if (client) {
      return client.close(timeout);
    }
    IS_DEBUG_BUILD4 && logger.warn("Cannot flush events and disable SDK. No client defined.");
    return resolvedSyncPromise(false);
  }
  function startSessionOnHub(hub) {
    hub.startSession({ ignoreDuration: true });
    hub.captureSession();
  }
  function startSessionTracking() {
    var window2 = getGlobalObject();
    var document2 = window2.document;
    if (typeof document2 === "undefined") {
      IS_DEBUG_BUILD4 && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
      return;
    }
    var hub = getCurrentHub();
    if (!hub.captureSession) {
      return;
    }
    startSessionOnHub(hub);
    addInstrumentationHandler("history", function(_a) {
      var from = _a.from, to = _a.to;
      if (!(from === void 0 || from === to)) {
        startSessionOnHub(getCurrentHub());
      }
    });
  }

  // ../node_modules/@sentry/tracing/node_modules/tslib/modules/index.js
  var import_tslib39 = __toESM(require_tslib6(), 1);
  var {
    __extends: __extends6,
    __assign: __assign6,
    __rest: __rest6,
    __decorate: __decorate6,
    __param: __param6,
    __metadata: __metadata6,
    __awaiter: __awaiter6,
    __generator: __generator6,
    __exportStar: __exportStar6,
    __createBinding: __createBinding6,
    __values: __values6,
    __read: __read6,
    __spread: __spread6,
    __spreadArrays: __spreadArrays6,
    __await: __await6,
    __asyncGenerator: __asyncGenerator6,
    __asyncDelegator: __asyncDelegator6,
    __asyncValues: __asyncValues6,
    __makeTemplateObject: __makeTemplateObject6,
    __importStar: __importStar6,
    __importDefault: __importDefault6,
    __classPrivateFieldGet: __classPrivateFieldGet6,
    __classPrivateFieldSet: __classPrivateFieldSet6
  } = import_tslib39.default;

  // ../node_modules/@sentry/tracing/esm/flags.js
  var IS_DEBUG_BUILD5 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/tracing/esm/utils.js
  function hasTracingEnabled(maybeOptions) {
    var client = getCurrentHub().getClient();
    var options = maybeOptions || client && client.getOptions();
    return !!options && ("tracesSampleRate" in options || "tracesSampler" in options);
  }
  function getActiveTransaction(maybeHub) {
    var hub = maybeHub || getCurrentHub();
    var scope = hub.getScope();
    return scope && scope.getTransaction();
  }
  function msToSec(time) {
    return time / 1e3;
  }
  function secToMs(time) {
    return time * 1e3;
  }

  // ../node_modules/@sentry/tracing/esm/errors.js
  function registerErrorInstrumentation() {
    addInstrumentationHandler("error", errorCallback);
    addInstrumentationHandler("unhandledrejection", errorCallback);
  }
  function errorCallback() {
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      var status_1 = "internal_error";
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Transaction: " + status_1 + " -> Global error occured");
      activeTransaction.setStatus(status_1);
    }
  }

  // ../node_modules/@sentry/tracing/esm/constants.js
  var FINISH_REASON_TAG = "finishReason";
  var IDLE_TRANSACTION_FINISH_REASONS = ["heartbeatFailed", "idleTimeout", "documentHidden"];

  // ../node_modules/@sentry/tracing/esm/span.js
  var SpanRecorder = function() {
    function SpanRecorder2(maxlen) {
      if (maxlen === void 0) {
        maxlen = 1e3;
      }
      this.spans = [];
      this._maxlen = maxlen;
    }
    SpanRecorder2.prototype.add = function(span) {
      if (this.spans.length > this._maxlen) {
        span.spanRecorder = void 0;
      } else {
        this.spans.push(span);
      }
    };
    return SpanRecorder2;
  }();
  var Span = function() {
    function Span2(spanContext) {
      this.traceId = uuid4();
      this.spanId = uuid4().substring(16);
      this.startTimestamp = timestampWithMs();
      this.tags = {};
      this.data = {};
      if (!spanContext) {
        return this;
      }
      if (spanContext.traceId) {
        this.traceId = spanContext.traceId;
      }
      if (spanContext.spanId) {
        this.spanId = spanContext.spanId;
      }
      if (spanContext.parentSpanId) {
        this.parentSpanId = spanContext.parentSpanId;
      }
      if ("sampled" in spanContext) {
        this.sampled = spanContext.sampled;
      }
      if (spanContext.op) {
        this.op = spanContext.op;
      }
      if (spanContext.description) {
        this.description = spanContext.description;
      }
      if (spanContext.data) {
        this.data = spanContext.data;
      }
      if (spanContext.tags) {
        this.tags = spanContext.tags;
      }
      if (spanContext.status) {
        this.status = spanContext.status;
      }
      if (spanContext.startTimestamp) {
        this.startTimestamp = spanContext.startTimestamp;
      }
      if (spanContext.endTimestamp) {
        this.endTimestamp = spanContext.endTimestamp;
      }
    }
    Span2.prototype.child = function(spanContext) {
      return this.startChild(spanContext);
    };
    Span2.prototype.startChild = function(spanContext) {
      var childSpan = new Span2(__assign6(__assign6({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
      childSpan.spanRecorder = this.spanRecorder;
      if (childSpan.spanRecorder) {
        childSpan.spanRecorder.add(childSpan);
      }
      childSpan.transaction = this.transaction;
      return childSpan;
    };
    Span2.prototype.setTag = function(key, value) {
      var _a;
      this.tags = __assign6(__assign6({}, this.tags), (_a = {}, _a[key] = value, _a));
      return this;
    };
    Span2.prototype.setData = function(key, value) {
      var _a;
      this.data = __assign6(__assign6({}, this.data), (_a = {}, _a[key] = value, _a));
      return this;
    };
    Span2.prototype.setStatus = function(value) {
      this.status = value;
      return this;
    };
    Span2.prototype.setHttpStatus = function(httpStatus) {
      this.setTag("http.status_code", String(httpStatus));
      var spanStatus = spanStatusfromHttpCode(httpStatus);
      if (spanStatus !== "unknown_error") {
        this.setStatus(spanStatus);
      }
      return this;
    };
    Span2.prototype.isSuccess = function() {
      return this.status === "ok";
    };
    Span2.prototype.finish = function(endTimestamp) {
      this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
    };
    Span2.prototype.toTraceparent = function() {
      var sampledString = "";
      if (this.sampled !== void 0) {
        sampledString = this.sampled ? "-1" : "-0";
      }
      return this.traceId + "-" + this.spanId + sampledString;
    };
    Span2.prototype.toContext = function() {
      return dropUndefinedKeys({
        data: this.data,
        description: this.description,
        endTimestamp: this.endTimestamp,
        op: this.op,
        parentSpanId: this.parentSpanId,
        sampled: this.sampled,
        spanId: this.spanId,
        startTimestamp: this.startTimestamp,
        status: this.status,
        tags: this.tags,
        traceId: this.traceId
      });
    };
    Span2.prototype.updateWithContext = function(spanContext) {
      var _a, _b, _c, _d, _e;
      this.data = (_a = spanContext.data, _a !== null && _a !== void 0 ? _a : {});
      this.description = spanContext.description;
      this.endTimestamp = spanContext.endTimestamp;
      this.op = spanContext.op;
      this.parentSpanId = spanContext.parentSpanId;
      this.sampled = spanContext.sampled;
      this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
      this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
      this.status = spanContext.status;
      this.tags = (_d = spanContext.tags, _d !== null && _d !== void 0 ? _d : {});
      this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
      return this;
    };
    Span2.prototype.getTraceContext = function() {
      return dropUndefinedKeys({
        data: Object.keys(this.data).length > 0 ? this.data : void 0,
        description: this.description,
        op: this.op,
        parent_span_id: this.parentSpanId,
        span_id: this.spanId,
        status: this.status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        trace_id: this.traceId
      });
    };
    Span2.prototype.toJSON = function() {
      return dropUndefinedKeys({
        data: Object.keys(this.data).length > 0 ? this.data : void 0,
        description: this.description,
        op: this.op,
        parent_span_id: this.parentSpanId,
        span_id: this.spanId,
        start_timestamp: this.startTimestamp,
        status: this.status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        timestamp: this.endTimestamp,
        trace_id: this.traceId
      });
    };
    return Span2;
  }();
  function spanStatusfromHttpCode(httpStatus) {
    if (httpStatus < 400 && httpStatus >= 100) {
      return "ok";
    }
    if (httpStatus >= 400 && httpStatus < 500) {
      switch (httpStatus) {
        case 401:
          return "unauthenticated";
        case 403:
          return "permission_denied";
        case 404:
          return "not_found";
        case 409:
          return "already_exists";
        case 413:
          return "failed_precondition";
        case 429:
          return "resource_exhausted";
        default:
          return "invalid_argument";
      }
    }
    if (httpStatus >= 500 && httpStatus < 600) {
      switch (httpStatus) {
        case 501:
          return "unimplemented";
        case 503:
          return "unavailable";
        case 504:
          return "deadline_exceeded";
        default:
          return "internal_error";
      }
    }
    return "unknown_error";
  }

  // ../node_modules/@sentry/tracing/esm/transaction.js
  var Transaction = function(_super) {
    __extends6(Transaction2, _super);
    function Transaction2(transactionContext, hub) {
      var _this = _super.call(this, transactionContext) || this;
      _this._measurements = {};
      _this._hub = getCurrentHub();
      if (isInstanceOf(hub, Hub)) {
        _this._hub = hub;
      }
      _this.name = transactionContext.name || "";
      _this.metadata = transactionContext.metadata || {};
      _this._trimEnd = transactionContext.trimEnd;
      _this.transaction = _this;
      return _this;
    }
    Transaction2.prototype.setName = function(name) {
      this.name = name;
    };
    Transaction2.prototype.initSpanRecorder = function(maxlen) {
      if (maxlen === void 0) {
        maxlen = 1e3;
      }
      if (!this.spanRecorder) {
        this.spanRecorder = new SpanRecorder(maxlen);
      }
      this.spanRecorder.add(this);
    };
    Transaction2.prototype.setMeasurements = function(measurements) {
      this._measurements = __assign6({}, measurements);
    };
    Transaction2.prototype.setMetadata = function(newMetadata) {
      this.metadata = __assign6(__assign6({}, this.metadata), newMetadata);
    };
    Transaction2.prototype.finish = function(endTimestamp) {
      var _this = this;
      if (this.endTimestamp !== void 0) {
        return void 0;
      }
      if (!this.name) {
        IS_DEBUG_BUILD5 && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
        this.name = "<unlabeled transaction>";
      }
      _super.prototype.finish.call(this, endTimestamp);
      if (this.sampled !== true) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
        var client = this._hub.getClient();
        var transport = client && client.getTransport && client.getTransport();
        if (transport && transport.recordLostEvent) {
          transport.recordLostEvent("sample_rate", "transaction");
        }
        return void 0;
      }
      var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function(s) {
        return s !== _this && s.endTimestamp;
      }) : [];
      if (this._trimEnd && finishedSpans.length > 0) {
        this.endTimestamp = finishedSpans.reduce(function(prev, current) {
          if (prev.endTimestamp && current.endTimestamp) {
            return prev.endTimestamp > current.endTimestamp ? prev : current;
          }
          return prev;
        }).endTimestamp;
      }
      var transaction = {
        contexts: {
          trace: this.getTraceContext()
        },
        spans: finishedSpans,
        start_timestamp: this.startTimestamp,
        tags: this.tags,
        timestamp: this.endTimestamp,
        transaction: this.name,
        type: "transaction",
        sdkProcessingMetadata: this.metadata
      };
      var hasMeasurements = Object.keys(this._measurements).length > 0;
      if (hasMeasurements) {
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
        transaction.measurements = this._measurements;
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
      return this._hub.captureEvent(transaction);
    };
    Transaction2.prototype.toContext = function() {
      var spanContext = _super.prototype.toContext.call(this);
      return dropUndefinedKeys(__assign6(__assign6({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
    };
    Transaction2.prototype.updateWithContext = function(transactionContext) {
      var _a;
      _super.prototype.updateWithContext.call(this, transactionContext);
      this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : "");
      this._trimEnd = transactionContext.trimEnd;
      return this;
    };
    return Transaction2;
  }(Span);

  // ../node_modules/@sentry/tracing/esm/idletransaction.js
  var DEFAULT_IDLE_TIMEOUT = 1e3;
  var HEARTBEAT_INTERVAL = 5e3;
  var IdleTransactionSpanRecorder = function(_super) {
    __extends6(IdleTransactionSpanRecorder2, _super);
    function IdleTransactionSpanRecorder2(_pushActivity, _popActivity, transactionSpanId, maxlen) {
      if (transactionSpanId === void 0) {
        transactionSpanId = "";
      }
      var _this = _super.call(this, maxlen) || this;
      _this._pushActivity = _pushActivity;
      _this._popActivity = _popActivity;
      _this.transactionSpanId = transactionSpanId;
      return _this;
    }
    IdleTransactionSpanRecorder2.prototype.add = function(span) {
      var _this = this;
      if (span.spanId !== this.transactionSpanId) {
        span.finish = function(endTimestamp) {
          span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
          _this._popActivity(span.spanId);
        };
        if (span.endTimestamp === void 0) {
          this._pushActivity(span.spanId);
        }
      }
      _super.prototype.add.call(this, span);
    };
    return IdleTransactionSpanRecorder2;
  }(SpanRecorder);
  var IdleTransaction = function(_super) {
    __extends6(IdleTransaction2, _super);
    function IdleTransaction2(transactionContext, _idleHub, _idleTimeout, _onScope) {
      if (_idleTimeout === void 0) {
        _idleTimeout = DEFAULT_IDLE_TIMEOUT;
      }
      if (_onScope === void 0) {
        _onScope = false;
      }
      var _this = _super.call(this, transactionContext, _idleHub) || this;
      _this._idleHub = _idleHub;
      _this._idleTimeout = _idleTimeout;
      _this._onScope = _onScope;
      _this.activities = {};
      _this._heartbeatCounter = 0;
      _this._finished = false;
      _this._beforeFinishCallbacks = [];
      if (_idleHub && _onScope) {
        clearActiveTransaction(_idleHub);
        IS_DEBUG_BUILD5 && logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
        _idleHub.configureScope(function(scope) {
          return scope.setSpan(_this);
        });
      }
      _this._initTimeout = setTimeout(function() {
        if (!_this._finished) {
          _this.finish();
        }
      }, _this._idleTimeout);
      return _this;
    }
    IdleTransaction2.prototype.finish = function(endTimestamp) {
      var e_1, _a;
      var _this = this;
      if (endTimestamp === void 0) {
        endTimestamp = timestampWithMs();
      }
      this._finished = true;
      this.activities = {};
      if (this.spanRecorder) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
        try {
          for (var _b = __values6(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
            var callback = _c.value;
            callback(this, endTimestamp);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        this.spanRecorder.spans = this.spanRecorder.spans.filter(function(span) {
          if (span.spanId === _this.spanId) {
            return true;
          }
          if (!span.endTimestamp) {
            span.endTimestamp = endTimestamp;
            span.setStatus("cancelled");
            IS_DEBUG_BUILD5 && logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
          }
          var keepSpan = span.startTimestamp < endTimestamp;
          if (!keepSpan) {
            IS_DEBUG_BUILD5 && logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
          }
          return keepSpan;
        });
        IS_DEBUG_BUILD5 && logger.log("[Tracing] flushing IdleTransaction");
      } else {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] No active IdleTransaction");
      }
      if (this._onScope) {
        clearActiveTransaction(this._idleHub);
      }
      return _super.prototype.finish.call(this, endTimestamp);
    };
    IdleTransaction2.prototype.registerBeforeFinishCallback = function(callback) {
      this._beforeFinishCallbacks.push(callback);
    };
    IdleTransaction2.prototype.initSpanRecorder = function(maxlen) {
      var _this = this;
      if (!this.spanRecorder) {
        var pushActivity = function(id) {
          if (_this._finished) {
            return;
          }
          _this._pushActivity(id);
        };
        var popActivity = function(id) {
          if (_this._finished) {
            return;
          }
          _this._popActivity(id);
        };
        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
        IS_DEBUG_BUILD5 && logger.log("Starting heartbeat");
        this._pingHeartbeat();
      }
      this.spanRecorder.add(this);
    };
    IdleTransaction2.prototype._pushActivity = function(spanId) {
      if (this._initTimeout) {
        clearTimeout(this._initTimeout);
        this._initTimeout = void 0;
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] pushActivity: " + spanId);
      this.activities[spanId] = true;
      IS_DEBUG_BUILD5 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    };
    IdleTransaction2.prototype._popActivity = function(spanId) {
      var _this = this;
      if (this.activities[spanId]) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] popActivity " + spanId);
        delete this.activities[spanId];
        IS_DEBUG_BUILD5 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      if (Object.keys(this.activities).length === 0) {
        var timeout = this._idleTimeout;
        var end_1 = timestampWithMs() + timeout / 1e3;
        setTimeout(function() {
          if (!_this._finished) {
            _this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);
            _this.finish(end_1);
          }
        }, timeout);
      }
    };
    IdleTransaction2.prototype._beat = function() {
      if (this._finished) {
        return;
      }
      var heartbeatString = Object.keys(this.activities).join("");
      if (heartbeatString === this._prevHeartbeatString) {
        this._heartbeatCounter += 1;
      } else {
        this._heartbeatCounter = 1;
      }
      this._prevHeartbeatString = heartbeatString;
      if (this._heartbeatCounter >= 3) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
        this.setStatus("deadline_exceeded");
        this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);
        this.finish();
      } else {
        this._pingHeartbeat();
      }
    };
    IdleTransaction2.prototype._pingHeartbeat = function() {
      var _this = this;
      IS_DEBUG_BUILD5 && logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
      setTimeout(function() {
        _this._beat();
      }, HEARTBEAT_INTERVAL);
    };
    return IdleTransaction2;
  }(Transaction);
  function clearActiveTransaction(hub) {
    if (hub) {
      var scope = hub.getScope();
      if (scope) {
        var transaction = scope.getTransaction();
        if (transaction) {
          scope.setSpan(void 0);
        }
      }
    }
  }

  // ../node_modules/@sentry/tracing/esm/hubextensions.js
  function traceHeaders() {
    var scope = this.getScope();
    if (scope) {
      var span = scope.getSpan();
      if (span) {
        return {
          "sentry-trace": span.toTraceparent()
        };
      }
    }
    return {};
  }
  function sample(transaction, options, samplingContext) {
    if (!hasTracingEnabled(options)) {
      transaction.sampled = false;
      return transaction;
    }
    if (transaction.sampled !== void 0) {
      transaction.setMetadata({
        transactionSampling: { method: "explicitly_set" }
      });
      return transaction;
    }
    var sampleRate;
    if (typeof options.tracesSampler === "function") {
      sampleRate = options.tracesSampler(samplingContext);
      transaction.setMetadata({
        transactionSampling: {
          method: "client_sampler",
          rate: Number(sampleRate)
        }
      });
    } else if (samplingContext.parentSampled !== void 0) {
      sampleRate = samplingContext.parentSampled;
      transaction.setMetadata({
        transactionSampling: { method: "inheritance" }
      });
    } else {
      sampleRate = options.tracesSampleRate;
      transaction.setMetadata({
        transactionSampling: {
          method: "client_rate",
          rate: Number(sampleRate)
        }
      });
    }
    if (!isValidSampleRate(sampleRate)) {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
      transaction.sampled = false;
      return transaction;
    }
    if (!sampleRate) {
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
      transaction.sampled = false;
      return transaction;
    }
    transaction.sampled = Math.random() < sampleRate;
    if (!transaction.sampled) {
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
      return transaction;
    }
    IS_DEBUG_BUILD5 && logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
    return transaction;
  }
  function isValidSampleRate(rate) {
    if (isNaN2(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
      return false;
    }
    if (rate < 0 || rate > 1) {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
      return false;
    }
    return true;
  }
  function _startTransaction(transactionContext, customSamplingContext) {
    var client = this.getClient();
    var options = client && client.getOptions() || {};
    var transaction = new Transaction(transactionContext, this);
    transaction = sample(transaction, options, __assign6({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
    if (transaction.sampled) {
      transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    return transaction;
  }
  function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
    var client = hub.getClient();
    var options = client && client.getOptions() || {};
    var transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);
    transaction = sample(transaction, options, __assign6({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
    if (transaction.sampled) {
      transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    return transaction;
  }
  function _addTracingExtensions() {
    var carrier = getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    if (!carrier.__SENTRY__.extensions.startTransaction) {
      carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
    }
    if (!carrier.__SENTRY__.extensions.traceHeaders) {
      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
    }
  }
  function _autoloadDatabaseIntegrations() {
    var carrier = getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    var packageToIntegrationMapping = {
      mongodb: function() {
        var integration = dynamicRequire(module, "./integrations/node/mongo");
        return new integration.Mongo();
      },
      mongoose: function() {
        var integration = dynamicRequire(module, "./integrations/node/mongo");
        return new integration.Mongo({ mongoose: true });
      },
      mysql: function() {
        var integration = dynamicRequire(module, "./integrations/node/mysql");
        return new integration.Mysql();
      },
      pg: function() {
        var integration = dynamicRequire(module, "./integrations/node/postgres");
        return new integration.Postgres();
      }
    };
    var mappedPackages = Object.keys(packageToIntegrationMapping).filter(function(moduleName) {
      return !!loadModule(moduleName);
    }).map(function(pkg) {
      try {
        return packageToIntegrationMapping[pkg]();
      } catch (e) {
        return void 0;
      }
    }).filter(function(p) {
      return p;
    });
    if (mappedPackages.length > 0) {
      carrier.__SENTRY__.integrations = __spread6(carrier.__SENTRY__.integrations || [], mappedPackages);
    }
  }
  function addExtensionMethods() {
    _addTracingExtensions();
    if (isNodeEnv()) {
      _autoloadDatabaseIntegrations();
    }
    registerErrorInstrumentation();
  }

  // ../node_modules/@sentry/tracing/esm/browser/backgroundtab.js
  var global8 = getGlobalObject();
  function registerBackgroundTabDetection() {
    if (global8 && global8.document) {
      global8.document.addEventListener("visibilitychange", function() {
        var activeTransaction = getActiveTransaction();
        if (global8.document.hidden && activeTransaction) {
          var statusType = "cancelled";
          IS_DEBUG_BUILD5 && logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op);
          if (!activeTransaction.status) {
            activeTransaction.setStatus(statusType);
          }
          activeTransaction.setTag("visibilitychange", "document.hidden");
          activeTransaction.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[2]);
          activeTransaction.finish();
        }
      });
    } else {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js
  var bindReporter = function(callback, metric, reportAllChanges) {
    var prevValue;
    return function(forceReport) {
      if (metric.value >= 0) {
        if (forceReport || reportAllChanges) {
          metric.delta = metric.value - (prevValue || 0);
          if (metric.delta || prevValue === void 0) {
            prevValue = metric.value;
            callback(metric);
          }
        }
      }
    };
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js
  var generateUniqueID = function() {
    return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js
  var initMetric = function(name, value) {
    return {
      name,
      value: value !== null && value !== void 0 ? value : -1,
      delta: 0,
      entries: [],
      id: generateUniqueID()
    };
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js
  var observe = function(type, callback) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(type)) {
        if (type === "first-input" && !("PerformanceEventTiming" in self)) {
          return;
        }
        var po = new PerformanceObserver(function(l) {
          return l.getEntries().map(callback);
        });
        po.observe({ type, buffered: true });
        return po;
      }
    } catch (e) {
    }
    return;
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js
  var onHidden = function(cb, once) {
    var onHiddenOrPageHide = function(event) {
      if (event.type === "pagehide" || getGlobalObject().document.visibilityState === "hidden") {
        cb(event);
        if (once) {
          removeEventListener("visibilitychange", onHiddenOrPageHide, true);
          removeEventListener("pagehide", onHiddenOrPageHide, true);
        }
      }
    };
    addEventListener("visibilitychange", onHiddenOrPageHide, true);
    addEventListener("pagehide", onHiddenOrPageHide, true);
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js
  var getCLS = function(onReport, reportAllChanges) {
    var metric = initMetric("CLS", 0);
    var report;
    var sessionValue = 0;
    var sessionEntries = [];
    var entryHandler = function(entry) {
      if (entry && !entry.hadRecentInput) {
        var firstSessionEntry = sessionEntries[0];
        var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
        if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
          sessionValue += entry.value;
          sessionEntries.push(entry);
        } else {
          sessionValue = entry.value;
          sessionEntries = [entry];
        }
        if (sessionValue > metric.value) {
          metric.value = sessionValue;
          metric.entries = sessionEntries;
          if (report) {
            report();
          }
        }
      }
    };
    var po = observe("layout-shift", entryHandler);
    if (po) {
      report = bindReporter(onReport, metric, reportAllChanges);
      onHidden(function() {
        po.takeRecords().map(entryHandler);
        report(true);
      });
    }
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js
  var firstHiddenTime = -1;
  var initHiddenTime = function() {
    return getGlobalObject().document.visibilityState === "hidden" ? 0 : Infinity;
  };
  var trackChanges = function() {
    onHidden(function(_a) {
      var timeStamp = _a.timeStamp;
      firstHiddenTime = timeStamp;
    }, true);
  };
  var getVisibilityWatcher = function() {
    if (firstHiddenTime < 0) {
      firstHiddenTime = initHiddenTime();
      trackChanges();
    }
    return {
      get firstHiddenTime() {
        return firstHiddenTime;
      }
    };
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js
  var getFID = function(onReport, reportAllChanges) {
    var visibilityWatcher = getVisibilityWatcher();
    var metric = initMetric("FID");
    var report;
    var entryHandler = function(entry) {
      if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
        metric.value = entry.processingStart - entry.startTime;
        metric.entries.push(entry);
        report(true);
      }
    };
    var po = observe("first-input", entryHandler);
    if (po) {
      report = bindReporter(onReport, metric, reportAllChanges);
      onHidden(function() {
        po.takeRecords().map(entryHandler);
        po.disconnect();
      }, true);
    }
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js
  var reportedMetricIDs = {};
  var getLCP = function(onReport, reportAllChanges) {
    var visibilityWatcher = getVisibilityWatcher();
    var metric = initMetric("LCP");
    var report;
    var entryHandler = function(entry) {
      var value = entry.startTime;
      if (value < visibilityWatcher.firstHiddenTime) {
        metric.value = value;
        metric.entries.push(entry);
      }
      if (report) {
        report();
      }
    };
    var po = observe("largest-contentful-paint", entryHandler);
    if (po) {
      report = bindReporter(onReport, metric, reportAllChanges);
      var stopListening_1 = function() {
        if (!reportedMetricIDs[metric.id]) {
          po.takeRecords().map(entryHandler);
          po.disconnect();
          reportedMetricIDs[metric.id] = true;
          report(true);
        }
      };
      ["keydown", "click"].forEach(function(type) {
        addEventListener(type, stopListening_1, { once: true, capture: true });
      });
      onHidden(stopListening_1, true);
    }
  };

  // ../node_modules/@sentry/tracing/esm/browser/metrics.js
  var global9 = getGlobalObject();
  var MetricsInstrumentation = function() {
    function MetricsInstrumentation2(_reportAllChanges) {
      if (_reportAllChanges === void 0) {
        _reportAllChanges = false;
      }
      this._reportAllChanges = _reportAllChanges;
      this._measurements = {};
      this._performanceCursor = 0;
      if (!isNodeEnv() && global9 && global9.performance && global9.document) {
        if (global9.performance.mark) {
          global9.performance.mark("sentry-tracing-init");
        }
        this._trackCLS();
        this._trackLCP();
        this._trackFID();
      }
    }
    MetricsInstrumentation2.prototype.addPerformanceEntries = function(transaction) {
      var _this = this;
      if (!global9 || !global9.performance || !global9.performance.getEntries || !browserPerformanceTimeOrigin) {
        return;
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Adding & adjusting spans using Performance API");
      var timeOrigin = msToSec(browserPerformanceTimeOrigin);
      var responseStartTimestamp;
      var requestStartTimestamp;
      global9.performance.getEntries().slice(this._performanceCursor).forEach(function(entry) {
        var startTime = msToSec(entry.startTime);
        var duration = msToSec(entry.duration);
        if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
          return;
        }
        switch (entry.entryType) {
          case "navigation": {
            addNavigationSpans(transaction, entry, timeOrigin);
            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
            break;
          }
          case "mark":
          case "paint":
          case "measure": {
            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
            var firstHidden = getVisibilityWatcher();
            var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
            if (entry.name === "first-paint" && shouldRecord) {
              IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding FP");
              _this._measurements["fp"] = { value: entry.startTime };
              _this._measurements["mark.fp"] = { value: startTimestamp };
            }
            if (entry.name === "first-contentful-paint" && shouldRecord) {
              IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding FCP");
              _this._measurements["fcp"] = { value: entry.startTime };
              _this._measurements["mark.fcp"] = { value: startTimestamp };
            }
            break;
          }
          case "resource": {
            var resourceName = entry.name.replace(global9.location.origin, "");
            addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
            break;
          }
          default:
        }
      });
      this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
      this._trackNavigator(transaction);
      if (transaction.op === "pageload") {
        var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);
        if (typeof responseStartTimestamp === "number") {
          IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding TTFB");
          this._measurements["ttfb"] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1e3 };
          if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
            this._measurements["ttfb.requestTime"] = { value: (responseStartTimestamp - requestStartTimestamp) * 1e3 };
          }
        }
        ["fcp", "fp", "lcp"].forEach(function(name) {
          if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
            return;
          }
          var oldValue = _this._measurements[name].value;
          var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);
          var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
          var delta = normalizedValue - oldValue;
          IS_DEBUG_BUILD5 && logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
          _this._measurements[name].value = normalizedValue;
        });
        if (this._measurements["mark.fid"] && this._measurements["fid"]) {
          _startChild(transaction, {
            description: "first input delay",
            endTimestamp: this._measurements["mark.fid"].value + msToSec(this._measurements["fid"].value),
            op: "web.vitals",
            startTimestamp: this._measurements["mark.fid"].value
          });
        }
        if (!("fcp" in this._measurements)) {
          delete this._measurements.cls;
        }
        transaction.setMeasurements(this._measurements);
        tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
        transaction.setTag("sentry_reportAllChanges", this._reportAllChanges);
      }
    };
    MetricsInstrumentation2.prototype._trackNavigator = function(transaction) {
      var navigator = global9.navigator;
      if (!navigator) {
        return;
      }
      var connection = navigator.connection;
      if (connection) {
        if (connection.effectiveType) {
          transaction.setTag("effectiveConnectionType", connection.effectiveType);
        }
        if (connection.type) {
          transaction.setTag("connectionType", connection.type);
        }
        if (isMeasurementValue(connection.rtt)) {
          this._measurements["connection.rtt"] = { value: connection.rtt };
        }
        if (isMeasurementValue(connection.downlink)) {
          this._measurements["connection.downlink"] = { value: connection.downlink };
        }
      }
      if (isMeasurementValue(navigator.deviceMemory)) {
        transaction.setTag("deviceMemory", String(navigator.deviceMemory));
      }
      if (isMeasurementValue(navigator.hardwareConcurrency)) {
        transaction.setTag("hardwareConcurrency", String(navigator.hardwareConcurrency));
      }
    };
    MetricsInstrumentation2.prototype._trackCLS = function() {
      var _this = this;
      getCLS(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding CLS");
        _this._measurements["cls"] = { value: metric.value };
        _this._clsEntry = entry;
      });
    };
    MetricsInstrumentation2.prototype._trackLCP = function() {
      var _this = this;
      getLCP(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        var timeOrigin = msToSec(browserPerformanceTimeOrigin);
        var startTime = msToSec(entry.startTime);
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding LCP");
        _this._measurements["lcp"] = { value: metric.value };
        _this._measurements["mark.lcp"] = { value: timeOrigin + startTime };
        _this._lcpEntry = entry;
      }, this._reportAllChanges);
    };
    MetricsInstrumentation2.prototype._trackFID = function() {
      var _this = this;
      getFID(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        var timeOrigin = msToSec(browserPerformanceTimeOrigin);
        var startTime = msToSec(entry.startTime);
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding FID");
        _this._measurements["fid"] = { value: metric.value };
        _this._measurements["mark.fid"] = { value: timeOrigin + startTime };
      });
    };
    return MetricsInstrumentation2;
  }();
  function addNavigationSpans(transaction, entry, timeOrigin) {
    ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(function(event) {
      addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
    });
    addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
    addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
    addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
    addRequest(transaction, entry, timeOrigin);
  }
  function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
    var measureStartTimestamp = timeOrigin + startTime;
    var measureEndTimestamp = measureStartTimestamp + duration;
    _startChild(transaction, {
      description: entry.name,
      endTimestamp: measureEndTimestamp,
      op: entry.entryType,
      startTimestamp: measureStartTimestamp
    });
    return measureStartTimestamp;
  }
  function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
    if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
      return;
    }
    var data = {};
    if ("transferSize" in entry) {
      data["Transfer Size"] = entry.transferSize;
    }
    if ("encodedBodySize" in entry) {
      data["Encoded Body Size"] = entry.encodedBodySize;
    }
    if ("decodedBodySize" in entry) {
      data["Decoded Body Size"] = entry.decodedBodySize;
    }
    var startTimestamp = timeOrigin + startTime;
    var endTimestamp = startTimestamp + duration;
    _startChild(transaction, {
      description: resourceName,
      endTimestamp,
      op: entry.initiatorType ? "resource." + entry.initiatorType : "resource",
      startTimestamp,
      data
    });
  }
  function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
    var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
    var start = entry[event + "Start"];
    if (!start || !end) {
      return;
    }
    _startChild(transaction, {
      op: "browser",
      description: description !== null && description !== void 0 ? description : event,
      startTimestamp: timeOrigin + msToSec(start),
      endTimestamp: timeOrigin + msToSec(end)
    });
  }
  function addRequest(transaction, entry, timeOrigin) {
    _startChild(transaction, {
      op: "browser",
      description: "request",
      startTimestamp: timeOrigin + msToSec(entry.requestStart),
      endTimestamp: timeOrigin + msToSec(entry.responseEnd)
    });
    _startChild(transaction, {
      op: "browser",
      description: "response",
      startTimestamp: timeOrigin + msToSec(entry.responseStart),
      endTimestamp: timeOrigin + msToSec(entry.responseEnd)
    });
  }
  function _startChild(transaction, _a) {
    var startTimestamp = _a.startTimestamp, ctx = __rest6(_a, ["startTimestamp"]);
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
      transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild(__assign6({ startTimestamp }, ctx));
  }
  function isMeasurementValue(value) {
    return typeof value === "number" && isFinite(value);
  }
  function tagMetricInfo(transaction, lcpEntry, clsEntry) {
    if (lcpEntry) {
      IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding LCP Data");
      if (lcpEntry.element) {
        transaction.setTag("lcp.element", htmlTreeAsString(lcpEntry.element));
      }
      if (lcpEntry.id) {
        transaction.setTag("lcp.id", lcpEntry.id);
      }
      if (lcpEntry.url) {
        transaction.setTag("lcp.url", lcpEntry.url.trim().slice(0, 200));
      }
      transaction.setTag("lcp.size", lcpEntry.size);
    }
    if (clsEntry && clsEntry.sources) {
      IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding CLS Data");
      clsEntry.sources.forEach(function(source, index) {
        return transaction.setTag("cls.source." + (index + 1), htmlTreeAsString(source.node));
      });
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/request.js
  var DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
  var defaultRequestInstrumentationOptions = {
    traceFetch: true,
    traceXHR: true,
    tracingOrigins: DEFAULT_TRACING_ORIGINS
  };
  function instrumentOutgoingRequests(_options) {
    var _a = __assign6(__assign6({}, defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
    var urlMap = {};
    var defaultShouldCreateSpan = function(url) {
      if (urlMap[url]) {
        return urlMap[url];
      }
      var origins = tracingOrigins;
      urlMap[url] = origins.some(function(origin) {
        return isMatchingPattern(url, origin);
      }) && !isMatchingPattern(url, "sentry_key");
      return urlMap[url];
    };
    var shouldCreateSpan = defaultShouldCreateSpan;
    if (typeof shouldCreateSpanForRequest === "function") {
      shouldCreateSpan = function(url) {
        return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
      };
    }
    var spans = {};
    if (traceFetch) {
      addInstrumentationHandler("fetch", function(handlerData) {
        fetchCallback(handlerData, shouldCreateSpan, spans);
      });
    }
    if (traceXHR) {
      addInstrumentationHandler("xhr", function(handlerData) {
        xhrCallback(handlerData, shouldCreateSpan, spans);
      });
    }
  }
  function fetchCallback(handlerData, shouldCreateSpan, spans) {
    if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
      return;
    }
    if (handlerData.endTimestamp) {
      var spanId = handlerData.fetchData.__span;
      if (!spanId)
        return;
      var span = spans[spanId];
      if (span) {
        if (handlerData.response) {
          span.setHttpStatus(handlerData.response.status);
        } else if (handlerData.error) {
          span.setStatus("internal_error");
        }
        span.finish();
        delete spans[spanId];
      }
      return;
    }
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      var span = activeTransaction.startChild({
        data: __assign6(__assign6({}, handlerData.fetchData), { type: "fetch" }),
        description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
        op: "http.client"
      });
      handlerData.fetchData.__span = span.spanId;
      spans[span.spanId] = span;
      var request = handlerData.args[0] = handlerData.args[0];
      var options = handlerData.args[1] = handlerData.args[1] || {};
      var headers = options.headers;
      if (isInstanceOf(request, Request)) {
        headers = request.headers;
      }
      if (headers) {
        if (typeof headers.append === "function") {
          headers.append("sentry-trace", span.toTraceparent());
        } else if (Array.isArray(headers)) {
          headers = __spread6(headers, [["sentry-trace", span.toTraceparent()]]);
        } else {
          headers = __assign6(__assign6({}, headers), { "sentry-trace": span.toTraceparent() });
        }
      } else {
        headers = { "sentry-trace": span.toTraceparent() };
      }
      options.headers = headers;
    }
  }
  function xhrCallback(handlerData, shouldCreateSpan, spans) {
    if (!hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
      return;
    }
    var xhr = handlerData.xhr.__sentry_xhr__;
    if (handlerData.endTimestamp) {
      var spanId = handlerData.xhr.__sentry_xhr_span_id__;
      if (!spanId)
        return;
      var span = spans[spanId];
      if (span) {
        span.setHttpStatus(xhr.status_code);
        span.finish();
        delete spans[spanId];
      }
      return;
    }
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      var span = activeTransaction.startChild({
        data: __assign6(__assign6({}, xhr.data), { type: "xhr", method: xhr.method, url: xhr.url }),
        description: xhr.method + " " + xhr.url,
        op: "http.client"
      });
      handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
      spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
      if (handlerData.xhr.setRequestHeader) {
        try {
          handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
        } catch (_) {
        }
      }
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/router.js
  var global10 = getGlobalObject();
  function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) {
      startTransactionOnPageLoad = true;
    }
    if (startTransactionOnLocationChange === void 0) {
      startTransactionOnLocationChange = true;
    }
    if (!global10 || !global10.location) {
      IS_DEBUG_BUILD5 && logger.warn("Could not initialize routing instrumentation due to invalid location");
      return;
    }
    var startingUrl = global10.location.href;
    var activeTransaction;
    if (startTransactionOnPageLoad) {
      activeTransaction = customStartTransaction({ name: global10.location.pathname, op: "pageload" });
    }
    if (startTransactionOnLocationChange) {
      addInstrumentationHandler("history", function(_a) {
        var to = _a.to, from = _a.from;
        if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
          startingUrl = void 0;
          return;
        }
        if (from !== to) {
          startingUrl = void 0;
          if (activeTransaction) {
            IS_DEBUG_BUILD5 && logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
            activeTransaction.finish();
          }
          activeTransaction = customStartTransaction({ name: global10.location.pathname, op: "navigation" });
        }
      });
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/browsertracing.js
  var DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
  var DEFAULT_BROWSER_TRACING_OPTIONS = __assign6({ idleTimeout: DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, defaultRequestInstrumentationOptions);
  var BrowserTracing = function() {
    function BrowserTracing2(_options) {
      this.name = BrowserTracing2.id;
      this._configuredIdleTimeout = void 0;
      var tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
      if (_options) {
        this._configuredIdleTimeout = _options.idleTimeout;
        if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
          tracingOrigins = _options.tracingOrigins;
        } else {
          IS_DEBUG_BUILD5 && (this._emitOptionsWarning = true);
        }
      }
      this.options = __assign6(__assign6(__assign6({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins });
      var _metricOptions = this.options._metricOptions;
      this._metrics = new MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
    }
    BrowserTracing2.prototype.setupOnce = function(_, getCurrentHub2) {
      var _this = this;
      this._getCurrentHub = getCurrentHub2;
      if (this._emitOptionsWarning) {
        IS_DEBUG_BUILD5 && logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
        IS_DEBUG_BUILD5 && logger.warn("[Tracing] We added a reasonable default for you: " + defaultRequestInstrumentationOptions.tracingOrigins);
      }
      var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
      instrumentRouting(function(context) {
        return _this._createRouteTransaction(context);
      }, startTransactionOnPageLoad, startTransactionOnLocationChange);
      if (markBackgroundTransactions) {
        registerBackgroundTabDetection();
      }
      instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
    };
    BrowserTracing2.prototype._createRouteTransaction = function(context) {
      var _this = this;
      if (!this._getCurrentHub) {
        IS_DEBUG_BUILD5 && logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
        return void 0;
      }
      var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
      var parentContextFromHeader = context.op === "pageload" ? getHeaderContext() : void 0;
      var expandedContext = __assign6(__assign6(__assign6({}, context), parentContextFromHeader), { trimEnd: true });
      var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
      var finalContext = modifiedContext === void 0 ? __assign6(__assign6({}, expandedContext), { sampled: false }) : modifiedContext;
      if (finalContext.sampled === false) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
      var hub = this._getCurrentHub();
      var location = getGlobalObject().location;
      var idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, true, { location });
      idleTransaction.registerBeforeFinishCallback(function(transaction, endTimestamp) {
        _this._metrics.addPerformanceEntries(transaction);
        adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);
      });
      idleTransaction.setTag("idleTimeout", this._configuredIdleTimeout);
      return idleTransaction;
    };
    BrowserTracing2.id = "BrowserTracing";
    return BrowserTracing2;
  }();
  function getHeaderContext() {
    var header = getMetaContent("sentry-trace");
    if (header) {
      return extractTraceparentData(header);
    }
    return void 0;
  }
  function getMetaContent(metaName) {
    var el = getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
    return el ? el.getAttribute("content") : null;
  }
  function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
    var diff = endTimestamp - transaction.startTimestamp;
    var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
    if (isOutdatedTransaction) {
      transaction.setStatus("deadline_exceeded");
      transaction.setTag("maxTransactionDurationExceeded", "true");
    }
  }

  // ../node_modules/@sentry/tracing/esm/index.js
  addExtensionMethods();

  // ../node_modules/@sentry/integrations/esm/captureconsole.js
  var global11 = getGlobalObject();
  var CaptureConsole = function() {
    function CaptureConsole2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = CaptureConsole2.id;
      this._levels = CONSOLE_LEVELS;
      if (options.levels) {
        this._levels = options.levels;
      }
    }
    CaptureConsole2.prototype.setupOnce = function(_, getCurrentHub2) {
      if (!("console" in global11)) {
        return;
      }
      this._levels.forEach(function(level) {
        if (!(level in global11.console)) {
          return;
        }
        fill(global11.console, level, function(originalConsoleMethod) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var hub = getCurrentHub2();
            if (hub.getIntegration(CaptureConsole2)) {
              hub.withScope(function(scope) {
                scope.setLevel(severityFromString(level));
                scope.setExtra("arguments", args);
                scope.addEventProcessor(function(event) {
                  event.logger = "console";
                  return event;
                });
                var message = safeJoin(args, " ");
                if (level === "assert") {
                  if (args[0] === false) {
                    message = "Assertion failed: " + (safeJoin(args.slice(1), " ") || "console.assert");
                    scope.setExtra("arguments", args.slice(1));
                    hub.captureMessage(message);
                  }
                } else if (level === "error" && args[0] instanceof Error) {
                  hub.captureException(args[0]);
                } else {
                  hub.captureMessage(message);
                }
              });
            }
            if (originalConsoleMethod) {
              originalConsoleMethod.apply(global11.console, args);
            }
          };
        });
      });
    };
    CaptureConsole2.id = "CaptureConsole";
    return CaptureConsole2;
  }();

  // src/systems/sentry-client/src/FbwAircraftSentryClient.ts
  var SENTRY_CONSENT_KEY = "SENTRY_CONSENT";
  var FbwAircraftSentryClient = class {
    onInstrumentLoaded(config) {
      if (!config.dsn) {
        console.log("[SentryClient] No DSN defined. Will not try to initialize");
        return Promise.resolve(false);
      }
      this.runClientSubscription(config);
      if (config.root) {
        console.log("[SentryClient] Starting as root client");
        return this.runRootClientFlow(config);
      }
      return Promise.resolve(false);
    }
    async runClientSubscription(config) {
      NXDataStore.getAndSubscribe(SENTRY_CONSENT_KEY, (key, value) => {
        if (value === "Given" /* Given */) {
          console.log("[SentryClient] Synchronised consent state is Given. Initializing sentry");
          FbwAircraftSentryClient.attemptInitializeSentry(config);
        }
        if (value === "Refused" /* Refused */) {
          console.log("[SentryClient] Synchronised consent state is Refused. Shutting down the client");
          FbwAircraftSentryClient.closeSentry();
        }
      });
    }
    async runRootClientFlow(config) {
      const consentValue = NXDataStore.get(SENTRY_CONSENT_KEY, "Unknown" /* Unknown */);
      switch (consentValue) {
        case "Given" /* Given */:
          console.log("[SentryClient] Consent state is Given. Initializing sentry");
          return FbwAircraftSentryClient.attemptInitializeSentry(config);
        case "Unknown" /* Unknown */:
          console.log("[SentryClient] Consent state is Unknown. Asking for consent");
          return new Promise((resolve, reject) => {
            const instrument2 = document.querySelector("vcockpit-panel > *");
            if (instrument2) {
              instrument2.addEventListener("FlightStart", () => {
                setTimeout(() => {
                  resolve(FbwAircraftSentryClient.requestConsent().then((didConsent) => {
                    if (didConsent) {
                      NXDataStore.set(SENTRY_CONSENT_KEY, "Given" /* Given */);
                      console.log("[SentryClient] User requested consent state Given. Initializing sentry");
                      return FbwAircraftSentryClient.attemptInitializeSentry(config);
                    }
                    NXDataStore.set(SENTRY_CONSENT_KEY, "Refused" /* Refused */);
                    console.log("[SentryClient] User requested consent state Refused. Doing nothing");
                    return false;
                  }).catch(() => false));
                }, 1e3);
              });
            } else {
              reject(new Error("[SentryClient] Could not find an instrument element to hook onto"));
            }
          });
        case "Refused" /* Refused */:
          console.log("[SentryClient] Consent state is Refused. Doing nothing");
          break;
        default:
          console.log("[SentryClient] Consent state is corrupted. Doing nothing");
          break;
      }
      return false;
    }
    static async requestConsent() {
      const popup = new PopUpDialog();
      return new Promise((resolve) => {
        popup.showPopUp(
          "A32NX - ERROR REPORTING",
          "Are you willing to help FlyByWire Simulations by enabling anonymous reporting of errors that may occur in the future? This is 100% optional and we will never collect your personal data, but it will help us diagnose issues quickly.",
          "normal",
          () => resolve(true),
          () => resolve(false)
        );
      });
    }
    static async attemptInitializeSentry(config) {
      return FbwAircraftSentryClient.initializeSentry(config).then(() => true).catch((e) => {
        console.error("[SentryClient] Error while initializing sentry");
        console.error(e);
        return false;
      });
    }
    static closeSentry() {
      close();
      console.log("[SentryClient] Sentry closed");
    }
    static async initializeSentry(config) {
      let release = "unknown";
      try {
        const manifest = await (await fetch(`/VFS/${config.buildInfoFilePrefix}_build_info.json`)).json();
        release = manifest.pretty_release_name;
      } catch (e) {
        console.warn(`[SentryClient] Could not load ${config.buildInfoFilePrefix}_build_info.json. Using 'unknown' as release name`);
      }
      const integrations = [new CaptureConsole({ levels: ["error"] })];
      if (config.enableTracing) {
        integrations.push(new BrowserTracing());
      }
      init({
        dsn: config.dsn,
        release,
        integrations,
        sampleRate: 0.1
      });
      console.log("[SentryClient] Sentry initialized");
      NXDataStore.getAndSubscribe("A32NX_SENTRY_SESSION_ID", (_, value) => {
        if (value) {
          setTag("session_id", value);
          console.log('[SentryClient] Sentry tag "session_id" set to', value);
        }
      });
    }
  };

  // src/systems/instruments/src/Common/index.tsx
  var render = (Slot, enableSentryTracing = false, sentryRootClient = false) => {
    const doRender = () => {
      new FbwAircraftSentryClient().onInstrumentLoaded({
        dsn: "https://abd67c4440a644b3aaaf44838e565bea@o1135700.ingest.sentry.io/6185355",
        buildInfoFilePrefix: "a32nx",
        enableTracing: enableSentryTracing,
        root: sentryRootClient
      });
      import_react_dom.default.render(Slot, getRenderTarget());
    };
    if (false) {
      window.addEventListener("AceInitialized", () => doRender());
    } else {
      doRender();
    }
  };

  // src/systems/instruments/src/DCDU/pages/SelfTest.tsx
  var import_react12 = __toESM(require_react());
  var SelfTest = () => /* @__PURE__ */ import_react12.default.createElement(import_react12.default.Fragment, null, /* @__PURE__ */ import_react12.default.createElement("svg", { className: "startup-text" }, /* @__PURE__ */ import_react12.default.createElement("text", { x: "1968", y: "1360" }, "SELF TEST IN PROGRESS"), /* @__PURE__ */ import_react12.default.createElement("text", { x: "1968", y: "1680" }, "(MAX 10 SECONDS)")));

  // src/systems/instruments/src/DCDU/elements/AtsuStatusMessage.tsx
  var import_react13 = __toESM(require_react());
  var translateStatusMessage = (status) => {
    switch (status) {
      case 0 /* AnswerRequired */:
        return "ANSWER MSG";
      case 1 /* CommunicationFault */:
        return "COM FAULT";
      case 2 /* CommunicationNotAvailable */:
        return "COM NOT AVAIL";
      case 3 /* CommunicationNotInitialized */:
        return "COM NOT INIT";
      case 4 /* MaximumDownlinkMessages */:
        return "FILE FULL";
      case 5 /* LinkLost */:
        return "LINK LOST";
      case 6 /* FlightplanLoadFailed */:
        return "LOAD FAILED";
      case 7 /* FlightplanLoadPartial */:
        return "LOAD PARTIAL";
      case 8 /* FlightplanLoadingUnavailable */:
        return "LOAD UNAVAIL";
      case 9 /* MonitoringFailed */:
        return "MONIT FAILED";
      case 10 /* MonitoringLost */:
        return "MONIT LOST";
      case 11 /* MonitoringUnavailable */:
        return "MONIT UNAVAIL";
      case 12 /* NoAtcReply */:
        return "NO ATC REPLY";
      case 13 /* OverflowClosed */:
        return "OVERFLW CLOSED";
      case 14 /* PrintFailed */:
        return "PRINT FAILED";
      case 15 /* PriorityMessage */:
        return "PRIORITY MSG";
      case 16 /* SendFailed */:
        return "SEND FAILED";
      case 17 /* FlightplanLoadSecondary */:
        return "LOAD SEC OK";
      case 18 /* FlightplanLoadingSecondary */:
        return "LOADING SEC";
      case 19 /* FmsDisplayForText */:
        return "MCDU FOR TEXT";
      case 20 /* FmsDisplayForModification */:
        return "MCDU FOR MODIF";
      case 21 /* MonitoringCancelled */:
        return "MONIT CNCLD";
      case 22 /* Monitoring */:
        return "MONITORING";
      case 23 /* NoFmData */:
        return "NO FM DATA";
      case 24 /* NoMoreMessages */:
        return "NO MORE MSG";
      case 25 /* NoMorePages */:
        return "NO MORE PGE";
      case 26 /* PartialFmgsData */:
        return "PARTIAL DATA";
      case 27 /* Printing */:
        return "PRINTING";
      case 28 /* RecallMode */:
        return "RECALL MODE";
      case 29 /* RecallEmpty */:
        return /* @__PURE__ */ import_react13.default.createElement(import_react13.default.Fragment, null, /* @__PURE__ */ import_react13.default.createElement("tspan", null, "RECALL EMPTY"), /* @__PURE__ */ import_react13.default.createElement("tspan", { x: "50%", dy: 200 }, "CONSULT MSG RECORD"));
      case 30 /* Reminder */:
        return "REMINDER";
      case 31 /* Sending */:
        return "SENDING";
      case 32 /* Sent */:
        return "SENT";
      case 33 /* WaitFmData */:
        return "WAIT FM DATA";
      case -1 /* NoMessage */:
      default:
        return "";
    }
  };
  var AtsuStatusMessage = ({ visibleMessage, systemMessage }) => {
    if (visibleMessage === -1 /* NoMessage */ && systemMessage === -1 /* NoMessage */) {
      return /* @__PURE__ */ import_react13.default.createElement(import_react13.default.Fragment, null);
    }
    let textFill = "rgb(255,255,255)";
    if (systemMessage !== -1 /* NoMessage */) {
      if (systemMessage <= 16 /* SendFailed */) {
        textFill = "rgb(255,191,0)";
      }
    } else if (visibleMessage !== -1 /* NoMessage */) {
      if (visibleMessage <= 16 /* SendFailed */) {
        textFill = "rgb(255,191,0)";
      }
    }
    return /* @__PURE__ */ import_react13.default.createElement(import_react13.default.Fragment, null, /* @__PURE__ */ import_react13.default.createElement("g", null, /* @__PURE__ */ import_react13.default.createElement(
      "text",
      {
        className: "status-atsu",
        fill: textFill,
        x: "50%",
        y: "2160"
      },
      translateStatusMessage(systemMessage !== -1 /* NoMessage */ ? systemMessage : visibleMessage)
    )));
  };

  // src/systems/instruments/src/DCDU/pages/WaitingForData.tsx
  var import_react14 = __toESM(require_react());
  var WaitingForData = () => /* @__PURE__ */ import_react14.default.createElement(import_react14.default.Fragment, null, /* @__PURE__ */ import_react14.default.createElement("svg", { className: "startup-text" }, /* @__PURE__ */ import_react14.default.createElement("text", { x: "1968", y: "1360" }, "WAITING FOR DATA"), /* @__PURE__ */ import_react14.default.createElement("text", { x: "1968", y: "1680" }, "(MAX 30 SECONDS)")));

  // src/systems/instruments/src/DCDU/elements/DcduLines.tsx
  var import_react15 = __toESM(require_react());
  var DcduLines = () => /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("g", null, /* @__PURE__ */ import_react15.default.createElement("path", { className: "dcdu-line", d: "m 128 1888 h 3600" }), /* @__PURE__ */ import_react15.default.createElement("path", { className: "dcdu-line", d: "m 1040 2000 v 816" }), /* @__PURE__ */ import_react15.default.createElement("path", { className: "dcdu-line", d: "m 2896 2000 v 816" })));

  // src/systems/instruments/src/DCDU/elements/DatalinkMessage.tsx
  var import_react17 = __toESM(require_react());

  // src/systems/instruments/src/DCDU/elements/MessageVisualization.tsx
  var import_react16 = __toESM(require_react());
  function visualizeLine(line, startIdx, startY, deltaY, useDeltaY, reminder, ignoreHighlight, backgroundActive) {
    if (startIdx >= line.length) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null);
    }
    const highlight = line[startIdx].highlight && !ignoreHighlight;
    const monitoring = line[startIdx].watchdog && !ignoreHighlight;
    let className = "message-tspan";
    if (!reminder) {
      if (backgroundActive) {
        className += " message-onbackground";
      } else if (monitoring) {
        className += " message-monitoring";
      } else if (highlight) {
        className += " message-highlight";
      }
    }
    let nextIdx = line.length;
    let message = "";
    for (let i = startIdx; i < line.length; ++i) {
      message += `${line[i].word}\xA0`;
      if (i + 1 < line.length && line[i].highlight !== line[i + 1].highlight) {
        nextIdx = i + 1;
        break;
      }
    }
    if (startIdx === 0) {
      if (useDeltaY) {
        return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("tspan", { x: "224", dy: deltaY, className }, message), visualizeLine(line, nextIdx, startY, deltaY, useDeltaY, reminder, ignoreHighlight, backgroundActive));
      }
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("tspan", { x: "224", y: startY, className }, message), visualizeLine(line, nextIdx, startY, deltaY, useDeltaY, reminder, ignoreHighlight, backgroundActive));
    }
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("tspan", { className }, message), visualizeLine(line, nextIdx, startY, deltaY, useDeltaY, reminder, ignoreHighlight, backgroundActive));
  }
  function visualizeLines(lines, backgroundIdx, yStart, deltaY, reminder, ignoreHighlight) {
    if (lines.length === 0) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null);
    }
    const firstLine = lines[0];
    lines.shift();
    let lineCount = 0;
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, visualizeLine(firstLine.words, 0, yStart, deltaY, false, reminder, ignoreHighlight, backgroundIdx <= 0), lines.map((line) => {
      lineCount += 1;
      return visualizeLine(line.words, 0, yStart, deltaY, true, reminder, ignoreHighlight, backgroundIdx <= lineCount);
    }));
  }
  function indexInList(list, index) {
    for (const value of list) {
      if (value === index) {
        return true;
      }
    }
    return false;
  }
  function colorizeWords(message, keepNewlines, watchdogIndices) {
    const words = [];
    if (!keepNewlines) {
      message = message.replace(/\n/gi, " ");
    }
    let watchdogColor = false;
    let highlightColor = false;
    const messageWords = message.match(/[-@_A-Z0-9]+|\[\s+\]/g);
    if (!messageWords) {
      return [];
    }
    for (let word of messageWords) {
      if (word.length === 0) {
        continue;
      }
      const highlightMarkers = [];
      for (let i = 0; i < word.length; ++i) {
        if (word[i] === "@")
          highlightMarkers.push(i);
      }
      word = word.replace(/@/gi, "");
      if (highlightMarkers.length === 1 && highlightMarkers[0] === 0) {
        highlightColor = !highlightColor;
        watchdogColor = false;
        if (highlightColor) {
          if (indexInList(watchdogIndices, words.length)) {
            watchdogColor = true;
          }
        }
      } else if (highlightMarkers.length !== 0) {
        highlightColor = !highlightColor;
        if (highlightColor) {
          if (indexInList(watchdogIndices, words.length)) {
            watchdogColor = true;
          }
        }
      }
      words.push({ word, highlight: highlightColor, watchdog: watchdogColor });
      if (highlightMarkers.length === 1 && highlightMarkers[0] !== 0) {
        highlightColor = !highlightColor;
      } else if (highlightMarkers.length !== 0) {
        highlightColor = !highlightColor;
      }
    }
    return words;
  }
  function insertWord(lines, word, keepNewlines) {
    if (!keepNewlines) {
      if (lines[lines.length - 1].length + word.word.length + 1 >= 27 && lines[lines.length - 1].length !== 0) {
        lines.push({ length: 0, words: [] });
      }
    }
    if (lines[lines.length - 1].length !== 0) {
      lines[lines.length - 1].length += 1;
    }
    lines[lines.length - 1].length += word.word.length;
    lines[lines.length - 1].words.push(word);
  }
  function createVisualizationLines(message, keepNewlines, watchdogIndices) {
    const lines = [];
    if (!keepNewlines) {
      const words = colorizeWords(message, keepNewlines, watchdogIndices);
      lines.push({ length: 0, words: [] });
      words.forEach((word) => {
        let newline = false;
        word.word.split(/_/).forEach((entry) => {
          if (newline) {
            lines.push({ length: 0, words: [] });
          }
          insertWord(lines, { word: entry, highlight: word.highlight, watchdog: word.watchdog }, keepNewlines);
          newline = !keepNewlines;
        });
      });
    } else {
      const inputLines = message.split(/\n/);
      let lastLineHighlight = false;
      inputLines.forEach((line) => {
        const words = colorizeWords(line, keepNewlines, watchdogIndices);
        if (words.length === 1 && /-+/.test(line)) {
          lastLineHighlight = false;
        }
        if (words.length !== 0) {
          if (lastLineHighlight) {
            words.forEach((word) => {
              word.highlight = !word.highlight;
              if (!word.highlight) {
                word.watchdog = false;
              }
            });
          }
          lastLineHighlight = words[words.length - 1].highlight;
        }
        lines.push({ length: 0, words });
      });
    }
    return lines;
  }
  var MessageVisualization = (0, import_react16.memo)(({
    messageUid,
    message,
    backgroundColor,
    messageIsReminder,
    keepNewlines = false,
    ignoreHighlight,
    cssClass,
    yStart,
    deltaY,
    seperatorLine = null,
    watchdogIndices = [],
    updateSystemStatusMessage,
    reachedEndOfMessage
  }) => {
    const [pageIndex, setPageIndex] = (0, import_react16.useState)(0);
    const [pageCount, setPageCount] = (0, import_react16.useState)(0);
    const maxLines = 5;
    useInteractionEvents(["A32NX_DCDU_BTN_MPL_POEMINUS", "A32NX_DCDU_BTN_MPR_POEMINUS"], () => {
      if (pageCount === 0) {
        return;
      }
      reachedEndOfMessage(messageUid, pageCount === 1);
      if (pageIndex > 0) {
        updateSystemStatusMessage(-1 /* NoMessage */);
        setPageIndex(pageIndex - 1);
      } else {
        updateSystemStatusMessage(25 /* NoMorePages */);
      }
    });
    useInteractionEvents(["A32NX_DCDU_BTN_MPL_POEPLUS", "A32NX_DCDU_BTN_MPR_POEPLUS"], () => {
      if (pageCount === 0) {
        return;
      }
      reachedEndOfMessage(messageUid, pageCount <= pageIndex + 2);
      if (pageCount > pageIndex + 1) {
        updateSystemStatusMessage(-1 /* NoMessage */);
        setPageIndex(pageIndex + 1);
      } else {
        updateSystemStatusMessage(25 /* NoMorePages */);
      }
    });
    if (message.length === 0) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null);
    }
    let lines = createVisualizationLines(message, keepNewlines, watchdogIndices);
    const messagePageCountWithoutOverlap = Math.ceil(lines.length / maxLines);
    const messagePageCount = Math.ceil((lines.length + messagePageCountWithoutOverlap - 1) / maxLines);
    if (messagePageCount !== pageCount) {
      reachedEndOfMessage(messageUid, messagePageCount === 1);
      setPageCount(messagePageCount);
      setPageIndex(0);
    }
    if (pageCount === 0) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null);
    }
    const startIndex = pageIndex * maxLines - pageIndex;
    const endIndex = Math.min(startIndex + maxLines, lines.length);
    lines = lines.slice(startIndex, endIndex);
    let backgroundY = 520;
    let contentHeight = 120;
    let backgroundNeeded = false;
    if (backgroundColor[0] !== 0 || backgroundColor[1] !== 0 || backgroundColor[2] !== 0) {
      if (seperatorLine) {
        backgroundNeeded = true;
        if (seperatorLine <= startIndex) {
          contentHeight += lines.length * 220;
        } else if (seperatorLine < endIndex) {
          contentHeight += (endIndex - seperatorLine) * 220;
          backgroundY += (lines.length - (endIndex - seperatorLine)) * 220;
        } else {
          backgroundNeeded = false;
        }
      } else {
        contentHeight += lines.length * 220;
        backgroundNeeded = true;
      }
    }
    const rgb = `rgb(${backgroundColor[0]},${backgroundColor[1]},${backgroundColor[2]})`;
    let backgroundIdx = maxLines;
    if (backgroundNeeded) {
      if (seperatorLine && seperatorLine >= startIndex) {
        backgroundIdx = seperatorLine - startIndex >= maxLines ? 0 : seperatorLine - startIndex;
      } else if (seperatorLine) {
        backgroundIdx = 0;
      }
    }
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, backgroundNeeded && /* @__PURE__ */ import_react16.default.createElement(
      Checkerboard,
      {
        x: 130,
        y: backgroundY,
        width: 3600,
        height: contentHeight,
        cellSize: 10,
        fill: rgb
      }
    ), /* @__PURE__ */ import_react16.default.createElement("text", { className: cssClass }, visualizeLines(lines, backgroundIdx, yStart, deltaY, messageIsReminder, ignoreHighlight)), pageCount > 1 && /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("text", { className: "status-atsu", fill: "white", x: "65%", y: "2480" }, "PG"), /* @__PURE__ */ import_react16.default.createElement("text", { className: "status-atsu", fill: "white", x: "65%", y: "2720" }, pageIndex + 1, " ", "/", " ", pageCount)));
  });

  // src/systems/instruments/src/DCDU/elements/DatalinkMessage.tsx
  var DatalinkMessage = ({ messages, updateSystemStatusMessage, reachedEndOfMessage }) => {
    var _a, _b, _c, _d, _e, _f;
    let backgroundColor = [0, 0, 0];
    if (messages[0].Direction === 1 /* Downlink */) {
      if (messages[0].ComStatus === 2 /* Sent */ || messages[0].ComStatus === 1 /* Sending */) {
        backgroundColor = [0, 255, 0];
      } else {
        backgroundColor = [0, 255, 255];
      }
    } else if (messages[0].SemanticResponseRequired) {
      if (((_a = messages[0].Response) == null ? void 0 : _a.ComStatus) === 2 /* Sent */ || ((_b = messages[0].Response) == null ? void 0 : _b.ComStatus) === 1 /* Sending */) {
        backgroundColor = [0, 255, 0];
      } else {
        backgroundColor = [0, 255, 255];
      }
    }
    let ignoreHighlight = false;
    if (messages[0].Direction === 1 /* Downlink */) {
      ignoreHighlight = true;
    } else if (((_c = messages[0].Response) == null ? void 0 : _c.ComStatus) === 1 /* Sending */) {
      ignoreHighlight = true;
    } else if (((_d = messages[0].Response) == null ? void 0 : _d.ComStatus) === 2 /* Sent */ && ((_e = messages[0].Response) == null ? void 0 : _e.Message) !== "STANDBY") {
      ignoreHighlight = true;
    }
    const messageIsReminder = !messages[0].SemanticResponseRequired && messages[0].MessageMonitoring === 4 /* Finished */;
    let messageClass = "message-content";
    if (messages[0].Direction === 1 /* Downlink */) {
      messageClass += " message-content-other message-content-out";
    } else if (ignoreHighlight && !messageIsReminder) {
      messageClass += " message-content-sent";
    } else {
      messageClass += " message-content-other message-content-in";
    }
    let content = "";
    const watchdogIndices = [];
    let messageSeperatorLine = void 0;
    if (messages[0].MessageMonitoring === 4 /* Finished */) {
      content = `_____REMINDER MSG ${messages[0].Timestamp.mailboxTimestamp()}
`;
      messageSeperatorLine = 1;
      if (messages[0].SemanticResponseRequired) {
        content += `${messages[0].Response.serialize(2 /* Mailbox */)}
`;
      } else {
        messages.forEach((message) => {
          if (message.Content.length === 0 && message.Message !== "") {
            content += `${message.Message}
`;
          } else {
            content += `${message.serialize(2 /* Mailbox */)}
`;
          }
        });
      }
      content = content.replace(/@/g, "");
    } else {
      let offset = 0;
      messages.forEach((message) => {
        if (message.Content.length === 0 && message.Message !== "") {
          content += `${message.Message}
`;
          offset += message.Message.split(" ").length;
        } else {
          if (messages[0].MessageMonitoring === 2 /* Monitoring */) {
            message.Content.forEach((element) => {
              element.Content.forEach((value) => {
                if (value.Monitoring) {
                  watchdogIndices.push(offset + value.IndexStart);
                }
              });
            });
          }
          const text = message.serialize(2 /* Mailbox */);
          offset += text.split(" ").length;
          content += `${text}
`;
        }
      });
      content += "//";
      if (messages[0].SemanticResponseRequired && messages[0].Response) {
        messageSeperatorLine = content.split("\n").length;
        content += "------------------------------\n";
        content += `${messages[0].Response.serialize(2 /* Mailbox */)}//
`;
      }
    }
    if (content.length !== 0) {
      content = content.slice(0, -1);
    }
    if ((_f = messages[0].Content[0]) == null ? void 0 : _f.Urgent) {
      content = `_____***HIGH PRIORITY***
${content}`;
      if (messageSeperatorLine !== void 0) {
        messageSeperatorLine += 1;
      }
    }
    return /* @__PURE__ */ import_react17.default.createElement("g", null, /* @__PURE__ */ import_react17.default.createElement(
      MessageVisualization,
      {
        messageUid: messages.length !== 0 ? messages[0].UniqueMessageID : -1,
        message: content,
        seperatorLine: messageSeperatorLine,
        backgroundColor,
        messageIsReminder,
        keepNewlines: true,
        ignoreHighlight,
        cssClass: messageClass,
        yStart: 720,
        deltaY: 240,
        watchdogIndices,
        updateSystemStatusMessage,
        reachedEndOfMessage
      }
    ));
  };

  // src/systems/instruments/src/DCDU/elements/MessageStatus.tsx
  var import_react18 = __toESM(require_react());
  var translateResponseId = (response, message) => {
    const answerExpected = message.Content[0].ExpectedResponse !== "NE" /* NotRequired */ && message.Content[0].ExpectedResponse !== "N" /* No */;
    if (response === -1) {
      if (message.Direction === 0 /* Uplink */ && answerExpected) {
        return "OPEN";
      }
      if (message.ComStatus === 2 /* Sent */) {
        return "SENT";
      }
    } else if (`DM${response}` in CpdlcMessagesDownlink) {
      const text = CpdlcMessagesDownlink[`DM${response}`][0][0];
      if (text === "STANDBY") {
        return "STBY";
      }
      if (text === "NEGATIVE") {
        return "NEGATV";
      }
      return text;
    }
    return "";
  };
  var translateResponseMessage = (message, response) => {
    const answerExpected = message.Content[0].ExpectedResponse !== "NE" /* NotRequired */ && message.Content[0].ExpectedResponse !== "N" /* No */;
    if (!response) {
      if (message.Direction === 0 /* Uplink */ && answerExpected) {
        return "OPEN";
      }
      if (message.ComStatus === 2 /* Sent */) {
        return "SENT";
      }
    } else if (response.Content.length !== 0 && response.Content[0].TypeId in CpdlcMessagesDownlink) {
      if (!message.SemanticResponseRequired) {
        const text = CpdlcMessagesDownlink[response.Content[0].TypeId][0][0];
        if (text === "STANDBY") {
          return "STBY";
        }
        if (text === "NEGATIVE") {
          return "NEGATV";
        }
        return text;
      }
      if (response.ComStatus !== 2 /* Sent */) {
        return "OPEN";
      }
      return "";
    }
    return "";
  };
  var MessageStatus = ({ message, selectedResponse }) => {
    var _a, _b, _c, _d, _e, _f;
    const messageIsReminder = !message.SemanticResponseRequired && message.MessageMonitoring === 4 /* Finished */;
    let statusClass = "status-message ";
    if (message.Direction === 0 /* Uplink */) {
      if (!message.SemanticResponseRequired) {
        if (message.Response || selectedResponse !== -1) {
          statusClass += "status-other";
        } else {
          statusClass += "status-open";
        }
      } else if (((_a = message.Response) == null ? void 0 : _a.ComStatus) === 0 /* Open */) {
        statusClass += "status-open";
      } else {
        statusClass += "status-other";
      }
    } else if (message.ComStatus === 2 /* Sent */) {
      statusClass += "status-other";
    } else {
      statusClass += "status-open";
    }
    let text = "";
    if (message.Direction === 0 /* Uplink */ && !messageIsReminder) {
      if (selectedResponse !== -1) {
        text = translateResponseId(selectedResponse, message);
      } else {
        text = translateResponseMessage(message, message.Response);
      }
    }
    const backgroundRequired = text !== "OPEN" && text !== "SENT";
    let backgroundColor = "rgba(0,0,0,0)";
    if (message.Direction === 0 /* Uplink */) {
      if (selectedResponse === -1 || ((_b = message.Response) == null ? void 0 : _b.Content[0].TypeId) === `DM${selectedResponse}`) {
        backgroundColor = "rgb(0,255,0)";
      } else {
        backgroundColor = "rgb(0,255,255)";
      }
    }
    const background = { x: 0, y: 0, width: 0, height: 0 };
    if (text.length !== 0) {
      background.width = text.length * 116 + 48;
      background.height = 187;
      background.x = 3740 - background.width;
      background.y = 310 - background.height;
    }
    let title = "";
    if (message.MessageMonitoring === 4 /* Finished */) {
      if (message.SemanticResponseRequired) {
        title = `${(_d = (_c = message.Response) == null ? void 0 : _c.Timestamp) == null ? void 0 : _d.mailboxTimestamp()} TO ${(_e = message.Response) == null ? void 0 : _e.Station}`;
      } else if (message.ReminderTimestamp !== null) {
        title = message.ReminderTimestamp.mailboxTimestamp();
        text = "";
      } else {
        title = "----Z";
      }
    } else {
      title = `${(_f = message.Timestamp) == null ? void 0 : _f.mailboxTimestamp()} ${message.Direction === 1 /* Downlink */ ? " TO " : " FROM "} ${message.Station}`;
    }
    return /* @__PURE__ */ import_react18.default.createElement("g", null, /* @__PURE__ */ import_react18.default.createElement("text", { className: "station", x: "168", y: "280" }, title), /* @__PURE__ */ import_react18.default.createElement(import_react18.default.Fragment, null, "(", backgroundRequired && /* @__PURE__ */ import_react18.default.createElement(
      Checkerboard,
      {
        x: background.x,
        y: background.y,
        width: background.width,
        height: background.height,
        cellSize: 10,
        fill: backgroundColor
      }
    ), ")", /* @__PURE__ */ import_react18.default.createElement("text", { className: statusClass, x: "3716", y: "290" }, /* @__PURE__ */ import_react18.default.createElement("tspan", null, text))));
  };

  // src/systems/instruments/src/DCDU/elements/AtcStatus.tsx
  var import_react19 = __toESM(require_react());
  var AtcStatus = ({ message }) => {
    let cssClass = "atc-info ";
    if (message.includes("CURRENT")) {
      cssClass += "atc-info-active";
    } else {
      cssClass += "atc-info-standby";
    }
    const reachedEndOfMessageSink = (_uid, _reachedEnd) => {
    };
    const systemStatusSink = (_status) => {
    };
    return /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, /* @__PURE__ */ import_react19.default.createElement(
      MessageVisualization,
      {
        message,
        messageUid: -1,
        messageIsReminder: false,
        backgroundColor: [0, 0, 0],
        ignoreHighlight: false,
        cssClass,
        yStart: 800,
        deltaY: 240,
        updateSystemStatusMessage: systemStatusSink,
        reachedEndOfMessage: reachedEndOfMessageSink
      }
    ));
  };

  // src/systems/instruments/src/util.js
  var import_react20 = __toESM(require_react());
  var renderTarget = document.getElementById("MSFS_REACT_MOUNT");
  var customElement = renderTarget.parentElement;
  function useUpdate2(handler) {
    const savedHandler = (0, import_react20.useRef)(handler);
    (0, import_react20.useEffect)(() => {
      savedHandler.current = handler;
    }, [handler]);
    (0, import_react20.useEffect)(() => {
      const wrappedHandler = (event) => {
        savedHandler.current(event.detail);
      };
      customElement.addEventListener("update", wrappedHandler);
      return () => {
        customElement.removeEventListener("update", wrappedHandler);
      };
    });
  }
  var SIMVAR_CACHE = /* @__PURE__ */ new Map();
  customElement.addEventListener("update", () => {
    SIMVAR_CACHE.clear();
  });

  // src/systems/instruments/src/DCDU/index.tsx
  var DcduMessageBlock = class {
    constructor() {
      __publicField(this, "messages", []);
      __publicField(this, "timestamp", 0);
      __publicField(this, "response", -1);
      __publicField(this, "statusMessage", -1 /* NoMessage */);
      __publicField(this, "messageVisible", false);
      __publicField(this, "automaticCloseTimeout", -1);
      __publicField(this, "semanticResponseIncomplete", false);
      __publicField(this, "reachedEndOfMessage", false);
    }
  };
  var sortedMessageArray = (messages) => {
    const arrMessages = Array.from(messages.values());
    arrMessages.sort((a, b) => a.timestamp - b.timestamp);
    return arrMessages;
  };
  var DcduSystemStatusDuration = 5e3;
  var DCDU = () => {
    const [publisher, setPublisher] = (0, import_react21.useState)(null);
    const [_subscriber, setSubscriber] = (0, import_react21.useState)(null);
    const [electricityState] = useSimVar("L:A32NX_ELEC_DC_1_BUS_IS_POWERED", "bool", 200);
    const [isColdAndDark] = useSimVar("L:A32NX_COLD_AND_DARK_SPAWN", "Bool", 200);
    const [state, setState] = (0, import_react21.useState)(isColdAndDark ? 0 /* Off */ : 1 /* On */);
    const [systemStatusMessage, setSystemStatusMessage] = (0, import_react21.useState)(-1 /* NoMessage */);
    const [systemStatusTimer, setSystemStatusTimer] = (0, import_react21.useState)(null);
    const [screenTimeout, setScreenTimeout] = (0, import_react21.useState)(null);
    const [messages, setMessages] = (0, import_react21.useState)(/* @__PURE__ */ new Map());
    const publisherRef = (0, import_react21.useRef)();
    const messagesRef = (0, import_react21.useRef)();
    const [atcMessage, setAtcMessage] = (0, import_react21.useState)("");
    messagesRef.current = messages;
    publisherRef.current = publisher;
    const updateSystemStatusMessage = (status) => {
      setSystemStatusMessage(status);
      setSystemStatusTimer(5e3);
    };
    const reachedEndOfMessage = (uid, reachedEnd) => {
      if (!messagesRef.current) {
        return;
      }
      const updateMap = new Map(messagesRef.current);
      const entry = updateMap.get(uid);
      if (entry !== void 0) {
        entry.reachedEndOfMessage = reachedEnd;
      }
      setMessages(updateMap);
    };
    const setMessageStatus = (uid, response2) => {
      var _a;
      if (!messagesRef.current) {
        return;
      }
      const updateMap = new Map(messagesRef.current);
      const entry = updateMap.get(uid);
      if (entry !== void 0) {
        (_a = publisherRef.current) == null ? void 0 : _a.pub("readMessage", uid, true, false);
        entry.response = response2;
      }
      setMessages(updateMap);
    };
    const deleteMessage = (uid) => {
      var _a;
      return (_a = publisherRef.current) == null ? void 0 : _a.pub("deleteMessage", uid, true, false);
    };
    const sendMessage = (uid) => {
      var _a;
      return (_a = publisherRef.current) == null ? void 0 : _a.pub("downlinkTransmit", uid, true, false);
    };
    const sendResponse = (uid, responseId) => {
      var _a;
      return (_a = publisherRef.current) == null ? void 0 : _a.pub("uplinkResponse", { uid, responseId }, true, false);
    };
    const invertResponse = (uid) => {
      var _a;
      (_a = publisherRef.current) == null ? void 0 : _a.pub("invertSemanticResponse", uid, true, false);
    };
    const modifyResponse = (uid) => {
      var _a, _b;
      if (!messagesRef.current) {
        return;
      }
      const message = messagesRef.current.get(uid);
      if (message) {
        message.statusMessage = 20 /* FmsDisplayForModification */;
        (_a = publisherRef.current) == null ? void 0 : _a.pub("readMessage", uid, true, false);
        (_b = publisherRef.current) == null ? void 0 : _b.pub("modifyMessage", uid, true, false);
      }
      setMessages(new Map(messagesRef.current));
    };
    const recallMessage = () => {
      var _a;
      (_a = publisherRef.current) == null ? void 0 : _a.pub("recallMessage", true, true, false);
    };
    const closeMessage = (uid) => {
      var _a;
      if (!messagesRef.current) {
        return;
      }
      const sortedMessages = sortedMessageArray(messagesRef.current);
      const index = sortedMessages.findIndex((element) => element.messages[0].UniqueMessageID === uid);
      (_a = publisherRef.current) == null ? void 0 : _a.pub("closeMessage", uid, true, false);
      if (index !== -1) {
        setSystemStatusMessage(-1 /* NoMessage */);
        setSystemStatusTimer(null);
        const updatedMap = new Map(messagesRef.current);
        if (index > 0) {
          const message = updatedMap.get(sortedMessages[index - 1].messages[0].UniqueMessageID);
          if (message) {
            message.messageVisible = true;
          }
        } else if (index + 1 < sortedMessages.length) {
          const message = updatedMap.get(sortedMessages[index + 1].messages[0].UniqueMessageID);
          if (message) {
            message.messageVisible = true;
          }
        }
        updatedMap.delete(uid);
        setMessages(updatedMap);
      }
    };
    const monitorMessage = (uid) => {
      var _a;
      return (_a = publisherRef.current) == null ? void 0 : _a.pub("updateMessageMonitoring", uid, true, false);
    };
    const stopMessageMonitoring = (uid) => {
      var _a;
      return (_a = publisherRef.current) == null ? void 0 : _a.pub("stopMessageMonitoring", uid, true, false);
    };
    useInteractionEvents(["A32NX_DCDU_BTN_MPL_MS0MINUS", "A32NX_DCDU_BTN_MPR_MS0MINUS"], () => {
      if (!messagesRef.current || messagesRef.current.size === 0) {
        return;
      }
      const sortedMessages = sortedMessageArray(messagesRef.current);
      const index = sortedMessages.findIndex((element) => element.messageVisible);
      if (index <= 0) {
        setSystemStatusMessage(24 /* NoMoreMessages */);
        setSystemStatusTimer(DcduSystemStatusDuration);
      } else {
        setSystemStatusMessage(-1 /* NoMessage */);
        setSystemStatusTimer(null);
        const oldMessage = messagesRef.current.get(sortedMessages[index].messages[0].UniqueMessageID);
        const newMessage = messagesRef.current.get(sortedMessages[index - 1].messages[0].UniqueMessageID);
        if (oldMessage && newMessage) {
          oldMessage.messageVisible = false;
          newMessage.messageVisible = true;
          setMessages(new Map(messagesRef.current));
        }
      }
    });
    useInteractionEvents(["A32NX_DCDU_BTN_MPL_MS0PLUS", "A32NX_DCDU_BTN_MPR_MS0PLUS"], () => {
      if (!messagesRef.current || messagesRef.current.size === 0) {
        return;
      }
      const sortedMessages = sortedMessageArray(messagesRef.current);
      const index = sortedMessages.findIndex((element) => element.messageVisible);
      if (index + 1 >= sortedMessages.length) {
        setSystemStatusMessage(24 /* NoMoreMessages */);
        setSystemStatusTimer(DcduSystemStatusDuration);
      } else {
        setSystemStatusMessage(-1 /* NoMessage */);
        setSystemStatusTimer(null);
        const oldMessage = messagesRef.current.get(sortedMessages[index].messages[0].UniqueMessageID);
        const newMessage = messagesRef.current.get(sortedMessages[index + 1].messages[0].UniqueMessageID);
        if (oldMessage && newMessage) {
          oldMessage.messageVisible = false;
          newMessage.messageVisible = true;
          setMessages(new Map(messagesRef.current));
        }
      }
    });
    useInteractionEvents(["A32NX_DCDU_BTN_MPL_PRINT", "A32NX_DCDU_BTN_MPR_PRINT"], () => {
      var _a;
      if (!messagesRef.current || messagesRef.current.size === 0) {
        return;
      }
      const sortedMessages = sortedMessageArray(messagesRef.current);
      const index = sortedMessages.findIndex((element) => element.messageVisible);
      if (index !== -1) {
        (_a = publisherRef.current) == null ? void 0 : _a.pub("printMessage", sortedMessages[index].messages[0].UniqueMessageID, true, false);
      }
    });
    (0, import_react21.useEffect)(() => {
      const eventBus = new EventBus();
      setPublisher(eventBus.getPublisher());
      const newSubscriber = eventBus.getSubscriber();
      newSubscriber.on("resetSystem").handle(() => {
        setSystemStatusMessage(-1 /* NoMessage */);
        setSystemStatusTimer(null);
        if (screenTimeout) {
          clearTimeout(screenTimeout);
          setScreenTimeout(null);
        }
        setMessages(/* @__PURE__ */ new Map());
        setAtcMessage("");
      });
      const handleIncomingMessages = (cpdlcMessages) => {
        var _a;
        if (!messagesRef.current) {
          return;
        }
        const enhancedMessages = [];
        cpdlcMessages.forEach((message) => enhancedMessages.push(Conversion.messageDataToMessage(message)));
        if (enhancedMessages.length !== 0) {
          const newMessageMap = new Map(messagesRef.current);
          const dcduBlock = newMessageMap.get(enhancedMessages[0].UniqueMessageID);
          if (dcduBlock !== void 0) {
            dcduBlock.messages = enhancedMessages;
            if (dcduBlock.statusMessage === -1 /* NoMessage */) {
              if (enhancedMessages[0].MessageMonitoring === 2 /* Monitoring */) {
                dcduBlock.statusMessage = 22 /* Monitoring */;
              } else if (enhancedMessages[0].MessageMonitoring === 3 /* Cancelled */) {
                dcduBlock.statusMessage = 21 /* MonitoringCancelled */;
              }
            } else if (dcduBlock.statusMessage === 22 /* Monitoring */) {
              if (enhancedMessages[0].MessageMonitoring === 3 /* Cancelled */) {
                dcduBlock.statusMessage = 21 /* MonitoringCancelled */;
              } else if (enhancedMessages[0].MessageMonitoring !== 2 /* Monitoring */) {
                dcduBlock.statusMessage = -1 /* NoMessage */;
              }
            } else if (enhancedMessages[0].MessageMonitoring === 4 /* Finished */) {
              dcduBlock.statusMessage = -1 /* NoMessage */;
            }
            if (((_a = enhancedMessages[0].Response) == null ? void 0 : _a.ComStatus) === 2 /* Sent */) {
              dcduBlock.response = -1;
            }
          } else {
            const message = new DcduMessageBlock();
            message.messages = enhancedMessages;
            message.timestamp = new Date().getTime();
            if (enhancedMessages[0].MessageMonitoring === 2 /* Monitoring */) {
              message.statusMessage = 22 /* Monitoring */;
            } else if (enhancedMessages[0].MessageMonitoring === 3 /* Cancelled */) {
              message.statusMessage = 21 /* MonitoringCancelled */;
            }
            newMessageMap.set(enhancedMessages[0].UniqueMessageID, message);
          }
          if (enhancedMessages[0].SemanticResponseRequired && enhancedMessages[0].Response && enhancedMessages[0].Response.Content) {
            const dcduBlock2 = newMessageMap.get(enhancedMessages[0].UniqueMessageID);
            if (dcduBlock2) {
              dcduBlock2.semanticResponseIncomplete = false;
              if (dcduBlock2.statusMessage === 23 /* NoFmData */ || dcduBlock2.statusMessage === 20 /* FmsDisplayForModification */) {
                dcduBlock2.statusMessage = -1 /* NoMessage */;
              }
              for (const entry of enhancedMessages[0].Response.Content[0].Content) {
                if (entry.Value === "") {
                  dcduBlock2.semanticResponseIncomplete = true;
                  dcduBlock2.statusMessage = 23 /* NoFmData */;
                  break;
                }
              }
            }
          }
          if (newMessageMap.size === 1) {
            const message = newMessageMap.get(enhancedMessages[0].UniqueMessageID);
            if (message) {
              message.messageVisible = true;
            }
          }
          setMessages(newMessageMap);
        }
      };
      newSubscriber.on("cpdlcMessages").handle((messages2) => handleIncomingMessages(messages2));
      newSubscriber.on("dclMessages").handle((messages2) => handleIncomingMessages(messages2));
      newSubscriber.on("oclMessages").handle((messages2) => handleIncomingMessages(messages2));
      newSubscriber.on("deleteMessage").handle((uid) => closeMessage(uid));
      newSubscriber.on("logonMessage").handle((message) => setAtcMessage(message));
      newSubscriber.on("systemStatus").handle((status) => {
        setSystemStatusMessage(status);
        setSystemStatusTimer(5e3);
      });
      newSubscriber.on("messageStatus").handle((data) => {
        if (!messagesRef.current) {
          return;
        }
        const dcduBlock = messagesRef.current.get(data.uid);
        if (dcduBlock !== void 0) {
          dcduBlock.statusMessage = data.status;
          if (data.status === -1 /* NoMessage */) {
            if (dcduBlock.messages[0].MessageMonitoring === 2 /* Monitoring */) {
              dcduBlock.statusMessage = 22 /* Monitoring */;
            } else if (dcduBlock.messages[0].MessageMonitoring === 3 /* Cancelled */) {
              dcduBlock.statusMessage = 21 /* MonitoringCancelled */;
            }
          }
          setMessages(new Map(messagesRef.current));
        }
      });
      setSubscriber(newSubscriber);
      return () => {
        setSubscriber(null);
      };
    }, []);
    useUpdate2((deltaTime) => {
      if (messagesRef.current === void 0) {
        return;
      }
      const currentTime = new Date().getTime() / 1e3;
      const sortedArray = sortedMessageArray(messagesRef.current);
      sortedArray.forEach((message) => {
        var _a, _b;
        if (message.messages[0].CloseAutomatically) {
          if (message.messageVisible && message.automaticCloseTimeout < 0) {
            const cpdlcMessage = message.messages[0];
            if (cpdlcMessage.Direction === 1 /* Downlink */ && cpdlcMessage.ComStatus === 2 /* Sent */ || cpdlcMessage.Direction === 0 /* Uplink */ && ((_a = cpdlcMessage.Response) == null ? void 0 : _a.Content[0].TypeId) !== "DM2" && ((_b = cpdlcMessage.Response) == null ? void 0 : _b.ComStatus) === 2 /* Sent */) {
              message.automaticCloseTimeout = new Date().getTime() / 1e3;
            }
          } else if (message.automaticCloseTimeout > 0 && currentTime - message.automaticCloseTimeout >= 2 && message.messages[0].MessageMonitoring !== 4 /* Finished */) {
            closeMessage(message.messages[0].UniqueMessageID);
          } else if (!message.messageVisible) {
            message.automaticCloseTimeout = -1;
          }
        }
      });
      if (systemStatusTimer !== null) {
        if (systemStatusTimer > 0) {
          setSystemStatusTimer(systemStatusTimer - deltaTime);
        } else {
          setSystemStatusMessage(-1 /* NoMessage */);
          setSystemStatusTimer(null);
        }
      }
    });
    (0, import_react21.useEffect)(() => {
      if (state === 1 /* On */ && electricityState === 0) {
        setState(4 /* Standby */);
        setScreenTimeout(setTimeout(() => setState(0 /* Off */), 1e4));
      } else if (state === 4 /* Standby */ && electricityState !== 0) {
        setState(1 /* On */);
        if (screenTimeout) {
          clearTimeout(screenTimeout);
          setScreenTimeout(null);
        }
      } else if (state === 0 /* Off */ && electricityState !== 0) {
        setState(2 /* Selftest */);
        setScreenTimeout(setTimeout(() => {
          setState(3 /* Waiting */);
          setScreenTimeout(setTimeout(() => setState(1 /* On */), 12e3));
        }, 6e3));
      } else if ((state === 2 /* Selftest */ || state === 3 /* Waiting */) && electricityState === 0) {
        setState(0 /* Off */);
        if (screenTimeout) {
          clearTimeout(screenTimeout);
          setScreenTimeout(null);
        }
      }
    }, [electricityState]);
    let messageIndex = -1;
    let messageReadComplete = true;
    let visibleMessagesSemanticResponseIncomplete = false;
    let visibleMessages = void 0;
    let visibleMessageStatus = -1 /* NoMessage */;
    let response = -1;
    if (state === 1 /* On */ && messages.size !== 0) {
      const arrMessages = sortedMessageArray(messagesRef.current);
      messageIndex = arrMessages.findIndex((element) => element.messageVisible);
      if (messageIndex !== -1) {
        response = arrMessages[messageIndex].response;
        visibleMessages = arrMessages[messageIndex].messages;
        messageReadComplete = arrMessages[messageIndex].reachedEndOfMessage;
        visibleMessageStatus = arrMessages[messageIndex].statusMessage;
        visibleMessagesSemanticResponseIncomplete = arrMessages[messageIndex].semanticResponseIncomplete;
      }
      let noUrgentMessage = true;
      arrMessages.forEach((message) => {
        var _a;
        if (((_a = message.messages[0].Content[0]) == null ? void 0 : _a.Urgent) && !message.messageVisible) {
          if (systemStatusMessage !== 15 /* PriorityMessage */) {
            setSystemStatusMessage(15 /* PriorityMessage */);
            setSystemStatusTimer(-1);
          }
          noUrgentMessage = false;
        }
      });
      if (noUrgentMessage && systemStatusMessage === 15 /* PriorityMessage */) {
        setSystemStatusMessage(-1 /* NoMessage */);
      }
    }
    let answerRequired = false;
    if (visibleMessages !== void 0 && visibleMessages[0].Direction === 0 /* Uplink */) {
      answerRequired = visibleMessages[0].Content[0].ExpectedResponse !== "NE" /* NotRequired */ && visibleMessages[0].Content[0].ExpectedResponse !== "N" /* No */;
    }
    switch (state) {
      case 2 /* Selftest */:
        return /* @__PURE__ */ import_react21.default.createElement(SelfTest, null);
      case 3 /* Waiting */:
        return /* @__PURE__ */ import_react21.default.createElement(WaitingForData, null);
      case 0 /* Off */:
        return /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null);
      default:
        return /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement("svg", { className: "dcdu" }, visibleMessages === void 0 && atcMessage !== "" && /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement(AtcStatus, { message: atcMessage })), visibleMessages !== void 0 && /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement(
          MessageStatus,
          {
            message: visibleMessages[0],
            selectedResponse: response
          }
        ), /* @__PURE__ */ import_react21.default.createElement(
          DatalinkMessage,
          {
            messages: visibleMessages,
            updateSystemStatusMessage,
            reachedEndOfMessage
          }
        )), visibleMessages !== void 0 && answerRequired && !visibleMessages[0].SemanticResponseRequired && visibleMessages[0].Content[0].ExpectedResponse === "WU" /* WilcoUnable */ && /* @__PURE__ */ import_react21.default.createElement(
          WilcoUnableButtons,
          {
            message: visibleMessages[0],
            reachedEndOfMessage: messageReadComplete,
            selectedResponse: response,
            setMessageStatus,
            sendResponse,
            closeMessage,
            monitorMessage,
            cancelMessageMonitoring: stopMessageMonitoring
          }
        ), visibleMessages !== void 0 && answerRequired && !visibleMessages[0].SemanticResponseRequired && visibleMessages[0].Content[0].ExpectedResponse === "AN" /* AffirmNegative */ && /* @__PURE__ */ import_react21.default.createElement(
          AffirmNegativeButtons,
          {
            message: visibleMessages[0],
            reachedEndOfMessage: messageReadComplete,
            selectedResponse: response,
            setMessageStatus,
            sendResponse,
            closeMessage,
            monitorMessage,
            cancelMessageMonitoring: stopMessageMonitoring
          }
        ), visibleMessages !== void 0 && answerRequired && !visibleMessages[0].SemanticResponseRequired && visibleMessages[0].Content[0].ExpectedResponse === "R" /* Roger */ && /* @__PURE__ */ import_react21.default.createElement(
          RogerButtons,
          {
            message: visibleMessages[0],
            reachedEndOfMessage: messageReadComplete,
            selectedResponse: response,
            setMessageStatus,
            sendResponse,
            closeMessage,
            monitorMessage,
            cancelMessageMonitoring: stopMessageMonitoring
          }
        ), visibleMessages !== void 0 && !answerRequired && !visibleMessages[0].SemanticResponseRequired && visibleMessages[0].Direction === 1 /* Downlink */ && /* @__PURE__ */ import_react21.default.createElement(
          OutputButtons,
          {
            message: visibleMessages[0],
            reachedEndOfMessage: messageReadComplete,
            sendMessage,
            deleteMessage,
            closeMessage
          }
        ), visibleMessages !== void 0 && visibleMessages[0].SemanticResponseRequired && visibleMessages[0].Direction === 0 /* Uplink */ && /* @__PURE__ */ import_react21.default.createElement(
          SemanticResponseButtons,
          {
            message: visibleMessages[0],
            reachedEndOfMessage: messageReadComplete,
            messageUnderModification: visibleMessageStatus === 20 /* FmsDisplayForModification */ || visibleMessageStatus === 19 /* FmsDisplayForText */,
            dataIncomplete: visibleMessagesSemanticResponseIncomplete,
            invertResponse,
            modifyResponse,
            sendMessage,
            closeMessage
          }
        ), visibleMessages !== void 0 && !answerRequired && !visibleMessages[0].SemanticResponseRequired && visibleMessages[0].Direction === 0 /* Uplink */ && /* @__PURE__ */ import_react21.default.createElement(
          CloseButtons,
          {
            message: visibleMessages[0],
            closeMessage
          }
        ), visibleMessages === void 0 && /* @__PURE__ */ import_react21.default.createElement(RecallButtons, { recallMessage }), /* @__PURE__ */ import_react21.default.createElement(AtsuStatusMessage, { visibleMessage: visibleMessageStatus, systemMessage: systemStatusMessage }), /* @__PURE__ */ import_react21.default.createElement(DcduLines, null), messagesRef.current.size > 1 && /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement("g", null, /* @__PURE__ */ import_react21.default.createElement("text", { className: "status-atsu", fill: "white", x: "35%", y: "2480" }, "MSG"), /* @__PURE__ */ import_react21.default.createElement("text", { className: "status-atsu", fill: "white", x: "35%", y: "2720" }, messageIndex + 1, " ", "/", " ", messagesRef.current.size)))));
    }
  };
  render(/* @__PURE__ */ import_react21.default.createElement(DCDU, null));
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

    }

    Update() {
        super.Update();
        this.dispatchEvent(new CustomEvent('update', { detail: this.getDeltaTime() }));
    }

    onInteractionEvent(event) {
        const eventName = String(event);
        this.dispatchEvent(new CustomEvent(eventName));
        this.dispatchEvent(new CustomEvent('*', { detail: eventName }));
    }
}

registerInstrument('a32nx-dcdu', InstrumentLogic);
