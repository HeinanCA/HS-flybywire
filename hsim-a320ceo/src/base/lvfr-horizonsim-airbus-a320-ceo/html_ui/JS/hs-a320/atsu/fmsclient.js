var AtsuFmsClient = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    FmsClient: () => FmsClient
  });

  // ../../../../../fbw-common/src/systems/datalink/common/src/components/Convert.ts
  function wordWrap(text, maxLength) {
    const result = [];
    let line = [];
    let length = 0;
    const words = text.match(/[-.:*@_A-Z0-9]+|\[\s+\]|\n/g);
    for (const word of words) {
      if (length + word.length >= maxLength || word === "\n") {
        result.push(line.join(" ").toUpperCase());
        line = [];
        length = 0;
        if (word === "\n") {
          continue;
        }
      }
      length += word.length + 1;
      line.push(word);
    }
    if (line.length > 0) {
      result.push(line.join(" ").toUpperCase());
    }
    return result;
  }
  function timestampToString(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds / 60) % 60;
    return `${hours.toString().padStart(2, "0")}${minutes.toString().padStart(2, "0")}`;
  }
  function decimalToDms(deg, lng) {
    const M = 0 | deg % 1 * 6e8;
    let degree;
    if (lng) {
      degree = (0 | (deg < 0 ? -deg : deg)).toString().padStart(3, "0");
    } else {
      degree = 0 | (deg < 0 ? -deg : deg);
    }
    let dir = "";
    if (deg < 0) {
      dir = lng ? "W" : "S";
    } else {
      dir = lng ? "E" : "N";
    }
    return {
      dir,
      deg: degree,
      min: Math.abs(0 | M / 1e7),
      sec: Math.abs((0 | M / 1e6 % 1 * 6e4) / 100)
    };
  }
  function coordinateToString(coordinate, shortVersion) {
    const dmsLat = decimalToDms(coordinate.lat, false);
    const dmsLon = decimalToDms(coordinate.lon, true);
    dmsLon.deg = Number(dmsLon.deg);
    dmsLat.sec = Math.ceil(Number(dmsLat.sec / 100));
    dmsLon.sec = Math.ceil(Number(dmsLon.sec / 100));
    if (shortVersion) {
      if (dmsLat.dir === "N") {
        if (dmsLon.dir === "E") {
          return `${dmsLat.deg}N${dmsLon.deg}`;
        }
        return `${dmsLat.deg}${dmsLon.deg}N`;
      }
      if (dmsLon.dir === "E") {
        return `${dmsLat.deg}${dmsLon.deg}S`;
      }
      return `${dmsLat.deg}W${dmsLon.deg}`;
    }
    const lat = `${dmsLat.deg}\xB0${dmsLat.min}.${dmsLat.sec}${dmsLat.dir}`;
    const lon = `${dmsLon.deg}\xB0${dmsLon.min}.${dmsLon.sec}${dmsLon.dir}`;
    return `${lat}/${lon}`;
  }

  // ../../../../../fbw-common/src/systems/datalink/common/src/components/InputValidationFansA.ts
  var InputValidationFansA = class {
    static validateScratchpadAltitude(value) {
      if (!/^[0-9]{1,5}(FT|M)*$/.test(value)) {
        return 15 /* FormatError */;
      }
      const feet = !value.endsWith("M");
      const altitude = parseInt(value.match(/([0-9]+)/)[0]);
      if (feet) {
        if (altitude >= 0 && altitude <= 1e3 && !value.endsWith("FT")) {
          return 15 /* FormatError */;
        }
        if (altitude >= 0 && altitude <= 25e3) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (altitude >= 0 && altitude <= 12500) {
        return 0 /* Ok */;
      }
      return 14 /* EntryOutOfRange */;
    }
    static validateScratchpadSpeed(value) {
      if (/^((M*)\.[0-9]{1,2})$/.test(value)) {
        let mach = parseInt(value.match(/([0-9]+)/)[0]);
        if (mach < 10)
          mach *= 10;
        if (mach >= 61 && mach <= 92) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (/^([0-9]{1,3}(KT)*)$/.test(value)) {
        const knots = parseInt(value.match(/([0-9]+)/)[0]);
        if (knots >= 70 && knots <= 350) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/components/InputValidationFansB.ts
  var InputValidationFansB = class {
    static validateScratchpadAltitude(value) {
      if (!/^-*[0-9]{1,5}(FT|M)*$/.test(value)) {
        return 15 /* FormatError */;
      }
      const feet = !value.endsWith("M");
      const altitude = parseInt(value.match(/(-*[0-9]+)/)[0]);
      if (feet) {
        if (altitude >= 0 && altitude <= 410 && !value.endsWith("FT")) {
          return 15 /* FormatError */;
        }
        if (altitude >= -600 && altitude <= 41e3) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (altitude >= -30 && altitude <= 12500) {
        return 0 /* Ok */;
      }
      return 14 /* EntryOutOfRange */;
    }
    static validateScratchpadSpeed(value) {
      if (/^((M*)\.[0-9]{1,2})$/.test(value)) {
        let mach = parseInt(value.match(/([0-9]+)/)[0]);
        if (mach < 10)
          mach *= 10;
        if (mach >= 50 && mach <= 92) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (/^([0-9]{1,3}(KT)*)$/.test(value)) {
        const knots = parseInt(value.match(/([0-9]+)/)[0]);
        if (knots >= 0 && knots <= 350) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/components/InputValidation.ts
  var InputWaypointType = /* @__PURE__ */ ((InputWaypointType2) => {
    InputWaypointType2[InputWaypointType2["Invalid"] = 0] = "Invalid";
    InputWaypointType2[InputWaypointType2["GeoCoordinate"] = 1] = "GeoCoordinate";
    InputWaypointType2[InputWaypointType2["Timepoint"] = 2] = "Timepoint";
    InputWaypointType2[InputWaypointType2["Place"] = 3] = "Place";
    return InputWaypointType2;
  })(InputWaypointType || {});
  var _InputValidation = class {
    /**
     * Checks if the value fits to a waypoint format
     * @param value The entered waypoint candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadWaypoint(value) {
      if (value.match(/^(N|S)?([0-9]{2,4}\.[0-9])(N|S)?\/(E|W)?([0-9]{2,5}\.[0-9])(E|W)?$/) !== null) {
        return 0 /* Ok */;
      }
      if (/^[A-Z0-9]{1,5}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Checks if the value fits to a position format
     * @param value The entered position candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadPosition(value) {
      if (/^[A-Z0-9]{1,10}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Checks if the value fits to a procedure format
     * @param value The entered procedure candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadProcedure(value) {
      if (/^[A-Z0-9]{1,7}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Checks if the value fits to the time format
     * @param value The entered time candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadTime(value, expectZulu = true) {
      if (expectZulu && /^[0-9]{4}Z$/.test(value) || !expectZulu && /^[0-9]{4}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Checks if the value fits to the ATIS format
     * @param value The entered ATIS candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadAtis(value) {
      if (/^[A-Z]{1}$/.test(value)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Checks if the value fits to the degree format
     * @param value The entered degree candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadDegree(value) {
      if (/^[0-9]{1,3}$/.test(value)) {
        const heading = parseInt(value);
        if (heading >= 0 && heading <= 360) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Checks if the value fits to the squawk format
     * @param value The entered squawk candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadSquawk(value) {
      if (/^[0-9]{4}$/.test(value)) {
        const squawk = parseInt(value);
        if (squawk >= 0 && squawk < 7777) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    static isLatLonFormat(waypoint) {
      return waypoint.match(/^(N|S)?([0-9]{2,4}\.[0-9])(N|S)?\/(E|W)?([0-9]{2,5}\.[0-9])(E|W)?$/) !== null;
    }
    /**
     * Classifies a possible waypoint type of the scratchpad
     * Types:
     *   -  0 = lat-lon coordinate
     *   -  1 = time
     *   -  2 = place
     *   - -1 = unknonw
     * @param {string} waypoint The entered waypoint
     * @param {boolean} allowTime Indicates if time entries are allowed
     * @returns A tuple with the type and null or a NXSystemMessage-entry in case of a failure
     */
    static classifyScratchpadWaypointType(waypoint, allowTime) {
      if (_InputValidation.isLatLonFormat(waypoint)) {
        return [1 /* GeoCoordinate */, 0 /* Ok */];
      }
      if (allowTime && /^([0-2][0-4][0-5][0-9]Z?)$/.test(waypoint)) {
        return [2 /* Timepoint */, 0 /* Ok */];
      }
      if (/^[A-Z0-9]{2,7}/.test(waypoint)) {
        return [3 /* Place */, 0 /* Ok */];
      }
      return [0 /* Invalid */, 15 /* FormatError */];
    }
    /**
     * Validate a given VHF frequency that it fits to the 8.33 kHz-spacing
     * @param {string} value Frequency candidate
     * @returns null or a NXSystemMessages-entry in case of a failure
     */
    static validateVhfFrequency(value) {
      if (!/^1[1-3][0-9].[0-9]{2}[0|5]$/.test(value)) {
        return 15 /* FormatError */;
      }
      const elements = value.split(".");
      const before = parseInt(elements[0]);
      if (before < 118 || before > 136) {
        return 14 /* EntryOutOfRange */;
      }
      const frequencySpacingOther = ["00", "05", "10", "15", "25", "30", "35", "40", "50", "55", "60", "65", "75", "80", "85", "90"];
      const frequencySpacingEnd = ["00", "05", "10", "15", "25", "30", "35", "40", "50", "55", "60", "65", "75"];
      const twoDigitFraction = elements[1].substring(1, elements[1].length);
      if (before === 136) {
        if (frequencySpacingEnd.findIndex((entry) => entry === twoDigitFraction) === -1) {
          return 14 /* EntryOutOfRange */;
        }
      } else if (frequencySpacingOther.findIndex((entry) => entry === twoDigitFraction) === -1) {
        return 14 /* EntryOutOfRange */;
      }
      return 0 /* Ok */;
    }
    /**
     * Validates a value that it is compatible with the FCOM format for altitudes and flight levels
     * @param {string} value The entered scratchpad altitude
     * @returns An AtsuStatusCodes-value
     */
    static validateScratchpadAltitude(value) {
      if (/^((FL)*[0-9]{1,3})$/.test(value)) {
        const flightlevel = parseInt(value.match(/([0-9]+)/)[0]);
        if (flightlevel >= 30 && flightlevel <= 410) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      if (_InputValidation.FANS === 2 /* FansB */) {
        return InputValidationFansB.validateScratchpadAltitude(value);
      }
      return InputValidationFansA.validateScratchpadAltitude(value);
    }
    /**
     * Checks if a string fits to the distance definition
     * @param distance The distance candidate
     * @returns AtsuStatusCodes.Ok if the format is valid
     */
    static validateScratchpadDistance(distance) {
      if (/^[0-9]{1,3}(NM|KM)$/.test(distance) || /^[0-9]{1,3}$/.test(distance)) {
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Validates a value that it is compatible with the FCOM format for lateral offsets
     * @param {string} value The entered scratchpad offset
     * @returns An AtsuStatusCodes-value
     */
    static validateScratchpadOffset(offset) {
      let nmUnit = true;
      let distance = 0;
      if (/^[LR][0-9]{1,3}(NM|KM)$/.test(offset) || /^[LR][0-9]{1,3}$/.test(offset)) {
        distance = parseInt(offset.match(/([0-9]+)/)[0]);
        nmUnit = !offset.endsWith("KM");
      } else if (/^[0-9]{1,3}(NM|KM)[LR]$/.test(offset) || /^[0-9]{1,3}[LR]$/.test(offset)) {
        distance = parseInt(offset.match(/([0-9]+)/)[0]);
        nmUnit = !(offset.endsWith("KML") || offset.endsWith("KMR"));
      } else {
        return 15 /* FormatError */;
      }
      if (nmUnit) {
        if (distance >= 1 && distance <= 128) {
          return 0 /* Ok */;
        }
      } else if (distance >= 1 && distance <= 256) {
        return 0 /* Ok */;
      }
      return 14 /* EntryOutOfRange */;
    }
    /**
     * Validates a value that it is compatible with the FCOM format for speeds
     * @param {string} value The entered scratchpad speed
     * @returns An AtsuStatusCodes-value
     */
    static validateScratchpadSpeed(value) {
      if (_InputValidation.FANS === 2 /* FansB */) {
        return InputValidationFansB.validateScratchpadSpeed(value);
      }
      return InputValidationFansA.validateScratchpadSpeed(value);
    }
    /**
     * Validates a value that it is compatible with the FCOM format for vertical speeds
     * @param {string} value The entered scratchpad vertical speed
     * @returns An AtsuStatusCodes-value
     */
    static validateScratchpadVerticalSpeed(value) {
      if (/^(\+|-|M)?[0-9]{1,4}(FT\/MIN|FT|FTM|M\/MIN|MM|M){1}$/.test(value)) {
        let verticalSpeed = parseInt(value.match(/([0-9]+)/)[0]);
        if (value.startsWith("-") || value.startsWith("M")) {
          verticalSpeed *= -1;
        }
        if (!/(FT){1}/.test(value)) {
          if (verticalSpeed >= -2e3 && verticalSpeed <= 2e3) {
            return 0 /* Ok */;
          }
        } else if (verticalSpeed >= -6e3 && verticalSpeed <= 6e3) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Validates that two speed entries describe the same (knots or mach)
     * @param {string} lower Lower speed value
     * @param {string} higher Higher speed value
     * @returns True if both are same type else false
     */
    static sameSpeedType(lower, higher) {
      if (lower[0] === "M" && higher[0] === "M") {
        return true;
      }
      if (lower[0] === "M" || higher[0] === "M") {
        return false;
      }
      return true;
    }
    /**
     * Validates that a scratchpad entry follows the FCOM definition for speed ranges
     * @param {string} Given speed range candidate
     * @returns An array of AtsuStatusCodes-value and the speed ranges
     */
    static validateScratchpadSpeedRanges(value) {
      const entries = value.split("/");
      if (entries.length !== 2) {
        return [15 /* FormatError */, []];
      }
      if (_InputValidation.validateScratchpadSpeed(entries[0]) || _InputValidation.validateScratchpadSpeed(entries[1])) {
        let error = _InputValidation.validateScratchpadSpeed(entries[0]);
        if (error) {
          return [error, []];
        }
        error = this.validateScratchpadSpeed(entries[1]);
        return [error, []];
      }
      const lower = _InputValidation.formatScratchpadSpeed(entries[0]);
      const higher = _InputValidation.formatScratchpadSpeed(entries[1]);
      if (!_InputValidation.sameSpeedType(lower, higher)) {
        return [15 /* FormatError */, []];
      }
      if (parseInt(lower.match(/([0-9]+)/)[0]) >= parseInt(higher.match(/([0-9]+)/)[0])) {
        return [14 /* EntryOutOfRange */, []];
      }
      return [0 /* Ok */, [lower, higher]];
    }
    /**
     * Formats a scratchpad to a standard altitude string
     * @param {string} value The entered valid altitude
     * @returns Formatted string or empty string in case of a failure
     */
    static formatScratchpadAltitude(value) {
      if (value.startsWith("FL") || value.endsWith("M") || value.endsWith("FT")) {
        return value;
      }
      const altitude = parseInt(value);
      if (altitude >= 30 && altitude <= 410) {
        return `FL${value}`;
      }
      return `${value}FT`;
    }
    /**
     * Formats a scratchpad entry to the standard speed description
     * @param {string} value Valid speed entry
     * @returns The formatted speed string
     */
    static formatScratchpadSpeed(value) {
      if (value[0] === "M" || value[0] === ".") {
        return `M.${value.match(/([0-9]+)/)[0]}`;
      }
      return value.replace("KT", "");
    }
    /**
     * Validates a value that it is compatible with the FCOM format for vertical speeds
     * @param {string} value The entered scratchpad vertical speed
     * @returns An AtsuStatusCodes-value
     */
    static formatScratchpadVerticalSpeed(value) {
      let verticalSpeed = parseInt(value.match(/([0-9]+)/)[0]);
      if (value.startsWith("-") || value.startsWith("M")) {
        verticalSpeed *= -1;
      }
      if (!/(FT){1}/.test(value)) {
        return `${verticalSpeed}MM`;
      }
      return `${verticalSpeed}FTM`;
    }
    /**
     * Validates that two altitude entries describe the same (FL, feet or meters)
     * @param {string} lower Lower altitude value
     * @param {string} higher Higher altitude value
     * @returns True if both are same type else false
     */
    static sameAltitudeType(lower, higher) {
      if (lower.startsWith("FL") && higher.startsWith("FL")) {
        return true;
      }
      if (lower.startsWith("FL") || higher.startsWith("FL")) {
        return false;
      }
      if (lower[lower.length - 1] === "M" && higher[higher.length - 1] === "M" || lower[lower.length - 1] !== "M" && higher[higher.length - 1] !== "M") {
        return true;
      }
      return false;
    }
    /**
     * Converts a given altitude into foot
     * @param value The altitude that needs to be converted
     * @returns The altitude in feet
     */
    static convertToFeet(value) {
      const height = parseInt(value.match(/([0-9]+)/)[0]);
      if (value.startsWith("FL")) {
        return height * 100;
      }
      if (value[value.length - 1] === "M") {
        return height * 3.28;
      }
      if (value.endsWith("FT")) {
        return height;
      }
      if (height < 1e3)
        return height * 100;
      return height;
    }
    /**
     * Validates that lower is smaller than higher
     * @param {string} lower Lower altitude value
     * @param {string} higher Higher altitude value
     * @returns True if lower is smaller than higher, else false
     */
    static validateAltitudeRange(lower, higher) {
      if (!_InputValidation.sameAltitudeType(lower, higher))
        return 15 /* FormatError */;
      const errorLower = _InputValidation.validateScratchpadAltitude(lower);
      if (errorLower !== 0 /* Ok */)
        return errorLower;
      const errorHigher = _InputValidation.validateScratchpadAltitude(higher);
      if (errorHigher !== 0 /* Ok */)
        return errorHigher;
      const lowerFt = _InputValidation.convertToFeet(lower);
      const higherFt = _InputValidation.convertToFeet(higher);
      if (lowerFt >= higherFt)
        return 14 /* EntryOutOfRange */;
      return 0 /* Ok */;
    }
    /**
     * Validates the persons on board
     * @param {string} value The persons on board
     * @returns AtsuStatusCodes.Ok if the value is valid
     */
    static validateScratchpadPersonsOnBoard(value) {
      if (/^[0-9]{1,4}$/.test(value)) {
        const pob = parseInt(value.match(/([0-9]+)/)[0]);
        if (pob >= 1 && pob <= 1024) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Validates the endurance
     * @param {string} value The entered endurance
     * @returns AtsuStatusCodes.Ok if the value is valid
     */
    static validateScratchpadEndurance(value) {
      if (/^([0-9]{1}H|[0-9]{2}(H)*)[0-9]{2}(M|MIN|MN)*$/.test(value)) {
        const matches = value.match(/[0-9]{1,2}/g);
        const hours = parseInt(matches[0]);
        if (hours < 0 || hours >= 24) {
          return 14 /* EntryOutOfRange */;
        }
        const minutes = parseInt(matches[1]);
        if (minutes < 0 || minutes >= 60) {
          return 14 /* EntryOutOfRange */;
        }
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Validates the temparture
     * @param {string} value The entered temperature
     * @returns AtsuStatusCodes.Ok if the value is valid
     */
    static validateScratchpadTemperature(value) {
      if (/^[-+M]?[0-9]{1,3}[CF]?$/.test(value)) {
        const negative = value.startsWith("-") || value.startsWith("M");
        const fahrenheit = value.endsWith("F");
        let temperature = parseInt(value.match(/([0-9]+)/)[0]);
        if (negative) {
          temperature *= -1;
        }
        if (fahrenheit && temperature >= -105 && temperature <= 150) {
          return 0 /* Ok */;
        }
        if (!fahrenheit && (temperature >= 80 || temperature < 47)) {
          return 0 /* Ok */;
        }
        return 14 /* EntryOutOfRange */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Validates the wind data
     * @param {string} value The entered wind data
     * @returns AtsuStatusCodes.Ok if the value is valid
     */
    static validateScratchpadWind(value) {
      if (/^[0-9]{1,3}\/[0-9]{1,3}(KT|KM)?$/.test(value)) {
        const numbers = value.match(/([0-9]+)/g);
        const direction = parseInt(numbers[0]);
        const speed = parseInt(numbers[1]);
        if (direction < 1 || direction > 360 || speed < 0 || speed > 255) {
          return 14 /* EntryOutOfRange */;
        }
        return 0 /* Ok */;
      }
      return 15 /* FormatError */;
    }
    /**
     * Converts an FCOM valid encoded offset string to a list of offset entries
     * @param {string} offset Valid encoded offset
     * @returns The decoded offset entries
     */
    static decodeOffsetString(offset) {
      let nmUnit = true;
      let left = false;
      let distance;
      if (/^[LR][0-9]{1,3}(NM|KM)$/.test(offset) || /^[LR][0-9]{1,3}$/.test(offset)) {
        distance = offset.replace(/NM|KM/, "").replace(/L|R/, "");
        if (/(?!^\d+$)^.+$/.test(distance)) {
          return [];
        }
        distance = parseInt(distance);
        nmUnit = !offset.endsWith("KM");
        left = offset[0] === "L";
      } else if (/[0-9]{1,3}(NM|KM)[LR]/.test(offset) || /[0-9]{1,3}[LR]/.test(offset)) {
        distance = offset.replace(/NM|KM/, "").replace(/L|R/, "");
        if (/(?!^\d+$)^.+$/.test(distance)) {
          return null;
        }
        distance = parseInt(distance);
        nmUnit = !(offset.endsWith("KML") || offset.endsWith("KMR"));
        left = offset[offset.length - 1] === "L";
      }
      return [distance.toString(), nmUnit ? "NM" : "KM", left ? "L" : "R"];
    }
    /**
     * Formats a valid scratchpad offset to a normalized temperature entry
     * @param {string} value The entered temperature
     * @returns The formatted temperature
     */
    static formatScratchpadTemperature(value) {
      const negative = value.startsWith("-") || value.startsWith("M");
      const fahrenheit = value.endsWith("F");
      let temperature = parseInt(value.match(/([0-9]+)/)[0]);
      if (negative) {
        temperature *= -1;
      }
      return `${temperature}${fahrenheit ? "F" : "C"}`;
    }
    /**
     * Normalizes the wind data
     * @param {string} value The entered wind data
     * @returns The normalized wind data
     */
    static formatScratchpadWind(value) {
      const numbers = value.match(/([0-9]+)/g);
      const direction = parseInt(numbers[0]);
      const speed = parseInt(numbers[1]);
      const kilometers = value.endsWith("M");
      return `${direction.toString().padStart(3, "0")}/${speed.toString().padStart(3, "0")}${kilometers ? "KM" : "KT"}`;
    }
    /**
     * Formats a valid scratchpad offset to a normalized offset entry
     * @param {string} value The scratchpad entry
     * @returns The normalized offset entry
     */
    static formatScratchpadOffset(value) {
      const entries = _InputValidation.decodeOffsetString(value);
      return `${entries[0]}${entries[1]}${entries[2]}`;
    }
    /**
     * Formats a valid scratchpad endurance entry to a normalized offset entry
     * @param {string} value The scratchpad entry
     * @returns The normalized offset entry
     */
    static formatScratchpadEndurance(value) {
      const matches = value.match(/[0-9]{1,2}/g);
      const hours = parseInt(matches[0]);
      const minutes = parseInt(matches[1]);
      return `${hours}H${minutes}`;
    }
    /**
     * Expands a lateral offset encoded string into an expanded version
     * @param {string} offset The valid offset value
     * @returns The expanded lateral offset
     */
    static expandLateralOffset(offset) {
      const entries = _InputValidation.decodeOffsetString(offset);
      return `${entries[0]}${entries[1]} ${entries[2] === "L" ? "LEFT" : "RIGHT"}`;
    }
    /**
     * Formats a valid scratchpad distance entry to a normalized distance entry
     * @param {string} value The scratchpad entry
     * @returns The normalized distance entry
     */
    static formatScratchpadDistance(distance) {
      if (distance.endsWith("NM") || distance.endsWith("KM")) {
        return distance;
      }
      return `${distance}NM`;
    }
  };
  var InputValidation = _InputValidation;
  __publicField(InputValidation, "FANS", 0 /* FansNone */);

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/CpdlcMessageElements.ts
  var CpdlcMessageExpectedResponseType = /* @__PURE__ */ ((CpdlcMessageExpectedResponseType2) => {
    CpdlcMessageExpectedResponseType2["NotRequired"] = "NE";
    CpdlcMessageExpectedResponseType2["WilcoUnable"] = "WU";
    CpdlcMessageExpectedResponseType2["AffirmNegative"] = "AN";
    CpdlcMessageExpectedResponseType2["Roger"] = "R";
    CpdlcMessageExpectedResponseType2["No"] = "N";
    CpdlcMessageExpectedResponseType2["Yes"] = "Y";
    return CpdlcMessageExpectedResponseType2;
  })(CpdlcMessageExpectedResponseType || {});
  var CpdlcMessageContentType = /* @__PURE__ */ ((CpdlcMessageContentType2) => {
    CpdlcMessageContentType2[CpdlcMessageContentType2["Unknown"] = 0] = "Unknown";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Level"] = 1] = "Level";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Position"] = 2] = "Position";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Time"] = 3] = "Time";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Direction"] = 4] = "Direction";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Distance"] = 5] = "Distance";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Speed"] = 6] = "Speed";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Frequency"] = 7] = "Frequency";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Procedure"] = 8] = "Procedure";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Degree"] = 9] = "Degree";
    CpdlcMessageContentType2[CpdlcMessageContentType2["VerticalRate"] = 10] = "VerticalRate";
    CpdlcMessageContentType2[CpdlcMessageContentType2["LegType"] = 11] = "LegType";
    CpdlcMessageContentType2[CpdlcMessageContentType2["LegTypeDistance"] = 12] = "LegTypeDistance";
    CpdlcMessageContentType2[CpdlcMessageContentType2["LegTypeTime"] = 13] = "LegTypeTime";
    CpdlcMessageContentType2[CpdlcMessageContentType2["AtcUnit"] = 14] = "AtcUnit";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Squawk"] = 15] = "Squawk";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Altimeter"] = 16] = "Altimeter";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Atis"] = 17] = "Atis";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Fuel"] = 18] = "Fuel";
    CpdlcMessageContentType2[CpdlcMessageContentType2["PersonsOnBoard"] = 19] = "PersonsOnBoard";
    CpdlcMessageContentType2[CpdlcMessageContentType2["Freetext"] = 20] = "Freetext";
    return CpdlcMessageContentType2;
  })(CpdlcMessageContentType || {});
  var CpdlcMessageContent = class {
    constructor(type, ...args) {
      __publicField(this, "Type", 0 /* Unknown */);
      __publicField(this, "IndexStart", -1);
      __publicField(this, "IndexEnd", -1);
      __publicField(this, "Monitoring", false);
      __publicField(this, "Value", "");
      this.Type = type;
      args.forEach((arg) => {
        if (typeof arg === "number") {
          if (this.IndexStart === -1) {
            this.IndexStart = arg;
          } else {
            this.IndexEnd = arg;
          }
        } else if (typeof arg === "boolean") {
          this.Monitoring = arg;
        } else if (typeof arg === "string") {
          this.Value = arg;
        }
      });
    }
    static createInstance(type) {
      switch (type) {
        case 1 /* Level */:
          return new CpdlcMessageContentLevel(0);
        case 2 /* Position */:
          return new CpdlcMessageContentPosition(0);
        case 3 /* Time */:
          return new CpdlcMessageContentTime(0);
        case 4 /* Direction */:
          return new CpdlcMessageContentDirection(0);
        case 5 /* Distance */:
          return new CpdlcMessageContentDistance(0);
        case 6 /* Speed */:
          return new CpdlcMessageContentSpeed(0);
        case 7 /* Frequency */:
          return new CpdlcMessageContentFrequency(0);
        case 8 /* Procedure */:
          return new CpdlcMessageContentProcedure(0);
        case 9 /* Degree */:
          return new CpdlcMessageContentDegree(0);
        case 10 /* VerticalRate */:
          return new CpdlcMessageContentVerticalRate(0);
        case 11 /* LegType */:
          return new CpdlcMessageContentLegType(0);
        case 12 /* LegTypeDistance */:
          return new CpdlcMessageContentLegTypeDistance(0);
        case 13 /* LegTypeTime */:
          return new CpdlcMessageContentLegTypeTime(0);
        case 14 /* AtcUnit */:
          return new CpdlcMessageContentAtcUnit(0);
        case 15 /* Squawk */:
          return new CpdlcMessageContentSquawk(0);
        case 16 /* Altimeter */:
          return new CpdlcMessageContentAltimeter(0);
        case 17 /* Atis */:
          return new CpdlcMessageContentAtis(0);
        case 18 /* Fuel */:
          return new CpdlcMessageContentFuel(0);
        case 19 /* PersonsOnBoard */:
          return new CpdlcMessageContentPersonsOnBoard(0);
        case 20 /* Freetext */:
          return new CpdlcMessageContentFreetext(0, 0);
        default:
          return null;
      }
    }
    static deserialize(jsonData) {
      const retval = CpdlcMessageContent.createInstance(jsonData.Type);
      retval.Type = jsonData.Type;
      retval.IndexStart = jsonData.IndexStart;
      retval.IndexEnd = jsonData.IndexEnd;
      retval.Value = jsonData.Value;
      retval.Monitoring = jsonData.Monitoring;
      return retval;
    }
  };
  var CpdlcMessageContentLevel = class extends CpdlcMessageContent {
    constructor(...args) {
      super(1 /* Level */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        retval = InputValidation.validateScratchpadAltitude(value[this.IndexStart]) === 0 /* Ok */;
        if (retval) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
        }
      }
      if (!retval && this.IndexEnd < value.length && this.IndexEnd > -1) {
        retval = InputValidation.validateScratchpadAltitude(value[this.IndexEnd]) === 0 /* Ok */;
        if (retval) {
          this.Value = value[this.IndexEnd];
          value[this.IndexEnd] = "%s";
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentPosition = class extends CpdlcMessageContent {
    constructor(...args) {
      super(2 /* Position */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadWaypoint(value[this.IndexStart]) === 0 /* Ok */ && InputValidation.validateScratchpadTime(value[this.IndexStart], true) !== 0 /* Ok */ && InputValidation.validateScratchpadTime(value[this.IndexStart], false) !== 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentTime = class extends CpdlcMessageContent {
    constructor(...args) {
      super(3 /* Time */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadTime(value[this.IndexStart], true) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        } else if (InputValidation.validateScratchpadTime(value[this.IndexStart], false) === 0 /* Ok */) {
          this.Value = `${value[this.IndexStart]}Z`;
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentDirection = class extends CpdlcMessageContent {
    constructor(...args) {
      super(4 /* Direction */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (value[this.IndexStart] === "LEFT" || value[this.IndexStart] === "RIGHT") {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentDistance = class extends CpdlcMessageContent {
    constructor(...args) {
      super(5 /* Distance */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadDistance(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentSpeed = class extends CpdlcMessageContent {
    constructor(...args) {
      super(6 /* Speed */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadSpeed(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentFrequency = class extends CpdlcMessageContent {
    constructor(...args) {
      super(7 /* Frequency */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateVhfFrequency(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentProcedure = class extends CpdlcMessageContent {
    constructor(...args) {
      super(8 /* Procedure */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadProcedure(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentDegree = class extends CpdlcMessageContent {
    constructor(...args) {
      super(9 /* Degree */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (InputValidation.validateScratchpadDegree(value[this.IndexStart]) === 0 /* Ok */) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentVerticalRate = class extends CpdlcMessageContent {
    constructor(...args) {
      super(10 /* VerticalRate */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart + 3 < value.length && this.IndexStart > -1) {
        if (value[this.IndexStart + 1] === "FEET" && value[this.IndexStart + 2] === "PER" && value[this.IndexStart + 3] === "MINUTE") {
          this.Value = `${value[this.IndexStart]} FEET PER MINUTE`;
          value[this.IndexStart] = "%s";
          value.slice(this.IndexStart + 1, 3);
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentAtcUnit = class extends CpdlcMessageContent {
    constructor(...args) {
      super(14 /* AtcUnit */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (this.IndexStart + 1 < value.length && value[this.IndexStart + 1] === "CTR") {
          this.Value = `${value[this.IndexStart]} ${value[this.IndexStart + 1]}`;
          value.splice(this.IndexStart + 1, 1);
        } else {
          this.Value = value[this.IndexStart];
        }
        value[this.IndexStart] = "%s";
        retval = true;
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentSquawk = class extends CpdlcMessageContent {
    constructor(...args) {
      super(15 /* Squawk */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1 && /^[0-9]{4}$/.test(value[this.IndexStart])) {
        const squawk = parseInt(value[this.IndexStart]);
        if (squawk >= 0 && squawk < 7777) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentFreetext = class extends CpdlcMessageContent {
    constructor(...args) {
      super(20 /* Freetext */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        this.Value = value.slice(this.IndexStart, this.IndexEnd === -1 ? value.length : this.IndexEnd + 1).join(" ");
        value = value.slice(0, this.IndexStart);
        value.push("%s");
        retval = true;
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentLegTypeDistance = class extends CpdlcMessageContent {
    constructor(...args) {
      super(12 /* LegTypeDistance */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[0-9]{1,2}$/.test(value[this.IndexStart])) {
          const distance = parseInt(value[this.IndexStart]);
          if (distance >= 1 && distance < 100) {
            this.Value = value[this.IndexStart];
            value[this.IndexStart] = "%s";
            retval = true;
          }
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentLegTypeTime = class extends CpdlcMessageContent {
    constructor(...args) {
      super(13 /* LegTypeTime */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart + 1 < value.length && this.IndexStart > -1 && /^[0-9]{1}$/.test(value[this.IndexStart])) {
        if (value[this.IndexStart + 1] === "MIN" || value[this.IndexStart + 1] === "MINS" || value[this.IndexStart + 1] === "MINUTES") {
          const minutes = parseInt(value[this.IndexStart]);
          if (minutes >= 1 && minutes < 10) {
            this.Value = value[this.IndexStart];
            value[this.IndexStart] = "%s";
            retval = true;
          }
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentLegType = class extends CpdlcMessageContent {
    constructor(...args) {
      super(11 /* LegType */, ...args);
      __publicField(this, "legDistance");
      __publicField(this, "legTime");
      this.legDistance = new CpdlcMessageContentLegTypeDistance(...args);
      this.legTime = new CpdlcMessageContentLegTypeTime(...args);
    }
    validateAndReplaceContent(value) {
      const legTimeRetval = this.legTime.validateAndReplaceContent(value);
      if (legTimeRetval.matched === true) {
        return legTimeRetval;
      }
      return this.legDistance.validateAndReplaceContent(value);
    }
  };
  var CpdlcMessageContentAltimeter = class extends CpdlcMessageContent {
    constructor(...args) {
      super(16 /* Altimeter */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart >= 1 && this.IndexStart < value.length && this.IndexStart > -1) {
        if (value[this.IndexStart - 1] === "ALTIMETER" && /^[0-9]{2}\.[0-9]{2}$/.test(value[this.IndexStart])) {
          retval = true;
        } else if (value[this.IndexStart - 1] === "QNH" && /^[0-9]{3,4}$/.test(value[this.IndexStart])) {
          retval = true;
        }
        if (retval === true) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentAtis = class extends CpdlcMessageContent {
    constructor(...args) {
      super(17 /* Atis */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[A-Z]{1}$/.test(value[this.IndexStart])) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentFuel = class extends CpdlcMessageContent {
    constructor(...args) {
      super(18 /* Fuel */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[0-9]{1,6}$/.test(value[this.IndexStart])) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageContentPersonsOnBoard = class extends CpdlcMessageContent {
    constructor(...args) {
      super(19 /* PersonsOnBoard */, ...args);
    }
    validateAndReplaceContent(value) {
      let retval = false;
      if (this.IndexStart < value.length && this.IndexStart > -1) {
        if (/^[0-9]{1,3}$/.test(value[this.IndexStart])) {
          this.Value = value[this.IndexStart];
          value[this.IndexStart] = "%s";
          retval = true;
        }
      }
      return { matched: retval, remaining: value };
    }
  };
  var CpdlcMessageElement = class {
    constructor(typeId, ...args) {
      __publicField(this, "TypeId", "");
      __publicField(this, "FansModes", []);
      __publicField(this, "Urgent", false);
      __publicField(this, "Content", []);
      __publicField(this, "ExpectedResponse", "N" /* No */);
      this.TypeId = typeId;
      args.forEach((arg) => {
        if (arg instanceof Array && arg[0] instanceof CpdlcMessageContent)
          this.Content = arg;
        else if (typeof arg === "boolean")
          this.Urgent = arg;
        else if (arg instanceof Array)
          this.FansModes = arg;
        else if (typeof arg === "string")
          this.ExpectedResponse = arg;
        else
          console.log(`Unknown arg: ${arg}, type: ${typeof arg}`);
      });
    }
    deepCopy() {
      const instance = new CpdlcMessageElement(this.TypeId, this.FansModes, this.Urgent, this.ExpectedResponse);
      this.Content.forEach((entry) => {
        instance.Content.push(CpdlcMessageContent.createInstance(entry.Type));
        instance.Content[instance.Content.length - 1].IndexStart = entry.IndexStart;
        instance.Content[instance.Content.length - 1].IndexEnd = entry.IndexEnd;
        instance.Content[instance.Content.length - 1].Value = entry.Value;
        instance.Content[instance.Content.length - 1].Monitoring = entry.Monitoring;
      });
      return instance;
    }
    static deserialize(jsonData) {
      const retval = new CpdlcMessageElement(jsonData.TypeId);
      retval.TypeId = jsonData.TypeId;
      retval.FansModes = jsonData.FansModes;
      retval.Urgent = jsonData.Urgent;
      jsonData.Content.forEach((entry) => retval.Content.push(CpdlcMessageContent.deserialize(entry)));
      retval.ExpectedResponse = jsonData.ExpectedResponse;
      return retval;
    }
  };
  var CpdlcMessagesDownlink = {
    DM0: [["WILCO"], new CpdlcMessageElement("DM0", [1 /* FansA */, 2 /* FansB */])],
    DM1: [["UNABLE"], new CpdlcMessageElement("DM1", [1 /* FansA */, 2 /* FansB */])],
    DM2: [["STANDBY"], new CpdlcMessageElement("DM2", [1 /* FansA */, 2 /* FansB */])],
    DM3: [["ROGER"], new CpdlcMessageElement("DM3", [1 /* FansA */, 2 /* FansB */])],
    DM4: [["AFFIRM"], new CpdlcMessageElement("DM4", [1 /* FansA */, 2 /* FansB */])],
    DM5: [["NEGATIVE"], new CpdlcMessageElement("DM5", [1 /* FansA */, 2 /* FansB */])],
    DM6: [["REQUEST %s"], new CpdlcMessageElement("DM6", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(1)], "Y" /* Yes */)],
    DM7: [["REQUEST BLOCK %s TO %s"], new CpdlcMessageElement(
      "DM7",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2), new CpdlcMessageContentLevel(4)],
      "Y" /* Yes */
    )],
    DM8: [["REQUEST CRUISE CLIMB TO %s"], new CpdlcMessageElement("DM8", [1 /* FansA */], [new CpdlcMessageContentLevel(4)], "Y" /* Yes */)],
    DM9: [["REQUEST CLIMB TO %s"], new CpdlcMessageElement("DM9", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(3)], "Y" /* Yes */)],
    DM10: [["REQUEST DESCEND TO %s"], new CpdlcMessageElement("DM10", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(3)], "Y" /* Yes */)],
    DM11: [["AT %s REQUEST CLIMB TO %s"], new CpdlcMessageElement(
      "DM11",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM12: [["AT %s REQUEST DESCEND TO %s"], new CpdlcMessageElement(
      "DM12",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM13: [["AT %s REQUEST CLIMB TO %s"], new CpdlcMessageElement(
      "DM13",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM14: [["AT %s REQUEST DESCEND TO %s"], new CpdlcMessageElement(
      "DM14",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentLevel(5)],
      "Y" /* Yes */
    )],
    DM15: [["REQUEST OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM15",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(2), new CpdlcMessageContentDirection(3)],
      "Y" /* Yes */
    )],
    DM16: [["AT %s REQUEST OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM16",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentDistance(4), new CpdlcMessageContentDirection(5)],
      "Y" /* Yes */
    )],
    DM17: [["AT %s REQUEST OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM17",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentDistance(4), new CpdlcMessageContentDirection(5)],
      "Y" /* Yes */
    )],
    DM18: [["REQUEST %s"], new CpdlcMessageElement("DM18", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "Y" /* Yes */)],
    DM19: [["REQUEST %s TO %s"], new CpdlcMessageElement("DM19", [1 /* FansA */], [new CpdlcMessageContentSpeed(1), new CpdlcMessageContentSpeed(3)], "Y" /* Yes */)],
    DM20: [["REQUEST VOICE CONTACT"], new CpdlcMessageElement("DM20", [1 /* FansA */], "Y" /* Yes */)],
    DM21: [["REQUEST VOICE CONTACT %s"], new CpdlcMessageElement("DM21", [1 /* FansA */], [new CpdlcMessageContentFrequency(3)], "Y" /* Yes */)],
    DM22: [["REQUEST DIRECT TO %s"], new CpdlcMessageElement("DM22", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentPosition(3)], "Y" /* Yes */)],
    DM23: [["REQUEST %s"], new CpdlcMessageElement("DM23", [1 /* FansA */], [new CpdlcMessageContentProcedure(1)], "Y" /* Yes */)],
    DM25: [["REQUEST %s CLEARANCE"], new CpdlcMessageElement("DM25", [1 /* FansA */], [new CpdlcMessageContentFreetext(1, 2)], "Y" /* Yes */)],
    DM26: [["REQUEST WEATHER DEVIATION TO %s VIA %s"], new CpdlcMessageElement(
      "DM26",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(4), new CpdlcMessageContentFreetext(6, -1)],
      "Y" /* Yes */
    )],
    DM27: [["REQUEST WEATHER DEVIATION UP TO %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM27",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDistance(5), new CpdlcMessageContentDirection(6)],
      "Y" /* Yes */
    )],
    DM28: [["LEAVING %s"], new CpdlcMessageElement("DM28", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "N" /* No */)],
    DM29: [["CLIMBING TO %s"], new CpdlcMessageElement("DM29", [1 /* FansA */], [new CpdlcMessageContentLevel(2)], "N" /* No */)],
    DM30: [["DESCENDING TO %s"], new CpdlcMessageElement("DM30", [1 /* FansA */], [new CpdlcMessageContentLevel(2)], "N" /* No */)],
    DM31: [["PASSING %s"], new CpdlcMessageElement("DM31", [1 /* FansA */], [new CpdlcMessageContentPosition(1)], "N" /* No */)],
    DM32: [["PRESENT LEVEL %s"], new CpdlcMessageElement(
      "DM32",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2)],
      "N" /* No */
    )],
    DM33: [["PRESENT POSITION %s"], new CpdlcMessageElement("DM33", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM34: [["PRESENT SPEED %s"], new CpdlcMessageElement("DM34", [1 /* FansA */], [new CpdlcMessageContentSpeed(2)], "N" /* No */)],
    DM35: [["PRESENT HEADING %s"], new CpdlcMessageElement("DM35", [1 /* FansA */], [new CpdlcMessageContentDegree(2)], "N" /* No */)],
    DM36: [["PRESENT GROUND TRACK %s"], new CpdlcMessageElement("DM36", [1 /* FansA */], [new CpdlcMessageContentDegree(3)], "N" /* No */)],
    DM37: [["MAINTAINING %s", "LEVEL %s"], new CpdlcMessageElement("DM37", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "N" /* No */)],
    DM38: [["ASSIGNED LEVEL %s"], new CpdlcMessageElement(
      "DM38",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2)],
      "N" /* No */
    )],
    DM39: [["ASSIGNED SPEED %s"], new CpdlcMessageElement("DM39", [1 /* FansA */], [new CpdlcMessageContentSpeed(2)], "N" /* No */)],
    DM40: [["ASSIGNED ROUTE %s"], new CpdlcMessageElement("DM40", [1 /* FansA */], [new CpdlcMessageContentFreetext(2, -1)], "N" /* No */)],
    DM41: [["BACK ON ROUTE"], new CpdlcMessageElement("DM41", [1 /* FansA */], "N" /* No */)],
    DM42: [["NEXT WAYPOINT %s"], new CpdlcMessageElement("DM42", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM43: [["NEXT WAYPOINT ETA %s"], new CpdlcMessageElement("DM43", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "N" /* No */)],
    DM44: [["ENSUING WAYPOINT %s"], new CpdlcMessageElement("DM44", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM45: [["REPORTED WAYPOINT %s"], new CpdlcMessageElement("DM45", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "N" /* No */)],
    DM46: [["REPORTED WAYPOINT %s"], new CpdlcMessageElement("DM46", [1 /* FansA */], [new CpdlcMessageContentTime(2)], "N" /* No */)],
    DM47: [["SQUAWKING %s"], new CpdlcMessageElement("DM47", [1 /* FansA */], [new CpdlcMessageContentSquawk(1)], "N" /* No */)],
    DM48: [["POSITION REPORT"], new CpdlcMessageElement("DM48", [1 /* FansA */], "R" /* Roger */)],
    DM49: [["WHEN CAN WE EXPECT %s"], new CpdlcMessageElement("DM49", [1 /* FansA */], [new CpdlcMessageContentSpeed(4)], "Y" /* Yes */)],
    DM50: [["WHEN CAN WE EXPECT %s TO %s"], new CpdlcMessageElement(
      "DM50",
      [1 /* FansA */],
      [new CpdlcMessageContentSpeed(4), new CpdlcMessageContentSpeed(6)],
      "Y" /* Yes */
    )],
    DM51: [["WHEN CAN WE EXPECT BACK ON ROUTE"], new CpdlcMessageElement("DM51", [1 /* FansA */], "Y" /* Yes */)],
    DM52: [["WHEN CAN WE EXPECT LOWER LEVEL"], new CpdlcMessageElement("DM52", [1 /* FansA */], "Y" /* Yes */)],
    DM53: [["WHEN CAN WE EXPECT HIGHER LEVEL"], new CpdlcMessageElement("DM53", [1 /* FansA */], "Y" /* Yes */)],
    DM54: [["WHEN CAN WE EXPECT CRUISE CLIMB TO %s"], new CpdlcMessageElement("DM54", [1 /* FansA */], [new CpdlcMessageContentLevel(7)], "Y" /* Yes */)],
    DM55: [["PAN PAN PAN"], new CpdlcMessageElement("DM55", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */, true)],
    DM56: [["MAYDAY MAYDAY MAYDAY"], new CpdlcMessageElement("DM56", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */, true)],
    DM57: [["%s FUEL REMAINING AND %s PERSONS ON BOARD"], new CpdlcMessageElement(
      "DM57",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentFuel(0), new CpdlcMessageContentPersonsOnBoard(4)],
      "Y" /* Yes */,
      true
    )],
    DM58: [["CANCEL EMERGENCY"], new CpdlcMessageElement("DM58", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */, true)],
    DM59: [["DIVERTING TO %s VIA %s"], new CpdlcMessageElement(
      "DM59",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentFreetext(4, -1)],
      "Y" /* Yes */,
      true
    )],
    DM60: [["OFFSETTING %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM60",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDistance(1), new CpdlcMessageContentDirection(2)],
      "Y" /* Yes */,
      true
    )],
    DM61: [["DESCENDING TO %s"], new CpdlcMessageElement("DM61", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(2)], "Y" /* Yes */, true)],
    DM62: [["ERROR %s"], new CpdlcMessageElement("DM62", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "Y" /* Yes */, true)],
    DM63: [["NOT CURRENT DATA AUTHORITY"], new CpdlcMessageElement("DM63", [1 /* FansA */, 2 /* FansB */], "N" /* No */)],
    DM65: [["DUE TO WEATHER"], new CpdlcMessageElement("DM65", [1 /* FansA */, 2 /* FansB */], "N" /* No */)],
    DM66: [["DUE TO AIRCRAFT PERFORMANCE"], new CpdlcMessageElement("DM66", [1 /* FansA */, 2 /* FansB */], "N" /* No */)],
    DM67: [["%s"], new CpdlcMessageElement("DM67", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(0, -1)], "N" /* No */)],
    DM68: [["%s"], new CpdlcMessageElement("DM68", [1 /* FansA */], true, [new CpdlcMessageContentFreetext(0, -1)], "Y" /* Yes */)],
    DM69: [["REQUEST VMC DESCEND"], new CpdlcMessageElement("DM69", [1 /* FansA */], "Y" /* Yes */)],
    DM70: [["REQUEST HEADING %s"], new CpdlcMessageElement("DM70", [1 /* FansA */], [new CpdlcMessageContentDegree(2)], "Y" /* Yes */)],
    DM71: [["REQUEST GROUND TRACK %s"], new CpdlcMessageElement("DM71", [1 /* FansA */], [new CpdlcMessageContentDegree(3)], "Y" /* Yes */)],
    DM72: [["REACHING %s"], new CpdlcMessageElement("DM72", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "Y" /* Yes */)],
    DM74: [["REQUEST TO MAINTAIN OWN SEPARATION AND VMC"], new CpdlcMessageElement("DM74", [1 /* FansA */], "Y" /* Yes */)],
    DM75: [["AT PILOTS DISCRETION"], new CpdlcMessageElement("DM75", [1 /* FansA */], "Y" /* Yes */)],
    DM76: [["REACHING BLOCK %s TO %s"], new CpdlcMessageElement(
      "DM76",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2), new CpdlcMessageContentLevel(4)],
      "N" /* No */
    )],
    DM78: [["AT %s %s TO %s", "AT %s %s FROM %s"], new CpdlcMessageElement(
      "DM78",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentDistance(2), new CpdlcMessageContentPosition(4)],
      "N" /* No */
    )],
    DM79: [["ATIS %s"], new CpdlcMessageElement("DM79", [1 /* FansA */], [new CpdlcMessageContentAtis(1)], "N" /* No */)],
    DM80: [["DEVIATING UP TO %s %s OF ROUTE"], new CpdlcMessageElement(
      "DM80",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "Y" /* Yes */,
      true
    )],
    DM81: [["WE CAN ACCEPT %s AT %s"], new CpdlcMessageElement(
      "DM81",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "N" /* No */
    )],
    DM82: [["WE CANNOT ACCEPT %s"], new CpdlcMessageElement("DM82", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(3)], "N" /* No */)],
    DM83: [["WE CAN ACCEPT %s AT %s"], new CpdlcMessageElement(
      "DM83",
      [1 /* FansA */],
      [new CpdlcMessageContentSpeed(3), new CpdlcMessageContentTime(5)],
      "N" /* No */
    )],
    DM84: [["WE CANNOT ACCEPT %s"], new CpdlcMessageElement("DM84", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "N" /* No */)],
    DM85: [["WE CAN ACCEPT %s %s AT %s"], new CpdlcMessageElement(
      "DM85",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4), new CpdlcMessageContentTime(6)],
      "N" /* No */
    )],
    DM86: [["WE CANNOT ACCEPT %s %s"], new CpdlcMessageElement(
      "DM86",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "N" /* No */
    )],
    DM87: [["WHEN CAN WE EXPECT CLIMB TO %s"], new CpdlcMessageElement("DM87", [1 /* FansA */], [new CpdlcMessageContentLevel(6)], "Y" /* Yes */)],
    DM88: [["WHEN CAN WE EXPECT DESCEND TO %s"], new CpdlcMessageElement("DM88", [1 /* FansA */], [new CpdlcMessageContentLevel(6)], "Y" /* Yes */)],
    DM89: [["MONITORING %s %s"], new CpdlcMessageElement(
      "DM89",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentAtcUnit(1), new CpdlcMessageContentFrequency(2)],
      "N" /* No */
    )],
    DM98: [["%s"], new CpdlcMessageElement("DM98", [2 /* FansB */], [new CpdlcMessageContentFreetext(0, -1)], "N" /* No */)],
    DM99: [["CURRENT DATA AUTHORITY"], new CpdlcMessageElement("DM99", [1 /* FansA */, 2 /* FansB */], "N" /* No */, true)],
    DM100: [["LOGICAL ACKNOWLEDGEMENT"], new CpdlcMessageElement("DM100", [2 /* FansB */], "N" /* No */)],
    DM104: [["ETA %s %s"], new CpdlcMessageElement("DM104", [1 /* FansA */], [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(2)], "N" /* No */)],
    DM106: [["PREFERRED LEVEL %s"], new CpdlcMessageElement("DM106", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(2)], "N" /* No */)],
    DM107: [["NOT AUTHORIZED NEXT DATA AUTHORITY"], new CpdlcMessageElement("DM107", [2 /* FansB */], "N" /* No */)],
    DM109: [["TOP OF DESCENT %s"], new CpdlcMessageElement("DM109", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentTime(3)], "N" /* No */)],
    DM113: [["SPEED %s"], new CpdlcMessageElement("DM113", [1 /* FansA */], [new CpdlcMessageContentSpeed(1)], "N" /* No */)],
    DM9998: [["REQUEST LOGON"], new CpdlcMessageElement("DM9998", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    DM9999: [["LOGOFF"], new CpdlcMessageElement("DM9999", [1 /* FansA */, 2 /* FansB */], "N" /* No */)]
  };
  var CpdlcMessagesUplink = {
    UM0: [["UNABLE"], new CpdlcMessageElement("UM0", [1 /* FansA */, 2 /* FansB */])],
    UM1: [["STANDBY"], new CpdlcMessageElement("UM1", [1 /* FansA */, 2 /* FansB */])],
    UM3: [["ROGER"], new CpdlcMessageElement("UM3", [1 /* FansA */, 2 /* FansB */])],
    UM4: [["AFFIRM"], new CpdlcMessageElement("UM4", [1 /* FansA */, 2 /* FansB */])],
    UM5: [["NEGATIVE"], new CpdlcMessageElement("UM5", [1 /* FansA */, 2 /* FansB */])],
    UM6: [["EXPECT %s"], new CpdlcMessageElement("UM6", [1 /* FansA */], [new CpdlcMessageContentLevel(1)], "R" /* Roger */)],
    UM7: [["EXPECT CLIMB AT %s"], new CpdlcMessageElement("UM7", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "R" /* Roger */)],
    UM8: [["EXPECT CLIMB AT %s"], new CpdlcMessageElement("UM8", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "R" /* Roger */)],
    UM9: [["EXPECT DESCENT AT %s"], new CpdlcMessageElement("UM9", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "R" /* Roger */)],
    UM10: [["EXPECT DESCENT AT %s"], new CpdlcMessageElement("UM10", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "R" /* Roger */)],
    UM11: [["EXPECT CRUISE CLIMB AT %s"], new CpdlcMessageElement("UM11", [1 /* FansA */], [new CpdlcMessageContentTime(4)], "R" /* Roger */)],
    UM12: [["EXPECT CRUISE CLIMB AT %s"], new CpdlcMessageElement("UM12", [1 /* FansA */], [new CpdlcMessageContentPosition(4)], "R" /* Roger */)],
    UM19: [["MAINTAIN %s"], new CpdlcMessageElement(
      "UM19",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(1)],
      "WU" /* WilcoUnable */
    )],
    UM20: [["CLIMB TO %s", "CLIMB TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM20",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2, 4)],
      "WU" /* WilcoUnable */
    )],
    UM21: [["AT %s CLIMB TO %s", "AT %s CLIMB TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM21",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM22: [["AT %s CLIMB TO %s", "AT %s CLIMB TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM22",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM23: [["DESCEND TO %s", "DESCEND TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM23",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2, 4)],
      "WU" /* WilcoUnable */
    )],
    UM24: [["AT %s DESCEND TO %s", "AT %s DESCEND TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM24",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM25: [["AT %s DESCEND TO %s", "AT %s DESCEND TO AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM25",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentLevel(4, 6)],
      "WU" /* WilcoUnable */
    )],
    UM26: [["CLIMB TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM26",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM27: [["CLIMB TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM27",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM28: [["DESCEND TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM28",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM29: [["DESCEND TO REACH %s BY %s"], new CpdlcMessageElement(
      "UM29",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM30: [["MAINTAIN BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM30",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(2), new CpdlcMessageContentLevel(4)],
      "WU" /* WilcoUnable */
    )],
    UM31: [["CLIMB TO MAINTAIN BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM31",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(4), new CpdlcMessageContentLevel(6)],
      "WU" /* WilcoUnable */
    )],
    UM32: [["DESCEND TO MAINTAIN BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM32",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentLevel(4), new CpdlcMessageContentLevel(6)],
      "WU" /* WilcoUnable */
    )],
    UM34: [["CRUISE CLIMB TO %s"], new CpdlcMessageElement("UM34", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */)],
    UM35: [["WHEN ABOVE %s COMMENCE CRUISE CLIMB", "CRUISE CLIMB ABOVE %s"], new CpdlcMessageElement(
      "UM35",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2, 3)],
      "WU" /* WilcoUnable */
    )],
    UM36: [["EXPEDITE CLIMB TO %s"], new CpdlcMessageElement("UM36", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM37: [["EXPEDITE DESCENT TO %s"], new CpdlcMessageElement("UM37", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM38: [["IMMEDIATELY CLIMB TO %s"], new CpdlcMessageElement("UM38", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM39: [["IMMEDIATELY DESCEND TO %s"], new CpdlcMessageElement("UM39", [1 /* FansA */], [new CpdlcMessageContentLevel(3)], "WU" /* WilcoUnable */, true)],
    UM46: [["CROSS %s AT %s"], new CpdlcMessageElement(
      "UM46",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(3)],
      "WU" /* WilcoUnable */
    )],
    UM47: [["CROSS %s AT OR ABOVE %s"], new CpdlcMessageElement(
      "UM47",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM48: [["CROSS %s AT OR BELOW %s"], new CpdlcMessageElement(
      "UM48",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM49: [["CROSS %s AT AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM49",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM50: [["CROSS %s BETWEEN %s AND %s"], new CpdlcMessageElement(
      "UM50",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(3), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM51: [["CROSS %s AT %s"], new CpdlcMessageElement(
      "UM51",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(3)],
      "WU" /* WilcoUnable */
    )],
    UM52: [["CROSS %s AT OR BEFORE %s"], new CpdlcMessageElement(
      "UM52",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM53: [["CROSS %s AT OR AFTER %s"], new CpdlcMessageElement(
      "UM53",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM54: [["CROSS %s BETWEEN %s AND %s"], new CpdlcMessageElement(
      "UM54",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(3), new CpdlcMessageContentTime(5)],
      "WU" /* WilcoUnable */
    )],
    UM55: [["CROSS %s AT %s"], new CpdlcMessageElement(
      "UM55",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(3)],
      "WU" /* WilcoUnable */
    )],
    UM56: [["CROSS %s AT OR LESS THAN %s"], new CpdlcMessageElement(
      "UM56",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(6)],
      "WU" /* WilcoUnable */
    )],
    UM57: [["CROSS %s AT OR GREATER THAN %s"], new CpdlcMessageElement(
      "UM57",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(6)],
      "WU" /* WilcoUnable */
    )],
    UM58: [["CROSS %s AT %s AT %s"], new CpdlcMessageElement(
      "UM58",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(3), new CpdlcMessageContentLevel(5)],
      "WU" /* WilcoUnable */
    )],
    UM59: [["CROSS %s AT OR BEFORE %s AT %s"], new CpdlcMessageElement(
      "UM59",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5), new CpdlcMessageContentLevel(7)],
      "WU" /* WilcoUnable */
    )],
    UM60: [["CROSS %s AT OR AFTER %s AT %s"], new CpdlcMessageElement(
      "UM60",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentTime(5), new CpdlcMessageContentLevel(7)],
      "WU" /* WilcoUnable */
    )],
    UM61: [["CROSS %s AT AND MAINTAIN %s AT %s"], new CpdlcMessageElement(
      "UM61",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentLevel(5), new CpdlcMessageContentSpeed(7)],
      "WU" /* WilcoUnable */
    )],
    UM62: [["AT %s CROSS %s AT AND MAINTAIN %s"], new CpdlcMessageElement(
      "UM62",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentPosition(3), new CpdlcMessageContentLevel(7)],
      "WU" /* WilcoUnable */
    )],
    UM63: [["AT %s CROSS %s AT AND MAINTAIN %s AT %s"], new CpdlcMessageElement(
      "UM63",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentPosition(3), new CpdlcMessageContentLevel(7), new CpdlcMessageContentSpeed(9)],
      "WU" /* WilcoUnable */
    )],
    UM64: [["OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM64",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDistance(1), new CpdlcMessageContentDirection(2)],
      "WU" /* WilcoUnable */
    )],
    UM65: [["AT %s OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM65",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "WU" /* WilcoUnable */
    )],
    UM66: [["AT %s OFFSET %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM66",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentDistance(3), new CpdlcMessageContentDirection(4)],
      "WU" /* WilcoUnable */
    )],
    UM67: [["PROCEED BACK ON ROUTE"], new CpdlcMessageElement("UM67", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM68: [["REJOIN ROUTE BY %s"], new CpdlcMessageElement("UM68", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "WU" /* WilcoUnable */)],
    UM69: [["REJOIN ROUTE BY %s"], new CpdlcMessageElement("UM69", [1 /* FansA */], [new CpdlcMessageContentTime(3)], "WU" /* WilcoUnable */)],
    UM70: [["EXPECT BACK ON ROUTE BY %s"], new CpdlcMessageElement("UM70", [1 /* FansA */], [new CpdlcMessageContentPosition(5)], "WU" /* WilcoUnable */)],
    UM71: [["EXPECT BACK ON ROUTE BY %s"], new CpdlcMessageElement("UM71", [1 /* FansA */], [new CpdlcMessageContentTime(5)], "WU" /* WilcoUnable */)],
    UM72: [["RESUME OWN NAVIGATION"], new CpdlcMessageElement("UM72", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    // UM73 for clearance skipped -> needs to be handled in DCL manager
    UM74: [["PROCEED DIRECT TO %s"], new CpdlcMessageElement("UM74", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentPosition(3)], "WU" /* WilcoUnable */)],
    UM75: [["WHEN ABLE PROCEED DIRECT TO %s"], new CpdlcMessageElement("UM75", [1 /* FansA */], [new CpdlcMessageContentPosition(5)], "WU" /* WilcoUnable */)],
    UM76: [["AT %s PROCEED DIRECT TO %s"], new CpdlcMessageElement(
      "UM76",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM77: [["AT %s PROCEED DIRECT TO %s"], new CpdlcMessageElement(
      "UM77",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM78: [["AT %s PROCEED DIRECT TO %s"], new CpdlcMessageElement(
      "UM78",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1, true), new CpdlcMessageContentPosition(5)],
      "WU" /* WilcoUnable */
    )],
    UM79: [["CLEARED TO %s VIA %s"], new CpdlcMessageElement(
      "UM79",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentFreetext(4, -1)],
      "WU" /* WilcoUnable */
    )],
    UM80: [["CLEARED %s"], new CpdlcMessageElement("UM80", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "WU" /* WilcoUnable */)],
    UM81: [["CLEARED %s"], new CpdlcMessageElement("UM81", [1 /* FansA */], [new CpdlcMessageContentProcedure(1)], "WU" /* WilcoUnable */)],
    UM82: [["CLEARED TO DEVIATE UP TO %s %s OF ROUTE"], new CpdlcMessageElement(
      "UM82",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDirection(5), new CpdlcMessageContentDistance(6)],
      "WU" /* WilcoUnable */
    )],
    UM83: [["AT %s CLEARED %s"], new CpdlcMessageElement(
      "UM83",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentFreetext(3, -1)],
      "WU" /* WilcoUnable */
    )],
    UM84: [["AT %s CLEARED %s"], new CpdlcMessageElement(
      "UM84",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentProcedure(3)],
      "WU" /* WilcoUnable */
    )],
    UM85: [["EXPECT %s"], new CpdlcMessageElement("UM85", [1 /* FansA */], [new CpdlcMessageContentFreetext(1, -1)], "R" /* Roger */)],
    UM86: [["AT %s EXPECT %s"], new CpdlcMessageElement(
      "UM86",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentFreetext(3, -1)],
      "R" /* Roger */
    )],
    UM87: [["EXPECT DIRECT TO %s"], new CpdlcMessageElement("UM87", [1 /* FansA */], [new CpdlcMessageContentPosition(3)], "R" /* Roger */)],
    UM88: [["AT %s EXPECT DIRECT TO %s"], new CpdlcMessageElement(
      "UM88",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentPosition(5)],
      "R" /* Roger */
    )],
    UM89: [["AT %s EXPECT DIRECT TO %s"], new CpdlcMessageElement(
      "UM89",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentPosition(5)],
      "R" /* Roger */
    )],
    UM90: [["AT %s EXPECT DIRECT TO %s"], new CpdlcMessageElement(
      "UM90",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1), new CpdlcMessageContentPosition(5)],
      "R" /* Roger */
    )],
    UM91: [["HOLD AT %s MAINTAIN %s INBOUND TRACK %s %s TURNS %s", "HOLD AT %s MAINTAIN %s INBOUND TRACK %s %s TURN LEG TIME %s"], new CpdlcMessageElement(
      "UM91",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentLevel(4), new CpdlcMessageContentDegree(7), new CpdlcMessageContentDirection(8), new CpdlcMessageContentLegType(12)],
      "WU" /* WilcoUnable */
    )],
    UM92: [["HOLD AT %s AS PUBLISHED MAINTAIN %s"], new CpdlcMessageElement(
      "UM92",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(2), new CpdlcMessageContentLevel(6)],
      "WU" /* WilcoUnable */
    )],
    UM93: [["EXPECT FURTHER CLEARANCE AT %s"], new CpdlcMessageElement("UM93", [1 /* FansA */], [new CpdlcMessageContentTime(4)], "R" /* Roger */)],
    UM94: [["TURN %s HEADING %s"], new CpdlcMessageElement(
      "UM94",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentDirection(1), new CpdlcMessageContentDegree(3)],
      "WU" /* WilcoUnable */
    )],
    UM95: [["TURN %s GROUND TRACK %s"], new CpdlcMessageElement(
      "UM95",
      [1 /* FansA */],
      [new CpdlcMessageContentDirection(1), new CpdlcMessageContentDegree(4)],
      "WU" /* WilcoUnable */
    )],
    UM96: [["CONTINUE PRESENT HEADING", "FLY PRESENT HEADING"], new CpdlcMessageElement("UM96", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM97: [["AT %s FLY HEADING %s"], new CpdlcMessageElement(
      "UM97",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentDegree(4)],
      "WU" /* WilcoUnable */
    )],
    UM98: [["IMMEDIATELY TURN %s HEADING %s"], new CpdlcMessageElement(
      "UM98",
      [1 /* FansA */],
      [new CpdlcMessageContentDirection(2), new CpdlcMessageContentDegree(4)],
      "WU" /* WilcoUnable */,
      true
    )],
    UM99: [["EXPECT %s"], new CpdlcMessageElement("UM99", [1 /* FansA */], [new CpdlcMessageContentProcedure(1)], "R" /* Roger */)],
    UM100: [["AT %s EXPECT %s"], new CpdlcMessageElement("UM100", [1 /* FansA */], [new CpdlcMessageContentTime(1), new CpdlcMessageContentSpeed(3)], "R" /* Roger */)],
    UM101: [["AT %s EXPECT %s"], new CpdlcMessageElement(
      "UM101",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(3)],
      "R" /* Roger */
    )],
    UM102: [["AT %s EXPECT %s"], new CpdlcMessageElement(
      "UM102",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1), new CpdlcMessageContentSpeed(3)],
      "R" /* Roger */
    )],
    UM103: [["AT %s EXPECT %s TO %s"], new CpdlcMessageElement(
      "UM103",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1), new CpdlcMessageContentSpeed(3), new CpdlcMessageContentSpeed(5)],
      "R" /* Roger */
    )],
    UM104: [["AT %s EXPECT %s TO %s"], new CpdlcMessageElement(
      "UM104",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1), new CpdlcMessageContentSpeed(3), new CpdlcMessageContentSpeed(5)],
      "R" /* Roger */
    )],
    UM105: [["AT %s EXPECT %s TO %s"], new CpdlcMessageElement(
      "UM105",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(1), new CpdlcMessageContentSpeed(3), new CpdlcMessageContentSpeed(5)],
      "R" /* Roger */
    )],
    UM106: [["MAINTAIN %s"], new CpdlcMessageElement("UM106", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "WU" /* WilcoUnable */)],
    UM107: [["MAINTAIN PRESENT SPEED"], new CpdlcMessageElement("UM107", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM108: [["MAINTAIN %s OR GREATER"], new CpdlcMessageElement("UM108", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "WU" /* WilcoUnable */)],
    UM109: [["MAINTAIN %s OR LESS"], new CpdlcMessageElement("UM109", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSpeed(1)], "WU" /* WilcoUnable */)],
    UM110: [["MAINTAIN %s TO %s"], new CpdlcMessageElement(
      "UM110",
      [1 /* FansA */],
      [new CpdlcMessageContentSpeed(1), new CpdlcMessageContentSpeed(3)],
      "WU" /* WilcoUnable */
    )],
    UM111: [["INCREASE SPEED TO %s"], new CpdlcMessageElement("UM111", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM112: [["INCREASE SPEED TO %s OR GREATER"], new CpdlcMessageElement("UM112", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM113: [["REDUCE SPEED TO %s"], new CpdlcMessageElement("UM113", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM114: [["REDUCE SPEED TO %s OR LESS"], new CpdlcMessageElement("UM114", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM115: [["DO NOT EXCEED %s"], new CpdlcMessageElement("UM115", [1 /* FansA */], [new CpdlcMessageContentSpeed(3)], "WU" /* WilcoUnable */)],
    UM116: [["RESUME NORMAL SPEED"], new CpdlcMessageElement("UM116", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM117: [["CONTACT %s %s"], new CpdlcMessageElement(
      "UM117",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentAtcUnit(1), new CpdlcMessageContentFrequency(2)],
      "WU" /* WilcoUnable */
    )],
    UM118: [["AT %s CONTACT %s %s"], new CpdlcMessageElement(
      "UM118",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM119: [["AT %s CONTACT %s %s"], new CpdlcMessageElement(
      "UM119",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM120: [["MONITOR %s %s"], new CpdlcMessageElement(
      "UM120",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentAtcUnit(1), new CpdlcMessageContentFrequency(2)],
      "WU" /* WilcoUnable */
    )],
    UM121: [["AT %s MONITOR %s %s"], new CpdlcMessageElement(
      "UM121",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM122: [["AT %s MONITOR %s %s"], new CpdlcMessageElement(
      "UM122",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(1, true), new CpdlcMessageContentAtcUnit(3), new CpdlcMessageContentFrequency(4)],
      "WU" /* WilcoUnable */
    )],
    UM123: [["SQUAWK %s"], new CpdlcMessageElement("UM123", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentSquawk(1)], "WU" /* WilcoUnable */)],
    UM124: [["STOP SQUAWK"], new CpdlcMessageElement("UM124", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM125: [["SQUAWK MODE CHARLIE", "SQUAWK ALTITUDE"], new CpdlcMessageElement("UM125", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM126: [["STOP SQUAWK MODE CHARLIE", "STOP SQUAWK ALTITUDE"], new CpdlcMessageElement("UM126", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM127: [["REPORT BACK ON ROUTE"], new CpdlcMessageElement("UM127", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM128: [["REPORT LEAVING %s"], new CpdlcMessageElement("UM128", [1 /* FansA */], [new CpdlcMessageContentLevel(2, true)], "WU" /* WilcoUnable */)],
    UM129: [["REPORT MAINTAINING %s", "REPORT LEVEL %s"], new CpdlcMessageElement(
      "UM129",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(2, true)],
      "WU" /* WilcoUnable */
    )],
    UM130: [["REPORT PASSING %s"], new CpdlcMessageElement("UM130", [1 /* FansA */], [new CpdlcMessageContentPosition(2, true)], "WU" /* WilcoUnable */)],
    UM131: [["REPORT REMAINING FUEL AND PERSONS ON BOARD", "REPORT REMAINING FUEL AND SOULS ON BOARD"], new CpdlcMessageElement(
      "UM131",
      [1 /* FansA */],
      "Y" /* Yes */,
      true
    )],
    UM132: [["REPORT POSITION", "CONFIRM POSITION"], new CpdlcMessageElement("UM132", [1 /* FansA */], "Y" /* Yes */)],
    UM133: [["REPORT PRESENT LEVEL"], new CpdlcMessageElement("UM133", [1 /* FansA */], "Y" /* Yes */)],
    UM134: [["REPORT SPEED", "CONFIRM SPEED"], new CpdlcMessageElement("UM134", [1 /* FansA */], "Y" /* Yes */)],
    UM135: [["CONFIRM ASSIGNED LEVEL"], new CpdlcMessageElement("UM135", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    UM136: [["CONFIRM ASSIGNED SPEED"], new CpdlcMessageElement("UM136", [1 /* FansA */], "Y" /* Yes */)],
    UM137: [["CONFIRM ASSIGNED ROUTE"], new CpdlcMessageElement("UM137", [1 /* FansA */], "Y" /* Yes */)],
    UM138: [["CONFIRM TIME OVER REPORTED WAYPOINT"], new CpdlcMessageElement("UM138", [1 /* FansA */], "Y" /* Yes */)],
    UM139: [["CONFIRM REPORTED WAYPOINT"], new CpdlcMessageElement("UM139", [1 /* FansA */], "Y" /* Yes */)],
    UM140: [["CONFIRM NEXT WAYPOINT"], new CpdlcMessageElement("UM140", [1 /* FansA */], "Y" /* Yes */)],
    UM141: [["CONFIRM NEXT WAYPOINT ETA"], new CpdlcMessageElement("UM141", [1 /* FansA */], "Y" /* Yes */)],
    UM142: [["CONFIRM ENSUING WAYPOINT"], new CpdlcMessageElement("UM142", [1 /* FansA */], "Y" /* Yes */)],
    UM143: [["CONFIRM REQUEST"], new CpdlcMessageElement("UM143", [1 /* FansA */], "Y" /* Yes */)],
    UM144: [["CONFIRM SQUAWK"], new CpdlcMessageElement("UM144", [1 /* FansA */], "Y" /* Yes */)],
    UM145: [["REPORT HEADING", "CONFIRM HEADING"], new CpdlcMessageElement("UM145", [1 /* FansA */], "Y" /* Yes */)],
    UM146: [["REPORT GROUND TRACK", "CONFIRM GROUND TRACK"], new CpdlcMessageElement("UM146", [1 /* FansA */], "Y" /* Yes */)],
    UM147: [["REQUEST POSITION REPORT"], new CpdlcMessageElement("UM147", [1 /* FansA */], "Y" /* Yes */)],
    UM148: [["WHEN CAN YOU ACCEPT %s"], new CpdlcMessageElement("UM148", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentLevel(4)], "Y" /* Yes */)],
    UM149: [["CAN YOU ACCEPT %s AT %s"], new CpdlcMessageElement(
      "UM149",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentPosition(5)],
      "AN" /* AffirmNegative */
    )],
    UM150: [["CAN YOU ACCEPT %s AT %s"], new CpdlcMessageElement(
      "UM150",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(3), new CpdlcMessageContentTime(5)],
      "AN" /* AffirmNegative */
    )],
    UM151: [["WHEN CAN YOU ACCEPT %s"], new CpdlcMessageElement("UM151", [1 /* FansA */], [new CpdlcMessageContentSpeed(4)], "Y" /* Yes */)],
    UM152: [["WHEN CAN YOU ACCEPT %s %s OFFSET"], new CpdlcMessageElement(
      "UM152",
      [1 /* FansA */],
      [new CpdlcMessageContentDistance(4), new CpdlcMessageContentDirection(5)],
      "Y" /* Yes */
    )],
    UM153: [["ALTIMETER %s", "QNH %s"], new CpdlcMessageElement("UM153", [1 /* FansA */], [new CpdlcMessageContentAltimeter(1)], "R" /* Roger */)],
    UM154: [["RADAR SERVICE TERMINATED", "RADAR SERVICES TERMINATED"], new CpdlcMessageElement("UM154", [1 /* FansA */], "R" /* Roger */)],
    UM155: [["RADAR CONTACT %s"], new CpdlcMessageElement("UM155", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "R" /* Roger */)],
    UM156: [["RADAR CONTACT LOST"], new CpdlcMessageElement("UM156", [1 /* FansA */], "R" /* Roger */)],
    UM157: [["CHECK STUCK MICROPHONE %s"], new CpdlcMessageElement(
      "UM157",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentFrequency(3)],
      "R" /* Roger */,
      true
    )],
    UM158: [["ATIS %s"], new CpdlcMessageElement("UM158", [1 /* FansA */], [new CpdlcMessageContentAtis(1)], "R" /* Roger */)],
    UM159: [["ERROR %s"], new CpdlcMessageElement("UM159", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "NE" /* NotRequired */)],
    UM160: [["NEXT DATA AUTHORITY %s"], new CpdlcMessageElement("UM160", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentAtcUnit(3)], "NE" /* NotRequired */)],
    UM161: [["END SERVICE"], new CpdlcMessageElement("UM161", [1 /* FansA */], "NE" /* NotRequired */)],
    UM162: [["MESSAGE NOT SUPPORTED BY THIS ATS UNIT", "SERVICE UNAVAILABLE"], new CpdlcMessageElement(
      "UM162",
      [1 /* FansA */, 2 /* FansB */],
      "NE" /* NotRequired */
    )],
    UM168: [["DISREGARD"], new CpdlcMessageElement("UM168", [1 /* FansA */], "R" /* Roger */)],
    UM169: [["%s"], new CpdlcMessageElement("UM169", [1 /* FansA */], [new CpdlcMessageContentFreetext(0, -1)], "R" /* Roger */)],
    UM171: [["CLIMB AT %s MINIMUM"], new CpdlcMessageElement(
      "UM171",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM172: [["CLIMB AT %s MAXIMUM"], new CpdlcMessageElement(
      "UM172",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM173: [["DESCEND AT %s MINIMUM"], new CpdlcMessageElement(
      "UM173",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM174: [["DESCEND AT %s MAXIMUM"], new CpdlcMessageElement(
      "UM174",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentVerticalRate(2)],
      "WU" /* WilcoUnable */
    )],
    UM175: [["REPORT REACHING %s"], new CpdlcMessageElement("UM175", [1 /* FansA */], [new CpdlcMessageContentLevel(2, true)], "WU" /* WilcoUnable */)],
    UM176: [["MAINTAIN OWN SEPARATION AND VMC"], new CpdlcMessageElement("UM176", [1 /* FansA */], "WU" /* WilcoUnable */)],
    UM177: [["AT PILOTS DISCRETION"], new CpdlcMessageElement("UM177", [1 /* FansA */], "N" /* No */)],
    UM179: [["SQUAWK IDENT"], new CpdlcMessageElement("UM179", [1 /* FansA */, 2 /* FansB */], "WU" /* WilcoUnable */)],
    UM180: [["REPORT REACHING BLOCK %s TO %s"], new CpdlcMessageElement(
      "UM180",
      [1 /* FansA */],
      [new CpdlcMessageContentLevel(3, true), new CpdlcMessageContentLevel(5, true)],
      "WU" /* WilcoUnable */
    )],
    UM181: [["REPORT DISTANCE TO %s", "REPORT DISTANCE FROM %s"], new CpdlcMessageElement(
      "UM181",
      [1 /* FansA */],
      [new CpdlcMessageContentPosition(3)],
      "Y" /* Yes */
    )],
    UM182: [["CONFIRM ATIS CODE"], new CpdlcMessageElement("UM182", [1 /* FansA */], "Y" /* Yes */)],
    UM183: [["%s"], new CpdlcMessageElement("UM183", [2 /* FansB */], [new CpdlcMessageContentFreetext(0, -1)], "R" /* Roger */)],
    UM184: [["AT TIME %s REPORT DISTANCE TO %s", "AT TIME %s REPORT DISTANCE FROM %s"], new CpdlcMessageElement(
      "UM184",
      [1 /* FansA */],
      [new CpdlcMessageContentTime(2, true), new CpdlcMessageContentPosition(6)],
      "Y" /* Yes */
    )],
    UM190: [["FLY HEADING %s"], new CpdlcMessageElement("UM190", [2 /* FansB */], [new CpdlcMessageContentDegree(2)], "WU" /* WilcoUnable */)],
    UM213: [["%s ALTIMETER %s", "%s QNH %s"], new CpdlcMessageElement(
      "UM213",
      [1 /* FansA */, 2 /* FansB */],
      [new CpdlcMessageContentPosition(0), new CpdlcMessageContentAltimeter(2)],
      "R" /* Roger */
    )],
    UM215: [["TURN %s %s DEGREES"], new CpdlcMessageElement(
      "UM215",
      [2 /* FansB */],
      [new CpdlcMessageContentDirection(1), new CpdlcMessageContentDegree(2)],
      "WU" /* WilcoUnable */
    )],
    UM222: [["NO SPEED RESTRICTION"], new CpdlcMessageElement("UM222", [1 /* FansA */, 2 /* FansB */], "R" /* Roger */)],
    UM227: [["LOGICAL ACKNOWLEDGEMENT"], new CpdlcMessageElement("UM227", [2 /* FansB */], "R" /* Roger */)],
    UM228: [["REPORT ETA %s"], new CpdlcMessageElement("UM228", [1 /* FansA */], [new CpdlcMessageContentPosition(2)], "Y" /* Yes */)],
    UM231: [["STATE PREFERRED LEVEL"], new CpdlcMessageElement("UM231", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    UM232: [["STATE TOP OF DESCENT"], new CpdlcMessageElement("UM232", [1 /* FansA */, 2 /* FansB */], "Y" /* Yes */)],
    UM242: [["TRANSMIT ADS-B IDENT"], new CpdlcMessageElement("UM242", [1 /* FansA */], "R" /* Roger */)],
    UM244: [["IDENTIFICATION TERMINATED"], new CpdlcMessageElement("UM244", [1 /* FansA */], "R" /* Roger */)],
    UM9995: [["LOGOFF"], new CpdlcMessageElement("UM9995", [1 /* FansA */, 2 /* FansB */], "NE" /* NotRequired */)],
    UM9996: [["UNABLE %s"], new CpdlcMessageElement("UM9996", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(1, -1)], "NE" /* NotRequired */)],
    UM9997: [["LOGON ACCEPTED"], new CpdlcMessageElement("UM9997", [1 /* FansA */, 2 /* FansB */], "NE" /* NotRequired */)],
    UM9998: [["HANDOVER %s"], new CpdlcMessageElement("UM9998", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentAtcUnit(1)], "NE" /* NotRequired */)],
    UM9999: [["CURRENT ATC %s"], new CpdlcMessageElement("UM9999", [1 /* FansA */, 2 /* FansB */], [new CpdlcMessageContentFreetext(2, -1)], "NE" /* NotRequired */)]
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/AtsuTimestamp.ts
  var AtsuTimestamp = class {
    constructor() {
      __publicField(this, "Year", 0);
      __publicField(this, "Month", 0);
      __publicField(this, "Day", 0);
      __publicField(this, "Seconds", 0);
    }
    static deserialize(jsonData) {
      const retval = new AtsuTimestamp();
      if (jsonData !== null) {
        retval.Year = jsonData.Year;
        retval.Month = jsonData.Month;
        retval.Day = jsonData.Day;
        retval.Seconds = jsonData.Seconds;
      }
      return retval;
    }
    mailboxTimestamp() {
      return `${timestampToString(this.Seconds)}Z`;
    }
    fmsTimestamp() {
      return timestampToString(this.Seconds);
    }
    static fromClock(clock) {
      const timestamp = new AtsuTimestamp();
      timestamp.Year = clock.year;
      timestamp.Month = clock.month;
      timestamp.Day = clock.dayOfMonth;
      timestamp.Seconds = clock.secondsOfDay;
      return timestamp;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/AtsuMessage.ts
  var AtsuMessageNetwork = /* @__PURE__ */ ((AtsuMessageNetwork2) => {
    AtsuMessageNetwork2[AtsuMessageNetwork2["Hoppie"] = 0] = "Hoppie";
    AtsuMessageNetwork2[AtsuMessageNetwork2["FBW"] = 1] = "FBW";
    return AtsuMessageNetwork2;
  })(AtsuMessageNetwork || {});
  var AtsuMessageDirection = /* @__PURE__ */ ((AtsuMessageDirection2) => {
    AtsuMessageDirection2[AtsuMessageDirection2["Uplink"] = 0] = "Uplink";
    AtsuMessageDirection2[AtsuMessageDirection2["Downlink"] = 1] = "Downlink";
    return AtsuMessageDirection2;
  })(AtsuMessageDirection || {});
  var AtsuMessageType = /* @__PURE__ */ ((AtsuMessageType2) => {
    AtsuMessageType2[AtsuMessageType2["Freetext"] = 0] = "Freetext";
    AtsuMessageType2[AtsuMessageType2["METAR"] = 1] = "METAR";
    AtsuMessageType2[AtsuMessageType2["TAF"] = 2] = "TAF";
    AtsuMessageType2[AtsuMessageType2["ATIS"] = 3] = "ATIS";
    AtsuMessageType2[AtsuMessageType2["AOC"] = 4] = "AOC";
    AtsuMessageType2[AtsuMessageType2["CPDLC"] = 5] = "CPDLC";
    AtsuMessageType2[AtsuMessageType2["DCL"] = 6] = "DCL";
    AtsuMessageType2[AtsuMessageType2["OCL"] = 7] = "OCL";
    AtsuMessageType2[AtsuMessageType2["ATC"] = 8] = "ATC";
    return AtsuMessageType2;
  })(AtsuMessageType || {});
  var AtsuMessageComStatus = /* @__PURE__ */ ((AtsuMessageComStatus2) => {
    AtsuMessageComStatus2[AtsuMessageComStatus2["Open"] = 0] = "Open";
    AtsuMessageComStatus2[AtsuMessageComStatus2["Sending"] = 1] = "Sending";
    AtsuMessageComStatus2[AtsuMessageComStatus2["Sent"] = 2] = "Sent";
    AtsuMessageComStatus2[AtsuMessageComStatus2["Received"] = 3] = "Received";
    AtsuMessageComStatus2[AtsuMessageComStatus2["Failed"] = 4] = "Failed";
    return AtsuMessageComStatus2;
  })(AtsuMessageComStatus || {});
  var AtsuMessageSerializationFormat = /* @__PURE__ */ ((AtsuMessageSerializationFormat2) => {
    AtsuMessageSerializationFormat2[AtsuMessageSerializationFormat2["FmsDisplay"] = 0] = "FmsDisplay";
    AtsuMessageSerializationFormat2[AtsuMessageSerializationFormat2["FmsDisplayMonitored"] = 1] = "FmsDisplayMonitored";
    AtsuMessageSerializationFormat2[AtsuMessageSerializationFormat2["Mailbox"] = 2] = "Mailbox";
    AtsuMessageSerializationFormat2[AtsuMessageSerializationFormat2["Printer"] = 3] = "Printer";
    AtsuMessageSerializationFormat2[AtsuMessageSerializationFormat2["Network"] = 4] = "Network";
    return AtsuMessageSerializationFormat2;
  })(AtsuMessageSerializationFormat || {});
  var AtsuMessage = class {
    constructor() {
      __publicField(this, "Network", 0 /* Hoppie */);
      __publicField(this, "UniqueMessageID", -1);
      __publicField(this, "Timestamp", new AtsuTimestamp());
      __publicField(this, "Station", "");
      __publicField(this, "ComStatus", 0 /* Open */);
      __publicField(this, "Type", null);
      __publicField(this, "Direction", null);
      __publicField(this, "Confirmed", false);
      __publicField(this, "Message", "");
    }
    serialize(_format) {
      throw new Error("No valid implementation");
    }
    // used to deserialize event data
    static deserialize(jsonData, message = null) {
      if (message === null)
        message = new AtsuMessage();
      message.Network = jsonData.Network;
      message.UniqueMessageID = jsonData.UniqueMessageID;
      if (jsonData.Timestamp) {
        message.Timestamp = AtsuTimestamp.deserialize(jsonData.Timestamp);
      }
      message.Station = jsonData.Station;
      message.ComStatus = jsonData.ComStatus;
      message.Type = jsonData.Type;
      message.Direction = jsonData.Direction;
      message.Confirmed = jsonData.Confirmed;
      message.Message = jsonData.Message;
      return message;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/CpdlcMessage.ts
  var CpdlcMessageMonitoringState = /* @__PURE__ */ ((CpdlcMessageMonitoringState2) => {
    CpdlcMessageMonitoringState2[CpdlcMessageMonitoringState2["Ignored"] = 0] = "Ignored";
    CpdlcMessageMonitoringState2[CpdlcMessageMonitoringState2["Required"] = 1] = "Required";
    CpdlcMessageMonitoringState2[CpdlcMessageMonitoringState2["Monitoring"] = 2] = "Monitoring";
    CpdlcMessageMonitoringState2[CpdlcMessageMonitoringState2["Cancelled"] = 3] = "Cancelled";
    CpdlcMessageMonitoringState2[CpdlcMessageMonitoringState2["Finished"] = 4] = "Finished";
    return CpdlcMessageMonitoringState2;
  })(CpdlcMessageMonitoringState || {});
  var CpdlcMessage = class extends AtsuMessage {
    constructor() {
      super();
      __publicField(this, "Content", []);
      __publicField(this, "Response", null);
      __publicField(this, "CurrentTransmissionId", -1);
      __publicField(this, "PreviousTransmissionId", -1);
      __publicField(this, "MailboxRelevantMessage", true);
      __publicField(this, "CloseAutomatically", true);
      __publicField(this, "MessageMonitoring", 0 /* Ignored */);
      __publicField(this, "SemanticResponseRequired", false);
      __publicField(this, "ReminderTimestamp", null);
      this.Type = 5 /* CPDLC */;
      this.Network = 0 /* Hoppie */;
      this.Direction = 1 /* Downlink */;
    }
    static deserialize(jsonData, message = null) {
      if (message === null)
        message = new CpdlcMessage();
      AtsuMessage.deserialize(jsonData, message);
      jsonData.Content.forEach((element) => message.Content.push(CpdlcMessageElement.deserialize(element)));
      if (jsonData.Response) {
        message.Response = CpdlcMessage.deserialize(jsonData.Response);
      }
      message.CurrentTransmissionId = jsonData.CurrentTransmissionId;
      message.PreviousTransmissionId = jsonData.PreviousTransmissionId;
      message.MailboxRelevantMessage = jsonData.MailboxRelevantMessage;
      message.CloseAutomatically = jsonData.CloseAutomatically;
      message.MessageMonitoring = jsonData.MessageMonitoring;
      message.SemanticResponseRequired = jsonData.SemanticResponseRequired;
      if (jsonData.ReminderTimestamp) {
        message.ReminderTimestamp = AtsuTimestamp.deserialize(jsonData.ReminderTimestamp);
      }
      return message;
    }
    serializeContent(format, template, element) {
      let content = "";
      content = template;
      element.Content.forEach((entry) => {
        const idx = content.indexOf("%s");
        if (format === 4 /* Network */) {
          content = `${content.substring(0, idx)}${entry.Value}${content.substring(idx + 2)}`;
        } else if (entry.Value !== "") {
          if (this.MessageMonitoring === 2 /* Monitoring */ && format === 1 /* FmsDisplayMonitored */) {
            content = `${content.substring(0, idx)}{magenta}${entry.Value}{end}${content.substring(idx + 2)}`;
          } else {
            content = `${content.substring(0, idx)}@${entry.Value}@${content.substring(idx + 2)}`;
          }
        } else {
          content = `${content.substring(0, idx)}[      ]${content.substring(idx + 2)}`;
        }
      });
      return content;
    }
    extendSerializationWithResponse() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      if (!this.Response || this.Response.Content.length === 0) {
        return false;
      }
      return ((_a = this.Response.Content[0]) == null ? void 0 : _a.TypeId) !== "DM0" && ((_b = this.Response.Content[0]) == null ? void 0 : _b.TypeId) !== "DM1" && ((_c = this.Response.Content[0]) == null ? void 0 : _c.TypeId) !== "DM2" && ((_d = this.Response.Content[0]) == null ? void 0 : _d.TypeId) !== "DM3" && ((_e = this.Response.Content[0]) == null ? void 0 : _e.TypeId) !== "DM4" && ((_f = this.Response.Content[0]) == null ? void 0 : _f.TypeId) !== "DM5" && ((_g = this.Response.Content[0]) == null ? void 0 : _g.TypeId) !== "UM0" && ((_h = this.Response.Content[0]) == null ? void 0 : _h.TypeId) !== "UM1" && ((_i = this.Response.Content[0]) == null ? void 0 : _i.TypeId) !== "UM3" && ((_j = this.Response.Content[0]) == null ? void 0 : _j.TypeId) !== "UM4" && ((_k = this.Response.Content[0]) == null ? void 0 : _k.TypeId) !== "UM5";
    }
    serialize(format) {
      var _a;
      const lineLength = format === 2 /* Mailbox */ ? 30 : 25;
      const lines = [];
      let message = "";
      if (this.Content.length !== 0) {
        for (const element of this.Content) {
          if (this.Direction === 1 /* Downlink */) {
            lines.push(...wordWrap(this.serializeContent(format, CpdlcMessagesDownlink[element.TypeId][0][0], element), lineLength));
          } else {
            lines.push(...wordWrap(this.serializeContent(format, CpdlcMessagesUplink[element.TypeId][0][0], element), lineLength));
          }
        }
      } else {
        this.Message.split("_").forEach((entry) => {
          lines.push(...wordWrap(entry, lineLength));
        });
      }
      if (format === 4 /* Network */) {
        message = `/data2/${this.CurrentTransmissionId}/${this.PreviousTransmissionId !== -1 ? this.PreviousTransmissionId : ""}/${(_a = this.Content[0]) == null ? void 0 : _a.ExpectedResponse}/${lines.join(" ")}`;
      } else if (format === 2 /* Mailbox */) {
        message = lines.join("\n");
      } else if (format === 0 /* FmsDisplay */ || format === 1 /* FmsDisplayMonitored */) {
        if (this.Direction === 0 /* Uplink */) {
          message += `{cyan}${this.Timestamp.mailboxTimestamp()} FROM ${this.Station}{end}
`;
        } else {
          message += `{cyan}${this.Timestamp.mailboxTimestamp()} TO ${this.Station}{end}
`;
        }
        lines.forEach((line) => {
          line = line.replace(/@/gi, "");
          if (format === 1 /* FmsDisplayMonitored */) {
            message += line;
          } else {
            message += `{green}${line}{end}
`;
          }
        });
        message += "{white}------------------------{end}\n";
        if (this.extendSerializationWithResponse()) {
          message += this.Response.serialize(format);
        }
      } else if (format === 3 /* Printer */) {
        message += `${this.Timestamp.mailboxTimestamp()} ${this.Direction === 0 /* Uplink */ ? "FROM" : "TO"} ${this.Station}}
`;
        lines.forEach((line) => {
          line = line.replace(/@/gi, "");
          message += `${line}
`;
        });
        message += "------------------------\n";
        if (this.extendSerializationWithResponse()) {
          message += this.Response.serialize(format);
        }
      } else {
        message = this.Message;
      }
      return message;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/components/UplinkMessageInterpretation.ts
  var _UplinkMessageInterpretation = class {
    static MessageRemainsOnMailbox(message) {
      return _UplinkMessageInterpretation.NonAutomaticClosingMessage.findIndex((elem) => message.Content[0].TypeId === elem) !== -1;
    }
    static SemanticAnswerRequired(message) {
      return message.Content[0].TypeId === "UM143" || message.Content[0].TypeId in _UplinkMessageInterpretation.SemanticAnswerTable;
    }
    static FillPresentData(atc, message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM132":
          if (atc.digitalInputs.PresentPosition.latitude.isNormalOperation() && atc.digitalInputs.PresentPosition.longitude.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = coordinateToString({
              lat: atc.digitalInputs.PresentPosition.latitude.value,
              lon: atc.digitalInputs.PresentPosition.longitude.value
            }, false);
            return true;
          }
          return false;
        case "UM133":
          if (atc.digitalInputs.PresentPosition.altitude.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadAltitude(Math.round(atc.digitalInputs.PresentPosition.altitude.value / 100).toString());
            return true;
          }
          return false;
        case "UM134":
          if (atc.digitalInputs.PresentDynamics.computedAirspeed.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadSpeed(Math.round(atc.digitalInputs.PresentDynamics.computedAirspeed.value).toString());
            return true;
          }
          return false;
        case "UM144":
          message.Response.Content[0].Content[0].Value = String(atc.digitalInputs.TransponderCode).padStart(4, "0");
          return true;
        case "UM145":
          if (atc.digitalInputs.PresentPosition.heading.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadSpeed(Math.round(atc.digitalInputs.PresentPosition.heading.value).toString());
            return true;
          }
          return false;
        case "UM146":
          if (atc.digitalInputs.PresentPosition.track.isNormalOperation()) {
            message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadSpeed(Math.round(atc.digitalInputs.PresentPosition.track.value).toString());
            return true;
          }
          return false;
        case "UM228":
          if (atc.digitalInputs.FlightRoute.destination) {
            message.Response.Content[0].Content[0].Value = `${timestampToString(atc.digitalInputs.FlightRoute.destination.utc)}Z`;
            return true;
          }
          return false;
        default:
          return false;
      }
    }
    static FillAssignedData(atc, message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM135":
          message.Response.Content[0].Content[0].Value = InputValidation.formatScratchpadAltitude(Math.round(Math.round(atc.digitalInputs.AutopilotData.selectedAltitude) / 100).toString());
          return true;
        case "UM136":
          if (atc.digitalInputs.AutopilotData.autothrustMode.isNormalOperation() && atc.digitalInputs.AutopilotData.autothrustMode.value !== 0) {
            let content = "";
            if (atc.digitalInputs.AutopilotData.machMode) {
              content = InputValidation.formatScratchpadAltitude(atc.digitalInputs.AutopilotData.selectedMach.value.toString());
            } else {
              content = InputValidation.formatScratchpadAltitude(Math.round(atc.digitalInputs.AutopilotData.selectedSpeed.value).toString());
            }
            message.Response.Content[0].Content[0].Value = content;
            return true;
          }
          return false;
        default:
          return false;
      }
    }
    static FillPositionReportRelatedData(atc, message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM138":
          if (atc.digitalInputs.FlightRoute.lastWaypoint) {
            message.Response.Content[0].Content[0].Value = `${timestampToString(atc.digitalInputs.FlightRoute.lastWaypoint.utc)}Z`;
          }
          return true;
        case "UM139":
          if (atc.digitalInputs.FlightRoute.lastWaypoint) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.lastWaypoint.ident;
          }
          return true;
        case "UM140":
          if (atc.digitalInputs.FlightRoute.activeWaypoint) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.activeWaypoint.ident;
          }
          return true;
        case "UM141":
          if (atc.digitalInputs.FlightRoute.activeWaypoint) {
            message.Response.Content[0].Content[0].Value = `${timestampToString(atc.digitalInputs.FlightRoute.activeWaypoint.utc)}Z`;
          }
          return true;
        case "UM142":
          if (atc.digitalInputs.FlightRoute.nextWaypoint) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.nextWaypoint.ident;
          }
          return true;
        case "UM147":
          message.Response = atc.createPositionReport();
          return true;
        case "UM148":
        case "UM151":
          message.Response.Content[0].Content[0].Value = message.Content[0].Content[0].Value;
          return true;
        case "UM152":
          message.Response.Content[0].Content[0].Value = message.Content[0].Content[0].Value;
          message.Response.Content[0].Content[1].Value = message.Content[0].Content[1].Value;
          return true;
        case "UM228":
          if (atc.digitalInputs.FlightRoute.destination) {
            message.Response.Content[0].Content[0].Value = atc.digitalInputs.FlightRoute.destination.ident;
            message.Response.Content[0].Content[1].Value = `${timestampToString(atc.digitalInputs.FlightRoute.destination.utc)}Z`;
          }
          return true;
        default:
          return false;
      }
    }
    static FillReportingRelatedData(message) {
      var _a;
      switch ((_a = message.Content[0]) == null ? void 0 : _a.TypeId) {
        case "UM128":
        case "UM129":
        case "UM130":
        case "UM175":
          message.Response.Content[0].Content[0].Value = message.Content[0].Content[0].Value;
          return true;
        case "UM180":
          for (let i = 0; i < message.Response.Content[0].Content.length; ++i) {
            message.Response.Content[0].Content[i].Value = message.Content[0].Content[i].Value;
          }
          return true;
        default:
          return false;
      }
    }
    static AppendSemanticAnswer(atc, positiveAnswer, message) {
      var _a, _b;
      if (((_a = message.Content[0]) == null ? void 0 : _a.TypeId) === "UM143") {
        for (const atcMessage of atc.messages()) {
          const cpdlc = atcMessage;
          if (_UplinkMessageInterpretation.RequestMessages.findIndex((elem) => elem === cpdlc.Content[0].TypeId) !== -1) {
            const response = new CpdlcMessage();
            response.Station = atcMessage.Station;
            response.PreviousTransmissionId = message.CurrentTransmissionId;
            for (const entry of cpdlc.Content) {
              response.Content.push(entry.deepCopy());
            }
            message.Response = response;
            return true;
          }
        }
        if (!message.Response) {
          const response = new CpdlcMessage();
          response.Station = message.Station;
          response.PreviousTransmissionId = message.CurrentTransmissionId;
          response.Content.push(CpdlcMessagesDownlink.DM67[1].deepCopy());
          response.Content[0].Content[0].Value = "NO REQUEST TRANSMITTED";
          message.Response = response;
        }
      } else if (((_b = message.Content[0]) == null ? void 0 : _b.TypeId) in _UplinkMessageInterpretation.SemanticAnswerTable) {
        const lutEntry = _UplinkMessageInterpretation.SemanticAnswerTable[message.Content[0].TypeId];
        if (lutEntry.positiveOrNegative) {
          const response = new CpdlcMessage();
          response.Station = message.Station;
          response.PreviousTransmissionId = message.CurrentTransmissionId;
          if (positiveAnswer) {
            response.Content.push(CpdlcMessagesDownlink[lutEntry.messages[0]][1].deepCopy());
          } else {
            response.Content.push(CpdlcMessagesDownlink[lutEntry.messages[1]][1].deepCopy());
          }
          message.Response = response;
        } else if (lutEntry.messages[0] in CpdlcMessagesDownlink) {
          const response = new CpdlcMessage();
          response.Station = message.Station;
          response.PreviousTransmissionId = message.CurrentTransmissionId;
          response.Content.push(CpdlcMessagesDownlink[lutEntry.messages[0]][1].deepCopy());
          message.Response = response;
        }
      }
      if (!_UplinkMessageInterpretation.FillPresentData(atc, message) && !_UplinkMessageInterpretation.FillAssignedData(atc, message)) {
        if (!_UplinkMessageInterpretation.FillPositionReportRelatedData(atc, message)) {
          _UplinkMessageInterpretation.FillReportingRelatedData(message);
        }
      }
      return false;
    }
    static HasNegativeResponse(message) {
      var _a, _b;
      if (((_a = message.Content[0]) == null ? void 0 : _a.TypeId) in _UplinkMessageInterpretation.SemanticAnswerTable) {
        const lutEntry = _UplinkMessageInterpretation.SemanticAnswerTable[(_b = message.Content[0]) == null ? void 0 : _b.TypeId];
        if (lutEntry.positiveOrNegative) {
          return message.Response.Content[0].TypeId !== lutEntry.messages[1];
        }
      }
      return false;
    }
    static IsModifiable(message) {
      var _a, _b;
      if (((_a = message.Content[0]) == null ? void 0 : _a.TypeId) in _UplinkMessageInterpretation.SemanticAnswerTable) {
        const lutEntry = _UplinkMessageInterpretation.SemanticAnswerTable[(_b = message.Content[0]) == null ? void 0 : _b.TypeId];
        return lutEntry.modifiable;
      }
      return false;
    }
  };
  var UplinkMessageInterpretation = _UplinkMessageInterpretation;
  __publicField(UplinkMessageInterpretation, "NonAutomaticClosingMessage", [
    "UM127",
    "UM128",
    "UM129",
    "UM130",
    "UM131",
    "UM132",
    "UM133",
    "UM134",
    "UM135",
    "UM136",
    "UM137",
    "UM138",
    "UM139",
    "UM140",
    "UM141",
    "UM142",
    "UM143",
    "UM144",
    "UM145",
    "UM146",
    "UM147",
    "UM148",
    "UM151",
    "UM152",
    "UM180",
    "UM181",
    "UM182",
    "UM228",
    "UM231",
    "UM232"
  ]);
  __publicField(UplinkMessageInterpretation, "RequestMessages", [
    "DM15",
    "DM16",
    "DM17",
    "DM18",
    "DM19",
    "DM20",
    "DM21",
    "DM22",
    "DM23",
    "DM24",
    "DM25",
    "DM26",
    "DM27",
    "DM51",
    "DM52",
    "DM53",
    "DM54",
    "DM69",
    "DM70",
    "DM71",
    "DM72",
    "DM73",
    "DM74"
  ]);
  __publicField(UplinkMessageInterpretation, "SemanticAnswerTable", {
    UM128: { positiveOrNegative: false, modifiable: false, messages: ["DM28"] },
    UM129: { positiveOrNegative: false, modifiable: false, messages: ["DM37"] },
    UM130: { positiveOrNegative: false, modifiable: false, messages: ["DM31"] },
    UM131: { positiveOrNegative: false, modifiable: true, messages: ["DM57"] },
    UM132: { positiveOrNegative: false, modifiable: true, messages: ["DM33"] },
    UM133: { positiveOrNegative: false, modifiable: true, messages: ["DM32"] },
    UM134: { positiveOrNegative: false, modifiable: true, messages: ["DM34"] },
    UM135: { positiveOrNegative: false, modifiable: true, messages: ["DM38"] },
    UM136: { positiveOrNegative: false, modifiable: true, messages: ["DM39"] },
    UM137: { positiveOrNegative: false, modifiable: true, messages: ["DM40"] },
    UM138: { positiveOrNegative: false, modifiable: true, messages: ["DM46"] },
    UM139: { positiveOrNegative: false, modifiable: true, messages: ["DM45"] },
    UM140: { positiveOrNegative: false, modifiable: true, messages: ["DM42"] },
    UM141: { positiveOrNegative: false, modifiable: true, messages: ["DM43"] },
    UM142: { positiveOrNegative: false, modifiable: true, messages: ["DM44"] },
    UM144: { positiveOrNegative: false, modifiable: true, messages: ["DM47"] },
    UM145: { positiveOrNegative: false, modifiable: true, messages: ["DM35"] },
    UM146: { positiveOrNegative: false, modifiable: true, messages: ["DM36"] },
    UM147: { positiveOrNegative: false, modifiable: true, messages: ["DM48"] },
    UM148: { positiveOrNegative: true, modifiable: true, messages: ["DM81", "DM82"] },
    UM151: { positiveOrNegative: false, modifiable: true, messages: ["DM83"] },
    UM152: { positiveOrNegative: true, modifiable: true, messages: ["DM85", "DM86"] },
    UM175: { positiveOrNegative: false, modifiable: false, messages: ["DM72"] },
    UM180: { positiveOrNegative: false, modifiable: false, messages: ["DM76"] },
    UM181: { positiveOrNegative: false, modifiable: true, messages: ["DM67"] },
    UM182: { positiveOrNegative: false, modifiable: true, messages: ["DM79"] },
    UM184: { positiveOrNegative: false, modifiable: true, messages: ["DM67"] },
    UM228: { positiveOrNegative: false, modifiable: true, messages: ["DM104"] },
    UM231: { positiveOrNegative: false, modifiable: true, messages: ["DM106"] },
    UM232: { positiveOrNegative: false, modifiable: true, messages: ["DM109"] }
  });

  // ../../../../../fbw-common/src/systems/datalink/common/src/types/Clock.ts
  var Clock2 = class {
    constructor(year, month, dayOfMonth, hour, minute, second, secondsOfDay) {
      this.year = year;
      this.month = month;
      this.dayOfMonth = dayOfMonth;
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.secondsOfDay = secondsOfDay;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/components/UplinkMonitor.ts
  var UplinkMonitorType = /* @__PURE__ */ ((UplinkMonitorType2) => {
    UplinkMonitorType2[UplinkMonitorType2["Unknown"] = -1] = "Unknown";
    UplinkMonitorType2[UplinkMonitorType2["Time"] = 0] = "Time";
    UplinkMonitorType2[UplinkMonitorType2["Altitude"] = 1] = "Altitude";
    UplinkMonitorType2[UplinkMonitorType2["Position"] = 2] = "Position";
    return UplinkMonitorType2;
  })(UplinkMonitorType || {});
  var _UplinkMonitor = class {
    constructor(message) {
      __publicField(this, "type");
      __publicField(this, "messageId", -1);
      this.messageId = message.UniqueMessageID;
    }
    static relevantMessage(message) {
      if (_UplinkMonitor.positionMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) === -1 && _UplinkMonitor.timeMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) === -1 && _UplinkMonitor.levelMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) === -1) {
        return false;
      }
      return true;
    }
    static createMessageMonitor(message) {
      if (_UplinkMonitor.positionMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) !== -1) {
        return new PositionMonitor(message);
      }
      if (_UplinkMonitor.timeMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) !== -1) {
        return new TimeMonitor(message);
      }
      if (_UplinkMonitor.levelMonitoringMessageIds.findIndex((id) => {
        var _a;
        return id === ((_a = message.Content[0]) == null ? void 0 : _a.TypeId);
      }) !== -1) {
        return new LevelMonitor(message);
      }
      return null;
    }
  };
  var UplinkMonitor = _UplinkMonitor;
  __publicField(UplinkMonitor, "positionMonitoringMessageIds", ["UM22", "UM25", "UM65", "UM77", "UM83", "UM84", "UM97", "UM118", "UM121", "UM130"]);
  __publicField(UplinkMonitor, "timeMonitoringMessageIds", ["UM21", "UM24", "UM66", "UM76", "UM119", "UM122", "UM184"]);
  __publicField(UplinkMonitor, "levelMonitoringMessageIds", ["UM78", "UM128", "UM129", "UM130", "UM175", "UM180"]);
  var PositionMonitor = class extends UplinkMonitor {
    constructor(message) {
      var _a, _b;
      super(message);
      __publicField(this, "positionMonitor", "");
      this.type = 2 /* Position */;
      this.positionMonitor = (_b = (_a = message.Content[0]) == null ? void 0 : _a.Content[0]) == null ? void 0 : _b.Value;
    }
    conditionsMet(condition) {
      if (typeof condition !== "number" && "ident" in condition) {
        const lastPosition = condition.ident;
        return this.positionMonitor === lastPosition;
      }
      return false;
    }
  };
  var _TimeMonitor = class extends UplinkMonitor {
    constructor(message) {
      var _a, _b;
      super(message);
      __publicField(this, "timeOffset", 0);
      __publicField(this, "timeMonitor", -1);
      this.type = 0 /* Time */;
      if (_TimeMonitor.deferredMessageIDs.findIndex((id) => {
        var _a2;
        return id === ((_a2 = message.Content[0]) == null ? void 0 : _a2.TypeId);
      }) !== -1) {
        this.timeOffset = 30;
      }
      this.timeMonitor = _TimeMonitor.extractSeconds((_b = (_a = message.Content[0]) == null ? void 0 : _a.Content[0]) == null ? void 0 : _b.Value);
    }
    static extractSeconds(value) {
      const matches = value.match(/[0-9]{2}/g);
      const hours = parseInt(matches[0]);
      const minutes = parseInt(matches[1]);
      return (hours * 60 + minutes) * 60;
    }
    conditionsMet(condition) {
      if (condition instanceof Clock2) {
        if (condition.secondsOfDay + this.timeOffset >= this.timeMonitor) {
          return condition.secondsOfDay - this.timeMonitor < 30;
        }
      }
      return false;
    }
  };
  var TimeMonitor = _TimeMonitor;
  __publicField(TimeMonitor, "deferredMessageIDs", ["UM66", "UM69", "UM119", "UM122"]);
  var LevelMonitor = class extends UplinkMonitor {
    constructor(message) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      super(message);
      __publicField(this, "lowerLevel", -1);
      __publicField(this, "upperLevel", -1);
      __publicField(this, "reachingLevel", false);
      __publicField(this, "leavingLevel", false);
      __publicField(this, "reachedLevel", false);
      this.type = 1 /* Altitude */;
      this.lowerLevel = LevelMonitor.extractAltitude((_b = (_a = message.Content[0]) == null ? void 0 : _a.Content[0]) == null ? void 0 : _b.Value);
      if (((_c = message.Content[0]) == null ? void 0 : _c.TypeId) === "UM180") {
        this.upperLevel = LevelMonitor.extractAltitude((_d = message.Content[0]) == null ? void 0 : _d.Content[1].Value);
        this.reachingLevel = true;
      } else if (((_e = message.Content[0]) == null ? void 0 : _e.TypeId) === "UM78" || ((_f = message.Content[0]) == null ? void 0 : _f.TypeId) === "UM129" || ((_g = message.Content[0]) == null ? void 0 : _g.TypeId) === "UM175") {
        this.reachingLevel = true;
      } else if (((_h = message.Content[0]) == null ? void 0 : _h.TypeId) === "UM128") {
        this.reachingLevel = false;
      } else if (((_i = message.Content[0]) == null ? void 0 : _i.TypeId) === "UM130") {
        this.reachingLevel = true;
        this.leavingLevel = true;
      }
    }
    static extractAltitude(value) {
      let altitude = parseInt(value.match(/[0-9]+/)[0]);
      if (value.startsWith("FL")) {
        altitude *= 100;
      } else if (value.endsWith("M")) {
        altitude *= 3.28084;
      }
      return altitude;
    }
    conditionsMet(condition) {
      if (typeof condition === "number") {
        if (this.reachingLevel && this.leavingLevel) {
          if (!this.reachedLevel) {
            this.reachedLevel = Math.abs(condition - this.lowerLevel) <= 100;
          } else {
            return Math.abs(condition - this.lowerLevel) > 100;
          }
        }
        if (!this.reachingLevel) {
          return Math.abs(condition - this.lowerLevel) > 100;
        }
        if (this.upperLevel > -1) {
          return this.lowerLevel <= condition && this.upperLevel >= condition;
        }
        return Math.abs(condition - this.lowerLevel) <= 100;
      }
      return false;
    }
  };

  // ../../shared/src/persistence.ts
  var _NXDataStore = class {
    static get listener() {
      if (this.mListener === void 0) {
        this.mListener = RegisterViewListener("JS_LISTENER_SIMVARS", null, true);
      }
      return this.mListener;
    }
    static get(key, defaultVal) {
      const val = GetStoredData(`A32NX_${key}`);
      if (val === null || val.length === 0) {
        return defaultVal;
      }
      return val;
    }
    /**
     * Sets a value in persistent storage
     *
     * @param key The property key
     * @param val The value to assign to the property
     */
    static set(key, val) {
      SetStoredData(`A32NX_${key}`, val);
      this.listener.triggerToAllSubscribers("A32NX_NXDATASTORE_UPDATE", key, val);
    }
    static subscribe(key, callback) {
      return Coherent.on("A32NX_NXDATASTORE_UPDATE", (updatedKey, value) => {
        if (key === "*" || key === updatedKey) {
          callback(updatedKey, value);
        }
      }).clear;
    }
    static getAndSubscribe(key, callback, defaultVal) {
      callback(key, _NXDataStore.get(key, defaultVal));
      return _NXDataStore.subscribe(key, callback);
    }
  };
  var NXDataStore = _NXDataStore;
  __publicField(NXDataStore, "mListener");

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/WeatherMessage.ts
  var WeatherMessage = class extends AtsuMessage {
    constructor() {
      super();
      __publicField(this, "Reports", []);
      this.Direction = 0 /* Uplink */;
    }
    serialize(format) {
      let type = "";
      switch (this.Type) {
        case 1 /* METAR */:
          type = "METAR";
          break;
        case 2 /* TAF */:
          type = "TAF";
          break;
        default:
          type = "ATIS";
          break;
      }
      let message = "";
      if (format === 0 /* FmsDisplay */ || format === 1 /* FmsDisplayMonitored */) {
        this.Reports.forEach((report) => {
          message += `{cyan}${type} ${report.airport}{end}
`;
          wordWrap(report.report, 25).forEach((line) => {
            if (line.startsWith("D-ATIS")) {
              message += `{amber}${line}{end}
`;
            } else if (line === "NO METAR AVAILABLE" || line === "NO TAF AVAILABLE") {
              message += `{amber}${line}{end}
`;
            } else {
              message += `{green}${line}{end}
`;
            }
          });
          message += "{white}------------------------{end}\n";
        });
      } else {
        this.Reports.forEach((report) => {
          message += `${type} ${report.airport}
`;
          message += `${report.report}
`;
          message += "------------------------\n";
        });
      }
      return message;
    }
    static deserialize(jsonData, message = null) {
      if (message === null)
        message = new WeatherMessage();
      AtsuMessage.deserialize(jsonData, message);
      jsonData.Reports.forEach((report) => {
        message.Reports.push({ airport: report.airport, report: report.report });
      });
      return message;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/AtisMessage.ts
  var AtisType = /* @__PURE__ */ ((AtisType3) => {
    AtisType3[AtisType3["Departure"] = 0] = "Departure";
    AtisType3[AtisType3["Arrival"] = 1] = "Arrival";
    AtisType3[AtisType3["Enroute"] = 2] = "Enroute";
    return AtisType3;
  })(AtisType || {});
  var AtisMessage = class extends WeatherMessage {
    constructor() {
      super();
      __publicField(this, "Information", "");
      this.Type = 3 /* ATIS */;
      this.Station = NXDataStore.get("CONFIG_ATIS_SRC", "MSFS");
    }
    parseInformation() {
      let foundInfo = false;
      this.Reports.forEach((report) => {
        report.report.split(" ").forEach((word) => {
          if (foundInfo === false) {
            if (word === "INFORMATION" || word === "INFO") {
              foundInfo = true;
            }
          } else {
            this.Information = word;
            if (this.Information.length > 1) {
              this.Information = this.Information[0];
            }
            foundInfo = false;
          }
        });
      });
    }
    static deserialize(jsonData) {
      const retval = new AtisMessage();
      WeatherMessage.deserialize(jsonData, retval);
      retval.Information = jsonData.Information;
      return retval;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/DclMessage.ts
  var DclMessage = class extends CpdlcMessage {
    constructor() {
      super();
      __publicField(this, "Callsign", "");
      __publicField(this, "Origin", "");
      __publicField(this, "Destination", "");
      __publicField(this, "AcType", "");
      __publicField(this, "Atis", "");
      __publicField(this, "Gate", "");
      __publicField(this, "Freetext", []);
      this.Type = 6 /* DCL */;
      this.Direction = 1 /* Downlink */;
      this.CloseAutomatically = false;
    }
    serialize(format) {
      let dclMessage = "";
      if (format === 4 /* Network */) {
        dclMessage = "REQUEST PREDEP CLEARANCE \n";
        dclMessage += `${this.Callsign} ${this.AcType} TO ${this.Destination} 
`;
        dclMessage += `AT ${this.Origin}${this.Gate !== "" ? ` STAND ${this.Gate}` : ""} 
`;
        dclMessage += `ATIS ${this.Atis}`;
      } else {
        if (format !== 2 /* Mailbox */) {
          dclMessage = `${this.Timestamp.mailboxTimestamp()} TO ${this.Station}
`;
        }
        dclMessage += `DEPART REQUEST
${this.Callsign}
`;
        dclMessage += `FROM:${this.Origin}${this.Gate.length !== 0 ? ` GATE:${this.Gate}` : ""}
`;
        dclMessage += `TO:${this.Destination} ATIS:${this.Atis}
`;
        dclMessage += `A/C TYPE:${this.AcType}`;
        const freetext = this.Freetext.join("\n").replace(/^\s*\n/gm, "");
        if (freetext.length !== 0) {
          dclMessage += `
${freetext}`;
        }
      }
      return dclMessage;
    }
    // used to deserialize event data
    static deserialize(jsonData) {
      const retval = new DclMessage();
      CpdlcMessage.deserialize(jsonData, retval);
      retval.Callsign = jsonData.Callsign;
      retval.Origin = jsonData.Origin;
      retval.Destination = jsonData.Destination;
      retval.AcType = jsonData.AcType;
      retval.Gate = jsonData.Gate;
      retval.Atis = jsonData.Atis;
      retval.Freetext = jsonData.Freetext;
      return retval;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/FreetextMessage.ts
  var FreetextMessage = class extends AtsuMessage {
    constructor() {
      super();
      this.Type = 0 /* Freetext */;
      this.Direction = 1 /* Downlink */;
    }
    serialize(format) {
      let message = "";
      if (format === 0 /* FmsDisplay */ || format === 1 /* FmsDisplayMonitored */) {
        wordWrap(this.Message, 25).forEach((line) => {
          message += `{green}${line}{end}
`;
        });
        message += "{white}------------------------{end}\n";
      } else {
        message = this.Message;
      }
      return message;
    }
    static deserialize(jsonData) {
      const retval = new FreetextMessage();
      AtsuMessage.deserialize(jsonData, retval);
      return retval;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/MetarMessage.ts
  var MetarMessage = class extends WeatherMessage {
    constructor() {
      super();
      this.Type = 1 /* METAR */;
      this.Station = NXDataStore.get("CONFIG_METAR_SRC", "MSFS");
    }
    static deserialize(jsonData) {
      const retval = new MetarMessage();
      WeatherMessage.deserialize(jsonData, retval);
      return retval;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/OclMessage.ts
  var OclMessage = class extends CpdlcMessage {
    constructor() {
      super();
      __publicField(this, "Callsign", "");
      __publicField(this, "Destination", "");
      __publicField(this, "EntryPoint", "");
      __publicField(this, "EntryTime", "");
      __publicField(this, "RequestedMach", "");
      __publicField(this, "RequestedFlightlevel", "");
      __publicField(this, "Freetext", []);
      this.Type = 7 /* OCL */;
      this.Direction = 1 /* Downlink */;
      this.CloseAutomatically = false;
    }
    serialize(format) {
      let oclMessage = `OCEANIC REQUEST
${this.Callsign} 
`;
      oclMessage += `ENTRY POINT:${this.EntryPoint}
AT:${this.EntryTime} 
`;
      oclMessage += `REQ:${this.RequestedMach} ${this.RequestedFlightlevel}`;
      const freetext = this.Freetext.join("\n").replace(/^\s*\n/gm, "");
      if (freetext.length !== 0) {
        oclMessage += `
${freetext}`;
      }
      if (format === 4 /* Network */) {
        oclMessage = `/data2/${this.CurrentTransmissionId}//N/${oclMessage}`;
      } else if (format !== 2 /* Mailbox */) {
        oclMessage = `${this.Timestamp.mailboxTimestamp()} TO ${this.Station}
${oclMessage}`;
      }
      return oclMessage;
    }
    // used to deserialize event data
    static deserialize(jsonData) {
      const retval = new OclMessage();
      CpdlcMessage.deserialize(jsonData, retval);
      retval.Callsign = jsonData.Callsign;
      retval.Destination = jsonData.Destination;
      retval.EntryPoint = jsonData.EntryPoint;
      retval.EntryTime = jsonData.EntryTime;
      retval.RequestedMach = jsonData.RequestedMach;
      retval.RequestedFlightlevel = jsonData.RequestedFlightlevel;
      retval.Freetext = jsonData.Freetext;
      return retval;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/TafMessage.ts
  var TafMessage = class extends WeatherMessage {
    constructor() {
      super();
      this.Type = 2 /* TAF */;
      this.Station = NXDataStore.get("CONFIG_TAF_SRC", "MSFS");
    }
    static deserialize(jsonData) {
      const retval = new TafMessage();
      WeatherMessage.deserialize(jsonData, retval);
      return retval;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/messages/Conversion.ts
  var Conversion = class {
    static messageDataToMessage(data) {
      switch (data.Type) {
        case 3 /* ATIS */:
          return AtisMessage.deserialize(data);
        case 5 /* CPDLC */:
          return CpdlcMessage.deserialize(data);
        case 6 /* DCL */:
          return DclMessage.deserialize(data);
        case 0 /* Freetext */:
          return FreetextMessage.deserialize(data);
        case 1 /* METAR */:
          return MetarMessage.deserialize(data);
        case 7 /* OCL */:
          return OclMessage.deserialize(data);
        case 2 /* TAF */:
          return TafMessage.deserialize(data);
        default:
          return null;
      }
    }
  };

  // ../../shared/src/arinc429.ts
  var Arinc429SignStatusMatrix = /* @__PURE__ */ ((Arinc429SignStatusMatrix2) => {
    Arinc429SignStatusMatrix2[Arinc429SignStatusMatrix2["FailureWarning"] = 0] = "FailureWarning";
    Arinc429SignStatusMatrix2[Arinc429SignStatusMatrix2["NoComputedData"] = 1] = "NoComputedData";
    Arinc429SignStatusMatrix2[Arinc429SignStatusMatrix2["FunctionalTest"] = 2] = "FunctionalTest";
    Arinc429SignStatusMatrix2[Arinc429SignStatusMatrix2["NormalOperation"] = 3] = "NormalOperation";
    return Arinc429SignStatusMatrix2;
  })(Arinc429SignStatusMatrix || {});
  var _Arinc429Word = class {
    constructor(word) {
      __publicField(this, "ssm");
      __publicField(this, "value");
      _Arinc429Word.u32View[0] = (word & 4294967295) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 3;
      this.value = _Arinc429Word.f32View[0];
    }
    static empty() {
      return new _Arinc429Word(0);
    }
    static fromSimVarValue(name) {
      return new _Arinc429Word(SimVar.GetSimVarValue(name, "number"));
    }
    static async toSimVarValue(name, value, ssm) {
      _Arinc429Word.f32View[0] = value;
      const simVal = _Arinc429Word.u32View[0] + Math.trunc(ssm) * 2 ** 32;
      return SimVar.SetSimVarValue(name, "string", simVal.toString());
    }
    isFailureWarning() {
      return this.ssm === 0 /* FailureWarning */;
    }
    isNoComputedData() {
      return this.ssm === 1 /* NoComputedData */;
    }
    isFunctionalTest() {
      return this.ssm === 2 /* FunctionalTest */;
    }
    isNormalOperation() {
      return this.ssm === 3 /* NormalOperation */;
    }
    /**
     * Returns the value when normal operation, the supplied default value otherwise.
     */
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    getBitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    getBitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
    setBitValue(bit, value) {
      if (value) {
        this.value |= 1 << bit - 1;
      } else {
        this.value &= ~(1 << bit - 1);
      }
    }
  };
  var Arinc429Word = _Arinc429Word;
  __publicField(Arinc429Word, "u32View", new Uint32Array(1));
  __publicField(Arinc429Word, "f32View", new Float32Array(_Arinc429Word.u32View.buffer));
  var Arinc429Register = class {
    constructor() {
      __publicField(this, "u32View", new Uint32Array(1));
      __publicField(this, "f32View", new Float32Array(this.u32View.buffer));
      __publicField(this, "ssm");
      __publicField(this, "value");
      this.set(0);
    }
    static empty() {
      return new Arinc429Register();
    }
    set(word) {
      this.u32View[0] = (word & 4294967295) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 3;
      this.value = this.f32View[0];
    }
    setFromSimVar(name) {
      this.set(SimVar.GetSimVarValue(name, "number"));
    }
    isFailureWarning() {
      return this.ssm === 0 /* FailureWarning */;
    }
    isNoComputedData() {
      return this.ssm === 1 /* NoComputedData */;
    }
    isFunctionalTest() {
      return this.ssm === 2 /* FunctionalTest */;
    }
    isNormalOperation() {
      return this.ssm === 3 /* NormalOperation */;
    }
    /**
     * Returns the value when normal operation, the supplied default value otherwise.
     */
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    bitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    bitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
  };

  // ../../../../../node_modules/@microsoft/msfs-sdk/msfssdk.js
  var SimVarValueType;
  (function(SimVarValueType2) {
    SimVarValueType2["Number"] = "number";
    SimVarValueType2["Percent"] = "percent";
    SimVarValueType2["Degree"] = "degrees";
    SimVarValueType2["Knots"] = "knots";
    SimVarValueType2["Feet"] = "feet";
    SimVarValueType2["Meters"] = "meters";
    SimVarValueType2["FPM"] = "feet per minute";
    SimVarValueType2["Radians"] = "radians";
    SimVarValueType2["InHG"] = "inches of mercury";
    SimVarValueType2["MB"] = "Millibars";
    SimVarValueType2["Bool"] = "bool";
    SimVarValueType2["Celsius"] = "celsius";
    SimVarValueType2["MHz"] = "MHz";
    SimVarValueType2["KHz"] = "KHz";
    SimVarValueType2["NM"] = "nautical mile";
    SimVarValueType2["String"] = "string";
    SimVarValueType2["RPM"] = "Rpm";
    SimVarValueType2["PPH"] = "Pounds per hour";
    SimVarValueType2["GPH"] = "gph";
    SimVarValueType2["Farenheit"] = "farenheit";
    SimVarValueType2["PSI"] = "psi";
    SimVarValueType2["GAL"] = "gallons";
    SimVarValueType2["LBS"] = "pounds";
    SimVarValueType2["Hours"] = "Hours";
    SimVarValueType2["Volts"] = "Volts";
    SimVarValueType2["Amps"] = "Amperes";
    SimVarValueType2["Seconds"] = "seconds";
    SimVarValueType2["Enum"] = "enum";
    SimVarValueType2["LLA"] = "latlonalt";
    SimVarValueType2["MetersPerSecond"] = "meters per second";
    SimVarValueType2["Mach"] = "mach";
    SimVarValueType2["Pounds"] = "pounds";
    SimVarValueType2["SlugsPerCubicFoot"] = "slug per cubic foot";
  })(SimVarValueType || (SimVarValueType = {}));
  var latlonaltRegEx = new RegExp(/latlonalt/i);
  var latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
  var pbhRegex = new RegExp(/pbh/i);
  var pid_structRegex = new RegExp(/pid_struct/i);
  var xyzRegex = new RegExp(/xyz/i);
  var stringRegex = new RegExp(/string/i);
  var boolRegex = new RegExp(/boolean|bool/i);
  var numberRegex = new RegExp(/number/i);
  var defaultSource = "";
  SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
      if (simvar) {
        let output;
        const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
        if (registeredID >= 0) {
          if (numberRegex.test(unit)) {
            output = simvar.getValueReg(registeredID);
          } else if (stringRegex.test(unit)) {
            output = simvar.getValueReg_String(registeredID);
          } else if (latlonaltRegEx.test(unit)) {
            output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
          } else if (latlonaltpbhRegex.test(unit)) {
            output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
          } else if (pbhRegex.test(unit)) {
            output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
          } else if (pid_structRegex.test(unit)) {
            output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
          } else if (xyzRegex.test(unit)) {
            output = new XYZ(simvar.getValue_XYZ(name, dataSource));
          } else {
            output = simvar.getValueReg(registeredID);
          }
        }
        return output;
      } else {
        console.warn("SimVar handler is not defined (" + name + ")");
      }
    } catch (error) {
      console.warn("ERROR ", error, " GetSimVarValue " + name + " unit : " + unit);
      return null;
    }
    return null;
  };
  SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == void 0) {
      console.warn(name + " : Trying to set a null value");
      return Promise.resolve();
    }
    try {
      if (simvar) {
        const regID = SimVar.GetRegisteredId(name, unit, dataSource);
        if (regID >= 0) {
          if (stringRegex.test(unit)) {
            return Coherent.call("setValueReg_String", regID, value);
          } else if (boolRegex.test(unit)) {
            return Coherent.call("setValueReg_Bool", regID, !!value);
          } else if (numberRegex.test(unit)) {
            return Coherent.call("setValueReg_Number", regID, value);
          } else if (latlonaltRegEx.test(unit)) {
            return Coherent.call("setValue_LatLongAlt", name, value, dataSource);
          } else if (latlonaltpbhRegex.test(unit)) {
            return Coherent.call("setValue_LatLongAltPBH", name, value, dataSource);
          } else if (pbhRegex.test(unit)) {
            return Coherent.call("setValue_PBH", name, value, dataSource);
          } else if (pid_structRegex.test(unit)) {
            return Coherent.call("setValue_PID_STRUCT", name, value, dataSource);
          } else if (xyzRegex.test(unit)) {
            return Coherent.call("setValue_XYZ", name, value, dataSource);
          } else {
            return Coherent.call("setValueReg_Number", regID, value);
          }
        }
      } else {
        console.warn("SimVar handler is not defined");
      }
    } catch (error) {
      console.warn("error SetSimVarValue " + error);
    }
    return Promise.resolve();
  };
  var NumberUnit = class {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
      this._number = number;
      this._unit = unit;
      this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
      return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
      return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
      if (typeof value !== "number" && this.unit.canConvert(value.unit)) {
        return this.unit.convertFrom(value.number, value.unit);
      }
      if (typeof value === "number" && (!unit || this.unit.canConvert(unit))) {
        return unit ? this.unit.convertFrom(value, unit) : value;
      }
      return void 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
      const converted = this.toNumberOfThisUnit(arg1, arg2);
      if (converted !== void 0) {
        this._number = converted;
        return this;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number + converted, this.unit);
        } else {
          out = this;
          this._number += converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number - converted, this.unit);
        } else {
          out = this;
          this._number -= converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
      if (out) {
        return out.set(this.number * factor, this.unit);
      } else {
        this._number *= factor;
        return this;
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted) {
        return this.number / converted;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
      if (out) {
        return out.set(Math.abs(this.number), this.unit);
      } else {
        this._number = Math.abs(this._number);
        return this;
      }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
      return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        throw new Error("Invalid unit conversion attempted.");
      }
      const diff = this.number - converted;
      if (Math.abs(diff) < 1e-14) {
        return 0;
      }
      return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        return false;
      }
      if (isNaN(converted) && this.isNaN()) {
        return true;
      }
      const diff = this.number - converted;
      return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
      return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
      return new NumberUnit(this.number, this.unit);
    }
  };
  var NumberUnitReadOnly = class {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
      this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
      return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
      return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.add(arg1, arg2, out);
      } else {
        return this.source.add(arg1, out);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.subtract(arg1, arg2, out);
      } else {
        return this.source.subtract(arg1, out);
      }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
      return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.ratio(arg1, arg2);
      } else {
        return this.source.ratio(arg1);
      }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
      return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
      return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.compare(arg1, arg2);
      } else {
        return this.source.compare(arg1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2);
      } else {
        return this.source.equals(arg1);
      }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
      return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
      return this.source.copy();
    }
  };
  var AbstractUnit = class {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
      this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
      return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
      return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
      return this.family === other.family && this.name === other.name;
    }
  };
  var SimpleUnit = class extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
      super(name);
      this.family = family;
      this.scaleFactor = scaleFactor;
      this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
      return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
  };
  var CompoundUnit = class extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
      if (name === void 0) {
        name = "";
        let i = 0;
        while (i < numerator.length - 1) {
          name += `${numerator[i++].name}-`;
        }
        name += `${numerator[i].name}`;
        if (denominator.length > 0) {
          name += " per ";
          i = 0;
          while (i < denominator.length - 1) {
            name += `${denominator[i++].name}-`;
          }
          name += `${denominator[i].name}`;
        }
      }
      super(name);
      this.family = family;
      this.numerator = Array.from(numerator);
      this.denominator = Array.from(denominator);
      this.numerator.sort((a, b) => a.family.localeCompare(b.family));
      this.denominator.sort((a, b) => a.family.localeCompare(b.family));
      this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
      let factor = 1;
      factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
      factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
      return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
      return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
  };
  var UnitFamily;
  (function(UnitFamily2) {
    UnitFamily2["Distance"] = "distance";
    UnitFamily2["Angle"] = "angle";
    UnitFamily2["Duration"] = "duration";
    UnitFamily2["Weight"] = "weight";
    UnitFamily2["Volume"] = "volume";
    UnitFamily2["Pressure"] = "pressure";
    UnitFamily2["Temperature"] = "temperature";
    UnitFamily2["TemperatureDelta"] = "temperature_delta";
    UnitFamily2["Speed"] = "speed";
    UnitFamily2["Acceleration"] = "acceleration";
    UnitFamily2["WeightFlux"] = "weight_flux";
    UnitFamily2["VolumeFlux"] = "volume_flux";
  })(UnitFamily || (UnitFamily = {}));
  var UnitType = class {
  };
  UnitType.METER = new SimpleUnit(UnitFamily.Distance, "meter", 1);
  UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, "foot", 0.3048);
  UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, "kilometer", 1e3);
  UnitType.MILE = new SimpleUnit(UnitFamily.Distance, "mile", 1609.34);
  UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, "nautical mile", 1852);
  UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, "great arc radian", 6378100);
  UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, "radian", 1);
  UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, "degree", Math.PI / 180);
  UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, "minute", Math.PI / 180 / 60);
  UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, "second", Math.PI / 180 / 3600);
  UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, "millisecond", 1e-3);
  UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, "second", 1);
  UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, "minute", 60);
  UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, "hour", 3600);
  UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, "kilogram", 1);
  UnitType.POUND = new SimpleUnit(UnitFamily.Weight, "pound", 0.453592);
  UnitType.TON = new SimpleUnit(UnitFamily.Weight, "ton", 907.185);
  UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, "tonne", 1e3);
  UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, "liter", 0.80283679);
  UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "gallon", 3.0390664);
  UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "imperial gallon", 3.6497683);
  UnitType.LITER = new SimpleUnit(UnitFamily.Volume, "liter", 1);
  UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, "gallon", 3.78541);
  UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, "hectopascal", 1);
  UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, "atmosphere", 1013.25);
  UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, "inch of mercury", 33.8639);
  UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, "millimeter of mercury", 1.33322);
  UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, "kelvin", 1, 0);
  UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, "\xB0 Celsius", 1, 273.15);
  UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, "\xB0 Fahrenheit", 5 / 9, 459.67);
  UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, "\xB0 Rankine", 5 / 9, 0);
  UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Celsius", 1);
  UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Fahrenheit", 5 / 9);
  UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], "knot");
  UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
  UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
  UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
  UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
  UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
  UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
  UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [new SimpleUnit(UnitFamily.Distance, "9.80665 meter", 9.80665)], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
  UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
  UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
  UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
  UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
  var BasePublisher = class {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = void 0) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.publishActive = false;
      this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
      this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
      this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
      return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
      return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    publish(topic, data, sync = false, isCached = true) {
      if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
        this.publisher.pub(topic, data, sync, isCached);
      }
    }
  };
  var RandomNumberPublisher = class extends BasePublisher {
    /**
     * Start publishing random numbers.
     */
    startPublish() {
      super.startPublish();
      this.publishRandomNumbers();
    }
    /**
     * Async thread that publishes random numbers
     * @param ms - Milliseconds to sleep between publishes
     */
    async publishRandomNumbers(ms = 1e3) {
      while (this.isPublishing()) {
        const newVal = Math.floor(Math.random() * ms);
        this.publish("randomNumber", newVal, true);
        await new Promise((r) => setTimeout(r, ms));
      }
    }
  };
  var SimVarPublisher = class extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
      super(bus, pacer);
      this.resolvedSimVars = /* @__PURE__ */ new Map();
      this.indexedSimVars = /* @__PURE__ */ new Map();
      this.subscribed = /* @__PURE__ */ new Set();
      for (const [topic, entry] of simVarMap) {
        if (entry.indexed) {
          this.indexedSimVars.set(topic, entry);
          this.resolveIndexedSimVar(topic, entry);
        } else {
          this.resolvedSimVars.set(topic, entry);
        }
      }
      const handleSubscribedTopic = (topic) => {
        if (this.resolvedSimVars.has(topic)) {
          this.onTopicSubscribed(topic);
        } else {
          this.tryMatchIndexedSubscribedTopic(topic);
        }
      };
      this.bus.forEachSubscribedTopic(handleSubscribedTopic);
      this.bus.getSubscriber().on("event_bus_topic_first_sub").handle(handleSubscribedTopic);
    }
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    tryMatchIndexedSubscribedTopic(topic) {
      if (this.indexedSimVars.size === 0) {
        return;
      }
      if (!SimVarPublisher.INDEXED_REGEX.test(topic)) {
        return;
      }
      const match = topic.match(SimVarPublisher.INDEXED_REGEX);
      const [, matchedTopic, index] = match;
      const entry = this.indexedSimVars.get(matchedTopic);
      if (entry) {
        this.onTopicSubscribed(this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index)));
      }
    }
    /**
     * Resolves an indexed topic with an index, generating a version of the topic which is mapped to an indexed simvar.
     * The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic.
     */
    resolveIndexedSimVar(topic, entry, index) {
      const resolvedTopic = index === void 0 ? topic : `${topic}_${index}`;
      if (this.resolvedSimVars.has(resolvedTopic)) {
        return resolvedTopic;
      }
      this.resolvedSimVars.set(resolvedTopic, { name: entry.name.replace("#index#", `${index !== null && index !== void 0 ? index : 1}`), type: entry.type, map: entry.map });
      return resolvedTopic;
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
      if (this.subscribed.has(topic)) {
        return;
      }
      this.subscribed.add(topic);
      if (this.publishActive) {
        this.publishTopic(topic);
      }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
      return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
      return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
      for (const topic of this.subscribed.values()) {
        this.publishTopic(topic);
      }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
      const value = this.getValue(topic);
      if (value !== void 0) {
        this.publish(topic, value);
      }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
      const entry = this.resolvedSimVars.get(topic);
      if (entry === void 0) {
        return void 0;
      }
      return entry.map === void 0 ? this.getSimVarValue(entry) : entry.map(this.getSimVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getSimVarValue(entry) {
      const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
      if (entry.type === SimVarValueType.Bool) {
        return svValue === 1;
      }
      return svValue;
    }
  };
  SimVarPublisher.INDEXED_REGEX = /(.*)_([1-9]\d*)$/;
  var GameVarPublisher = class extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
      super(bus, pacer);
      this.simvars = simVarMap;
      this.subscribed = /* @__PURE__ */ new Set();
      for (const topic of this.simvars.keys()) {
        if (bus.getTopicSubscriberCount(topic) > 0) {
          this.onTopicSubscribed(topic);
        }
      }
      bus.getSubscriber().on("event_bus_topic_first_sub").handle((topic) => {
        if (this.simvars.has(topic)) {
          this.onTopicSubscribed(topic);
        }
      });
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
      if (this.subscribed.has(topic)) {
        return;
      }
      this.subscribed.add(topic);
      if (this.publishActive) {
        this.publishTopic(topic);
      }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
      return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
      return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
      for (const topic of this.subscribed.values()) {
        this.publishTopic(topic);
      }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
      const value = this.getValue(topic);
      if (value !== void 0) {
        this.publish(topic, value);
      }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
      const entry = this.simvars.get(topic);
      if (entry === void 0) {
        return void 0;
      }
      return entry.map === void 0 ? this.getGameVarValue(entry) : entry.map(this.getGameVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getGameVarValue(entry) {
      const svValue = SimVar.GetGameVarValue(entry.name, entry.type);
      if (entry.type === SimVarValueType.Bool) {
        return svValue === 1;
      }
      return svValue;
    }
  };
  var AdcPublisher = class extends SimVarPublisher {
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
      var _a;
      const simvars = /* @__PURE__ */ new Map([
        ["ias", { name: "AIRSPEED INDICATED:#index#", type: SimVarValueType.Knots, indexed: true }],
        ["tas", { name: "AIRSPEED TRUE:#index#", type: SimVarValueType.Knots, indexed: true }],
        [
          "mach_to_kias_factor",
          {
            name: "AIRSPEED INDICATED:#index#",
            type: SimVarValueType.Knots,
            map: (kias) => {
              const factor = kias < 1 ? Simplane.getMachToKias(1) : kias / this.mach;
              return isFinite(factor) ? factor : 1;
            },
            indexed: true
          }
        ],
        ["indicated_alt", { name: "INDICATED ALTITUDE:#index#", type: SimVarValueType.Feet, indexed: true }],
        ["altimeter_baro_setting_inhg", { name: "KOHLSMAN SETTING HG:#index#", type: SimVarValueType.InHG, indexed: true }],
        ["altimeter_baro_setting_mb", { name: "KOHLSMAN SETTING MB:#index#", type: SimVarValueType.MB, indexed: true }],
        ["altimeter_baro_preselect_raw", { name: "L:XMLVAR_Baro#index#_SavedPressure", type: SimVarValueType.Number, indexed: true }],
        ["altimeter_baro_preselect_inhg", { name: "L:XMLVAR_Baro#index#_SavedPressure", type: SimVarValueType.Number, map: (raw) => UnitType.HPA.convertTo(raw / 16, UnitType.IN_HG), indexed: true }],
        ["altimeter_baro_preselect_mb", { name: "L:XMLVAR_Baro#index#_SavedPressure", type: SimVarValueType.Number, map: (raw) => raw / 16, indexed: true }],
        ["altimeter_baro_is_std", { name: "L:XMLVAR_Baro#index#_ForcedToSTD", type: SimVarValueType.Bool, indexed: true }],
        ["radio_alt", { name: "RADIO HEIGHT", type: SimVarValueType.Feet }],
        ["pressure_alt", { name: "PRESSURE ALTITUDE", type: SimVarValueType.Feet }],
        ["vertical_speed", { name: "VERTICAL SPEED", type: SimVarValueType.FPM }],
        ["ambient_temp_c", { name: "AMBIENT TEMPERATURE", type: SimVarValueType.Celsius }],
        ["ambient_pressure_inhg", { name: "AMBIENT PRESSURE", type: SimVarValueType.InHG }],
        ["isa_temp_c", { name: "STANDARD ATM TEMPERATURE", type: SimVarValueType.Celsius }],
        ["ram_air_temp_c", { name: "TOTAL AIR TEMPERATURE", type: SimVarValueType.Celsius }],
        ["ambient_wind_velocity", { name: "AMBIENT WIND VELOCITY", type: SimVarValueType.Knots }],
        ["ambient_wind_direction", { name: "AMBIENT WIND DIRECTION", type: SimVarValueType.Degree }],
        ["on_ground", { name: "SIM ON GROUND", type: SimVarValueType.Bool }],
        ["aoa", { name: "INCIDENCE ALPHA", type: SimVarValueType.Degree }],
        ["stall_aoa", { name: "STALL ALPHA", type: SimVarValueType.Degree }],
        ["zero_lift_aoa", { name: "ZERO LIFT ALPHA", type: SimVarValueType.Degree }],
        ["mach_number", { name: "AIRSPEED MACH", type: SimVarValueType.Mach }]
      ]);
      super(simvars, bus, pacer);
      this.mach = 0;
      (_a = this.needUpdateMach) !== null && _a !== void 0 ? _a : this.needUpdateMach = false;
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
      super.onTopicSubscribed(topic);
      if (topic.startsWith("mach_to_kias_factor")) {
        this.needUpdateMach = true;
      }
    }
    /** @inheritdoc */
    onUpdate() {
      const isSlewing = SimVar.GetSimVarValue("IS SLEW ACTIVE", "bool");
      if (!isSlewing) {
        if (this.needUpdateMach) {
          this.mach = SimVar.GetSimVarValue("AIRSPEED MACH", SimVarValueType.Number);
        }
        super.onUpdate();
      }
    }
  };
  var AeroMath = class {
    // ---- Ideal gas law relationships for air ----
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature, density) {
      return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure, temperature) {
      return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure, density) {
      return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    // ---- Other properties of air ----.
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature) {
      return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    // ---- Pressure ratios ----
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach) {
      return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    // ---- ISA modeling ----
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude) {
      if (altitude < 11e3) {
        return 15 + Math.max(altitude, -610) * -65e-4;
      } else if (altitude < 2e4) {
        return -56.5;
      } else if (altitude < 32e3) {
        return -56.5 + (altitude - 2e4) * 1e-3;
      } else if (altitude < 47e3) {
        return -44.5 + (altitude - 32e3) * 28e-4;
      } else if (altitude < 51e3) {
        return -2.5;
      } else if (altitude < 71e3) {
        return -2.5 + (altitude - 51e3) * -28e-4;
      } else {
        return -58.5 + (Math.min(altitude, 8e4) - 71e3) * -2e-3;
      }
    }
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude) {
      if (altitude < -610) {
        return 1099.15;
      } else if (altitude <= 11e3) {
        return 1013.25 * Math.pow(1 - 22558e-9 * altitude, 5.2558);
      } else if (altitude <= 2e4) {
        return 226.32 * Math.exp(-157686e-9 * (altitude - 11e3));
      } else if (altitude <= 32e3) {
        return 54.7499 * Math.pow(1 + 461574e-11 * (altitude - 2e4), -34.1627);
      } else if (altitude <= 47e3) {
        return 8.68058 * Math.pow(1 + 122458e-10 * (altitude - 32e3), -12.201);
      } else if (altitude <= 51e3) {
        return 1.10914 * Math.exp(-126225e-9 * (altitude - 47e3));
      } else if (altitude <= 71e3) {
        return 0.669439 * Math.pow(1 - 103455e-10 * (altitude - 51e3), 12.201);
      } else if (altitude <= 8e4) {
        return 0.039568 * Math.pow(1 - 931749e-11 * (altitude - 71e3), 17.0814);
      } else {
        return 88638e-7;
      }
    }
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude, deltaIsa = 0) {
      return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude, deltaIsa = 0) {
      return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    // ---- Speed conversions ----
    // The following section contains methods for converting between different speeds: CAS, TAS, and mach.
    // All conversions are based on the following:
    // Constants:
    // gamma (adiabatic index of air) = 1.4
    // pressure_sea_level_isa = 1013.25 hPa
    // sound_speed_sea_level_isa = 340.2964 m/s
    // Relationship between mach and impact pressure (only valid for subsonic flow):
    // mach = sqrt(5 * ((impact_pressure / static_pressure + 1) ^ ((gamma - 1) / gamma)) - 1)
    // impact_pressure = static_pressure * ((1 + 0.2 * mach ^ 2) ^ (gamma / (gamma - 1)) - 1)
    // Relationship between mach and airspeed:
    // mach = airspeed / sound_speed
    // airspeed = mach * sound_speed
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas, soundSpeed) {
      return tas / soundSpeed;
    }
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
      return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach, soundSpeed) {
      return mach * soundSpeed;
    }
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
      return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas, pressure) {
      const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
      const impactPressure = 1013.25 * (Math.pow(1 + 0.2 * mach0 * mach0, 3.5) - 1);
      return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas, altitude) {
      return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach, pressure) {
      const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
      return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach, altitude) {
      return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas, pressure, temperature) {
      return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
      return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas, pressure, temperature) {
      return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
      return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    // ---- Lift and drag equations ----
    // force_coefficient = force / (dynamic_pressure * area)
    // dynamic_pressure = 0.5 * density * speed ^ 2
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    static flowCoefFromForce(force, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return force / (dynamicPressure * area);
    }
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    static flowForceFromCoef(coef, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return coef * dynamicPressure * area;
    }
  };
  AeroMath.R = 8.314462618153;
  AeroMath.R_AIR = 287.057;
  AeroMath.GAMMA_AIR = 1.4;
  AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
  AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.lift = AeroMath.flowForceFromCoef;
  AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.drag = AeroMath.flowForceFromCoef;
  var BitFlags = class {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
      if (index < 0 || index > 32) {
        throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
      }
      return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
      return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
      let result = 0;
      const len = flags.length;
      for (let i = 0; i < len; i++) {
        result |= flags[i];
      }
      return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
      const len = flags.length;
      if (len === 0) {
        return 0;
      }
      let result = flags[0];
      for (let i = 1; i < len; i++) {
        result &= flags[i];
      }
      return result;
    }
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags, valuesToSet, mask) {
      return flags & ~mask | valuesToSet & mask;
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
      return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
      return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
      startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0, 0, 32);
      endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = 32, 0, 32);
      for (let i = startIndex; i < endIndex; i++) {
        const value = (flags & 1 << i) !== 0;
        if (valueFilter === void 0 || valueFilter === value) {
          callback(value, i, flags);
        }
      }
    }
  };
  var HandlerSubscription = class {
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
      this.handler = handler;
      this.initialNotifyFunc = initialNotifyFunc;
      this.onDestroy = onDestroy;
      this._isAlive = true;
      this._isPaused = false;
      this.canInitialNotify = initialNotifyFunc !== void 0;
    }
    /** @inheritdoc */
    get isAlive() {
      return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
      return this._isPaused;
    }
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
      if (!this._isAlive) {
        throw new Error("HandlerSubscription: cannot notify a dead Subscription.");
      }
      this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot pause a dead Subscription.");
      }
      this._isPaused = true;
      return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot resume a dead Subscription.");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      if (initialNotify) {
        this.initialNotify();
      }
      return this;
    }
    /** @inheritdoc */
    destroy() {
      if (!this._isAlive) {
        return;
      }
      this._isAlive = false;
      this.onDestroy && this.onDestroy(this);
    }
  };
  var SubscribablePipe = class extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
      let handler;
      let onDestroy;
      if (typeof arg4 === "function") {
        handler = (fromVal) => {
          to.set(arg3(fromVal, to.get()));
        };
        onDestroy = arg4;
      } else {
        handler = (fromVal) => {
          to.set(fromVal);
        };
        onDestroy = arg3;
      }
      super(handler, (sub) => {
        sub.handler(from.get());
      }, onDestroy);
    }
  };
  var AbstractSubscribable = class {
    constructor() {
      this.isSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.notifySubscription.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            this.notifySubscription(sub);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`AbstractSubscribable: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
      sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
      return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var MappedSubscribableClass = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param input This subscribable's input.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     */
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
      super();
      this.input = input;
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.input.get()));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.input.get());
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSub = this.input.sub((inputValue) => {
        this.updateValue(inputValue);
      }, true);
    }
    /** @inheritdoc */
    get isAlive() {
      return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
      return this._isPaused;
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     * @param inputValue The input value.
     */
    updateValue(inputValue) {
      const value = this.mapFunc(inputValue, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    /** @inheritdoc */
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot pause a dead subscribable");
      }
      if (this._isPaused) {
        return this;
      }
      this.inputSub.pause();
      this._isPaused = true;
      return this;
    }
    /** @inheritdoc */
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot resume a dead subscribable");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this.inputSub.resume(true);
      return this;
    }
    /** @inheritdoc */
    destroy() {
      this._isAlive = false;
      this.inputSub.destroy();
    }
  };
  var NumberUnitSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
      return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var Vec2Math = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
      const vec = new Float64Array(2);
      if (x !== void 0 && y !== void 0) {
        vec[0] = x;
        vec[1] = y;
      }
      return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
      vec[0] = x;
      vec[1] = y;
      return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
      vec[0] = r * Math.cos(theta);
      vec[1] = r * Math.sin(theta);
      return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
      return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
      const mag = Vec2Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
      const x = v1[0];
      const y = v1[1];
      if (!counterClockwise) {
        out[0] = y;
        out[1] = -x;
      } else {
        out[0] = -y;
        out[1] = x;
      }
      return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
      return Vec2Math.set(from[0], from[1], to);
    }
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon, point) {
      let k = 0;
      let f = 0;
      let u1 = 0;
      let v1 = 0;
      let u2 = 0;
      let v2 = 0;
      let currentP = null;
      let nextP = null;
      const x = point[0];
      const y = point[1];
      const contourLen = polygon.length - 1;
      currentP = polygon[0];
      if (currentP[0] !== polygon[contourLen][0] && currentP[1] !== polygon[contourLen][1]) {
        throw new Error("First and last coordinates in a ring must be the same");
      }
      u1 = currentP[0] - x;
      v1 = currentP[1] - y;
      for (let i = 0; i < polygon.length - 1; i++) {
        nextP = polygon[i + 1];
        v2 = nextP[1] - y;
        if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
          currentP = nextP;
          v1 = v2;
          u1 = currentP[0] - x;
          continue;
        }
        u2 = nextP[0] - point[0];
        if (v2 > 0 && v1 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f > 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v1 > 0 && v2 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f < 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v2 === 0 && v1 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 === 0) {
          if (u2 <= 0 && u1 >= 0) {
            return void 0;
          } else if (u1 <= 0 && u2 >= 0) {
            return void 0;
          }
        }
        currentP = nextP;
        v1 = v2;
        u1 = u2;
      }
      if (k % 2 === 0) {
        return false;
      }
      return true;
    }
  };
  var Vec3Math = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
      const vec = new Float64Array(3);
      if (x !== void 0 && y !== void 0 && z !== void 0) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
      }
      return vec;
    }
    /**
     * Gets the spherical angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle theta of the vector.
     */
    static theta(vec) {
      return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi of a vector in radians.
     * @param vec - a vector.
     * @returns the spherical angle phi of the vector.
     */
    static phi(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param z - the new z-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, z, vec) {
      vec[0] = x;
      vec[1] = y;
      vec[2] = z;
      return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new spherical angle theta, in radians.
     * @param phi - the new spherical angle phi, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
      const sinTheta = Math.sin(theta);
      vec[0] = sinTheta * Math.cos(phi);
      vec[1] = sinTheta * Math.sin(phi);
      vec[2] = Math.cos(theta);
      return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      out[2] = v1[2] + v2[2];
      return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      out[2] = v1[2] - v2[2];
      return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
      const x1 = v1[0];
      const y1 = v1[1];
      const z1 = v1[2];
      const x2 = v2[0];
      const y2 = v2[1];
      const z2 = v2[2];
      out[0] = y1 * z2 - z1 * y2;
      out[1] = z1 * x2 - x1 * z2;
      out[2] = x1 * y2 - y1 * x2;
      return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      out[2] = v1[2] * scalar;
      return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
      return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      out[2] = v1[2] / mag;
      return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
      return Vec3Math.set(from[0], from[1], from[2], to);
    }
  };
  var VecNMath = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
      const vec = new Float64Array(length);
      for (let i = 0; i < length && components.length; i++) {
        vec[i] = components[i];
      }
      return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
      for (let i = 0; i < vec.length && components.length; i++) {
        vec[i] = components[i];
      }
      return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
      return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
      if (v1.length !== v2.length) {
        throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
      }
      let dot = 0;
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        dot += v1[i] * v2[i];
      }
      return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        out[i] = v1[i] / mag;
      }
      return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
      if (vec1.length !== vec2.length) {
        return false;
      }
      for (let i = 0; i < vec1.length; i++) {
        if (vec1[i] !== vec2[i]) {
          return false;
        }
      }
      return true;
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
      if (from.length !== to.length) {
        throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
      }
      to.set(from);
      return to;
    }
  };
  var Vec2Subject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal) {
      return new Vec2Subject(initialVal);
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal) {
      return new Vec2Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
      let x, y;
      if (typeof arg1 === "number") {
        x = arg1;
        y = arg2;
      } else {
        x = arg1[0];
        y = arg1[1];
      }
      const equals = x === this.value[0] && y === this.value[1];
      if (!equals) {
        Vec2Math.set(x, y, this.value);
        this.notify();
      }
    }
  };
  var Vec3Subject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal) {
      return new Vec3Subject(initialVal);
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal) {
      return new Vec3Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
      let x, y, z;
      if (typeof arg1 === "number") {
        x = arg1;
        y = arg2;
        z = arg3;
      } else {
        x = arg1[0];
        y = arg1[1];
        z = arg1[2];
      }
      const equals = x === this.value[0] && y === this.value[1] && z === this.value[2];
      if (!equals) {
        Vec3Math.set(x, y, z, this.value);
        this.notify();
      }
    }
  };
  var VecNSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     */
    static create(initialVal) {
      return new VecNSubject(initialVal);
    }
    /**
     * Creates a VecNSubject.
     * @param initialVal The initial value.
     * @returns A VecNSubject.
     * @deprecated Use `VecNSubject.create()` instead.
     */
    static createFromVector(initialVal) {
      return new VecNSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, ...args) {
      let array;
      if (typeof arg1 === "number") {
        array = args;
        args.unshift(arg1);
      } else {
        array = arg1;
      }
      if (array.length > this.value.length) {
        throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
      }
      let equals = true;
      const len = array.length;
      for (let i = 0; i < len; i++) {
        if (array[i] !== this.value[i]) {
          equals = false;
          break;
        }
      }
      if (!equals) {
        this.value.set(array);
        this.notify();
      }
    }
  };
  var Subject = class extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
      super();
      this.value = value;
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
      return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
      sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
      if (!this.equalityFunc(value, this.value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
      let changed = false;
      for (const prop in value) {
        changed = value[prop] !== this.value[prop];
        if (changed) {
          break;
        }
      }
      Object.assign(this.value, value);
      changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
      super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
      return this.value;
    }
  };
  var TemperatureSystem = class {
    /**
     * Creates an instance of a TemperatureSystem.
     * @param capacity The heat capacity of the system, in joules per kelvin.
     */
    constructor(capacity) {
      this.capacity = capacity;
      this.sources = [];
      this._value = Subject.create(0);
    }
    /**
     * Gets the system's output value.
     * @returns The system's output temperature value, in degrees Celsius.
     */
    get value() {
      return this._value;
    }
    /**
     * Directly sets the current temperature value.
     * @param value The temperature value, in degrees Celsius.
     */
    set(value) {
      this._value.set(Math.max(-273.15, value));
    }
    /**
     * Adds a temperature source.
     * @param source The temperature source.
     * @returns The index of the added temperature source.
     */
    addSource(source) {
      return this.sources.push(source) - 1;
    }
    /**
     * Sets the temperature of a temperature source.
     * @param index The index of the source.
     * @param temperature The temperature to set to, in degrees Celsius.
     */
    setSourceTemp(index, temperature) {
      const source = this.sources[index];
      if (source !== void 0) {
        source.temperature = temperature;
      }
    }
    /**
     * Sets the conductivity of a temperature source.
     * @param index The index of the source.
     * @param conductivity The conductivity to set to, in watts per meter-kelvin.
     */
    setSourceConductivity(index, conductivity) {
      const source = this.sources[index];
      if (source !== void 0) {
        source.conductivity = conductivity;
      }
    }
    /**
     * Sets the heat capacity of the system.
     * @param capacity The heat capacity of the system, in joules per kelvin.
     */
    setCapacity(capacity) {
      this.capacity = capacity;
    }
    /**
     * Updates the temperature of this system following a period of elapsed time. This method assumes that this system's
     * sources, their temperatures and conductivities, and this system's heat capacity at the time this method is called
     * all remained constant throughout the time elapsed.
     * @param deltaTime The elapsed time, in milliseconds.
     */
    update(deltaTime) {
      if (deltaTime === 0 || this.sources.length === 0) {
        return;
      }
      const Q0 = (this._value.get() + 273.15) * this.capacity;
      let A = 0, k = 0;
      for (let i = 0; i < this.sources.length; i++) {
        const source = this.sources[i];
        A += Math.max(source.temperature + 273.15, 0) * source.conductivity;
        k += source.conductivity;
      }
      let Q;
      if (k === 0) {
        Q = Q0 + A * deltaTime / 1e3;
      } else {
        const B = A * this.capacity / k;
        Q = B + (Q0 - B) * Math.exp(-k * deltaTime / 1e3 / this.capacity);
      }
      this._value.set(Math.max(Q, 0) / this.capacity - 273.15);
    }
  };
  var Transform2D = class {
    constructor() {
      this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    /**
     * Gets the parameters of this transformation as a 6-tuple: `[scaleX, skewX, translateX, skewY, scaleY, translateY]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
      return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
      let scaleX = arg1;
      if (arg1 instanceof Transform2D) {
        [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewX;
      array[2] = translateX;
      array[3] = skewY;
      array[4] = scaleY;
      array[5] = translateY;
      return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
      this.array[4] = value;
      return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y) {
      this.array[0] = x;
      this.array[4] = y;
      return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param value The new x skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(value) {
      this.array[1] = value;
      return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param value The new y skew factor.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(value) {
      this.array[3] = value;
      return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
      this.array[2] = value;
      return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
      this.array[5] = value;
      return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y) {
      this.array[2] = x;
      this.array[5] = y;
      return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     */
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_10 = array[3];
      const e_11 = array[4];
      const e_12 = array[5];
      const i_00 = e_11;
      const i_01 = -e_10;
      const i_10 = -e_01;
      const i_11 = e_00;
      const i_20 = e_01 * e_12 - e_02 * e_11;
      const i_21 = -(e_00 * e_12 - e_02 * e_10);
      const det = e_00 * i_00 + e_01 * i_01;
      return this.set(i_00 / det, i_10 / det, i_20 / det, i_01 / det, i_11 / det, i_21 / det);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
      return new Transform2D().set(this);
    }
    /**
     * Applies this transformation to a 2D vector.
     * @param vec A 2D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
      const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
      return Vec2Math.set(x, y, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y) {
      Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
      Transform2D.offsetOriginCache[1] = this;
      Transform2D.offsetOriginCache[2].toTranslation(x, y);
      return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
      return this.set(1, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y) {
      return this.set(1, 0, x, 0, 1, y);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, originX, originY) {
      this.set(x, 0, 0, 0, y, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, originX, originY) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, -sin, 0, sin, cos, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toReflection(theta, originX, originY) {
      const sin = Math.sin(2 * theta);
      const cos = Math.cos(2 * theta);
      this.set(cos, sin, 0, sin, -cos, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, order = "after") {
      if (order === "before") {
        Transform2D.addCache[0].toTranslation(x, y);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        Transform2D.addCache[1].toTranslation(x, y);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, arg3, arg4, arg5) {
      let originX, originY, order;
      if (typeof arg3 === "number") {
        originX = arg3;
        originY = arg4;
        order = arg5;
      } else {
        order = arg3;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addReflection(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform2D.concatCache[0];
      const newTransform = Transform2D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 2; j++) {
            newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform2D.offsetOriginCache = [new Transform2D(), void 0, new Transform2D()];
  Transform2D.addCache = [new Transform2D(), new Transform2D()];
  Transform2D.concatCache = [new Transform2D(), new Transform2D()];
  var Transform3D = class {
    constructor() {
      this.array = new Float64Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    }
    /**
     * Gets the parameters of this transformation as a 12-tuple:
     * `[scaleX, skewX(Y), skewX(Z), translateX, skewY(X), scaleY, skewY(Z), translateY, skewZ(X), skewZ(Y), scaleZ, translateZ]`.
     * @returns The parameters of this transformation.
     */
    getParameters() {
      return this.array;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
      let scaleX = arg1;
      if (arg1 instanceof Transform3D) {
        [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewXY;
      array[2] = skewXZ;
      array[3] = translateX;
      array[4] = skewYX;
      array[5] = scaleY;
      array[6] = skewYZ;
      array[7] = translateY;
      array[8] = skewZX;
      array[9] = skewZY;
      array[10] = scaleZ;
      array[11] = translateZ;
      return this;
    }
    /**
     * Sets the x scaling factor of this transformation.
     * @param value The new x scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    /**
     * Sets the y scaling factor of this transformation.
     * @param value The new y scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleY(value) {
      this.array[5] = value;
      return this;
    }
    /**
     * Sets the z scaling factor of this transformation.
     * @param value The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScaleZ(value) {
      this.array[10] = value;
      return this;
    }
    /**
     * Sets the x and y scaling factors of this transformation.
     * @param x The new x scaling factor.
     * @param y The new y scaling factor.
     * @param z The new z scaling factor.
     * @returns This transformation, after it has been changed.
     */
    setScale(x, y, z) {
      this.array[0] = x;
      this.array[5] = y;
      this.array[10] = z;
      return this;
    }
    /**
     * Sets the x skew factor of this transformation.
     * @param y The new x skew factor along the y axis.
     * @param z The new x skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewX(y, z) {
      this.array[1] = y;
      this.array[2] = z;
      return this;
    }
    /**
     * Sets the y skew factor of this transformation.
     * @param x The new y skew factor along the x axis.
     * @param z The new y skew factor along the z axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewY(x, z) {
      this.array[4] = x;
      this.array[6] = z;
      return this;
    }
    /**
     * Sets the z skew factor of this transformation.
     * @param x The new z skew factor along the x axis.
     * @param y The new z skew factor along the y axis.
     * @returns This transformation, after it has been changed.
     */
    setSkewZ(x, y) {
      this.array[8] = x;
      this.array[9] = y;
      return this;
    }
    /**
     * Sets the x translation of this transformation.
     * @param value The new x translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateX(value) {
      this.array[3] = value;
      return this;
    }
    /**
     * Sets the y translation of this transformation.
     * @param value The new y translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateY(value) {
      this.array[7] = value;
      return this;
    }
    /**
     * Sets the z translation of this transformation.
     * @param value The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslateZ(value) {
      this.array[11] = value;
      return this;
    }
    /**
     * Sets the x and y translations of this transformation.
     * @param x The new x translation.
     * @param y The new y translation.
     * @param z The new z translation.
     * @returns This transformation, after it has been changed.
     */
    setTranslate(x, y, z) {
      this.array[3] = x;
      this.array[7] = y;
      this.array[11] = z;
      return this;
    }
    /**
     * Inverts this transformation.
     * @returns This transformation, after it has been inverted.
     * @throws Error if this transformation cannot be inverted.
     */
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_03 = array[3];
      const e_10 = array[4];
      const e_11 = array[5];
      const e_12 = array[6];
      const e_13 = array[7];
      const e_20 = array[8];
      const e_21 = array[9];
      const e_22 = array[10];
      const e_23 = array[11];
      const c_00 = e_11 * e_22 - e_12 * e_21;
      const c_01 = e_12 * e_20 - e_10 * e_22;
      const c_02 = e_10 * e_21 - e_11 * e_20;
      const c_10 = e_02 * e_21 - e_01 * e_22;
      const c_11 = e_00 * e_22 - e_02 * e_20;
      const c_12 = e_01 * e_20 - e_00 * e_21;
      const c_20 = e_01 * e_12 - e_02 * e_11;
      const c_21 = e_02 * e_10 - e_00 * e_12;
      const c_22 = e_00 * e_11 - e_01 * e_10;
      const det = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
      if (det === 0) {
        throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
      }
      const i_00 = c_00 / det;
      const i_01 = c_10 / det;
      const i_02 = c_20 / det;
      const i_10 = c_01 / det;
      const i_11 = c_11 / det;
      const i_12 = c_21 / det;
      const i_20 = c_02 / det;
      const i_21 = c_12 / det;
      const i_22 = c_22 / det;
      const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
      const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
      const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
      return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
      return new Transform3D().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector.
     * @param out The vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
      const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
      const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
      return Vec3Math.set(x, y, z, out);
    }
    /**
     * Changes this transformation to the one that is the result of offsetting this transformation's origin.
     * @param x The x-coordinate of the offset origin.
     * @param y The y-coordinate of the offset origin.
     * @param z The z-coordinate of the offset origin.
     * @returns This transformation, after it has been changed.
     */
    offsetOrigin(x, y, z) {
      Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
      Transform3D.offsetOriginCache[1] = this;
      Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
      return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    /**
     * Sets this transformation to the identity transformation.
     * @returns This transformation, after it has been changed.
     */
    toIdentity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    /**
     * Sets this transformation to a translation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @returns This transformation, after it has been changed.
     */
    toTranslation(x, y, z) {
      return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toScale(x, y, z, originX, originY, originZ) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationX(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(1, 0, 0, 0, 0, cos, -sin, 0, 0, sin, cos, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationY(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, 0, sin, 0, 0, 1, 0, 0, -sin, 0, cos, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotationZ(theta, originX, originY, originZ) {
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      this.set(cos, -sin, 0, 0, sin, cos, 0, 0, 0, 0, 1, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
      const abs = Math.hypot(axisX, axisY, axisZ);
      const ux = axisX / abs;
      const uy = axisY / abs;
      const uz = axisZ / abs;
      const ux_uy = ux * uy;
      const ux_uz = ux * uz;
      const uy_uz = uy * uz;
      const sin = Math.sin(theta);
      const cos = Math.cos(theta);
      const cosCompl = 1 - cos;
      this.set(cos + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin, ux_uz * cosCompl * uy * sin, 0, ux_uy * cosCompl + uz * sin, cos + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin, 0, ux_uz * cosCompl - uy * sin, uy_uz * cosCompl + ux * sin, cos + uz * uz * cosCompl, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    /**
     * Adds a translation to this transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param z The z translation.
     * @param order The order in which to add the translation, relative to this existing transformation, either
     * `'before'` or `'after'`. Defaults to `'after'`.
     * @returns This transformation, after it has been changed.
     */
    addTranslation(x, y, z, order = "after") {
      if (order === "before") {
        Transform3D.addCache[0].toTranslation(x, y, z);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        Transform3D.addCache[1].toTranslation(x, y, z);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
      let originX, originY, originZ, order;
      if (typeof arg4 === "number") {
        originX = arg4;
        originY = arg5;
        originZ = arg6;
        order = arg7;
      } else {
        order = arg4;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationX(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationY(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
      let originX, originY, originZ, order;
      if (typeof arg5 === "number") {
        originX = arg5;
        originY = arg6;
        originZ = arg7;
        order = arg8;
      } else {
        order = arg5;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    /**
     * Concatenates one or more transformations and returns the result. Concatenating transformations `[A, B, ...]`
     * results in a transformation that is equivalent to first applying `A`, then applying `B`, etc. Note that this order
     * is the _opposite_ of the one resulting from multiplying the individual transformation _matrices_
     * `M_A * M_B * ...`.
     *
     * If the number of transformations to concatenate equals zero, the identity matrix is returned.
     * @param out The transformation to which to write the result.
     * @param transforms The transformations to concatenate, in order.
     * @returns The result of concatenating all transformations in `transforms`.
     */
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform3D.concatCache[0];
      const newTransform = Transform3D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 3; j++) {
            newArray[j * 4 + i] = oldArray[i] * nextArray[j * 4] + oldArray[4 + i] * nextArray[j * 4 + 1] + oldArray[8 + i] * nextArray[j * 4 + 2] + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform3D.offsetOriginCache = [new Transform3D(), void 0, new Transform3D()];
  Transform3D.addCache = [new Transform3D(), new Transform3D()];
  Transform3D.concatCache = [new Transform3D(), new Transform3D()];
  var TransformPerspective = class {
    constructor() {
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create(0, 0, 1);
      this.cameraPosTransform = new Transform3D();
      this.cameraRotationTransform = new Transform3D();
      this.cameraRotationInverseTransform = new Transform3D();
      this.allCameraTransforms = [this.cameraPosTransform, this.cameraRotationInverseTransform];
      this.fullTransform = new Transform3D();
    }
    /**
     * Gets the position of this transformation's camera, as `[x, y, z]` in world coordinates.
     * @returns The position of this transformation's camera, as `[x, y, z]` in world coordinates.
     */
    getCameraPosition() {
      return this.cameraPos;
    }
    /**
     * Gets the transformation representing the rotation of this transformation's camera.
     * @returns The transformation representing the rotation of this transformation's camera.
     */
    getCameraRotation() {
      return this.cameraRotationTransform;
    }
    /**
     * Gets the position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns The position of this transformation's projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     */
    getSurfacePosition() {
      return this.cameraPos;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
      if (arg1 instanceof Float64Array) {
        this._setCameraPosition(arg1);
        this._setCameraRotation(arg2);
        this.setSurfacePosition(arg3);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
      } else {
        return this.set(arg1.getCameraPosition(), arg1.getCameraRotation(), arg1.getSurfacePosition());
      }
    }
    /**
     * Sets the position of this projection's camera. Does not update the full camera transformation.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     */
    _setCameraPosition(cameraPos) {
      Vec3Math.copy(cameraPos, this.cameraPos);
      this.cameraPosTransform.toTranslation(-cameraPos[0], -cameraPos[1], -cameraPos[2]);
    }
    /**
     * Sets the rotation of this projection's camera. Does not update the full camera transformation.
     * @param cameraRotation A transformation representing the rotation of the camera.
     */
    _setCameraRotation(cameraRotation) {
      this.cameraRotationTransform.set(cameraRotation);
      this.cameraRotationInverseTransform.set(cameraRotation).invert();
    }
    /**
     * Sets the position of this projection's camera.
     * @param cameraPos The position of the camera, as `[x, y, z]` in world coordinates.
     * @returns This transformation, after it has been changed.
     */
    setCameraPosition(cameraPos) {
      this._setCameraPosition(cameraPos);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    /**
     * Sets the rotation of this projection's camera.
     * @param cameraRotation A transformation representing the rotation of the camera.
     * @returns This transformation, after it has been changed.
     */
    setCameraRotation(cameraRotation) {
      this._setCameraRotation(cameraRotation);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    /**
     * Sets the position of this transformation's projection surface relative to the camera.
     * @param surfacePos The position of the projection surface relative to the camera, as `[x, y, z]` in camera
     * coordinates.
     * @returns This transformation, after it has been changed.
     */
    setSurfacePosition(surfacePos) {
      Vec3Math.copy(surfacePos, this.surfacePos);
      return this;
    }
    /**
     * Copies this transformation.
     * @returns A copy of this transformation.
     */
    copy() {
      return new TransformPerspective().set(this);
    }
    /**
     * Applies this transformation to a 3D vector.
     * @param vec A 3D vector, in world coordinates.
     * @param out The 2D vector to which to write the result.
     * @returns The result of applying this transformation to `vec`.
     */
    apply(vec, out) {
      const transformedVec = this.fullTransform.apply(vec, TransformPerspective.vec3Cache[0]);
      if (Vec3Math.abs(transformedVec) < 1e-7) {
        return Vec2Math.set(0, 0, out);
      }
      if (transformedVec[2] < 0) {
        return Vec2Math.set(NaN, NaN, out);
      }
      const ratio = this.surfacePos[2] / transformedVec[2];
      return Vec2Math.set(transformedVec[0] * ratio + this.surfacePos[0], transformedVec[1] * ratio + this.surfacePos[1], out);
    }
  };
  TransformPerspective.vec3Cache = [Vec3Math.create()];
  var SimpleMovingAverage = class {
    /**
     * Class to return a numerical average from a specified number of inputs.
     * @param samples is the number of samples.
     */
    constructor(samples) {
      this.samples = samples;
      this._values = [];
    }
    /**
     * Returns a numerical average of the inputs.
     * @param input is the input number.
     * @returns The numerical average.
     */
    getAverage(input) {
      if (this._values.length === this.samples) {
        this._values.splice(0, 1);
      }
      this._values.push(input);
      let sum = 0;
      this._values.forEach((v) => {
        sum += v;
      });
      return sum / this._values.length;
    }
    /**
     * Resets the average.
     */
    reset() {
      this._values = [];
    }
  };
  var MathUtils = class {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value, precision = 1) {
      return Math.round(value / precision) * precision;
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
      const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
      return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      if (x0 !== x1 && y0 !== y1) {
        const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
        return fraction * (y1 - y0) + y0;
      } else {
        return y0;
      }
    }
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      const length = Math.min(y0.length, y1.length, out.length);
      for (let i = 0; i < length; i++) {
        out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
      }
      return out;
    }
  };
  MathUtils.TWO_PI = Math.PI * 2;
  MathUtils.HALF_PI = Math.PI / 2;
  var ExpSmoother = class {
    /**
     * Constructor.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
      this.tau = tau;
      this.dtThreshold = dtThreshold;
      this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last() {
      return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
      let next;
      if (this.tau > 0 && this.lastValue !== null) {
        const factor = this.calculateFactor(dt);
        next = ExpSmoother.smooth(raw, this.lastValue, factor);
      } else {
        next = raw;
      }
      this.lastValue = next;
      return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
      if (dt > this.dtThreshold) {
        return 0;
      } else {
        return Math.exp(-dt / this.tau);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
      return this.lastValue = value !== null && value !== void 0 ? value : null;
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
      return value * (1 - factor) + last * factor;
    }
  };
  var Lookahead = class {
    /**
     * Constructor.
     * @param lookahead This calculator's lookahead time.
     * @param valueSmoothingTau The smoothing time constant to apply to the calculator's input values before rate of
     * change is computed. A value of `0` is equivalent to no smoothing. Defaults to `0`.
     * @param trendSmoothingTau The smoothing time constant to apply to the calculator's computed trend values. A value
     * of `0` is equivalent to no smoothing. Defaults to `0`.
     */
    constructor(lookahead, valueSmoothingTau = 0, trendSmoothingTau = 0) {
      this.lookahead = lookahead;
      this.lastSmoothedValue = null;
      this.lastTrendValue = 0;
      this.lastLookaheadValue = null;
      this.lastSmoothedLookaheadValue = null;
      this.valueSmoother = new ExpSmoother(valueSmoothingTau);
      this.trendSmoother = new ExpSmoother(trendSmoothingTau);
    }
    /**
     * Gets this calculator's last computed lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param smoothed Whether to retrieve the lookahead value computed using the last smoothed input value instead of
     * the raw input value as the present (`t = 0`) value. Defaults to `false`.
     * @returns This calculator's last computed lookahead value.
     */
    last(smoothed = false) {
      return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Gets this calculator's last computed trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @returns This calculator's last computed trend value.
     */
    lastTrend() {
      return this.lastTrendValue;
    }
    /**
     * Adds a new input value and gets the next lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @param smoothed Whether to return the lookahead value computed using the smoothed input value instead of the raw
     * input value as the present (`t = 0`) value. Note that this argument does not determine whether smoothing is
     * applied for the purposes of calculating rate of change (smoothing is always applied for this purpose if a positive
     * time constant is defined). Defaults to `false`.
     * @returns The next lookahead value.
     */
    next(value, dt, smoothed = false) {
      const oldSmoothedValue = this.lastSmoothedValue;
      let trend;
      if (dt < 0) {
        return this.reset(value);
      } else if (dt > 0) {
        this.lastSmoothedValue = this.valueSmoother.next(value, dt);
        if (oldSmoothedValue === null) {
          this.trendSmoother.reset();
          trend = 0;
        } else {
          trend = this.trendSmoother.next((this.lastSmoothedValue - oldSmoothedValue) / dt * this.lookahead, dt);
        }
      } else {
        trend = this.lastTrendValue;
        this.lastSmoothedValue = this.valueSmoother.next(value, dt);
      }
      this.lastTrendValue = trend;
      this.lastLookaheadValue = value + trend;
      this.lastSmoothedLookaheadValue = this.lastSmoothedValue + trend;
      return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Adds a new input value and gets the next trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @returns The next trend value.
     */
    nextTrend(value, dt) {
      this.next(value, dt);
      return this.lastTrendValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
      this.lastSmoothedValue = this.valueSmoother.reset(value);
      this.trendSmoother.reset();
      this.lastTrendValue = 0;
      this.lastLookaheadValue = this.lastSmoothedValue;
      this.lastSmoothedLookaheadValue = this.lastSmoothedValue;
      return this.lastLookaheadValue;
    }
  };
  var GeoPointReadOnly = class {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
      this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
      return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
      return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distance(arg1, arg2);
      } else {
        return this.source.distance(arg1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distanceRhumb(arg1, arg2);
      } else {
        return this.source.distanceRhumb(arg1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingTo(arg1, arg2);
      } else {
        return this.source.bearingTo(arg1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingFrom(arg1, arg2);
      } else {
        return this.source.bearingFrom(arg1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingRhumb(arg1, arg2);
      } else {
        return this.source.bearingRhumb(arg1);
      }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.antipode(out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
      return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2, arg3);
      } else {
        return this.source.equals(arg1, arg2);
      }
    }
    /** @inheritdoc */
    copy(to) {
      return this.source.copy(to);
    }
  };
  var GeoPoint = class {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
      this._lat = 0;
      this._lon = 0;
      this.set(lat, lon);
      this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
      return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
      return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
      if (typeof arg1 === "number") {
        return GeoPoint.tempGeoPoint.set(arg1, arg2);
      } else {
        return arg1;
      }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
      } else {
        return arg1;
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      lat = GeoPoint.toPlusMinus180(lat);
      lon = GeoPoint.toPlusMinus180(lon);
      if (Math.abs(lat) > 90) {
        lat = 180 - lat;
        lat = GeoPoint.toPlusMinus180(lat);
        lon += 180;
        lon = GeoPoint.toPlusMinus180(lon);
      }
      this._lat = lat;
      this._lon = lon;
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
      const vec = GeoPoint.asVec3(arg1, arg2, arg3);
      const theta = Vec3Math.theta(vec);
      const phi = Vec3Math.phi(vec);
      return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(latRad);
      const cosLat = Math.cos(latRad);
      const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
      const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
      const angularDistance = distance;
      const sinAngularDistance = Math.sin(angularDistance);
      const cosAngularDistance = Math.cos(angularDistance);
      const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
      const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
      const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
      const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const bearingRad = bearing * Avionics.Utils.DEG2RAD;
      const deltaLat = distance * Math.cos(bearingRad);
      let offsetLat = latRad + deltaLat;
      let offsetLon;
      if (Math.abs(offsetLat) >= Math.PI / 2) {
        offsetLat = Math.sign(offsetLat) * 90;
        offsetLon = 0;
      } else {
        const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
        const deltaLon = distance * Math.sin(bearingRad) / correction;
        offsetLon = lonRad + deltaLon;
        offsetLat *= Avionics.Utils.RAD2DEG;
        offsetLon *= Avionics.Utils.RAD2DEG;
      }
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out) {
      return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    /** @inheritdoc */
    toCartesian(out) {
      return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      if (other) {
        if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
          return true;
        }
        const tolerance = typeof arg1 === "number" ? arg3 : arg2;
        const distance = this.distance(other);
        return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return false;
      }
    }
    /** @inheritdoc */
    copy(to) {
      return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
      const point = GeoPoint.asLatLonInterface(arg1, arg2);
      const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
      const phi = point.lon * Avionics.Utils.DEG2RAD;
      return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
      if (arg1 instanceof Float64Array) {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      } else if (typeof arg1 === "number") {
        return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof Float64Array) {
        return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
      } else {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === "number") {
          lat1 = arg1;
          lon1 = arg2;
          lat2 = arg3;
          lon2 = arg4;
        } else {
          lat1 = arg1.lat;
          lon1 = arg1.lon;
          lat2 = arg2.lat;
          lon2 = arg2.lon;
        }
        lat1 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
        const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
        const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
      let lat1, lon1, lat2, lon2;
      if (typeof arg1 === "number") {
        lat1 = arg1 * Avionics.Utils.DEG2RAD;
        lon1 = arg2 * Avionics.Utils.DEG2RAD;
        lat2 = arg3 * Avionics.Utils.DEG2RAD;
        lon2 = arg4 * Avionics.Utils.DEG2RAD;
      } else if (arg1 instanceof Float64Array) {
        const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
        lat1 = point1.lat;
        lon1 = point1.lon;
        const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
        lat2 = point2.lat;
        lon2 = point2.lon;
      } else {
        lat1 = arg1.lat;
        lon1 = arg1.lon;
        lat2 = arg2.lat;
        lon2 = arg2.lon;
      }
      const deltaLat = lat2 - lat1;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      const cosLat2 = Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
      const y = Math.sin(lon2 - lon1) * cosLat2;
      const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
      return (bearing + 360) % 360;
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
      return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
      return (angle % 360 + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
      return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
      return Math.abs(deltaPsi) > 1e-12 ? (latRad2 - latRad1) / deltaPsi : Math.cos(latRad1);
    }
  };
  GeoPoint.EQUALITY_TOLERANCE = 1e-7;
  GeoPoint.tempVec3 = new Float64Array(3);
  GeoPoint.tempGeoPoint = new GeoPoint(0, 0);
  var GeoCircle = class {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
      this._center = new Float64Array(3);
      this._radius = 0;
      this._sinRadius = 0;
      this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
      return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
      return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
      return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
      return this._sinRadius * angle;
    }
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length) {
      return length / this._sinRadius;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
      if (center instanceof Float64Array) {
        if (Vec3Math.abs(center) === 0) {
          Vec3Math.set(1, 0, 0, this._center);
        } else {
          Vec3Math.normalize(center, this._center);
        }
      } else {
        GeoPoint.sphericalToCartesian(center, this._center);
      }
      this._radius = Math.abs(radius) % Math.PI;
      this._sinRadius = Math.sin(this._radius);
      return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
      this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
      return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
      Vec3Math.multScalar(this._center, -1, this._center);
      this._radius = Math.PI - this._radius;
      return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
      if (point instanceof Float64Array) {
        point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
      } else {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const dot = Vec3Math.dot(point, this._center);
      return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
      const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
      const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
        return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
      }
      const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
      const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
      return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
      const distanceToCenter = this.distanceToCenter(point);
      return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return inclusive ? distance <= tolerance : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
      }
      if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
        throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
      const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
      const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
      const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
      return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angle = distance / Math.sin(this.radius);
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this.radius === 0) {
        return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
      }
      point = this.closest(point, GeoCircle.vec3Cache[3]);
      const sin = Math.sin(angle / 2);
      const q0 = Math.cos(angle / 2);
      const q1 = sin * this._center[0];
      const q2 = sin * this._center[1];
      const q3 = sin * this._center[2];
      const q0Sq = q0 * q0;
      const q1Sq = q1 * q1;
      const q2Sq = q2 * q2;
      const q3Sq = q3 * q3;
      const q01 = q0 * q1;
      const q02 = q0 * q2;
      const q03 = q0 * q3;
      const q12 = q1 * q2;
      const q13 = q1 * q3;
      const q23 = q2 * q3;
      const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
      const rot_12 = 2 * (q12 - q03);
      const rot_13 = 2 * (q13 + q02);
      const rot_21 = 2 * (q12 + q03);
      const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
      const rot_23 = 2 * (q23 - q01);
      const rot_31 = 2 * (q13 - q02);
      const rot_32 = 2 * (q23 + q01);
      const rot_33 = q0Sq - q1Sq - q2Sq + q3Sq;
      const x = point[0];
      const y = point[1];
      const z = point[2];
      const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
      const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
      const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
      return out instanceof Float64Array ? Vec3Math.set(rotX, rotY, rotZ, out) : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
      const center1 = this._center;
      const center2 = other._center;
      const radius1 = this._radius;
      const radius2 = other._radius;
      const dot = Vec3Math.dot(center1, center2);
      const dotSquared = dot * dot;
      if (dotSquared === 1) {
        return 0;
      }
      const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross, cross);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
      let solutionCount = 1;
      if (!out[0]) {
        out[0] = new Float64Array(3);
      }
      out[0].set(cross);
      Vec3Math.multScalar(out[0], offset, out[0]);
      Vec3Math.add(out[0], intersection, out[0]);
      if (offset > 0) {
        if (!out[1]) {
          out[1] = new Float64Array(3);
        }
        out[1].set(cross);
        Vec3Math.multScalar(out[1], -offset, out[1]);
        Vec3Math.add(out[1], intersection, out[1]);
        solutionCount++;
      }
      return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
      const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
      for (let i = 0; i < solutionCount; i++) {
        if (!out[i]) {
          out[i] = new GeoPoint(0, 0);
        }
        out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
      }
      return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const center1 = this.center;
      const center2 = other.center;
      const radius1 = this.radius;
      const radius2 = other.radius;
      const dot = Vec3Math.dot(center1, center2);
      const dotSquared = dot * dot;
      if (dotSquared === 1) {
        if (dot === 1) {
          return Math.abs(this.radius - other.radius) <= tolerance ? NaN : 0;
        } else {
          return Math.abs(Math.PI - this.radius - other.radius) <= tolerance ? NaN : 0;
        }
      }
      const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross, cross);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const sinTol = Math.sin(tolerance);
      return (1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
      return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
      return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
      return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
      return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
      if (typeof arg2 === "number") {
        return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
      } else {
        return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
      }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
      if (!(point1 instanceof Float64Array)) {
        point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
      }
      return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
      if (point instanceof Float64Array) {
        point = GeoCircle.tempGeoPoint.setFromCartesian(point);
      }
      const lat = point.lat * Avionics.Utils.DEG2RAD;
      const long = point.lon * Avionics.Utils.DEG2RAD;
      bearing *= Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(lat);
      const sinLon = Math.sin(long);
      const cosLon = Math.cos(long);
      const sinBearing = Math.sin(bearing);
      const cosBearing = Math.cos(bearing);
      const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
      const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
      const z = Math.cos(lat) * sinBearing;
      return Vec3Math.set(x, y, z, out);
    }
  };
  GeoCircle.ANGULAR_TOLERANCE = 1e-7;
  GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
  GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
  GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var NavMath = class {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
      if (isFinite(heading)) {
        return (heading % 360 + 360) % 360;
      } else {
        console.error(`normalizeHeading: Invalid heading: ${heading}`);
        return NaN;
      }
    }
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading) {
      return NavMath.normalizeHeading(heading + 180);
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue, bankAngle) {
      return Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)) / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
      const airspeedMS = airspeedTrue * 0.51444444;
      return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
      return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? "left" : "right";
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
      return NavMath.normalizeHeading(180 / Math.PI * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
      return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
      const angularWidth = (endBearing - startBearing + 360) % 360 * Avionics.Utils.DEG2RAD;
      const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
      return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const a = dx * dx + dy * dy;
      const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
      const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
      const det = b * b - 4 * a * c;
      if (a < 1e-7 || det < 0) {
        sRef.x1 = NaN;
        sRef.x2 = NaN;
        sRef.y1 = NaN;
        sRef.y2 = NaN;
        return 0;
      } else if (det == 0) {
        const t = -b / (2 * a);
        sRef.x1 = x1 + t * dx;
        sRef.y1 = y1 + t * dy;
        sRef.x2 = NaN;
        sRef.y2 = NaN;
        return 1;
      } else {
        const t1 = (-b + Math.sqrt(det)) / (2 * a);
        sRef.x1 = x1 + t1 * dx;
        sRef.y1 = y1 + t1 * dy;
        const t2 = (-b - Math.sqrt(det)) / (2 * a);
        sRef.x2 = x1 + t2 * dx;
        sRef.y2 = y1 + t2 * dy;
        return 2;
      }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
      return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
      const range = this.normalizeHeading(end - start);
      const relativeBearing = this.normalizeHeading(bearing - start);
      return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
      return NavMath.normalizeHeading(heading + (turnDirection === "left" ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
      return NavMath.normalizeHeading(angle + (turnDirection === "left" ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
      const currCrosswind = windSpeed * Math.sin(course * Math.PI / 180 - windDirection * Math.PI / 180);
      const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
      return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
      return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
      const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
      return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
      const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
      const sign = turnDirection === "right" ? 1 : -1;
      const alpha = ((end - start) * sign + 360) % 360;
      const mid = (start + alpha / 2 * sign + 360) % 360;
      const rotBearing = (bearingFromCenter - mid + 540) % 360 - 180;
      const frac = rotBearing * sign / alpha + 0.5;
      return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
      const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
      const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
      const bearing = turnDirection === "right" ? start + theta : start - theta;
      center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
      return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
      return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
      let diff = b - a;
      while (diff > 180) {
        diff -= 360;
      }
      while (diff <= -180) {
        diff += 360;
      }
      return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
      return 2 * Math.atan(Math.tan(0.5 * (b - c)) * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
      const normalCourse = NavMath.headingToAngle(course, turnDirection);
      const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
      outVector[0] = Math.cos(polarCourse);
      outVector[1] = Math.sin(polarCourse);
    }
  };
  NavMath.vec3Cache = [new Float64Array(3)];
  NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MagVar = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
      return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing + (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing - (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
      if (typeof Facilities === "undefined") {
        return 0;
      }
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      return Facilities.getMagVar(lat, lon);
    }
  };
  var GeoPointSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    constructor(value, tolerance) {
      super();
      this.value = value;
      this.tolerance = tolerance;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal, tolerance) {
      return new GeoPointSubject(initialVal, tolerance);
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal) {
      return new GeoPointSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
      return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var AbstractGeoProjection = class {
    constructor() {
      this.center = new GeoPoint(0, 0);
      this.centerTranslation = new Float64Array(2);
      this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
      this.preRotation = new Float64Array(3);
      this.translation = new Float64Array(2);
      this.postRotation = 0;
      this.rotationSin = 0;
      this.rotationCos = 1;
      this.reflectY = 1;
      this.preRotationForwardTransform = new Transform3D();
      this.preRotationReverseTransform = new Transform3D();
      this.rotationCache = [new Transform3D(), new Transform3D()];
    }
    /** @inheritdoc */
    getCenter() {
      return this.center.readonly;
    }
    /** @inheritdoc */
    getScaleFactor() {
      return this.scaleFactor;
    }
    /** @inheritdoc */
    getPreRotation() {
      return this.preRotation;
    }
    /** @inheritdoc */
    getTranslation() {
      return this.translation;
    }
    /** @inheritdoc */
    getPostRotation() {
      return this.postRotation;
    }
    /** @inheritdoc */
    getReflectY() {
      return this.reflectY === -1;
    }
    /** @inheritdoc */
    setCenter(point) {
      this.center.set(point);
      this.updateCenterTranslation();
      return this;
    }
    /** @inheritdoc */
    setScaleFactor(factor) {
      this.scaleFactor = factor;
      return this;
    }
    /** @inheritdoc */
    setPreRotation(vec) {
      this.preRotation.set(vec);
      this.updatePreRotationTransforms();
      this.updateCenterTranslation();
      return this;
    }
    /** @inheritdoc */
    setTranslation(vec) {
      this.translation.set(vec);
      return this;
    }
    /** @inheritdoc */
    setPostRotation(rotation) {
      this.postRotation = rotation;
      this.rotationCos = Math.cos(rotation);
      this.rotationSin = Math.sin(rotation);
      return this;
    }
    /** @inheritdoc */
    setReflectY(val) {
      this.reflectY = val ? -1 : 1;
      return this;
    }
    /** @inheritdoc */
    copyParametersFrom(other) {
      return this.setCenter(other.getCenter()).setPreRotation(other.getPreRotation()).setScaleFactor(other.getScaleFactor()).setTranslation(other.getTranslation()).setPostRotation(other.getPostRotation()).setReflectY(other.getReflectY());
    }
    /**
     * Updates the pre-rotation transformation matrices.
     */
    updatePreRotationTransforms() {
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      this.rotationCache[0].toRotationX(gamma);
      this.rotationCache[1].toRotationY(-phi);
      Transform3D.concat(this.preRotationForwardTransform, this.rotationCache);
      this.preRotationReverseTransform.set(this.preRotationForwardTransform);
      this.preRotationReverseTransform.invert();
    }
    /**
     * Updates the translation vector to move the center of this projection to the origin.
     */
    updateCenterTranslation() {
      const centerArray = AbstractGeoProjection.vec2Cache[0];
      centerArray[0] = this.center.lon;
      centerArray[1] = this.center.lat;
      this.preRotateForward(centerArray, centerArray);
      this.projectRaw(centerArray, this.centerTranslation);
    }
    /**
     * Applies a forward rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateForward(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      if (phi === 0 && gamma === 0) {
        return Vec2Math.set(rotatedLon, lat, out);
      }
      const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
      const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
      const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
      return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    /**
     * Applies a reverse rotation to a set of lat/lon coordinates using this projection's pre-projection rotation angles.
     * @param vec - the lat/lon coordinates to rotate, as a vector ([long, lat]).
     * @param out - the vector to which to write the result.
     * @returns the rotated lat/lon coordinates.
     */
    preRotateReverse(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      let rotatedLat = lat;
      let rotatedLon = lon;
      if (phi !== 0 || gamma !== 0) {
        const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
        const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
        rotatedLat = unrotated.lat;
        rotatedLon = unrotated.lon;
      }
      rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    /** @inheritdoc */
    project(point, out) {
      if (point instanceof Float64Array) {
        out.set(point);
      } else {
        out[0] = point.lon;
        out[1] = point.lat;
      }
      this.preRotateForward(out, out);
      this.projectRaw(out, out);
      out[0] -= this.centerTranslation[0];
      out[1] -= this.centerTranslation[1];
      out[1] *= this.reflectY;
      out[0] *= this.scaleFactor;
      out[1] *= this.scaleFactor;
      const x = out[0];
      const y = out[1];
      out[0] = x * this.rotationCos - y * this.rotationSin;
      out[1] = x * this.rotationSin + y * this.rotationCos;
      out[0] += this.translation[0];
      out[1] += this.translation[1];
      return out;
    }
    /** @inheritdoc */
    invert(vec, out) {
      const projected = AbstractGeoProjection.vec2Cache[0];
      projected.set(vec);
      projected[0] -= this.translation[0];
      projected[1] -= this.translation[1];
      const x = projected[0];
      const y = projected[1];
      projected[0] = x * this.rotationCos + y * this.rotationSin;
      projected[1] = -x * this.rotationSin + y * this.rotationCos;
      projected[0] /= this.scaleFactor;
      projected[1] /= this.scaleFactor;
      projected[1] *= this.reflectY;
      projected[0] += this.centerTranslation[0];
      projected[1] += this.centerTranslation[1];
      const inverted = this.invertRaw(projected, projected);
      this.preRotateReverse(inverted, inverted);
      if (out instanceof Float64Array) {
        out.set(inverted);
        return out;
      } else {
        return out.set(inverted[1], inverted[0]);
      }
    }
  };
  AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
  AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
  AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
  var MercatorProjection = class extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.DEG2RAD;
      out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
      return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.RAD2DEG;
      out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
      return out;
    }
  };
  var OrthographicProjection = class extends AbstractGeoProjection {
    /**
     * Applies a raw projection.
     * @param vec - a [lon, lat] vector describing the geographic point to project.
     * @param out - a 2D vector to which to write the result.
     * @returns the projected point.
     */
    projectRaw(vec, out) {
      const lonRad = vec[0] * Avionics.Utils.DEG2RAD;
      const latRad = vec[1] * Avionics.Utils.DEG2RAD;
      out[0] = Math.cos(latRad) * Math.sin(lonRad);
      out[1] = Math.sin(latRad);
      return out;
    }
    /**
     * Inverts a raw projection.
     * @param vec - a 2D vector describing the projected point to invert.
     * @param out - a 2D vector to which to write the result.
     * @returns the inverted point.
     */
    invertRaw(vec, out) {
      const x = vec[0];
      const y = vec[1];
      const rho = Math.hypot(x, y);
      const c = Math.asin(rho);
      const sinC = Math.sin(c);
      const cosC = Math.cos(c);
      out[0] = Math.atan2(x * sinC, rho * cosC) * Avionics.Utils.RAD2DEG;
      out[1] = Math.asin(rho === 0 ? rho : y * sinC / rho) * Avionics.Utils.RAD2DEG;
      return out;
    }
  };
  var GeodesicResampler = class {
    /**
     * Constructor.
     * @param minDistance The minimum geodesic distance this resampler enforces between two adjacent resampled points, in
     * great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance this resampler uses when deciding whether to discard a resampled
     * point during the line simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by 2^[maxDepth] - 1.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
      this.minDistance = minDistance;
      this.dpTolerance = dpTolerance;
      this.maxDepth = maxDepth;
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.cosMinDistance = Math.cos(minDistance);
      this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected geodesic (great-circle) path.
     * @param projection The projection to use.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     * @throws Error when the start and end of the path are antipodal.
     */
    resample(projection, start, end, handler) {
      const startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
      const endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
      const startProjected = projection.project(start, this.vec2Cache[0]);
      const endProjected = projection.project(end, this.vec2Cache[1]);
      handler(this.geoPointCache[0].set(start), startProjected, 0);
      const index = this.resampleHelper(projection, start.lat, start.lon, startVec[0], startVec[1], startVec[2], startProjected[0], startProjected[1], end.lat, end.lon, endVec[0], endVec[1], endVec[2], endProjected[0], endProjected[1], handler, 0, 1);
      handler(this.geoPointCache[0].set(end), endProjected, index);
    }
    /**
     * Resamples a projected geodesic (great-circle) path. This method will recursively split the path into two halves
     * and resample the midpoint. Recursion continues as long as the maximum depth has not been reached and at least one
     * of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * The Douglas-Peucker metric of the projected midpoint is greater than or equal to the set tolerance.
     * @param projection The projection to use.
     * @param lat1 The latitude of the start of the path.
     * @param lon1 The longitude of the start of the path.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path.
     * @param projY1 The y-component of the projected location of the start of the path.
     * @param lat2 The latitude of the end of the path.
     * @param lon2 The longitude of the end of the path.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path.
     * @param projY2 The y-component of the projected location of the end of the path.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param index The index of the next resampled point.
     * @returns The index of the next resampled point.
     * @throws Error when the start and end of the path are antipodal.
     */
    resampleHelper(projection, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, index) {
      if (depth >= this.maxDepth) {
        return index;
      }
      const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
      const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
      const sumVec = Vec3Math.add(startVec, endVec, this.vec3Cache[2]);
      if (Vec3Math.dot(sumVec, sumVec) === 0) {
        throw new Error("Cannot resample from antipodal endpoints.");
      }
      const midVec = Vec3Math.normalize(sumVec, sumVec);
      const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
      const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
      const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
      const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
      const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
      const midProjected = projection.project(midPoint, this.vec2Cache[2]);
      const lat0 = midPoint.lat;
      const lon0 = midPoint.lon;
      const x0 = midVec[0];
      const y0 = midVec[1];
      const z0 = midVec[2];
      const projX0 = midProjected[0];
      const projY0 = midProjected[1];
      const cosDistance = Vec3Math.dot(startVec, midVec);
      if (cosDistance > this.cosMinDistance) {
        const area = (projX2 - projX1) * (projY1 - projY0) - (projX1 - projX0) * (projY2 - projY1);
        const dpDisSq = area * area / deltaProjectedDot;
        if (dpDisSq < this.dpTolSq) {
          return index;
        }
      }
      index = this.resampleHelper(projection, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, index);
      handler(this.geoPointCache[0].set(lat0, lon0), Vec2Math.set(projX0, projY0, this.vec2Cache[0]), index);
      return this.resampleHelper(projection, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, index + 1);
    }
  };
  var GeoCircleResampler = class {
    /**
     * Constructor.
     * @param minDistance The minimum great-circle distance this resampler enforces between two adjacent resampled
     * points, in great-arc radians.
     * @param dpTolerance The Douglas-Peucker tolerance, in pixels, this resampler uses when deciding whether to discard
     * a resampled point during the simplification process.
     * @param maxDepth The maximum depth of the resampling algorithm used by this resampler. The number of resampled
     * points is bounded from above by `2^[maxDepth] - 1`.
     */
    constructor(minDistance, dpTolerance, maxDepth) {
      this.minDistance = minDistance;
      this.dpTolerance = dpTolerance;
      this.maxDepth = maxDepth;
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.startVector = {
        type: "start",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.lineVector = {
        type: "line",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.arcVector = {
        type: "arc",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        projectedArcCenter: new Float64Array(2),
        projectedArcRadius: 0,
        projectedArcStartAngle: 0,
        projectedArcEndAngle: 0,
        index: 0
      };
      this.state = {
        index: 0,
        prevX: 0,
        prevY: 0,
        vectorType: "line",
        arcCenterX: 0,
        arcCenterY: 0,
        arcRadius: 0,
        isArcCounterClockwise: false
      };
      this.cosMinDistance = Math.cos(minDistance);
      this.dpTolSq = dpTolerance * dpTolerance;
    }
    /**
     * Resamples a projected great- or small-circle path.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param start The start of the path.
     * @param end The end of the path.
     * @param handler A function to handle the resampled points. The function is called once for each resampled point,
     * in order.
     */
    resample(projection, circle, start, end, handler) {
      let startPoint, startVec, endPoint, endVec;
      if (start instanceof Float64Array) {
        startPoint = this.geoPointCache[0].setFromCartesian(start);
        startVec = start;
      } else {
        startPoint = start;
        startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
      }
      if (end instanceof Float64Array) {
        endPoint = this.geoPointCache[0].setFromCartesian(end);
        endVec = end;
      } else {
        endPoint = end;
        endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
      }
      const startLat = startPoint.lat;
      const startLon = startPoint.lon;
      const endLat = endPoint.lat;
      const endLon = endPoint.lon;
      const startProjected = projection.project(start, this.vec2Cache[0]);
      const endProjected = projection.project(end, this.vec2Cache[1]);
      const startX = startProjected[0];
      const startY = startProjected[1];
      const endX = endProjected[0];
      const endY = endProjected[1];
      this.startVector.point.set(startLat, startLon);
      Vec2Math.copy(startProjected, this.startVector.projected);
      handler(this.startVector);
      this.state.index = 1;
      this.state.prevX = startX;
      this.state.prevY = startY;
      this.state.vectorType = "line";
      const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
      this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    /**
     * Resamples a projected great- or small-circle path. This method will recursively split the path into two halves
     * and resample the midpoint. Based on the projected position of the midpoint relative to those of the start and end
     * points, the projected path is modeled as either a straight line from the start to the end or a circular arc
     * connecting the start, end, and midpoints. Recursion continues as long as the maximum depth has not been reached
     * and at least one of the following conditions is met:
     * * The distance from the midpoint to the endpoints is greater than or equal to the minimum resampling distance.
     * * If the path is modeled as a line: the distance from the projected midpoint to the model line is greater than
     * this resampler's Douglas-Peucker tolerance.
     * * If the path is modeled as an arc: the distance from the projected one-quarter or the three-quarter point along
     * the path to the model arc is greater than this resampler's Douglas-Peucker tolerance.
     * @param projection The projection to use.
     * @param circle The geo circle along which the path lies.
     * @param lat1 The latitude of the start of the path, in degrees.
     * @param lon1 The longitude of the start of the path, in degrees.
     * @param x1 The x-component of the Cartesian position vector of the start of the path.
     * @param y1 The y-component of the Cartesian position vector of the start of the path.
     * @param z1 The z-component of the Cartesian position vector of the start of the path.
     * @param projX1 The x-component of the projected location of the start of the path, in pixels.
     * @param projY1 The y-component of the projected location of the start of the path, in pixels.
     * @param lat2 The latitude of the end of the path, in degrees.
     * @param lon2 The longitude of the end of the path, in degrees.
     * @param x2 The x-component of the Cartesian position vector of the end of the path.
     * @param y2 The y-component of the Cartesian position vector of the end of the path.
     * @param z2 The z-component of the Cartesian position vector of the end of the path.
     * @param projX2 The x-component of the projected location of the end of the path, in pixels.
     * @param projY2 The y-component of the projected location of the end of the path, in pixels.
     * @param handler A function to handle the resampled points.
     * @param depth The current depth of the resampling algorithm.
     * @param state The current state of the resampling algorithm.
     * @returns The index of the next resampled point.
     */
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
      if (depth >= this.maxDepth) {
        return state;
      }
      const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
      const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
      const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
      if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
        return state;
      }
      const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
      const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
      const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
      const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
      const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
      const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
      const midProjected = projection.project(midPoint, this.vec2Cache[2]);
      const lat0 = midPoint.lat;
      const lon0 = midPoint.lon;
      const x0 = midVec[0];
      const y0 = midVec[1];
      const z0 = midVec[2];
      const projX0 = midProjected[0];
      const projY0 = midProjected[1];
      const A = projX2 - projX1;
      const B = projY2 - projY1;
      const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
      const D = projX0 - projX1;
      const E = projY0 - projY1;
      const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
      const det = 2 * (A * E - B * D);
      const dpDisSq = det * det / 4 / deltaProjectedDot;
      if (dpDisSq > this.dpTolSq) {
        const arcCenterX = (B * F - C * E) / det;
        const arcCenterY = (C * D - A * F) / det;
        const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
        const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
        const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
        const cross = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
        state.vectorType = "arc";
        state.arcCenterX = arcCenterX;
        state.arcCenterY = arcCenterY;
        state.arcRadius = arcRadius;
        state.isArcCounterClockwise = cross[2] > 0;
      } else {
        state.vectorType = "line";
      }
      const cosDistance = Vec3Math.dot(startVec, midVec);
      if (cosDistance > this.cosMinDistance) {
        if (state.vectorType === "line") {
          return state;
        }
        const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
        const projectedQuery = projection.project(query, this.vec2Cache[0]);
        let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
        if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
          circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
          projection.project(query, projectedQuery);
          distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
          if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
            return state;
          }
        }
      }
      state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
      this.callHandler(handler, lat0, lon0, projX0, projY0, state);
      state.index++;
      state.prevX = projX0;
      state.prevY = projY0;
      return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    /**
     * Calls a handler function for a resampled point.
     * @param handler The handler function to call.
     * @param lat The latitude of the resampled point, in degrees.
     * @param lon The longitude of the resampled point, in degrees.
     * @param projX The x-coordinate of the projected resampled point, in pixels.
     * @param projY The y-coordinate of the projected resampled point, in pixels.
     * @param state The current state of the resampling algorithm.
     */
    callHandler(handler, lat, lon, projX, projY, state) {
      let vector;
      if (state.vectorType === "line") {
        vector = this.lineVector;
      } else {
        vector = this.arcVector;
        Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
        vector.projectedArcRadius = state.arcRadius;
        vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
        vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
        if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
          vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils.TWO_PI : MathUtils.TWO_PI;
        }
      }
      vector.point.set(lat, lon);
      Vec2Math.set(projX, projY, vector.projected);
      vector.index = state.index;
      handler(vector);
    }
  };
  var NavAngleUnitReferenceNorth;
  (function(NavAngleUnitReferenceNorth2) {
    NavAngleUnitReferenceNorth2["True"] = "true";
    NavAngleUnitReferenceNorth2["Magnetic"] = "magnetic";
  })(NavAngleUnitReferenceNorth || (NavAngleUnitReferenceNorth = {}));
  var BasicNavAngleUnit = class extends AbstractUnit {
    /**
     * Constructor.
     * @param referenceNorth The reference north of the new unit.
     * @param magVar The initial magnetic variation of the new unit.
     */
    constructor(referenceNorth, magVar) {
      super(referenceNorth === NavAngleUnitReferenceNorth.True ? "true bearing" : "magnetic bearing");
      this.family = "navangle";
      this._magVar = 0;
      this._magVar = magVar;
    }
    /** @inheritdoc */
    get magVar() {
      return this._magVar;
    }
    /**
     * Checks whether this nav angle unit is relative to magnetic north.
     * @returns Whether this nav angle unit is relative to magnetic north.
     */
    isMagnetic() {
      return this.name === "magnetic bearing";
    }
    /**
     * Converts a value of this unit to another unit. This unit's magnetic variation is used for the conversion.
     * @param value The value to convert.
     * @param toUnit The unit to which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === toUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.magneticToTrue(value, this.magVar) : MagVar.trueToMagnetic(value, this.magVar);
    }
    /**
     * Converts a value of another unit to this unit. This unit's magnetic variation is used for the conversion.
     * @param value The value to convert.
     * @param fromUnit The unit from which to convert.
     * @returns The converted value.
     * @throws Error if attempting an invalid conversion.
     */
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === fromUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.trueToMagnetic(value, this.magVar) : MagVar.magneticToTrue(value, this.magVar);
    }
    /**
     * Sets this unit's magnetic variation.
     * @param magVar The magnetic variation to set, in degrees.
     */
    setMagVar(magVar) {
      this._magVar = magVar;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setMagVarFromLocation(arg1, arg2) {
      if (typeof arg1 === "number") {
        this._magVar = MagVar.get(arg1, arg2);
      } else {
        this._magVar = MagVar.get(arg1);
      }
    }
    /** @inheritdoc */
    equals(other) {
      return other instanceof BasicNavAngleUnit && this.name === other.name && this.magVar === other.magVar;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(isMagnetic, arg2, arg3) {
      const referenceNorth = isMagnetic ? NavAngleUnitReferenceNorth.Magnetic : NavAngleUnitReferenceNorth.True;
      let magVar = 0;
      if (arg2 !== void 0) {
        if (typeof arg2 === "number") {
          if (arg3 === void 0) {
            magVar = arg2;
          } else {
            magVar = MagVar.get(arg2, arg3);
          }
        } else {
          magVar = MagVar.get(arg2);
        }
      }
      return new BasicNavAngleUnit(referenceNorth, magVar);
    }
  };
  var BasicNavAngleSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    /**
     * Creates a BasicNavAngleSubject.
     * @param initialVal The initial value.
     * @returns A BasicNavAngleSubject.
     */
    static create(initialVal) {
      return new BasicNavAngleSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
      return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
      const isArg1Number = typeof arg1 === "number";
      const isArg2Number = typeof arg2 === "number";
      const isArg2LatLon = typeof arg2 === "object" && "lat" in arg2 && "lon" in arg2;
      const unit = isArg1Number ? isArg2Number || isArg2LatLon || arg2 === void 0 ? this.value.unit : arg2 : arg1.unit;
      const oldMagVar = this.value.unit.magVar;
      const oldValue = this.value.number;
      if (isArg2LatLon) {
        this.value.unit.setMagVarFromLocation(arg2);
      } else if (isArg2Number) {
        if (typeof arg3 === "number") {
          this.value.unit.setMagVarFromLocation(arg2, arg3);
        } else {
          this.value.unit.setMagVar(arg2);
        }
      } else {
        this.value.unit.setMagVar(unit.magVar);
      }
      if (isArg1Number) {
        this.value.set(arg1, unit);
      } else {
        this.value.set(arg1);
      }
      if (!(isNaN(oldMagVar) && isNaN(this.value.unit.magVar)) && oldMagVar !== this.value.unit.magVar || !(isNaN(oldValue) && isNaN(this.value.number)) && oldValue !== this.value.number) {
        this.notify();
      }
    }
  };
  BasicNavAngleSubject.TRUE_BEARING = BasicNavAngleUnit.create(false);
  var AhrsPublisher = class extends SimVarPublisher {
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
      var _a;
      const simvars = /* @__PURE__ */ new Map([
        ["pitch_deg", { name: "ATTITUDE INDICATOR PITCH DEGREES:#index#", type: SimVarValueType.Degree, indexed: true }],
        ["roll_deg", { name: "ATTITUDE INDICATOR BANK DEGREES:#index#", type: SimVarValueType.Degree, indexed: true }],
        ["hdg_deg", { name: "HEADING INDICATOR:#index#", type: SimVarValueType.Degree, indexed: true }],
        ["hdg_deg_true", { name: "HEADING INDICATOR:#index#", type: SimVarValueType.Degree, map: (heading) => MagVar.magneticToTrue(heading, this.magVar), indexed: true }],
        ["delta_heading_rate", { name: "DELTA HEADING RATE:#index#", type: SimVarValueType.Degree, indexed: true }],
        ["turn_coordinator_ball", { name: "TURN COORDINATOR BALL", type: SimVarValueType.Number }],
        ["actual_hdg_deg", { name: "PLANE HEADING DEGREES MAGNETIC", type: SimVarValueType.Degree }],
        ["actual_hdg_deg_true", { name: "PLANE HEADING DEGREES TRUE", type: SimVarValueType.Degree }],
        ["actual_pitch_deg", { name: "PLANE PITCH DEGREES", type: SimVarValueType.Degree }],
        ["actual_roll_deg", { name: "PLANE BANK DEGREES", type: SimVarValueType.Degree }]
      ]);
      super(simvars, bus, pacer);
      this.magVar = 0;
      (_a = this.needUpdateMagVar) !== null && _a !== void 0 ? _a : this.needUpdateMagVar = false;
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
      super.onTopicSubscribed(topic);
      if (topic.startsWith("hdg_deg_true")) {
        this.needUpdateMagVar = true;
      }
    }
    /** @inheritdoc */
    onUpdate() {
      if (this.needUpdateMagVar) {
        this.magVar = SimVar.GetSimVarValue("MAGVAR", SimVarValueType.Degree);
      }
      super.onUpdate();
    }
  };
  var AntiIcePublisher = class extends SimVarPublisher {
    /**
     * Creates an instance of an AntiIcePublisher.
     * @param bus The event bus to use with this instance.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
      const engineIndexedSimVars = [
        ["anti_ice_engine_switch_on", { name: "ENG ANTI ICE", type: SimVarValueType.Bool }],
        ["anti_ice_prop_switch_on", { name: "PROP DEICE SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(AntiIcePublisher.nonIndexedSimVars);
      const engineCount = SimVar.GetSimVarValue("NUMBER OF ENGINES", SimVarValueType.Number);
      for (const [topic, simvar2] of engineIndexedSimVars) {
        for (let i = 1; i <= engineCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  AntiIcePublisher.nonIndexedSimVars = [
    ["anti_ice_structural_switch_on", { name: "STRUCTURAL DEICE SWITCH", type: SimVarValueType.Bool }],
    ["anti_ice_windshield_switch_on", { name: "WINDSHIELD DEICE SWITCH", type: SimVarValueType.Bool }]
  ];
  var BasicConsumer = class {
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe, state = {}, currentHandler) {
      this.subscribe = subscribe;
      this.state = state;
      this.currentHandler = currentHandler;
      this.isConsumer = true;
      this.activeSubs = /* @__PURE__ */ new Map();
    }
    /** @inheritdoc */
    handle(handler, paused = false) {
      let activeHandler;
      if (this.currentHandler !== void 0) {
        activeHandler = (data) => {
          this.currentHandler(data, this.state, handler);
        };
      } else {
        activeHandler = handler;
      }
      let activeSubArray = this.activeSubs.get(handler);
      if (!activeSubArray) {
        activeSubArray = [];
        this.activeSubs.set(handler, activeSubArray);
      }
      const onDestroyed = (destroyed) => {
        const activeSubsArray = this.activeSubs.get(handler);
        if (activeSubsArray) {
          activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
          if (activeSubsArray.length === 0) {
            this.activeSubs.delete(handler);
          }
        }
      };
      const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
      if (sub.isAlive) {
        activeSubArray.push(sub);
      } else if (activeSubArray.length === 0) {
        this.activeSubs.delete(handler);
      }
      return sub;
    }
    /** @inheritdoc */
    off(handler) {
      var _a;
      const activeSubArray = this.activeSubs.get(handler);
      if (activeSubArray) {
        (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
        if (activeSubArray.length === 0) {
          this.activeSubs.delete(handler);
        }
      }
    }
    /** @inheritdoc */
    atFrequency(frequency, immediateFirstPublish = true) {
      const initialState = {
        previousTime: Date.now(),
        firstRun: immediateFirstPublish
      };
      return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
      const deltaTimeTrigger = 1e3 / frequency;
      return (data, state, next) => {
        const currentTime = Date.now();
        const deltaTime = currentTime - state.previousTime;
        if (deltaTimeTrigger <= deltaTime || state.firstRun) {
          while (state.previousTime + deltaTimeTrigger < currentTime) {
            state.previousTime += deltaTimeTrigger;
          }
          if (state.firstRun) {
            state.firstRun = false;
          }
          this.with(data, next);
        }
      };
    }
    /** @inheritdoc */
    withPrecision(precision) {
      return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
      return (data, state, next) => {
        const dataValue = data;
        const multiplier = Math.pow(10, precision);
        const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
        if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
          state.hasLastValue = true;
          state.lastValue = currentValueAtPrecision;
          this.with(currentValueAtPrecision, next);
        }
      };
    }
    /** @inheritdoc */
    whenChangedBy(amount) {
      return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
      return (data, state, next) => {
        const dataValue = data;
        const diff = Math.abs(dataValue - state.lastValue);
        if (!state.hasLastValue || diff >= amount) {
          state.hasLastValue = true;
          state.lastValue = dataValue;
          this.with(data, next);
        }
      };
    }
    /** @inheritdoc */
    whenChanged() {
      return new BasicConsumer(this.subscribe, { lastValue: "", hasLastValue: false }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
      return (data, state, next) => {
        if (!state.hasLastValue || state.lastValue !== data) {
          state.hasLastValue = true;
          state.lastValue = data;
          this.with(data, next);
        }
      };
    }
    /** @inheritdoc */
    onlyAfter(deltaTime) {
      return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
      return (data, state, next) => {
        const currentTime = Date.now();
        const timeDiff = currentTime - state.previousTime;
        if (timeDiff > deltaTime) {
          state.previousTime += deltaTime;
          this.with(data, next);
        }
      };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
      if (this.currentHandler !== void 0) {
        this.currentHandler(data, this.state, handler);
      } else {
        handler(data);
      }
    }
  };
  var ConsumerSubscription = class {
    /**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
      this.sub = sub;
      this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    get isAlive() {
      return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
      return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
      return this.sub.canInitialNotify;
    }
    /** @inheritdoc */
    pause() {
      this.sub.pause();
      return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
      this.sub.resume(initialNotify);
      return this;
    }
    /** @inheritdoc */
    destroy() {
      this.sub.destroy();
      this.onDestroy(this);
    }
  };
  var EventSubscriber = class {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
      this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
      return new BasicConsumer((handler, paused) => {
        return this.bus.on(topic, handler, paused);
      });
    }
  };
  var APLockType;
  (function(APLockType2) {
    APLockType2[APLockType2["Heading"] = 0] = "Heading";
    APLockType2[APLockType2["Nav"] = 1] = "Nav";
    APLockType2[APLockType2["Alt"] = 2] = "Alt";
    APLockType2[APLockType2["Bank"] = 3] = "Bank";
    APLockType2[APLockType2["WingLevel"] = 4] = "WingLevel";
    APLockType2[APLockType2["Vs"] = 5] = "Vs";
    APLockType2[APLockType2["Flc"] = 6] = "Flc";
    APLockType2[APLockType2["Pitch"] = 7] = "Pitch";
    APLockType2[APLockType2["Approach"] = 8] = "Approach";
    APLockType2[APLockType2["Backcourse"] = 9] = "Backcourse";
    APLockType2[APLockType2["Glideslope"] = 10] = "Glideslope";
    APLockType2[APLockType2["VNav"] = 11] = "VNav";
  })(APLockType || (APLockType = {}));
  var APSimVarPublisher = class extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = void 0) {
      super(APSimVarPublisher.simvars, bus, pacer);
    }
  };
  APSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["ap_heading_selected", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_1", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_2", { name: "AUTOPILOT HEADING LOCK DIR:2", type: SimVarValueType.Degree }],
    ["ap_heading_selected_3", { name: "AUTOPILOT HEADING LOCK DIR:3", type: SimVarValueType.Degree }],
    ["ap_altitude_selected", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_1", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_2", { name: "AUTOPILOT ALTITUDE LOCK VAR:2", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_3", { name: "AUTOPILOT ALTITUDE LOCK VAR:3", type: SimVarValueType.Feet }],
    ["ap_master_status", { name: "AUTOPILOT MASTER", type: SimVarValueType.Bool }],
    ["ap_yd_status", { name: "AUTOPILOT YAW DAMPER", type: SimVarValueType.Bool }],
    ["ap_heading_hold", { name: "AUTOPILOT HEADING LOCK", type: SimVarValueType.Bool }],
    ["ap_nav_hold", { name: "AUTOPILOT NAV1 LOCK", type: SimVarValueType.Bool }],
    ["ap_bank_hold", { name: "AUTOPILOT BANK HOLD", type: SimVarValueType.Bool }],
    ["ap_max_bank_id", { name: "AUTOPILOT MAX BANK ID", type: SimVarValueType.Number }],
    ["ap_max_bank_value", { name: "AUTOPILOT MAX BANK", type: SimVarValueType.Degree }],
    ["ap_wing_lvl_hold", { name: "AUTOPILOT WING LEVELER", type: SimVarValueType.Bool }],
    ["ap_approach_hold", { name: "AUTOPILOT APPROACH HOLD", type: SimVarValueType.Bool }],
    ["ap_backcourse_hold", { name: "AUTOPILOT BACKCOURSE HOLD", type: SimVarValueType.Bool }],
    ["ap_vs_hold", { name: "AUTOPILOT VERTICAL HOLD", type: SimVarValueType.Bool }],
    ["ap_flc_hold", { name: "AUTOPILOT FLIGHT LEVEL CHANGE", type: SimVarValueType.Bool }],
    ["ap_alt_hold", { name: "AUTOPILOT ALTITUDE LOCK", type: SimVarValueType.Bool }],
    ["ap_glideslope_hold", { name: "AUTOPILOT GLIDESLOPE HOLD", type: SimVarValueType.Bool }],
    ["ap_pitch_hold", { name: "AUTOPILOT PITCH HOLD", type: SimVarValueType.Bool }],
    ["ap_toga_hold", { name: "AUTOPILOT TAKEOFF POWER ACTIVE", type: SimVarValueType.Bool }],
    ["ap_vs_selected", { name: "AUTOPILOT VERTICAL HOLD VAR:1", type: SimVarValueType.FPM }],
    ["ap_fpa_selected", { name: "L:WT_AP_FPA_Target:1", type: SimVarValueType.Degree }],
    ["ap_ias_selected", { name: "AUTOPILOT AIRSPEED HOLD VAR", type: SimVarValueType.Knots }],
    ["ap_mach_selected", { name: "AUTOPILOT MACH HOLD VAR", type: SimVarValueType.Number }],
    ["ap_selected_speed_is_mach", { name: "AUTOPILOT MANAGED SPEED IN MACH", type: SimVarValueType.Bool }],
    ["ap_selected_speed_is_manual", { name: "L:XMLVAR_SpeedIsManuallySet", type: SimVarValueType.Bool }],
    ["flight_director_bank", { name: "AUTOPILOT FLIGHT DIRECTOR BANK", type: SimVarValueType.Degree }],
    ["flight_director_pitch", { name: "AUTOPILOT FLIGHT DIRECTOR PITCH", type: SimVarValueType.Degree }],
    ["flight_director_is_active_1", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:1", type: SimVarValueType.Bool }],
    ["flight_director_is_active_2", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:2", type: SimVarValueType.Bool }],
    ["vnav_active", { name: "L:XMLVAR_VNAVButtonValue", type: SimVarValueType.Bool }],
    ["ap_pitch_selected", { name: "AUTOPILOT PITCH HOLD REF", type: SimVarValueType.Degree }]
  ]);
  var AutopilotPublisher = class extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
      super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
      this.publish("ap_master_engage", true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
      this.publish("ap_master_disengage", true);
    }
    /**
     * Publish a YD engage event
     */
    publishYdEngage() {
      this.publish("ap_yd_engage", true);
    }
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage() {
      this.publish("ap_yd_disengage", true);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
      this.publish("ap_lock_set", lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
      this.publish("ap_lock_release", lock);
    }
  };
  var AutopilotInstrument = class {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
      this.bus = bus;
      this.publisher = new AutopilotPublisher(bus);
      this.simVarPublisher = new APSimVarPublisher(bus);
      this.simVarSubscriber = new EventSubscriber(bus);
    }
    /**
     * Initialize the instrument
     */
    init() {
      this.publisher.startPublish();
      this.simVarPublisher.startPublish();
      this.simVarSubscriber.on("ap_master_status").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishMasterEngage();
        } else {
          this.publisher.publishMasterDisengage();
        }
      });
      this.simVarSubscriber.on("ap_yd_status").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishYdEngage();
        } else {
          this.publisher.publishYdDisengage();
        }
      });
      this.simVarSubscriber.on("ap_alt_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Alt);
        } else {
          this.publisher.publishLockRelease(APLockType.Alt);
        }
      });
      this.simVarSubscriber.on("ap_pitch_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Pitch);
        } else {
          this.publisher.publishLockRelease(APLockType.Pitch);
        }
      });
      this.simVarSubscriber.on("ap_heading_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Heading);
        } else {
          this.publisher.publishLockRelease(APLockType.Heading);
        }
      });
      this.simVarSubscriber.on("ap_nav_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Nav);
        } else {
          this.publisher.publishLockRelease(APLockType.Nav);
        }
      });
      this.simVarSubscriber.on("ap_approach_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Approach);
        } else {
          this.publisher.publishLockRelease(APLockType.Approach);
        }
      });
      this.simVarSubscriber.on("ap_backcourse_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Backcourse);
        } else {
          this.publisher.publishLockRelease(APLockType.Backcourse);
        }
      });
      this.simVarSubscriber.on("ap_bank_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Bank);
        } else {
          this.publisher.publishLockRelease(APLockType.Bank);
        }
      });
      this.simVarSubscriber.on("ap_wing_lvl_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.WingLevel);
        } else {
          this.publisher.publishLockRelease(APLockType.WingLevel);
        }
      });
      this.simVarSubscriber.on("ap_flc_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Flc);
        } else {
          this.publisher.publishLockRelease(APLockType.Flc);
        }
      });
      this.simVarSubscriber.on("ap_vs_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Vs);
        } else {
          this.publisher.publishLockRelease(APLockType.Vs);
        }
      });
      this.simVarSubscriber.on("ap_glideslope_hold").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.Glideslope);
        } else {
          this.publisher.publishLockRelease(APLockType.Glideslope);
        }
      });
      this.simVarSubscriber.on("vnav_active").whenChangedBy(1).handle((engaged) => {
        if (engaged) {
          this.publisher.publishLockSet(APLockType.VNav);
        } else {
          this.publisher.publishLockRelease(APLockType.VNav);
        }
      });
    }
    /** update our publishers */
    onUpdate() {
      this.simVarPublisher.onUpdate();
    }
  };
  var RadioUtils = class {
    /**
     * Checks whether a frequency is a NAV frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a NAV frequency.
     */
    static isNavFrequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 108e3 || freqKhz > 117950) {
        return false;
      }
      return freqKhz % 50 === 0;
    }
    /**
     * Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check, in megahertz.
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd.
     */
    static isLocalizerFrequency(freq) {
      return freq >= 108.1 && freq <= 111.95 && Math.trunc(freq * 10) % 2 === 1;
    }
    /**
     * Checks whether a frequency is a 8.33 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 8.33 kHz-spacing COM frequency.
     */
    static isCom833Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136990) {
        return false;
      }
      return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    /**
     * Checks whether a frequency is a 25 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 25 kHz-spacing COM frequency.
     */
    static isCom25Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136975) {
        return false;
      }
      return freqKhz % 25 === 0;
    }
    /**
     * Checks whether a frequency is an ADF frequency.
     * @param freq The frequency to check, in kilohertz.
     * @returns Whether the specified frequency is an ADF frequency.
     */
    static isAdfFrequency(freq) {
      const freqHz = Math.round(freq * 1e3);
      if (freqHz < 19e4 || freqHz > 1799500) {
        return false;
      }
      return freqHz % 500 === 0;
    }
  };
  RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];
  var RadioType;
  (function(RadioType2) {
    RadioType2["Com"] = "COM";
    RadioType2["Nav"] = "NAV";
    RadioType2["Adf"] = "ADF";
  })(RadioType || (RadioType = {}));
  var FrequencyBank;
  (function(FrequencyBank2) {
    FrequencyBank2[FrequencyBank2["Active"] = 0] = "Active";
    FrequencyBank2[FrequencyBank2["Standby"] = 1] = "Standby";
  })(FrequencyBank || (FrequencyBank = {}));
  var ComSpacing;
  (function(ComSpacing2) {
    ComSpacing2[ComSpacing2["Spacing25Khz"] = 0] = "Spacing25Khz";
    ComSpacing2[ComSpacing2["Spacing833Khz"] = 1] = "Spacing833Khz";
  })(ComSpacing || (ComSpacing = {}));
  var NavProcSimVarPublisher = class extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = void 0) {
      super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
      return [
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
        [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
        [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
        [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
        [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
        [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
        [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
        [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
        [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
        [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
        [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
        [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
      ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
      ];
    }
  };
  NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ["gps_dtk", { name: "GPS WP DESIRED TRACK", type: SimVarValueType.Degree }],
    ["gps_xtk", { name: "GPS WP CROSS TRK", type: SimVarValueType.NM }],
    ["gps_wp", { name: "GPS WP NEXT ID", type: SimVarValueType.NM }],
    ["gps_wp_bearing", { name: "GPS WP BEARING", type: SimVarValueType.String }],
    ["gps_wp_distance", { name: "GPS WP DISTANCE", type: SimVarValueType.NM }],
    ["mkr_bcn_state_simvar", { name: "MARKER BEACON STATE", type: SimVarValueType.Number }],
    ["gps_obs_active_simvar", { name: "GPS OBS ACTIVE", type: SimVarValueType.Bool }],
    ["gps_obs_value_simvar", { name: "GPS OBS VALUE", type: SimVarValueType.Degree }]
  ]);
  var NavSourceType;
  (function(NavSourceType2) {
    NavSourceType2[NavSourceType2["Nav"] = 0] = "Nav";
    NavSourceType2[NavSourceType2["Gps"] = 1] = "Gps";
    NavSourceType2[NavSourceType2["Adf"] = 2] = "Adf";
  })(NavSourceType || (NavSourceType = {}));
  var VorToFrom;
  (function(VorToFrom2) {
    VorToFrom2[VorToFrom2["OFF"] = 0] = "OFF";
    VorToFrom2[VorToFrom2["TO"] = 1] = "TO";
    VorToFrom2[VorToFrom2["FROM"] = 2] = "FROM";
  })(VorToFrom || (VorToFrom = {}));
  var MarkerBeaconState;
  (function(MarkerBeaconState2) {
    MarkerBeaconState2[MarkerBeaconState2["Inactive"] = 0] = "Inactive";
    MarkerBeaconState2[MarkerBeaconState2["Outer"] = 1] = "Outer";
    MarkerBeaconState2[MarkerBeaconState2["Middle"] = 2] = "Middle";
    MarkerBeaconState2[MarkerBeaconState2["Inner"] = 3] = "Inner";
  })(MarkerBeaconState || (MarkerBeaconState = {}));
  var NavSourceBase = class {
    /**
     * Create a bearing pointer
     * @param id The navsourceid.
     */
    constructor(id) {
      this._ident = null;
      this._bearing = null;
      this._distance = null;
      this._obs = 0;
      this._deviation = null;
      this._toFrom = VorToFrom.OFF;
      this._glideslopeDeviation = null;
      this._glideslopeAngle = null;
      this._localizerCourse = null;
      this._magneticVariation = null;
      this._isLocalizerFrequency = null;
      this.validHandler = void 0;
      this.identHandler = void 0;
      this.brgHandler = void 0;
      this.distHandler = void 0;
      this.obsHandler = void 0;
      this.deviationHandler = void 0;
      this.toFromHandler = void 0;
      this.glideslopeDeviationHandler = void 0;
      this.glideslopeAngleHandler = void 0;
      this.localizerCourseHandler = void 0;
      this.magvarHandler = void 0;
      this.isLocalizerFrequencyHandler = void 0;
      this._valid = false;
      this._activeBrg = false;
      this._activeCdi = false;
      this._hasCdi = false;
      this._hasDme = false;
      this._hasLocalizer = false;
      this._hasGlideslope = false;
      this._signal = 0;
      this._activeForCount = 0;
      if (id.type !== null && id.type in [NavSourceType.Nav, NavSourceType.Gps]) {
        this._hasCdi = true;
      }
      this.valid = false;
      this.srcId = id;
    }
    /**
     * Do we support CDI?
     * @returns A boolean with our CDI support state.
     */
    get hasCdi() {
      return this._hasCdi;
    }
    /**
     * Set a new ident.
     * @param ident The new ident string.
     */
    set ident(ident) {
      this._ident = ident;
      if (this.valid && this.activeBrg && this.identHandler !== void 0) {
        this.identHandler(ident, this.srcId);
      }
    }
    /**
     * Get an ident.
     * @returns A string identifying the nav source.
     */
    get ident() {
      if (this._signal > 0) {
        return this._ident;
      } else {
        return null;
      }
    }
    /**
     * Set a new bearing.
     * @param bearing The new bearing in degrees.
     */
    set bearing(bearing) {
      if (bearing !== null) {
        bearing = (bearing + 180) % 360;
      }
      this._bearing = bearing;
      if (this.valid && this.activeBrg && this.brgHandler !== void 0) {
        this.brgHandler(bearing, this.srcId);
      }
    }
    /**
     * Get abearing.
     * @returns Bearing to the source in degrees.
     */
    get bearing() {
      return this._bearing;
    }
    /**
     * Set a new distance
     * @param distance The distance in NM.
     */
    set distance(distance) {
      this._distance = distance;
      if (this.valid && this.activeBrg && this.distHandler !== void 0) {
        this.distHandler(this.distance, this.srcId);
      }
    }
    /**
     * Get the distance to a source..
     * @returns Distance to the source in degrees.
     */
    get distance() {
      if (this.hasDme) {
        return this._distance;
      } else {
        return null;
      }
    }
    /**
     * Set a new OBS
     * @param obs the new bearing in degrees
     */
    set obs(obs) {
      this._obs = obs;
      if (this.activeCdi && this.obsHandler !== void 0) {
        this.obsHandler(obs, this.srcId);
      }
    }
    /**
     * Get the OBS setting.
     * @returns OBS in degrees.
     */
    get obs() {
      return this._obs;
    }
    /**
     * Set a new deviation
     * @param deviation The new deviation in points.
     */
    set deviation(deviation) {
      this._deviation = deviation;
      if (this.activeCdi && this.deviationHandler !== void 0) {
        this.deviationHandler(deviation, this.srcId);
      }
    }
    /**
     * Get the deviation.
     * @returns The deviation in points.
     */
    get deviation() {
      return this._deviation;
    }
    /**
     * Set a new VOR to/from value
     * @param toFrom The to/from value.
     */
    set toFrom(toFrom) {
      if (this.activeCdi && this.toFromHandler !== void 0) {
        this.toFromHandler(toFrom, this.srcId);
      }
      this._toFrom = toFrom;
    }
    /**
     * Get the VOR to/from value.
     * @returns The VOR to/from value.
     */
    get toFrom() {
      return this._toFrom;
    }
    /**
     * Set whether the nav radio has a loc signal
     * @param valid If the loc exists.
     */
    set hasLocalizer(valid) {
      this._hasLocalizer = valid;
      if (!this._hasLocalizer) {
        this.localizerCourse = -1;
      } else if (this._hasLocalizer && this.localizerCourseHandler && this.localizerCourseHandler !== null && this._localizerCourse !== null && this._localizerCourse >= 0) {
        this.localizerCourseHandler(this._localizerCourse, this.srcId);
      }
    }
    /**
     * Get if the radio has a loc.
     * @returns The loc bool.
     */
    get hasLocalizer() {
      return this._hasLocalizer;
    }
    /**
     * Set a new localizerCourse
     * @param course The new localizer course.
     */
    set localizerCourse(course) {
      this._localizerCourse = course !== null ? course * (180 / Math.PI) : -1;
      if (this._localizerCourse !== -1 && this.localizerCourseHandler !== void 0) {
        this.localizerCourseHandler(this._localizerCourse, this.srcId);
      }
    }
    /**
     * Get the localizerCourse.
     * @returns The glideslopeDeviation in degrees.
     */
    get localizerCourse() {
      return this._localizerCourse;
    }
    /**
     * Set whether the nav radio has a GS signal
     * @param valid If the GS exists.
     */
    set hasGlideslope(valid) {
      this._hasGlideslope = valid;
      if (this.glideslopeDeviationHandler !== void 0) {
        this.glideslopeDeviationHandler(this.glideslopeDeviation, this.srcId);
      }
    }
    /**
     * Get if the radio has a glideslope.
     * @returns The glideslope bool.
     */
    get hasGlideslope() {
      return this._hasGlideslope;
    }
    /**
     * Set a new _glideslopeDeviation
     * @param deviation The new deviation in points.
     */
    set glideslopeDeviation(deviation) {
      this._glideslopeDeviation = deviation;
      if (this.valid && this.activeCdi && this.hasGlideslope && this.glideslopeDeviationHandler !== void 0) {
        this.glideslopeDeviationHandler(deviation, this.srcId);
      }
    }
    /**
     * Get the glideslopeDeviation.
     * @returns The glideslopeDeviation in degrees.
     */
    get glideslopeDeviation() {
      return this._glideslopeDeviation;
    }
    /**
     * Set a new _glideslopeAngle
     * @param angle The new angle in degrees.
     */
    set glideslopeAngle(angle) {
      this._glideslopeAngle = angle;
      if (this.valid && this.activeCdi && this.hasGlideslope && this.glideslopeAngleHandler !== void 0) {
        this.glideslopeAngleHandler(angle, this.srcId);
      }
    }
    /**
     * Get the glideslopeAngle.
     * @returns The glideslopeAngle in degrees.
     */
    get glideslopeAngle() {
      return this._glideslopeAngle;
    }
    /**
     * Set whether there's a valid DME signal.
     * @param hasDme Whether a nav signal is present or not.
     */
    set hasDme(hasDme) {
      this._hasDme = hasDme;
      if (this.distHandler !== void 0) {
        this.distHandler(this.distance, this.srcId);
      }
    }
    /**
     * Get whether there's a valid DME signal.
     * @returns A boolean indicatind presence of DME.
     */
    get hasDme() {
      return this._hasDme;
    }
    /**
     * Get the nav radio magvar.
     * @returns The magvar value.
     */
    get magneticVariation() {
      return this._magneticVariation;
    }
    /**
     * Set a new nav radio magvar
     * @param magvar The new nav radio magvar.
     */
    set magneticVariation(magvar) {
      this._magneticVariation = magvar;
      if (this.valid && this.activeCdi && this.magvarHandler !== void 0) {
        this.magvarHandler(magvar, this.srcId);
      }
    }
    /**
     * Get if the frequency is for a localizer.
     * @returns a bool of whether the freq is for a localizer.
     */
    get isLocalizerFrequency() {
      return this._isLocalizerFrequency;
    }
    /**
     * Sets if a frequency is for a localizer
     * @param isLocFreq whether the freq is a localizer freq.
     */
    set isLocalizerFrequency(isLocFreq) {
      if (this.isLocalizerFrequencyHandler !== void 0) {
        this.isLocalizerFrequencyHandler(isLocFreq, this.srcId);
      }
      this._isLocalizerFrequency = isLocFreq;
    }
    /**
     * Set the nav signal strength.
     * @param signal The signal strength as a number.
     */
    set signal(signal) {
      if (this._signal == 0 != (signal == 0)) {
        this._signal = signal;
        if (this.identHandler !== void 0) {
          this.identHandler(this.ident, this.srcId);
        }
      } else {
        this._signal = signal;
      }
    }
    /**
     * Set validity.
     * @param valid Whether we are valid or not.
     */
    set valid(valid) {
      this._valid = valid;
      this.validHandler && this.validHandler(valid, this.srcId);
      if (valid && this.activeBrg) {
        if (this.identHandler !== void 0) {
          this.identHandler(this._ident, this.srcId);
        }
        if (this.brgHandler !== void 0) {
          this.brgHandler(this._bearing, this.srcId);
        }
        if (this.distHandler !== void 0) {
          this.distHandler(this._distance, this.srcId);
        }
        if (this.toFromHandler !== void 0) {
          this.toFromHandler(this._toFrom, this.srcId);
        }
        if (this.localizerCourseHandler !== void 0) {
          this.localizerCourseHandler(this._localizerCourse, this.srcId);
        }
        if (this.glideslopeDeviationHandler !== void 0) {
          this.glideslopeDeviationHandler(this._glideslopeDeviation, this.srcId);
        }
        if (this.magvarHandler !== void 0) {
          this.magvarHandler(this._magneticVariation, this.srcId);
        }
        if (this.isLocalizerFrequencyHandler !== void 0) {
          this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
        }
        if (this.obsHandler !== void 0) {
          this.obsHandler(this._obs, this.srcId);
        }
      } else if (this.activeBrg) {
        if (this.identHandler !== void 0) {
          this.identHandler(null, this.srcId);
        }
        if (this.brgHandler !== void 0) {
          this.brgHandler(null, this.srcId);
        }
        if (this.distHandler !== void 0) {
          this.distHandler(null, this.srcId);
        }
        if (this.toFromHandler !== void 0) {
          this.toFromHandler(this._toFrom, this.srcId);
        }
        if (this.localizerCourseHandler !== void 0) {
          this.localizerCourseHandler(null, this.srcId);
        }
        if (this.glideslopeDeviationHandler !== void 0) {
          this.glideslopeDeviationHandler(null, this.srcId);
        }
        if (this.magvarHandler !== void 0) {
          this.magvarHandler(null, this.srcId);
        }
        if (this.isLocalizerFrequencyHandler !== void 0) {
          this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
        }
        if (this.obsHandler !== void 0) {
          this.obsHandler(this._obs, this.srcId);
        }
      }
    }
    /**
     * Get validity
     * @returns A boolean indicating whether this is valid
     */
    get valid() {
      return this._valid;
    }
    /**
     * Set as active for bearing information
     * @param active Whether we are active for bearing info.
     */
    set activeBrg(active) {
      if (active) {
        this._activeForCount++;
      } else if (this._activeForCount > 0) {
        this._activeForCount--;
      }
      this.validHandler && this.validHandler(this.valid, this.srcId);
      if (!this.activeBrg || !this.valid) {
        if (this.identHandler !== void 0) {
          this.identHandler(null, this.srcId);
        }
        if (this.brgHandler !== void 0) {
          this.brgHandler(null, this.srcId);
        }
        if (this.distHandler !== void 0) {
          this.distHandler(null, this.srcId);
        }
        if (this.toFromHandler !== void 0) {
          this.toFromHandler(this._toFrom, this.srcId);
        }
        if (this.isLocalizerFrequencyHandler !== void 0) {
          this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
        }
      } else {
        if (this.identHandler !== void 0) {
          this.identHandler(this.ident, this.srcId);
        }
        if (this.brgHandler !== void 0) {
          this.brgHandler(this.bearing, this.srcId);
        }
        if (this.distHandler !== void 0) {
          this.distHandler(this.distance, this.srcId);
        }
        if (this.toFromHandler !== void 0) {
          this.toFromHandler(this._toFrom, this.srcId);
        }
        if (this.isLocalizerFrequencyHandler !== void 0) {
          this.isLocalizerFrequencyHandler(this._isLocalizerFrequency, this.srcId);
        }
      }
    }
    /**
     * Are we active for bearing information?
     * @returns Our active state
     */
    get activeBrg() {
      return this._activeForCount > 0;
    }
    /**
     * Set this at the active deviation source or not
     * @param active Whether we are active for publishing deviation info.
     */
    set activeCdi(active) {
      this._activeCdi = active;
      if (active && this.deviationHandler !== void 0) {
        this.deviationHandler(this._deviation, this.srcId);
      }
    }
    /**
     * Are we active for CDI data?
     * @returns Boolean of our CDI active state
     */
    get activeCdi() {
      return this._activeCdi;
    }
  };
  var NavProcessorConfig = class {
    constructor() {
      this.numNav = 2;
      this.numGps = 1;
      this.numAdf = 1;
      this.courseIncEvents = /* @__PURE__ */ new Set();
      this.courseDecEvents = /* @__PURE__ */ new Set();
      this.courseSyncEvents = /* @__PURE__ */ new Set();
      this.additionalSources = new Array();
    }
  };
  var NavProcPublisher = class extends BasePublisher {
    /**
     * Creates a NavProcPublisher
     * @param bus The event bus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer) {
      super(bus, pacer);
    }
    /**
     * Publish a new CDI source selection.
     * @param source The selected NavSource.
     */
    publishCdiSelect(source) {
      this.publish("cdi_select", source, true);
    }
    /**
     * Publish a new CDI deviation
     * @param deviation The deviation
     * @param source the source for thes deviation
     */
    publishDeviation(deviation, source) {
      this.publish("cdi_deviation", { source, deviation });
    }
    /**
     * Publish a new OBS heading
     * @param heading The heading
     * @param source The source for this heading.
     */
    publishObsHeading(heading, source) {
      this.publish("obs_set", { source, heading });
    }
    /**
     * Publish new validity information.
     * @param index The bearing index number to update.
     * @param valid The validity state of that berign source.
     */
    publishBrgValidity(index, valid) {
      this.publish("brg_validity", { index, valid }, true);
    }
    /**
     * Publish a new bearing source
     * @param index The source number.
     * @param source The source name.
     */
    publishBrgSrc(index, source) {
      this.publish("brg_source", { index, source });
    }
    /**
     * Publish heading of a bearing source.
     * @param index The index number to update.
     * @param direction The direction.
     */
    publishBrgDir(index, direction) {
      this.publish("brg_direction", { index, direction });
    }
    /**
     * Publish distance to a bearing source.
     * @param index The source number.
     * @param distance The distance in NMs.
     */
    publishBrgDist(index, distance) {
      this.publish("brg_distance", { index, distance });
    }
    /**
     * Publish distance to a bearing source.
     * @param index The source number.
     * @param ident The ident as a string.
     * @param isLoc is this source a loc.
     */
    publishBrgIdent(index, ident, isLoc) {
      this.publish("brg_ident", { index, ident, isLoc });
    }
    // /**
    //  * Publish distance to a bearing source.
    //  * @param index The source number.
    //  * @param isLoc The ident as a string.
    //  */
    // public publishBrgIsLoc(index: number, isLoc: boolean | null): void {
    //     this.publish('brg_is_loc', { index: index, isLoc: isLoc });
    // }
    /**
     * Publish to/from value for a nav source.
     * @param toFrom The to/from enum value.
     * @param source The nav radio source.
     */
    publishToFrom(toFrom, source) {
      this.publish("vor_to_from", { toFrom, source });
    }
    /**
     * Publish localizer value for a nav source.
     * @param localizer is the localizer data
     * @param source The nav radio source.
     */
    publishLocalizer(localizer, source) {
      this.publish("localizer", { isValid: localizer.isValid, course: localizer.course, source });
    }
    /**
     * Publish if the nav source is tuned to a localizer frequency.
     * @param isLoc is a bool whether or not the nav source is a loc frequency
     * @param source The nav radio source.
     */
    publishIsLocalizerFrequency(isLoc, source) {
      this.publish("is_localizer_frequency", { isLocalizer: isLoc.isLocalizer, source });
    }
    /**
     * Publish gliseslope value for a nav source.
     * @param glideslope is the localizer data
     * @param source The nav radio source.
     */
    publishGlideslope(glideslope, source) {
      this.publish("glideslope", { isValid: glideslope.isValid, deviation: glideslope.deviation, gsAngle: glideslope.gsAngle, source });
    }
    /**
     * Publish magvar value for a nav source.
     * @param variation is the magnetic variation
     * @param source The nav radio source.
     */
    publishMagvar(variation, source) {
      if (variation !== null) {
        this.publish("mag_variation", { variation, source });
      }
    }
    /**
     * Publish marker beacon state value.
     * @param state is the marker beacon state value
     */
    publishMarkerBeacon(state) {
      this.publish("mkr_bcn_state", state);
    }
    /**
     * Publish DME state.
     * @param state is the has_dme state value
     * @param distance is the dme distance value.
     * @param source The nav radio source.
     */
    publishDmeState(state, distance, source) {
      this.publish("dme_state", { hasDme: state, dmeDistance: distance, source });
    }
    /**
     * Publish GPS OBS State.
     * @param state is the GPS OBS Active State
     */
    publishGpsObsState(state) {
      this.publish("gps_obs_active", state, true);
    }
    /**
     * Publish GPS OBS Value.
     * @param value is the GPS OBS heading value
     */
    publishGpsObsValue(value) {
      this.publish("gps_obs_value", value, true);
    }
  };
  var NavProcessor = class {
    /**
     * Create a NavProcessor.
     * @param bus The event bus to publish to.
     * @param config A config object defining our radio options.
     */
    constructor(bus, config) {
      this.brgSrcAsoboMap = [-1, 0, 1, 3, 2];
      this.eventHandler = (event) => {
        if (this.config.courseIncEvents.has(event)) {
          this.handleCrsInc();
        } else if (this.config.courseDecEvents.has(event)) {
          this.handleCrsDec();
        } else if (this.config.courseSyncEvents.has(event)) {
          this.handleCrsSync();
        }
      };
      this.onCdiGpsToggle = () => {
        const src = this.navSources[this.cdiSourceIdx];
        if (src.srcId.type === NavSourceType.Gps) {
          this.switchCdiSrc();
        } else {
          this.switchCdiSrc(3);
        }
      };
      this.bus = bus;
      this.config = config;
      this.publisher = new NavProcPublisher(bus);
      this.simVarPublisher = config.simVarPublisher ? config.simVarPublisher : new NavProcSimVarPublisher(this.bus);
      this.hEvents = bus.getSubscriber();
      this.controlSubscriber = bus.getSubscriber();
      this.simVarSubscriber = new EventSubscriber(bus);
      this.navComSubscriber = bus.getSubscriber();
      this.navSources = new Array();
      this.bearingSourceIdxs = [-1, -1];
      this.cdiSourceIdx = 0;
    }
    /**
     * Initialize a nav processor
     */
    init() {
      this.publisher.startPublish();
      this.simVarPublisher.startPublish();
      this.hEvents.on("hEvent").handle(this.eventHandler);
      this.controlSubscriber.on("cdi_src_switch").handle(() => {
        this.switchCdiSrc();
      });
      this.controlSubscriber.on("cdi_src_set").handle((src) => {
        if (src.type === NavSourceType.Gps) {
          this.switchCdiSrc(3);
        } else if (src.type === NavSourceType.Nav) {
          this.switchCdiSrc(src.index - 1);
        }
      });
      this.controlSubscriber.on("cdi_src_gps_toggle").handle(this.onCdiGpsToggle);
      this.controlSubscriber.on("init_cdi").handle(this.initCdi.bind(this));
      this.controlSubscriber.on("brg_src_switch").handle(this.cycleBrgSrc.bind(this));
      this.simVarSubscriber.on("mkr_bcn_state_simvar").whenChanged().handle((state) => {
        this.publisher.publishMarkerBeacon(state);
      });
      this.simVarSubscriber.on("gps_obs_active_simvar").whenChanged().handle((state) => {
        this.publisher.publishGpsObsState(state);
      });
      this.simVarSubscriber.on("gps_obs_value_simvar").whenChangedBy(1).handle((value) => {
        this.publisher.publishGpsObsValue(value);
      });
      for (let i = 1; i <= this.config.numNav; i++) {
        const index = i;
        const src = new NavSourceBase({ type: NavSourceType.Nav, index });
        src.deviationHandler = this.publisher.publishDeviation.bind(this.publisher);
        src.obsHandler = this.publisher.publishObsHeading.bind(this.publisher);
        src.distHandler = this.onBrgDistance.bind(this);
        src.brgHandler = this.onBrgDirection.bind(this);
        src.identHandler = this.onBrgIdent.bind(this);
        src.toFromHandler = this.publisher.publishToFrom.bind(this.publisher);
        src.localizerCourseHandler = this.onLocalizerCourse.bind(this);
        src.glideslopeDeviationHandler = this.onGlideslopeDeviation.bind(this);
        src.magvarHandler = this.publisher.publishMagvar.bind(this.publisher);
        src.isLocalizerFrequencyHandler = this.onIsLocalizerFrequency.bind(this);
        src.glideslopeAngleHandler = this.onGlideslopeAngle.bind(this);
        src.validHandler = this.onBrgValidity.bind(this);
        this.simVarSubscriber.on(`nav_cdi_${index}`).whenChangedBy(1).handle((deviation) => {
          src.deviation = deviation;
        });
        this.simVarSubscriber.on(`nav_obs_${index}`).whenChangedBy(1).handle((obs) => {
          src.obs = obs;
        });
        this.simVarSubscriber.on(`nav_dme_${index}`).whenChangedBy(0.1).handle((distance) => {
          src.distance = distance;
          this.onDme(src.hasDme, src.distance, src.srcId);
        });
        this.simVarSubscriber.on(`nav_radial_${index}`).handle((bearing) => {
          src.bearing = bearing;
        });
        this.simVarSubscriber.on(`nav_ident_${index}`).whenChanged().handle((ident) => {
          src.ident = ident;
        });
        this.simVarSubscriber.on(`nav_signal_${index}`).withPrecision(0).handle((signal) => {
          src.signal = signal;
        });
        this.simVarSubscriber.on(`nav_has_nav_${index}`).whenChanged().handle((valid) => {
          src.valid = !!valid;
        });
        this.simVarSubscriber.on(`nav_has_dme_${index}`).whenChanged().handle((dme) => {
          src.hasDme = !!dme;
          this.onDme(src.hasDme, src.distance, src.srcId);
        });
        this.simVarSubscriber.on(`nav_to_from_${index}`).whenChanged().handle((value) => {
          src.toFrom = value;
        });
        this.simVarSubscriber.on(`nav_localizer_${index}`).whenChanged().handle((localizer) => {
          src.hasLocalizer = localizer;
        });
        this.simVarSubscriber.on(`nav_localizer_crs_${index}`).whenChanged().handle((locCourse) => {
          src.localizerCourse = locCourse;
        });
        this.simVarSubscriber.on(`nav_glideslope_${index}`).whenChanged().handle((gs) => {
          src.hasGlideslope = gs;
        });
        this.simVarSubscriber.on(`nav_gs_error_${index}`).whenChanged().handle((gsDev) => {
          src.glideslopeDeviation = gsDev;
        });
        this.simVarSubscriber.on(`nav_raw_gs_${index}`).whenChanged().handle((rawGs) => {
          src.glideslopeAngle = rawGs;
        });
        this.simVarSubscriber.on(`nav_magvar_${index}`).whenChanged().handle((magvar) => {
          src.magneticVariation = magvar;
        });
        this.navComSubscriber.on("set_radio_state").handle((radioState) => {
          if (radioState.radioType === RadioType.Nav && radioState.index == i && radioState.activeFrequency) {
            src.isLocalizerFrequency = this.frequencyIsLocalizer(radioState.activeFrequency);
          }
        });
        this.navComSubscriber.on("set_frequency").handle((setFrequency) => {
          if (setFrequency.radio.radioType === RadioType.Nav && setFrequency.radio.index == i && setFrequency.bank == FrequencyBank.Active) {
            src.isLocalizerFrequency = this.frequencyIsLocalizer(setFrequency.frequency);
            for (let j = 0; j < this.bearingSourceIdxs.length; j++) {
              if (this.navSources[this.bearingSourceIdxs[j]] !== void 0) {
                const source = this.navSources[this.bearingSourceIdxs[j]].srcId;
                if (source.type === NavSourceType.Nav && source.index === i) {
                  this.setBrgSrc(j, this.bearingSourceIdxs[j]);
                }
              }
            }
          }
        });
        this.navSources.push(src);
      }
      if (this.config.numGps > 0) {
        this.cdiSourceIdx = this.config.numNav;
        const src = new NavSourceBase({ type: NavSourceType.Gps, index: 1 });
        src.valid = true;
        src.deviationHandler = this.publisher.publishDeviation.bind(this.publisher);
        src.obsHandler = this.publisher.publishObsHeading.bind(this.publisher);
        src.distHandler = this.onBrgDistance.bind(this);
        src.brgHandler = this.onBrgDirection.bind(this);
        src.identHandler = this.onBrgIdent.bind(this);
        this.simVarSubscriber.on("gps_xtk").whenChangedBy(1).handle((deviation) => {
          src.deviation = deviation;
        });
        this.simVarSubscriber.on("gps_dtk").whenChangedBy(1).handle((obs) => {
          src.obs = obs;
        });
        this.simVarSubscriber.on("gps_wp_bearing").withPrecision(2).handle((brg) => {
          brg = (brg * Avionics.Utils.RAD2DEG + 180) % 360;
          src.bearing = brg;
        });
        this.navSources.push(src);
      }
      if (this.config.numAdf > 0) {
        const src = new NavSourceBase({ type: NavSourceType.Adf, index: 1 });
        src.valid = false;
        src.signal = 0;
        src.brgHandler = this.onBrgDirection.bind(this);
        src.identHandler = this.onBrgIdent.bind(this);
        src.validHandler = this.onBrgValidity.bind(this);
        this.simVarSubscriber.on("adf_signal_1").withPrecision(0).handle((signal) => {
          src.signal = signal;
          if (signal > 0) {
            if (!src.valid) {
              src.valid = true;
            }
          } else {
            if (src.valid) {
              src.valid = false;
            }
          }
        });
        this.navComSubscriber.on("adf_active_frequency_1").handle((freq) => {
          if (src.ident !== freq.toFixed(1)) {
            src.ident = freq.toFixed(1);
          }
        });
        this.simVarSubscriber.on("adf_bearing_1").withPrecision(2).handle((brg) => {
          brg = (brg + 180) % 360;
          src.bearing = brg;
        });
        this.navSources.push(src);
      }
      for (const source of this.config.additionalSources) {
        this.addNavSource(source);
      }
      const initGpsDrivesNav1 = SimVar.GetSimVarValue("GPS DRIVES NAV1", SimVarValueType.Bool);
      this.cdiSourceIdx = initGpsDrivesNav1 ? this.getFirstNavSourceIndexByType(NavSourceType.Gps) : this.getFirstNavSourceIndexByType(NavSourceType.Nav);
      for (let i = 0; i < 2; i++) {
        const fltBrgSrc = SimVar.GetSimVarValue(`L:PFD_BRG${i + 1}_Source`, SimVarValueType.Number);
        this.setBrgSrc(i, this.brgSrcAsoboMap[fltBrgSrc]);
      }
    }
    /**
     * Add a custom nav source to the processor.
     * @param source The implementation of NavSourceBase to add.
     */
    addNavSource(source) {
      if (source.validHandler) {
        source.validHandler = this.onBrgValidity.bind(this);
      }
      if (source.brgHandler) {
        source.brgHandler = this.onBrgDirection.bind(this);
      }
      if (source.distHandler) {
        source.distHandler = this.onBrgDistance.bind(this);
      }
      if (source.identHandler) {
        source.identHandler = this.onBrgIdent.bind(this);
      }
      this.navSources.push(source);
    }
    /**
     * Process a CDI source change event.
     * @param index is specified if a specific cdiSourceIdx is requested
     */
    switchCdiSrc(index) {
      let src = this.navSources[this.cdiSourceIdx];
      src.activeCdi = false;
      if (index !== void 0 && index < this.navSources.length && this.navSources[index].hasCdi) {
        this.cdiSourceIdx = index;
      } else if (index === void 0) {
        do {
          this.cdiSourceIdx = this.cdiSourceIdx < this.navSources.length - 1 ? this.cdiSourceIdx + 1 : 0;
        } while (!this.navSources[this.cdiSourceIdx].hasCdi);
      } else {
        console.warn(`switchCdiSrc: Unable to set CDI Source index ${index}`);
        return;
      }
      src = this.navSources[this.cdiSourceIdx];
      src.activeCdi = true;
      this.publisher.publishCdiSelect(src.srcId);
      if (src.obs) {
        this.publisher.publishObsHeading(src.obs, src.srcId);
      }
      if (src.toFrom) {
        this.publisher.publishToFrom(src.toFrom, src.srcId);
      }
      this.publisher.publishDmeState(src.hasDme, src.distance, src.srcId);
      SimVar.SetSimVarValue("GPS DRIVES NAV1", SimVarValueType.Bool, src.srcId.type === NavSourceType.Gps);
      if (src.srcId.type === NavSourceType.Nav) {
        SimVar.SetSimVarValue("AUTOPILOT NAV SELECTED", SimVarValueType.Number, src.srcId.index);
      }
    }
    /** Initialize the CDI. */
    initCdi() {
      const src = this.navSources[this.cdiSourceIdx];
      src.activeCdi = true;
      this.publisher.publishCdiSelect(src.srcId);
      if (src.obs) {
        this.publisher.publishObsHeading(src.obs, src.srcId);
      }
      if (src.toFrom) {
        this.publisher.publishToFrom(src.toFrom, src.srcId);
      }
      this.publisher.publishDmeState(src.hasDme, src.distance, src.srcId);
      SimVar.SetSimVarValue("GPS DRIVES NAV1", SimVarValueType.Bool, src.srcId.type === NavSourceType.Gps);
    }
    /**
     * Process a bearing source change event.
     * @param index The index of the source to change (1-based).
     */
    cycleBrgSrc(index) {
      index--;
      let newNavSrcIndex = -1;
      if (this.bearingSourceIdxs[index] < this.navSources.length - 1) {
        newNavSrcIndex = this.bearingSourceIdxs[index] + 1;
      }
      this.setBrgSrc(index, newNavSrcIndex);
    }
    /**
     * Set the bearing source to the specified nav source index.
     * @param bearingSrcIndex The index of the bearing source to change (0-based).
     * @param navSrcIndex The index of the nav source to change to (0-based).
     */
    setBrgSrc(bearingSrcIndex, navSrcIndex) {
      if (bearingSrcIndex > this.bearingSourceIdxs.length - 1 || navSrcIndex > this.navSources.length - 1) {
        console.warn(`setBrgSrc: Unable to set bearing source index ${bearingSrcIndex} and nav source index ${navSrcIndex}`);
        return;
      }
      const oldSrc = this.navSources[this.bearingSourceIdxs[bearingSrcIndex]];
      if (oldSrc !== void 0) {
        oldSrc.activeBrg = false;
      }
      this.bearingSourceIdxs[bearingSrcIndex] = navSrcIndex;
      const newSrc = this.navSources[this.bearingSourceIdxs[bearingSrcIndex]];
      this.publisher.publishBrgSrc(bearingSrcIndex, newSrc !== void 0 ? newSrc.srcId : null);
      SimVar.SetSimVarValue(`L:PFD_BRG${bearingSrcIndex + 1}_Source`, SimVarValueType.Number, this.brgSrcAsoboMap.indexOf(navSrcIndex));
      if (newSrc !== void 0) {
        newSrc.activeBrg = true;
      }
      newSrc && this.publisher.publishBrgValidity(bearingSrcIndex, newSrc.valid);
      if (newSrc === void 0) {
        this.publisher.publishBrgIdent(bearingSrcIndex, null, false);
        this.publisher.publishBrgDir(bearingSrcIndex, null);
        this.publisher.publishBrgDist(bearingSrcIndex, null);
      }
    }
    /**
     * Handle a course inc event if we have a nav radio as our active CDI source.
     */
    handleCrsInc() {
      if (this.navSources[this.cdiSourceIdx].srcId.type != NavSourceType.Nav) {
        return;
      }
      switch (this.navSources[this.cdiSourceIdx].srcId.index) {
        case 1:
          SimVar.SetSimVarValue("K:VOR1_OBI_INC", "number", 0);
          break;
        case 2:
          SimVar.SetSimVarValue("K:VOR2_OBI_INC", "number", 0);
      }
    }
    /**
     * Handle a course dec event if we have a nav radio as our active CDI source.
     */
    handleCrsDec() {
      if (this.navSources[this.cdiSourceIdx].srcId.type != NavSourceType.Nav) {
        return;
      }
      switch (this.navSources[this.cdiSourceIdx].srcId.index) {
        case 1:
          SimVar.SetSimVarValue("K:VOR1_OBI_DEC", "number", 0);
          break;
        case 2:
          SimVar.SetSimVarValue("K:VOR2_OBI_DEC", "number", 0);
          break;
      }
    }
    /**
     * Handle a course sync event if we have a nav radio as our active CDI source.
     */
    handleCrsSync() {
      if (this.navSources[this.cdiSourceIdx].srcId.type != NavSourceType.Nav) {
        return;
      }
      switch (this.navSources[this.cdiSourceIdx].srcId.index) {
        case 1:
          SimVar.SetSimVarValue("K:VOR1_SET", "number", this.navSources[0].bearing);
          break;
        case 2:
          SimVar.SetSimVarValue("K:VOR2_SET", "number", this.navSources[1].bearing);
          break;
      }
    }
    /**
     * Handle a bearing validity change.
     * @param valid The new bearing validity
     * @param source The source of
     */
    onBrgValidity(valid, source) {
      if (this.bearingSourceIdxs) {
        for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
          if (this.navSources[this.bearingSourceIdxs[i]] && this.navSources[this.bearingSourceIdxs[i]].srcId == source) {
            this.publisher.publishBrgValidity(i, valid);
          }
        }
      }
    }
    // TODO Unify the next two functions
    /**
     * Handle a bearing distance change.
     * @param distance The distance to the source.
     * @param source The nav source ID.
     */
    onBrgDistance(distance, source) {
      for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
        if (this.navSources[this.bearingSourceIdxs[i]] && this.navSources[this.bearingSourceIdxs[i]].srcId == source && !this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
          this.publisher.publishBrgDist(i, distance);
        }
      }
    }
    /**
     * Handle a bearing direction change.
     * @param direction The distance to the source.
     * @param source The nav source ID.
     */
    onBrgDirection(direction, source) {
      for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
        if (this.navSources[this.bearingSourceIdxs[i]] && this.navSources[this.bearingSourceIdxs[i]].srcId == source && !this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
          this.publisher.publishBrgDir(i, direction);
        }
      }
    }
    /**
     * Handle a bearing ident change.
     * @param ident The ident of the source.
     * @param source The nav source ID.
     */
    onBrgIdent(ident, source) {
      for (let i = 0; i < this.bearingSourceIdxs.length; i++) {
        if (this.navSources[this.bearingSourceIdxs[i]] && this.navSources[this.bearingSourceIdxs[i]].srcId == source) {
          this.publisher.publishBrgIdent(i, ident, this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency);
          if (this.navSources[this.bearingSourceIdxs[i]].isLocalizerFrequency) {
            this.publisher.publishBrgDir(i, null);
            this.publisher.publishBrgDist(i, null);
          } else {
            this.publisher.publishBrgSrc(i, source);
          }
        }
      }
    }
    /**
     * Handle a localizer course change.
     * @param course The localizer course of the source.
     * @param source The nav source ID.
     */
    onLocalizerCourse(course, source) {
      for (let i = 0; i < this.navSources.length; i++) {
        if (this.navSources[i] && this.navSources[i].srcId == source && this.navSources[i].hasLocalizer && course !== null) {
          const localizer = { isValid: true, course, source };
          this.publisher.publishLocalizer(localizer, source);
        }
      }
    }
    /**
     * Handle a glideslope deviation change.
     * @param deviation The glideslope deviation of the source.
     * @param source The nav source ID.
     */
    onGlideslopeDeviation(deviation, source) {
      for (let i = 0; i < this.navSources.length; i++) {
        const navSource = this.navSources[i];
        if (navSource && navSource.srcId == source && deviation !== null && navSource.glideslopeAngle) {
          const glideslope = { isValid: this.navSources[i].hasGlideslope, deviation, gsAngle: navSource.glideslopeAngle, source };
          this.publisher.publishGlideslope(glideslope, source);
        }
      }
    }
    /**
     * Handle a glideslope angle change.
     * @param angle The glideslope angle of the source.
     * @param source The nav source ID.
     */
    onGlideslopeAngle(angle, source) {
      for (let i = 0; i < this.navSources.length; i++) {
        const navSource = this.navSources[i];
        if (navSource && navSource.srcId == source && navSource.deviation && angle !== null) {
          const glideslope = { isValid: this.navSources[i].hasGlideslope, deviation: navSource.deviation, gsAngle: angle, source };
          this.publisher.publishGlideslope(glideslope, source);
        }
      }
    }
    /**
     * Determine whether a set frequency is a localizer frequency.
     * @param frequency The frequency to evaluate.
     * @returns a bool true if the frequency is a loc freq.
     */
    frequencyIsLocalizer(frequency) {
      const roundedFreq = Math.round(frequency * 100) / 100;
      return RadioUtils.isLocalizerFrequency(roundedFreq);
    }
    /**
     * Publishers whether a set frequency is a localizer frequency.
     * @param isLoc whether the freq is a loc.
     * @param source the selected nav source.
     */
    onIsLocalizerFrequency(isLoc, source) {
      if (isLoc !== null) {
        const loc = { isLocalizer: isLoc, source };
        this.publisher.publishIsLocalizerFrequency(loc, source);
      }
    }
    /**
     * Publishers dme distance info.  This should be replaced by a generalization of
     * BearingDistance that provides the distance to any nav source if it has DME.
     * @param hasDme whether the radio has dme.
     * @param distance is the dme distance.
     * @param source the selected nav source.
     */
    onDme(hasDme, distance, source) {
      this.publisher.publishDmeState(hasDme ? hasDme : false, distance ? distance : -1, source);
    }
    /**
     * Gets the index of the first nav source of the given type.
     * @param type The type of nav source to find.
     * @returns The nav source index.
     */
    getFirstNavSourceIndexByType(type) {
      return this.navSources.findIndex((source) => source.srcId.type === type);
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
      this.simVarPublisher.onUpdate();
    }
  };
  var APRadioNavInstrument = class {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
      this.bus = bus;
      this.navRadioData = {
        0: {
          gsLocation: new LatLongAlt(0, 0),
          navLocation: new LatLongAlt(0, 0),
          glideslope: this.createEmptyGlideslope({ index: 1, type: NavSourceType.Nav }),
          localizer: this.createEmptyLocalizer({ index: 1, type: NavSourceType.Nav }),
          cdi: this.createEmptyCdi({ index: 1, type: NavSourceType.Nav }),
          obs: this.createEmptyObs({ index: 1, type: NavSourceType.Nav }),
          magVar: 0
        },
        1: {
          gsLocation: new LatLongAlt(0, 0),
          navLocation: new LatLongAlt(0, 0),
          glideslope: this.createEmptyGlideslope({ index: 1, type: NavSourceType.Nav }),
          localizer: this.createEmptyLocalizer({ index: 1, type: NavSourceType.Nav }),
          cdi: this.createEmptyCdi({ index: 1, type: NavSourceType.Nav }),
          obs: this.createEmptyObs({ index: 1, type: NavSourceType.Nav }),
          magVar: 0
        },
        2: {
          gsLocation: new LatLongAlt(0, 0),
          navLocation: new LatLongAlt(0, 0),
          glideslope: this.createEmptyGlideslope({ index: 2, type: NavSourceType.Nav }),
          localizer: this.createEmptyLocalizer({ index: 2, type: NavSourceType.Nav }),
          cdi: this.createEmptyCdi({ index: 2, type: NavSourceType.Nav }),
          obs: this.createEmptyObs({ index: 2, type: NavSourceType.Nav }),
          magVar: 0
        },
        3: {
          gsLocation: new LatLongAlt(0, 0),
          navLocation: new LatLongAlt(0, 0),
          glideslope: this.createEmptyGlideslope({ index: 3, type: NavSourceType.Nav }),
          localizer: this.createEmptyLocalizer({ index: 3, type: NavSourceType.Nav }),
          cdi: this.createEmptyCdi({ index: 3, type: NavSourceType.Nav }),
          obs: this.createEmptyObs({ index: 3, type: NavSourceType.Nav }),
          magVar: 0
        },
        4: {
          gsLocation: new LatLongAlt(0, 0),
          navLocation: new LatLongAlt(0, 0),
          glideslope: this.createEmptyGlideslope({ index: 4, type: NavSourceType.Nav }),
          localizer: this.createEmptyLocalizer({ index: 4, type: NavSourceType.Nav }),
          cdi: this.createEmptyCdi({ index: 4, type: NavSourceType.Nav }),
          obs: this.createEmptyObs({ index: 4, type: NavSourceType.Nav }),
          magVar: 0
        }
      };
      this.currentCdiIndex = 1;
      this.navProc = new NavProcSimVarPublisher(bus);
      this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
      this.navProc.startPublish();
      const navProcSubscriber = this.bus.getSubscriber();
      navProcSubscriber.on("nav_glideslope_1").whenChanged().handle((hasGs) => this.setGlideslopeValue(1, "isValid", hasGs));
      navProcSubscriber.on("nav_gs_lla_1").handle((lla) => this.setGlideslopePosition(1, lla));
      navProcSubscriber.on("nav_gs_error_1").whenChanged().handle((gsError) => this.setGlideslopeValue(1, "deviation", gsError));
      navProcSubscriber.on("nav_raw_gs_1").whenChanged().handle((rawGs) => this.setGlideslopeValue(1, "gsAngle", rawGs));
      navProcSubscriber.on("nav_localizer_1").whenChanged().handle((hasLoc) => this.setLocalizerValue(1, "isValid", hasLoc));
      navProcSubscriber.on("nav_localizer_crs_1").whenChanged().handle((locCourse) => this.setLocalizerValue(1, "course", locCourse));
      navProcSubscriber.on("nav_cdi_1").whenChanged().handle((deviation) => this.setCDIValue(1, "deviation", deviation));
      navProcSubscriber.on("nav_obs_1").whenChanged().handle((obs) => this.setOBSValue(1, "heading", obs));
      navProcSubscriber.on("nav_lla_1").handle((lla) => this.setNavPosition(1, lla));
      navProcSubscriber.on("nav_magvar_1").whenChanged().handle((magVar) => this.setMagVar(1, magVar));
      navProcSubscriber.on("nav_has_nav_1").whenChanged().handle((hasNav) => !hasNav && this.setCDIValue(1, "deviation", null));
      navProcSubscriber.on("nav_glideslope_2").whenChanged().handle((hasGs) => this.setGlideslopeValue(2, "isValid", hasGs));
      navProcSubscriber.on("nav_gs_lla_2").handle((lla) => this.setGlideslopePosition(2, lla));
      navProcSubscriber.on("nav_gs_error_2").whenChanged().handle((gsError) => this.setGlideslopeValue(2, "deviation", gsError));
      navProcSubscriber.on("nav_raw_gs_2").whenChanged().handle((rawGs) => this.setGlideslopeValue(2, "gsAngle", rawGs));
      navProcSubscriber.on("nav_localizer_2").whenChanged().handle((hasLoc) => this.setLocalizerValue(2, "isValid", hasLoc));
      navProcSubscriber.on("nav_localizer_crs_2").whenChanged().handle((locCourse) => this.setLocalizerValue(2, "course", locCourse));
      navProcSubscriber.on("nav_cdi_2").whenChanged().handle((deviation) => this.setCDIValue(2, "deviation", deviation));
      navProcSubscriber.on("nav_obs_2").whenChanged().handle((obs) => this.setOBSValue(2, "heading", obs));
      navProcSubscriber.on("nav_lla_2").handle((lla) => this.setNavPosition(2, lla));
      navProcSubscriber.on("nav_magvar_2").whenChanged().handle((magVar) => this.setMagVar(2, magVar));
      navProcSubscriber.on("nav_has_nav_2").whenChanged().handle((hasNav) => !hasNav && this.setCDIValue(2, "deviation", null));
      navProcSubscriber.on("nav_glideslope_3").whenChanged().handle((hasGs) => this.setGlideslopeValue(3, "isValid", hasGs));
      navProcSubscriber.on("nav_gs_lla_3").handle((lla) => this.setGlideslopePosition(3, lla));
      navProcSubscriber.on("nav_gs_error_3").whenChanged().handle((gsError) => this.setGlideslopeValue(3, "deviation", gsError));
      navProcSubscriber.on("nav_raw_gs_3").whenChanged().handle((rawGs) => this.setGlideslopeValue(3, "gsAngle", rawGs));
      navProcSubscriber.on("nav_localizer_3").whenChanged().handle((hasLoc) => this.setLocalizerValue(3, "isValid", hasLoc));
      navProcSubscriber.on("nav_localizer_crs_3").whenChanged().handle((locCourse) => this.setLocalizerValue(3, "course", locCourse));
      navProcSubscriber.on("nav_cdi_3").whenChanged().handle((deviation) => this.setCDIValue(3, "deviation", deviation));
      navProcSubscriber.on("nav_obs_3").whenChanged().handle((obs) => this.setOBSValue(3, "heading", obs));
      navProcSubscriber.on("nav_lla_3").handle((lla) => this.setNavPosition(3, lla));
      navProcSubscriber.on("nav_magvar_3").whenChanged().handle((magVar) => this.setMagVar(3, magVar));
      navProcSubscriber.on("nav_has_nav_3").whenChanged().handle((hasNav) => !hasNav && this.setCDIValue(3, "deviation", null));
      navProcSubscriber.on("nav_glideslope_4").whenChanged().handle((hasGs) => this.setGlideslopeValue(4, "isValid", hasGs));
      navProcSubscriber.on("nav_gs_lla_4").handle((lla) => this.setGlideslopePosition(4, lla));
      navProcSubscriber.on("nav_gs_error_4").whenChanged().handle((gsError) => this.setGlideslopeValue(4, "deviation", gsError));
      navProcSubscriber.on("nav_raw_gs_4").whenChanged().handle((rawGs) => this.setGlideslopeValue(4, "gsAngle", rawGs));
      navProcSubscriber.on("nav_localizer_4").whenChanged().handle((hasLoc) => this.setLocalizerValue(4, "isValid", hasLoc));
      navProcSubscriber.on("nav_localizer_crs_4").whenChanged().handle((locCourse) => this.setLocalizerValue(4, "course", locCourse));
      navProcSubscriber.on("nav_cdi_4").whenChanged().handle((deviation) => this.setCDIValue(4, "deviation", deviation));
      navProcSubscriber.on("nav_obs_4").whenChanged().handle((obs) => this.setOBSValue(4, "heading", obs));
      navProcSubscriber.on("nav_lla_4").handle((lla) => this.setNavPosition(4, lla));
      navProcSubscriber.on("nav_magvar_4").whenChanged().handle((magVar) => this.setMagVar(4, magVar));
      navProcSubscriber.on("nav_has_nav_4").whenChanged().handle((hasNav) => !hasNav && this.setCDIValue(4, "deviation", null));
      const navEvents = this.bus.getSubscriber();
      navEvents.on("cdi_select").handle((source) => {
        const oldIndex = this.currentCdiIndex;
        this.currentCdiIndex = source.type === NavSourceType.Nav ? source.index : 0;
        if (oldIndex !== this.currentCdiIndex) {
          const data = this.navRadioData[this.currentCdiIndex];
          this.publisher.pub("nav_radio_active_gs_location", data.gsLocation);
          this.publisher.pub("nav_radio_active_nav_location", data.navLocation);
          this.publisher.pub("nav_radio_active_glideslope", data.glideslope);
          this.publisher.pub("nav_radio_active_localizer", data.localizer);
          this.publisher.pub("nav_radio_active_cdi_deviation", data.cdi);
          this.publisher.pub("nav_radio_active_obs_setting", data.obs);
          this.publisher.pub("nav_radio_active_magvar", data.magVar);
        }
      });
    }
    /** @inheritdoc */
    onUpdate() {
      this.navProc.onUpdate();
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
      this.navRadioData[index].glideslope[field] = value;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_glideslope", this.navRadioData[index].glideslope);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_glideslope_1", this.navRadioData[index].glideslope);
          break;
        case 2:
          this.publisher.pub("nav_radio_glideslope_2", this.navRadioData[index].glideslope);
          break;
        case 3:
          this.publisher.pub("nav_radio_glideslope_3", this.navRadioData[index].glideslope);
          break;
        case 4:
          this.publisher.pub("nav_radio_glideslope_4", this.navRadioData[index].glideslope);
          break;
      }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setGlideslopePosition(index, lla) {
      this.navRadioData[index].gsLocation = lla;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_gs_location", lla);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_gs_location_1", this.navRadioData[index].gsLocation);
          break;
        case 2:
          this.publisher.pub("nav_radio_gs_location_2", this.navRadioData[index].gsLocation);
          break;
        case 3:
          this.publisher.pub("nav_radio_gs_location_3", this.navRadioData[index].gsLocation);
          break;
        case 4:
          this.publisher.pub("nav_radio_gs_location_4", this.navRadioData[index].gsLocation);
          break;
      }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setNavPosition(index, lla) {
      this.navRadioData[index].navLocation = lla;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_nav_location", lla);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_nav_location_1", this.navRadioData[index].navLocation);
          break;
        case 2:
          this.publisher.pub("nav_radio_nav_location_2", this.navRadioData[index].navLocation);
          break;
        case 3:
          this.publisher.pub("nav_radio_nav_location_3", this.navRadioData[index].navLocation);
          break;
        case 4:
          this.publisher.pub("nav_radio_nav_location_4", this.navRadioData[index].navLocation);
          break;
      }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
      this.navRadioData[index].localizer[field] = value;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_localizer", this.navRadioData[index].localizer);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_localizer_1", this.navRadioData[index].localizer);
          break;
        case 2:
          this.publisher.pub("nav_radio_localizer_2", this.navRadioData[index].localizer);
          break;
        case 3:
          this.publisher.pub("nav_radio_localizer_3", this.navRadioData[index].localizer);
          break;
        case 4:
          this.publisher.pub("nav_radio_localizer_4", this.navRadioData[index].localizer);
          break;
      }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
      this.navRadioData[index].cdi[field] = value;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_cdi_deviation", this.navRadioData[index].cdi);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_cdi_1", this.navRadioData[index].cdi);
          break;
        case 2:
          this.publisher.pub("nav_radio_cdi_2", this.navRadioData[index].cdi);
          break;
        case 3:
          this.publisher.pub("nav_radio_cdi_3", this.navRadioData[index].cdi);
          break;
        case 4:
          this.publisher.pub("nav_radio_cdi_4", this.navRadioData[index].cdi);
          break;
      }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
      this.navRadioData[index].obs[field] = value;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_obs_setting", this.navRadioData[index].obs);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_obs_1", this.navRadioData[index].obs);
          break;
        case 2:
          this.publisher.pub("nav_radio_obs_2", this.navRadioData[index].obs);
          break;
        case 3:
          this.publisher.pub("nav_radio_obs_3", this.navRadioData[index].obs);
          break;
        case 4:
          this.publisher.pub("nav_radio_obs_4", this.navRadioData[index].obs);
          break;
      }
    }
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    setMagVar(index, magVar) {
      magVar = NavMath.normalizeHeading(-magVar + 180) % 360 - 180;
      this.navRadioData[index].magVar = magVar;
      if (this.currentCdiIndex === index) {
        this.publisher.pub("nav_radio_active_magvar", magVar);
      }
      switch (index) {
        case 1:
          this.publisher.pub("nav_radio_magvar_1", this.navRadioData[index].magVar);
          break;
        case 2:
          this.publisher.pub("nav_radio_magvar_2", this.navRadioData[index].magVar);
          break;
        case 3:
          this.publisher.pub("nav_radio_magvar_3", this.navRadioData[index].magVar);
          break;
        case 4:
          this.publisher.pub("nav_radio_magvar_4", this.navRadioData[index].magVar);
          break;
      }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
      return {
        isValid: false,
        course: 0,
        source: id
      };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
      return {
        isValid: false,
        gsAngle: 0,
        deviation: 0,
        source: id
      };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
      return {
        deviation: 0,
        source: id
      };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
      return {
        heading: 0,
        source: id
      };
    }
  };
  var InstrumentBackplane = class {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
      this.publishers = /* @__PURE__ */ new Map();
      this.instruments = /* @__PURE__ */ new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
      this.initPublishers();
      this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
      this.updatePublishers();
      this.updateInstruments();
    }
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name, publisher, override = false) {
      if (override || !InstrumentBackplane.checkAlreadyExists(name, publisher, this.publishers)) {
        this.publishers.set(name, publisher);
      }
    }
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name, instrument, override = false) {
      if (override || !InstrumentBackplane.checkAlreadyExists(name, instrument, this.instruments)) {
        this.instruments.set(name, instrument);
      }
    }
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher(name) {
      return this.publishers.get(name);
    }
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument(name) {
      return this.instruments.get(name);
    }
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    static checkAlreadyExists(name, objToCheck, map) {
      if (map.has(name)) {
        console.warn(`${name} already exists in backplane.`);
        return true;
      }
      for (const p of map.values()) {
        if (p.constructor === objToCheck.constructor) {
          console.warn(`${name} already exists in backplane.`);
          return true;
        }
      }
      return false;
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
      for (const publisher of this.publishers.values()) {
        publisher.startPublish();
      }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
      for (const instrument of this.instruments.values()) {
        instrument.init();
      }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
      for (const publisher of this.publishers.values()) {
        publisher.onUpdate();
      }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
      for (const instrument of this.instruments.values()) {
        instrument.onUpdate();
      }
    }
  };
  var BrakeSimvarPublisher = class extends SimVarPublisher {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      const simvars = /* @__PURE__ */ new Map([
        ["brake_position_left", { name: "BRAKE LEFT POSITION", type: SimVarValueType.Percent }],
        ["brake_position_right", { name: "BRAKE RIGHT POSITION", type: SimVarValueType.Percent }],
        ["brake_position_left_raw", { name: "BRAKE LEFT POSITION EX1", type: SimVarValueType.Percent }],
        ["brake_position_right_raw", { name: "BRAKE RIGHT POSITION EX1", type: SimVarValueType.Percent }],
        ["left_wheel_rpm", { name: "LEFT WHEEL RPM", type: SimVarValueType.RPM }],
        ["right_wheel_rpm", { name: "RIGHT WHEEL RPM", type: SimVarValueType.RPM }],
        ["parking_brake_set", { name: "BRAKE PARKING POSITION", type: SimVarValueType.Bool }]
      ]);
      super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
      super.onUpdate();
    }
  };
  var ClockPublisher = class extends BasePublisher {
    /** @inheritdoc */
    startPublish() {
      super.startPublish();
      setInterval(() => this.publish("simTimeHiFreq", ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue("E:ABSOLUTE TIME", "seconds"))), 0);
    }
    /** @inheritdoc */
    onUpdate() {
      this.publish("realTime", Date.now());
      this.publish("simTime", ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue("E:ABSOLUTE TIME", "seconds")));
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
      return (absoluteTime - 62135596800) * 1e3;
    }
  };
  var Clock3 = class {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
      this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
      this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
      this.publisher.onUpdate();
    }
  };
  var ControlSurfacesPublisher = class extends SimVarPublisher {
    /**
     * Create an ControlSurfacesPublisher.
     * @param bus The EventBus to publish to.
     * @param gearCount The number of landing gear to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, gearCount, pacer) {
      const nonIndexedSimVars = [
        ["flaps_handle_index", { name: "FLAPS HANDLE INDEX", type: SimVarValueType.Number }],
        ["flaps_left_angle", { name: "TRAILING EDGE FLAPS LEFT ANGLE", type: SimVarValueType.Degree }],
        ["flaps_right_angle", { name: "TRAILING EDGE FLAPS RIGHT ANGLE", type: SimVarValueType.Degree }],
        ["flaps_left_percent", { name: "TRAILING EDGE FLAPS LEFT PERCENT", type: SimVarValueType.Percent }],
        ["flaps_right_percent", { name: "TRAILING EDGE FLAPS RIGHT PERCENT", type: SimVarValueType.Percent }],
        ["slats_left_angle", { name: "LEADING EDGE FLAPS LEFT ANGLE", type: SimVarValueType.Degree }],
        ["slats_right_angle", { name: "LEADING EDGE FLAPS RIGHT ANGLE", type: SimVarValueType.Degree }],
        ["slats_left_percent", { name: "LEADING EDGE FLAPS LEFT PERCENT", type: SimVarValueType.Percent }],
        ["slats_right_percent", { name: "LEADING EDGE FLAPS RIGHT PERCENT", type: SimVarValueType.Percent }],
        ["spoilers_left_percent", { name: "SPOILERS LEFT POSITION", type: SimVarValueType.Percent }],
        ["spoilers_right_percent", { name: "SPOILERS RIGHT POSITION", type: SimVarValueType.Percent }],
        ["spoilers_without_spoilerons_left_percent", { name: "SPOILERS WITHOUT SPOILERONS LEFT POSITION", type: SimVarValueType.Percent }],
        ["elevator_trim_angle", { name: "ELEVATOR TRIM POSITION", type: SimVarValueType.Degree }],
        ["elevator_trim_pct", { name: "ELEVATOR TRIM PCT", type: SimVarValueType.Percent }],
        ["elevator_trim_neutral_pct", { name: "AIRCRAFT ELEVATOR TRIM NEUTRAL", type: SimVarValueType.Percent }],
        ["aileron_trim_angle", { name: "AILERON TRIM", type: SimVarValueType.Degree }],
        ["aileron_trim_pct", { name: "AILERON TRIM PCT", type: SimVarValueType.Percent }],
        ["rudder_trim_angle", { name: "RUDDER TRIM", type: SimVarValueType.Degree }],
        ["rudder_trim_pct", { name: "RUDDER TRIM PCT", type: SimVarValueType.Percent }],
        ["aileron_left_percent", { name: "AILERON LEFT DEFLECTION PCT", type: SimVarValueType.Percent }],
        ["aileron_right_percent", { name: "AILERON RIGHT DEFLECTION PCT", type: SimVarValueType.Percent }],
        ["elevator_percent", { name: "ELEVATOR DEFLECTION PCT", type: SimVarValueType.Percent }],
        ["rudder_percent", { name: "RUDDER DEFLECTION PCT", type: SimVarValueType.Percent }]
      ];
      const gearIndexedSimVars = [
        ["gear_position", { name: "GEAR POSITION", type: SimVarValueType.Number }],
        ["gear_is_on_ground", { name: "GEAR IS ON GROUND", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(nonIndexedSimVars);
      for (const [topic, simvar2] of [...gearIndexedSimVars]) {
        simvars.set(`${topic}`, {
          name: `${simvar2.name}:0`,
          type: simvar2.type,
          map: simvar2.map
        });
      }
      gearCount = Math.max(gearCount, 1);
      for (let i = 0; i < gearCount; i++) {
        for (const [topic, simvar2] of gearIndexedSimVars) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  var HydraulicsPublisher = class extends SimVarPublisher {
    /**
     * Create an HydraulicsPublisher.
     * @param bus The EventBus to publish to.
     * @param pumpsCount The number of hydraulic pumps.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pumpsCount, pacer) {
      const hydIndexedSimVars = [
        ["hyd_pump_switch_state", { name: "HYDRAULIC SWITCH", type: SimVarValueType.Bool }],
        ["hyd_pressure", { name: "HYDRAULIC PRESSURE", type: SimVarValueType.PSI }],
        ["hyd_reservoir_perc", { name: "HYDRAULIC RESERVOIR PERCENT", type: SimVarValueType.Percent }]
      ];
      const simvars = /* @__PURE__ */ new Map();
      for (const [topic, simvar2] of [...hydIndexedSimVars]) {
        for (let i = 1; i <= pumpsCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  var EventBus = class {
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync = false, shouldResync = true) {
      this._topicSubsMap = /* @__PURE__ */ new Map();
      this._wildcardSubs = new Array();
      this._notifyDepthMap = /* @__PURE__ */ new Map();
      this._wildcardNotifyDepth = 0;
      this._eventCache = /* @__PURE__ */ new Map();
      this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
      this._busId = Math.floor(Math.random() * 2147483647);
      useAlternativeEventSync = typeof RegisterGenericDataListener === "undefined";
      const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
      this._busSync = new syncFunc(this.pub.bind(this), this._busId);
      if (shouldResync === true) {
        this.syncEvent("event_bus", "resync_request", false);
        this.on("event_bus", (data) => {
          if (data == "resync_request") {
            this.resyncEvents();
          }
        });
      }
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
      let subs = this._topicSubsMap.get(topic);
      if (subs === void 0) {
        this._topicSubsMap.set(topic, subs = []);
        this.pub("event_bus_topic_first_sub", topic, false, false);
      }
      const initialNotifyFunc = (sub2) => {
        const lastState = this._eventCache.get(topic);
        if (lastState !== void 0) {
          sub2.handler(lastState.data);
        }
      };
      const onDestroyFunc = (sub2) => {
        var _a;
        if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
          const subsToSplice = this._topicSubsMap.get(topic);
          if (subsToSplice) {
            subsToSplice.splice(subsToSplice.indexOf(sub2), 1);
          }
        }
      };
      const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
      subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
      const handlers = this._topicSubsMap.get(topic);
      const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
      const sub = new HandlerSubscription(handler, void 0, this.onWildcardSubDestroyedFunc);
      this._wildcardSubs.push(sub);
      return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
      const toDestroy = this._wildcardSubs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
      var _a;
      if (isCached) {
        this._eventCache.set(topic, { data, synced: sync });
      }
      const subs = this._topicSubsMap.get(topic);
      if (subs !== void 0) {
        let needCleanUpSubs2 = false;
        const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
        this._notifyDepthMap.set(topic, notifyDepth + 1);
        const len = subs.length;
        for (let i = 0; i < len; i++) {
          try {
            const sub = subs[i];
            if (sub.isAlive && !sub.isPaused) {
              sub.handler(data);
            }
            needCleanUpSubs2 || (needCleanUpSubs2 = !sub.isAlive);
          } catch (error) {
            console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
            if (error instanceof Error) {
              console.error(error.stack);
            }
          }
        }
        this._notifyDepthMap.set(topic, notifyDepth);
        if (needCleanUpSubs2 && notifyDepth === 0) {
          const filteredSubs = subs.filter((sub) => sub.isAlive);
          this._topicSubsMap.set(topic, filteredSubs);
        }
      }
      if (sync) {
        this.syncEvent(topic, data, isCached);
      }
      let needCleanUpSubs = false;
      this._wildcardNotifyDepth++;
      const wcLen = this._wildcardSubs.length;
      for (let i = 0; i < wcLen; i++) {
        const sub = this._wildcardSubs[i];
        if (sub.isAlive && !sub.isPaused) {
          sub.handler(topic, data);
        }
        needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
      }
      this._wildcardNotifyDepth--;
      if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
        this._wildcardSubs = this._wildcardSubs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
      if (this._wildcardNotifyDepth === 0) {
        this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
      }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
      for (const [topic, event] of this._eventCache) {
        if (event.synced) {
          this.syncEvent(topic, event.data, true);
        }
      }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
      this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
      return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
      return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic) {
      var _a, _b;
      return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn) {
      this._topicSubsMap.forEach((subs, topic) => {
        subs.length > 0 && fn(topic, subs.length);
      });
    }
  };
  var EventBusSyncBase = class {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
      this.isPaused = false;
      this.lastEventSynced = -1;
      this.dataPackageQueue = [];
      this.recvEventCb = recvEventCb;
      this.busId = busId;
      this.hookReceiveEvent();
      const sendFn = () => {
        if (!this.isPaused && this.dataPackageQueue.length > 0) {
          const syncDataPackage = {
            busId: this.busId,
            packagedId: Math.floor(Math.random() * 1e9),
            data: this.dataPackageQueue
          };
          if (this.executeSync(syncDataPackage)) {
            this.dataPackageQueue.length = 0;
          } else {
            console.warn("Failed to send sync data package");
          }
        }
        requestAnimationFrame(sendFn);
      };
      requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
      if (this.busId !== syncData.busId) {
        if (this.lastEventSynced !== syncData.packagedId) {
          this.lastEventSynced = syncData.packagedId;
          syncData.data.forEach((data) => {
            try {
              this.recvEventCb(data.topic, data.data !== void 0 ? data.data : void 0, false, data.isCached);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          });
        }
      }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
      const dataObj = data;
      const dataPackage = {
        topic,
        data: dataObj,
        isCached
      };
      this.dataPackageQueue.push(dataPackage);
    }
  };
  var EventBusCoherentSync = class extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
      try {
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
      this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, void 0, true);
      this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
        try {
          const evt = JSON.parse(e);
          this.processEventsReceived(evt);
        } catch (error) {
          console.error(error);
        }
      });
    }
  };
  EventBusCoherentSync.EB_KEY = "eb.evt";
  EventBusCoherentSync.EB_LISTENER_KEY = "JS_LISTENER_SIMVARS";
  var EventBusFlowEventSync = class extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
      try {
        LaunchFlowEvent("ON_MOUSERECT_HTMLEVENT", EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
      Coherent.on("OnInteractionEvent", (target, args) => {
        if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
          return;
        }
        this.processEventsReceived(JSON.parse(args[2]));
      });
    }
  };
  EventBusFlowEventSync.EB_LISTENER_KEY = "EB_EVENTS";
  var EventBusListenerSync = class extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
      try {
        this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
        return true;
      } catch (error) {
        return false;
      }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
      this.isPaused = true;
      this.listener = RegisterGenericDataListener(() => {
        this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
          try {
            this.processEventsReceived(data);
          } catch (error) {
            console.error(error);
          }
        });
        this.isPaused = false;
      });
    }
  };
  EventBusListenerSync.EB_KEY = "wt.eb.evt";
  EventBusListenerSync.EB_LISTENER_KEY = "JS_LISTENER_GENERICDATA";
  var IntervalPacer = class {
    /**
     * Create an IntervalPacer.
     * @param msec Time to wait between publishs in ms
     */
    constructor(msec) {
      this.lastPublished = /* @__PURE__ */ new Map();
      this.interval = msec;
    }
    /**
     * Determine whether the data can be published based on the time since its
     * prior publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canPublish(topic, data) {
      const prior = this.lastPublished.get(topic);
      const now = Date.now();
      if (prior && now - prior < this.interval) {
        return false;
      }
      this.lastPublished.set(topic, now);
      return true;
    }
  };
  var DeltaPacer = class {
    /**
     * Create a DeltaPacer.
     * @param delta The difference required for publishing to be allowed.
     */
    constructor(delta) {
      this.lastPublished = /* @__PURE__ */ new Map();
      this.delta = delta;
    }
    /**
     * Determine whether the data can be published based on its delta from the
     * pror publish.
     * @param topic The topic data would be sent on.
     * @param data The data which would be sent.
     * @returns A bool indicating if the data should be published.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canPublish(topic, data) {
      const prior = this.lastPublished.get(topic);
      if (prior && Math.abs(data - prior) < this.delta) {
        return false;
      }
      this.lastPublished.set(topic, data);
      return true;
    }
  };
  var EventRepublisher = class {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.bus = bus;
      this.metaEvents = this.bus.getSubscriber();
      this.sourceSubscriber = this.bus.getSubscriber();
      this.publisher = this.bus.getPublisher();
      this.republishes = /* @__PURE__ */ new Map();
      this.republishId = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    startRepublish(sourceTopic, targetTopic, sync, cache, map) {
      const id = this.republishId++;
      if (sync || this.bus.getTopicSubscriberCount(targetTopic) > 0) {
        this.registerRepublish(id, sourceTopic, targetTopic, sync, cache, map);
      } else {
        const topicSub = this.metaEvents.on("event_bus_topic_first_sub").handle((topic) => {
          if (topic === targetTopic) {
            topicSub.destroy();
            this.registerRepublish(id, sourceTopic, targetTopic, sync, cache, map);
          }
        }, true);
        this.republishes.set(id, topicSub);
        topicSub.resume();
      }
      return id;
    }
    /**
     * Stops a republish handled by this publisher.
     * @param id The unique ID associated with the republish to stop.
     * @returns Whether the requested republish was stopped.
     */
    stopRepublish(id) {
      const republish = this.republishes.get(id);
      if (republish === void 0) {
        return false;
      }
      this.republishes.delete(id);
      republish.destroy();
      return true;
    }
    /**
     * Clears all republishes from this publisher.
     */
    clearRepublishes() {
      for (const republish of this.republishes.values()) {
        republish.destroy();
      }
      this.republishes.clear();
    }
    /**
     * Registers a republish.
     * @param id A unique ID to associate with the republish.
     * @param sourceTopic The source topic.
     * @param targetTopic The target topic.
     * @param sync Whether the target topic should be synced across instruments.
     * @param cache Whether the target topic data should be cached.
     * @param map A mapping function to use to transform the source data.
     */
    registerRepublish(id, sourceTopic, targetTopic, sync, cache, map) {
      const handler = map === void 0 ? (sourceData) => {
        this.publisher.pub(targetTopic, sourceData, sync, cache);
      } : (sourceData) => {
        this.publisher.pub(targetTopic, map(sourceData), sync, cache);
      };
      const republish = this.sourceSubscriber.on(sourceTopic).handle(handler, true);
      this.republishes.set(id, republish);
      republish.resume(true);
    }
  };
  var ConsumerValue = class {
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    constructor(consumer, initialValue) {
      this.consumerHandler = (v) => {
        this.value = v;
      };
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialValue;
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused() {
      return this._isPaused;
    }
    /**
     * Gets the current value.
     * @returns The current value.
     */
    get() {
      return this.value;
    }
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     * @returns This object, after it has been resumed.
     */
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
      var _a;
      this.isDestroyed = true;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create(consumer, initialValue) {
      return new ConsumerValue(consumer, initialValue);
    }
  };
  var HEventPublisher = class extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
      this.publish("hEvent", hEvent, sync, false);
    }
  };
  var ConsumerSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
      super();
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.consumerHandler = this.onEventConsumed.bind(this);
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialVal;
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
      return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
      return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
      if (!this.equalityFunc(this.value, value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
      var _a;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.isDestroyed = true;
    }
  };
  var StallWarningPublisher = class extends BasePublisher {
    /**
     * Creates an instance of the StallWarningPublisher. Requires the `aoa` (if not provided) and `on_ground` events from `AdcEvents``.
     * @param bus The event bus to use with this instance.
     * @param aoaThreshold The AoA stall warning threshold, where 1 is 100% of stall AoA.
     * @param debounceMs The amount of time, in milliseconds, to debounce the stall warning. Defaults to 500 ms.
     * @param aoa An optional subscribable that provides the AoA value, in degrees.
     */
    constructor(bus, aoaThreshold, debounceMs = 500, aoa) {
      super(bus);
      this.aoaThreshold = aoaThreshold;
      this.debounceMs = debounceMs;
      this.stallAoA = SimVar.GetSimVarValue("STALL ALPHA", SimVarValueType.Degree);
      this.stallWarningOn = false;
      this.previousTime = -1;
      this.aoa = aoa !== null && aoa !== void 0 ? aoa : ConsumerSubject.create(bus.getSubscriber().on("aoa"), 0);
      this.onGround = ConsumerValue.create(bus.getSubscriber().on("on_ground"), true);
      this.debounceTimeRemaining = debounceMs;
    }
    /** @inheritdoc */
    onUpdate() {
      if (this.isPublishing()) {
        const time = Date.now();
        if (this.previousTime === -1) {
          this.previousTime = time;
        }
        const deltaTime = time - this.previousTime;
        if (this.aoa.get() >= this.aoaThreshold * this.stallAoA && !this.onGround.get()) {
          this.debounceTimeRemaining = Math.max(this.debounceTimeRemaining - deltaTime, 0);
          if (this.debounceTimeRemaining === 0) {
            this.setStallWarningOn(true);
          } else {
            this.setStallWarningOn(false);
          }
        } else {
          this.debounceTimeRemaining = this.debounceMs;
          this.setStallWarningOn(false);
        }
        this.previousTime = time;
      } else {
        this.previousTime = -1;
      }
    }
    /**
     * Sets whether the stall warning is on or not.
     * @param isOn Whether the stall warning is on.
     */
    setStallWarningOn(isOn) {
      if (this.stallWarningOn !== isOn) {
        this.publish("stall_warning_on", isOn, true, true);
        this.stallWarningOn = isOn;
      }
    }
  };
  var ControlPublisher = class extends BasePublisher {
    /**
     * Create a ControlPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer = void 0) {
      super(bus, pacer);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
    /** debug logger */
    startPublish() {
      super.startPublish();
    }
  };
  var CompositeLogicXMLValueType;
  (function(CompositeLogicXMLValueType2) {
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Any"] = 0] = "Any";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Number"] = 1] = "Number";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["String"] = 2] = "String";
  })(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
  var CompositeLogicXMLHost = class {
    /**
     * Ctor
     * @param startPaused True to start paused.
     */
    constructor(startPaused = false) {
      this.anyHandlers = new Array();
      this.stringHandlers = new Array();
      this.numberHandlers = new Array();
      this.anyResultCache = new Array();
      this.stringResultCache = new Array();
      this.numberResultCache = new Array();
      this.context = new LogicXMLContext();
      this.isPaused = false;
      this.isPaused = startPaused;
    }
    /**
     * Set to pause the logic update loop.
     * @param isPaused True to pause, false to resume.
     */
    setIsPaused(isPaused) {
      this.isPaused = isPaused;
    }
    /**
     * Add a new logic element to calcluate a number or a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values of either type.
     * @returns The current value of the logic.
     */
    addLogic(logic, handler) {
      this.anyHandlers.push({ logic, handler });
      return logic.getValue(this.context);
    }
    /**
     * Add a new logic element to calcluate a number.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as numbers.
     * @param precision An optional precision to require for updates to be sent.
     * @param smoothFactor An optional linear smoothing factor to apply to the value when updating.
     * @returns The current value of the logic.
     */
    addLogicAsNumber(logic, handler, precision, smoothFactor) {
      this.numberHandlers.push({ logic, handler, precision, smoothFactor });
      return logic.getValueAsNumber(this.context);
    }
    /**
     * Add a new logic element to calcluate a string.
     * @param logic A CompositeLogicXMLElement.
     * @param handler A callback hander to take new values as strings.
     * @returns The current value of the logic.
     */
    addLogicAsString(logic, handler) {
      this.stringHandlers.push({ logic, handler });
      return logic.getValueAsString(this.context);
    }
    /**
     * Add a function to the logic context.
     * @param funcSpec The XMLFunction configuration.
     * @returns The function's current value.
     */
    addFunction(funcSpec) {
      const func = new LogicXMLFunction();
      func.name = funcSpec.name;
      func.callback = funcSpec.logic;
      this.context.addFunction(func);
      return funcSpec.logic.getValue(this.context);
    }
    /**
     * Update every logic element and publish updates.
     * @param deltaTime The time since the last update, in ms.
     */
    update(deltaTime) {
      if (!this.isPaused) {
        for (let i = 0; i < this.anyHandlers.length; i++) {
          const newVal = this.anyHandlers[i].logic.getValue(this.context);
          if (newVal !== this.anyResultCache[i]) {
            this.anyResultCache[i] = newVal;
            this.anyHandlers[i].handler(newVal);
          }
        }
        for (let i = 0; i < this.stringHandlers.length; i++) {
          const newVal = this.stringHandlers[i].logic.getValueAsString(this.context);
          if (newVal !== this.stringResultCache[i]) {
            this.stringResultCache[i] = newVal;
            this.stringHandlers[i].handler(newVal);
          }
        }
        for (let i = 0; i < this.numberHandlers.length; i++) {
          let newVal = this.numberHandlers[i].logic.getValueAsNumber(this.context);
          let precision = this.numberHandlers[i].precision;
          if (precision !== void 0) {
            precision = Math.pow(10, precision);
            newVal = Math.round(newVal * precision) / precision;
          }
          if (this.numberHandlers[i].smoothFactor !== void 0 && this.numberHandlers[i].smoothFactor !== 0) {
            newVal = Utils.SmoothLinear(this.numberResultCache[i], newVal, this.numberHandlers[i].smoothFactor || 0, deltaTime);
          }
          if (newVal !== this.numberResultCache[i]) {
            this.numberResultCache[i] = newVal;
            this.numberHandlers[i].handler(newVal);
          }
        }
        this.context.update();
      }
    }
  };
  var DataStore;
  (function(DataStore2) {
    function set(key, value) {
      SetStoredData(key, JSON.stringify(value));
    }
    DataStore2.set = set;
    function get(key) {
      try {
        const string = GetStoredData(key);
        return JSON.parse(string);
      } catch (e) {
        return void 0;
      }
    }
    DataStore2.get = get;
    function remove(key) {
      DeleteStoredData(key);
    }
    DataStore2.remove = remove;
  })(DataStore || (DataStore = {}));
  var GameStateProvider = class {
    /**
     * Constructor.
     */
    constructor() {
      this.gameState = Subject.create(void 0);
      window.document.addEventListener("OnVCockpitPanelAttributesChanged", this.onAttributesChanged.bind(this));
      this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
      var _a;
      if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute("gamestate")) {
        const attribute = window.parent.document.body.getAttribute("gamestate");
        if (attribute !== null) {
          this.gameState.set(GameState[attribute]);
          return;
        }
      }
      this.gameState.set(void 0);
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
      var _a;
      return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : GameStateProvider.INSTANCE = new GameStateProvider()).gameState;
    }
  };
  var KeyEventManager = class {
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    constructor(keyListener, bus) {
      this.keyListener = keyListener;
      this.bus = bus;
      Coherent.on("keyIntercepted", this.onKeyIntercepted.bind(this));
    }
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param value1 The second data value of the key event.
     * @param value0 The first data value of the key event.
     * @param value2 The third data value of the key event.
     */
    onKeyIntercepted(key, value1, value0, value2) {
      if (value0 !== void 0 && value0 >= 2147483648) {
        value0 -= 4294967296;
      }
      this.bus.pub("key_intercept", { key, value0, value1, value2 }, false, false);
    }
    /**
     * Triggers a key event.
     * @param key The key to trigger.
     * @param bypass Whether the event should bypass intercepts.
     * @param value0 The first data value of the key event. Defaults to `0`.
     * @param value1 The second data value of the key event. Defaults to `0`.
     * @param value2 The third data value of the key event. Defaults to `0`.
     * @returns A Promise which is fulfilled after the key event has been triggered.
     */
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
      return Coherent.call("TRIGGER_KEY_EVENT", key, bypass, value0, value1, value2);
    }
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key, passThrough) {
      Coherent.call("INTERCEPT_KEY_EVENT", key, passThrough ? 0 : 1);
    }
    /**
     * Gets an instance of KeyEventManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyEventManager.
     */
    static getManager(bus) {
      if (KeyEventManager.INSTANCE) {
        return Promise.resolve(KeyEventManager.INSTANCE);
      }
      if (!KeyEventManager.isCreatingInstance) {
        KeyEventManager.createInstance(bus);
      }
      return new Promise((resolve) => {
        KeyEventManager.pendingPromiseResolves.push(resolve);
      });
    }
    /**
     * Creates an instance of KeyEventManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    static async createInstance(bus) {
      KeyEventManager.isCreatingInstance = true;
      KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
      KeyEventManager.isCreatingInstance = false;
      for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
        KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
      }
    }
    /**
     * Creates an instance of KeyEventManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyEventManager after it has been created.
     */
    static create(bus) {
      return new Promise((resolve, reject) => {
        const gameState = GameStateProvider.get();
        const sub = gameState.sub((state) => {
          if (window["IsDestroying"]) {
            sub.destroy();
            reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            sub.destroy();
            const keyListener = RegisterViewListener("JS_LISTENER_KEYEVENT", () => {
              if (window["IsDestroying"]) {
                reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
                return;
              }
              resolve(new KeyEventManager(keyListener, bus));
            });
          }
        }, false, true);
        sub.resume(true);
      });
    }
  };
  KeyEventManager.isCreatingInstance = false;
  KeyEventManager.pendingPromiseResolves = [];
  var FacilityFrequencyType;
  (function(FacilityFrequencyType2) {
    FacilityFrequencyType2[FacilityFrequencyType2["None"] = 0] = "None";
    FacilityFrequencyType2[FacilityFrequencyType2["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType2[FacilityFrequencyType2["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType2[FacilityFrequencyType2["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType2[FacilityFrequencyType2["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType2[FacilityFrequencyType2["Ground"] = 5] = "Ground";
    FacilityFrequencyType2[FacilityFrequencyType2["Tower"] = 6] = "Tower";
    FacilityFrequencyType2[FacilityFrequencyType2["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType2[FacilityFrequencyType2["Approach"] = 8] = "Approach";
    FacilityFrequencyType2[FacilityFrequencyType2["Departure"] = 9] = "Departure";
    FacilityFrequencyType2[FacilityFrequencyType2["Center"] = 10] = "Center";
    FacilityFrequencyType2[FacilityFrequencyType2["FSS"] = 11] = "FSS";
    FacilityFrequencyType2[FacilityFrequencyType2["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType2[FacilityFrequencyType2["ASOS"] = 13] = "ASOS";
    FacilityFrequencyType2[FacilityFrequencyType2["CPT"] = 14] = "CPT";
    FacilityFrequencyType2[FacilityFrequencyType2["GCO"] = 15] = "GCO";
  })(FacilityFrequencyType || (FacilityFrequencyType = {}));
  var AdditionalApproachType;
  (function(AdditionalApproachType2) {
    AdditionalApproachType2[AdditionalApproachType2["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
  })(AdditionalApproachType || (AdditionalApproachType = {}));
  var FixTypeFlags;
  (function(FixTypeFlags2) {
    FixTypeFlags2[FixTypeFlags2["None"] = 0] = "None";
    FixTypeFlags2[FixTypeFlags2["IAF"] = 1] = "IAF";
    FixTypeFlags2[FixTypeFlags2["IF"] = 2] = "IF";
    FixTypeFlags2[FixTypeFlags2["MAP"] = 4] = "MAP";
    FixTypeFlags2[FixTypeFlags2["FAF"] = 8] = "FAF";
    FixTypeFlags2[FixTypeFlags2["MAHP"] = 16] = "MAHP";
  })(FixTypeFlags || (FixTypeFlags = {}));
  var RnavTypeFlags;
  (function(RnavTypeFlags2) {
    RnavTypeFlags2[RnavTypeFlags2["None"] = 0] = "None";
    RnavTypeFlags2[RnavTypeFlags2["LNAV"] = 1] = "LNAV";
    RnavTypeFlags2[RnavTypeFlags2["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags2[RnavTypeFlags2["LP"] = 4] = "LP";
    RnavTypeFlags2[RnavTypeFlags2["LPV"] = 8] = "LPV";
  })(RnavTypeFlags || (RnavTypeFlags = {}));
  var AirportClass;
  (function(AirportClass2) {
    AirportClass2[AirportClass2["None"] = 0] = "None";
    AirportClass2[AirportClass2["HardSurface"] = 1] = "HardSurface";
    AirportClass2[AirportClass2["SoftSurface"] = 2] = "SoftSurface";
    AirportClass2[AirportClass2["AllWater"] = 3] = "AllWater";
    AirportClass2[AirportClass2["HeliportOnly"] = 4] = "HeliportOnly";
    AirportClass2[AirportClass2["Private"] = 5] = "Private";
  })(AirportClass || (AirportClass = {}));
  var AirportClassMask;
  (function(AirportClassMask2) {
    AirportClassMask2[AirportClassMask2["None"] = 0] = "None";
    AirportClassMask2[AirportClassMask2["HardSurface"] = 2] = "HardSurface";
    AirportClassMask2[AirportClassMask2["SoftSurface"] = 4] = "SoftSurface";
    AirportClassMask2[AirportClassMask2["AllWater"] = 8] = "AllWater";
    AirportClassMask2[AirportClassMask2["HeliportOnly"] = 16] = "HeliportOnly";
    AirportClassMask2[AirportClassMask2["Private"] = 32] = "Private";
  })(AirportClassMask || (AirportClassMask = {}));
  var IntersectionType;
  (function(IntersectionType2) {
    IntersectionType2[IntersectionType2["None"] = 0] = "None";
    IntersectionType2[IntersectionType2["Named"] = 1] = "Named";
    IntersectionType2[IntersectionType2["Unnamed"] = 2] = "Unnamed";
    IntersectionType2[IntersectionType2["Vor"] = 3] = "Vor";
    IntersectionType2[IntersectionType2["NDB"] = 4] = "NDB";
    IntersectionType2[IntersectionType2["Offroute"] = 5] = "Offroute";
    IntersectionType2[IntersectionType2["IAF"] = 6] = "IAF";
    IntersectionType2[IntersectionType2["FAF"] = 7] = "FAF";
    IntersectionType2[IntersectionType2["RNAV"] = 8] = "RNAV";
    IntersectionType2[IntersectionType2["VFR"] = 9] = "VFR";
  })(IntersectionType || (IntersectionType = {}));
  var UserFacilityType;
  (function(UserFacilityType2) {
    UserFacilityType2[UserFacilityType2["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType2[UserFacilityType2["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType2[UserFacilityType2["LAT_LONG"] = 2] = "LAT_LONG";
  })(UserFacilityType || (UserFacilityType = {}));
  var LegType;
  (function(LegType2) {
    LegType2[LegType2["Unknown"] = 0] = "Unknown";
    LegType2[LegType2["AF"] = 1] = "AF";
    LegType2[LegType2["CA"] = 2] = "CA";
    LegType2[LegType2["CD"] = 3] = "CD";
    LegType2[LegType2["CF"] = 4] = "CF";
    LegType2[LegType2["CI"] = 5] = "CI";
    LegType2[LegType2["CR"] = 6] = "CR";
    LegType2[LegType2["DF"] = 7] = "DF";
    LegType2[LegType2["FA"] = 8] = "FA";
    LegType2[LegType2["FC"] = 9] = "FC";
    LegType2[LegType2["FD"] = 10] = "FD";
    LegType2[LegType2["FM"] = 11] = "FM";
    LegType2[LegType2["HA"] = 12] = "HA";
    LegType2[LegType2["HF"] = 13] = "HF";
    LegType2[LegType2["HM"] = 14] = "HM";
    LegType2[LegType2["IF"] = 15] = "IF";
    LegType2[LegType2["PI"] = 16] = "PI";
    LegType2[LegType2["RF"] = 17] = "RF";
    LegType2[LegType2["TF"] = 18] = "TF";
    LegType2[LegType2["VA"] = 19] = "VA";
    LegType2[LegType2["VD"] = 20] = "VD";
    LegType2[LegType2["VI"] = 21] = "VI";
    LegType2[LegType2["VM"] = 22] = "VM";
    LegType2[LegType2["VR"] = 23] = "VR";
    LegType2[LegType2["Discontinuity"] = 99] = "Discontinuity";
    LegType2[LegType2["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
  })(LegType || (LegType = {}));
  var AltitudeRestrictionType;
  (function(AltitudeRestrictionType2) {
    AltitudeRestrictionType2[AltitudeRestrictionType2["Unused"] = 0] = "Unused";
    AltitudeRestrictionType2[AltitudeRestrictionType2["At"] = 1] = "At";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType2[AltitudeRestrictionType2["Between"] = 4] = "Between";
  })(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
  var LegTurnDirection;
  (function(LegTurnDirection2) {
    LegTurnDirection2[LegTurnDirection2["None"] = 0] = "None";
    LegTurnDirection2[LegTurnDirection2["Left"] = 1] = "Left";
    LegTurnDirection2[LegTurnDirection2["Right"] = 2] = "Right";
    LegTurnDirection2[LegTurnDirection2["Either"] = 3] = "Either";
  })(LegTurnDirection || (LegTurnDirection = {}));
  var AirwayType;
  (function(AirwayType2) {
    AirwayType2[AirwayType2["None"] = 0] = "None";
    AirwayType2[AirwayType2["Victor"] = 1] = "Victor";
    AirwayType2[AirwayType2["Jet"] = 2] = "Jet";
    AirwayType2[AirwayType2["Both"] = 3] = "Both";
  })(AirwayType || (AirwayType = {}));
  var NdbType;
  (function(NdbType2) {
    NdbType2[NdbType2["CompassPoint"] = 0] = "CompassPoint";
    NdbType2[NdbType2["MH"] = 1] = "MH";
    NdbType2[NdbType2["H"] = 2] = "H";
    NdbType2[NdbType2["HH"] = 3] = "HH";
  })(NdbType || (NdbType = {}));
  var VorType;
  (function(VorType2) {
    VorType2[VorType2["Unknown"] = 0] = "Unknown";
    VorType2[VorType2["VOR"] = 1] = "VOR";
    VorType2[VorType2["VORDME"] = 2] = "VORDME";
    VorType2[VorType2["DME"] = 3] = "DME";
    VorType2[VorType2["TACAN"] = 4] = "TACAN";
    VorType2[VorType2["VORTAC"] = 5] = "VORTAC";
    VorType2[VorType2["ILS"] = 6] = "ILS";
    VorType2[VorType2["VOT"] = 7] = "VOT";
  })(VorType || (VorType = {}));
  var RunwaySurfaceType;
  (function(RunwaySurfaceType2) {
    RunwaySurfaceType2[RunwaySurfaceType2["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType2[RunwaySurfaceType2["Grass"] = 1] = "Grass";
    RunwaySurfaceType2[RunwaySurfaceType2["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType2[RunwaySurfaceType2["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType2[RunwaySurfaceType2["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType2[RunwaySurfaceType2["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType2[RunwaySurfaceType2["Snow"] = 8] = "Snow";
    RunwaySurfaceType2[RunwaySurfaceType2["Ice"] = 9] = "Ice";
    RunwaySurfaceType2[RunwaySurfaceType2["Urban"] = 10] = "Urban";
    RunwaySurfaceType2[RunwaySurfaceType2["Forest"] = 11] = "Forest";
    RunwaySurfaceType2[RunwaySurfaceType2["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType2[RunwaySurfaceType2["Coral"] = 13] = "Coral";
    RunwaySurfaceType2[RunwaySurfaceType2["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType2[RunwaySurfaceType2["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType2[RunwaySurfaceType2["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType2[RunwaySurfaceType2["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType2[RunwaySurfaceType2["Brick"] = 18] = "Brick";
    RunwaySurfaceType2[RunwaySurfaceType2["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType2[RunwaySurfaceType2["Planks"] = 20] = "Planks";
    RunwaySurfaceType2[RunwaySurfaceType2["Sand"] = 21] = "Sand";
    RunwaySurfaceType2[RunwaySurfaceType2["Shale"] = 22] = "Shale";
    RunwaySurfaceType2[RunwaySurfaceType2["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType2[RunwaySurfaceType2["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    RunwaySurfaceType2[RunwaySurfaceType2["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType2[RunwaySurfaceType2["Water"] = 27] = "Water";
    RunwaySurfaceType2[RunwaySurfaceType2["Pond"] = 28] = "Pond";
    RunwaySurfaceType2[RunwaySurfaceType2["Lake"] = 29] = "Lake";
    RunwaySurfaceType2[RunwaySurfaceType2["River"] = 30] = "River";
    RunwaySurfaceType2[RunwaySurfaceType2["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType2[RunwaySurfaceType2["Paint"] = 32] = "Paint";
  })(RunwaySurfaceType || (RunwaySurfaceType = {}));
  var RunwayLightingType;
  (function(RunwayLightingType2) {
    RunwayLightingType2[RunwayLightingType2["Unknown"] = 0] = "Unknown";
    RunwayLightingType2[RunwayLightingType2["None"] = 1] = "None";
    RunwayLightingType2[RunwayLightingType2["PartTime"] = 2] = "PartTime";
    RunwayLightingType2[RunwayLightingType2["FullTime"] = 3] = "FullTime";
    RunwayLightingType2[RunwayLightingType2["Frequency"] = 4] = "Frequency";
  })(RunwayLightingType || (RunwayLightingType = {}));
  var AirportPrivateType;
  (function(AirportPrivateType2) {
    AirportPrivateType2[AirportPrivateType2["Uknown"] = 0] = "Uknown";
    AirportPrivateType2[AirportPrivateType2["Public"] = 1] = "Public";
    AirportPrivateType2[AirportPrivateType2["Military"] = 2] = "Military";
    AirportPrivateType2[AirportPrivateType2["Private"] = 3] = "Private";
  })(AirportPrivateType || (AirportPrivateType = {}));
  var GpsBoolean;
  (function(GpsBoolean2) {
    GpsBoolean2[GpsBoolean2["Unknown"] = 0] = "Unknown";
    GpsBoolean2[GpsBoolean2["No"] = 1] = "No";
    GpsBoolean2[GpsBoolean2["Yes"] = 2] = "Yes";
  })(GpsBoolean || (GpsBoolean = {}));
  var VorClass;
  (function(VorClass2) {
    VorClass2[VorClass2["Unknown"] = 0] = "Unknown";
    VorClass2[VorClass2["Terminal"] = 1] = "Terminal";
    VorClass2[VorClass2["LowAlt"] = 2] = "LowAlt";
    VorClass2[VorClass2["HighAlt"] = 3] = "HighAlt";
    VorClass2[VorClass2["ILS"] = 4] = "ILS";
    VorClass2[VorClass2["VOT"] = 5] = "VOT";
  })(VorClass || (VorClass = {}));
  var FacilityType;
  (function(FacilityType2) {
    FacilityType2["Airport"] = "LOAD_AIRPORT";
    FacilityType2["Intersection"] = "LOAD_INTERSECTION";
    FacilityType2["VOR"] = "LOAD_VOR";
    FacilityType2["NDB"] = "LOAD_NDB";
    FacilityType2["USR"] = "USR";
    FacilityType2["RWY"] = "RWY";
    FacilityType2["VIS"] = "VIS";
  })(FacilityType || (FacilityType = {}));
  var FacilitySearchType;
  (function(FacilitySearchType2) {
    FacilitySearchType2[FacilitySearchType2["All"] = 0] = "All";
    FacilitySearchType2[FacilitySearchType2["Airport"] = 1] = "Airport";
    FacilitySearchType2[FacilitySearchType2["Intersection"] = 2] = "Intersection";
    FacilitySearchType2[FacilitySearchType2["Vor"] = 3] = "Vor";
    FacilitySearchType2[FacilitySearchType2["Ndb"] = 4] = "Ndb";
    FacilitySearchType2[FacilitySearchType2["Boundary"] = 5] = "Boundary";
    FacilitySearchType2[FacilitySearchType2["User"] = 6] = "User";
    FacilitySearchType2[FacilitySearchType2["Visual"] = 7] = "Visual";
    FacilitySearchType2[FacilitySearchType2["AllExceptVisual"] = 8] = "AllExceptVisual";
  })(FacilitySearchType || (FacilitySearchType = {}));
  var BoundaryType;
  (function(BoundaryType2) {
    BoundaryType2[BoundaryType2["None"] = 0] = "None";
    BoundaryType2[BoundaryType2["Center"] = 1] = "Center";
    BoundaryType2[BoundaryType2["ClassA"] = 2] = "ClassA";
    BoundaryType2[BoundaryType2["ClassB"] = 3] = "ClassB";
    BoundaryType2[BoundaryType2["ClassC"] = 4] = "ClassC";
    BoundaryType2[BoundaryType2["ClassD"] = 5] = "ClassD";
    BoundaryType2[BoundaryType2["ClassE"] = 6] = "ClassE";
    BoundaryType2[BoundaryType2["ClassF"] = 7] = "ClassF";
    BoundaryType2[BoundaryType2["ClassG"] = 8] = "ClassG";
    BoundaryType2[BoundaryType2["Tower"] = 9] = "Tower";
    BoundaryType2[BoundaryType2["Clearance"] = 10] = "Clearance";
    BoundaryType2[BoundaryType2["Ground"] = 11] = "Ground";
    BoundaryType2[BoundaryType2["Departure"] = 12] = "Departure";
    BoundaryType2[BoundaryType2["Approach"] = 13] = "Approach";
    BoundaryType2[BoundaryType2["MOA"] = 14] = "MOA";
    BoundaryType2[BoundaryType2["Restricted"] = 15] = "Restricted";
    BoundaryType2[BoundaryType2["Prohibited"] = 16] = "Prohibited";
    BoundaryType2[BoundaryType2["Warning"] = 17] = "Warning";
    BoundaryType2[BoundaryType2["Alert"] = 18] = "Alert";
    BoundaryType2[BoundaryType2["Danger"] = 19] = "Danger";
    BoundaryType2[BoundaryType2["NationalPark"] = 20] = "NationalPark";
    BoundaryType2[BoundaryType2["ModeC"] = 21] = "ModeC";
    BoundaryType2[BoundaryType2["Radar"] = 22] = "Radar";
    BoundaryType2[BoundaryType2["Training"] = 23] = "Training";
  })(BoundaryType || (BoundaryType = {}));
  var BoundaryAltitudeType;
  (function(BoundaryAltitudeType2) {
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType2[BoundaryAltitudeType2["MSL"] = 1] = "MSL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["AGL"] = 2] = "AGL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unlimited"] = 3] = "Unlimited";
  })(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
  var BoundaryVectorType;
  (function(BoundaryVectorType2) {
    BoundaryVectorType2[BoundaryVectorType2["None"] = 0] = "None";
    BoundaryVectorType2[BoundaryVectorType2["Start"] = 1] = "Start";
    BoundaryVectorType2[BoundaryVectorType2["Line"] = 2] = "Line";
    BoundaryVectorType2[BoundaryVectorType2["Origin"] = 3] = "Origin";
    BoundaryVectorType2[BoundaryVectorType2["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType2[BoundaryVectorType2["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType2[BoundaryVectorType2["Circle"] = 6] = "Circle";
  })(BoundaryVectorType || (BoundaryVectorType = {}));
  var MetarWindSpeedUnits;
  (function(MetarWindSpeedUnits2) {
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["KilometerPerHour"] = 2] = "KilometerPerHour";
  })(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
  var MetarVisibilityUnits;
  (function(MetarVisibilityUnits2) {
    MetarVisibilityUnits2[MetarVisibilityUnits2["Meter"] = 0] = "Meter";
    MetarVisibilityUnits2[MetarVisibilityUnits2["StatuteMile"] = 1] = "StatuteMile";
  })(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
  var MetarCloudLayerCoverage;
  (function(MetarCloudLayerCoverage2) {
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Few"] = 3] = "Few";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Overcast"] = 6] = "Overcast";
  })(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
  var MetarCloudLayerType;
  (function(MetarCloudLayerType2) {
    MetarCloudLayerType2[MetarCloudLayerType2["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType2[MetarCloudLayerType2["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType2[MetarCloudLayerType2["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType2[MetarCloudLayerType2["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
  })(MetarCloudLayerType || (MetarCloudLayerType = {}));
  var MetarPhenomenonType;
  (function(MetarPhenomenonType2) {
    MetarPhenomenonType2[MetarPhenomenonType2["None"] = 0] = "None";
    MetarPhenomenonType2[MetarPhenomenonType2["Mist"] = 1] = "Mist";
    MetarPhenomenonType2[MetarPhenomenonType2["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType2[MetarPhenomenonType2["Dust"] = 3] = "Dust";
    MetarPhenomenonType2[MetarPhenomenonType2["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType2[MetarPhenomenonType2["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType2[MetarPhenomenonType2["Fog"] = 6] = "Fog";
    MetarPhenomenonType2[MetarPhenomenonType2["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType2[MetarPhenomenonType2["Hail"] = 8] = "Hail";
    MetarPhenomenonType2[MetarPhenomenonType2["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType2[MetarPhenomenonType2["Haze"] = 10] = "Haze";
    MetarPhenomenonType2[MetarPhenomenonType2["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType2[MetarPhenomenonType2["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType2[MetarPhenomenonType2["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType2[MetarPhenomenonType2["Spray"] = 14] = "Spray";
    MetarPhenomenonType2[MetarPhenomenonType2["Rain"] = 15] = "Rain";
    MetarPhenomenonType2[MetarPhenomenonType2["Sand"] = 16] = "Sand";
    MetarPhenomenonType2[MetarPhenomenonType2["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType2[MetarPhenomenonType2["Shower"] = 18] = "Shower";
    MetarPhenomenonType2[MetarPhenomenonType2["Snow"] = 19] = "Snow";
    MetarPhenomenonType2[MetarPhenomenonType2["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType2[MetarPhenomenonType2["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType2[MetarPhenomenonType2["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType2[MetarPhenomenonType2["VolcanicAsh"] = 23] = "VolcanicAsh";
  })(MetarPhenomenonType || (MetarPhenomenonType = {}));
  var MetarPhenomenonIntensity;
  (function(MetarPhenomenonIntensity2) {
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Light"] = -1] = "Light";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Heavy"] = 1] = "Heavy";
  })(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
  var ICAO = class {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
      switch (icao[0]) {
        case "A":
          return FacilityType.Airport;
        case "W":
          return FacilityType.Intersection;
        case "V":
          return FacilityType.VOR;
        case "N":
          return FacilityType.NDB;
        case "U":
          return FacilityType.USR;
        case "R":
          return FacilityType.RWY;
        case "S":
          return FacilityType.VIS;
        default:
          throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
      }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
      return icao.substr(3, 4).trim();
    }
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao, type) {
      switch (icao[0]) {
        case "A":
          return type === void 0 || type === FacilityType.Airport;
        case "W":
          return type === void 0 || type === FacilityType.Intersection;
        case "V":
          return type === void 0 || type === FacilityType.VOR;
        case "N":
          return type === void 0 || type === FacilityType.NDB;
        case "U":
          return type === void 0 || type === FacilityType.USR;
        case "R":
          return type === void 0 || type === FacilityType.RWY;
        case "S":
          return type === void 0 || type === FacilityType.VIS;
        default:
          return false;
      }
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
      return icao.substr(7).trim();
    }
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao) {
      return icao.substr(1, 2).trim();
    }
  };
  ICAO.emptyIcao = "            ";
  var FacilityUtils = class {
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType(facility, type) {
      if (facility["__Type"] === "JS_FacilityIntersection") {
        return type === FacilityType.Intersection;
      }
      return ICAO.isFacility(facility.icao, type);
    }
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
        return -facility.magneticVariation;
      } else {
        return MagVar.get(facility.lat, facility.lon);
      }
    }
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
      return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
      const magVar1 = FacilityUtils.getMagVar(reference1);
      const magVar2 = FacilityUtils.getMagVar(reference2);
      const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
      const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
      const radial1IncludesRef2 = radialCircle1.includes(reference2);
      const radial2IncludesRef1 = radialCircle2.includes(reference1);
      if (radial1IncludesRef2 && radial2IncludesRef1) {
        return out.set(NaN, NaN);
      } else if (radial1IncludesRef2) {
        return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
      } else if (radial2IncludesRef1) {
        return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
      }
      const numIntersections = radialCircle1.encircles(reference2) ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache) : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
      if (numIntersections === 0) {
        return out.set(NaN, NaN);
      }
      return out.set(FacilityUtils.intersectionCache[0]);
    }
  };
  FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
  FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var IntersectionFacilityUtils = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isTerminal(arg) {
      const icao = typeof arg === "string" ? arg : arg.icao;
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao);
    }
    /**
     * Gets the non-terminal version of an intersection ICAO. If the ICAO is already a non-terminal intersection ICAO,
     * then an identical string will be returned.
     * @param icao An intersection ICAO.
     * @returns The non-terminal version of the specified intersection ICAO.
     * @throws Error if the specified ICAO is not an intersection ICAO.
     */
    static getNonTerminalICAO(icao) {
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao) ? `${icao.substring(0, 3)}    ${icao.substring(7)}` : icao;
    }
    /**
     * Gets an ICAO string from itself.
     * @param icao An ICAO string.
     * @returns The specified ICAO string.
     */
    static getIcaoIdentity(icao) {
      return icao;
    }
    /**
     * Gets an ICAO string from a facility.
     * @param facility A facility.
     * @returns The specified facility's ICAO string.
     */
    static getIcaoFacility(facility) {
      return facility.icao;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static filterDuplicates(array, arg2, arg3) {
      if (array.length === 0) {
        return [];
      }
      let getIcao;
      let retainTerminal;
      if (typeof arg2 === "function") {
        getIcao = arg2;
        retainTerminal = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        retainTerminal = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        if (typeof array[0] === "string") {
          getIcao = IntersectionFacilityUtils.getIcaoIdentity;
        } else {
          getIcao = IntersectionFacilityUtils.getIcaoFacility;
        }
      }
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      for (let i = 0; i < array.length; i++) {
        const icao = getIcao(array[i]);
        if (ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) === retainTerminal) {
          IntersectionFacilityUtils.filterDuplicatesSet.add(IntersectionFacilityUtils.getNonTerminalICAO(icao));
        }
      }
      if (IntersectionFacilityUtils.filterDuplicatesSet.size === 0) {
        return array.slice();
      }
      const filtered = array.filter((icao) => {
        return IntersectionFacilityUtils.filterDuplicatesHelper(icao, getIcao, retainTerminal, IntersectionFacilityUtils.filterDuplicatesSet);
      });
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      return filtered;
    }
    /**
     * Checks whether an element should be filtered out from an array such that the filtered array does not contain any
     * elements that are mapped to duplicate terminal/non-terminal intersection pairs.
     * @param element The element to check.
     * @param getIcao A function which maps elements to ICAOs.
     * @param retainTerminal Whether to retain the terminal version of a duplicate pair in the filtered array.
     * @param nonTerminalIcaosToFilter A set of non-terminal ICAOs to filter out of the array.
     * @returns Whether the specified element should be filtered out from an array such that the filtered array does not
     * contain any elements that are mapped to duplicate terminal/non-terminal intersection pairs.
     */
    static filterDuplicatesHelper(element, getIcao, retainTerminal, nonTerminalIcaosToFilter) {
      const icao = getIcao(element);
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        return true;
      }
      const isTerminal = IntersectionFacilityUtils.isTerminal(icao);
      if (isTerminal === retainTerminal) {
        return true;
      }
      if (isTerminal) {
        return !nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao));
      } else {
        return !nonTerminalIcaosToFilter.has(icao);
      }
    }
  };
  IntersectionFacilityUtils.TERMINAL_REGEX = /^...[a-zA-Z\d]/;
  IntersectionFacilityUtils.filterDuplicatesSet = /* @__PURE__ */ new Set();
  var UserFacilityUtils = class {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
      const fac = {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat,
        lon,
        userFacilityType: UserFacilityType.LAT_LONG,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(lat, lon)
      };
      return fac;
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
      const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
      return {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_DISTANCE,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference.icao,
        reference1Radial: radial,
        reference1MagVar: FacilityUtils.getMagVar(reference),
        reference1Distance: distance
      };
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
      const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
      if (isNaN(location.lat) || isNaN(location.lon)) {
        return void 0;
      }
      return {
        icao,
        name: name !== null && name !== void 0 ? name : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_RADIAL,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference1.icao,
        reference1Radial: radial1,
        reference1MagVar: FacilityUtils.getMagVar(reference1),
        reference2Icao: reference2.icao,
        reference2Radial: radial2,
        reference2MagVar: FacilityUtils.getMagVar(reference2)
      };
    }
  };
  UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  var TacanUtils = class {
    /**
     * Converts a VOR frequency to a TACAN channel.
     * @param frequency The frequency of the VOR.
     * @returns The TACAN channel.
     */
    static frequencyToChannel(frequency) {
      const uFrequency = frequency * 10;
      let res = 0;
      if (uFrequency <= 1122) {
        res = (uFrequency - 1063) % 256;
      } else if (uFrequency <= 1179) {
        res = (uFrequency - 1053) % 256;
      } else if (uFrequency < 1333) {
        return "";
      } else if (uFrequency <= 1342) {
        res = (uFrequency - 1273) % 256;
      } else {
        res = (uFrequency - 1343) % 256;
      }
      const letter = Math.round(frequency * 100) % 10 === 0 ? "X" : "Y";
      return res.toFixed(0) + letter;
    }
  };
  var RunwaySurfaceCategory;
  (function(RunwaySurfaceCategory2) {
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Water"] = 8] = "Water";
  })(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
  var RunwayUtils = class {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
      const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
      return lowerCase ? letter.toLowerCase() : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
      return {
        parentRunwayIndex: -1,
        designation: "",
        direction: 36,
        runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
        course: 0,
        elevation: 0,
        elevationEnd: 0,
        gradient: 0,
        latitude: 0,
        longitude: 0,
        length: 0,
        width: 0,
        startThresholdLength: 0,
        endThresholdLength: 0,
        surface: RunwaySurfaceType.Concrete,
        lighting: RunwayLightingType.Unknown
      };
    }
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport) {
      const runways = [];
      airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach((d) => {
        runways.push(d[0]);
        runways.push(d[1]);
      });
      runways.sort(RunwayUtils.sortRunways);
      return runways;
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
      const splitRunways = [];
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        let course = 0;
        let thresholdDistanceFromCenter = 0;
        let thresholdElevation = 0;
        let endThresholdElevation = 0;
        let ilsFrequency;
        let startThresholdLength = 0, endThresholdLength = 0;
        if (i === 0) {
          designator = runway.designatorCharPrimary;
          course = runway.direction;
          thresholdDistanceFromCenter = runway.length / 2 - runway.primaryThresholdLength;
          thresholdElevation = runway.primaryElevation;
          endThresholdElevation = runway.secondaryElevation;
          ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? void 0 : runway.primaryILSFrequency;
          startThresholdLength = runway.primaryThresholdLength;
          endThresholdLength = runway.secondaryThresholdLength;
        } else if (i === 1) {
          designator = runway.designatorCharSecondary;
          course = NavMath.normalizeHeading(runway.direction + 180);
          thresholdDistanceFromCenter = runway.length / 2 - runway.secondaryThresholdLength;
          thresholdElevation = runway.secondaryElevation;
          endThresholdElevation = runway.primaryElevation;
          ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? void 0 : runway.secondaryILSFrequency;
          startThresholdLength = runway.secondaryThresholdLength;
          endThresholdLength = runway.primaryThresholdLength;
        }
        const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
        const coordinates = RunwayUtils.tempGeoPoint.set(runway.latitude, runway.longitude).offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
        splitRunways.push({
          parentRunwayIndex: index,
          designation,
          direction: runwayNumber,
          runwayDesignator: designator,
          course,
          elevation: thresholdElevation,
          elevationEnd: endThresholdElevation,
          gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
          latitude: coordinates.lat,
          longitude: coordinates.lon,
          ilsFrequency,
          length: runway.length,
          width: runway.width,
          startThresholdLength,
          endThresholdLength,
          surface: runway.surface,
          lighting: runway.lighting
        });
      }
      return splitRunways;
    }
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway, padded = true) {
      const pad = padded ? 2 : 0;
      const dashIndex = runway.designation.search("-");
      const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
      const secondary = dashIndex < 0 ? "" : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
      return primary + secondary;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = "") {
      let numberText = `${runwayNumber}`;
      if (padded) {
        numberText = numberText.padStart(2, "0");
      }
      return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return parseInt(runway.designation);
      } else {
        return parseInt(runway.designation.substring(0, dashIndex));
      }
    }
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return void 0;
      } else {
        return parseInt(runway.designation.substring(dashIndex + 1));
      }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const length = airport.runways.length;
      for (let r = 0; r < length; r++) {
        const runway = airport.runways[r];
        const designation = runway.designation;
        const primaryRunwayNumber = parseInt(designation.split("-")[0]);
        const secondaryRunwayNumber = parseInt(designation.split("-")[1]);
        if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
          const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
          return oneWayRunways[0];
        } else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
          const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
          return oneWayRunways[1];
        }
      }
      return void 0;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
      const length = airport.runways.length;
      for (let i = 0; i < length; i++) {
        const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
          return r.designation === designation;
        });
        if (match) {
          return match;
        }
      }
      return void 0;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
      return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
      const oneways = new Array();
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let runwayName;
        if (i === 0) {
          runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, "");
        } else {
          runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, "");
        }
        oneways.push(runwayName);
      }
      const found = new Array();
      for (const procedure of procedures) {
        if (oneways.includes(procedure.runway.trim())) {
          found.push(procedure);
        } else if (procedure.runwayNumber === 0) {
          found.push(procedure);
        }
      }
      return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
      let runway;
      if (typeof arg1 === "string") {
        const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else if (typeof arg1 === "number") {
        const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else {
        runway = arg1;
      }
      const runwayDesignation = runway.designation;
      if (runway.ilsFrequency) {
        return runway.ilsFrequency;
      }
      for (let i = 0; i < airport.frequencies.length; i++) {
        const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ""));
        if (match > -1) {
          return airport.frequencies[i];
        }
      }
      return void 0;
    }
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
      const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
      if (!matchedRunway) {
        return void 0;
      }
      return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
      let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
      switch (runwayDesignator) {
        case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
          break;
        case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
          break;
        default:
          oppositeRunwayDesignator = runwayDesignator;
          break;
      }
      return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
      if (r1.direction === r2.direction) {
        let v1 = 0;
        if (r1.designation.indexOf("L") != -1) {
          v1 = 1;
        } else if (r1.designation.indexOf("C") != -1) {
          v1 = 2;
        } else if (r1.designation.indexOf("R") != -1) {
          v1 = 3;
        }
        let v2 = 0;
        if (r2.designation.indexOf("L") != -1) {
          v2 = 1;
        } else if (r2.designation.indexOf("C") != -1) {
          v2 = 2;
        } else if (r2.designation.indexOf("R") != -1) {
          v2 = 3;
        }
        return v1 - v2;
      }
      return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
      const icao = typeof airport === "string" ? airport : airport.icao;
      return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, " ")}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
      return {
        icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
        name: `Runway ${runway.designation}`,
        region: airport.region,
        city: airport.city,
        lat: runway.latitude,
        lon: runway.longitude,
        magvar: airport.magvar,
        runway
      };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
      const n = Math.round(number);
      return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway) {
      const surface = typeof runway === "object" ? runway.surface : runway;
      if (this.SURFACES_HARD.includes(surface)) {
        return RunwaySurfaceCategory.Hard;
      } else if (this.SURFACES_SOFT.includes(surface)) {
        return RunwaySurfaceCategory.Soft;
      } else if (this.SURFACES_WATER.includes(surface)) {
        return RunwaySurfaceCategory.Water;
      } else {
        return RunwaySurfaceCategory.Unknown;
      }
    }
  };
  RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: "",
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: "L",
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: "R",
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: "C",
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: "W",
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: "A",
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: "B"
  };
  RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban
  ];
  RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
  ];
  RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
  ];
  RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);
  var AirportUtils = class {
    /**
     * Attempts to get the region code of an airport.
     * @param facility The facility record for the airport.
     * @returns The region code of an airport, or `undefined` if one could not be found.
     */
    static tryGetRegionCode(facility) {
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        if (approach.runway.length === 0 || approach.finalLegs.length === 0) {
          continue;
        }
        const fixIcao = approach.finalLegs[approach.finalLegs.length - 1].fixIcao;
        if (ICAO.isFacility(fixIcao, FacilityType.RWY)) {
          const region = ICAO.getRegionCode(fixIcao);
          if (AirportUtils.REGION_CODES.has(region)) {
            return region;
          }
        }
      }
      if (facility.approaches.length > 1) {
        let region = void 0;
        let regionCount = 0;
        for (let i = 0; i < facility.approaches.length; i++) {
          const approach = facility.approaches[i];
          for (let j = 0; j < approach.finalLegs.length; j++) {
            const leg = approach.finalLegs[j];
            if (leg.fixTypeFlags === FixTypeFlags.FAF && ICAO.isFacility(leg.fixIcao)) {
              const fafRegion = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(fafRegion)) {
                region !== null && region !== void 0 ? region : region = fafRegion;
                if (region !== fafRegion) {
                  region = void 0;
                }
                regionCount++;
                break;
              }
            }
          }
          if (region === void 0 && regionCount > 0) {
            break;
          }
        }
        if (region !== void 0 && regionCount > 1) {
          return region;
        }
      }
      const ident = ICAO.getIdent(facility.icao);
      if (ident.length === 4 && ident.search(AirportUtils.NUMERAL_REGEX) < 0) {
        const region = ident.substring(0, 2);
        if (AirportUtils.REGION_CODES.has(region)) {
          return region;
        }
      }
      for (let i = 0; i < facility.departures.length; i++) {
        const departure = facility.departures[i];
        for (let j = 0; j < departure.commonLegs.length; j++) {
          const leg = departure.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < departure.runwayTransitions.length; j++) {
          const transition = departure.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.arrivals.length; i++) {
        const arrival = facility.arrivals[i];
        for (let j = 0; j < arrival.commonLegs.length; j++) {
          const leg = arrival.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < arrival.runwayTransitions.length; j++) {
          const transition = arrival.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        for (let j = 0; j < approach.finalLegs.length; j++) {
          const leg = approach.finalLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < approach.transitions.length; j++) {
          const transition = approach.transitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      return void 0;
    }
    /**
     * Gets the elevation of an airport, in meters. The elevation is estimated as the average elevation of the airport's
     * runways. If the airport has no runways, an elevation cannot be estimated and `undefined` is returned instead.
     * @param facility The facility record for the airport.
     * @returns The elevation of the specified airport, in meters, or `undefined` if the elevation could not be
     * determined.
     */
    static getElevation(facility) {
      if (facility.runways.length === 0) {
        return void 0;
      }
      return facility.runways.reduce((sum, runway) => sum + runway.elevation, 0) / facility.runways.length;
    }
    /**
     * Gets the longest runway of an airport.
     * @param facility The facility record for the airport.
     * @returns The longest runway as an AirportRunway, or null.
     */
    static getLongestRunway(facility) {
      let longestRunway = null;
      for (const runway of facility.runways) {
        if (longestRunway === null || runway.length > longestRunway.length) {
          longestRunway = runway;
        }
      }
      return longestRunway;
    }
    /**
     * Get a list of runways at an airport matching specific criteria.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A list of matching runways.
     */
    static getFilteredRunways(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      const result = [];
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
            result.push(runway);
          }
        }
      }
      return result;
    }
    /**
     * Checks to see whether an airport has a runway matching specific criteria.   This is a
     * lighter version of getFilteredRunways that doesn't do any extra assignments.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A boolean if a matching runway exists.
     */
    static hasMatchingRunway(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
            return true;
          }
        }
      }
      return false;
    }
  };
  AirportUtils.REGION_CODES = /* @__PURE__ */ new Set([
    "AG",
    "AN",
    "AY",
    "BG",
    "BI",
    "BK",
    "CY",
    "DA",
    "DB",
    "DF",
    "DG",
    "DI",
    "DN",
    "DR",
    "DT",
    "DX",
    "EB",
    "ED",
    "EE",
    "EF",
    "EG",
    "EH",
    "EI",
    "EK",
    "EL",
    "EN",
    "EP",
    "ES",
    "ET",
    "EV",
    "EY",
    "FA",
    "FB",
    "FC",
    "FD",
    "FE",
    "FG",
    "FH",
    "FI",
    "FJ",
    "FK",
    "FL",
    "FM",
    "FN",
    "FO",
    "FP",
    "FQ",
    "FS",
    "FT",
    "FV",
    "FW",
    "FX",
    "FY",
    "FZ",
    "GA",
    "GB",
    "GC",
    "GE",
    "GF",
    "GG",
    "GL",
    "GM",
    "GO",
    "GQ",
    "GS",
    "GU",
    "GV",
    "HA",
    "HB",
    "HD",
    "HE",
    "HH",
    "HK",
    "HL",
    "HR",
    "HS",
    "HT",
    "HU",
    "K1",
    "K2",
    "K3",
    "K4",
    "K5",
    "K6",
    "K7",
    "LA",
    "LB",
    "LC",
    "LD",
    "LE",
    "LF",
    "LG",
    "LH",
    "LI",
    "LJ",
    "LK",
    "LL",
    "LM",
    "LO",
    "LP",
    "LQ",
    "LR",
    "LS",
    "LT",
    "LU",
    "LV",
    "LW",
    "LX",
    "LY",
    "LZ",
    "MB",
    "MD",
    "MG",
    "MH",
    "MK",
    "MM",
    "MN",
    "MP",
    "MR",
    "MS",
    "MT",
    "MU",
    "MW",
    "MY",
    "MZ",
    "NC",
    "NF",
    "NG",
    "NI",
    "NL",
    "NS",
    "NT",
    "NV",
    "NW",
    "NZ",
    "OA",
    "OB",
    "OE",
    "OI",
    "OJ",
    "OK",
    "OL",
    "OM",
    "OO",
    "OP",
    "OR",
    "OS",
    "OT",
    "OY",
    "PA",
    "PG",
    "PH",
    "PJ",
    "PK",
    "PL",
    "PM",
    "PO",
    "PP",
    "PT",
    "PW",
    "RC",
    "RJ",
    "RK",
    "RO",
    "RP",
    "SA",
    "SB",
    "SC",
    "SD",
    "SE",
    "SG",
    "SI",
    "SJ",
    "SK",
    "SL",
    "SM",
    "SO",
    "SP",
    "SS",
    "SU",
    "SV",
    "SW",
    "SY",
    "TA",
    "TB",
    "TD",
    "TF",
    "TG",
    "TI",
    "TJ",
    "TK",
    "TL",
    "TN",
    "TQ",
    "TT",
    "TU",
    "TV",
    "TX",
    "UA",
    "UB",
    "UC",
    "UD",
    "UE",
    "UG",
    "UH",
    "UI",
    "UK",
    "UL",
    "UM",
    "UN",
    "UO",
    "UR",
    "US",
    "UT",
    "UU",
    "UW",
    "VA",
    "VC",
    "VD",
    "VE",
    "VG",
    "VH",
    "VI",
    "VL",
    "VM",
    "VN",
    "VO",
    "VR",
    "VT",
    "VV",
    "VY",
    "WA",
    "WB",
    "WI",
    "WM",
    "WR",
    "WS",
    "YB",
    "YM",
    "ZB",
    "ZG",
    "ZH",
    "ZK",
    "ZL",
    "ZM",
    "ZP",
    "ZS",
    "ZU",
    "ZW",
    "ZY"
  ]);
  AirportUtils.NUMERAL_REGEX = /\d/;
  var AirspaceType;
  (function(AirspaceType2) {
    AirspaceType2[AirspaceType2["None"] = 0] = "None";
    AirspaceType2[AirspaceType2["Center"] = 1] = "Center";
    AirspaceType2[AirspaceType2["ClassA"] = 2] = "ClassA";
    AirspaceType2[AirspaceType2["ClassB"] = 3] = "ClassB";
    AirspaceType2[AirspaceType2["ClassC"] = 4] = "ClassC";
    AirspaceType2[AirspaceType2["ClassD"] = 5] = "ClassD";
    AirspaceType2[AirspaceType2["ClassE"] = 6] = "ClassE";
    AirspaceType2[AirspaceType2["ClassF"] = 7] = "ClassF";
    AirspaceType2[AirspaceType2["ClassG"] = 8] = "ClassG";
    AirspaceType2[AirspaceType2["Tower"] = 9] = "Tower";
    AirspaceType2[AirspaceType2["Clearance"] = 10] = "Clearance";
    AirspaceType2[AirspaceType2["Ground"] = 11] = "Ground";
    AirspaceType2[AirspaceType2["Departure"] = 12] = "Departure";
    AirspaceType2[AirspaceType2["Approach"] = 13] = "Approach";
    AirspaceType2[AirspaceType2["MOA"] = 14] = "MOA";
    AirspaceType2[AirspaceType2["Restricted"] = 15] = "Restricted";
    AirspaceType2[AirspaceType2["Prohibited"] = 16] = "Prohibited";
    AirspaceType2[AirspaceType2["Warning"] = 17] = "Warning";
    AirspaceType2[AirspaceType2["Alert"] = 18] = "Alert";
    AirspaceType2[AirspaceType2["Danger"] = 19] = "Danger";
    AirspaceType2[AirspaceType2["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType2[AirspaceType2["ModeC"] = 21] = "ModeC";
    AirspaceType2[AirspaceType2["Radar"] = 22] = "Radar";
    AirspaceType2[AirspaceType2["Training"] = 23] = "Training";
    AirspaceType2[AirspaceType2["Max"] = 24] = "Max";
  })(AirspaceType || (AirspaceType = {}));
  var CoherentAirspace = class {
    /**
     * Constructor.
     * @param def The airspace definition to use for the new airspace.
     * @param uid A unique string ID for the new airspace.
     */
    constructor(def, uid) {
      this.name = "";
      this._segments = [];
      this.type = def.type;
      this.uid = uid;
      const segments = def.segments;
      const len = segments.length;
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        this._segments[i] = new GeoPoint(point.lat, point.long);
      }
    }
    /** @inheritdoc */
    get segments() {
      return this._segments;
    }
    /** @inheritdoc */
    equals(other) {
      if (other instanceof CoherentAirspace) {
        return this.uid === other.uid;
      }
      return this.type === other.type && this.segments.length === other.segments.length && this.segments.every((point, index) => point.equals(other.segments[index]));
    }
  };
  var AirspaceSearcher = class {
    /**
     * Constructor.
     * @param cacheSize The maximum size of the Airspace cache.
     */
    constructor(cacheSize = AirspaceSearcher.DEFAULT_CACHE_SIZE) {
      this.cacheSize = cacheSize;
      this.cache = /* @__PURE__ */ new Map();
      this._isBusy = false;
      this.queue = [];
    }
    /**
     * Checks whether this searcher is currently busy with a search.
     * @returns whether this searcher is currently busy with a search.
     */
    isBusy() {
      return this._isBusy;
    }
    /**
     * Searches for airspaces around a geographic point. If the searcher is not busy, the search will execute
     * immediately. If the search is busy, the search will be queued. Queued searches will be executed one at a time in
     * FIFO order as searches are finished.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of airspaces when the search finishes.
     */
    search(center) {
      return new Promise((resolve) => {
        if (this._isBusy || this.queue.length > 0) {
          this.enqueueSearch(center, resolve);
        } else {
          this.doSearch(center, resolve);
        }
      });
    }
    /**
     * Enqueues a search operation.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    enqueueSearch(center, resolve) {
      this.queue.push(this.doSearch.bind(this, center, resolve));
    }
    /**
     * Executes the next search operation in the queue, if one exists.
     */
    processQueue() {
      const next = this.queue.shift();
      if (next) {
        next();
      }
    }
    /**
     * Executes an airspace search.
     * @param center The center of the search area.
     * @param resolve The Promise resolve function to call with the search results.
     */
    async doSearch(center, resolve) {
      this._isBusy = true;
      try {
        const coherentDefs = await Promise.race([
          this.executeCoherentSearch(center),
          new Promise((timeoutResolve, reject) => setTimeout(() => reject("Airspace search timed out."), AirspaceSearcher.SEARCH_TIMEOUT))
        ]);
        const airspaces = this.processCoherentDefs(coherentDefs);
        resolve(airspaces);
      } catch (e) {
        resolve([]);
      }
      this._isBusy = false;
      this.processQueue();
    }
    /**
     * Executes a Coherent airspace search.
     * @param center The center of the search area.
     * @returns a Promise which is fulfilled with an array of Coherent airspace definitions when the search finishes.
     */
    async executeCoherentSearch(center) {
      await Coherent.call("SET_LOAD_LATLON", center.lat, center.lon);
      return await Coherent.call("GET_NEAREST_AIRSPACES");
    }
    /**
     * Processes an array of Coherent airspace definitions into an array of Airspaces.
     * @param defs An array fo Coherent airspace definitions.
     * @returns an array of Airspaces corresponding to the supplied definitions.
     */
    processCoherentDefs(defs) {
      const result = [];
      const len = defs.length;
      for (let i = 0; i < len; i++) {
        const def = defs[i];
        if (def.type === AirspaceType.None) {
          continue;
        }
        const uid = AirspaceSearcher.generateUID(def);
        let airspace = this.cache.get(uid);
        if (!airspace) {
          airspace = new CoherentAirspace(def, uid);
          this.cacheAirspace(airspace);
        }
        result.push(airspace);
      }
      return result;
    }
    /**
     * Adds an airspace to the cache. If the cache size exceeds the maximum after the operation, airspaces will be
     * removed from the cache in FIFO order to maintain the maximum cache size.
     * @param airspace The airspace to cache.
     */
    cacheAirspace(airspace) {
      this.cache.set(airspace.uid, airspace);
      if (this.cache.size > this.cacheSize) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    /**
     * Generates a unique string ID for a Coherent airspace definition.
     * @param def The airspace definition.
     * @returns a unique string ID.
     */
    static generateUID(def) {
      const segments = def.segments;
      let uid = `${def.type}[${segments.length}]:`;
      const len = Math.min(segments.length - 1, 10);
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        uid += `(${point.lat},${point.long})`;
      }
      if (len < segments.length - 1) {
        const point = segments[segments.length - 2];
        uid += `(${point.lat},${point.long})`;
      }
      return uid;
    }
  };
  AirspaceSearcher.SEARCH_TIMEOUT = 5e3;
  AirspaceSearcher.DEFAULT_CACHE_SIZE = 1e3;
  var ApproachUtils = class {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query) {
      const rnavTypeFlags = typeof query === "number" ? query : query.rnavTypeFlags;
      if (rnavTypeFlags & RnavTypeFlags.LPV) {
        return RnavTypeFlags.LPV;
      }
      if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
        return RnavTypeFlags.LNAVVNAV;
      }
      if (rnavTypeFlags & RnavTypeFlags.LP) {
        return RnavTypeFlags.LP;
      }
      if (rnavTypeFlags & RnavTypeFlags.LNAV) {
        return RnavTypeFlags.LNAV;
      }
      return RnavTypeFlags.None;
    }
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach) {
      return approach.approachType === ApproachType.APPROACH_TYPE_RNAV && approach.rnavTypeFlags === RnavTypeFlags.None && approach.runwayNumber !== 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getFrequencyFromAirport(facility, approach) {
      if (typeof approach === "number") {
        approach = facility.approaches[approach];
      }
      if (approach) {
        switch (approach.approachType) {
          case ApproachType.APPROACH_TYPE_ILS:
          case ApproachType.APPROACH_TYPE_LOCALIZER:
          case ApproachType.APPROACH_TYPE_LDA:
          case ApproachType.APPROACH_TYPE_SDF:
            return RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
          case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            return RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
        }
      }
      return void 0;
    }
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static async getReferenceFacility(approach, facLoader) {
      let facilityType;
      let isLoc = false;
      switch (approach.approachType) {
        case ApproachType.APPROACH_TYPE_ILS:
        case ApproachType.APPROACH_TYPE_LOCALIZER:
        case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
        case ApproachType.APPROACH_TYPE_LDA:
        case ApproachType.APPROACH_TYPE_SDF:
          isLoc = true;
        case ApproachType.APPROACH_TYPE_VOR:
        case ApproachType.APPROACH_TYPE_VORDME:
          facilityType = FacilityType.VOR;
          break;
        case ApproachType.APPROACH_TYPE_NDB:
        case ApproachType.APPROACH_TYPE_NDBDME:
          facilityType = FacilityType.NDB;
          break;
        default:
          return void 0;
      }
      const finalLegs = approach.finalLegs;
      let fafLeg = void 0;
      for (let i = 0; i < finalLegs.length; i++) {
        const leg = finalLegs[i];
        if (BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
          fafLeg = leg;
          break;
        }
      }
      if (!fafLeg) {
        return void 0;
      }
      if (!ICAO.isFacility(fafLeg.originIcao, facilityType)) {
        return void 0;
      }
      try {
        const facility = await facLoader.getFacility(facilityType, fafLeg.originIcao);
        if (isLoc && facility.type !== VorType.ILS) {
          return void 0;
        } else {
          return facility;
        }
      } catch (_a) {
        return void 0;
      }
    }
  };
  var MSFSAPStates;
  (function(MSFSAPStates2) {
    MSFSAPStates2[MSFSAPStates2["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates2[MSFSAPStates2["APOn"] = 2] = "APOn";
    MSFSAPStates2[MSFSAPStates2["FDOn"] = 4] = "FDOn";
    MSFSAPStates2[MSFSAPStates2["FLC"] = 8] = "FLC";
    MSFSAPStates2[MSFSAPStates2["Alt"] = 16] = "Alt";
    MSFSAPStates2[MSFSAPStates2["AltArm"] = 32] = "AltArm";
    MSFSAPStates2[MSFSAPStates2["GS"] = 64] = "GS";
    MSFSAPStates2[MSFSAPStates2["GSArm"] = 128] = "GSArm";
    MSFSAPStates2[MSFSAPStates2["Pitch"] = 256] = "Pitch";
    MSFSAPStates2[MSFSAPStates2["VS"] = 512] = "VS";
    MSFSAPStates2[MSFSAPStates2["Heading"] = 1024] = "Heading";
    MSFSAPStates2[MSFSAPStates2["Nav"] = 2048] = "Nav";
    MSFSAPStates2[MSFSAPStates2["NavArm"] = 4096] = "NavArm";
    MSFSAPStates2[MSFSAPStates2["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates2[MSFSAPStates2["Attitude"] = 16384] = "Attitude";
    MSFSAPStates2[MSFSAPStates2["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates2[MSFSAPStates2["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates2[MSFSAPStates2["ATArm"] = 131072] = "ATArm";
    MSFSAPStates2[MSFSAPStates2["YD"] = 262144] = "YD";
    MSFSAPStates2[MSFSAPStates2["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates2[MSFSAPStates2["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates2[MSFSAPStates2["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates2[MSFSAPStates2["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates2[MSFSAPStates2["Bank"] = 8388608] = "Bank";
    MSFSAPStates2[MSFSAPStates2["FBW"] = 16777216] = "FBW";
    MSFSAPStates2[MSFSAPStates2["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates2[MSFSAPStates2["None"] = -2147483648] = "None";
  })(MSFSAPStates || (MSFSAPStates = {}));
  var airportIcaoRegionPattern = new RegExp(/^A../);
  var FacilityTypeSearchType = {
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User,
    /** Visual facility type. */
    [FacilityType.VIS]: FacilitySearchType.Visual
  };
  var FacilityLoader = class {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => {
    }) {
      this.facilityRepo = facilityRepo;
      this.onInitialized = onInitialized;
      if (FacilityLoader.facilityListener === void 0) {
        FacilityLoader.facilityListener = RegisterViewListener("JS_LISTENER_FACILITY", () => {
          FacilityLoader.facilityListener.on("SendAirport", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendIntersection", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendVor", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendNdb", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("NearestSearchCompleted", FacilityLoader.onNearestSearchCompleted);
          setTimeout(() => FacilityLoader.init(), 2e3);
        }, true);
      }
      this.awaitInitialization().then(() => this.onInitialized());
    }
    /**
     * Initializes this facility loader.
     */
    static init() {
      FacilityLoader.isInitialized = true;
      for (const resolve of this.initPromiseResolveQueue) {
        resolve();
      }
      this.initPromiseResolveQueue.length = 0;
    }
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization() {
      if (FacilityLoader.isInitialized) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          FacilityLoader.initPromiseResolveQueue.push(resolve);
        });
      }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
      switch (type) {
        case FacilityType.USR:
        case FacilityType.RWY:
        case FacilityType.VIS:
          return this.getFacilityFromRepo(type, icao);
        default:
          return this.getFacilityFromCoherent(type, icao);
      }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
      const fac = this.facilityRepo.get(icao);
      if (fac) {
        return fac;
      } else if (type === FacilityType.RWY) {
        try {
          const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
          const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
          if (runway) {
            const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
            this.facilityRepo.add(runwayFac);
            return runwayFac;
          }
        } catch (e) {
        }
      }
      throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromCoherent(type, icao) {
      const isMismatch = ICAO.getFacilityType(icao) !== type;
      if (type === FacilityType.Airport) {
        icao = icao.replace(airportIcaoRegionPattern, "A  ");
      }
      let queue = FacilityLoader.requestQueue;
      let cache = FacilityLoader.facCache;
      if (isMismatch) {
        queue = FacilityLoader.mismatchRequestQueue;
        cache = FacilityLoader.typeMismatchFacCache;
      }
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const cachedFac = cache.get(icao);
      if (cachedFac !== void 0) {
        return Promise.resolve(cachedFac);
      }
      const currentTime = Date.now();
      let request = queue.get(icao);
      if (request === void 0 || currentTime - request.timeStamp > 1e4) {
        if (request !== void 0) {
          request.reject(`Facility request for ${icao} has timed out.`);
        }
        let resolve = void 0;
        let reject = void 0;
        const promise = new Promise((resolution, rejection) => {
          resolve = resolution;
          reject = rejection;
          Coherent.call(type, icao).then((isValid) => {
            if (!isValid) {
              rejection(`Facility ${icao} could not be found.`);
              queue.delete(icao);
            }
          });
        });
        request = { promise, timeStamp: currentTime, resolve, reject };
        queue.set(icao, request);
      }
      return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
      if (FacilityLoader.airwayCache.has(airwayName)) {
        const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
        const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
          w.icao === icao;
        });
        if (match !== void 0 && cachedAirway !== void 0) {
          return cachedAirway;
        }
      }
      const fac = await this.getFacility(FacilityType.Intersection, icao);
      const route = fac.routes.find((r) => r.name === airwayName);
      if (route !== void 0) {
        const airwayBuilder = new AirwayBuilder(fac, route, this);
        const status = await airwayBuilder.startBuild();
        if (status === AirwayStatus.COMPLETE) {
          const waypoints = airwayBuilder.waypoints;
          if (waypoints !== null) {
            const airway = new AirwayObject(airwayName, airwayType);
            airway.waypoints = [...waypoints];
            FacilityLoader.addToAirwayCache(airway);
            return airway;
          }
        }
      }
      throw new Error("Airway could not be found.");
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
      switch (type) {
        case FacilitySearchType.User:
        case FacilitySearchType.Visual:
          return this.startRepoNearestSearchSession(type);
        case FacilitySearchType.AllExceptVisual:
          return this.startCoherentNearestSearchSession(FacilitySearchType.All);
        default:
          return this.startCoherentNearestSearchSession(type);
      }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const sessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", type);
      let session;
      switch (type) {
        case FacilitySearchType.Airport:
          session = new NearestAirportSearchSession(sessionId);
          break;
        case FacilitySearchType.Intersection:
          session = new NearestIntersectionSearchSession(sessionId);
          break;
        case FacilitySearchType.Vor:
          session = new NearestVorSearchSession(sessionId);
          break;
        case FacilitySearchType.Boundary:
          session = new NearestBoundarySearchSession(sessionId);
          break;
        default:
          session = new CoherentNearestSearchSession(sessionId);
          break;
      }
      FacilityLoader.searchSessions.set(sessionId, session);
      return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
      const sessionId = FacilityLoader.repoSearchSessionId--;
      switch (type) {
        case FacilitySearchType.User:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        case FacilitySearchType.Visual:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        default:
          throw new Error();
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const ident = typeof arg === "string" ? arg : ICAO.getIdent(arg.icao);
      const metar = await Coherent.call("GET_METAR_BY_IDENT", ident);
      return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const metar = await Coherent.call("GET_METAR_BY_LATLON", lat, lon);
      return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
      if (raw.icao === "") {
        return void 0;
      }
      raw.gust < 0 && delete raw.gust;
      raw.vertVis < 0 && delete raw.vertVis;
      isNaN(raw.altimeterA) && delete raw.altimeterA;
      raw.altimeterQ < 0 && delete raw.altimeterQ;
      isNaN(raw.slp) && delete raw.slp;
      return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      let results;
      if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
        const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
        results = await Coherent.call("SEARCH_BY_IDENT", ident, coherentFilter, maxItems);
      } else {
        results = [];
      }
      const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
      if (facRepositorySearchTypes) {
        this.facilityRepo.forEach((fac) => {
          const facIdent = ICAO.getIdent(fac.icao);
          if (facIdent === ident) {
            results.unshift(fac.icao);
          } else if (facIdent.startsWith(ident)) {
            results.push(fac.icao);
          }
        }, facRepositorySearchTypes);
      }
      return results;
    }
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
      const results = await this.searchByIdent(filter, ident, maxItems);
      if (!results) {
        return [];
      }
      const promises = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i];
        const facIdent = ICAO.getIdent(icao);
        if (facIdent === ident) {
          const facType = ICAO.getFacilityType(icao);
          promises.push(this.getFacility(facType, icao));
        }
      }
      const foundFacilities = await Promise.all(promises);
      if (foundFacilities.length > 1) {
        foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
        return foundFacilities;
      } else if (foundFacilities.length === 1) {
        return foundFacilities;
      } else {
        return [];
      }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
      const isMismatch = facility["__Type"] === "JS_FacilityIntersection" && facility.icao[0] !== "W";
      const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
      const request = queue.get(facility.icao);
      if (request !== void 0) {
        request.resolve(facility);
        FacilityLoader.addToFacilityCache(facility, isMismatch);
        queue.delete(facility.icao);
      }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
      const session = FacilityLoader.searchSessions.get(results.sessionId);
      if (session instanceof CoherentNearestSearchSession) {
        session.onSearchCompleted(results);
      }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
      const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
      cache.set(fac.icao, fac);
      if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
        cache.delete(cache.keys().next().value);
      }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
      FacilityLoader.airwayCache.set(airway.name, airway);
      if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
        FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
      }
    }
  };
  FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1e3;
  FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1e3;
  FacilityLoader.requestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.mismatchRequestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.facCache = /* @__PURE__ */ new Map();
  FacilityLoader.typeMismatchFacCache = /* @__PURE__ */ new Map();
  FacilityLoader.airwayCache = /* @__PURE__ */ new Map();
  FacilityLoader.searchSessions = /* @__PURE__ */ new Map();
  FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
  };
  FacilityLoader.repoSearchSessionId = -1;
  FacilityLoader.isInitialized = false;
  FacilityLoader.initPromiseResolveQueue = [];
  var CoherentNearestSearchSession = class {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
      this.sessionId = sessionId;
      this.searchQueue = /* @__PURE__ */ new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
      const promise = new Promise((resolve) => {
        Coherent.call("SEARCH_NEAREST", this.sessionId, lat, lon, radius, maxItems).then((searchId) => {
          this.searchQueue.set(searchId, { promise, resolve });
        });
      });
      return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
      const request = this.searchQueue.get(results.searchId);
      if (request !== void 0) {
        request.resolve(results);
        this.searchQueue.delete(results.searchId);
      }
    }
  };
  var NearestAirportSearchSession = class extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
      Coherent.call("SET_NEAREST_AIRPORT_FILTER", this.sessionId, showClosed ? 1 : 0, classMask);
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      Coherent.call("SET_NEAREST_EXTENDED_AIRPORT_FILTERS", this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
  };
  NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
  };
  var NearestIntersectionSearchSession = class extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     */
    setIntersectionFilter(typeMask) {
      Coherent.call("SET_NEAREST_INTERSECTION_FILTER", this.sessionId, typeMask);
    }
  };
  NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
  };
  var NearestVorSearchSession = class extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
      Coherent.call("SET_NEAREST_VOR_FILTER", this.sessionId, classMask, typeMask);
    }
  };
  NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
  };
  var NearestBoundarySearchSession = class extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
      Coherent.call("SET_NEAREST_BOUNDARY_FILTER", this.sessionId, classMask);
    }
  };
  var NearestRepoFacilitySearchSession = class {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
      this.repo = repo;
      this.sessionId = sessionId;
      this.filter = void 0;
      this.cachedResults = /* @__PURE__ */ new Set();
      this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
      const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
      const added = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i].icao;
        if (this.cachedResults.has(icao)) {
          this.cachedResults.delete(icao);
        } else {
          added.push(icao);
        }
      }
      const removed = Array.from(this.cachedResults);
      this.cachedResults.clear();
      for (let i = 0; i < results.length; i++) {
        this.cachedResults.add(results[i].icao);
      }
      return Promise.resolve({
        sessionId: this.sessionId,
        searchId: this.searchId++,
        added,
        removed
      });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
      this.filter = filter;
    }
  };
  var AirwayObject = class {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
      this._waypoints = [];
      this._name = name;
      this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
      return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
      return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
      return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
      this._waypoints = waypoints;
    }
  };
  var AirwayStatus;
  (function(AirwayStatus2) {
    AirwayStatus2[AirwayStatus2["INCOMPLETE"] = 0] = "INCOMPLETE";
    AirwayStatus2[AirwayStatus2["COMPLETE"] = 1] = "COMPLETE";
    AirwayStatus2[AirwayStatus2["PARTIAL"] = 2] = "PARTIAL";
  })(AirwayStatus || (AirwayStatus = {}));
  var AirwayBuilder = class {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
      this._initialWaypoint = _initialWaypoint;
      this._initialData = _initialData;
      this.facilityLoader = facilityLoader;
      this._waypointsArray = [];
      this._hasStarted = false;
      this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
      return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
      return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
      return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
      let isDone = false;
      let current = this._initialData;
      while (!isDone && current) {
        const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
        if (nextICAO && nextICAO.length > 0 && nextICAO[0] != " " && this._waypointsArray !== null && !this._waypointsArray.find((waypoint) => waypoint.icao === nextICAO)) {
          const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
          arrayInsertFunc(fac);
          const next = fac.routes.find((route) => route.name === current.name);
          if (next !== void 0) {
            current = next;
          } else {
            isDone = true;
          }
        } else {
          isDone = true;
        }
      }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
      if (this._waypointsArray !== null) {
        return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
      }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
      if (this._waypointsArray !== null) {
        return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
      }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
      this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
      if (this.hasStarted) {
        return Promise.reject(new Error("Airway builder has already started building."));
      }
      return new Promise((resolve) => {
        this._hasStarted = true;
        if (this._waypointsArray !== null) {
          this._waypointsArray.push(this._initialWaypoint);
          Promise.all([
            this._stepForward(),
            this._stepBackward()
          ]).then(() => {
            this._isDone = true;
            resolve(AirwayStatus.COMPLETE);
          }).catch(() => {
            this._isDone = true;
            resolve(AirwayStatus.PARTIAL);
          });
        }
      });
    }
  };
  var ArrayUtils = class {
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create(length, init) {
      const newArray = [];
      for (let i = 0; i < length; i++) {
        newArray[i] = init(i);
      }
      return newArray;
    }
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at(array, index) {
      if (index < 0) {
        index += array.length;
      }
      if (index < 0 || index >= array.length) {
        throw new RangeError();
      }
      return array[index];
    }
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt(array, index) {
      if (index < 0) {
        index += array.length;
      }
      return array[index];
    }
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[0];
    }
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst(array) {
      return array[0];
    }
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[array.length - 1];
    }
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast(array) {
      return array[array.length - 1];
    }
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes(array, searchElement, fromIndex) {
      return array.includes(searchElement, fromIndex);
    }
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalsFunc(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap(array, map) {
      const out = [];
      for (let i = 0; i < array.length; i++) {
        const mapped = map(array[i], i, array);
        if (Array.isArray(mapped)) {
          for (let j = 0; j < mapped.length; j++) {
            out[out.length] = mapped[j];
          }
        } else {
          out[out.length] = mapped;
        }
      }
      return out;
    }
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat(array, depth = 1) {
      const out = [];
      this.flatHelper(array, depth, 0, out);
      return out;
    }
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    static flatHelper(array, maxDepth, depth, out) {
      for (let i = 0; i < array.length; i++) {
        const element = array[i];
        if (Array.isArray(element) && depth < maxDepth) {
          this.flatHelper(element, maxDepth, depth + 1, out);
        } else {
          out[out.length] = element;
        }
      }
    }
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy(source, target = []) {
      target.length = source.length;
      for (let i = 0; i < source.length; i++) {
        target[i] = source[i];
      }
      return target;
    }
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch(array, element, comparator, first = true) {
      let min = 0;
      let max = array.length;
      let index = Math.floor((min + max) / 2);
      while (min < max) {
        const compare = comparator(element, array[index]);
        if (compare < 0) {
          max = index;
        } else if (compare > 0) {
          min = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min + max) / 2);
      }
      return -(index + 1);
    }
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array) {
      return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
  };
  ArrayUtils.STRICT_EQUALS = (a, b) => a === b;
  var BinaryHeap = class {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
      this.comparator = comparator;
      this.tree = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
      return this.tree.length;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
      return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
      if (this.tree.length === 0) {
        return void 0;
      }
      const min = this.tree[0];
      this.swap(0, this.tree.length - 1);
      this.tree.length--;
      this.heapifyDown(0);
      return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
      this.tree.push(element);
      this.heapifyUp(this.tree.length - 1);
      return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
      if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
        return element;
      }
      return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
      const min = this.tree[0];
      this.tree[0] = element;
      this.heapifyDown(0);
      return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
      this.tree.length = 0;
      return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
      let parent = BinaryHeap.parent(index);
      while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
        this.swap(parent, index);
        index = parent;
        parent = BinaryHeap.parent(index);
      }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
      const len = this.tree.length;
      while (index < len) {
        const left = BinaryHeap.left(index);
        const right = BinaryHeap.right(index);
        let needSwapFlags = 0;
        if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
          needSwapFlags |= 1;
        }
        if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
          needSwapFlags |= 2;
        }
        if (needSwapFlags === 3) {
          needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
        }
        if (needSwapFlags === 0) {
          break;
        }
        const swapChild = needSwapFlags === 1 ? left : right;
        this.swap(index, swapChild);
        index = swapChild;
      }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
      const old1 = this.tree[index1];
      this.tree[index1] = this.tree[index2];
      this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
      return index - 1 >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
      return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
      return index * 2 + 2;
    }
  };
  var BinomialHeap = class {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
      this.comparator = comparator;
      this._size = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
      return this._size;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
      return this.minimum;
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
      let leftSibling = void 0;
      let minNode = this.rootsHead;
      while (minNode && minNode.element !== this.minimum) {
        leftSibling = minNode;
        minNode = minNode.rightSibling;
      }
      if (!minNode) {
        return void 0;
      }
      if (leftSibling) {
        leftSibling.rightSibling = minNode.rightSibling;
      } else {
        this.rootsHead = minNode.rightSibling;
      }
      const heap = BinomialHeap.reverseSiblings(minNode.leftmostChild);
      this.rootsHead = this.mergeHeaps(this.rootsHead, heap);
      this.updateMin();
      this._size--;
      return minNode.element;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
      const newRoot = {
        order: 0,
        element
      };
      this.rootsHead = this.mergeHeaps(this.rootsHead, newRoot);
      this.updateMin();
      this._size++;
      return this;
    }
    /**
     * Merges this heap with another one. The merge can either be non-destructive or destructive. A non-destructive merge
     * preserves the other heap. A destructive merge clears the other heap. A destructive merge takes O(log N) time
     * while a non-destructive merge takes O(M + log N) time, where N is either the size of this heap or the size of the
     * other heap, whichever is larger, and M is the size of the other heap. The difference stems from the need to copy
     * the other heap in a non-destructive merge. Note that the result of this operation is only valid if the two heaps
     * have equivalent comparator functions.
     * @param other The heap to merge into this one.
     * @param destructive Whether to perform a destructive merge. False by default.
     * @returns This heap, after the merge has been completed.
     */
    merge(other, destructive = false) {
      const otherSize = other.size;
      let toMerge;
      if (destructive) {
        toMerge = other.rootsHead;
        other.clear();
      } else {
        toMerge = BinomialHeap.copyTree(other.rootsHead);
      }
      this.rootsHead = this.mergeHeaps(this.rootsHead, toMerge);
      this.updateMin();
      this._size += otherSize;
      return this;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
      this.rootsHead = void 0;
      this.minimum = void 0;
      this._size = 0;
      return this;
    }
    /**
     * Updates the pointer to this heap's minimum element.
     */
    updateMin() {
      let root = this.rootsHead;
      let min;
      while (root) {
        if (min === void 0 || this.comparator(root.element, min) < 0) {
          min = root.element;
        }
        root = root.rightSibling;
      }
      this.minimum = min;
    }
    /**
     * Merges two heaps.
     * @param a The lowest-ordered root of the first heap to merge, or undefined for an empty heap.
     * @param b The lowest-ordered root of the second heap to merge, or undefined for an empty heap.
     * @returns The lowest-ordered root of the union of the two input heaps, or undefined if the merged heap is empty.
     */
    mergeHeaps(a, b) {
      if (!a && !b) {
        return void 0;
      } else if (!a) {
        return b;
      } else if (!b) {
        return a;
      }
      let currentRootA = a;
      let currentRootB = b;
      let merged;
      let previousRootMerged;
      let currentRootMerged;
      while (currentRootA && currentRootB || (currentRootA === null || currentRootA === void 0 ? void 0 : currentRootA.order) === currentRootMerged.order || (currentRootB === null || currentRootB === void 0 ? void 0 : currentRootB.order) === currentRootMerged.order) {
        let toAdd;
        if (!currentRootB || currentRootA && currentRootA.order < currentRootB.order) {
          toAdd = currentRootA;
          currentRootA = currentRootA.rightSibling;
        } else if (!currentRootA || currentRootB.order < currentRootA.order) {
          toAdd = currentRootB;
          currentRootB = currentRootB.rightSibling;
        } else {
          const currentRootASibling = currentRootA.rightSibling;
          const currentRootBSibling = currentRootB.rightSibling;
          toAdd = this.mergeTrees(currentRootA, currentRootB);
          currentRootA = currentRootASibling;
          currentRootB = currentRootBSibling;
        }
        if (currentRootMerged) {
          if (currentRootMerged.order === toAdd.order) {
            toAdd = this.mergeTrees(currentRootMerged, toAdd);
            if (previousRootMerged) {
              previousRootMerged.rightSibling = toAdd;
            } else {
              merged = toAdd;
            }
          } else {
            previousRootMerged = currentRootMerged;
            currentRootMerged.rightSibling = toAdd;
          }
        } else {
          merged = toAdd;
        }
        currentRootMerged = toAdd;
      }
      currentRootMerged.rightSibling = currentRootA !== null && currentRootA !== void 0 ? currentRootA : currentRootB;
      return merged;
    }
    /**
     * Merges two binomial trees of equal order.
     * @param a The root of the first tree to merge.
     * @param b The root of the second tree to merge.
     * @returns The root of the merged tree.
     * @throws Error if the two input trees have different orders.
     */
    mergeTrees(a, b) {
      if (a.order !== b.order) {
        throw new Error(`BinomialHeap: attempted to merge trees of unequal order (${a.order} and ${b.order})`);
      }
      let min, max;
      if (this.comparator(a.element, b.element) <= 0) {
        min = a;
        max = b;
      } else {
        min = b;
        max = a;
      }
      max.rightSibling = min.leftmostChild;
      min.leftmostChild = max;
      min.order++;
      return min;
    }
    /**
     * Reverses the order of sibling nodes.
     * @param leftMostSibling The left-most sibling in a set of sibling nodes to reverse.
     * @returns The left-most sibling of the reversed set of siblings (originally the right-most sibling before the
     * reversal).
     */
    static reverseSiblings(leftMostSibling) {
      if (!leftMostSibling) {
        return void 0;
      }
      if (!leftMostSibling.rightSibling) {
        return leftMostSibling;
      }
      const rightSibling = leftMostSibling.rightSibling;
      const reversed = BinomialHeap.reverseSiblings(rightSibling);
      rightSibling.rightSibling = leftMostSibling;
      leftMostSibling.rightSibling = void 0;
      return reversed;
    }
    /**
     * Copies a binomial tree.
     * @param root The root of the tree to copy.
     * @returns The root of the copy.
     */
    static copyTree(root) {
      if (!root) {
        return void 0;
      }
      return {
        order: root.order,
        element: root.element,
        leftmostChild: root.leftmostChild ? BinomialHeap.copyTree(root.leftmostChild) : void 0,
        rightSibling: root.rightSibling ? BinomialHeap.copyTree(root.rightSibling) : void 0
      };
    }
  };
  var SortedArray = class {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
      this.comparatorFunc = comparatorFunc;
      this.equalityFunc = equalityFunc;
      this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
      return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
      return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
      let min = 0;
      let max = this._array.length;
      let index = Math.floor((min + max) / 2);
      while (min < max) {
        const compare = this.comparatorFunc(element, this._array[index]);
        if (compare < 0) {
          max = index;
        } else if (compare > 0) {
          min = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min + max) / 2);
      }
      return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
      let index = startIndex;
      while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
        if (this.equalityFunc(element, this._array[index])) {
          return index;
        }
        index++;
      }
      return -1;
    }
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index) {
      if (index < 0 || index >= this._array.length) {
        throw new RangeError();
      }
      return this._array[index];
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index) {
      return this._array[index];
    }
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[0];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst() {
      return this._array[0];
    }
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[this._array.length - 1];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast() {
      return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
      return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
      let index = this.findIndex(element, false);
      if (index < 0) {
        index = -index - 1;
      }
      this._array.splice(index, 0, element);
      return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let toInsertIndex = 0;
      let toInsert = sorted[toInsertIndex];
      const len = this._array.length;
      const insertLen = sorted.length;
      for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
        if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
          this._array.splice(i, 0, toInsert);
          toInsert = sorted[++toInsertIndex];
        }
      }
      for (; toInsertIndex < insertLen; toInsertIndex++) {
        this._array.push(sorted[toInsertIndex]);
      }
      return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
      const index = this.searchEquals(element, this.findIndex(element));
      if (index >= 0) {
        this._array.splice(index, 1);
      }
      return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let numRemoved = 0;
      let toRemoveIndex = 0;
      let toRemove = sorted[toRemoveIndex];
      const len = this._array.length;
      const removeLen = sorted.length;
      for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
        if (this.equalityFunc(toRemove, this._array[i])) {
          this._array.splice(i--, 1);
          toRemove = sorted[++toRemoveIndex];
          numRemoved++;
        }
      }
      return numRemoved;
    }
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index) {
      if (index < 0 || index >= this._array.length) {
        return void 0;
      }
      return this._array.splice(index, 1)[0];
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
      return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
      return this._array.shift();
    }
    /**
     * Re-sorts this array using its sorting function.
     */
    resort() {
      this._array.sort(this.comparatorFunc);
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
      return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
      const index = this.matchIndex(query);
      return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
      return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
      this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
      return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
      return this._array.values();
    }
  };
  SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var LerpLookupTable = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg) {
      this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg === "number") {
        this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
        return;
      }
      const leastDimension = arg.reduce((accum, current) => current.length < accum.length ? current : accum);
      this._dimensionCount = Math.max(0, leastDimension ? leastDimension.length - 1 : 0);
      if (this._dimensionCount === 0) {
        return;
      }
      for (let i = 0; i < arg.length; i++) {
        this.insertBreakpoint(arg[i]);
      }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
      return this._dimensionCount;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table);
      if (value === void 0) {
        throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray) {
      const dimensionKey = key[dimension];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array);
        endValue = this.lookupHelper(key, dimension + 1, end.array);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      if (startValue === endValue) {
        return startValue;
      }
      return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpLookupTable.tempBreakpoint = { key: 0 };
  var LerpVectorLookupTable = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2) {
      var _a, _b;
      this.table = new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg1 === "number") {
        this._dimensionCount = isFinite(arg1) ? 0 : Math.max(0, arg1);
        this._vectorLength = isFinite(arg2) ? 0 : Math.max(0, arg2);
      } else {
        let leastBreakpointDimension = Infinity;
        let leastVectorLength = Infinity;
        for (let i = 0; i < arg1.length; i++) {
          leastBreakpointDimension = Math.min(leastBreakpointDimension, Math.max(arg1[i].length - 1, 0));
          leastVectorLength = Math.min(leastVectorLength, (_b = (_a = arg1[i][0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        }
        this._dimensionCount = isFinite(leastBreakpointDimension) ? leastBreakpointDimension : 0;
        this._vectorLength = isFinite(leastVectorLength) ? leastVectorLength : 0;
        if (this._dimensionCount > 0) {
          for (let i = 0; i < arg1.length; i++) {
            this.insertBreakpoint(arg1[i]);
          }
        }
      }
      this.tempVectors = ArrayUtils.create(this._dimensionCount * 2, () => new Float64Array(this._vectorLength));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
      return this._dimensionCount;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of the vectors in this table. */
    get vectorLength() {
      return this._vectorLength;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, the breakpoint has fewer dimensions than this table, or the
     * the length of the breakpoint vector is less than this table's vector length property.
     */
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      if (breakpoint[0].length < this._vectorLength) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint[0].length}-length vector into a table with vectors of length ${this._vectorLength}`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    /**
     * Looks up a vector in this table using a specified key. The returned vector will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param out The vector to which to write the result.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The vector corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a vector could
     * not be retrieved.
     */
    get(out, ...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table, out);
      if (value === void 0) {
        throw new Error(`LerpVectorLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @param out The vector to which to write the result.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray, out) {
      const dimensionKey = key[dimension];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array, this.tempVectors[dimension * 2]);
        endValue = this.lookupHelper(key, dimension + 1, end.array, this.tempVectors[dimension * 2 + 1]);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      return MathUtils.lerpVector(out, dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpVectorLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpVectorLookupTable.tempBreakpoint = { key: 0 };
  var Table3D = class {
    constructor() {
      this.data = [];
    }
    /**
     * Adds a range of values to the table.
     * @param x The x value for this range of values.
     * @param values The range of values in [y, z]
     */
    addRange(x, values) {
      values.sort((a, b) => a[0] - b[0]);
      this.data.push([x, values]);
      this.data.sort((a, b) => a[0] - b[0]);
    }
    /**
     * Gets the interpolated value from the table given an x and y position.
     * @param x The x position to interpolate for.
     * @param y The y position to interpolate for.
     * @returns The interpolated number.
     */
    getValue(x, y) {
      if (x <= this.data[0][0]) {
        return this.interpRange(y, this.data[0][1]);
      }
      if (x >= this.data[this.data.length - 1][0]) {
        return this.interpRange(y, this.data[this.data.length - 1][1]);
      }
      for (let i = 0; i < this.data.length; i++) {
        if (this.data[i][0] >= x) {
          const bottomRange = this.data[i - 1][1];
          const topRange = this.data[i][1];
          const bottomZ = this.interpRange(y, bottomRange);
          const topZ = this.interpRange(y, topRange);
          return this.interp2d(x, this.data[i - 1][0], this.data[i][0], bottomZ, topZ);
        }
      }
      return NaN;
    }
    /**
     * Interpolates a range of values given a starting y value.
     * @param y The y value to use.
     * @param range The range of values to interpolate over.
     * @returns A resultant interpolated z value.
     */
    interpRange(y, range) {
      if (range.length === 0) {
        return NaN;
      }
      if (y <= range[0][0]) {
        return range[0][1];
      }
      if (y >= range[range.length - 1][0]) {
        return range[range.length - 1][1];
      }
      for (let i = 0; i < range.length; i++) {
        if (range[i][0] >= y) {
          return this.interp2d(y, range[i - 1][0], range[i][0], range[i - 1][1], range[i][1]);
        }
      }
      return NaN;
    }
    /**
     * Interpolates in two dimensions.
     * @param y The input y value.
     * @param y0 The bottom y value for interpolation.
     * @param y1 The top y value for interpolation.
     * @param z0 The bottom z number for interpolation
     * @param z1 The top z number for interpolation.
     * @returns An interpolated z result given the input y.
     */
    interp2d(y, y0, y1, z0, z1) {
      const yPercent = (y - y0) / (y1 - y0);
      return (z1 - z0) * yPercent + z0;
    }
  };
  var KdTree = class {
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
      this.keyFunc = keyFunc;
      this.elements = [];
      this.keys = [];
      this.nodes = [];
      this.minDepth = -1;
      this.maxDepth = -1;
      this.dimensionCount = Math.trunc(dimensionCount);
      if (this.dimensionCount < 2) {
        throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
      }
      this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
      this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
        return (a, b) => {
          const aKey = this.keys[a];
          const bKey = this.keys[b];
          for (let i = 0; i < this.dimensionCount; i++) {
            const dimension = (i + index) % this.dimensionCount;
            if (aKey[dimension] < bKey[dimension]) {
              return -1;
            } else if (aKey[dimension] > bKey[dimension]) {
              return 1;
            }
          }
          return 0;
        };
      });
      this.keyCache = [
        new Float64Array(this.dimensionCount)
      ];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
      return this.elements.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
      if (typeof arg3 === "number") {
        return this.doResultsSearch(void 0, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(void 0, key, radius, arg3);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
      const key = this.keyFunc(element, this.keyCache[0]);
      if (typeof arg3 === "number") {
        return this.doResultsSearch(element, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(element, key, radius, arg3);
      }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        return visitor(elementInner, keyInner, distance, queryKey, queryElement);
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        return searchRadius + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
      if (maxResultCount <= 0) {
        out.length = 0;
        return out;
      }
      const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
          if (heap.size === maxResultCount) {
            heap.insertAndRemoveMin(elementIndex);
          } else {
            heap.insert(elementIndex);
          }
        }
        return true;
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        let maxDist = searchRadius;
        if (heap.size === maxResultCount) {
          maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
        }
        return maxDist + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
      out.length = heap.size;
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = this.elements[heap.removeMin()];
      }
      return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
      const elementIndex = this.nodes[nodeIndex];
      if (elementIndex === void 0) {
        return true;
      }
      const nodeKey = this.keys[elementIndex];
      const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
      if (distanceFromNode <= radius) {
        if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
          return false;
        }
      }
      const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      const lesserNodeIndex = KdTree.lesser(nodeIndex);
      const greaterNodeIndex = KdTree.greater(nodeIndex);
      if (this.nodes[lesserNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, -1)) {
        if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      if (this.nodes[greaterNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, 1)) {
        if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
      const insertDepth = this.insertElementInTree(element) + 1;
      this.maxDepth = Math.max(this.maxDepth, insertDepth);
      if (insertDepth === this.minDepth + 1) {
        this.minDepth = KdTree.depth(this.nodes.indexOf(void 0, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
      }
      if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
        this.rebuild();
      }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
      for (const element of elements) {
        this.elements.push(element);
        this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
        const insertedIndex = this.elements.length - 1;
        for (let i = 0; i < this.dimensionCount; i++) {
          this.indexArrays[i].push(insertedIndex);
        }
      }
      this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
      const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
      let index = 0;
      let depth = 0;
      let elementIndex;
      while ((elementIndex = this.nodes[index]) !== void 0) {
        const pivotDimension = depth % this.dimensionCount;
        const keyToCompare = key[pivotDimension];
        if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
          index = KdTree.lesser(index);
        } else {
          index = KdTree.greater(index);
        }
        depth++;
      }
      this.elements.push(element);
      this.keys.push(key);
      const insertedIndex = this.elements.length - 1;
      this.nodes[index] = insertedIndex;
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].push(insertedIndex);
      }
      return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
      if (!this.removeElementFromArrays(element)) {
        return false;
      }
      this.resetIndexArrays();
      this.rebuild();
      return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
      let removed = false;
      for (const element of elements) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
        this.rebuild();
      }
      return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
      const index = this.elements.indexOf(element);
      if (index < 0) {
        return false;
      }
      const lastIndex = this.elements.length - 1;
      this.elements[index] = this.elements[lastIndex];
      this.keys[index] = this.keys[lastIndex];
      this.elements.length--;
      this.keys.length--;
      return true;
    }
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    resetIndexArrays() {
      for (let i = 0; i < this.dimensionCount; i++) {
        const array = this.indexArrays[i];
        array.length = this.elements.length;
        for (let j = 0; j < array.length; j++) {
          array[j] = j;
        }
      }
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
      let removed = false;
      for (const element of toRemove) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
      }
      this.insertAll(toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
      this.nodes.length = 0;
      if (this.size === 0) {
        return;
      }
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].sort(this.indexSortFuncs[i]);
      }
      this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
      const log = Math.log2(this.elements.length + 1);
      this.minDepth = Math.floor(log) - 1;
      this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
      const tempArray = this.indexArrays[this.dimensionCount];
      const sortedArray = this.indexArrays[0];
      const medianIndex = Math.trunc((start + end) / 2);
      const medianKeyIndex = sortedArray[medianIndex];
      this.nodes[nodeIndex] = medianKeyIndex;
      if (end - start === 1) {
        return;
      }
      if (end - start <= 3) {
        const lesserIndex = medianIndex - 1;
        const greaterIndex = medianIndex + 1;
        if (lesserIndex >= start) {
          this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
        }
        if (greaterIndex < end) {
          this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
        }
        return;
      }
      for (let i = start; i < end; i++) {
        tempArray[i] = sortedArray[i];
      }
      for (let i = 1; i < this.dimensionCount; i++) {
        const targetArray = this.indexArrays[i - 1];
        const toPartitionArray = this.indexArrays[i];
        let lesserCount = 0;
        let greaterCount = 0;
        for (let j = start; j < end; j++) {
          const keyIndex = toPartitionArray[j];
          if (keyIndex === medianKeyIndex) {
            targetArray[medianIndex] = keyIndex;
          } else {
            const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
            if (comparison <= 0) {
              const index = start + lesserCount++;
              targetArray[index] = keyIndex;
            } else {
              const index = medianIndex + 1 + greaterCount++;
              targetArray[index] = keyIndex;
            }
          }
        }
      }
      const newSortedArray = this.indexArrays[this.dimensionCount - 1];
      for (let i = start; i < end; i++) {
        newSortedArray[i] = tempArray[i];
      }
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
      this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
      this.elements.length = 0;
      this.keys.length = 0;
      this.nodes.length = 0;
      for (let i = 0; i < this.indexArrays.length; i++) {
        this.indexArrays[i].length = 0;
      }
      this.minDepth = -1;
      this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
      return index - 1 >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
      return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
      return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
      return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
      return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
      let sumSq = 0;
      for (let i = 0; i < dimensionCount; i++) {
        const diff = key1[i] - key2[i];
        sumSq += diff * diff;
      }
      return Math.sqrt(sumSq);
    }
  };
  var GeoKdTree = class {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
      this.keyFunc = keyFunc;
      this.cartesianTree = new KdTree(3, (element, out) => {
        const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
        out[0] = vec[0];
        out[1] = vec[1];
        out[2] = vec[2];
        return out;
      });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
      let center, radius;
      let argA, argB, argC;
      if (typeof arg1 === "number") {
        center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
        radius = arg3;
        argA = arg4;
        argB = arg5;
        argC = arg6;
      } else if (!(arg1 instanceof Float64Array)) {
        center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      } else {
        center = arg1;
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      }
      const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
      if (typeof argA === "number") {
        return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
      } else {
        this.doVisitorSearch(center, radiusCartesian, argA);
      }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
      this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return visitor(element, vec, greatCircleDist, center);
      });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
      const cartesianFilter = filter ? (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return filter(element, vec, greatCircleDist, center);
      } : void 0;
      return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
      this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
      this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
      return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
      return this.cartesianTree.removeAll(elements);
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
      this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
      this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
      this.cartesianTree.clear();
    }
  };
  GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  var SubscribableArrayEventType;
  (function(SubscribableArrayEventType2) {
    SubscribableArrayEventType2["Added"] = "Added";
    SubscribableArrayEventType2["Removed"] = "Removed";
    SubscribableArrayEventType2["Cleared"] = "Cleared";
  })(SubscribableArrayEventType || (SubscribableArrayEventType = {}));
  var AbstractSubscribableArray = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
      const array = this.getArray();
      if (index > array.length - 1) {
        throw new Error("Index out of range");
      }
      return array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
      return this.getArray()[index];
    }
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    notify(index, type, modifiedItem) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(index, type, modifiedItem, this.getArray());
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ArraySubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
      const array = this.getArray();
      sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
  };
  var SortedMappedSubscribableArray = class extends AbstractSubscribableArray {
    /**
     * Constructor.
     * @param source The source array subject for this subscribable.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(source, comparatorFunc, equalityFunc) {
      super();
      this.source = source;
      this.comparatorFunc = comparatorFunc;
      this.equalityFunc = equalityFunc;
      this.sorted = new SortedArray(this.comparatorFunc, this.equalityFunc);
      this.sourceSub = source.sub(this.onSourceChanged.bind(this), true);
    }
    /** @inheritdoc */
    get length() {
      return this.sorted.length;
    }
    /**
     * Creates a new SortedMappedSubscribableArray.
     * @param source The source array subject for the new mapped sorted array.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create(source, comparatorFunc, equalityFunc) {
      return new SortedMappedSubscribableArray(source, comparatorFunc, equalityFunc);
    }
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
      switch (type) {
        case SubscribableArrayEventType.Cleared:
          if (this.sorted.length !== 0) {
            this.sorted.clear();
            this.notify(0, SubscribableArrayEventType.Cleared);
          }
          break;
        case SubscribableArrayEventType.Added:
          if (item) {
            this.insert(item);
          }
          break;
        case SubscribableArrayEventType.Removed:
          if (item) {
            this.remove(item);
          }
          break;
      }
    }
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    insert(elements) {
      if (this.sorted.length === 0) {
        elements instanceof Array ? this.sorted.insertAll(elements) : this.sorted.insert(elements);
        this.notify(0, SubscribableArrayEventType.Added, elements instanceof Array ? this.sorted.array : elements);
      } else {
        if (elements instanceof Array) {
          const len = elements.length;
          for (let i = 0; i < len; i++) {
            const toInsert = elements[i];
            this.notify(this.sorted.insert(toInsert), SubscribableArrayEventType.Added, toInsert);
          }
        } else {
          this.notify(this.sorted.insert(elements), SubscribableArrayEventType.Added, elements);
        }
      }
    }
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    remove(elements) {
      if (elements instanceof Array) {
        const len = elements.length;
        for (let i = 0; i < len; i++) {
          const toRemove = elements[i];
          const removedIndex = this.sorted.remove(toRemove);
          if (removedIndex >= 0) {
            this.notify(removedIndex, SubscribableArrayEventType.Removed, toRemove);
          }
        }
      } else {
        const removedIndex = this.sorted.remove(elements);
        if (removedIndex >= 0) {
          this.notify(removedIndex, SubscribableArrayEventType.Removed, elements);
        }
      }
    }
    /** @inheritdoc */
    getArray() {
      return this.sorted.array;
    }
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy() {
      this.sourceSub.destroy();
    }
  };
  var FilteredMappedSubscribableArray = class extends AbstractSubscribableArray {
    /**
     * Private constructor for a FilteredMappedSubscribableArray.
     * @param source The source array subject for this subscribable.
     * @param filterFunc The filter function to use to prune members.  Should return false for filtered-out elements.
     */
    constructor(source, filterFunc) {
      super();
      this.source = source;
      this.filterFunc = filterFunc;
      this.filtered = new Array();
      this.sourceSub = source.sub(this.onSourceChanged.bind(this), true);
    }
    /** @inheritdoc */
    get length() {
      return this.filtered.length;
    }
    /**
     * Public creation method for a new FilteredMappedSubscribableArray.
     * @param source The source array subject for the new mapped array.
     * @param filterFunc The filter function to use to prune members.  Should return false for filtered-out elements.
     * @returns A new SortedMappedSubscribableArray.
     */
    static create(source, filterFunc) {
      return new FilteredMappedSubscribableArray(source, filterFunc);
    }
    /**
     * Responds to changes in this subscribable's source array.
     * @param index The index of the change.
     * @param type The type of change.
     * @param item The item(s) involved in the change, if any.
     */
    onSourceChanged(index, type, item) {
      switch (type) {
        case SubscribableArrayEventType.Cleared:
          if (this.filtered.length !== 0) {
            this.filtered = [];
            this.notify(0, SubscribableArrayEventType.Cleared);
          }
          break;
        case SubscribableArrayEventType.Added:
          if (item) {
            this.insert(item);
          }
          break;
        case SubscribableArrayEventType.Removed:
          if (item) {
            this.remove(item);
          }
          break;
      }
    }
    /**
     * Set a new filter for this array.
     * @param filterFunc The new filter function.
     */
    setFilter(filterFunc) {
      this.filterFunc = filterFunc;
      this.filtered = [];
      this.notify(0, SubscribableArrayEventType.Cleared);
      this.insert(this.source.getArray());
    }
    /**
     * Takes an element or array of elements and returns an array of only those passing the filter.
     * @param elements An element or array of elements to run through the filter.
     * @returns A new list composed of only those elements which pass the filter.
     */
    filter(elements) {
      if (elements instanceof Array) {
        return elements.filter(this.filterFunc);
      } else {
        return this.filterFunc(elements) ? [elements] : [];
      }
    }
    /**
     * Inserts elements into this array.
     * @param elements An element or array of elements to insert.
     */
    insert(elements) {
      const filtered = this.filter(elements);
      if (filtered.length > 0) {
        this.filtered.push(...filtered);
        this.notify(0, SubscribableArrayEventType.Added, filtered);
      }
    }
    /**
     * Finds the index of the first element in this array which equals a query element.
     * @param element The query element.
     * @returns The index of the first matching element, or -1 if no such element.
     */
    searchEquals(element) {
      for (let i = 0; i < this.filtered.length; i++) {
        if (this.filtered[i] === element) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Removes elements from this array.
     * @param elements An element or array of elements to remove.
     */
    remove(elements) {
      if (elements instanceof Array) {
        for (let i = 0; i < elements.length; i++) {
          this.removeElement(elements[i]);
        }
      } else {
        this.removeElement(elements);
      }
    }
    /**
     * Removes a single element from the array.
     * @param element The element to remove.
     */
    removeElement(element) {
      const removedIndex = this.searchEquals(element);
      if (removedIndex >= 0) {
        this.filtered.splice(removedIndex, 1);
        this.notify(removedIndex, SubscribableArrayEventType.Removed, element);
      }
    }
    /** @inheritdoc */
    getArray() {
      return this.filtered;
    }
    /**
     * Destroys this subscribable. After destruction, this subscribable will no longer update in response to changes
     * made to its source.
     */
    destroy() {
      this.sourceSub.destroy();
    }
  };
  var FacilityRepositorySyncType;
  (function(FacilityRepositorySyncType2) {
    FacilityRepositorySyncType2["Add"] = "Add";
    FacilityRepositorySyncType2["Remove"] = "Remove";
    FacilityRepositorySyncType2["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType2["DumpResponse"] = "DumpResponse";
  })(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
  var FacilityRepository = class {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.repos = /* @__PURE__ */ new Map();
      this.trees = {
        [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc)
      };
      this.ignoreSync = false;
      bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
      this.pubSyncEvent({
        type: FacilityRepositorySyncType.DumpRequest,
        uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
      });
    }
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types) {
      var _a, _b;
      let size = 0;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          size += repo.size;
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        }
      }
      return size;
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
      var _a;
      if (!ICAO.isFacility(icao)) {
        return void 0;
      }
      return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
      if (type !== FacilityType.USR && type !== FacilityType.VIS) {
        throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
      }
      if (typeof arg5 === "number") {
        return this.trees[type].search(lat, lon, radius, arg5, out, filter);
      } else {
        this.trees[type].search(lat, lon, radius, arg5);
      }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac) {
      if (!ICAO.isFacility(fac.icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
      }
      this.addToRepo(fac);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs) {
      this.addMultipleToRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      if (!ICAO.isFacility(icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
      }
      this.removeFromRepo(icao);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs) {
      this.removeMultipleFromRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map((fac) => typeof fac === "object" ? fac.icao : fac) });
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
      var _a;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          repo.forEach(fn);
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
      }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
      const facilityType = ICAO.getFacilityType(fac.icao);
      let repo = this.repos.get(facilityType);
      if (repo === void 0) {
        this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
      }
      const existing = repo.get(fac.icao);
      repo.set(fac.icao, fac);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        if (existing === void 0) {
          this.trees[facilityType].insert(fac);
        } else {
          this.trees[facilityType].removeAndInsert([existing], [fac]);
        }
      }
      if (existing === void 0) {
        this.publisher.pub("facility_added", fac, false, false);
      } else {
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    addMultipleToRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const addedFacilities = [];
      const changedFacilitiesRemoved = [];
      const changedFacilitiesAdded = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === void 0) {
          this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (existing === void 0) {
          addedFacilities.push(fac);
        } else {
          changedFacilitiesRemoved.push(existing);
          changedFacilitiesAdded.push(fac);
        }
      }
      const addedUserFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (addedUserFacilities.length > 0) {
        const removedUserFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
      }
      const addedVisFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (addedVisFacilities.length > 0) {
        const removedVisFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
      }
      for (let i = 0; i < addedFacilities.length; i++) {
        const fac = addedFacilities[i];
        this.publisher.pub("facility_added", fac, false, false);
      }
      for (let i = 0; i < changedFacilitiesAdded.length; i++) {
        const fac = changedFacilitiesAdded[i];
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    removeFromRepo(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      const facilityType = ICAO.getFacilityType(icao);
      const repo = this.repos.get(ICAO.getFacilityType(icao));
      if (repo === void 0) {
        return;
      }
      const facilityInRepo = repo.get(icao);
      if (facilityInRepo === void 0) {
        return;
      }
      repo.delete(icao);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        this.trees[facilityType].remove(facilityInRepo);
      }
      this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
      this.publisher.pub("facility_removed", facilityInRepo, false, false);
    }
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    removeMultipleFromRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const removedFacilities = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const icao = typeof fac === "string" ? fac : fac.icao;
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === void 0) {
          continue;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === void 0) {
          continue;
        }
        repo.delete(icao);
        removedFacilities.push(facilityInRepo);
      }
      const removedUserFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (removedUserFacilities.length > 0) {
        this.trees[FacilityType.USR].removeAll(removedUserFacilities);
      }
      const removedVisFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (removedVisFacilities.length > 0) {
        this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
      }
      for (let i = 0; i < removedFacilities.length; i++) {
        const removedFac = removedFacilities[i];
        this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
        this.publisher.pub("facility_removed", removedFac, false, false);
      }
    }
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    pubSyncEvent(data) {
      this.ignoreSync = true;
      this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
      this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
      if (this.ignoreSync) {
        return;
      }
      switch (data.type) {
        case FacilityRepositorySyncType.DumpResponse:
          if (data.uid !== this.lastDumpRequestUid) {
            break;
          } else {
            this.lastDumpRequestUid = void 0;
          }
        case FacilityRepositorySyncType.Add:
          if (data.facs.length === 1) {
            this.addToRepo(data.facs[0]);
          } else {
            this.addMultipleToRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.Remove:
          if (data.facs.length === 1) {
            this.removeFromRepo(data.facs[0]);
          } else {
            this.removeMultipleFromRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.DumpRequest:
          if (data.uid !== this.lastDumpRequestUid) {
            const facs = [];
            this.forEach((fac) => facs.push(fac));
            this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
          }
          break;
      }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
      var _a;
      return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : FacilityRepository.INSTANCE = new FacilityRepository(bus);
    }
  };
  FacilityRepository.SYNC_TOPIC = "facilityrepo_sync";
  FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
  };
  var HoldEntryType;
  (function(HoldEntryType2) {
    HoldEntryType2[HoldEntryType2["Direct"] = 0] = "Direct";
    HoldEntryType2[HoldEntryType2["Teardrop"] = 1] = "Teardrop";
    HoldEntryType2[HoldEntryType2["Parallel"] = 2] = "Parallel";
    HoldEntryType2[HoldEntryType2["None"] = 3] = "None";
  })(HoldEntryType || (HoldEntryType = {}));
  var HoldMaxSpeedRule;
  (function(HoldMaxSpeedRule2) {
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Faa"] = 0] = "Faa";
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Icao"] = 1] = "Icao";
  })(HoldMaxSpeedRule || (HoldMaxSpeedRule = {}));
  var HoldUtils = class {
    /**
     * Gets a hold direction UI string for a given inbound course.
     *
     * @param course The inbound course to get the string for.
     * @param short Whether to get the string in short form (single letter)
     *
     * @returns A UI human-readable course string.
     */
    static getDirectionString(course, short = false) {
      if (course >= 0 && course < 22.5) {
        return short ? "S" : "South";
      } else if (course >= 22.5 && course < 67.5) {
        return short ? "SW" : "Southwest";
      } else if (course >= 67.5 && course < 112.5) {
        return short ? "W" : "West";
      } else if (course >= 112.5 && course < 157.5) {
        return short ? "NW" : "Northwest";
      } else if (course >= 157.5 && course < 202.5) {
        return short ? "N" : "North";
      } else if (course >= 202.5 && course < 247.5) {
        return short ? "NE" : "Northeast";
      } else if (course >= 247.5 && course < 292.5) {
        return short ? "E" : "East";
      } else if (course >= 292.5 && course < 337.5) {
        return short ? "SE" : "Southeast";
      } else {
        return short ? "S" : "South";
      }
    }
    /**
     * Obtains hold speed (number and isMach) depending on altitude and speed rule (ICAO or FAA)
     *
     * @param altitude MSL altitude
     * @param rule     hold speed rule
     *
     * @returns hold speed and whether that number is in Mach
     */
    static getHoldSpeed(altitude, rule) {
      switch (rule) {
        case HoldMaxSpeedRule.Faa:
          if (altitude < 6e3) {
            return [200, false];
          } else if (altitude < 14e3) {
            return [230, false];
          } else {
            return [265, false];
          }
        case HoldMaxSpeedRule.Icao:
          if (altitude < 14e3) {
            return [230, false];
          } else if (altitude < 2e4) {
            return [240, false];
          } else if (altitude < 34e3) {
            return [265, false];
          } else {
            return [0.83, true];
          }
      }
    }
  };
  var SubscribableUtils = class {
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable(query) {
      return typeof query === "object" && query !== null && query.isSubscribable === true;
    }
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable(query) {
      return typeof query === "object" && query !== null && query.isMutableSubscribable === true;
    }
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable(value, excludeSubscribables) {
      if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
        return value;
      } else {
        return Subject.create(value);
      }
    }
  };
  SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || isNaN(a) && isNaN(b);
  var facilitySearchTypeMap = /* @__PURE__ */ new Map([
    [FacilitySearchType.Airport, FacilityType.Airport],
    [FacilitySearchType.Intersection, FacilityType.Intersection],
    [FacilitySearchType.Vor, FacilityType.VOR],
    [FacilitySearchType.Ndb, FacilityType.NDB],
    [FacilitySearchType.User, FacilityType.USR]
  ]);
  var AbstractNearestSubscription = class extends AbstractSubscribableArray {
    /**
     * Creates an instance of a NearestSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     */
    constructor(facilityLoader, type) {
      super();
      this.facilityLoader = facilityLoader;
      this.type = type;
      this.facilities = [];
      this.facilityIndex = /* @__PURE__ */ new Map();
      this.startPromiseResolves = [];
      this.updatePromiseResolves = [];
      this.hasRequestedSession = false;
      this.searchInProgress = false;
    }
    /** @inheritdoc */
    get length() {
      return this.facilities.length;
    }
    /**
     * Whether or not this subscription has been started.
     * @returns True if started, false otherwise.
     */
    get started() {
      return this.session !== void 0;
    }
    /** @inheritdoc */
    getArray() {
      return this.facilities;
    }
    /** @inheritdoc */
    awaitStart() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        this.startPromiseResolves.push(resolve);
      });
    }
    /** @inheritdoc */
    start() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      if (this.hasRequestedSession) {
        return this.awaitStart();
      }
      return new Promise((resolve) => {
        this.hasRequestedSession = true;
        this.startPromiseResolves.push(resolve);
        this.facilityLoader.startNearestSearchSession(this.type).then((session) => {
          this.session = session;
          this.startPromiseResolves.forEach((queuedResolve) => {
            queuedResolve();
          });
          this.startPromiseResolves.length = 0;
        });
      });
    }
    /** @inheritdoc */
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    /**
     * Executes an update of the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      if (!this.started) {
        await this.start();
      }
      const results = await this.session.searchNearest(lat, lon, radius, maxItems);
      await this.onResults(results);
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    /**
     * Adds a facility to the collection.
     * @param facility The facility to add.
     * @param key The key to track this facility by.
     */
    addFacility(facility, key) {
      if (this.facilityIndex.has(key)) {
        console.warn(`Facility ${key} is already in the collection.`);
      }
      this.facilities.push(facility);
      this.facilityIndex.set(key, facility);
      this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, facility);
    }
    /**
     * Removes a facility from the collection.
     * @param key The key of the facility to remove.
     */
    removeFacility(key) {
      const facility = this.facilityIndex.get(key);
      if (facility !== void 0) {
        const index = this.facilities.indexOf(facility);
        this.facilities.splice(index, 1);
        this.facilityIndex.delete(key);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Removed, facility);
      }
    }
  };
  var NearestWaypointSubscription = class extends AbstractNearestSubscription {
    /**
     * Creates a new NearestWaypointSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     */
    constructor(facilityLoader, type, filterCb) {
      super(facilityLoader, type);
      this.facilityCache = /* @__PURE__ */ new Map();
      this.filterCb = filterCb;
    }
    /**
     * Sets this subscription's post-search session filter and refilters this subscription's latest results using the new
     * filter.
     * @param filter A function which filters results after they have been returned by this subscription's search
     * session, or `undefined` if no post-search session filtering is to be performed.
     */
    setFilterCb(filter) {
      this.filterCb = filter;
      this.refilter();
    }
    /**
     * Refilters the latest search results returned from this subscription's nearest search session.
     */
    refilter() {
      if (this.filterCb) {
        for (const icao of this.facilityIndex.keys()) {
          if (!this.filterCb(this.facilityIndex.get(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
          this.addFacility(this.facilityCache.get(icao), icao);
        }
      }
    }
    /** @inheritdoc */
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          this.facilityCache.set(added[i].icao, added[i]);
          if (this.filterCb === void 0 || this.filterCb(added[i])) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestAirportSubscription = class extends NearestWaypointSubscription {
    /**
     * Creates a new NearestAirportSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     */
    constructor(facilityLoader, filterCb) {
      super(facilityLoader, FacilitySearchType.Airport, filterCb);
    }
    /**
     * Sets the airport search filter.
     * @param showClosed Whether or not to return closed airports in the search.
     * @param classMask A bitmask representing the classes of airports to show.
     */
    setFilter(showClosed, classMask) {
      if (this.session !== void 0) {
        this.session.setAirportFilter(showClosed, classMask);
      }
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      if (this.session !== void 0) {
        this.session.setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
      }
    }
  };
  var NearestIntersectionSubscription = class extends NearestWaypointSubscription {
    /**
     * Creates a new NearestIntersectionSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     * @param filterDupTerminal Whether to filter out terminal intersections if their non-terminal counterparts are
     * also present in the subscription's results. Defaults to `false`.
     */
    constructor(facilityLoader, filterCb, filterDupTerminal = false) {
      super(facilityLoader, FacilitySearchType.Intersection, filterCb);
      this.nonTerminalIcaosToFilter = /* @__PURE__ */ new Set();
      this.filterDupTerminal = filterDupTerminal;
    }
    /**
     * Sets the intersection search filter.
     * @param typeMask A bitmask representing the classes of intersections to show.
     */
    setFilter(typeMask) {
      if (this.session !== void 0) {
        this.session.setIntersectionFilter(typeMask);
      }
    }
    /**
     * Sets whether to filter out terminal intersections if their non-terminal counterparts are also present in this
     * subscription's results and refilters this subscription's latest results accordingly.
     * @param filter Whether to filter out terminal intersections if their non-terminal counterparts are also present in
     * this subscription's results.
     */
    setFilterDupTerminal(filter) {
      if (filter === this.filterDupTerminal) {
        return;
      }
      this.filterDupTerminal = filter;
      this.refilter();
    }
    /** @inheritdoc */
    refilter() {
      this.nonTerminalIcaosToFilter.clear();
      if (this.filterDupTerminal) {
        for (const icao of this.facilityCache.keys()) {
          if (ICAO.isFacility(icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
            this.nonTerminalIcaosToFilter.add(icao);
          }
        }
      }
      if (this.filterCb || this.filterDupTerminal) {
        for (const icao of this.facilityIndex.keys()) {
          if (this.filterCb && !this.filterCb(this.facilityIndex.get(icao)) || this.filterDupTerminal && ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) && this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao)) {
          if ((this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao))) && (!this.filterDupTerminal || !ICAO.isFacility(icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(icao) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao)))) {
            this.addFacility(this.facilityCache.get(icao), icao);
          }
        }
      }
    }
    /** @inheritdoc */
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.nonTerminalIcaosToFilter.delete(results.removed[i]);
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          this.facilityCache.set(fac.icao, fac);
          if (this.filterDupTerminal && ICAO.isFacility(fac.icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(fac) && (this.filterCb === void 0 || this.filterCb(fac))) {
            this.nonTerminalIcaosToFilter.add(fac.icao);
          }
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          if ((this.filterCb === void 0 || this.filterCb(fac)) && (!this.filterDupTerminal || !ICAO.isFacility(fac.icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(fac) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(fac.icao)))) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestVorSubscription = class extends NearestWaypointSubscription {
    /**
     * Creates a new NearestVorSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Vor);
    }
    /**
     * Sets the VOR search filter.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
      if (this.session !== void 0) {
        this.session.setVorFilter(classMask, typeMask);
      }
    }
  };
  var NearestNdbSubscription = class extends NearestWaypointSubscription {
    /**
     * Creates a new NearestNdbSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Ndb);
    }
  };
  var NearestUsrSubscription = class extends NearestWaypointSubscription {
    /**
     * Creates a new NearestUsrSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.User);
    }
  };
  var AdaptiveNearestSubscription = class extends AbstractSubscribableArray {
    /**
     * Creates an instance of AdaptiveNearestSubscription.
     * @param innerSubscription A {@link NearestSubscription} to use as our inner search.
     * @param absoluteMaxItems The maximum number of results to request in any search.
     */
    constructor(innerSubscription, absoluteMaxItems) {
      super();
      this.innerSubscription = innerSubscription;
      this.sortFunc = (a, b) => this.pos.distance(a) - this.pos.distance(b);
      this.facilities = [];
      this.derivedMaxItems = 0;
      this.searchInProgress = false;
      this.pos = new GeoPoint(0, 0);
      this.diffMap = /* @__PURE__ */ new Map();
      this.updatePromiseResolves = [];
      this.absoluteMaxItems = SubscribableUtils.toSubscribable(absoluteMaxItems, true);
    }
    /** @inheritdoc */
    get length() {
      return this.facilities.length;
    }
    /** @inheritdoc */
    getArray() {
      return this.facilities;
    }
    /** @inheritdoc */
    get started() {
      return this.innerSubscription.started;
    }
    /** @inheritdoc */
    awaitStart() {
      return this.innerSubscription.awaitStart();
    }
    /** @inheritdoc */
    start() {
      return this.innerSubscription.start();
    }
    /** @inheritdoc */
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    /**
     * Executes an update of the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      this.pos.set(lat, lon);
      maxItems = Math.max(0, maxItems);
      if (maxItems > this.derivedMaxItems) {
        this.derivedMaxItems = maxItems;
      }
      await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
      if (this.innerSubscription.length > maxItems) {
        this.derivedMaxItems = Math.max(Math.round(this.derivedMaxItems - this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_DOWN_FACTOR), maxItems);
      } else {
        const absoluteMaxItems = this.absoluteMaxItems.get();
        while (this.innerSubscription.length < maxItems && this.derivedMaxItems < absoluteMaxItems) {
          this.derivedMaxItems = Math.min(Math.round(this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_UP_FACTOR), absoluteMaxItems);
          await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
        }
      }
      if (this.innerSubscription.length > maxItems) {
        if (maxItems > 1) {
          const sorted = Array.from(this.innerSubscription.getArray()).sort(this.sortFunc);
          sorted.length = maxItems;
          this.diffAndNotify(sorted);
        } else if (maxItems === 1) {
          this.diffAndNotify([this.findNearest(this.innerSubscription.getArray())]);
        } else {
          this.diffAndNotify(AdaptiveNearestSubscription.EMPTY_ARRAY);
        }
      } else {
        this.diffAndNotify(this.innerSubscription.getArray());
      }
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    findNearest(array) {
      let nearest = array[0];
      let nearestDistance = this.pos.distance(nearest);
      for (let i = 1; i < array.length; i++) {
        const fac = array[i];
        const distance = this.pos.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    /**
     * Diffs a new facility array against this subscription's current facility array, makes the necessary changes to
     * the current facility array so that it contains the same facilities as the new one, and notifies subscribers of the
     * changes.
     * @param newArray A new facility array.
     */
    diffAndNotify(newArray) {
      if (this.facilities.length === 0 && newArray.length === 0) {
        return;
      }
      if (newArray.length === 0) {
        this.facilities.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
        return;
      }
      if (this.facilities.length === 0) {
        for (let i = 0; i < newArray.length; i++) {
          this.facilities[i] = newArray[i];
        }
        this.facilities.length = newArray.length;
        this.notify(0, SubscribableArrayEventType.Added, this.facilities);
        return;
      }
      for (let i = 0; i < newArray.length; i++) {
        this.diffMap.set(newArray[i].icao, newArray[i]);
      }
      for (let i = this.facilities.length - 1; i >= 0; i--) {
        const old = this.facilities[i];
        if (this.diffMap.has(old.icao)) {
          this.diffMap.delete(old.icao);
        } else {
          this.facilities.splice(i, 1);
          this.notify(i, SubscribableArrayEventType.Removed, old);
        }
      }
      for (const toAdd of this.diffMap.values()) {
        this.facilities.push(toAdd);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, toAdd);
      }
      this.diffMap.clear();
    }
  };
  AdaptiveNearestSubscription.RAMP_UP_FACTOR = 1.33;
  AdaptiveNearestSubscription.RAMP_DOWN_FACTOR = 0.1;
  AdaptiveNearestSubscription.EMPTY_ARRAY = [];
  var LodBoundary = class {
    /**
     * Constructor.
     * @param facility This boundary's facility object.
     * @param lodDistanceThresholds The Douglas-Peucker thresholds, in great-arc radians, used by each LOD level. If
     * undefined or an empty array, only one LOD level (LOD0) will be created with a distance threshold of 0.
     * @param lodVectorCountTargets The vector count targets for each LOD level. The number of vectors per shape after
     * simplification will not exceed the LOD levels' target. Non-positive targets are interpreted as unlimited.
     * If undefined, all LOD levels will be assigned an unlimited vector count target.
     */
    constructor(facility, lodDistanceThresholds, lodVectorCountTargets) {
      this.facility = facility;
      this.lodDistanceThresholds = (lodDistanceThresholds === null || lodDistanceThresholds === void 0 ? void 0 : lodDistanceThresholds.length) ? [...lodDistanceThresholds] : [0];
      this.lodVectorCountTargets = lodVectorCountTargets ? [...lodVectorCountTargets] : [];
      this.lods = this.processLods();
    }
    /**
     * Processes this boundary's LOD levels.
     * @returns This boundary's processed LOD levels.
     */
    processLods() {
      var _a;
      const lodShapes = [];
      const originalShapes = this.processShapes(this.facility.vectors);
      if (Array.isArray(this.facility.lods)) {
        lodShapes.push(originalShapes);
        for (let i = 0; i < this.facility.lods.length; i++) {
          lodShapes.push(this.processShapes(this.facility.lods[i]));
        }
      } else {
        let startIndex = 0;
        if (this.lodDistanceThresholds[0] === 0 && ((_a = this.lodVectorCountTargets[0]) !== null && _a !== void 0 ? _a : 0) <= 0) {
          lodShapes.push(originalShapes);
          startIndex = 1;
        }
        const len = this.lodDistanceThresholds.length;
        for (let i = startIndex; i < len; i++) {
          lodShapes.push(this.simplifyShapes(originalShapes, this.lodDistanceThresholds[i], this.lodVectorCountTargets[i]));
        }
      }
      return lodShapes;
    }
    /**
     * Processes this boundary's facility's vectors into boundary shapes.
     * @param vectors The vectors to process.
     * @returns Boundary shapes corresponding to this boundary's facility's vectors.
     */
    processShapes(vectors) {
      const shapes = [];
      const len = vectors.length;
      let index = 0;
      let currentShape;
      while (index < len) {
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            currentShape = [];
            index = this.processShape(currentShape, vectors, index);
            shapes.push(currentShape);
            break;
          case BoundaryVectorType.Circle:
            currentShape = [];
            index = this.processCircle(currentShape, vectors, index - 1);
            shapes.push(currentShape);
            break;
        }
        index++;
      }
      return shapes;
    }
    /**
     * Processes a single, non-circle boundary shape from this boundary's facility's vectors.
     * @param shape The shape to be processed.
     * @param vectors The array containing the facility boundary vectors making up the shape.
     * @param index The index of the first facility boundary vector which makes up the shape.
     * @returns The index of the last facility boundary vector which makes up the shape.
     */
    processShape(shape, vectors, index) {
      const start = vectors[index++];
      shape.push({ end: new GeoPoint(start.lat, start.lon) });
      const origins = [];
      const len = vectors.length;
      while (index < len) {
        const lastEndpoint = shape[shape.length - 1].end;
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            break;
          case BoundaryVectorType.Line:
            if (!lastEndpoint.equals(vector)) {
              shape.push({ circle: GeoCircle.createGreatCircle(lastEndpoint, vector), end: new GeoPoint(vector.lat, vector.lon) });
            }
            break;
          case BoundaryVectorType.Origin:
            origins[vector.originId] = vector;
            break;
          case BoundaryVectorType.ArcCCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const radius = end.distance(origin);
            shape.push({ circle: GeoCircle.createFromPoint(origin, radius), end });
            break;
          }
          case BoundaryVectorType.ArcCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const circle = GeoCircle.createFromPoint(origin, end.distance(origin)).reverse();
            shape.push({ circle, end });
            break;
          }
          case BoundaryVectorType.Circle:
            return index - 1;
        }
        index++;
      }
      return index - 1;
    }
    /**
     * Processes a single circle boundary shape from this boundary's facility's vectors.
     * @param shape The shape to be processed.
     * @param vectors The array containing the facility boundary vectors making up the shape.
     * @param index The index of the first facility boundary vector which makes up the shape.
     * @returns The index of the last facility boundary vector which makes up the shape.
     */
    processCircle(shape, vectors, index) {
      const originVector = vectors[index];
      const circleVector = vectors[index + 1];
      if (originVector.type === BoundaryVectorType.Origin && circleVector.originId === originVector.originId) {
        const radius = UnitType.METER.convertTo(circleVector.radius, UnitType.GA_RADIAN);
        const circle = GeoCircle.createFromPoint(originVector, radius);
        const isCenterPole = circle.center[0] === 0 && circle.center[1] === 0 && Math.abs(circle.center[2]) === 1;
        const end = isCenterPole ? new GeoPoint(0, 0) : new GeoPoint(90, 0);
        circle.closest(end, end);
        shape.push({ end });
        shape.push({ circle, end });
      }
      return index + 1;
    }
    /**
     * Simplifies boundary shapes using the Douglas-Peucker algorithm.
     * @param shapes The boundary shapes to simplify.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shapes. An undefined value is interpreted as
     * an unlimited target.
     * @returns The simplified boundary shapes.
     */
    simplifyShapes(shapes, distanceThreshold, vectorCountTarget) {
      const simplified = [];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        simplified.push(this.simplifyShape(shapes[i], distanceThreshold, vectorCountTarget));
      }
      return simplified;
    }
    /**
     * Simplifies a boundary shape using the Douglas-Peucker algorithm.
     * @param shape The boundary shape to simplify.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shape. An undefined value is interpreted as
     * an unlimited target.
     * @returns The simplified boundary shape.
     */
    simplifyShape(shape, distanceThreshold, vectorCountTarget) {
      if (shape.length < 3) {
        return shape;
      }
      const simplified = [];
      const retain = [];
      retain[0] = true;
      retain[shape.length - 1] = true;
      if (vectorCountTarget === void 0 || vectorCountTarget <= 0) {
        this.simplify(distanceThreshold, shape, 0, shape.length, retain);
      } else {
        this.simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, 0, shape.length, retain);
      }
      this.rebuildSimplifiedVectors(shape, retain, simplified);
      return simplified;
    }
    /**
     * Simplifies a sequence of vectors in a boundary shape using the Douglas-Peucker algorithm.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the first vector in the sequence to simplify, inclusive.
     * @param endIndex The index of the last vector in the sequence to simplify, exclusive.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     */
    simplify(distanceThreshold, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.index < 0) {
        return;
      }
      if (farthest.distance >= distanceThreshold) {
        retain[farthest.index] = true;
        this.simplify(distanceThreshold, shape, startIndex, farthest.index + 1, retain);
        this.simplify(distanceThreshold, shape, farthest.index, endIndex, retain);
      }
    }
    /**
     * Simplifies a sequence of vectors in a boundary shape using the Douglas-Peucker algorithm to a target vector count.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param vectorCountTarget The vector count target for the simplified shape.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the first vector in the sequence to simplify, inclusive.
     * @param endIndex The index of the last vector in the sequence to simplify, exclusive.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     */
    simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const queue = LodBoundary.queue;
      queue.clear();
      let edgeIndex = 0;
      let currentStartIndex = startIndex;
      let currentEndIndex = endIndex;
      let currentFarthestIndex;
      let retainCount = 2;
      while (retainCount < vectorCountTarget) {
        if (currentFarthestIndex === void 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentEndIndex, queue, edgeIndex++);
        } else if (currentFarthestIndex >= 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentFarthestIndex + 1, queue, edgeIndex++);
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentFarthestIndex, currentEndIndex, queue, edgeIndex++);
        }
        if (queue.size === 0) {
          break;
        }
        const edge = queue.removeMin();
        currentStartIndex = edge.startIndex;
        currentEndIndex = edge.endIndex;
        currentFarthestIndex = edge.farthestVectorIndex;
        retain[currentFarthestIndex] = true;
        retainCount++;
      }
    }
    /**
     * Computes an edge and inserts it into a priority queue if the distance from the edge to the farthest vector is
     * greater than a specified distance threshold.
     * @param distanceThreshold The Douglas-Peucker distance threshold, in great-arc radians.
     * @param shape The boundary shape containing the vectors to simplify.
     * @param startIndex The index of the vector at the start of the edge.
     * @param endIndex The index of the vector at the end of the edge.
     * @param queue The priority queue into which to insert the edge.
     * @param edgeIndex The index from which to retrieve an edge from the edge cache, if needed.
     */
    computeAndInsertEdgeToQueue(distanceThreshold, shape, startIndex, endIndex, queue, edgeIndex) {
      var _a;
      var _b;
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.distance >= distanceThreshold) {
        const edge = (_a = (_b = LodBoundary.edgeCache)[edgeIndex]) !== null && _a !== void 0 ? _a : _b[edgeIndex] = LodBoundary.createEdge();
        edge.startIndex = startIndex;
        edge.endIndex = endIndex;
        edge.farthestVectorIndex = farthest.index;
        edge.distanceToFarthestVector = farthest.distance;
        queue.insert(edge);
      }
    }
    /**
     * Finds the vector in a boundary shape containing the farthest point from a reference.
     * @param shape The shape containing the vectors to search.
     * @param startIndex The index of the first vector to search, inclusive.
     * @param endIndex The index of the last vector to search, exclusive.
     * @param reference The reference to which to measure distance.
     * @returns The index of the vector containing the farthest point from a reference, and the corresponding distance in great-arc radians.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    findFarthestVector(shape, startIndex, endIndex, reference) {
      let maxDistance = 0;
      let index = -1;
      for (let i = startIndex; i < endIndex; i++) {
        const distance = this.getDistanceFromReference(shape, i, reference);
        if (distance > maxDistance) {
          index = i;
          maxDistance = distance;
        }
      }
      return { index, distance: maxDistance };
    }
    /**
     * Calculates the maximum distance from a vector in a boundary shape to a reference.
     * @param shape The shape containing the vector to query.
     * @param index The index of the vector to query.
     * @param reference The reference to which to measure the distance.
     * @returns The maximum distance from the vector to the reference, in great-arc radians.
     */
    getDistanceFromReference(shape, index, reference) {
      const vector = shape[index];
      if (!vector.circle) {
        return reference instanceof GeoCircle ? Math.abs(reference.distance(vector.end)) : reference.distance(vector.end);
      } else {
        const center = reference instanceof GeoCircle ? reference.center : reference;
        const arcStart = shape[index - 1].end;
        const maxAngularDist = vector.circle.angleAlong(arcStart, vector.end, Math.PI);
        const projectedAngularDist = vector.circle.angleAlong(arcStart, center, Math.PI);
        const oppositeAngularDist = (projectedAngularDist + Math.PI) % (2 * Math.PI);
        let arcDistance;
        if (oppositeAngularDist > 0 && oppositeAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center) + vector.circle.radius * 2);
          arcDistance = Math.min(arcDistance, 2 * Math.PI - arcDistance);
        } else if (projectedAngularDist > 0 && projectedAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center));
        }
        if (reference instanceof GeoCircle) {
          return arcDistance ? Math.abs(arcDistance - Math.PI / 2) : Math.abs(reference.distance(vector.end));
        } else {
          return arcDistance !== null && arcDistance !== void 0 ? arcDistance : vector.end.distance(reference);
        }
      }
    }
    /**
     * Rebuilds vectors for a simplified shape.
     * @param shape The original shape.
     * @param retain An array of boolean values indicating which vectors in the shape to retain after simplification.
     * @param simplified The simplified shape to which to add the rebuilt vectors.
     */
    rebuildSimplifiedVectors(shape, retain, simplified) {
      var _a;
      let lastRetained;
      const len = shape.length;
      for (let i = 0; i < len; i++) {
        if (!retain[i]) {
          continue;
        }
        const currentVector = shape[i];
        if (currentVector) {
          const prevRetain = retain[i - 1];
          const prevVector = shape[i - 1];
          if (!prevRetain) {
            if (lastRetained) {
              if (currentVector.circle && !currentVector.circle.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, prevVector.end), end: prevVector.end });
                simplified.push(LodBoundary.copyVector(currentVector));
              } else if ((_a = currentVector.circle) === null || _a === void 0 ? void 0 : _a.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, currentVector.end), end: currentVector.end });
              } else {
                simplified.push(LodBoundary.copyVector(currentVector));
              }
            } else {
              simplified.push({ end: currentVector.end });
            }
          } else {
            simplified.push(LodBoundary.copyVector(currentVector));
          }
          lastRetained = currentVector;
        }
      }
    }
    /**
     * Copies a boundary shape vector.
     * @param source The vector to copy.
     * @returns A copy of `source`.
     */
    static copyVector(source) {
      return { circle: source.circle ? new GeoCircle(source.circle.center, source.circle.radius) : void 0, end: source.end.copy() };
    }
    /**
     * Creates an edge.
     * @returns An edge.
     */
    static createEdge() {
      return {
        startIndex: -1,
        endIndex: -1,
        farthestVectorIndex: -1,
        distanceToFarthestVector: 0
      };
    }
  };
  LodBoundary.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  LodBoundary.edgeCache = [];
  LodBoundary.queue = new BinaryHeap((a, b) => b.distanceToFarthestVector - a.distanceToFarthestVector);
  var LodBoundaryCache = class {
    /**
     * Constructor.
     * @param size The maximum size of this cache.
     * @param lodDistanceThresholds The Douglas-Peucker distance thresholds, in great-arc radians, for each LOD level
     * used by this cache's LodBoundary objects.
     * @param lodVectorCountTargets The vector count targets for each LOD level used by this cache's LodBoundary objects.
     */
    constructor(size, lodDistanceThresholds, lodVectorCountTargets) {
      this.size = size;
      this.lodDistanceThresholds = lodDistanceThresholds;
      this.lodVectorCountTargets = lodVectorCountTargets;
      this.cache = /* @__PURE__ */ new Map();
    }
    /**
     * Retrieves a LodBoundary from this cache corresponding to a boundary facility. If the requested LodBoundary does
     * not exist, it will be created and added to this cache.
     * @param facility A boundary facility.
     * @returns The LodBoundary corresponding to `facility`.
     */
    get(facility) {
      const existing = this.cache.get(facility.id);
      if (existing) {
        return existing;
      }
      return this.create(facility);
    }
    /**
     * Creates a new LodBoundary and adds it to this cache.
     * @param facility The facility from which to create the new LodBoundary.
     * @returns The newly created LodBoundary.
     */
    create(facility) {
      const boundary = new LodBoundary(facility, this.lodDistanceThresholds, this.lodVectorCountTargets);
      this.cache.set(facility.id, boundary);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
      return boundary;
    }
  };
  var ArrayTaskQueue = class {
    /**
     * Constructor.
     * @param tasks The array of tasks in this queue.
     */
    constructor(tasks) {
      this.tasks = tasks;
      this.head = 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    hasNext() {
      return this.head < this.tasks.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    next() {
      return this.tasks[this.head++];
    }
  };
  var ThrottledTaskQueueProcess = class {
    /**
     * Constructor.
     * @param queue The queue to process.
     * @param handler A handler which defines the behavior of this process.
     */
    constructor(queue, handler) {
      this.queue = queue;
      this.handler = handler;
      this._hasStarted = false;
      this._hasEnded = false;
      this._shouldAbort = false;
    }
    /**
     * Checks whether this process has been started.
     * @returns whether this process has been started.
     */
    hasStarted() {
      return this._hasStarted;
    }
    /**
     * Checks whether this process has ended.
     * @returns whether this process has ended.
     */
    hasEnded() {
      return this._hasEnded;
    }
    /**
     * Starts this process.
     */
    start() {
      this._hasStarted = true;
      this.processQueue(0);
    }
    /**
     * Processes the queue.
     * @param elapsedFrameCount The number of frames elapsed since queue processing started.
     */
    processQueue(elapsedFrameCount) {
      let dispatchCount = 0;
      const t0 = performance.now();
      while (!this._shouldAbort && this.queue.hasNext()) {
        if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
          const task = this.queue.next();
          task();
          dispatchCount++;
        } else {
          break;
        }
      }
      if (this._shouldAbort) {
        return;
      }
      if (!this.queue.hasNext()) {
        this.handler.onFinished(elapsedFrameCount);
        this._hasEnded = true;
      } else {
        this.handler.onPaused(elapsedFrameCount);
        requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
      }
    }
    /**
     * Aborts this process. Has no effect if the process has not been started or if it has already ended.
     */
    abort() {
      if (this._hasStarted && !this._hasEnded) {
        this.handler.onAborted();
        this._shouldAbort = true;
        this._hasEnded = true;
      }
    }
  };
  var NearestLodBoundarySearchSession = class {
    /**
     * Constructor.
     * @param cache The boundary cache this search session uses.
     * @param session The nearest boundary facility search session this search session uses.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     */
    constructor(cache, session, frameBudget) {
      this.cache = cache;
      this.session = session;
      this.frameBudget = frameBudget;
    }
    /**
     * Searches for the nearest boundaries around a specified location.
     * @param lat The latitude of the search center, in degrees.
     * @param lon The longitude of the search center, in degrees.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items for which to search.
     * @returns The nearest search results.
     */
    async searchNearest(lat, lon, radius, maxItems) {
      const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
      const results = { added: [], removed: facilityResults.removed };
      const tasks = facilityResults.added.map((fac, index) => () => {
        results.added[index] = this.cache.get(fac);
      });
      await new Promise((resolve) => {
        const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
        taskQueue.start();
      });
      return results;
    }
    /**
     * Sets this session's boundary class filter. The new filter takes effect with the next search executed in this
     * session.
     * @param classMask A bitmask defining the boundary classes to include in the search (`0`: exclude, `1`: include).
     * The bit index for each boundary class is equal to the value of the corresponding `BoundaryType` enum.
     */
    setFilter(classMask) {
      this.session.setBoundaryFilter(classMask);
    }
  };
  var NearestLodBoundarySearchTaskQueueHandler = class {
    /**
     * Constructor.
     * @param frameBudget The maximum amount of time allotted per frame to retrieve and process LodBoundary objects, in
     * milliseconds.
     * @param resolve The Promise resolve function this handler will call when the task queue is finished.
     */
    constructor(frameBudget, resolve) {
      this.frameBudget = frameBudget;
      this.resolve = resolve;
    }
    /** @inheritdoc */
    onStarted() {
    }
    /** @inheritdoc */
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
      return timeElapsed < this.frameBudget;
    }
    /** @inheritdoc */
    onPaused() {
    }
    /** @inheritdoc */
    onFinished() {
      this.resolve();
    }
    /** @inheritdoc */
    onAborted() {
    }
  };
  var FlightPathVectorFlags;
  (function(FlightPathVectorFlags2) {
    FlightPathVectorFlags2[FlightPathVectorFlags2["None"] = 0] = "None";
    FlightPathVectorFlags2[FlightPathVectorFlags2["TurnToCourse"] = 1] = "TurnToCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Arc"] = 2] = "Arc";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Direct"] = 4] = "Direct";
    FlightPathVectorFlags2[FlightPathVectorFlags2["InterceptCourse"] = 8] = "InterceptCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["CourseReversal"] = 512] = "CourseReversal";
    FlightPathVectorFlags2[FlightPathVectorFlags2["LegToLegTurn"] = 1024] = "LegToLegTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Fallback"] = 4096] = "Fallback";
  })(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
  var ProcedureDetails = class {
    constructor() {
      this.originRunway = void 0;
      this.departureIndex = -1;
      this.departureTransitionIndex = -1;
      this.departureRunwayIndex = -1;
      this.arrivalIndex = -1;
      this.arrivalTransitionIndex = -1;
      this.arrivalRunwayTransitionIndex = -1;
      this.arrivalRunway = void 0;
      this.approachIndex = -1;
      this.approachTransitionIndex = -1;
      this.destinationRunway = void 0;
    }
  };
  var FlightPlanSegmentType;
  (function(FlightPlanSegmentType2) {
    FlightPlanSegmentType2["Origin"] = "Origin";
    FlightPlanSegmentType2["Departure"] = "Departure";
    FlightPlanSegmentType2["Enroute"] = "Enroute";
    FlightPlanSegmentType2["Arrival"] = "Arrival";
    FlightPlanSegmentType2["Approach"] = "Approach";
    FlightPlanSegmentType2["Destination"] = "Destination";
    FlightPlanSegmentType2["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType2["RandomDirectTo"] = "RandomDirectTo";
  })(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
  var FlightPlanSegment = class {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
      this.segmentIndex = segmentIndex;
      this.offset = offset;
      this.legs = legs;
      this.segmentType = segmentType;
      this.airway = airway;
    }
  };
  FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
  var LegDefinitionFlags;
  (function(LegDefinitionFlags2) {
    LegDefinitionFlags2[LegDefinitionFlags2["None"] = 0] = "None";
    LegDefinitionFlags2[LegDefinitionFlags2["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags2[LegDefinitionFlags2["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags2[LegDefinitionFlags2["Obs"] = 4] = "Obs";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
  })(LegDefinitionFlags || (LegDefinitionFlags = {}));
  var VerticalFlightPhase;
  (function(VerticalFlightPhase2) {
    VerticalFlightPhase2["Climb"] = "Climb";
    VerticalFlightPhase2["Descent"] = "Descent";
  })(VerticalFlightPhase || (VerticalFlightPhase = {}));
  var SpeedUnit;
  (function(SpeedUnit2) {
    SpeedUnit2[SpeedUnit2["IAS"] = 0] = "IAS";
    SpeedUnit2[SpeedUnit2["MACH"] = 1] = "MACH";
  })(SpeedUnit || (SpeedUnit = {}));
  var SpeedRestrictionType;
  (function(SpeedRestrictionType2) {
    SpeedRestrictionType2[SpeedRestrictionType2["Unused"] = 0] = "Unused";
    SpeedRestrictionType2[SpeedRestrictionType2["At"] = 1] = "At";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType2[SpeedRestrictionType2["Between"] = 4] = "Between";
  })(SpeedRestrictionType || (SpeedRestrictionType = {}));
  var FlightPathUtils = class {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
      return {
        vectorType: "circle",
        flags: FlightPathVectorFlags.None,
        radius: 0,
        centerX: 1,
        centerY: 0,
        centerZ: 0,
        startLat: 0,
        startLon: 0,
        endLat: 0,
        endLon: 0,
        distance: 0
      };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
      vector.flags = flags;
      vector.radius = circle.radius;
      vector.centerX = circle.center[0];
      vector.centerY = circle.center[1];
      vector.centerZ = circle.center[2];
      vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
      start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
      end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
      vector.startLat = start.lat;
      vector.startLon = start.lon;
      vector.endLat = end.lat;
      vector.endLon = end.lon;
      return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
      return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
      return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector) {
      return vector.radius > MathUtils.HALF_PI ? "right" : "left";
    }
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector) {
      return Math.min(vector.radius, Math.PI - vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg, point, magVarFacility) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      const magVar = magVarFacility ? -magVarFacility.magneticVariation : Facilities.getMagVar(point.lat, point.lon);
      return NavMath.normalizeHeading(leg.course + magVar);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
      if (legCalc.endLat !== void 0 && legCalc.endLon !== void 0) {
        return out.set(legCalc.endLat, legCalc.endLon);
      }
      return void 0;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
      if (legCalc.flightPath.length > 0) {
        const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
        return this.getVectorFinalCourse(vector);
      }
      return void 0;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
      out.set(center, radius);
      if (turnDirection === "right") {
        out.reverse();
      }
      return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
      return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
      return circle.radius > MathUtils.HALF_PI ? "right" : "left";
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
      return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
      return circle.radius > MathUtils.HALF_PI ? out instanceof Float64Array ? Vec3Math.multScalar(circle.center, -1, out) : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2]) : out instanceof Float64Array ? Vec3Math.copy(circle.center, out) : out.setFromCartesian(circle.center);
    }
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
      }
      const radius = turnDirection === "left" ? turnRadius : Math.PI - turnRadius;
      const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
      const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
      return out.set(turnCenter, radius);
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      return circle.arcLength((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
        return posAngularDistance >= Math.PI ? -Infinity : Infinity;
      }
      return ((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angularTolerance = circle.angularWidth(tolerance);
      if (typeof end !== "number") {
        end = circle.angleAlong(start, end, Math.PI, angularTolerance);
      }
      if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
        return true;
      }
      const angle = circle.angleAlong(start, pos, Math.PI);
      if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
        return true;
      }
      const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
      return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static projectVelocityToCircle(speed, position, direction, projectTo) {
      if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      if (speed === 0) {
        return 0;
      }
      if (!(position instanceof Float64Array)) {
        position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
      }
      const velocityPath = typeof direction === "number" ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction) : direction.isGreatCircle() ? direction : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
      const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
      const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
      const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
      const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
      const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
      return speed * sinTheta * sign;
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
      var _a, _b, _c, _d, _e, _f;
      var _g, _h, _j, _k, _l, _m;
      const vectors = legCalc.ingressToEgress;
      let vectorIndex = 0;
      let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
      const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
      const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
      const firstEgressVector = legCalc.egress[0];
      const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
      if (lastIngressVector && ingressJoinVector) {
        const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
        const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
        const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon) : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
        const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
        const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
        if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
          if (ingressEndAlongVectorDistance > normalizedTolerance) {
            ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
            FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : vectors[_g] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
          } else {
            Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : vectors[_h] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVector);
          }
        }
        flightPathVectorIndex++;
      }
      const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
      for (let i = flightPathVectorIndex; i < end; i++) {
        Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : vectors[_j] = FlightPathUtils.createEmptyCircleVector(), legCalc.flightPath[i]);
        flightPathVectorIndex++;
      }
      if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
        if (firstEgressVector) {
          const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
          const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
          const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
          const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
          const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
          const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
          if (egressStartAlongVectorDistance > normalizedTolerance) {
            if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
              egressJoinVectorCircle.closest(egressStart, egressStart);
              FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : vectors[_k] = FlightPathUtils.createEmptyCircleVector(), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
            } else {
              Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : vectors[_l] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
            }
          }
        } else {
          Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : vectors[_m] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
        }
      }
      vectors.length = vectorIndex;
      return legCalc;
    }
  };
  FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var CircleVectorBuilder = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
      if (args[0] instanceof GeoCircle) {
        this.setFromCircle(vectors, index, ...args);
      } else {
        this.setFromPoints(vectors, index, ...args);
      }
      return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
      return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
      var _a;
      const vector = ((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === "circle" ? vectors[index] : vectors[index] = FlightPathUtils.createEmptyCircleVector();
      return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
  };
  CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var GreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
      if (pathArg instanceof GeoCircle) {
        return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
      } else {
        return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
      }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
      const startPoint = start instanceof Float64Array ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start) : GreatCircleBuilder.geoPointCache[0].set(start);
      const endPoint = end instanceof Float64Array ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end) : GreatCircleBuilder.geoPointCache[1].set(end);
      const distance = startPoint.distance(endPoint);
      const path = GreatCircleBuilder.geoCircleCache[0];
      if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
        if (initialCourse === void 0) {
          throw new Error("GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.");
        } else {
          path.setAsGreatCircle(start, initialCourse);
        }
      } else {
        path.setAsGreatCircle(start, end);
      }
      return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
      if (!path.isGreatCircle()) {
        throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
      }
      const end = typeof endArg === "number" ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI) : endArg;
      return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
  };
  GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
  GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var TurnToCourseBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
      if (start instanceof Float64Array) {
        start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
      }
      const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === "left" ? -90 : 90), radiusRad);
      const turnStartBearing = turnCenterPoint.bearingTo(start);
      const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
      if (turnEndPoint.equals(start)) {
        return 0;
      }
      return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
  };
  TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var CircleInterceptBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
      if (circle.includes(start)) {
        return 0;
      }
      let startPath;
      if (pathArg instanceof GeoCircle) {
        if (!pathArg.includes(start)) {
          throw new Error("CircleInterceptBuilder: the starting point does not lie on the starting path.");
        }
        startPath = pathArg;
      } else {
        startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
      }
      const intersections = CircleInterceptBuilder.intersectionCache;
      const numIntersections = startPath.intersection(circle, intersections);
      if (numIntersections === 0) {
        return 0;
      }
      const intersectionIndex = numIntersections === 1 || circle.encircles(start) ? 0 : 1;
      const endVec = intersections[intersectionIndex];
      return startPath.isGreatCircle() ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags) : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
  };
  CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
      if (!endPath.isGreatCircle()) {
        throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
      }
      let startPath;
      if (startPathArg instanceof GeoCircle) {
        if (!startPathArg.isGreatCircle()) {
          throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
        } else if (!startPathArg.includes(start)) {
          throw new Error("TurnToJoinPathBuilder: the starting point does not lie on the starting path.");
        }
        startPath = startPathArg;
      } else {
        startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
      }
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
      }
      const turnDirection = endPath.encircles(start) ? "left" : "right";
      const radiusRad = turnDirection === "left" ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
      const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
      const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === "left" ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
  };
  TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var ConnectCirclesBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path which consists of a single geo circle which connects two other
     * circles and optionally paths to link the connecting circle with a start point on the from circle and an end point
     * on the to circle.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param fromCircle The circle from which to add the connecting circle.
     * @param toCircle The circle to which to add the connecting circle.
     * @param radius The radius, in meters, of the circle to join the two circles. If not defined, defaults to pi / 2
     * times the radius of the Earth (and therefore the connecting circle will be a great circle).
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @param fromCircleVectorFlags The flags to set on the vector along `fromCircle`. Defaults to none (0).
     * @param toCircleVectorFlags The flags to set on the vector along the `toCircle`. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector connecting `fromCircle` to `toCircle`. Defaults to none
     * (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, fromCircle, toCircle, radius, from, to, fromCircleVectorFlags = 0, toCircleVectorFlags = 0, connectVectorFlags = 0) {
      if (radius === 0) {
        return 0;
      }
      const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
      if (angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius || Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE) {
        return 0;
      }
      if (from && !(from instanceof Float64Array)) {
        from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
      }
      if (to && !(to instanceof Float64Array)) {
        to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
      }
      const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
      const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
      if (!joinCircle) {
        return 0;
      }
      let vectorIndex = index;
      const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
      const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
      if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart, fromCircleVectorFlags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd, connectVectorFlags);
      if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to, toCircleVectorFlags);
      }
      return vectorIndex - index;
    }
    /**
     * Finds a GeoCircle which connects (is tangent to) two other circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param radius The desired radius of the connecting circle, in great-arc radians.
     * @param out A GeoCircle object to which to write the result.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns a GeoCircle which connects the two circles, or null if one could not be found.
     */
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
      const solutions = [];
      const intersections = ConnectCirclesBuilder.intersectionCache;
      const leftTurnRadius = radius;
      let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
      let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
      let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
      let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
      const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
      if (numLeftTurnSolutions === 1) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
      } else if (numLeftTurnSolutions === 2) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
      }
      if (radius !== Math.PI / 2) {
        const rightTurnRadius = Math.PI - radius;
        fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
        toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
        fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
        toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
        const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numRightTurnSolutions === 1) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
        } else if (numRightTurnSolutions === 2) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
          solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
        }
      }
      if (solutions.length === 0) {
        return null;
      } else if (solutions.length === 1) {
        return out.set(solutions[0].center, solutions[0].radius);
      } else {
        let circle = solutions[0];
        let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
        for (let i = 1; i < solutions.length; i++) {
          const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
          if (distance < minDistance) {
            circle = solutions[i];
            minDistance = distance;
          }
        }
        return out.set(circle.center, circle.radius);
      }
    }
    /**
     * Calculates the total distance along the joining path between two circles.
     * @param fromCircle The circle at the beginning of the connecting circle.
     * @param toCircle The circle at the end of the connecting circle.
     * @param joinCircle The connecting circle.
     * @param from The starting point along `fromCircle`. If not defined, this will be assumed to be equal to the
     * point where the connecting circle meets `fromCircle`.
     * @param to The ending point along `toCircle`. If not defined, this will be assumed to be equal to the point where
     * the connecting circle meets `toCircle`.
     * @returns the total distance along the joining path, in great-arc radians.
     */
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
      let distance = 0;
      const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
      const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
      if (from) {
        distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
      }
      distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
      if (to) {
        distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
      }
      return distance;
    }
  };
  ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleAtPointBuilder = class {
    constructor() {
      this.connectCirclesBuilder = new ConnectCirclesBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * connects with another turn via a great-circle path to terminate at a defined end point and final course.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters.
     * @param endTurnDirection The direction of the final turn.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0).
     * @param connectVectorFlags The flags to set on the vector along the great-circle path connecting the turns.
     * Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, end, endPath, endTurnRadius, endTurnDirection, startTurnVectorFlags = 0, endTurnVectorFlags = 0, connectVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[1]);
      }
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      const startTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
      const startTurnCircleRadiusRad = startTurnDirection === "left" ? startTurnRadiusRad : Math.PI - startTurnRadiusRad;
      const startTurnCircleCenter = startTurnOffsetPath.offsetDistanceAlong(start, startTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const startTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].set(startTurnCircleCenter, startTurnCircleRadiusRad);
      const endTurnRadiusRad = UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      const endTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
      const endTurnCircleRadiusRad = endTurnDirection === "left" ? endTurnRadiusRad : Math.PI - endTurnRadiusRad;
      const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const endTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
      return this.connectCirclesBuilder.build(vectors, index, startTurnCircle, endTurnCircle, void 0, start, end, startTurnVectorFlags, endTurnVectorFlags, connectVectorFlags);
    }
  };
  TurnToJoinGreatCircleAtPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleAtPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var InterceptGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
      }
      const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
      if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
      const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
      const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      if (startTurnDirection === void 0) {
        const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
        if (interceptCount === 0) {
          startTurnDirection = startPath.encircles(end) ? "left" : "right";
        } else {
          let intersectionIndex = 0;
          if (interceptCount > 1) {
            intersectionIndex = endPath.encircles(start) ? 0 : 1;
          }
          let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
          if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
            cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
              startTurnDirection = "right";
            } else {
              startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? "left" : "right";
            }
          } else {
            startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? "left" : "right";
          }
        }
      }
      const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
      const endTurnRadiusRad = endTurnRadius === void 0 ? void 0 : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        const startTurnEnd2 = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd2, end, Math.PI);
        if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd2, startTurnVectorFlags);
      }
      const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
      const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
      if (interceptPathCount === 0) {
        return 0;
      }
      const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
      let interceptCrossSign;
      if (startToEndPathAngleRad >= interceptAngleRad) {
        const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
        const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
        interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
        interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === "right") ? 1 : -1;
      } else {
        interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
        interceptCrossSign = startTurnDirection === "right" ? 1 : -1;
      }
      const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
      const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
      const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      let minDInterceptEnd = 0;
      if (endTurnRadiusRad !== void 0) {
        const endTheta = Math.PI - interceptAngleRad;
        minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
        if (isNaN(minDInterceptEnd)) {
          return 0;
        }
      }
      const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
      if (interceptToEndOffset < minDInterceptEnd) {
        return 0;
      }
      let vectorIndex = index;
      if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
        if (endTurnRadiusRad === void 0) {
          const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
          if (startTurnEndPathIntersectionCount === 0) {
            return 0;
          }
          const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === "right" ? 0 : 1];
          if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
        } else {
          const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
          const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === "left" ? 1 : -1));
          const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
          if (endTurnCircleCount === 0) {
            return 0;
          }
          const endTurnCenter = intersections[0];
          const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === "left" ? "right" : "left", InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
          endTurnCircle.closest(startTurnCenter, startTurnEnd);
          const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
        }
      } else {
        if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        let interceptPathEnd = intercept;
        if (endTurnRadiusRad !== void 0) {
          interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
        }
        if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
        }
        if (endTurnRadius !== void 0) {
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
        }
      }
      return vectorIndex - index;
    }
  };
  InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var JoinGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
      this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
      }
      if (!intersection) {
        const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
        const solutionCount = startPath.intersection(endPath, intersections);
        if (solutionCount === 0) {
          return 0;
        }
        intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0 ? intersections[0] : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
      const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
      const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const isEndForwardOfIntersection = intersectionToEndSign > 0;
      minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : minTurnRadius = 0;
      const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
      const pathDot = Vec3Math.dot(startPath.center, endPath.center);
      const theta = Math.acos(-pathDot);
      const tanHalfTheta = Math.tan(theta / 2);
      let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
      if (isNaN(minD)) {
        minD = Infinity;
      }
      const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
      const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
      const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
      const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
      const towardEndPointTurnDirection = startPath.encircles(end, false) ? "left" : "right";
      let needCalculateTwoTurnPath = false;
      let needCalculateOneTurnPath = false;
      if (isEndForwardOfIntersection) {
        if (desiredTurnDirection === void 0 || desiredTurnDirection === towardEndPointTurnDirection) {
          const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
          const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
          if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          } else {
            const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
            if (intersectionStartDistance <= intersectionEndDistance) {
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
              if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
              }
            } else {
              let turnStart = start;
              if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
              }
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
            }
          }
        } else {
          if (pathDot >= 0) {
            if (intersectionStartOffset <= minD) {
              needCalculateOneTurnPath = true;
            } else {
              needCalculateTwoTurnPath = !preferSingleTurn;
              needCalculateOneTurnPath = preferSingleTurn;
            }
          } else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          }
        }
      } else {
        needCalculateTwoTurnPath = !preferSingleTurn;
        needCalculateOneTurnPath = preferSingleTurn;
      }
      let needDirectFallback = false;
      if (needCalculateTwoTurnPath) {
        const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
        const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, void 0, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
        if (numInterceptVectors === 0) {
          needDirectFallback = allowDirectFallback;
        } else {
          vectorIndex += numInterceptVectors;
          const lastVector = vectors[vectorIndex - 1];
          const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
          if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
          }
        }
      } else if (needCalculateOneTurnPath) {
        minD = Math.min(minD, Math.PI / 2);
        if (minD > Math.PI / 2) {
          needDirectFallback = allowDirectFallback;
        } else {
          const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
          const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
          const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
          const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
          if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
          }
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
          if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
          }
        }
      }
      if (needDirectFallback) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
      }
      return vectorIndex - index;
    }
  };
  JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45;
  JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var ProcedureTurnBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
      }
      initialCourse !== null && initialCourse !== void 0 ? initialCourse : initialCourse = startPath.bearingAt(start, Math.PI);
      finalCourse !== null && finalCourse !== void 0 ? finalCourse : finalCourse = endPath.bearingAt(end, Math.PI);
      const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
      const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
      const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === "left");
      const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
      const thetaOutbound = (Math.PI - deltaOutbound) / 2;
      const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : initialTurnDirection === "left" === deltaOutbound < Math.PI ? "right" : "left";
      const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
      let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10 ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1) : 0;
      desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound)) * (isInitialTurnTowardEndPath ? 1 : -1);
      const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
      let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
      desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
      desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
      const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
      const initialTurnStartPoint = alongStartPathDistance > 0 ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1]) : startPoint;
      const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
      const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
      const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
      const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === "left" ? -1 : 1));
      const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
      const turnStartPoint = alongTurnOutboundPathDistance > 0 ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4]) : initialTurnEndPoint;
      const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
      const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
      let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
      const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
      let finalTurnDirection;
      let finalTurnRadius;
      let finalTurnStartPoint;
      let finalTurnCenterPoint;
      let finalTurnEndPoint;
      let endPoint;
      if (endPath.encircles(turnEndVec) === (initialTurnDirection === "left")) {
        const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnCircle.intersection(endPath, intersections);
        if (numIntersections === 0) {
          endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
        } else {
          if (numIntersections === 2) {
            const headingAdjustment = turnDirection === "left" ? -90 : 90;
            const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
          } else {
            turnEndPoint.setFromCartesian(intersections[0]);
          }
          turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
        }
      } else {
        const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
        const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnInboundPath.intersection(endPath, intersections);
        if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
          const intersection = intersections[numIntersections === 1 || endPath.encircles(turnEndVec) ? 0 : 1];
          if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
            const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
            const thetaInbound = (Math.PI - deltaInbound) / 2;
            const tanThetaInbound = Math.tan(thetaInbound);
            const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
            const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
            const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance ? desiredTurnRadiusRad : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
            finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
            finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
            finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
            finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === "left" ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
            finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
          }
        }
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      if (initialTurnStartPoint !== startPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
      if (turnStartPoint !== initialTurnEndPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
      if (finalTurnCenterPoint) {
        if (!finalTurnStartPoint.equals(turnEndPoint)) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, void 0, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
      } else {
        if (endPoint) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, void 0, flags);
        }
      }
      return vectorIndex - index;
    }
  };
  ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0)
  ];
  ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var DirectToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
      let vectorIndex = index;
      if (typeof startPath === "number") {
        startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
      }
      const endPos = DirectToPointBuilder.geoPointCache[0];
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        endPos.set(end);
        end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
      } else {
        endPos.setFromCartesian(end);
      }
      const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
      if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
        return vectorIndex - index;
      } else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
        return vectorIndex - index;
      }
      const startPathEncirclesTerminator = startPath.encircles(end);
      const startPathIncludesTerminator = startPath.includes(end);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPathEncirclesTerminator && !startPathIncludesTerminator ? "left" : "right";
      const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === "left" ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2]) : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
      let maxTurnRadiusRad;
      if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === "left")) {
        const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
        const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
        maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
      } else {
        maxTurnRadiusRad = Math.PI / 2;
      }
      const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
      const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
      const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
      const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
      const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
      const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
      const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === "left" ? -1 : 1) + 180);
      const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
      const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
      flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
      if (!GeoPoint.equals(turnEndVec, start)) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
      }
      if (!GeoPoint.equals(turnEndVec, end)) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, void 0, flags);
      }
      return vectorIndex - index;
    }
  };
  DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var AbstractFlightPathLegCalculator = class {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
      this.facilityCache = facilityCache;
      this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
      const facility = this.facilityCache.get(icao);
      return facility ? out.set(facility) : void 0;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
      if (leg.lat !== void 0 && leg.lon !== void 0) {
        return out.set(leg.lat, leg.lon);
      } else {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility.lat, facility.lon) : void 0;
      }
    }
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    getLegMagVar(leg, point) {
      const facIcao = leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR) ? leg.originIcao : leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR) ? leg.fixIcao : void 0;
      const facility = facIcao !== void 0 ? this.facilityCache.get(facIcao) : void 0;
      return facility === void 0 ? MagVar.get(point) : -facility.magneticVariation;
    }
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
      var _a, _b, _c;
      var _d;
      const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : _d.calculated = {
        courseMagVar: 0,
        startLat: void 0,
        startLon: void 0,
        endLat: void 0,
        endLon: void 0,
        distance: 0,
        distanceWithTransitions: 0,
        initialDtk: void 0,
        cumulativeDistance: 0,
        cumulativeDistanceWithTransitions: 0,
        flightPath: [],
        ingress: [],
        ingressJoinIndex: -1,
        ingressToEgress: [],
        egressJoinIndex: -1,
        egress: [],
        endsInFallback: false
      };
      const vectors = calcs.flightPath;
      if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
        state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
        state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
        state.isFallback = calcs.endsInFallback;
        return calcs;
      }
      try {
        this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
        this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
        resolveIngressToEgress && this.resolveIngressToEgress(calcs);
        calcs.endsInFallback = state.isFallback;
      } catch (e) {
        console.error(e);
        if (e instanceof Error) {
          console.error(e.stack);
        }
        vectors.length = 0;
        calcs.ingress.length = 0;
        calcs.ingressJoinIndex = 0;
        calcs.egress.length = 0;
        calcs.egressJoinIndex = -1;
        calcs.ingressToEgress.length = 0;
        calcs.endsInFallback = false;
        state.isFallback = false;
      }
      return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
      return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
      FlightPathUtils.resolveIngressToEgress(legCalc);
    }
  };
  var NoPathLegCalculator = class extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      legs[calculateIndex].calculated.courseMagVar = 0;
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      legs[calculateIndex].calculated.flightPath.length = 0;
      state.currentCourse = void 0;
      state.currentPosition = void 0;
      state.isFallback = false;
    }
  };
  var TrackToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, false);
      this.geoPointCache = [new GeoPoint(0, 0)];
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b;
      const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
      if (!terminatorPos) {
        vectors.length = 0;
        state.isFallback = false;
        return;
      }
      (_b = state.currentPosition) !== null && _b !== void 0 ? _b : state.currentPosition = terminatorPos.copy();
      const distance = state.currentPosition.distance(terminatorPos);
      if ((!prevLeg || prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM) && distance > GeoPoint.EQUALITY_TOLERANCE) {
        if (state.isFallback && state.currentCourse !== void 0) {
          vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), void 0, FlightPathVectorFlags.Fallback);
        } else {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
        }
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
      }
      state.currentPosition.set(terminatorPos);
      vectors.length = vectorIndex;
      state.isFallback = false;
    }
  };
  var DirectToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a;
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
      if (!terminatorPos) {
        vectors.length = 0;
        return;
      }
      (_a = state.currentPosition) !== null && _a !== void 0 ? _a : state.currentPosition = terminatorPos.copy();
      const startPoint = this.geoPointCache[0].set(state.currentPosition);
      let initialCourse;
      if (leg.course !== 0) {
        initialCourse = leg.trueDegrees ? leg.course % 360 : MagVar.magneticToTrue(leg.course, startPoint);
      } else {
        if (state.currentCourse === void 0) {
          const prevLeg = legs[calculateIndex - 1];
          switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) {
            case LegType.CA:
            case LegType.CF:
            case LegType.CR:
            case LegType.FA:
            case LegType.FC:
            case LegType.FD:
            case LegType.FM:
            case LegType.VA:
            case LegType.VD:
            case LegType.VM:
            case LegType.VR:
            case LegType.HF:
            case LegType.HM:
            case LegType.HA:
              initialCourse = this.getLegTrueCourse(prevLeg.leg, startPoint);
              break;
            case LegType.IF:
              if (ICAO.isFacility(prevLeg.leg.fixIcao, FacilityType.RWY)) {
                const runwayFix = this.facilityCache.get(prevLeg.leg.fixIcao);
                if (runwayFix) {
                  initialCourse = runwayFix.runway.course;
                  break;
                }
              }
            default:
              initialCourse = startPoint.bearingTo(terminatorPos);
              if (isNaN(initialCourse)) {
                initialCourse = 0;
              }
          }
        } else {
          initialCourse = state.currentCourse;
        }
      }
      const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
      vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : void 0);
      state.currentPosition.set(terminatorPos);
      if (vectorIndex > 0) {
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
      }
      vectors.length = vectorIndex;
    }
  };
  var TurnToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, false);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b;
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
      const turnCenter = this.getTurnCenter(leg);
      if (!terminatorPos || !turnCenter) {
        vectors.length = vectorIndex;
        return;
      }
      if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
        const direction = leg.turnDirection === LegTurnDirection.Left ? "left" : "right";
        const radius = this.getTurnRadius(leg, turnCenter);
        if (radius) {
          const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
          const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
          const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
          state.currentCourse = circle.bearingAt(terminatorVec);
          const turnVector = vectors[vectorIndex - 1];
          ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : state.currentPosition = new GeoPoint(0, 0)).set(turnVector.endLat, turnVector.endLon);
        }
      }
      (_b = state.currentPosition) !== null && _b !== void 0 ? _b : state.currentPosition = terminatorPos.copy();
      vectors.length = vectorIndex;
    }
  };
  var RadiusToFixLegCalculator = class extends TurnToFixLegCalculator {
    constructor() {
      super(...arguments);
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    /** @inheritdoc */
    getTurnCenter(leg) {
      return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    /** @inheritdoc */
    getTurnRadius(leg, center) {
      var _a;
      return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
  };
  var ArcToFixLegCalculator = class extends TurnToFixLegCalculator {
    /** @inheritdoc */
    getTurnCenter(leg) {
      return this.facilityCache.get(leg.originIcao);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
      return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
  };
  var CircleInterceptLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
      super(facilityCache, true);
      this.includeInitialTurn = includeInitialTurn;
      this.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
      this.geoPointCache = [new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
      this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
      this.turnBuilder = new TurnToCourseBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
      this.interceptBuilder = new CircleInterceptBuilder();
      this.interceptInfo = {
        circle: void 0,
        start: void 0,
        end: void 0
      };
      this.handleInvalidInterceptCache = {
        vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
        geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
        intersection: [new Float64Array(3), new Float64Array(3)]
      };
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a;
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const course = this.getInterceptCourse(legs, calculateIndex, state);
      const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
      if (course === void 0 || !interceptInfo.circle || !state.currentPosition) {
        vectors.length = vectorIndex;
        return;
      }
      const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
      const effectiveInterceptPathStartVec = interceptInfo.start ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0]) : interceptInfo.end ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI) : void 0;
      const effectiveInterceptPathEndVec = interceptInfo.end ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1]) : interceptInfo.start ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI) : void 0;
      const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI) : effectiveInterceptPathStartVec ? Math.PI : MathUtils.TWO_PI;
      const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
      const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
      const interceptPathStartVec = Vec3Math.copy(initialVec, this.vec3Cache[3]);
      let initialTurnVector = void 0;
      if (includeInitialTurn) {
        const turnDirection = leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : NavMath.getTurnDirection(startCourse, course);
        vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
        initialTurnVector = vectors[vectorIndex - 1];
        GeoPoint.sphericalToCartesian(initialTurnVector.endLat, initialTurnVector.endLon, interceptPathStartVec);
      }
      const interceptPath = this.geoCircleCache[0].setAsGreatCircle(interceptPathStartVec, course);
      const startPath = this.geoCircleCache[1].set(interceptPath.center, interceptPath.radius);
      let fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, initialTurnVector !== void 0, false, this.vec3Cache[4]);
      if (initialTurnVector !== void 0) {
        if (fallbackInterceptVec === void 0) {
          fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, false, this.vec3Cache[4]);
        } else {
          const turnCircle = FlightPathUtils.setGeoCircleFromVector(initialTurnVector, this.geoCircleCache[2]);
          const intersections = this.intersectionCache;
          const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
          if (numIntersections > 1) {
            if (interceptInfo.circle.radius > MathUtils.HALF_PI !== interceptInfo.circle.encircles(initialVec)) {
              const temp = intersections[0];
              intersections[0] = intersections[1];
              intersections[1] = temp;
            }
          }
          for (let i = 0; i < numIntersections; i++) {
            const intersection = intersections[i];
            if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, interceptPathStartVec, intersection) && (!effectiveInterceptPathStartVec || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
              const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
              if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                initialTurnVector.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                initialTurnVector.endLat = intersectionPoint.lat;
                initialTurnVector.endLon = intersectionPoint.lon;
                state.currentPosition.set(initialTurnVector.endLat, initialTurnVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(initialTurnVector);
              } else {
                vectorIndex--;
              }
              vectors.length = vectorIndex;
              return;
            }
          }
          vectorIndex = 0;
          Vec3Math.copy(initialVec, interceptPathStartVec);
          interceptPath.setAsGreatCircle(interceptPathStartVec, course);
          startPath.setAsGreatCircle(interceptPathStartVec, startCourse);
          fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, true, this.vec3Cache[4]);
        }
      }
      if (fallbackInterceptVec === void 0) {
        vectorIndex += this.interceptBuilder.build(vectors, vectorIndex, interceptPathStartVec, course, interceptInfo.circle);
      } else {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, interceptPathStartVec, startPath, fallbackInterceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), void 0, FlightPathVectorFlags.Fallback);
      }
      if (vectorIndex > 0) {
        const lastVector = vectors[vectorIndex - 1];
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
      }
      vectors.length = vectorIndex;
    }
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    calculateFallbackIntercept(start, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, onlyHandleInitialPointPastIntercept, forceFallback, out) {
      if (pathToInterceptCircle.includes(start)) {
        if (pathToInterceptAngularWidth === MathUtils.TWO_PI || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
          return forceFallback ? Vec3Math.copy(start, out) : void 0;
        }
      }
      let isInitialPosPastPath = false;
      const intersections = this.handleInvalidInterceptCache.intersection;
      const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
      let desiredIntersection;
      if (numIntersections === 2) {
        const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
        const prevIntersectionIndex = 1 - nextIntersectionIndex;
        const nextIntersection = intersections[nextIntersectionIndex];
        const prevIntersection = intersections[prevIntersectionIndex];
        if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
          isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
        } else {
          const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
          const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
          const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
          const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
          let prevIntersectionInterceptPathDistance = 0;
          let nextIntersectionInterceptPathDistance = 0;
          if (pathToInterceptStart && pathToInterceptEnd) {
            if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
              const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
              const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
              prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
            }
            if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
              const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
              const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
              nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
            }
          }
          const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
          const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
          if (pathToInterceptStart !== void 0 && pathToInterceptEnd !== void 0 || (prevIntersectionTotalDistance >= MathUtils.HALF_PI || nextIntersectionTotalDistance >= MathUtils.HALF_PI)) {
            isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
          }
        }
        desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
      } else if (numIntersections === 1) {
        const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
        isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
        desiredIntersection = intersections[0];
      }
      if (onlyHandleInitialPointPastIntercept && !isInitialPosPastPath) {
        return void 0;
      }
      let needHandleFallback = isInitialPosPastPath;
      if (!desiredIntersection) {
        desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
        needHandleFallback = true;
      }
      let fallbackIntercept;
      if (!pathToInterceptStart || !pathToInterceptEnd || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
        if (needHandleFallback || forceFallback) {
          fallbackIntercept = desiredIntersection;
        }
      } else {
        const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
        const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
        const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
        fallbackIntercept = distanceFromStart <= distanceFromEnd ? pathToInterceptStart : pathToInterceptEnd;
      }
      return fallbackIntercept === void 0 ? void 0 : Vec3Math.copy(fallbackIntercept, out);
    }
  };
  var CourseToDmeLegCalculator = class extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const dmeFacility = this.facilityCache.get(leg.leg.originIcao);
      leg.calculated.courseMagVar = dmeFacility === void 0 ? 0 : this.getLegMagVar(leg.leg, dmeFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
      const leg = legs[index].leg;
      const dmeFacility = this.facilityCache.get(leg.originIcao);
      return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : void 0;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
      const leg = legs[index].leg;
      const dmeFacility = this.facilityCache.get(leg.originIcao);
      if (dmeFacility) {
        this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        out.circle = this.dmeCircle;
        out.start = void 0;
        out.end = void 0;
      } else {
        out.circle = void 0;
        out.start = void 0;
        out.end = void 0;
      }
      return out;
    }
  };
  var CourseToRadialLegCalculator = class extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const radialFacility = this.facilityCache.get(leg.leg.originIcao);
      leg.calculated.courseMagVar = radialFacility === void 0 ? 0 : this.getLegMagVar(leg.leg, radialFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
      const leg = legs[index].leg;
      const radialFacility = this.facilityCache.get(leg.originIcao);
      return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : void 0;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
      const leg = legs[index].leg;
      const radialFacility = this.facilityCache.get(leg.originIcao);
      if (radialFacility) {
        const magVar = ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR ? -radialFacility.magneticVariation : MagVar.get(radialFacility);
        this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
        out.circle = this.radialCircle;
        out.start = radialFacility;
        out.end = void 0;
      } else {
        out.circle = void 0;
        out.start = void 0;
        out.end = void 0;
      }
      return out;
    }
  };
  var CourseToInterceptLegCalculator = class extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.predictLegPathCache = {
        geoPoint: [new GeoPoint(0, 0)],
        geoCircle: [new GeoCircle(new Float64Array(3), 0)]
      };
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
      const leg = legs[calculateIndex];
      leg.calculated.courseMagVar = state.currentPosition === void 0 ? 0 : this.getLegMagVar(leg.leg, state.currentPosition);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
      const leg = legs[index].leg;
      return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : void 0;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
      return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
      var _a;
      out.circle = void 0;
      out.start = void 0;
      out.end = void 0;
      const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
      if (!leg) {
        return out;
      }
      switch (leg.type) {
        case LegType.CF: {
          const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
          if (terminator) {
            out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
            out.end = terminator;
          }
          break;
        }
        case LegType.AF: {
          const facility = this.facilityCache.get(leg.originIcao);
          if (facility) {
            out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? "right" : "left", this.predictLegPathCache.geoCircle[0]);
            out.end = this.facilityCache.get(leg.fixIcao);
          }
          break;
        }
        case LegType.RF: {
          const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
          const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
          if (terminator && centerFacility) {
            out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? "right" : "left", this.predictLegPathCache.geoCircle[0]);
            out.end = terminator;
          }
          break;
        }
        case LegType.FM:
        case LegType.VM: {
          const origin = this.facilityCache.get(leg.originIcao);
          if (origin) {
            out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
            out.start = origin;
          }
          break;
        }
      }
      return out;
    }
  };
  var FixToDmeLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
      this.geoPointCache = [new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
      this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const startFacility = this.facilityCache.get(leg.leg.fixIcao);
      leg.calculated.courseMagVar = startFacility === void 0 ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
      const dmeFacility = this.facilityCache.get(leg.originIcao);
      if (!pathStartPoint || !dmeFacility) {
        vectors.length = vectorIndex;
        state.isFallback = false;
        return;
      }
      const course = this.getLegTrueCourse(leg, pathStartPoint);
      const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
      const dmeCircle = this.geoCircleCache[1].set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
      const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
      const interceptVec = this.vec3Cache[1];
      const intersections = this.intersectionCache;
      const numIntersections = path.intersection(dmeCircle, intersections);
      if (numIntersections === 0) {
        dmeCircle.closest(pathStartVec, interceptVec);
      } else {
        const intersectionIndex = numIntersections === 1 || dmeCircle.encircles(pathStartVec) ? 0 : 1;
        Vec3Math.copy(intersections[intersectionIndex], interceptVec);
      }
      if (state.isFallback && state.currentPosition !== void 0 && state.currentCourse !== void 0) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, interceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), void 0, FlightPathVectorFlags.Fallback);
      } else {
        const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
        if (GeoPoint.distance(startVec, interceptVec) > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, interceptVec, course);
        }
      }
      if (vectorIndex > 0) {
        const lastVector = vectors[vectorIndex - 1];
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : state.currentPosition = new GeoPoint(0, 0)).set(lastVector.endLat, lastVector.endLon);
      }
      vectors.length = vectorIndex;
      state.isFallback = false;
    }
  };
  var TrackFromFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, false);
      this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
      this.geoPointCache = [new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const startFacility = this.facilityCache.get(leg.leg.fixIcao);
      leg.calculated.courseMagVar = startFacility === void 0 ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
      if (!pathStartPoint) {
        vectors.length = vectorIndex;
        state.isFallback = false;
        return;
      }
      const course = this.getLegTrueCourse(leg, pathStartPoint);
      const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
      const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
      const endVec = path.offsetDistanceAlong(pathStartVec, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN), this.vec3Cache[1], Math.PI);
      if (state.isFallback && state.currentPosition !== void 0 && state.currentCourse !== void 0) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endVec, state.desiredTurnRadius.asUnit(UnitType.METER), void 0, FlightPathVectorFlags.Fallback);
      } else {
        const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
        if (GeoPoint.distance(startVec, endVec) > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, endVec, course);
        }
      }
      if (vectorIndex > 0) {
        const lastVector = vectors[vectorIndex - 1];
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : state.currentPosition = new GeoPoint(0, 0)).set(lastVector.endLat, lastVector.endLon);
      }
      vectors.length = vectorIndex;
      state.isFallback = false;
    }
  };
  var CourseToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0)
      ];
      this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
      this.procTurnBuilder = new ProcedureTurnBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const leg = legs[calculateIndex].leg;
      const prevLeg = legs[calculateIndex - 1];
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : void 0;
      const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
      if (!endPoint) {
        vectors.length = vectorIndex;
        state.isFallback = false;
        return;
      }
      const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
      if (state.isFallback && state.currentPosition !== void 0 && state.currentCourse !== void 0) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, void 0, FlightPathVectorFlags.Fallback);
        state.isFallback = false;
      } else {
        state.isFallback = false;
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM)) {
          const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        } else {
          const startVec = startPoint.toCartesian(this.vec3Cache[0]);
          const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
          const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
          const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
          const isStartEqualToEnd = startPoint.equals(endPoint);
          const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
          if (!leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type) && threshold.encircles(startVec, false)) {
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
            (_d = state.currentCourse) !== null && _d !== void 0 ? _d : state.currentCourse = currentCourse;
            state.isFallback = true;
          } else {
            const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
            if (pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE) {
              let desiredTurnDirection;
              switch (leg.turnDirection) {
                case LegTurnDirection.Left:
                  desiredTurnDirection = "left";
                  break;
                case LegTurnDirection.Right:
                  desiredTurnDirection = "right";
                  break;
                default: {
                  const endDistanceFromStartPath = startPath.distance(endVec);
                  if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? "left" : "right";
                  } else {
                    desiredTurnDirection = endDistanceFromStartPath < 0 ? "left" : "right";
                  }
                }
              }
              vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === "left" ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
              if (vectorIndex > 0) {
                const lastVector2 = vectors[vectorIndex - 1];
                const interceptVec = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                  vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector2.endLat, lastVector2.endLon), endPoint);
                }
              }
            } else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE || !isStartEqualToEnd && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 || ((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))) {
              if (!isStartEqualToEnd) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
              }
            } else {
              const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : void 0;
              vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
              const lastVector2 = vectors[vectorIndex - 1];
              if (lastVector2 !== void 0 && Math.abs(FlightPathUtils.getVectorFinalCourse(lastVector2) - endCourse) > 1 && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                let startTurnCircle;
                let startTurnEnd;
                const isLastVectorGreatCircle = FlightPathUtils.isVectorGreatCircle(lastVector2);
                if (isLastVectorGreatCircle && vectors[vectorIndex - 2] !== void 0) {
                  const startTurnVector = vectors[vectorIndex - 2];
                  startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                  startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[2]);
                } else if (!isLastVectorGreatCircle) {
                  startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPath.encircles(endVec) ? "left" : "right", this.geoCircleCache[3]);
                  if (Math.min(lastVector2.radius, Math.PI - lastVector2.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                    startTurnEnd = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                  }
                }
                if (startTurnCircle !== void 0) {
                  const intersections = this.intersectionCache;
                  const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                  if (intersectionCount === 1) {
                    if (threshold.encircles(FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, this.vec3Cache[2]))) {
                      vectorIndex = 0;
                      ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
                      (_h = state.currentCourse) !== null && _h !== void 0 ? _h : state.currentCourse = currentCourse;
                      state.isFallback = true;
                    }
                  } else if (startTurnEnd === void 0 || intersectionCount === 2) {
                    const thresholdCrossing = intersections[0];
                    const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                    if (startTurnEnd === void 0 || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                      vectorIndex = 0;
                      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                      state.isFallback = true;
                    }
                  }
                }
              }
            }
          }
        }
      }
      const lastVector = vectors[vectorIndex - 1];
      if (lastVector !== void 0) {
        ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : state.currentPosition = new GeoPoint(0, 0)).set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
      }
      vectors.length = vectorIndex;
    }
  };
  CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
  ];
  var ProcedureTurnLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
      this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const originFacility = this.facilityCache.get(leg.leg.fixIcao);
      leg.calculated.courseMagVar = originFacility === void 0 ? 0 : MagVar.get(originFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c;
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
      if (!origin) {
        vectors.length = vectorIndex;
        return;
      }
      (_a = state.currentPosition) !== null && _a !== void 0 ? _a : state.currentPosition = origin.copy();
      const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
      if (!origin.equals(state.currentPosition)) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
        state.currentCourse = origin.bearingFrom(state.currentPosition);
        state.currentPosition.set(origin);
      }
      if (!nextLeg) {
        vectors.length = vectorIndex;
        return;
      }
      const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
      if (!nextLegTerminatorFix) {
        vectors.length = vectorIndex;
        return;
      }
      const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
      const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
      const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
      if (outboundCourse === turnInitialCourse) {
        vectors.length = vectorIndex;
        return;
      }
      const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
      const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
      const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
      const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : void 0;
      vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
      const lastVector = vectors[vectorIndex - 1];
      state.currentPosition.set(lastVector.endLat, lastVector.endLon);
      state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
      vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
      var _a;
      const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
      if (!leg) {
        return void 0;
      }
      switch (leg.type) {
        case LegType.IF:
          return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
        case LegType.CF:
          return this.getLegTrueCourse(leg, terminator);
        default:
          return void 0;
      }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
      var _a;
      const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
      if (!leg) {
        return void 0;
      }
      try {
        switch (leg.type) {
          case LegType.IF:
          case LegType.TF:
          case LegType.DF:
          case LegType.CF: {
            const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
            return terminator ? origin.bearingTo(terminator) : void 0;
          }
          case LegType.CD:
          case LegType.VD:
          case LegType.CR:
          case LegType.VR:
          case LegType.FC:
          case LegType.FD:
            return this.getLegTrueCourse(leg, origin);
          case LegType.FA:
          case LegType.CA:
          case LegType.VA:
          case LegType.FM:
          case LegType.VM:
          case LegType.CI:
          case LegType.VI:
            return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
          default:
            return void 0;
        }
      } catch (e) {
        return void 0;
      }
    }
  };
  var CourseToManualLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, false);
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
      var _a;
      const leg = legs[calculateIndex];
      const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
      leg.calculated.courseMagVar = origin === void 0 ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a;
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
      if (!startPoint) {
        vectors.length = vectorIndex;
        return;
      }
      const course = this.getLegTrueCourse(leg, startPoint);
      const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
      vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
      state.currentPosition = void 0;
      state.currentCourse = void 0;
      vectors.length = vectorIndex;
    }
  };
  var CourseToAltitudeLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, false);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
      var _a;
      const leg = legs[calculateIndex];
      const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
      leg.calculated.courseMagVar = origin === void 0 ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      if (!state.currentPosition) {
        const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (fixPosition) {
          state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
        }
      }
      if (!state.currentPosition) {
        vectors.length = vectorIndex;
        return;
      }
      const course = this.getLegTrueCourse(leg, state.currentPosition);
      const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
      const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
      const climbStartVec = activeLegIndex === calculateIndex ? path.closest(state.planePosition, this.vec3Cache[1]) : originVec;
      const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
      const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
      const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
      const distanceRemaining = UnitType.NMILE.convertTo(deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
      const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
      const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
      vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
      state.currentPosition.setFromCartesian(legEndVec);
      state.currentCourse = path.bearingAt(legEndVec);
      vectors.length = vectorIndex;
    }
  };
  var HoldLegCalculator = class extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
      super(facilityCache, true);
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.turnToCourseBuilder = new TurnToCourseBuilder();
      this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
      this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const holdFacility = this.facilityCache.get(leg.leg.fixIcao);
      leg.calculated.courseMagVar = holdFacility === void 0 ? 0 : this.getLegMagVar(leg.leg, holdFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c, _d;
      state.isFallback = false;
      const leg = legs[calculateIndex].leg;
      const calcs = legs[calculateIndex].calculated;
      const vectors = calcs.flightPath;
      const ingress = calcs.ingress;
      let vectorIndex = 0, ingressVectorIndex = 0;
      const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
      if (!holdPos) {
        vectors.length = 0;
        ingress.length = 0;
        calcs.ingressJoinIndex = -1;
        return;
      }
      (_a = state.currentPosition) !== null && _a !== void 0 ? _a : state.currentPosition = holdPos.copy();
      if (!state.currentPosition.equals(holdPos)) {
        ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
        state.currentCourse = holdPos.bearingFrom(state.currentPosition);
      }
      const course = this.getLegTrueCourse(leg, holdPos);
      const distance = leg.distanceMinutes ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN) : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
      const turnDirection = leg.turnDirection === LegTurnDirection.Right ? "right" : "left";
      const turnDirectionSign = turnDirection === "left" ? -1 : 1;
      const turnRadiusMeters = state.desiredHoldTurnRadius.asUnit(UnitType.METER);
      const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
      const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
      const turnRadiusRad = state.desiredHoldTurnRadius.asUnit(UnitType.GA_RADIAN);
      const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
      const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
      const oppositeCourse = NavMath.normalizeHeading(course + 180);
      const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
      state.currentPosition.set(holdPos);
      (_b = state.currentCourse) !== null && _b !== void 0 ? _b : state.currentCourse = course;
      const normalizedEntryCourse = (state.currentCourse - course + 540) % 360 - 180;
      const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
      const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
      const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
      if (isDirectEntry) {
        if (directionalEntryCourse > 0) {
          ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, true, void 0, FlightPathVectorFlags.HoldDirectEntry);
          calcs.ingressJoinIndex = 1;
        } else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
          ingressVectorIndex = ingress.length;
        }
      } else if (directionalEntryCourse > 110) {
        if (directionalEntryCourse > 135) {
          const outboundCourse = course + 135 * turnDirectionSign;
          const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === "left" ? "right" : "left", state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
          if (numTurnVectorsAdded > 0) {
            ingressVectorIndex += numTurnVectorsAdded;
            const turnVector = ingress[ingressVectorIndex - 1];
            state.currentPosition.set(turnVector.endLat, turnVector.endLon);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
          }
        }
        ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, true, void 0, FlightPathVectorFlags.HoldTeardropEntry);
        if (skipRacetrack) {
          const lastEntryVector = ingress[ingressVectorIndex - 1];
          if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
            if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
              const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
              lastEntryVector.endLat = lastEntryVectorEnd.lat;
              lastEntryVector.endLon = lastEntryVectorEnd.lon;
              lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
            } else {
              ingressVectorIndex--;
            }
          }
        }
        calcs.ingressJoinIndex = 0;
      } else if (directionalEntryCourse < -70) {
        const parallelCourse = course + 180;
        const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === "left" ? "right" : "left", state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
        if (numTurnVectorsAdded > 0) {
          ingressVectorIndex += numTurnVectorsAdded;
          const turnVector = ingress[ingressVectorIndex - 1];
          state.currentPosition.set(turnVector.endLat, turnVector.endLon);
          state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
        }
        ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === "left" ? "right" : "left", state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
        calcs.ingressJoinIndex = 0;
      }
      ingress.length = ingressVectorIndex;
      if (ingress.length === 0) {
        calcs.ingressJoinIndex = -1;
      }
      let inboundStart;
      if (skipRacetrack) {
        inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
      } else {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, void 0, FlightPathVectorFlags.HoldOutboundLeg);
        const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
        const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
        inboundStart = inboundTurnEnd;
      }
      vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, void 0, FlightPathVectorFlags.HoldInboundLeg);
      state.currentPosition.set(holdPos);
      state.currentCourse = course;
      vectors.length = vectorIndex;
    }
  };
  var FlightPathTurnCalculator = class {
    constructor() {
      this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
      var _a, _b, _c, _d, _e, _f;
      const end = startIndex + count;
      let currentIndex = startIndex;
      while (currentIndex < end) {
        const fromLegCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
        const toLegCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
        if (fromLegCalc && toLegCalc) {
          const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
          const toVector = toLegCalc.flightPath[0];
          if (fromVector && toVector && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn)) && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
              currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
              continue;
            } else if (toVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
              continue;
            } else if (fromVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
              continue;
            }
          }
        }
        if (fromLegCalc && BitFlags.isAll((_d = (_c = fromLegCalc.egress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
          fromLegCalc.egress.length = 0;
          fromLegCalc.egressJoinIndex = -1;
        }
        if (toLegCalc && BitFlags.isAll((_f = (_e = toLegCalc.ingress[0]) === null || _e === void 0 ? void 0 : _e.flags) !== null && _f !== void 0 ? _f : 0, FlightPathVectorFlags.LegToLegTurn)) {
          toLegCalc.ingress.length = 0;
          toLegCalc.ingressJoinIndex = -1;
        }
        currentIndex++;
      }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
      const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
      const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
      if (trackAngleDiff < 1 || fromTrack.distance === 0 || toTrack.distance === 0 || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      if (trackAngleDiff > 175) {
        return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
      }
      const theta = (180 - trackAngleDiff) / 2;
      const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
      const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
      let restrictedD = Infinity;
      if (isRestrictedByPrevTurn) {
        if (previousTanTheta === void 0) {
          if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
            const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
            restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
          }
        } else {
          const tanThetaRatio = previousTanTheta / tanTheta;
          const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
          const cosTotalD = Math.cos(totalD);
          let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
          if (prevTurnRestrictedD > totalD) {
            prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
          }
          restrictedD = prevTurnRestrictedD;
        }
      }
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          let nextTurnRestrictedD;
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
          }
          restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
        }
      }
      const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
      const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
      const turnRadiusRad = desiredD === D ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN) : Math.atan(Math.sin(D) * tanTheta);
      if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
      const turnBisectorBearing = toTrackBearing + theta * (turnDirection === "left" ? -1 : 1);
      const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
      const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
      const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
      return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
          }
        }
      }
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
      const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? "left" : "right";
      const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === "left" ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
      toLegCalc.ingress.length = length;
      toLegCalc.ingressJoinIndex = 0;
      return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      if (arc.distance === 0 || track.distance === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const fromVector = isArcFirst ? arc : track;
      const toVector = isArcFirst ? track : arc;
      const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
      const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
      if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
        return toIndex;
      }
      const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
      const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
      const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
      if (vectorBearingDiff < 1) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
      const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, FlightPathTurnCalculator.geoPointCache[2]);
      const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
      const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const arcCircle = FlightPathTurnCalculator.geoCircleCache[0].set(arcCenter, arcRadius);
      const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[1]);
      const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
      const arcStartRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
      const arcEndRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
      const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
      if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
      let isInside;
      let turnRadiusRad;
      let arcCircleOffsetSign;
      let trackPathOffsetSign;
      if (arcTrackIntersectionCount === 1) {
        const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
        if (isForward) {
          this.setEmptyTurn(fromLegCalc, toLegCalc);
          return toIndex;
        } else {
          isInside = false;
          turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
          arcCircleOffsetSign = 1;
          trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
        }
      } else {
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        isInside = isArcFirst ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90 : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
        const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, FlightPathTurnCalculator.vector3Cache[0]);
        const maxTrackLimitDistance = isInside ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius)) : Infinity;
        const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
        const trackLimitPoint = isArcFirst ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]) : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]);
        const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, isArcFirst === isInside ? -1 : 1, FlightPathTurnCalculator.vector3Cache[1]), arcCircle.center, FlightPathTurnCalculator.vector3Cache[1]), Math.PI / 2);
        const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
        trackPerpendicularDiameter.intersection(arcCircle, antipodes);
        const intersectingPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === "left") ? antipodes[0] : antipodes[1], trackLimitPoint);
        const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
        let arcLimitAngularWidth = Infinity;
        if (numArcIntersections > 0) {
          const pseudoArcLimitPoint = arcIntersections[0];
          const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
          arcLimitAngularWidth = Math.abs(NavMath.diffAngle(isArcFirst ? arcEndRadial : arcStartRadial, pseudoArcLimitPointAngle));
        }
        let arcTurnRadiusLimit = 0;
        const arcAngularWidth = ((arcDirection === "left" ? arcStartRadial - arcEndRadial : arcEndRadial - arcStartRadial) + 360) % 360;
        arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
        if (arcLimitAngularWidth > 0) {
          const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * (arcDirection === "left" ? -1 : 1);
          const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, FlightPathTurnCalculator.geoPointCache[4]);
          const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
          const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
          if (theta >= Math.PI / 2) {
            if (isInside) {
              const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
              arcTurnRadiusLimit = (arcRadius - d) / 2;
            } else {
              arcTurnRadiusLimit = Infinity;
            }
          } else {
            const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
            arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
            const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
            const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[1]), FlightPathTurnCalculator.vector3Cache[1]);
            const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
            const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
            const sinTheta = Math.sin(theta);
            const sign = isInside ? -1 : 1;
            arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
          }
        }
        turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
        arcCircleOffsetSign = isInside ? -1 : 1;
        trackPathOffsetSign = turnDirection === "left" ? -1 : 1;
      }
      if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
      const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
      const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
      const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
      if (intersectionCount === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      let turnCenter;
      if (intersectionCount === 2) {
        if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
          turnCenter = intersections[1];
        } else {
          turnCenter = intersections[0];
        }
      } else {
        turnCenter = intersections[0];
      }
      const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
      const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
      const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
      const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
      let turnAngularDelta = turnEndBearing - turnStartBearing;
      if (turnDirection === "right" && turnEndBearing <= turnStartBearing) {
        turnAngularDelta += 360;
      } else if (turnDirection === "left" && turnEndBearing >= turnStartBearing) {
        turnAngularDelta -= 360;
      }
      const turnMiddleBearing = (turnStartBearing + turnAngularDelta / 2 + 360) % 360;
      const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
      const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
      const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
      turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
      return toIndex;
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      toLegCalc.ingress.length = 0;
      toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
      var _a, _b;
      var _c, _d;
      const egress = (_a = (_c = fromLegCalc.egress)[0]) !== null && _a !== void 0 ? _a : _c[0] = FlightPathUtils.createEmptyCircleVector();
      const ingress = (_b = (_d = toLegCalc.ingress)[0]) !== null && _b !== void 0 ? _b : _d[0] = FlightPathUtils.createEmptyCircleVector();
      fromLegCalc.egress.length = 1;
      toLegCalc.ingress.length = 1;
      fromLegCalc.egressJoinIndex = fromLegCalc.flightPath.length - 1;
      toLegCalc.ingressJoinIndex = 0;
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
      const egressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | fromLegCalc.flightPath[fromLegCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      const ingressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | toLegCalc.flightPath[toLegCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      FlightPathUtils.setCircleVector(egress, circle, start, middle, egressFlags);
      FlightPathUtils.setCircleVector(ingress, circle, middle, end, ingressFlags);
    }
  };
  FlightPathTurnCalculator.vector3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
  };
  var FlightPlanUtils = class {
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg) {
      switch (leg.type) {
        case LegType.IF:
        case LegType.TF:
        case LegType.DF:
        case LegType.CF:
        case LegType.AF:
        case LegType.RF:
        case LegType.HA:
        case LegType.HF:
        case LegType.HM:
          return leg.fixIcao;
        default:
          return void 0;
      }
    }
  };
  FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
  FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
  FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
  FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
  FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];
  var FlightPathAirplaneSpeedMode;
  (function(FlightPathAirplaneSpeedMode2) {
    FlightPathAirplaneSpeedMode2["Default"] = "Default";
    FlightPathAirplaneSpeedMode2["GroundSpeed"] = "GroundSpeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeed"] = "TrueAirspeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
  })(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
  var FlightPathCalculator = class {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader, options, bus) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.facilityCache = /* @__PURE__ */ new Map();
      this.legCalculatorMap = this.createLegCalculatorMap();
      this.turnCalculator = new FlightPathTurnCalculator();
      this.state = new FlightPathStateClass();
      this.calculateQueue = [];
      this.isBusy = false;
      this.options = Object.assign({}, options);
      this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
      this.holdBankAngleTable = this.options.holdBankAngle === null ? void 0 : this.buildBankAngleTable(this.options.holdBankAngle);
      this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? void 0 : this.buildBankAngleTable(this.options.courseReversalBankAngle);
      this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? void 0 : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
      this.bus.getSubscriber().on("flightpath_set_options").handle((newOptions) => this.setOptions(newOptions));
    }
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    setOptions(newOptions) {
      for (const key in newOptions) {
        const option = newOptions[key];
        if (option !== void 0) {
          this.options[key] = option;
          switch (key) {
            case "bankAngle":
              this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
              break;
            case "holdBankAngle":
              this.holdBankAngleTable = this.options.holdBankAngle === null ? void 0 : this.buildBankAngleTable(this.options.holdBankAngle);
              break;
            case "courseReversalBankAngle":
              this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? void 0 : this.buildBankAngleTable(this.options.courseReversalBankAngle);
              break;
            case "turnAnticipationBankAngle":
              this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? void 0 : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
              break;
          }
        }
      }
    }
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    buildBankAngleTable(angle) {
      if (typeof angle === "number") {
        return new LerpLookupTable([[angle, 0]]);
      } else {
        return new LerpLookupTable(angle);
      }
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
      let calc;
      return {
        [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
        [LegType.IF]: calc,
        [LegType.TF]: calc,
        [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
        [LegType.CD]: calc = new CourseToDmeLegCalculator(this.facilityCache),
        [LegType.VD]: calc,
        [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
        [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
        [LegType.VR]: calc,
        [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
        [LegType.FD]: new FixToDmeLegCalculator(this.facilityCache),
        [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
        [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
        [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
        [LegType.CA]: calc,
        [LegType.VA]: calc,
        [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
        [LegType.VM]: calc,
        [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
        [LegType.VI]: calc,
        [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
        [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
        [LegType.HM]: calc,
        [LegType.HF]: calc,
        [LegType.Discontinuity]: calc = new NoPathLegCalculator(this.facilityCache),
        [LegType.ThruDiscontinuity]: calc
      };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
      if (this.isBusy || this.calculateQueue.length > 0) {
        return new Promise((resolve, reject) => {
          this.calculateQueue.push(() => {
            this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
          });
        });
      } else {
        return new Promise((resolve, reject) => {
          this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
        });
      }
    }
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    async doCalculate(resolve, reject, legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
      this.isBusy = true;
      try {
        initialIndex = Math.max(0, initialIndex);
        count = Math.max(0, Math.min(legs.length - initialIndex, count));
        this.state.updatePlaneState(this.options, this.bankAngleTable, this.holdBankAngleTable, this.courseReversalBankAngleTable, this.turnAnticipationBankAngleTable);
        this.facilityCache.clear();
        await this.loadFacilities(legs, initialIndex, count);
        this.initCurrentLatLon(legs, initialIndex);
        this.initCurrentCourse(legs, initialIndex);
        this.initIsFallback(legs, initialIndex);
        this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
        this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER), this.state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), this.state.desiredTurnAnticipationTurnRadius.asUnit(UnitType.METER));
        this.resolveLegsIngressToEgress(legs, initialIndex, count);
        this.updateLegDistances(legs, initialIndex, count);
        this.isBusy = false;
        resolve();
      } catch (e) {
        this.isBusy = false;
        reject(e);
      }
      const nextInQueue = this.calculateQueue.shift();
      if (nextInQueue !== void 0) {
        nextInQueue();
      }
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
      const facilityPromises = [];
      for (let i = initialIndex; i < initialIndex + count; i++) {
        this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
        this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
        this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
      }
      if (facilityPromises.length > 0) {
        await Promise.all(facilityPromises);
      }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
      if (ICAO.isFacility(icao)) {
        facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao).then((facility) => {
          this.facilityCache.set(icao, facility);
          return true;
        }).catch(() => false));
      }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
      var _a;
      var _b;
      let index = Math.min(initialIndex, legs.length);
      while (--index >= 0) {
        const leg = legs[index];
        if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) || FlightPlanUtils.isManualDiscontinuityLeg(leg.leg.type)) {
          break;
        }
        const calc = leg.calculated;
        if (calc && calc.endLat !== void 0 && calc.endLon !== void 0) {
          ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : _b.currentPosition = new GeoPoint(0, 0)).set(calc.endLat, calc.endLon);
          return;
        }
      }
      this.state.currentPosition = void 0;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
      let index = Math.min(initialIndex, legs.length);
      while (--index >= 0) {
        const leg = legs[index];
        if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
          return;
        }
        const legCalc = leg.calculated;
        if (legCalc && legCalc.flightPath.length > 0) {
          this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
          if (this.state.currentCourse !== void 0) {
            return;
          }
        }
      }
      this.state.currentCourse = void 0;
    }
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initIsFallback(legs, initialIndex) {
      var _a, _b, _c;
      this.state.isFallback = (_c = (_b = (_a = legs[Math.min(initialIndex, legs.length) - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endsInFallback) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
      const end = initialIndex + count;
      for (let i = initialIndex; i < end; i++) {
        this.calculateLegPath(legs, i, activeLegIndex);
      }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
      const definition = legs[calculateIndex];
      const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
      const start = calcs.flightPath[0];
      const end = calcs.flightPath[calcs.flightPath.length - 1];
      calcs.initialDtk = void 0;
      if (start !== void 0) {
        const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
        if (!isNaN(trueDtk)) {
          calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
        }
      }
      calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
      calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
      calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
      calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
      if (!end && this.state.currentPosition) {
        calcs.endLat = this.state.currentPosition.lat;
        calcs.endLon = this.state.currentPosition.lon;
      }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
      const end = initialIndex + count;
      for (let i = initialIndex; i < end; i++) {
        const legCalc = legs[i].calculated;
        legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
      }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
      var _a, _b, _c, _d, _e, _f;
      const end = initialIndex + count;
      for (let i = initialIndex; i < end; i++) {
        const leg = legs[i];
        const calc = leg.calculated;
        calc.distance = 0;
        const len = calc.flightPath.length;
        for (let j = 0; j < len; j++) {
          calc.distance += calc.flightPath[j].distance;
        }
        calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
        calc.distanceWithTransitions = 0;
        const ingressLen = calc.ingress.length;
        for (let j = 0; j < ingressLen; j++) {
          calc.distanceWithTransitions += calc.ingress[j].distance;
        }
        const ingressToEgressLen = calc.ingressToEgress.length;
        for (let j = 0; j < ingressToEgressLen; j++) {
          calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
        }
        const egressLen = calc.egress.length;
        for (let j = 0; j < egressLen; j++) {
          calc.distanceWithTransitions += calc.egress[j].distance;
        }
        calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
      }
    }
  };
  var FlightPathStateClass = class {
    constructor() {
      this.isFallback = false;
      this._planePosition = new GeoPoint(0, 0);
      this.planePosition = this._planePosition.readonly;
      this._planeHeading = 0;
      this._planeAltitude = UnitType.FOOT.createNumber(0);
      this.planeAltitude = this._planeAltitude.readonly;
      this._planeSpeed = UnitType.KNOT.createNumber(0);
      this.planeSpeed = this._planeSpeed.readonly;
      this._planeClimbRate = UnitType.FPM.createNumber(0);
      this.planeClimbRate = this._planeClimbRate.readonly;
      this._desiredTurnRadius = UnitType.METER.createNumber(0);
      this.desiredTurnRadius = this._desiredTurnRadius.readonly;
      this._desiredHoldTurnRadius = UnitType.METER.createNumber(0);
      this.desiredHoldTurnRadius = this._desiredHoldTurnRadius.readonly;
      this._desiredCourseReversalTurnRadius = UnitType.METER.createNumber(0);
      this.desiredCourseReversalTurnRadius = this._desiredCourseReversalTurnRadius.readonly;
      this._desiredTurnAnticipationTurnRadius = UnitType.METER.createNumber(0);
      this.desiredTurnAnticipationTurnRadius = this._desiredTurnAnticipationTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
      return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     * @param bankAngleTable A lookup table for general turn bank angle, in degrees, versus airplane speed.
     * @param holdBankAngleTable A lookup table for hold turn bank angle, in degrees, versus airplane speed, in knots.
     * If not defined, the general turn bank angle table will be used instead.
     * @param courseReversalBankAngleTable A lookup table for course reversal turn bank angle, in degrees, versus
     * airplane speed, in knots. If not defined, the general turn bank angle table will be used instead.
     * @param turnAnticipationBankAngleTable A lookup table for turn anticipation bank angle, in degrees, versus airplane
     * speed, in knots. If not defined, the general turn bank angle table will be used instead.
     */
    updatePlaneState(options, bankAngleTable, holdBankAngleTable, courseReversalBankAngleTable, turnAnticipationBankAngleTable) {
      this._planePosition.set(SimVar.GetSimVarValue("PLANE LATITUDE", SimVarValueType.Degree), SimVar.GetSimVarValue("PLANE LONGITUDE", SimVarValueType.Degree));
      this._planeAltitude.set(SimVar.GetSimVarValue("INDICATED ALTITUDE", "feet"));
      this._planeHeading = SimVar.GetSimVarValue("PLANE HEADING DEGREES TRUE", "degree");
      switch (options.airplaneSpeedMode) {
        case FlightPathAirplaneSpeedMode.GroundSpeed:
          this._planeSpeed.set(Math.max(SimVar.GetSimVarValue("GROUND VELOCITY", SimVarValueType.Knots), options.defaultSpeed));
          break;
        case FlightPathAirplaneSpeedMode.TrueAirspeed:
        case FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind: {
          const trueAirspeed = SimVar.GetSimVarValue("AIRSPEED TRUE", SimVarValueType.Knots);
          const windSpeed = options.airplaneSpeedMode === FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind ? SimVar.GetSimVarValue("AMBIENT WIND VELOCITY", SimVarValueType.Knots) : 0;
          this._planeSpeed.set(Math.max(trueAirspeed + windSpeed, options.defaultSpeed));
          break;
        }
        default:
          this._planeSpeed.set(options.defaultSpeed);
      }
      this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue("VERTICAL SPEED", "feet per minute"), options.defaultClimbRate));
      const planeSpeedKnots = this._planeSpeed.asUnit(UnitType.KNOT);
      this._desiredTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(bankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
      if (holdBankAngleTable) {
        this._desiredHoldTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(holdBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
      } else {
        this._desiredHoldTurnRadius.set(this._desiredTurnRadius);
      }
      if (courseReversalBankAngleTable) {
        this._desiredCourseReversalTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(courseReversalBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
      } else {
        this._desiredCourseReversalTurnRadius.set(this._desiredTurnRadius);
      }
      if (turnAnticipationBankAngleTable) {
        this._desiredTurnAnticipationTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(turnAnticipationBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
      } else {
        this._desiredTurnAnticipationTurnRadius.set(this._desiredTurnRadius);
      }
    }
  };
  var LegEventType;
  (function(LegEventType2) {
    LegEventType2["Added"] = "Added";
    LegEventType2["Removed"] = "Removed";
    LegEventType2["Changed"] = "Changed";
  })(LegEventType || (LegEventType = {}));
  var SegmentEventType;
  (function(SegmentEventType2) {
    SegmentEventType2["Added"] = "Added";
    SegmentEventType2["Removed"] = "Removed";
    SegmentEventType2["Changed"] = "Changed";
    SegmentEventType2["Inserted"] = "Inserted";
  })(SegmentEventType || (SegmentEventType = {}));
  var ActiveLegType;
  (function(ActiveLegType2) {
    ActiveLegType2["Lateral"] = "Lateral";
    ActiveLegType2["Vertical"] = "Vertical";
    ActiveLegType2["Calculating"] = "Calculating";
  })(ActiveLegType || (ActiveLegType = {}));
  var OriginDestChangeType;
  (function(OriginDestChangeType2) {
    OriginDestChangeType2["OriginAdded"] = "OriginAdded";
    OriginDestChangeType2["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType2["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType2["DestinationRemoved"] = "DestinationRemoved";
  })(OriginDestChangeType || (OriginDestChangeType = {}));
  var FlightPlan = class {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
      this.planIndex = planIndex;
      this.calculator = calculator;
      this.onLegNameRequested = onLegNameRequested;
      this._activeLateralLeg = 0;
      this._activeVerticalLeg = 0;
      this._activeCalculatingLeg = 0;
      this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
      this.events = {};
      this.procedureDetails = new ProcedureDetails();
      this.planSegments = [];
      this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
      return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
      return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
      return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
      return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
      return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
      const segment = this.planSegments[this.planSegments.length - 1];
      if (segment !== void 0) {
        return segment.offset + segment.legs.length;
      }
      return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
      return this.planSegments.length;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex, endIndex) {
      return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex = 0, endIndex = this.length) {
      endIndex = Math.min(this.length, endIndex);
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.min(segment.legs.length, endIndex - segment.offset);
          if (end <= 0) {
            return;
          }
          for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
            yield segment.legs[l];
          }
        }
      }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
      endIndex = Math.max(-1, endIndex);
      for (let i = this.planSegments.length - 1; i > -1; i--) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.max(-1, endIndex - segment.offset);
          if (end >= segment.legs.length) {
            return;
          }
          for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
            yield segment.legs[l];
          }
        }
      }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0) {
          yield segment;
        }
      }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
      for (const segment of this.segments()) {
        if (segment.segmentType == segmentType) {
          yield segment;
        }
      }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
      this.planSegments[segmentIndex] = segment;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
      return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segment !== void 0) {
        const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments.splice(segmentIndex, 0, newSegment);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
        return newSegment;
      } else {
        return this.addSegment(segmentIndex, segmentType, airway, notify);
      }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.segmentIndex !== i) {
          segment.segmentIndex = i;
        }
      }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segmentIndex === this.planSegments.length - 1) {
        this.planSegments.splice(segmentIndex, 1);
      } else {
        delete this.planSegments[segmentIndex];
      }
      if (this.directToData.segmentIndex === segmentIndex)
        ;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      this.planSegments.splice(segmentIndex, 1);
      this.reflowSegments();
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
      const segment = this.tryGetSegment(segmentIndex);
      if (segment === null) {
        throw new Error(`Flight plan segment with ${segmentIndex === void 0 ? "active leg" : `segment index ${segmentIndex}`} could not be found.`);
      } else {
        return segment;
      }
    }
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex) {
      if (segmentIndex === void 0) {
        let calculatedSegmentIndex = 0;
        for (const segment2 of this.segments()) {
          if (this.activeLateralLeg == 0 && segment2.legs.length == 0) {
            calculatedSegmentIndex++;
          } else if (this.activeLateralLeg > segment2.offset + segment2.legs.length) {
            calculatedSegmentIndex++;
          } else {
            break;
          }
        }
        const segment = this.planSegments[calculatedSegmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      } else if (segmentIndex >= 0) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      }
      return null;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
      const segment = this.getSegment(segmentIndex);
      const legDefinition = {
        name: this.onLegNameRequested(leg),
        leg,
        flags,
        verticalData: {
          phase: VerticalFlightPhase.Descent,
          altDesc: AltitudeRestrictionType.Unused,
          altitude1: 0,
          altitude2: 0,
          displayAltitude1AsFlightLevel: false,
          displayAltitude2AsFlightLevel: false,
          speedDesc: SpeedRestrictionType.Unused,
          speed: 0,
          speedUnit: SpeedUnit.IAS
        }
      };
      if (segmentLegIndex === void 0) {
        segment.legs.push(legDefinition);
        segmentLegIndex = segment.legs.length - 1;
      } else {
        segment.legs.splice(segmentLegIndex, 0, legDefinition);
      }
      this.reflowSegmentOffsets();
      notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
      return legDefinition;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
      const leg = this._tryGetLeg(arg1, arg2);
      if (leg) {
        return leg;
      }
      throw new Error(`Leg with ${arg2 === void 0 ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
      return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
      var _a, _b;
      if (arg2 === void 0) {
        const legIndex = arg1;
        for (const segment of this.segments()) {
          if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
            return segment.legs[legIndex - segment.offset];
          }
        }
        return null;
      } else {
        const segmentIndex = arg1;
        const segmentLegIndex = arg2;
        return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
      }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
      const segment = this.getSegment(segmentIndex);
      let legDefinition;
      if (segmentLegIndex === void 0) {
        legDefinition = segment.legs.pop();
        segmentLegIndex = segment.legs.length;
      } else {
        const deleted = segment.legs.splice(segmentLegIndex, 1);
        legDefinition = deleted[0];
      }
      if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex)
        ;
      this.reflowSegmentOffsets();
      notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
      return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
      const legs = [...this.legs()];
      await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === void 0 ? this.activeCalculatingLeg : globalLegIndex);
      notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
      this._originAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
      const facilityIcao = this._originAirport;
      this._originAirport = void 0;
      this.procedureDetails.departureIndex = -1;
      this.procedureDetails.departureRunwayIndex = -1;
      this.procedureDetails.departureTransitionIndex = -1;
      this.procedureDetails.originRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
      this._destinationAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
      const facilityIcao = this._destinationAirport;
      this._destinationAirport = void 0;
      this.procedureDetails.approachIndex = -1;
      this.procedureDetails.approachTransitionIndex = -1;
      this.procedureDetails.arrivalIndex = -1;
      this.procedureDetails.arrivalRunwayTransitionIndex = -1;
      this.procedureDetails.arrivalRunway = void 0;
      this.procedureDetails.arrivalTransitionIndex = -1;
      this.procedureDetails.destinationRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeLateralLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeVerticalLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeCalculatingLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
      for (const key of Object.keys(this.procedureDetails)) {
        this.procedureDetails[key] = details[key];
      }
      notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
      let index = 0;
      for (const toCompare of this.legs()) {
        if (toCompare === leg) {
          return index;
        }
        index++;
      }
      return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
      for (const segment of this.segments()) {
        if (segment.legs.includes(leg)) {
          return segment;
        }
      }
      return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
      for (const segment of this.segments()) {
        if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.segmentIndex;
        }
      }
      return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
      const segmentIndex = this.getSegmentIndex(globalLegIndex);
      if (segmentIndex === -1) {
        return -1;
      }
      return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
      var _a, _b;
      if (segmentIndex < 0) {
        return null;
      }
      segmentIndex = Math.min(segmentIndex, this.planSegments.length);
      legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
      while (!leg && --segmentIndex >= 0) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[segment.legs.length - 1];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
      if (segmentIndex >= this.planSegments.length) {
        return null;
      }
      segmentIndex = Math.max(segmentIndex, -1);
      legIndex = Math.max(legIndex, -1);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
      while (!leg && ++segmentIndex < this.planSegments.length) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[0];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
      if (typeof arg1 !== "number") {
        arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
      }
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let notify = true;
      if (typeof arg2 !== "number") {
        const globalLegIndex = arg1;
        if (globalLegIndex >= 0) {
          segmentIndex = this.getSegmentIndex(globalLegIndex);
          if (segmentIndex >= 0) {
            segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
          }
        }
        notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
      }
      this.directToData.segmentIndex = segmentIndex;
      this.directToData.segmentLegIndex = segmentLegIndex;
      notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
      let notify = true;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let verticalData;
      if (typeof arg2 !== "number") {
        segmentIndex = this.getSegmentIndex(arg1);
        const segment = this.getSegment(segmentIndex);
        segmentLegIndex = arg1 - segment.offset;
        verticalData = arg2;
        notify = arg3 !== void 0 ? arg3 : notify;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        verticalData = arg3;
        notify = arg4 !== void 0 ? arg4 : notify;
      }
      const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
      if (leg) {
        Object.assign(leg.verticalData, verticalData);
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
      } else {
        console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
      }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
      const segment = this.getSegment(segmentIndex);
      if (!airway) {
        segment.airway = void 0;
      } else {
        segment.airway = airway;
      }
      this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
      this.userData[key] = data;
      this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
      if (this.userData[key] !== void 0) {
        delete this.userData[key];
      }
      this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
      return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
      let nextOffset = void 0;
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment) {
          if (nextOffset === void 0) {
            segment.offset = 0;
          } else {
            segment.offset = nextOffset;
          }
          nextOffset = segment.legs.length + segment.offset;
        }
      }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = void 0, notify = true) {
      this.procedureDetails.originRunway = runway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = void 0, notify = true) {
      this.procedureDetails.destinationRunway = runway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = void 0, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
      this.procedureDetails.departureIndex = departureIndex;
      this.procedureDetails.departureFacilityIcao = facilityIcao;
      this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
      this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = void 0, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = void 0, notify = true) {
      this.procedureDetails.arrivalIndex = arrivalIndex;
      this.procedureDetails.arrivalFacilityIcao = facilityIcao;
      this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
      this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
      this.procedureDetails.arrivalRunway = arrivalRunway;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = void 0, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachFacilityIcao = facilityIcao;
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
      const details = new ProcedureDetails();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex, copyCalcs = false) {
      if (planIndex === void 0) {
        planIndex = this.planIndex;
      }
      const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
      newPlan.setProcedureDetails(this.procedureDetails, false);
      newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
      for (const segment of this.segments()) {
        newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
        for (const leg of segment.legs) {
          const newLeg = newPlan.addLeg(segment.segmentIndex, leg.leg, void 0, leg.flags, false);
          const legIndex = newPlan.getLegIndexFromLeg(newLeg);
          newPlan.setLegVerticalData(legIndex, leg.verticalData);
          copyCalcs && this.copyLegCalculations(leg, newLeg);
        }
      }
      if (this.originAirport !== void 0) {
        newPlan.setOriginAirport(this.originAirport, false);
      }
      if (this.destinationAirport !== void 0) {
        newPlan.setDestinationAirport(this.destinationAirport, false);
      }
      newPlan.setLateralLeg(this.activeLateralLeg);
      newPlan.setVerticalLeg(this.activeVerticalLeg);
      newPlan.setCalculatingLeg(this.activeCalculatingLeg);
      for (const key in this.userData) {
        newPlan.setUserData(key, this.userData[key], false);
      }
      return newPlan;
    }
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    copyLegCalculations(existingLeg, newLeg) {
      if (existingLeg.calculated !== void 0) {
        newLeg.calculated = {
          courseMagVar: existingLeg.calculated.courseMagVar,
          initialDtk: existingLeg.calculated.initialDtk,
          distance: existingLeg.calculated.distance,
          cumulativeDistance: existingLeg.calculated.cumulativeDistance,
          distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
          cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
          startLat: existingLeg.calculated.startLat,
          startLon: existingLeg.calculated.startLon,
          endLat: existingLeg.calculated.endLat,
          endLon: existingLeg.calculated.endLon,
          flightPath: existingLeg.calculated.flightPath.map((vector) => Object.assign({}, vector)),
          ingress: existingLeg.calculated.ingress.map((vector) => Object.assign({}, vector)),
          ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
          ingressToEgress: existingLeg.calculated.ingressToEgress.map((vector) => Object.assign({}, vector)),
          egressJoinIndex: existingLeg.calculated.egressJoinIndex,
          egress: existingLeg.calculated.egress.map((vector) => Object.assign({}, vector)),
          endsInFallback: existingLeg.calculated.endsInFallback
        };
      }
      return newLeg;
    }
  };
  FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
  }, partial);
  var SubEvent = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    on(handler, paused = false) {
      const sub = new HandlerSubscription(handler, void 0, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      }
      return sub;
    }
    /** @inheritdoc */
    off(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /** @inheritdoc */
    clear() {
      this.notifyDepth++;
      for (let i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }
      this.notifyDepth--;
      if (this.notifyDepth === 0) {
        this.subs.length = 0;
      }
    }
    /** @inheritdoc */
    notify(sender, data) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(sender, data);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`SubEvent: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
  };
  var FlightPlanner = class {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(bus, calculator, onLegNameRequested = FlightPlanner.buildDefaultLegName) {
      this.bus = bus;
      this.calculator = calculator;
      this.onLegNameRequested = onLegNameRequested;
      this.flightPlans = [];
      this.ignoreSync = false;
      this._activePlanIndex = 0;
      this.flightPlanSynced = new SubEvent();
      this.publisher = bus.getPublisher();
      const subscriber = bus.getSubscriber();
      subscriber.on("fplsync_fplRequest").handle((data) => !this.ignoreSync && this.onFlightPlanRequest(data));
      subscriber.on("fplsync_fplResponse").handle((data) => !this.ignoreSync && this.onFlightPlanResponse(data));
      subscriber.on("fplsync_fplCreated").handle((data) => !this.ignoreSync && this.onPlanCreated(data));
      subscriber.on("fplsync_fplDeleted").handle((data) => !this.ignoreSync && this.onPlanDeleted(data));
      subscriber.on("fplsync_fplActiveLegChange").handle((data) => !this.ignoreSync && this.onActiveLegChanged(data));
      subscriber.on("fplsync_fplLegChange").handle((data) => !this.ignoreSync && this.onLegChanged(data));
      subscriber.on("fplsync_fplSegmentChange").handle((data) => !this.ignoreSync && this.onSegmentChanged(data));
      subscriber.on("fplsync_fplCalculated").handle((data) => !this.ignoreSync && this.onCalculated(data));
      subscriber.on("fplsync_fplOriginDestChanged").handle((data) => !this.ignoreSync && this.onOriginDestChanged(data));
      subscriber.on("fplsync_fplProcDetailsChanged").handle((data) => !this.ignoreSync && this.onProcedureDetailsChanged(data));
      subscriber.on("fplsync_fplIndexChanged").handle((data) => !this.ignoreSync && this.onPlanIndexChanged(data));
      subscriber.on("fplsync_fplCopied").handle((data) => !this.ignoreSync && this.onPlanCopied(data));
      subscriber.on("fplsync_fplUserDataSet").handle((data) => !this.ignoreSync && this.onUserDataSet(data));
      subscriber.on("fplsync_fplUserDataDelete").handle((data) => !this.ignoreSync && this.onUserDataDelete(data));
      subscriber.on("fplsync_fplDirectToDataChanged").handle((data) => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
      this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
      return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
      this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    onFlightPlanRequest(data) {
      this.ignoreSync = true;
      this.publisher.pub("fplsync_fplResponse", {
        uid: data.uid,
        flightPlans: this.flightPlans.map((plan) => {
          const newPlan = Object.assign({}, plan);
          newPlan.calculator = void 0;
          return newPlan;
        }),
        planIndex: this.activePlanIndex
      }, true, false);
      this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
      this.ignoreSync = true;
      this.publisher.pub("fplsync_fplRequest", { uid: this.lastRequestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER) }, true, false);
      this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
      if (data.uid !== this.lastRequestUid) {
        return;
      }
      this.lastRequestUid = void 0;
      for (let i = 0; i < data.flightPlans.length; i++) {
        if (data.flightPlans[i].segmentCount === 0) {
          continue;
        }
        const newPlan = Object.assign(new FlightPlan(i, this.calculator, this.onLegNameRequested), data.flightPlans[i]);
        newPlan.events = this.buildPlanEventHandlers(i);
        this.flightPlans[i] = newPlan;
        this.sendEvent("fplLoaded", { planIndex: i }, false);
        newPlan.calculate(0);
      }
      this.setActivePlanIndex(data.planIndex);
      this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
      return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
      const plan = this.flightPlans[planIndex];
      if (!plan) {
        throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
      }
      return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
      if (this.flightPlans[planIndex]) {
        return this.flightPlans[planIndex];
      }
      const flightPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
      flightPlan.events = this.buildPlanEventHandlers(planIndex);
      this.flightPlans[planIndex] = flightPlan;
      notify && this.sendPlanCreated(planIndex);
      return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
      this.createFlightPlan(data.planIndex, false);
      this.sendEvent("fplCreated", data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
      const data = { planIndex };
      this.sendEvent("fplCreated", data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
      const flightPlan = this.flightPlans[planIndex];
      if (flightPlan) {
        flightPlan.events = {};
        this.flightPlans[planIndex] = void 0;
        notify && this.sendPlanDeleted(planIndex);
      }
      if (planIndex === this.flightPlans.length - 1) {
        this.flightPlans.length--;
      }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
      this.deleteFlightPlan(data.planIndex, false);
      this.sendEvent("fplDeleted", data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
      const data = { planIndex };
      this.sendEvent("fplDeleted", data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
      return {
        onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
        onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
        onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
        onCalculated: (index) => this.sendCalculated(planIndex, index),
        onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
        onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
        onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
        onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
        onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
      };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
      return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
      return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, copyCalcs = false, notify = true) {
      const sourcePlan = this.flightPlans[sourcePlanIndex];
      if (!sourcePlan) {
        return;
      }
      const newPlan = sourcePlan.copy(targetPlanIndex, copyCalcs);
      newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
      this.flightPlans[targetPlanIndex] = newPlan;
      if (notify) {
        this.sendPlanCopied(sourcePlanIndex, targetPlanIndex, copyCalcs);
      }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
      this.copyFlightPlan(data.planIndex, data.targetPlanIndex, data.copyCalcs, false);
      this.sendEvent("fplCopied", data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    sendPlanCopied(planIndex, targetPlanIndex, copyCalcs) {
      const data = { planIndex, targetPlanIndex, copyCalcs };
      this.sendEvent("fplCopied", data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
      const plan = this.getFlightPlan(data.planIndex);
      let localLeg;
      switch (data.type) {
        case LegEventType.Added: {
          localLeg = plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
          break;
        }
        case LegEventType.Removed: {
          const leg = plan.removeLeg(data.segmentIndex, data.legIndex, false);
          if (!leg) {
            return;
          }
          localLeg = leg;
          break;
        }
        case LegEventType.Changed: {
          try {
            localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
          } catch (_a) {
            return;
          }
          plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
          break;
        }
      }
      const localData = {
        planIndex: data.planIndex,
        type: data.type,
        segmentIndex: data.segmentIndex,
        legIndex: data.legIndex,
        leg: localLeg
      };
      this.sendEvent("fplLegChange", localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
      const data = {
        planIndex,
        segmentIndex,
        legIndex: index,
        type,
        leg
      };
      this.sendEvent("fplLegChange", data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
      var _a, _b;
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      let localSegment = void 0;
      switch (data.type) {
        case SegmentEventType.Added:
          localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
          break;
        case SegmentEventType.Inserted:
          localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
          break;
        case SegmentEventType.Removed:
          localSegment = (_a = plan.tryGetSegment(data.segmentIndex)) !== null && _a !== void 0 ? _a : void 0;
          plan.removeSegment(data.segmentIndex, false);
          break;
        case SegmentEventType.Changed:
          localSegment = data.segment === void 0 ? void 0 : (_b = plan.tryGetSegment(data.segmentIndex)) !== null && _b !== void 0 ? _b : void 0;
          if (localSegment === void 0) {
            return;
          }
          plan.setAirway(data.segmentIndex, data.segment.airway, false);
          break;
      }
      const localData = {
        planIndex: data.planIndex,
        type: data.type,
        segmentIndex: data.segmentIndex,
        segment: localSegment
      };
      this.sendEvent("fplSegmentChange", localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
      const data = {
        planIndex,
        segmentIndex: index,
        type,
        segment
      };
      this.sendEvent("fplSegmentChange", data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      switch (data.type) {
        case ActiveLegType.Lateral:
          plan.setLateralLeg(data.index, false);
          break;
        case ActiveLegType.Vertical:
          plan.setVerticalLeg(data.index, false);
          break;
        case ActiveLegType.Calculating:
          plan.setCalculatingLeg(data.index, false);
          break;
      }
      this.sendEvent("fplActiveLegChange", data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
      const data = {
        segmentIndex,
        legIndex,
        planIndex,
        index,
        previousSegmentIndex,
        previousLegIndex,
        type
      };
      this.sendEvent("fplActiveLegChange", data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      await plan.calculate(data.index, false);
      if (this.flightPlans[data.planIndex] !== plan) {
        return;
      }
      this.sendEvent("fplCalculated", data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
      const data = { planIndex, index };
      this.sendEvent("fplCalculated", data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      switch (data.type) {
        case OriginDestChangeType.OriginAdded:
          data.airport && plan.setOriginAirport(data.airport, false);
          break;
        case OriginDestChangeType.OriginRemoved:
          plan.removeOriginAirport(false);
          break;
        case OriginDestChangeType.DestinationAdded:
          data.airport && plan.setDestinationAirport(data.airport, false);
          break;
        case OriginDestChangeType.DestinationRemoved:
          plan.removeDestinationAirport(false);
          break;
      }
      this.sendEvent("fplOriginDestChanged", data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
      const data = { planIndex, type, airport };
      this.sendEvent("fplOriginDestChanged", data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      plan.setProcedureDetails(data.details, false);
      this.sendEvent("fplProcDetailsChanged", data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
      const data = { planIndex, details };
      this.sendEvent("fplProcDetailsChanged", data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
      this.activePlanIndex = data.planIndex;
      this.sendEvent("fplIndexChanged", data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
      const data = { planIndex };
      this.sendEvent("fplIndexChanged", data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      plan.setUserData(data.key, data.data, false);
      this.sendEvent("fplUserDataSet", data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      plan.deleteUserData(data.key, false);
      this.sendEvent("fplUserDataDelete", data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
      const data = { planIndex, key, data: userData };
      this.sendEvent("fplUserDataSet", data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
      const data = { planIndex, key, data: void 0 };
      this.sendEvent("fplUserDataDelete", data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
      const plan = this.flightPlans[data.planIndex];
      if (!plan) {
        return;
      }
      plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
      this.sendEvent("fplDirectToDataChanged", data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
      const data = { planIndex, directToData };
      this.sendEvent("fplDirectToDataChanged", data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
      if (this.hasFlightPlan(planIndex)) {
        this.activePlanIndex = planIndex;
        this.sendPlanIndexChanged(planIndex);
      }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
      if (sync) {
        this.ignoreSync = true;
        this.publisher.pub(`fplsync_${topic}`, data, true, false);
        this.ignoreSync = false;
      }
      this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator, onLegNameRequested) {
      var _a;
      return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator, onLegNameRequested);
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
      let legDistanceNM;
      switch (leg.type) {
        case LegType.CA:
        case LegType.FA:
        case LegType.VA:
          return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
        case LegType.FM:
        case LegType.VM:
          return "MANSEQ";
        case LegType.FC:
          legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
          return `D${leg.course.toFixed(0).padStart(3, "0")}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
        case LegType.CD:
        case LegType.FD:
        case LegType.VD:
          legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
          return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
        case LegType.CR:
        case LegType.VR:
          return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
        case LegType.CI:
        case LegType.VI:
          return "INTRCPT";
        case LegType.PI:
          return "PROC. TURN";
        case LegType.HA:
        case LegType.HM:
        case LegType.HF:
          return "HOLD";
        default:
          return ICAO.getIdent(leg.fixIcao);
      }
    }
  };
  var FlightPlanLegIterator = class {
    constructor() {
      this.cursor = {
        segment: void 0,
        legIndex: -1,
        legDefinition: void 0,
        index: 0
      };
      this.cursorIsBusy = false;
    }
    /**
     * Method that checks whether the FlightPlanLegIterator is busy.
     * @returns Whether the cursor is busy.
     */
    isBusy() {
      return this.cursorIsBusy;
    }
    /**
     * Iterates through the active flight plan in reverse order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateReverse(lateralPlan, each) {
      if (this.cursorIsBusy) {
        throw new Error("FlightPlanLegIterator - iterateReverse: The iterator cursor is busy");
      }
      this.cursorIsBusy = true;
      let segmentIndex = lateralPlan.segmentCount - 1;
      let index = 0;
      try {
        while (segmentIndex >= 0) {
          const segment = lateralPlan.getSegment(segmentIndex);
          let legIndex = segment.legs.length - 1;
          while (legIndex >= 0) {
            this.cursor.legDefinition = segment.legs[legIndex];
            this.cursor.legIndex = legIndex;
            this.cursor.segment = segment;
            this.cursor.index = index;
            each(this.cursor);
            legIndex--;
            index++;
          }
          segmentIndex--;
        }
      } catch (error) {
        console.error(`FlightPlanLegIterator - iterateReverse: error in while loop: ${error}`);
        if (error instanceof Error) {
          console.error(error.stack);
        }
      }
      this.cursorIsBusy = false;
    }
    /**
     * Iterates through the active flight plan in forward order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateForward(lateralPlan, each) {
      if (this.cursorIsBusy) {
        throw new Error("FlightPlanLegIterator - iterateForward: The iterator cursor is busy");
      }
      this.cursorIsBusy = true;
      let segmentIndex = 0;
      let index = 0;
      try {
        while (segmentIndex < lateralPlan.segmentCount) {
          const segment = lateralPlan.getSegment(segmentIndex);
          let legIndex = 0;
          while (legIndex < segment.legs.length) {
            this.cursor.legDefinition = segment.legs[legIndex];
            this.cursor.legIndex = legIndex;
            this.cursor.segment = segment;
            this.cursor.index = index;
            each(this.cursor);
            legIndex++;
            index++;
          }
          segmentIndex++;
        }
      } catch (error) {
        console.error(`FlightPlanLegIterator - iterateForward: error in while loop: ${error}`);
        if (error instanceof Error) {
          console.error(error.stack);
        }
      }
      this.cursorIsBusy = false;
    }
  };
  var WaypointTypes;
  (function(WaypointTypes2) {
    WaypointTypes2["Custom"] = "Custom";
    WaypointTypes2["Airport"] = "Airport";
    WaypointTypes2["NDB"] = "NDB";
    WaypointTypes2["VOR"] = "VOR";
    WaypointTypes2["Intersection"] = "Intersection";
    WaypointTypes2["Runway"] = "Runway";
    WaypointTypes2["User"] = "User";
    WaypointTypes2["Visual"] = "Visual";
    WaypointTypes2["FlightPlan"] = "FlightPlan";
    WaypointTypes2["VNAV"] = "VNAV";
  })(WaypointTypes || (WaypointTypes = {}));
  var AbstractWaypoint = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(other) {
      return this.uid === other.uid;
    }
  };
  var CustomWaypoint = class extends AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2, arg3) {
      super();
      let location;
      let uid;
      if (typeof arg1 === "number") {
        location = GeoPointSubject.createFromGeoPoint(new GeoPoint(arg1, arg2));
        uid = `${arg3}[${location.get().lat},${location.get().lon}]`;
      } else {
        location = arg1;
        uid = arg2;
      }
      this._location = location;
      this._uid = uid;
    }
    /** @inheritdoc */
    get location() {
      return this._location;
    }
    /** @inheritdoc */
    get uid() {
      return this._uid;
    }
    /** @inheritdoc */
    get type() {
      return WaypointTypes.Custom;
    }
  };
  var BasicFacilityWaypoint = class extends AbstractWaypoint {
    /**
     * Constructor.
     * @param facility The facility associated with this waypoint.
     * @param bus The event bus.
     */
    constructor(facility, bus) {
      super();
      this.bus = bus;
      this.isFacilityWaypoint = true;
      this._facility = Subject.create(facility);
      this._location = GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat, facility.lon));
      this._type = BasicFacilityWaypoint.getType(facility);
      const facType = ICAO.getFacilityType(facility.icao);
      if (facType === FacilityType.VIS || facType === FacilityType.USR) {
        this.facChangeSub = this.bus.getSubscriber().on(`facility_changed_${facility.icao}`).handle((newFacility) => {
          this._facility.set(newFacility);
          this._location.set(newFacility.lat, newFacility.lon);
        });
      }
    }
    /** @inheritdoc */
    get location() {
      return this._location;
    }
    /** @inheritdoc */
    get uid() {
      return this.facility.get().icao;
    }
    /** @inheritdoc */
    get type() {
      return this._type;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The facility associated with this waypoint.
     */
    get facility() {
      return this._facility;
    }
    /**
     * Gets a waypoint type from a facility.
     * @param facility A facility.
     * @returns The waypoint type corresponding to the facility.
     */
    static getType(facility) {
      switch (ICAO.getFacilityType(facility.icao)) {
        case FacilityType.Airport:
          return WaypointTypes.Airport;
        case FacilityType.Intersection:
          return WaypointTypes.Intersection;
        case FacilityType.NDB:
          return WaypointTypes.NDB;
        case FacilityType.RWY:
          return WaypointTypes.Runway;
        case FacilityType.USR:
          return WaypointTypes.User;
        case FacilityType.VIS:
          return WaypointTypes.Visual;
        case FacilityType.VOR:
          return WaypointTypes.VOR;
        default:
          return WaypointTypes.User;
      }
    }
  };
  var FacilityWaypointUtils = class {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isFacilityWaypoint(waypoint, facilityType) {
      if (waypoint.isFacilityWaypoint !== true) {
        return false;
      }
      return facilityType === void 0 || FacilityUtils.isFacilityType(waypoint.facility.get(), facilityType);
    }
  };
  var FlightPathWaypoint = class extends AbstractWaypoint {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2, arg3, arg4, arg5) {
      super();
      if (typeof arg1 === "number") {
        this._location = GeoPointSubject.create(new GeoPoint(arg1, arg2));
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg4}`;
        this.leg = arg3;
        this.ident = arg5;
      } else {
        this._location = arg1;
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg3}`;
        this.leg = arg2;
        this.ident = arg4;
      }
    }
    /** @inheritdoc */
    get location() {
      return this._location;
    }
    /** @inheritdoc */
    get uid() {
      return this._uid;
    }
    /** @inheritdoc */
    get type() {
      return WaypointTypes.FlightPlan;
    }
  };
  FlightPathWaypoint.UID_PREFIX = "FLPTH";
  var VNavWaypoint = class extends AbstractWaypoint {
    /**
     * Constructor.
     * @param leg The leg that the VNAV waypoint is contained in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param uid A unique ID to assign to the VNAV waypoint.
     * @param ident This waypoint's ident string.
     */
    constructor(leg, distanceFromEnd, uid, ident) {
      super();
      this.ident = ident;
      this._uid = uid;
      this._location = GeoPointSubject.create(this.getWaypointLocation(leg, distanceFromEnd, new GeoPoint(0, 0)));
    }
    /** @inheritdoc */
    get type() {
      return WaypointTypes.VNAV;
    }
    /** @inheritdoc */
    get location() {
      return this._location;
    }
    /** @inheritdoc */
    get uid() {
      return this._uid;
    }
    /**
     * Sets this waypoint's location.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     */
    setLocation(leg, distanceFromEnd) {
      this._location.set(this.getWaypointLocation(leg, distanceFromEnd, VNavWaypoint.geoPointCache[0]));
    }
    /**
     * Gets the waypoint's location in space.
     * @param leg The leg that the waypoint resides in.
     * @param distanceFromEnd The distance along the flight path from the end of the leg to the location of the waypoint,
     * in meters.
     * @param out The GeoPoint object to which to write the location.
     * @returns The waypoint's location.
     */
    getWaypointLocation(leg, distanceFromEnd, out) {
      var _a, _b;
      if (leg.calculated !== void 0) {
        const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
        let vectorIndex = vectors.length - 1;
        while (vectorIndex >= 0) {
          const vector = vectors[vectorIndex];
          const vectorDistance = vector.distance;
          if (vectorDistance >= distanceFromEnd) {
            const end = GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, VNavWaypoint.vec3Cache[0]);
            return FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]).offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out, Math.PI);
          } else {
            distanceFromEnd -= vectorDistance;
          }
          vectorIndex--;
        }
        if (vectors.length > 0) {
          out.set(vectors[0].startLat, vectors[0].startLon);
        } else {
          out.set((_a = leg.calculated.endLat) !== null && _a !== void 0 ? _a : 0, (_b = leg.calculated.endLon) !== null && _b !== void 0 ? _b : 0);
        }
      }
      return out;
    }
  };
  VNavWaypoint.vec3Cache = [new Float64Array(3)];
  VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
  VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var DefaultFacilityWaypointCache = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param size The maximum size of this cache.
     */
    constructor(bus, size) {
      this.bus = bus;
      this.size = size;
      this.cache = /* @__PURE__ */ new Map();
    }
    /** @inheritdoc */
    get(facility) {
      const key = DefaultFacilityWaypointCache.getFacilityKey(facility);
      let existing = this.cache.get(key);
      if (!existing) {
        existing = new BasicFacilityWaypoint(facility, this.bus);
        this.addToCache(key, existing);
      }
      return existing;
    }
    /**
     * Adds a waypoint to this cache. If the size of the cache is greater than the maximum after the new waypoint is
     * added, a waypoint will be removed from the cache in FIFO order.
     * @param key The key of the waypoint to add.
     * @param waypoint The waypoint to add.
     */
    addToCache(key, waypoint) {
      this.cache.set(key, waypoint);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    /**
     * Gets a FacilityWaypointCache instance.
     * @param bus The event bus.
     * @returns A FacilityWaypointCache instance.
     */
    static getCache(bus) {
      var _a;
      return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(bus, 1e3);
    }
    /**
     * Gets the cache key for a facility.
     * @param facility A facility.
     * @returns The cache key for the specified facility.
     */
    static getFacilityKey(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection) && ICAO.getFacilityType(facility.icao) !== FacilityType.Intersection) {
        return `mismatch.${facility.icao}`;
      }
      return facility.icao;
    }
  };
  var DefaultLodBoundaryCache = class {
    /**
     * Gets an instance of DefaultLodBoundaryCache.
     * @returns An instance of DefaultLodBoundaryCache.
     */
    static getCache() {
      var _a;
      return (_a = DefaultLodBoundaryCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultLodBoundaryCache.INSTANCE = new LodBoundaryCache(DefaultLodBoundaryCache.SIZE, DefaultLodBoundaryCache.DISTANCE_THRESHOLDS, DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS);
    }
  };
  DefaultLodBoundaryCache.SIZE = 500;
  DefaultLodBoundaryCache.DISTANCE_THRESHOLDS = [0, 3e-5, 1e-4, 3e-4];
  DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS = [500, 300, 200, 100];
  var SubscribableMapFunctions = class {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity() {
      return (input) => input;
    }
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not() {
      return (input) => !input;
    }
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate() {
      return (input) => -input;
    }
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs() {
      return Math.abs;
    }
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision(precision) {
      return SubscribableUtils.isSubscribable(precision) ? (input) => {
        const precisionVal = precision.get();
        return Math.round(input / precisionVal) * precisionVal;
      } : (input) => {
        return Math.round(input / precision) * precision;
      };
    }
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy(threshold) {
      return SubscribableUtils.isSubscribable(threshold) ? (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal : (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency(freq, timeFunc = Date.now) {
      let t0;
      let timeRemaining = 0;
      if (SubscribableUtils.isSubscribable(freq)) {
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            const period = 1e3 / freq.get();
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      } else {
        const period = 1e3 / freq;
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      }
    }
  };
  var MappedSubject = class extends AbstractSubscribable {
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
      super();
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      this.inputs = inputs;
      this.inputValues = inputs.map((input) => input.get());
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.inputValues, void 0));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.inputValues, void 0);
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSubs = this.inputs.map((input, index) => input.sub((inputValue) => {
        this.inputValues[index] = inputValue;
        this.updateValue();
      }));
    }
    /** @inheritdoc */
    get isAlive() {
      return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
      return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(...args) {
      let mapFunc, equalityFunc, mutateFunc, initialVal;
      if (typeof args[0] === "function") {
        mapFunc = args.shift();
        if (typeof args[0] === "function") {
          equalityFunc = args.shift();
        } else {
          equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
        }
        if (typeof args[0] === "function") {
          mutateFunc = args.shift();
          initialVal = args.shift();
        }
      } else {
        mapFunc = MappedSubject.IDENTITY_MAP;
        equalityFunc = MappedSubject.NEVER_EQUALS;
      }
      return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    updateValue() {
      const value = this.mapFunc(this.inputValues, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    /** @inheritdoc */
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot pause a dead subject");
      }
      if (this._isPaused) {
        return this;
      }
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].pause();
      }
      this._isPaused = true;
      return this;
    }
    /** @inheritdoc */
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot resume a dead subject");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputValues[i] = this.inputs[i].get();
        this.inputSubs[i].resume();
      }
      this.updateValue();
      return this;
    }
    /** @inheritdoc */
    destroy() {
      this._isAlive = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].destroy();
      }
    }
  };
  MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
  MappedSubject.NEVER_EQUALS = () => false;
  var SubscribableSetEventType;
  (function(SubscribableSetEventType2) {
    SubscribableSetEventType2["Added"] = "Added";
    SubscribableSetEventType2["Deleted"] = "Deleted";
  })(SubscribableSetEventType || (SubscribableSetEventType = {}));
  var SubscribableSetPipe = class extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
      let handler;
      let initialNotifyFunc;
      let onDestroy;
      if (typeof arg4 === "function") {
        const toCast = to;
        const map = arg3;
        handler = (set, type, key) => {
          if (type === SubscribableSetEventType.Added) {
            toCast.add(map(key));
          } else {
            const mappedKey = map(key);
            for (const inputKey of set) {
              if (map(inputKey) === mappedKey) {
                return;
              }
            }
            toCast.delete(mappedKey);
          }
        };
        initialNotifyFunc = () => {
          const fromSet = from.get();
          const toAdd = /* @__PURE__ */ new Set();
          for (const key of fromSet) {
            toAdd.add(map(key));
          }
          for (const key of toCast.get()) {
            if (!toAdd.delete(key)) {
              toCast.delete(key);
            }
          }
          for (const key of toAdd) {
            toCast.add(key);
          }
        };
        onDestroy = arg4;
      } else {
        const toCast = to;
        handler = (set, type, key) => {
          if (type === SubscribableSetEventType.Added) {
            toCast.add(key);
          } else {
            toCast.delete(key);
          }
        };
        initialNotifyFunc = () => {
          const fromSet = from.get();
          const toAdd = new Set(fromSet);
          for (const key of to.get()) {
            if (!toAdd.delete(key)) {
              toCast.delete(key);
            }
          }
          for (const key of toAdd) {
            toCast.add(key);
          }
        };
        onDestroy = arg3;
      }
      super(handler, initialNotifyFunc, onDestroy);
    }
  };
  var AbstractSubscribableSet = class {
    constructor() {
      this.isSubscribable = true;
      this.isSubscribableSet = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
      return this.get().size;
    }
    /** @inheritdoc */
    has(key) {
      return this.get().has(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    notify(type, key) {
      const set = this.get();
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(set, type, key);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`AbstractSubscribableSet: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
      const set = this.get();
      for (const key of set) {
        sub.handler(set, SubscribableSetEventType.Added, key);
      }
    }
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
      const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
      return mutateFunc ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this) : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        if ("isSubscribableSet" in to) {
          sub = new SubscribableSetPipe(this, to, arg2, this.onSubDestroyedFunc);
        } else {
          sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        }
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        if ("isSubscribableSet" in to) {
          sub = new SubscribableSetPipe(this, to, this.onSubDestroyedFunc);
        } else {
          sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        }
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  var ArraySubject = class extends AbstractSubscribableArray {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
      super();
      this.array = arr;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of this array. */
    get length() {
      return this.array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
      return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index) {
      if (index === void 0 || index > this.array.length - 1) {
        index = this.array.length;
        this.array.push(item);
      } else {
        this.array.splice(index, 0, item);
      }
      this.notify(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
      this.array.splice(index, 0, ...arr);
      this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
      const removedItem = this.array.splice(index, 1);
      this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
      const index = this.array.indexOf(item);
      if (index > -1) {
        this.removeAt(index);
        return true;
      } else {
        return false;
      }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
      this.clear();
      this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
      this.array.length = 0;
      this.notify(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
      return this.array;
    }
  };
  var CombinedSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(...inputs) {
      super();
      this._isAlive = true;
      this._isPaused = false;
      this.inputs = inputs;
      this.inputValues = inputs.map((input) => input.get());
      this.inputSubs = this.inputs.map((input, index) => input.sub((inputValue) => {
        this.inputValues[index] = inputValue;
        this.notify();
      }));
    }
    /** @inheritdoc */
    get isAlive() {
      return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
      return this._isPaused;
    }
    /**
     * Creates a new subject whose state is a combined tuple of an arbitrary number of input values.
     * @param inputs The subscribables which provide the inputs to the new subject.
     * @returns A new subject whose state is a combined tuple of the specified input values.
     */
    static create(...inputs) {
      return new CombinedSubject(...inputs);
    }
    /** @inheritdoc */
    get() {
      return this.inputValues;
    }
    /** @inheritdoc */
    pause() {
      if (!this._isAlive) {
        throw new Error("CombinedSubject: cannot pause a dead subject");
      }
      if (this._isPaused) {
        return this;
      }
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].pause();
      }
      this._isPaused = true;
      return this;
    }
    /** @inheritdoc */
    resume() {
      if (!this._isAlive) {
        throw new Error("CombinedSubject: cannot resume a dead subject");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputValues[i] = this.inputs[i].get();
        this.inputSubs[i].resume();
      }
      this.notify();
      return this;
    }
    /** @inheritdoc */
    destroy() {
      this._isAlive = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].destroy();
      }
    }
  };
  var ComputedSubject = class {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
      this.computeFn = computeFn;
      this.isSubscribable = true;
      this.isMutableSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.notifySubscription.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
      this.rawValue = value;
      this.value = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
      return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
      this.rawValue = value;
      const compValue = this.computeFn(value);
      if (compValue !== this.value) {
        this.value = compValue;
        this.notify();
      }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
      return this.value;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
      return this.rawValue;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    notify() {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            this.notifySubscription(sub);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ComputedSubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
      sub.handler(this.value, this.rawValue);
    }
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
      const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
      return mutateFunc ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this) : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  var ObjectSubject = class {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
      this.obj = obj;
      this.isSubscribable = true;
      this.isMutableSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
      return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
      return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
      const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else if (initialNotify) {
        sub.initialNotify();
      }
      return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
      const toDestroy = this.subs.find((sub) => sub.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
      if (typeof arg1 === "object") {
        for (const prop in arg1) {
          if (prop in this.obj) {
            this.set(prop, arg1[prop]);
          }
        }
      } else {
        const oldValue = this.obj[arg1];
        if (value !== oldValue) {
          this.obj[arg1] = value;
          this.notify(arg1, oldValue);
        }
      }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub = this.subs[i];
          if (sub.isAlive && !sub.isPaused) {
            sub.handler(this.obj, key, this.obj[key], oldValue);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        } catch (error) {
          console.error(`ObjectSubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub) => sub.isAlive);
      }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
      for (const key in this.obj) {
        const v = this.obj[key];
        sub.handler(this.obj, key, v, v);
      }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub), 1);
      }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
      const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
      return mutateFunc ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this) : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
      let sub;
      let paused;
      if (typeof arg2 === "function") {
        sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub);
      if (paused) {
        sub.pause();
      } else {
        sub.initialNotify();
      }
      return sub;
    }
  };
  var SetSubject = class extends AbstractSubscribableSet {
    /**
     * Constructor.
     * @param initialKeys The keys with which to initialize this set. If not defined, this set will be initialized to the
     * empty set.
     */
    constructor(initialKeys) {
      super();
      this.isMutableSubscribable = true;
      this.isMutableSubscribableSet = true;
      this.backingSet = new Set(initialKeys);
    }
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not undefined, the new set will be initialized
     * to the empty set.
     * @returns A new SetSubject instance.
     */
    static create(initialKeys) {
      return new SetSubject(initialKeys);
    }
    /** @inheritdoc */
    get() {
      return this.backingSet;
    }
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys) {
      const toAdd = new Set(keys);
      for (const key of this.backingSet) {
        if (!toAdd.delete(key)) {
          this.delete(key);
        }
      }
      for (const key of toAdd) {
        this.add(key);
      }
    }
    /** @inheritdoc */
    add(key) {
      const oldSize = this.backingSet.size;
      this.backingSet.add(key);
      if (oldSize !== this.backingSet.size) {
        this.notify(SubscribableSetEventType.Added, key);
      }
      return this;
    }
    /** @inheritdoc */
    delete(key) {
      const wasDeleted = this.backingSet.delete(key);
      if (wasDeleted) {
        this.notify(SubscribableSetEventType.Deleted, key);
      }
      return wasDeleted;
    }
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set. If not defined, the key will be added to this set if it is not already present and
     * removed if it is already present.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key, force) {
      const shouldAdd = force !== null && force !== void 0 ? force : !this.backingSet.has(key);
      if (shouldAdd) {
        this.add(key);
      } else {
        this.delete(key);
      }
      return this.backingSet.has(key);
    }
    /**
     * Removes all keys from this set.
     */
    clear() {
      for (const key of this.backingSet) {
        this.backingSet.delete(key);
        this.notify(SubscribableSetEventType.Deleted, key);
      }
    }
  };
  var NearestContext = class {
    /**
     * Creates an instance of a NearestContext.
     * @param facilityLoader The facility loader to use for this instance.
     * @param bus An instance of the EventBus.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     */
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this.airports = new NearestAirportSubscription(facilityLoader);
      this.vors = new NearestVorSubscription(facilityLoader);
      this.intersections = new NearestIntersectionSubscription(facilityLoader);
      this.ndbs = new NearestNdbSubscription(facilityLoader);
      this.usrs = new NearestUsrSubscription(facilityLoader);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    /**
     * Gets an instance of the NearestContext.
     * @returns An instance of the NearestContext.
     * @throws An error if the NearestContext has not yet been initailized.
     */
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("NearestContext was not initialized.");
    }
    /**
     * Initialized the NearestContext instance.
     * @param facilityLoader The facility loader to use for the instance.
     * @param bus The EventBus to use with this instance.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     * @throws An error if the NearestContext is already initialized.
     */
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new NearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("NearestContext was already initialized.");
      }
    }
    /**
     * Subscribes to this NearestContext being initialized, or invokes the handler immediately if it is already initialized
     *
     * @param handler the handler
     *
     * @returns the subscription, if the action was not immediately performed
     */
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    /**
     * Updates the NearestContext.
     */
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    /**
     * Get the local ICAO region code based on nearby facility data.
     * @returns The region code.
     */
    getRegionCode() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region;
        }
      }
      return void 0;
    }
    /**
     * Get the variant of the region code used in airport idents.   Generally this will
     * be the region code except for the case of the US, where it will just be 'K'.
     * @returns The region code or just 'K' for the US.
     */
    getRegionIdent() {
      const region = this.getRegionCode();
      if (region !== void 0) {
        return region[0] === "K" ? "K" : region;
      }
      return void 0;
    }
    /**
     * Gets the first letter of the local ICAO region code.
     * @returns The airport region letter.
     */
    getRegionLetter() {
      const region = this.getRegionCode();
      return region !== void 0 ? region[0] : void 0;
    }
    /**
     * Gets the nearest facility for a given type.
     * @param facilityType The type of facility.
     * @returns The nearest facility for a given type.
     */
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    /**
     * Orders facilities by their distance to the plane PPOS.
     * @param a The first facility.
     * @param b The second facility.
     * @returns The comparison order number.
     */
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  NearestContext.initializedSubEvent = new SubEvent();
  var AdaptiveNearestContext = class {
    /**
     * Creates an instance of a AdaptiveNearestContext.
     * @param facilityLoader The facility loader to use for this instance.
     * @param bus An instance of the EventBus.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     */
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this._maxAirportsAbsolute = Subject.create(100);
      this._maxVorsAbsolute = Subject.create(100);
      this._maxIntersectionsAbsolute = Subject.create(100);
      this._maxNdbsAbsolute = Subject.create(100);
      this._maxUsrsAbsolute = Subject.create(100);
      this.airports = new AdaptiveNearestSubscription(new NearestAirportSubscription(facilityLoader), this._maxAirportsAbsolute);
      this.vors = new AdaptiveNearestSubscription(new NearestVorSubscription(facilityLoader), this._maxVorsAbsolute);
      this.intersections = new AdaptiveNearestSubscription(new NearestIntersectionSubscription(facilityLoader), this._maxIntersectionsAbsolute);
      this.ndbs = new AdaptiveNearestSubscription(new NearestNdbSubscription(facilityLoader), this._maxNdbsAbsolute);
      this.usrs = new AdaptiveNearestSubscription(new NearestUsrSubscription(facilityLoader), this._maxUsrsAbsolute);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The maximum number of airports returned by this context's inner searches. */
    get maxAirportsAbsolute() {
      return this._maxAirportsAbsolute.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set maxAirportsAbsolute(val) {
      this._maxAirportsAbsolute.set(val);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The maximum number of VORs returned by this context's inner searches. */
    get maxVorsAbsolute() {
      return this._maxVorsAbsolute.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set maxVorsAbsolute(val) {
      this._maxVorsAbsolute.set(val);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The maximum number of intersections returned by this context's inner searches. */
    get maxIntersectionsAbsolute() {
      return this._maxIntersectionsAbsolute.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set maxIntersectionsAbsolute(val) {
      this._maxIntersectionsAbsolute.set(val);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The maximum number of NDBs returned by this context's inner searches. */
    get maxNdbsAbsolute() {
      return this._maxNdbsAbsolute.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set maxNdbsAbsolute(val) {
      this._maxNdbsAbsolute.set(val);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The maximum number of user facilities returned by this context's inner searches. */
    get maxUsrsAbsolute() {
      return this._maxUsrsAbsolute.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set maxUsrsAbsolute(val) {
      this._maxUsrsAbsolute.set(val);
    }
    /**
     * Gets an instance of the AdaptiveNearestContext.
     * @returns An instance of the AdaptiveNearestContext.
     * @throws An error if the AdaptiveNearestContext has not yet been initailized.
     */
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("AdaptiveNearestContext was not initialized.");
    }
    /**
     * Initialized the AdaptiveNearestContext instance.
     * @param facilityLoader The facility loader to use for the instance.
     * @param bus The EventBus to use with this instance.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     * @throws An error if the AdaptiveNearestContext is already initialized.
     */
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new AdaptiveNearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("AdaptiveNearestContext was already initialized.");
      }
    }
    /**
     * Subscribes to this NearestContext being initialized, or invokes the handler immediately if it is already initialized
     *
     * @param handler the handler
     *
     * @returns the subscription, if the action was not immediately performed
     */
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    /**
     * Updates this context.
     */
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    /**
     * Gets the airport region letter to use for the first character in waypoint inputs.
     * @returns The airport region letter.
     */
    getRegionLetter() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region[0];
        }
      }
      return void 0;
    }
    /**
     * Gets the nearest facility for a given type.
     * @param facilityType The type of facility.
     * @returns The nearest facility for a given type.
     */
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    /**
     * Orders facilities by their distance to the plane PPOS.
     * @param a The first facility.
     * @param b The second facility.
     * @returns The comparison order number.
     */
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  AdaptiveNearestContext.initializedSubEvent = new SubEvent();
  var IcaoSearchFilter;
  (function(IcaoSearchFilter2) {
    IcaoSearchFilter2[IcaoSearchFilter2["ALL"] = 0] = "ALL";
    IcaoSearchFilter2[IcaoSearchFilter2["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter2[IcaoSearchFilter2["VOR"] = 2] = "VOR";
    IcaoSearchFilter2[IcaoSearchFilter2["NDB"] = 3] = "NDB";
    IcaoSearchFilter2[IcaoSearchFilter2["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter2[IcaoSearchFilter2["USR"] = 5] = "USR";
  })(IcaoSearchFilter || (IcaoSearchFilter = {}));
  var IcaoSearch = class {
    /**
     * Constructor.
     * @param facilityRepo The local facility repository included in this search session.
     * @param filter The filter applied to this search session.
     */
    constructor(facilityRepo, filter) {
      this.facilityRepo = facilityRepo;
      this.filter = filter;
      this.searchGuid = this.genGuid();
      this.MAX_RETRIES = 6;
      this.filterMap = /* @__PURE__ */ new Map([
        [IcaoSearchFilter.ALL, "AVNW"],
        [IcaoSearchFilter.AIRPORT, "A"],
        [IcaoSearchFilter.VOR, "V"],
        [IcaoSearchFilter.NDB, "N"],
        [IcaoSearchFilter.INTERSECTION, "W"],
        [IcaoSearchFilter.USR, ""]
      ]);
      this.opId = 0;
      this.batch = new SimVar.SimVarBatch("C:fs9gps:IcaoSearchMatchedIcaosNumber", "C:fs9gps:IcaoSearchMatchedIcao");
      this.batch.add("C:fs9gps:IcaoSearchCurrentIcao", "string", "string");
    }
    /**
     * Executes a new search in this session with a specified ident string to match. Only one active search can run
     * simultaneously. Therefore, if doSearch() is called while a previous search is still running, the newer search will
     * pre-empt the older one, causing the older one to fail.
     * @param ident An ident string.
     * @returns a Promise which is fulfilled with an array of ICAO strings that matched the ident string.
     * @throws Error if the search was pre-empted by a newer one.
     */
    async doSearch(ident) {
      const opId = ++this.opId;
      let icaos;
      if (this.filter !== IcaoSearchFilter.USR) {
        await Promise.all([
          SimVar.SetSimVarValue("C:fs9gps:IcaoSearchStartCursor", "string", this.filterMap.get(this.filter), this.searchGuid),
          SimVar.SetSimVarValue("C:fs9gps:IcaoSearchEnterChar", "string", ident, this.searchGuid)
        ]);
        if (opId !== this.opId) {
          throw new Error("ICAO search was pre-empted by a newer search");
        }
        let retries = this.MAX_RETRIES;
        while (true) {
          await this.delay(20);
          const itemCount = SimVar.GetSimVarValue("C:fs9gps:IcaoSearchMatchedIcaosNumber", "number", this.searchGuid);
          if (itemCount > 0) {
            break;
          } else {
            if (retries == 0) {
              break;
            }
            retries--;
          }
        }
        if (opId !== this.opId) {
          throw new Error("ICAO search was pre-empted by a newer search");
        }
        icaos = await new Promise((resolve) => SimVar.GetSimVarArrayValues(this.batch, (items) => {
          if (opId !== this.opId) {
            throw new Error("ICAO search was pre-empted by a newer search");
          }
          const fs9gpsIcaos = this.mapResult(items);
          SimVar.SetSimVarValue("C:fs9gps:IcaoSearchMatchedIcao", "number", 0, this.searchGuid);
          resolve(fs9gpsIcaos);
        }, this.searchGuid));
      } else {
        icaos = [];
      }
      if (this.filter === IcaoSearchFilter.USR || this.filter === IcaoSearchFilter.ALL) {
        const userIcaos = [];
        this.facilityRepo.forEach((fac) => {
          if (ICAO.getIdent(fac.icao).search(ident) === 0) {
            userIcaos.push(fac.icao);
          }
        }, [FacilityType.USR]);
        icaos.push(...userIcaos);
      }
      if (icaos.length > 1) {
        icaos = icaos.filter((icao) => ICAO.getIdent(icao) === ident);
      }
      return icaos;
    }
    /**
     * Maps the search results to an array of ICAO strings.
     * @param items The search results.
     * @returns an array of ICAO strings.
     */
    mapResult(items) {
      return items.map((item) => item[0]);
    }
    /**
     * Artificial delay for skipping cycles during search.
     * @param time The time to wait.
     * @returns a Promise which fulfills when the delay expires.
     */
    async delay(time) {
      return new Promise((resolve) => setTimeout(() => resolve(), time));
    }
    /**
     * Generates a unique id for search context.
     * @returns A unique ID string.
     */
    genGuid() {
      return "SRCH-xxxyxxyy".replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    }
  };
  var ElectricalPublisher = class extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      super(ElectricalPublisher.simvars, bus, pacer);
      this.flightStarted = false;
      this.avBusList = ["elec_av1_bus", "elec_av2_bus"];
      for (const topic of this.avBusList) {
        if (bus.getTopicSubscriberCount(topic)) {
          this.subscribed.add(topic);
        }
      }
      bus.getSubscriber().on("event_bus_topic_first_sub").handle((event) => {
        if (this.avBusList.includes(event)) {
          this.subscribed.add(event);
        }
      });
      const gameStateSub = GameStateProvider.get().sub((state) => {
        if (state === GameState.briefing || state === GameState.ingame) {
          gameStateSub.destroy();
          this.flightStarted = true;
        }
      }, false, true);
      gameStateSub.resume(true);
    }
    /** @inheritdoc */
    onUpdate() {
      if (this.flightStarted) {
        super.onUpdate();
        if (this.av1BusLogic && this.subscribed.has("elec_av1_bus")) {
          this.publish("elec_av1_bus", this.av1BusLogic.getValue() !== 0);
        }
        if (this.av2BusLogic && this.subscribed.has("elec_av2_bus")) {
          this.publish("elec_av2_bus", this.av2BusLogic.getValue() !== 0);
        }
      }
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
      this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
      this.av2BusLogic = logicElement;
    }
  };
  ElectricalPublisher.simvars = /* @__PURE__ */ new Map([
    ["elec_master_battery", { name: "ELECTRICAL MASTER BATTERY", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_1", { name: "CIRCUIT AVIONICS ON:1", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_2", { name: "CIRCUIT AVIONICS ON:2", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom1_on", { name: "CIRCUIT NAVCOM1 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom2_on", { name: "CIRCUIT NAVCOM2 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom3_on", { name: "CIRCUIT NAVCOM3 ON", type: SimVarValueType.Bool }],
    ["elec_bus_main_v", { name: "ELECTRICAL MAIN BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_main_a", { name: "ELECTRICAL MAIN BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_avionics_v", { name: "ELECTRICAL AVIONICS BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_avionics_a", { name: "ELECTRICAL AVIONICS BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_1_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_2_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:2", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_1_a", { name: "ELECTRICAL GENALT BUS AMPS:1", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_2_a", { name: "ELECTRICAL GENALT BUS AMPS:2", type: SimVarValueType.Amps }],
    ["elec_bat_a_1", { name: "ELECTRICAL BATTERY LOAD:1", type: SimVarValueType.Amps }],
    ["elec_bat_v_1", { name: "ELECTRICAL BATTERY VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bat_a_2", { name: "ELECTRICAL BATTERY LOAD:2", type: SimVarValueType.Amps }],
    ["elec_bat_v_2", { name: "ELECTRICAL BATTERY VOLTAGE:2", type: SimVarValueType.Volts }]
  ]);
  var EISPublisher = class extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      const isUsingAdvancedFuelSystem = SimVar.GetSimVarValue("NEW FUEL SYSTEM", SimVarValueType.Bool) !== 0;
      const totalUnusableFuelGal = SimVar.GetSimVarValue("UNUSABLE FUEL TOTAL QUANTITY", SimVarValueType.GAL);
      const totalUnusableFuelLb = SimVar.GetSimVarValue("UNUSABLE FUEL TOTAL QUANTITY", SimVarValueType.LBS);
      const nonIndexedSimVars = [
        ["vac", { name: "SUCTION PRESSURE", type: SimVarValueType.InHG }],
        ["fuel_total", { name: "FUEL TOTAL QUANTITY", type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? (v) => v + totalUnusableFuelGal : void 0 }],
        ["fuel_total_weight", { name: "FUEL TOTAL QUANTITY WEIGHT", type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? (v) => v + totalUnusableFuelGal : void 0 }],
        ["fuel_usable_total", { name: "FUEL TOTAL QUANTITY", type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? void 0 : (v) => Math.max(v - totalUnusableFuelGal, 0) }],
        ["fuel_usable_total_weight", { name: "FUEL TOTAL QUANTITY WEIGHT", type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? void 0 : (v) => Math.max(v - totalUnusableFuelLb, 0) }],
        ["fuel_left", { name: "FUEL LEFT QUANTITY", type: SimVarValueType.GAL }],
        ["fuel_right", { name: "FUEL RIGHT QUANTITY", type: SimVarValueType.GAL }],
        ["fuel_left_main", { name: "FUEL TANK LEFT MAIN QUANTITY", type: SimVarValueType.GAL }],
        ["fuel_left_main_pct", { name: "FUEL TANK LEFT MAIN LEVEL", type: SimVarValueType.Percent }],
        ["fuel_right_main", { name: "FUEL TANK RIGHT MAIN QUANTITY", type: SimVarValueType.GAL }],
        ["fuel_right_main_pct", { name: "FUEL TANK RIGHT MAIN LEVEL", type: SimVarValueType.Percent }],
        ["fuel_center", { name: "FUEL TANK CENTER QUANTITY", type: SimVarValueType.GAL }],
        ["fuel_weight_per_gallon", { name: "FUEL WEIGHT PER GALLON", type: SimVarValueType.LBS }],
        ["fuel_tank_selector_state_1", { name: "FUEL TANK SELECTOR:1", type: SimVarValueType.Number }],
        ["fuel_tank_selector_state_2", { name: "FUEL TANK SELECTOR:2", type: SimVarValueType.Number }],
        ["fuel_tank_selector_state_3", { name: "FUEL TANK SELECTOR:3", type: SimVarValueType.Number }],
        ["fuel_tank_selector_state_4", { name: "FUEL TANK SELECTOR:4", type: SimVarValueType.Number }],
        ["eng_hours_1", { name: "GENERAL ENG ELAPSED TIME:1", type: SimVarValueType.Hours }],
        ["apu_pct", { name: "APU PCT RPM", type: SimVarValueType.Percent }]
      ];
      const engineIndexedSimVars = [
        ["rpm", { name: "GENERAL ENG RPM", type: SimVarValueType.RPM }],
        ["prop_rpm", { name: "PROP RPM", type: SimVarValueType.RPM }],
        ["n1", { name: "TURB ENG CORRECTED N1", type: SimVarValueType.Percent }],
        ["n2", { name: "TURB ENG CORRECTED N2", type: SimVarValueType.Percent }],
        ["torque", { name: "TURB ENG MAX TORQUE PERCENT", type: SimVarValueType.Percent }],
        ["fuel_flow", { name: "ENG FUEL FLOW GPH", type: SimVarValueType.GPH }],
        ["recip_ff", { name: "RECIP ENG FUEL FLOW", type: SimVarValueType.PPH }],
        ["oil_press", { name: "ENG OIL PRESSURE", type: SimVarValueType.PSI }],
        ["oil_temp", { name: "ENG OIL TEMPERATURE", type: SimVarValueType.Farenheit }],
        ["itt", { name: "TURB ENG ITT", type: SimVarValueType.Celsius }],
        ["egt", { name: "ENG EXHAUST GAS TEMPERATURE", type: SimVarValueType.Farenheit }],
        ["eng_hyd_press", { name: "ENG HYDRAULIC PRESSURE", type: SimVarValueType.PSI }],
        ["eng_starter_on", { name: "GENERAL ENG STARTER", type: SimVarValueType.Bool }],
        ["eng_combustion", { name: "GENERAL ENG COMBUSTION", type: SimVarValueType.Bool }],
        ["eng_ignition_switch_state", { name: "TURB ENG IGNITION SWITCH EX1", type: SimVarValueType.Number }],
        ["eng_igniting", { name: "TURB ENG IS IGNITING", type: SimVarValueType.Bool }],
        ["eng_fuel_pump_on", { name: "GENERAL ENG FUEL PUMP ON", type: SimVarValueType.Bool }],
        ["eng_fuel_pump_switch_state", { name: "GENERAL ENG FUEL PUMP SWITCH EX1", type: SimVarValueType.Number }],
        ["eng_vibration", { name: "ENG VIBRATION", type: SimVarValueType.Number }],
        ["eng_fuel_flow_switch", { name: "FUELSYSTEM VALVE OPEN", type: SimVarValueType.Bool }],
        ["fuel_flow_pph", { name: "ENG FUEL FLOW PPH", type: SimVarValueType.PPH }]
      ];
      const simvars = new Map(nonIndexedSimVars);
      const engineCount = SimVar.GetSimVarValue("NUMBER OF ENGINES", SimVarValueType.Number);
      for (const [topic, simvar2] of [...engineIndexedSimVars]) {
        for (let i = 1; i <= engineCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
      this.engineCount = engineCount;
      this.subscribed.add("fuel_flow_total");
    }
    /** @inheritdoc */
    onUpdate() {
      super.onUpdate();
      if (this.subscribed.has("fuel_flow_total")) {
        let totalFuelFlow = 0;
        for (let i = 1; i <= this.engineCount; i++) {
          totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
        }
        this.publish("fuel_flow_total", totalFuelFlow);
      }
    }
  };
  var WeightBalanceSimvarPublisher = class extends SimVarPublisher {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      const simvars = /* @__PURE__ */ new Map([
        ["total_weight", { name: "TOTAL WEIGHT", type: SimVarValueType.Pounds }]
      ]);
      super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
      super.onUpdate();
    }
  };
  var FlightTimerMode;
  (function(FlightTimerMode2) {
    FlightTimerMode2[FlightTimerMode2["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode2[FlightTimerMode2["CountingUp"] = 1] = "CountingUp";
  })(FlightTimerMode || (FlightTimerMode = {}));
  var FlightTimerPublisher = class extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, timerCount, pacer) {
      const simVars = /* @__PURE__ */ new Map();
      const baseSimVars = [
        ["timer_mode", { name: "L:WTFltTimer_Mode", type: SimVarValueType.Number }],
        ["timer_is_running", { name: "L:WTFltTimer_Running", type: SimVarValueType.Bool }],
        ["timer_initial_value_ms", { name: "L:WTFltTimer_Initial_Value", type: SimVarValueType.Number }],
        ["timer_value_ms", { name: "L:WTFltTimer_Value", type: SimVarValueType.Number }]
      ];
      timerCount = Math.max(timerCount, 0);
      for (let i = 1; i <= timerCount; i++) {
        for (const [topic, simvar2] of baseSimVars) {
          simVars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type
          });
        }
      }
      super(simVars, bus, pacer);
    }
  };
  var FlightTimerInstrument = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     */
    constructor(bus, timerCount) {
      this.bus = bus;
      this.timers = {};
      this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on("simTime"), 0).pause();
      this.lastUpdateSimTime = this.simTime.get();
      this.timerCount = Math.max(timerCount, 0);
      for (let i = 1; i <= this.timerCount; i++) {
        this.timers[i] = new FlightTimer(bus, i);
      }
    }
    /** @inheritdoc */
    init() {
      this.simTime.resume();
      this.lastUpdateSimTime = this.simTime.get();
      for (let i = 1; i <= this.timerCount; i++) {
        this.timers[i].init(this.lastUpdateSimTime);
      }
    }
    /** @inheritdoc */
    onUpdate() {
      const currentSimTime = this.simTime.get();
      for (let i = 1; i <= this.timerCount; i++) {
        this.timers[i].update(currentSimTime);
      }
      this.lastUpdateSimTime = currentSimTime;
    }
  };
  var FlightTimer = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param index The index of this timer.
     */
    constructor(bus, index) {
      this.bus = bus;
      this.index = index;
      this.simVars = {
        mode: `L:WTFltTimer_Mode:${this.index}`,
        isRunning: `L:WTFltTimer_Running:${this.index}`,
        referenceTime: `L:WTFltTimer_Reference_Time:${this.index}`,
        referenceValue: `L:WTFltTimer_Reference_Value:${this.index}`,
        initialValue: `L:WTFltTimer_Initial_Value:${this.index}`,
        currentValue: `L:WTFltTimer_Value:${this.index}`
      };
      this.simTime = 0;
      this.mode = FlightTimerMode.CountingDown;
      this.isRunning = false;
      this.referenceTime = 0;
      this.referenceValue = 0;
      this.initialValue = 0;
      this.currentValue = 0;
    }
    /**
     * Initializes this timer. Once this timer is initialized, it will respond to timer control events.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     */
    init(time) {
      this.simTime = time;
      this.mode = SimVar.GetSimVarValue(this.simVars.mode, SimVarValueType.Number);
      this.isRunning = !!SimVar.GetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool);
      this.referenceTime = SimVar.GetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number);
      this.referenceValue = SimVar.GetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number);
      this.initialValue = SimVar.GetSimVarValue(this.simVars.initialValue, SimVarValueType.Number);
      this.currentValue = SimVar.GetSimVarValue(this.simVars.currentValue, SimVarValueType.Number);
      const sub = this.bus.getSubscriber();
      sub.on(`timer_set_mode_${this.index}`).handle((mode) => {
        this.mode = mode;
        this.referenceTime = this.simTime;
        this.referenceValue = this.currentValue;
        SimVar.SetSimVarValue(this.simVars.mode, SimVarValueType.Number, mode);
        SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
        SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
      });
      sub.on(`timer_set_initial_value_${this.index}`).handle((value) => {
        this.initialValue = value;
        SimVar.SetSimVarValue(this.simVars.initialValue, SimVarValueType.Number, this.initialValue);
      });
      sub.on(`timer_set_value_${this.index}`).handle((value) => {
        this.referenceTime = this.simTime;
        this.referenceValue = value;
        this.currentValue = value;
        SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
        SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
      });
      sub.on(`timer_start_${this.index}`).handle(() => {
        if (this.isRunning) {
          return;
        }
        this.isRunning = true;
        this.referenceTime = this.simTime;
        this.referenceValue = this.currentValue;
        SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
        SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
        SimVar.SetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool, 1);
      });
      sub.on(`timer_stop_${this.index}`).handle(() => {
        if (!this.isRunning) {
          return;
        }
        this.isRunning = false;
        SimVar.SetSimVarValue(this.simVars.isRunning, SimVarValueType.Bool, 0);
      });
      sub.on(`timer_reset_${this.index}`).handle(() => {
        this.referenceTime = this.simTime;
        this.referenceValue = this.initialValue;
        this.currentValue = this.initialValue;
        SimVar.SetSimVarValue(this.simVars.referenceTime, SimVarValueType.Number, this.referenceTime);
        SimVar.SetSimVarValue(this.simVars.referenceValue, SimVarValueType.Number, this.referenceValue);
        SimVar.SetSimVarValue(this.simVars.currentValue, SimVarValueType.Number, this.currentValue);
      });
    }
    /**
     * Updates this timer's current value.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
      this.simTime = time;
      if (!this.isRunning) {
        return;
      }
      const modeSign = this.mode === FlightTimerMode.CountingDown ? -1 : 1;
      const value = this.referenceValue + (time - this.referenceTime) * modeSign;
      this.currentValue = value;
      SimVar.SetSimVarValue(this.simVars.currentValue, SimVarValueType.Number, value);
    }
  };
  var GNSSPublisher = class extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      super(bus, pacer);
    }
    /**
     * A callback called when the publisher updates.
     */
    onUpdate() {
      this.publishPosition();
      this.publishTime();
      this.publishTrack();
      this.publishGroundSpeed();
      this.publishMagVar();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
      const lat = SimVar.GetSimVarValue("PLANE LATITUDE", SimVarValueType.Degree);
      const lon = SimVar.GetSimVarValue("PLANE LONGITUDE", SimVarValueType.Degree);
      const alt = SimVar.GetSimVarValue("PLANE ALTITUDE", SimVarValueType.Meters);
      this.publish("gps-position", new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the zulu_time and time_of_day events.
     */
    publishTime() {
      const zuluTime = SimVar.GetGlobalVarValue("ZULU TIME", "seconds");
      const timeOfDay = SimVar.GetSimVarValue("E:TIME OF DAY", "number");
      this.publish("zulu_time", zuluTime);
      this.publish("time_of_day", timeOfDay);
    }
    /**
     * Publishes the track_deg_true and track_deg_magnetic events.
     */
    publishTrack() {
      const headingTrue = SimVar.GetSimVarValue("PLANE HEADING DEGREES TRUE", SimVarValueType.Degree);
      const velocityEW = SimVar.GetSimVarValue("VELOCITY WORLD X", SimVarValueType.Knots);
      const velocityNS = SimVar.GetSimVarValue("VELOCITY WORLD Z", SimVarValueType.Knots);
      let track = headingTrue;
      if (velocityEW !== 0 || velocityNS !== 0) {
        track = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Math.atan2(velocityEW, velocityNS), UnitType.DEGREE));
      }
      const magvar = SimVar.GetSimVarValue("MAGVAR", SimVarValueType.Degree);
      const magneticTrack = NavMath.normalizeHeading(track - magvar);
      this.publish("track_deg_true", track);
      this.publish("track_deg_magnetic", magneticTrack);
    }
    /**
     * Publishes the ground_speed event.
     */
    publishGroundSpeed() {
      const gs = SimVar.GetSimVarValue("GROUND VELOCITY", SimVarValueType.Knots);
      this.publish("ground_speed", gs);
    }
    /**
     * Publishes the ground_speed event.
     */
    publishMagVar() {
      const magvar = SimVar.GetSimVarValue("MAGVAR", SimVarValueType.Degree);
      this.publish("magvar", magvar);
    }
  };
  var ResourceHeap = class {
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory, destructor, onAllocated, onFreed, initialSize = 0, maxSize = Number.MAX_SAFE_INTEGER, autoShrinkThreshold = Number.MAX_SAFE_INTEGER) {
      this.factory = factory;
      this.destructor = destructor;
      this.onAllocated = onAllocated;
      this.onFreed = onFreed;
      this.maxSize = maxSize;
      this.autoShrinkThreshold = autoShrinkThreshold;
      this.cache = [];
      this.numAllocated = 0;
      for (let i = 0; i < Math.min(initialSize, maxSize); i++) {
        this.cache.push(factory());
      }
    }
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate() {
      if (this.numAllocated >= this.maxSize) {
        throw new Error(`ResourceHeap: maximum number of allocations (${this.maxSize}) reached`);
      }
      let resource;
      if (this.numAllocated < this.cache.length) {
        resource = this.cache[this.numAllocated];
      } else {
        this.cache.push(resource = this.factory());
      }
      this.numAllocated++;
      if (this.onAllocated !== void 0) {
        this.onAllocated(resource);
      }
      return resource;
    }
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource) {
      const index = this.cache.indexOf(resource);
      if (index < 0 || index >= this.numAllocated) {
        return;
      }
      const freed = this.cache[index];
      this.numAllocated--;
      this.cache[index] = this.cache[this.numAllocated];
      this.cache[this.numAllocated] = freed;
      if (this.cache.length > this.autoShrinkThreshold && this.numAllocated <= this.cache.length / 2) {
        const newLength = Math.max(this.autoShrinkThreshold, this.numAllocated * 1.25);
        for (let i = newLength; i < this.cache.length; i++) {
          this.destructor(this.cache[i]);
        }
        this.cache.length = newLength;
      }
      if (this.onFreed !== void 0) {
        this.onFreed(resource);
      }
    }
  };
  var SBASGroupName;
  (function(SBASGroupName2) {
    SBASGroupName2["WAAS"] = "WAAS";
    SBASGroupName2["EGNOS"] = "EGNOS";
    SBASGroupName2["GAGAN"] = "GAGAN";
    SBASGroupName2["MSAS"] = "MSAS";
  })(SBASGroupName || (SBASGroupName = {}));
  var GPSSatComputer = class {
    /**
     * Creates an instance of GPSSat.
     * @param index The index of this GPSSat.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled.
     * @param syncRole This system's sync role. A `primary` system will broadcast sync events through the event bus when
     * satellite positions are calculated, satellite states change, or the system is reset. A `replica` system will
     * listen for the aforementioned sync events on the event bus and set its state accordingly. A system with a sync
     * role of `none` does neither; it maintains its own independent state and does not sync it to other systems.
     */
    constructor(index, bus, ephemerisFile, sbasFile, updateInterval, enabledSBASGroups, syncRole = "none") {
      this.index = index;
      this.bus = bus;
      this.ephemerisFile = ephemerisFile;
      this.sbasFile = sbasFile;
      this.updateInterval = updateInterval;
      this.syncRole = syncRole;
      this.publisher = this.bus.getPublisher();
      this.syncPublisher = this.bus.getPublisher();
      this.stateChangedTopic = `gps_system_state_changed_${this.index}`;
      this.satStateChangedTopic = `gps_sat_state_changed_${this.index}`;
      this.satPosCalcTopic = `gps_sat_pos_calculated_${this.index}`;
      this.sbasStateChangedTopic = `gps_system_sbas_state_changed_${this.index}`;
      this.pdopTopic = `gps_system_pdop_${this.index}`;
      this.hdopTopic = `gps_system_hdop_${this.index}`;
      this.vdopTopic = `gps_system_vdop_${this.index}`;
      this.satCalcSyncTopic = `gps_system_sync_sat_calc_${this.index}`;
      this.satStateSyncTopic = `gps_system_sync_sat_state_changed_${this.index}`;
      this.resetSyncTopic = `gps_system_sync_reset_${this.index}`;
      this.satStateRequestSyncTopic = `gps_system_sync_sat_state_request_${this.index}`;
      this.satStateResponseSyncTopic = `gps_system_sync_sat_state_response_${this.index}`;
      this.ephemerisData = {};
      this.sbasData = [];
      this.sbasServiceAreas = /* @__PURE__ */ new Map();
      this.currentSbasGroupsInView = /* @__PURE__ */ new Set();
      this.satellites = [];
      this.ppos = new GeoPoint(0, 0);
      this.pposVec = new Float64Array(2);
      this.vecHeap = new ResourceHeap(() => Vec3Math.create(), () => {
      });
      this.altitude = 0;
      this.previousSimTime = 0;
      this.previousUpdate = 0;
      this.simTime = 0;
      this._state = GPSSystemState.Searching;
      this._sbasState = GPSSystemSBASState.Disabled;
      this.dops = Vec3Math.create();
      this._pdop = -1;
      this._hdop = -1;
      this._vdop = -1;
      this.isInit = false;
      this.needAcquireAndUse = false;
      this.needSatCalc = false;
      this.pendingSatStateUpdates = /* @__PURE__ */ new Map();
      this.enabledSBASGroups = "isSubscribableSet" in enabledSBASGroups ? enabledSBASGroups : SetSubject.create(enabledSBASGroups);
      this.bus.getSubscriber().on("gps-position").handle((pos) => {
        this.ppos.set(pos.lat, pos.long);
        Vec2Math.set(pos.lat, pos.long, this.pposVec);
        this.altitude = pos.alt;
      });
      this.bus.getSubscriber().on("simTime").handle((time) => this.simTime = time);
    }
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state() {
      return this._state;
    }
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState() {
      return this._sbasState;
    }
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop() {
      return this._pdop;
    }
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop() {
      return this._hdop;
    }
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop() {
      return this._vdop;
    }
    /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    addSbasSatellites() {
      const tempVec = new Float64Array(3);
      const tempGeoPoint = new GeoPoint(0, 0);
      const orbitHeight = UnitType.KILOMETER.convertTo(35785, UnitType.GA_RADIAN);
      for (let i = 0; i < this.sbasData.length; i++) {
        const sbasDef = this.sbasData[i];
        this.sbasServiceAreas.set(sbasDef.group, sbasDef.coverage);
        for (const satDef of sbasDef.constellation) {
          const sat = new GPSSatellite(satDef.prn, sbasDef.group);
          tempGeoPoint.set(0, satDef.lon);
          const positionCartesian = Vec3Math.multScalar(tempGeoPoint.toCartesian(tempVec), orbitHeight, tempVec);
          sat.positionCartesian.set(positionCartesian);
          this.satellites.push(sat);
        }
      }
    }
    /** @inheritdoc */
    init() {
      this.publisher.pub(this.stateChangedTopic, this._state, false, true);
      this.publisher.pub(this.sbasStateChangedTopic, this._sbasState, false, true);
      this.publisher.pub(this.pdopTopic, this._pdop, false, true);
      this.publisher.pub(this.hdopTopic, this._hdop, false, true);
      this.publisher.pub(this.vdopTopic, this._vdop, false, true);
      this.loadEphemerisData().then(() => this.loadSbasData()).then(() => {
        this.isInit = true;
        if (this.syncRole === "replica") {
          const sub = this.bus.getSubscriber();
          sub.on(this.satCalcSyncTopic).handle(() => {
            this.needSatCalc = true;
          });
          sub.on(this.satStateSyncTopic).handle((data) => {
            this.pendingSatStateUpdates.set(data.prn, data);
          });
          sub.on(this.resetSyncTopic).handle(() => {
            this.reset();
          });
          sub.on(this.satStateResponseSyncTopic).handle((response) => {
            this.needSatCalc = true;
            response.forEach((data) => {
              this.pendingSatStateUpdates.set(data.prn, data);
            });
          });
          this.syncPublisher.pub(this.satStateRequestSyncTopic, void 0, true, false);
        } else if (this.syncRole === "primary") {
          const sub = this.bus.getSubscriber();
          sub.on(this.satStateRequestSyncTopic).handle(() => {
            this.syncPublisher.pub(this.satStateResponseSyncTopic, this.satellites.map((sat) => {
              return { prn: sat.prn, state: sat.state.get() };
            }), true, false);
          });
        }
        if (this.needAcquireAndUse) {
          this.needAcquireAndUse = false;
          this.acquireAndUseSatellites();
        } else {
          this.reset();
        }
      });
    }
    /**
     * Loads the GPS ephemeris data file.
     */
    loadEphemerisData() {
      return new Promise((resolve, reject) => {
        const request = new XMLHttpRequest();
        request.onreadystatechange = () => {
          if (request.readyState === XMLHttpRequest.DONE) {
            if (request.status === 200) {
              this.ephemerisData = JSON.parse(request.responseText);
              for (const prn in this.ephemerisData) {
                this.satellites.push(new GPSSatellite(parseInt(prn), void 0, this.ephemerisData[prn]));
              }
              resolve();
            } else {
              reject(`Could not initialize sat computer system with ephemeris data: ${request.responseText}`);
            }
          }
        };
        request.open("GET", this.ephemerisFile);
        request.send();
      });
    }
    /**
     * Loads the GPS SBAS data file.
     */
    loadSbasData() {
      return new Promise((resolve, reject) => {
        const request = new XMLHttpRequest();
        request.onreadystatechange = () => {
          if (request.readyState === XMLHttpRequest.DONE) {
            if (request.status === 200) {
              this.sbasData = JSON.parse(request.responseText);
              this.addSbasSatellites();
              resolve();
            } else {
              reject(`Could not initialize sat computer system with sbas data: ${request.responseText}`);
            }
          }
        };
        request.open("GET", this.sbasFile);
        request.send();
      });
    }
    /**
     * Instantly acquires and starts using all satellites with sufficient signal strength. If signal strength allows,
     * SBAS satellites are instantly promoted to the {@link GPSSatelliteState.Acquired} state, and GPS satellites are
     * instantly promoted to the {@link GPSSatelliteState.InUse}/{@link GPSSatelliteState.InUseDiffApplied} state.
     *
     * If this system is not initialized, the operation will be delayed until just after initialization, unless `reset()`
     * is called between now and then.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites() {
      if (this.syncRole === "replica") {
        return;
      }
      if (this.isInit) {
        this.updateSatellites(0, true, true);
      } else {
        this.needAcquireAndUse = true;
      }
    }
    /**
     * Resets the GPSSatComputer system. This will set the of the system to {@link GPSSystemState.Searching} and the
     * state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset() {
      this.needAcquireAndUse = false;
      if (!this.isInit) {
        return;
      }
      this.satellites.forEach((sat) => {
        const currentState2 = sat.state.get();
        sat.state.set(GPSSatelliteState.None);
        if (currentState2 !== GPSSatelliteState.None) {
          this.publisher.pub(this.satStateChangedTopic, sat, false, false);
        }
      });
      const currentState = this._state;
      this._state = GPSSystemState.Searching;
      if (currentState !== GPSSystemState.Searching) {
        this.publisher.pub(this.stateChangedTopic, GPSSystemState.Searching, false, true);
      }
      this.setDop(-1, -1, -1);
      if (this.syncRole === "primary") {
        this.syncPublisher.pub(this.resetSyncTopic, void 0, true, false);
      }
    }
    /** @inheritdoc */
    onUpdate() {
      if (!this.isInit) {
        return;
      }
      const deltaTime = this.simTime - this.previousSimTime;
      if (this.syncRole !== "replica") {
        if (deltaTime < 0 || deltaTime > this.updateInterval * 2) {
          this.previousSimTime = this.simTime;
          this.previousUpdate = this.simTime;
          return;
        }
      }
      const shouldUpdatePositions = this.syncRole === "replica" ? this.needSatCalc : this.simTime >= this.previousUpdate + this.updateInterval;
      this.needSatCalc = false;
      this.updateSatellites(deltaTime, shouldUpdatePositions, false);
    }
    /**
     * Updates the states and optionally the orbital positions of all satellites.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately force satellites to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} for SBAS satellites and {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} for GPS satellites) if signal strength is sufficient.
     */
    updateSatellites(deltaTime, shouldUpdatePositions, forceAcquireAndUse) {
      var _a, _b, _c, _d;
      let numAcquiring = 0;
      let numActiveSbas = 0;
      let shouldUpdateDop = shouldUpdatePositions;
      if (shouldUpdatePositions && this.syncRole === "primary") {
        (_a = this.syncPublisher) === null || _a === void 0 ? void 0 : _a.pub(this.satCalcSyncTopic, void 0, true, false);
      }
      this.currentSbasGroupsInView.clear();
      const enabledSBASGroups = this.enabledSBASGroups.get();
      for (let i = 0; i < this.satellites.length; i++) {
        const sat = this.satellites[i];
        if (shouldUpdatePositions) {
          sat.computeSatellitePositions(this.simTime);
          sat.applyProjection(this.ppos, this.altitude);
        }
        sat.calculateSignalStrength(this.altitude);
        const updatedState = this.syncRole === "replica" ? sat.forceUpdateState((_c = (_b = this.pendingSatStateUpdates.get(sat.prn)) === null || _b === void 0 ? void 0 : _b.state) !== null && _c !== void 0 ? _c : sat.state.get()) : sat.updateState(deltaTime, this._state === GPSSystemState.DiffSolutionAcquired, forceAcquireAndUse);
        if (updatedState) {
          this.publisher.pub(this.satStateChangedTopic, sat, false, false);
          if (this.syncRole === "primary") {
            this.syncPublisher.pub(this.satStateSyncTopic, { prn: sat.prn, state: sat.state.get() }, true, false);
          }
          shouldUpdateDop = true;
        }
        const satState = sat.state.get();
        if (satState === GPSSatelliteState.Acquired || satState === GPSSatelliteState.DataCollected) {
          numAcquiring++;
          if (sat.sbasGroup !== void 0 && enabledSBASGroups.has(sat.sbasGroup)) {
            numActiveSbas++;
            this.currentSbasGroupsInView.add(sat.sbasGroup);
          }
        }
      }
      this.pendingSatStateUpdates.clear();
      let withinSbasArea = false;
      for (const group of this.currentSbasGroupsInView) {
        const coverage = this.sbasServiceAreas.get(group);
        if (coverage !== void 0) {
          withinSbasArea = (_d = Vec2Math.pointWithinPolygon(coverage, this.pposVec)) !== null && _d !== void 0 ? _d : false;
        }
        if (withinSbasArea) {
          break;
        }
      }
      const newSBASState = withinSbasArea ? GPSSystemSBASState.Active : enabledSBASGroups.size === 0 ? GPSSystemSBASState.Disabled : GPSSystemSBASState.Inactive;
      let newSystemState = GPSSystemState.Searching;
      if (numAcquiring > 0) {
        newSystemState = GPSSystemState.Acquiring;
      }
      let pdop = this._pdop, hdop = this._hdop, vdop = this._vdop;
      if (shouldUpdateDop) {
        [pdop, hdop, vdop] = this.calculateDop(this.dops);
      }
      const is3dSolutionPossible = pdop >= 0;
      if (is3dSolutionPossible) {
        newSystemState = numActiveSbas > 0 && withinSbasArea ? GPSSystemState.DiffSolutionAcquired : GPSSystemState.SolutionAcquired;
      }
      if (this._state !== newSystemState) {
        this._state = newSystemState;
        this.publisher.pub(this.stateChangedTopic, newSystemState, false, true);
      }
      if (this._sbasState !== newSBASState) {
        this._sbasState = newSBASState;
        this.publisher.pub(this.sbasStateChangedTopic, newSBASState, false, true);
      }
      if (shouldUpdatePositions) {
        this.previousUpdate = this.simTime;
        this.publisher.pub(this.satPosCalcTopic, void 0, false, false);
      }
      this.setDop(pdop, hdop, vdop);
      this.previousSimTime = this.simTime;
    }
    /**
     * Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats() {
      return this.satellites;
    }
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle() {
      return Math.acos(6378100 / (6378100 + this.altitude));
    }
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the current satellite constellation.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current satellite constellation, as `[PDOP, HDOP, VDOP]`.
     */
    calculateDop(out) {
      Vec3Math.set(-1, -1, -1, out);
      const satsInUse = this.satellites.filter((sat) => {
        const state = sat.state.get();
        return state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
      });
      if (satsInUse.length < 4) {
        return out;
      }
      for (let i = 0; i < satsInUse.length; i++) {
        const [zenith, hour] = satsInUse[i].position.get();
        satsInUse[i] = Vec3Math.setFromSpherical(1, zenith, hour, this.vecHeap.allocate());
      }
      const satVecs = satsInUse;
      const P11 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[0], 0);
      const P12 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[1], 0);
      const P13 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[2], 0);
      const P14 = satVecs.reduce((sum, vec) => sum + vec[0], 0);
      const P22 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[1], 0);
      const P23 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[2], 0);
      const P24 = satVecs.reduce((sum, vec) => sum + vec[1], 0);
      const P33 = satVecs.reduce((sum, vec) => sum + vec[2] * vec[2], 0);
      const P34 = satVecs.reduce((sum, vec) => sum + vec[2], 0);
      const P44 = satVecs.length;
      for (let i = 0; i < satVecs.length; i++) {
        this.vecHeap.free(satVecs[i]);
      }
      const detA = 1 / (P11 * P22 - P12 * P12);
      const V11 = P22 * detA;
      const V12 = -P12 * detA;
      const V22 = P11 * detA;
      const X11 = V11 * P13 + V12 * P23;
      const X12 = V11 * P14 + V12 * P24;
      const X21 = V12 * P13 + V22 * P23;
      const X22 = V12 * P14 + V22 * P24;
      const Hi11 = P33 - (P13 * X11 + P23 * X21);
      const Hi12 = P34 - (P13 * X12 + P23 * X22);
      const Hi22 = P44 - (P14 * X12 + P24 * X22);
      const detHi = 1 / (Hi11 * Hi22 - Hi12 * Hi12);
      const H11 = Hi22 * detHi;
      const H12 = -Hi12 * detHi;
      const H22 = Hi11 * detHi;
      const Z11 = X11 * H11 + X12 * H12;
      const Z12 = X11 * H12 + X12 * H22;
      const Z21 = X21 * H11 + X22 * H12;
      const Z22 = X21 * H12 + X22 * H22;
      const E11 = V11 + Z11 * X11 + Z12 * X12;
      const E22 = V22 + Z21 * X21 + Z22 * X22;
      const varX = E11;
      const varY = E22;
      const varZ = H11;
      if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
        return out;
      }
      const horizSumVar = varX + varY;
      const pdop = Math.sqrt(horizSumVar + varZ);
      const hdop = Math.sqrt(horizSumVar);
      const vdop = Math.sqrt(varZ);
      return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP valu to set.
     */
    setDop(pdop, hdop, vdop) {
      if (this._pdop !== pdop) {
        this._pdop = pdop;
        this.publisher.pub(this.pdopTopic, pdop, false, true);
      }
      if (this._hdop !== hdop) {
        this._hdop = hdop;
        this.publisher.pub(this.hdopTopic, hdop, false, true);
      }
      if (this._vdop !== vdop) {
        this._vdop = vdop;
        this.publisher.pub(this.vdopTopic, vdop, false, true);
      }
    }
  };
  var GPSSatellite = class {
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
     */
    constructor(prn, sbasGroup, ephemeris) {
      this.prn = prn;
      this.sbasGroup = sbasGroup;
      this.ephemeris = ephemeris;
      this.stateChangeTime = (5 + 10 * Math.random()) * 1e3;
      this.stateChangeTimeRemaining = 0;
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.state = Subject.create(GPSSatelliteState.None);
      this.position = Vec2Subject.create(new Float64Array(2));
      this.positionCartesian = Vec3Subject.create(new Float64Array(3));
      this.signalStrength = Subject.create(0);
      this.isApplyingDiffCorrections = false;
      this.hasComputedPosition = false;
    }
    /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime) {
      const record = this.ephemeris;
      if (record !== void 0) {
        const mu = 3986005e8;
        const omegae_dot = 72921151467e-15;
        const a = record.sqrtA * record.sqrtA;
        const n0 = Math.sqrt(mu / (a * a * a));
        const now = simTime / 1e3;
        const t = (now - 86400 * 3 + 1735) % 604800;
        let tk = t - record.toeTimeEphemeris;
        if (tk > 302400) {
          tk -= 604800;
        } else if (tk < -302400) {
          tk += 604800;
        }
        const n = n0 + record.deltaN;
        const M = record.m0 + n * tk;
        let E = M;
        let E_old;
        let dE;
        for (let i2 = 1; i2 < 20; i2++) {
          E_old = E;
          E = M + record.eEccentricity * Math.sin(E);
          dE = E - E_old % (2 * Math.PI);
          if (Math.abs(dE) < 1e-12) {
            break;
          }
        }
        const sek = Math.sin(E);
        const cek = Math.cos(E);
        const OneMinusecosE = 1 - record.eEccentricity * cek;
        const sq1e2 = Math.sqrt(1 - record.eEccentricity * record.eEccentricity);
        const tmp_Y = sq1e2 * sek;
        const tmp_X = cek - record.eEccentricity;
        const nu = Math.atan2(tmp_Y, tmp_X);
        const phi = nu + record.omegaS;
        const s2pk = Math.sin(2 * phi);
        const c2pk = Math.cos(2 * phi);
        const u = phi + record.cuc * c2pk + record.cus * s2pk;
        const suk = Math.sin(u);
        const cuk = Math.cos(u);
        const r = a * OneMinusecosE + record.crc * c2pk + record.crs * s2pk;
        const i = record.i0 + record.idot * tk + record.cic * c2pk + record.cis * s2pk;
        const sik = Math.sin(i);
        const cik = Math.cos(i);
        const Omega_dot = record.omegaLDot - omegae_dot;
        const Omega = record.omegaL + Omega_dot * tk - omegae_dot * record.toeTimeEphemeris;
        const sok = Math.sin(Omega);
        const cok = Math.cos(Omega);
        const xprime = r * cuk;
        const yprime = r * suk;
        const x = xprime * cok - yprime * cik * sok;
        const y = xprime * sok + yprime * cik * cok;
        const z = yprime * sik;
        this.positionCartesian.set(UnitType.METER.convertTo(x, UnitType.GA_RADIAN), UnitType.METER.convertTo(y, UnitType.GA_RADIAN), UnitType.METER.convertTo(z, UnitType.GA_RADIAN));
      }
    }
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos, altitude) {
      const satPos = this.positionCartesian.get();
      const altRadians = UnitType.METER.convertTo(altitude, UnitType.GA_RADIAN);
      const pposCartesian = Vec3Math.multScalar(ppos.toCartesian(this.vec3Cache[0]), 1 + altRadians, this.vec3Cache[0]);
      const delta = Vec3Math.normalize(Vec3Math.sub(satPos, pposCartesian, this.vec3Cache[1]), this.vec3Cache[1]);
      const zenithAngle = Math.acos(Vec3Math.dot(delta, Vec3Math.normalize(pposCartesian, this.vec3Cache[2])));
      const satPos0 = Vec3Math.normalize(satPos, this.vec3Cache[1]);
      const northPole = Vec3Math.set(0, 0, 1, this.vec3Cache[2]);
      if (Math.abs(zenithAngle) < 1e-8 || Math.abs(zenithAngle - 180) < 1e-8) {
        this.position.set(zenithAngle, 0);
      } else {
        const A = Vec3Math.normalize(Vec3Math.cross(pposCartesian, northPole, this.vec3Cache[3]), this.vec3Cache[3]);
        const B = Vec3Math.normalize(Vec3Math.cross(pposCartesian, satPos0, this.vec3Cache[4]), this.vec3Cache[4]);
        const signBz = B[2] >= 0 ? 1 : -1;
        const hourAngle = Math.acos(Vec3Math.dot(A, B)) * signBz;
        this.position.set(zenithAngle, -hourAngle);
      }
      this.hasComputedPosition = true;
    }
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude) {
      if (this.hasComputedPosition) {
        const maxZenithAngle = GPSSatellite.calcHorizonAngle(altitude) + Math.PI / 2;
        const signalStrength = Math.max(0, 1 - this.position.get()[0] / maxZenithAngle);
        this.signalStrength.set(signalStrength);
      }
    }
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude) {
      return Math.acos(6378100 / (6378100 + Math.max(altitude, 0)));
    }
    /**
     * Updates the state of the satellite.
     * @param deltaTime The amount of sim time that has passed, in milliseconds.
     * @param applyDiffCorrections Whether or not to apply differential corrections to this GPS satellite.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} if this is an SBAS satellite or {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} if this is a GPS satellite) if signal strength is sufficient.
     * @returns True if the satellite state changed, false otherwise.
     */
    updateState(deltaTime, applyDiffCorrections, forceAcquireAndUse) {
      const reachable = this.signalStrength.get() > 0.05;
      if (this.stateChangeTimeRemaining >= 0) {
        this.stateChangeTimeRemaining -= deltaTime;
      }
      if (forceAcquireAndUse) {
        this.isApplyingDiffCorrections = applyDiffCorrections;
        const state = this.state.get();
        if (reachable) {
          const targetState = this.sbasGroup === void 0 ? applyDiffCorrections ? GPSSatelliteState.InUseDiffApplied : GPSSatelliteState.InUse : GPSSatelliteState.Acquired;
          if (state !== targetState) {
            this.state.set(targetState);
            return true;
          }
        } else {
          if (state !== GPSSatelliteState.Unreachable) {
            this.state.set(GPSSatelliteState.Unreachable);
            return true;
          }
        }
      } else {
        switch (this.state.get()) {
          case GPSSatelliteState.None:
            if (reachable) {
              this.state.set(GPSSatelliteState.Acquired);
              this.stateChangeTimeRemaining = this.stateChangeTime;
              return true;
            } else {
              this.state.set(GPSSatelliteState.Unreachable);
              this.stateChangeTimeRemaining = this.stateChangeTime;
              return true;
            }
          case GPSSatelliteState.Unreachable:
            if (reachable) {
              this.state.set(GPSSatelliteState.Acquired);
              this.stateChangeTimeRemaining = this.stateChangeTime;
              return true;
            }
            break;
          case GPSSatelliteState.Acquired:
            if (!reachable) {
              this.state.set(GPSSatelliteState.Unreachable);
              return true;
            } else if (this.stateChangeTimeRemaining <= 0 && this.sbasGroup === void 0) {
              this.state.set(GPSSatelliteState.DataCollected);
              this.stateChangeTimeRemaining = this.stateChangeTime;
              return true;
            }
            break;
          case GPSSatelliteState.DataCollected:
            if (!reachable) {
              this.state.set(GPSSatelliteState.Unreachable);
              return true;
            } else if (this.stateChangeTimeRemaining <= 0) {
              this.state.set(GPSSatelliteState.InUse);
              this.stateChangeTimeRemaining = this.stateChangeTime;
              return true;
            }
            break;
          case GPSSatelliteState.InUse:
            if (!reachable) {
              this.state.set(GPSSatelliteState.Unreachable);
              return true;
            } else if (applyDiffCorrections) {
              if (this.isApplyingDiffCorrections && this.stateChangeTimeRemaining <= 0) {
                this.state.set(GPSSatelliteState.InUseDiffApplied);
                return true;
              } else if (!this.isApplyingDiffCorrections) {
                this.isApplyingDiffCorrections = true;
                this.stateChangeTimeRemaining = this.stateChangeTime;
              }
            }
            break;
          case GPSSatelliteState.InUseDiffApplied:
            if (!reachable) {
              this.state.set(GPSSatelliteState.Unreachable);
              return true;
            } else if (!applyDiffCorrections) {
              this.isApplyingDiffCorrections = false;
              this.state.set(GPSSatelliteState.InUse);
              return true;
            }
            break;
        }
      }
      return false;
    }
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param state The state to which to update this satellite.
     * @returns Whether the satellite's state was changed as a result of the forced update.
     */
    forceUpdateState(state) {
      this.stateChangeTimeRemaining = 0;
      this.isApplyingDiffCorrections = state === GPSSatelliteState.InUseDiffApplied;
      if (this.state.get() !== state) {
        this.state.set(state);
        return true;
      } else {
        return false;
      }
    }
  };
  var GPSSatelliteState;
  (function(GPSSatelliteState2) {
    GPSSatelliteState2["None"] = "None";
    GPSSatelliteState2["Unreachable"] = "Unreachable";
    GPSSatelliteState2["Acquired"] = "Acquired";
    GPSSatelliteState2["Faulty"] = "Faulty";
    GPSSatelliteState2["DataCollected"] = "DataCollected";
    GPSSatelliteState2["InUse"] = "InUse";
    GPSSatelliteState2["InUseDiffApplied"] = "InUseDiffApplied";
  })(GPSSatelliteState || (GPSSatelliteState = {}));
  var GPSSystemState;
  (function(GPSSystemState2) {
    GPSSystemState2["Searching"] = "Searching";
    GPSSystemState2["Acquiring"] = "Acquiring";
    GPSSystemState2["SolutionAcquired"] = "SolutionAcquired";
    GPSSystemState2["DiffSolutionAcquired"] = "DiffSolutionAcquired";
  })(GPSSystemState || (GPSSystemState = {}));
  var GPSSystemSBASState;
  (function(GPSSystemSBASState2) {
    GPSSystemSBASState2["Disabled"] = "Disabled";
    GPSSystemSBASState2["Inactive"] = "Inactive";
    GPSSystemSBASState2["Active"] = "Active";
  })(GPSSystemSBASState || (GPSSystemSBASState = {}));
  var BaseInstrumentPublisher = class extends BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument, bus, pacer = void 0) {
      super(bus, pacer);
      this.instrument = instrument;
      this.lastGameState = void 0;
      this.lastIsPowered = void 0;
      this.lastScreenState = void 0;
      this.hasFlightStarted = false;
      instrument.addEventListener("mouseleave", (e) => {
        this.publish("vc_mouse_leave", e, false, false);
      });
      instrument.addEventListener("mouseenter", (e) => {
        this.publish("vc_mouse_enter", e, false, false);
      });
    }
    /** @inheritdoc */
    startPublish() {
      super.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
      super.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
      if (!this.isPublishing()) {
        return;
      }
      this.updateFromGameState(this.instrument.getGameState());
      this.updateFromPowered(this.instrument.isStarted);
      this.updateFromScreenState(this.instrument.screenState);
    }
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    updateFromGameState(gameState) {
      if (this.lastGameState === gameState) {
        return;
      }
      this.lastGameState = gameState;
      this.publish("vc_game_state", gameState);
      if (!this.hasFlightStarted && gameState === GameState.ingame) {
        this.publish("vc_flight_start", true);
      }
    }
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    updateFromPowered(isPowered) {
      if (this.lastIsPowered === isPowered) {
        return;
      }
      this.lastIsPowered = isPowered;
      this.publish("vc_powered", isPowered);
    }
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    updateFromScreenState(screenState) {
      if (this.lastScreenState === screenState) {
        return;
      }
      const lastScreenState = this.lastScreenState;
      this.lastScreenState = screenState;
      this.publish("vc_screen_state", { current: screenState, previous: lastScreenState });
    }
  };
  var MinimumsMode;
  (function(MinimumsMode2) {
    MinimumsMode2[MinimumsMode2["OFF"] = 0] = "OFF";
    MinimumsMode2[MinimumsMode2["BARO"] = 1] = "BARO";
    MinimumsMode2[MinimumsMode2["RA"] = 2] = "RA";
    MinimumsMode2[MinimumsMode2["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
  })(MinimumsMode || (MinimumsMode = {}));
  var MinimumsSimVarPublisher = class extends SimVarPublisher {
    /**
     * @inheritdoc
     */
    constructor(bus) {
      super(MinimumsSimVarPublisher.simvars, bus);
    }
  };
  MinimumsSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["decision_height_feet", { name: "DECISION HEIGHT", type: SimVarValueType.Feet }],
    ["decision_altitude_feet", { name: "DECISION ALTITUDE MSL", type: SimVarValueType.Feet }],
    ["minimums_mode", { name: "L:WT_MINIMUMS_MODE", type: SimVarValueType.Number }]
  ]);
  var MinimumsManager = class {
    /**
     * Create a MinimumsManager
     * @param bus The event bus
     */
    constructor(bus) {
      this.currentDH = 0;
      this.currentDA = 0;
      this.daDistanceUnit = UnitType.FOOT;
      this.dhDistanceUnit = UnitType.FOOT;
      this.bus = bus;
      this.controlSubscriber = bus.getSubscriber();
      SimVar.SetSimVarValue("K:SET_DECISION_HEIGHT", "number", 0);
      SimVar.SetSimVarValue("K:SET_DECISION_ALTITUDE_MSL", "number", 0);
      KeyEventManager.getManager(bus).then((manager) => {
        manager.interceptKey("INCREASE_DECISION_HEIGHT", false);
        manager.interceptKey("DECREASE_DECISION_HEIGHT", false);
        manager.interceptKey("INCREASE_DECISION_ALTITUDE_MSL", false);
        manager.interceptKey("DECREASE_DECISION_ALTITUDE_MSL", false);
      });
      this.controlSubscriber.on("set_decision_height_feet").handle((dh) => {
        SimVar.SetSimVarValue("K:SET_DECISION_HEIGHT", SimVarValueType.Number, dh);
      });
      this.controlSubscriber.on("set_decision_altitude_feet").handle((da) => {
        SimVar.SetSimVarValue("K:SET_DECISION_ALTITUDE_MSL", SimVarValueType.Number, da);
      });
      this.controlSubscriber.on("set_minimums_mode").handle((mode) => {
        SimVar.SetSimVarValue("L:WT_MINIMUMS_MODE", SimVarValueType.Number, mode);
      });
      this.controlSubscriber.on("set_dh_distance_unit").handle((unit) => {
        this.dhDistanceUnit = unit == "meters" ? UnitType.METER : UnitType.FOOT;
      });
      this.controlSubscriber.on("set_da_distance_unit").handle((unit) => {
        this.daDistanceUnit = unit == "meters" ? UnitType.METER : UnitType.FOOT;
      });
      const sub = this.bus.getSubscriber();
      sub.on("key_intercept").handle((evt) => {
        let simvar2;
        let curVal;
        let direction = "up";
        let unit;
        if (evt.value0 !== void 0) {
          switch (evt.key) {
            case "DECREASE_DECISION_HEIGHT":
              direction = "down";
            case "INCREASE_DECISION_HEIGHT":
              simvar2 = "K:SET_DECISION_HEIGHT";
              unit = this.dhDistanceUnit;
              curVal = this.currentDH;
              break;
            case "DECREASE_DECISION_ALTITUDE_MSL":
              direction = "down";
            case "INCREASE_DECISION_ALTITUDE_MSL":
              simvar2 = "K:SET_DECISION_ALTITUDE_MSL";
              unit = this.daDistanceUnit;
              curVal = this.currentDA;
              break;
          }
          if (simvar2 !== void 0 && curVal !== void 0 && unit !== void 0) {
            const increment = unit.convertTo(evt.value0, UnitType.FOOT) * (direction == "down" ? -1 : 1);
            SimVar.SetSimVarValue(simvar2, "number", curVal + increment);
          }
        }
      });
    }
  };
  var NavComSimVarPublisher = class extends SimVarPublisher {
    /**
     * Create a NavComSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = void 0) {
      super(NavComSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
      return [
        [`nav_active_frequency_${index}`, { name: `NAV ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_standby_frequency_${index}`, { name: `NAV STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_sound_${index}`, { name: `NAV SOUND:${index}`, type: SimVarValueType.Bool }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_volume_${index}`, { name: `NAV VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    /**
     * Creates an array of com radio sim var event definitions for an indexed com radio.
     * @param index The index of the com radio.
     * @returns An array of com radio sim var event definitions for the specified com radio.
     */
    static createComRadioDefinitions(index) {
      return [
        [`com_active_frequency_${index}`, { name: `COM ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_standby_frequency_${index}`, { name: `COM STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_active_facility_name_${index}`, { name: `COM ACTIVE FREQ NAME:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_type_${index}`, { name: `COM ACTIVE FREQ TYPE:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_ident_${index}`, { name: `COM ACTIVE FREQ IDENT:${index}`, type: SimVarValueType.String }],
        // Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
        // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
        [`com_receive_${index}`, { name: `COM RECEIVE EX1:${index}`, type: SimVarValueType.Bool }],
        [`com_status_${index}`, { name: `COM STATUS:${index}`, type: SimVarValueType.Number }],
        [`com_transmit_${index}`, { name: `COM TRANSMIT:${index}`, type: SimVarValueType.Bool }],
        [`com_spacing_mode_${index}`, { name: `COM SPACING MODE:${index}`, type: SimVarValueType.Enum }],
        [`com_volume_${index}`, { name: `COM VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_active_frequency_${index}`, { name: `ADF ACTIVE FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_standby_frequency_${index}`, { name: `ADF STANDBY FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_sound_${index}`, { name: `ADF SOUND:${index}`, type: SimVarValueType.Bool }],
        [`adf_volume_${index}`, { name: `ADF VOLUME:${index}`, type: SimVarValueType.Percent }],
        [`adf_ident_${index}`, { name: `ADF IDENT:${index}`, type: SimVarValueType.String }],
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }]
      ];
    }
  };
  NavComSimVarPublisher.simvars = new Map([
    ...NavComSimVarPublisher.createNavRadioDefinitions(1),
    ...NavComSimVarPublisher.createNavRadioDefinitions(2),
    ...NavComSimVarPublisher.createNavRadioDefinitions(3),
    ...NavComSimVarPublisher.createNavRadioDefinitions(4),
    ...NavComSimVarPublisher.createComRadioDefinitions(1),
    ...NavComSimVarPublisher.createComRadioDefinitions(2),
    ...NavComSimVarPublisher.createComRadioDefinitions(3),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(2),
    ["marker_beacon_hisense_on", { name: "MARKER BEACON SENSITIVITY HIGH", type: SimVarValueType.Bool }],
    ["marker_beacon_sound", { name: "MARKER SOUND", type: SimVarValueType.Bool }]
  ]);
  var NavComConfig = class {
    constructor() {
      this.navSwitchEvents = /* @__PURE__ */ new Map();
      this.navSelectorEvents = /* @__PURE__ */ new Map();
      this.navWholeIncEvents = /* @__PURE__ */ new Map();
      this.navWholeDecEvents = /* @__PURE__ */ new Map();
      this.navFractionIncEvents = /* @__PURE__ */ new Map();
      this.navFractionDecEvents = /* @__PURE__ */ new Map();
      this.comSwitchEvents = /* @__PURE__ */ new Map();
      this.comSelectorEvents = /* @__PURE__ */ new Map();
      this.comWholeIncEvents = /* @__PURE__ */ new Map();
      this.comWholeDecEvents = /* @__PURE__ */ new Map();
      this.comFractionIncEvents = /* @__PURE__ */ new Map();
      this.comFractionDecEvents = /* @__PURE__ */ new Map();
      this.comVolumeIncEvents = /* @__PURE__ */ new Map();
      this.comVolumeDecEvents = /* @__PURE__ */ new Map();
      this.navVolumeIncEvents = /* @__PURE__ */ new Map();
      this.navVolumeDecEvents = /* @__PURE__ */ new Map();
    }
  };
  var NavComPublisher = class extends BasePublisher {
    /**
     * Creates a NavComPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pace to use to control the rate of publishing.
     * @param sync Whether to use synced events.
     */
    constructor(bus, pacer, sync = true) {
      super(bus, pacer);
      this.sync = sync;
    }
    /**
     * Publish a radio state event.
     *
     * This sets the complete state of a radio for initialzation or resync.
     * @param radio The Radio data to publish.
     */
    publishRadioState(radio) {
      if (radio !== void 0) {
        super.publish("set_radio_state", radio, this.sync);
      }
    }
    /**
     * Publish a frequency change event.
     *
     * Unlike a radio state event, this just changes a specific frequency.
     * We provide this to avoid issues with potentially conflicting updates
     * if active and standby get updated quickly and we send a snapshot after
     * each.
     * @param radio The Radio to change.
     * @param bank The frequency bank to update.
     * @param frequency The new frequency to set.
     */
    publishFreqChange(radio, bank, frequency) {
      if (radio !== void 0) {
        super.publish("set_frequency", { radio, bank, frequency }, this.sync);
      }
    }
    /**
     * Publish the ident of the currently tuned station.
     * @param index The index number of the tuned radio.
     * @param ident The ident as a string.
     */
    publishIdent(index, ident) {
      super.publish("set_ident", { index, ident }, this.sync);
    }
    /**
     * Publish the signal strength of the currently tuned station.
     * @param index The index number of the tuned radio.
     * @param strength The signal strength as a number.
     */
    publishSignalStrength(index, strength) {
      super.publish("set_signal_strength", strength, this.sync);
    }
    /**
     * Publish the ADF1 Active Frequency in Khz.
     * @param freq The active frequency in Khz.
     */
    publishAdfActiveFrequencySet(freq) {
      super.publish("adf_active_frequency_1", freq, false);
    }
    /**
     * Publish the ADF1 Standby Frequency in Khz.
     * @param freq The standby frequency in Khz.
     */
    publishAdfStandbyFrequencySet(freq) {
      super.publish("adf_standby_frequency_1", freq, false);
    }
  };
  var NavComInstrument = class {
    /**
     * Create a NavComController.
     * @param bus The event bus to publish to.
     * @param config A NavComConfig object defining the radio configuration.
     * @param numNavRadios The number of nav radios in the system.
     * @param numComRadios The number of com radios in the system.
     * @param sync Whether to sync events or not, default true.
     */
    constructor(bus, config, numNavRadios, numComRadios, sync = true) {
      this.navRadios = new Array();
      this.comRadios = new Array();
      this.eventHandler = (hEvent) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        if (this.config !== void 0) {
          if ((_a = this.config.navSwitchEvents) === null || _a === void 0 ? void 0 : _a.has(hEvent)) {
            this.swapFreqs(this.getSelectedRadio(this.navRadios));
          } else if ((_b = this.config.navSelectorEvents) === null || _b === void 0 ? void 0 : _b.has(hEvent)) {
            this.swapSelection(this.navRadios);
          } else if ((_c = this.config.navWholeIncEvents) === null || _c === void 0 ? void 0 : _c.has(hEvent)) {
            this.wholeInc(this.getSelectedRadio(this.navRadios));
          } else if ((_d = this.config.navWholeDecEvents) === null || _d === void 0 ? void 0 : _d.has(hEvent)) {
            this.wholeDec(this.getSelectedRadio(this.navRadios));
          } else if ((_e = this.config.navFractionIncEvents) === null || _e === void 0 ? void 0 : _e.has(hEvent)) {
            this.fractInc(this.getSelectedRadio(this.navRadios));
          } else if ((_f = this.config.navFractionDecEvents) === null || _f === void 0 ? void 0 : _f.has(hEvent)) {
            this.fractDec(this.getSelectedRadio(this.navRadios));
          } else if ((_g = this.config.comSwitchEvents) === null || _g === void 0 ? void 0 : _g.has(hEvent)) {
            this.swapFreqs(this.getSelectedRadio(this.comRadios));
          } else if ((_h = this.config.comSelectorEvents) === null || _h === void 0 ? void 0 : _h.has(hEvent)) {
            this.swapSelection(this.comRadios);
          } else if ((_j = this.config.comWholeIncEvents) === null || _j === void 0 ? void 0 : _j.has(hEvent)) {
            this.wholeInc(this.getSelectedRadio(this.comRadios));
          } else if ((_k = this.config.comWholeDecEvents) === null || _k === void 0 ? void 0 : _k.has(hEvent)) {
            this.wholeDec(this.getSelectedRadio(this.comRadios));
          } else if ((_l = this.config.comFractionIncEvents) === null || _l === void 0 ? void 0 : _l.has(hEvent)) {
            this.fractInc(this.getSelectedRadio(this.comRadios));
          } else if ((_m = this.config.comFractionDecEvents) === null || _m === void 0 ? void 0 : _m.has(hEvent)) {
            this.fractDec(this.getSelectedRadio(this.comRadios));
          } else if ((_o = this.config.comVolumeIncEvents) === null || _o === void 0 ? void 0 : _o.has(hEvent)) {
            this.volumeInc(this.getSelectedRadio(this.comRadios));
          } else if ((_p = this.config.comVolumeDecEvents) === null || _p === void 0 ? void 0 : _p.has(hEvent)) {
            this.volumeDec(this.getSelectedRadio(this.comRadios));
          } else if ((_q = this.config.navVolumeIncEvents) === null || _q === void 0 ? void 0 : _q.has(hEvent)) {
            this.volumeInc(this.getSelectedRadio(this.navRadios));
          } else if ((_r = this.config.navVolumeDecEvents) === null || _r === void 0 ? void 0 : _r.has(hEvent)) {
            this.volumeDec(this.getSelectedRadio(this.navRadios));
          }
        }
      };
      this.bus = bus;
      this.config = config;
      for (let i = 1; i <= numNavRadios; i++) {
        this.navRadios.push({
          index: i,
          activeFrequency: 0,
          ident: null,
          signal: 0,
          standbyFrequency: 0,
          radioType: RadioType.Nav,
          selected: false
        });
      }
      for (let i = 1; i <= numComRadios; i++) {
        this.comRadios.push({
          index: i,
          activeFrequency: 0,
          ident: null,
          signal: 0,
          standbyFrequency: 0,
          radioType: RadioType.Com,
          selected: false
        });
      }
      this.hevents = this.bus.getSubscriber();
      this.publisher = new NavComPublisher(bus, void 0, sync);
      this.simVarPublisher = new NavComSimVarPublisher(this.bus);
      this.simVarSubscriber = new EventSubscriber(this.bus);
      this.controlSubscriber = bus.getSubscriber();
    }
    /**
     * Initialize the instrument.
     */
    init() {
      this.publisher.startPublish();
      this.simVarPublisher.startPublish();
      this.hevents.on("hEvent").handle(this.eventHandler);
      const navProcessorSubscriber = this.bus.getSubscriber();
      navProcessorSubscriber.on("cdi_select").handle(this.setActiveRadio.bind(this));
      this.controlSubscriber.on("publish_radio_states").handle(this.publishRadioStates.bind(this));
      this.controlSubscriber.on("standby_com_freq").handle(this.setStandbyFreq.bind(this, RadioType.Com));
      this.controlSubscriber.on("com_spacing_set").handle(this.setComSpacing.bind(this));
      this.controlSubscriber.on("standby_nav_freq").handle(this.setStandbyFreq.bind(this, RadioType.Nav));
      this.simVarSubscriber.on("nav_active_frequency_1").whenChangedBy(0.01).handle((data) => {
        this.updateRadioFreqCb(RadioType.Nav, 0, FrequencyBank.Active, data);
      });
      this.simVarSubscriber.on("nav_standby_frequency_1").whenChangedBy(0.01).handle((data) => {
        this.updateRadioFreqCb(RadioType.Nav, 0, FrequencyBank.Standby, data);
      });
      this.simVarSubscriber.on("nav_active_frequency_2").whenChangedBy(0.01).handle((data) => {
        this.updateRadioFreqCb(RadioType.Nav, 1, FrequencyBank.Active, data);
      });
      this.simVarSubscriber.on("nav_standby_frequency_2").whenChangedBy(0.01).handle((data) => {
        this.updateRadioFreqCb(RadioType.Nav, 1, FrequencyBank.Standby, data);
      });
      this.simVarSubscriber.on("com_active_frequency_1").whenChangedBy(1e-3).handle((data) => {
        this.updateRadioFreqCb(RadioType.Com, 0, FrequencyBank.Active, data);
      });
      this.simVarSubscriber.on("com_standby_frequency_1").whenChangedBy(1e-3).handle((data) => {
        this.updateRadioFreqCb(RadioType.Com, 0, FrequencyBank.Standby, data);
      });
      this.simVarSubscriber.on("com_active_frequency_2").whenChangedBy(1e-3).handle((data) => {
        this.updateRadioFreqCb(RadioType.Com, 1, FrequencyBank.Active, data);
      });
      this.simVarSubscriber.on("com_standby_frequency_2").whenChangedBy(1e-3).handle((data) => {
        this.updateRadioFreqCb(RadioType.Com, 1, FrequencyBank.Standby, data);
      });
      this.simVarSubscriber.on("nav_ident_1").whenChanged().handle((data) => {
        this.navRadios[0].ident = data;
        this.publisher.publishIdent(1, data);
      });
      this.simVarSubscriber.on("nav_ident_2").whenChanged().handle((data) => {
        this.navRadios[1].ident = data;
        this.publisher.publishIdent(2, data);
      });
      this.simVarSubscriber.on("nav_signal_1").withPrecision(0).handle((data) => {
        this.navRadios[0].signal = data;
        this.publisher.publishSignalStrength(1, data);
      });
      this.simVarSubscriber.on("nav_signal_2").withPrecision(0).handle((data) => {
        this.navRadios[1].signal = data;
        this.publisher.publishSignalStrength(2, data);
      });
      this.simVarSubscriber.on("adf_active_frequency_1").whenChanged().handle((freq) => {
        this.publisher.publishAdfActiveFrequencySet(freq);
      });
      this.simVarSubscriber.on("adf_standby_frequency_1").whenChanged().handle((freq) => {
        this.publisher.publishAdfStandbyFrequencySet(freq);
      });
      this.navRadios[0].selected = true;
      this.comRadios[0].selected = true;
      for (let i = 0; i < this.navRadios.length; i++) {
        this.updateAndPublish(this.navRadios[i]);
      }
      for (let i = 0; i < this.comRadios.length; i++) {
        this.updateAndPublish(this.comRadios[i]);
      }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
      this.simVarPublisher.onUpdate();
    }
    /**
     * Get the current frequency of a radio.
     * @param radioType The RadioType to query.
     * @param index The index number of the desired radio.
     * @param bank The FrequencyBank to query.
     * @returns The frequency in MHz.
     */
    getFrequency(radioType, index, bank) {
      return SimVar.GetSimVarValue(`${radioType == RadioType.Com ? "COM" : "NAV"} ${bank == FrequencyBank.Active ? "ACTIVE" : "STANDBY"} FREQUENCY:${index}`, "MHz");
    }
    /**
     * React to a change on a radio frequency simvar.
     * @param type The RadioType to update.
     * @param index Index of the radio in the internal array.
     * @param bank The FrequencyBank in the selected radio to update.
     * @param freq The new frequency in MHz.
     */
    updateRadioFreqCb(type, index, bank, freq) {
      const radioArr = type == RadioType.Nav ? this.navRadios : this.comRadios;
      switch (bank) {
        case FrequencyBank.Active:
          radioArr[index].activeFrequency = freq;
          this.publisher.publishFreqChange(radioArr[index], FrequencyBank.Active, freq);
          break;
        case FrequencyBank.Standby:
          radioArr[index].standbyFrequency = freq;
          this.publisher.publishFreqChange(radioArr[index], FrequencyBank.Standby, freq);
          break;
      }
    }
    /**
     * Get the current selected radio in a collection of radios.
     * @param radios An array of Radios.
     * @returns The selected Radio in the array.
     */
    getSelectedRadio(radios) {
      for (const radio of radios) {
        if (radio.selected) {
          return radio;
        }
      }
      return void 0;
    }
    /**
     * Swap frequencies in a radio.
     * @param radio The radio whose frequencies we want to swap.
     */
    swapFreqs(radio) {
      if (radio !== void 0) {
        this.setKVar("SWAP", radio);
      }
    }
    /**
     * Update the frequencies in a radio from simvars.
     *
     * This is useful for snapshot updates as long as we're not worried
     * about one of the frequencies being updated while the snapshot is in
     * flight.
     * @param radio the radio to update
     */
    updateAndPublish(radio) {
      if (radio !== void 0) {
        radio.activeFrequency = this.getFrequency(radio.radioType, radio.index, FrequencyBank.Active);
        radio.standbyFrequency = this.getFrequency(radio.radioType, radio.index, FrequencyBank.Standby);
      }
      switch (radio === null || radio === void 0 ? void 0 : radio.radioType) {
        case RadioType.Com:
          this.comRadios[radio.index - 1] = radio;
          break;
        case RadioType.Nav:
          this.navRadios[radio.index - 1] = radio;
          break;
      }
      this.publisher.publishRadioState(radio);
    }
    /**
     * Explicitly set a new selected nav radio.
     * @param navSourceId An array of Radios to toggle.
     */
    setActiveRadio(navSourceId) {
      if (navSourceId.type === NavSourceType.Nav) {
        for (let i = 0; i < this.navRadios.length; i++) {
          const radio = this.navRadios[i];
          if (radio.index == navSourceId.index) {
            radio.selected = true;
          } else {
            radio.selected = false;
          }
          this.publisher.publishRadioState(radio);
        }
      }
    }
    /**
     * Increase the volume of the selected nav or com radio.
     * @param radio The radio whose volume we want to increase.
     */
    volumeInc(radio) {
      if (radio !== void 0) {
        SimVar.SetSimVarValue(`K:${radio.radioType}${radio.index}_VOLUME_INC`, "number", 0);
      }
    }
    /**
     * Increase the volume of the selected nav or com radio.
     * @param radio The radio whose volume we want to increase.
     */
    volumeDec(radio) {
      if (radio !== void 0) {
        SimVar.SetSimVarValue(`K:${radio.radioType}${radio.index}_VOLUME_DEC`, "number", 0);
      }
    }
    /**
     * Increase the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    wholeInc(radio) {
      this.setKVar("WHOLE_INC", radio);
    }
    /**
     * Decrease the integer portion of a frequency.
     * @param radio The Radio to update.
     */
    wholeDec(radio) {
      this.setKVar("WHOLE_DEC", radio);
    }
    /**
     * Increase the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    fractInc(radio) {
      this.setKVar("FRACT_INC", radio);
    }
    /**
     * Decrease the decimal portion of a frequency.
     * @param radio The Radio to update.
     */
    fractDec(radio) {
      this.setKVar("FRACT_DEC", radio);
    }
    /**
     * Set the standby frequency of the currently selected nav or com radio.
     * @param radioType The radio type we want to set standby for.
     * @param frequency The frequency in MHz as a string.
     */
    setStandbyFreq(radioType, frequency) {
      let radio;
      switch (radioType) {
        case RadioType.Com:
          radio = this.getSelectedRadio(this.comRadios);
          break;
        case RadioType.Nav:
          radio = this.getSelectedRadio(this.navRadios);
          break;
      }
      this.freqSet(radio, FrequencyBank.Standby, frequency);
    }
    /**
     * Toggle which of the radios is selected.
     * @param radios An array of Radios to toggle.
     */
    swapSelection(radios) {
      for (let i = 0; i < radios.length; i++) {
        radios[i].selected = !radios[i].selected;
        this.publisher.publishRadioState(radios[i]);
      }
    }
    /**
     * Set the full frequency of a radio.
     * @param radio The Radio to update.
     * @param bank The FrequencyBank to update.
     * @param freq The new frequency in MHz as a string.
     */
    freqSet(radio, bank, freq) {
      if (!radio) {
        return;
      }
      let radioId;
      if (radio.radioType == RadioType.Com) {
        const first = radio.index == 1 ? "COM" : `COM${radio.index}`;
        const second = bank == FrequencyBank.Active ? "RADIO" : "STBY_RADIO";
        radioId = `${first}_${second}`;
      } else {
        radioId = `NAV${radio.index}_${bank == FrequencyBank.Active ? "RADIO" : "STBY"}`;
      }
      const freqMhz = Math.round(parseFloat(freq) * 1e3) / 1e3;
      SimVar.SetSimVarValue(`K:${radioId}_SET_HZ`, "Hz", Math.round(freqMhz * 1e6));
    }
    /**
     * Set the K var for a frequency event
     * @param action A string defining whole/fract and inc/dec.
     * @param radio The radio this frequency is for.
     */
    setKVar(action, radio) {
      if (radio == void 0) {
        return;
      }
      let device;
      switch (radio.radioType) {
        case RadioType.Nav:
          device = `NAV${radio.index}`;
          break;
        case RadioType.Com:
          if (action == "SWAP") {
            device = radio.index == 1 ? "COM_STBY" : `COM${radio.index}`;
          } else {
            device = radio.index == 1 ? "COM" : `COM${radio.index}`;
          }
          break;
        default:
          return;
      }
      SimVar.SetSimVarValue(`K:${device}_RADIO_${action}`, "number", 0);
    }
    /**
     * Send an update of all our radio states.
     * @param data True if we really want to do this.  (We need to support non-paramaterized commands.())
     */
    publishRadioStates(data) {
      if (!data) {
        return;
      }
      for (const radio of this.navRadios) {
        this.publisher.publishRadioState(radio);
      }
      for (const radio of this.comRadios) {
        this.publisher.publishRadioState(radio);
      }
    }
    /**
     * Sets the COM frequency spacing.
     * @param evt The event that is setting the spacing.
     */
    setComSpacing(evt) {
      const currentSpacing = SimVar.GetSimVarValue(`COM SPACING MODE:${evt.index}`, SimVarValueType.Enum);
      if (currentSpacing !== evt.spacing) {
        SimVar.SetSimVarValue(`K:COM_${evt.index.toFixed(0)}_SPACING_MODE_SWITCH`, "number", 0);
      }
    }
  };
  var PitotPublisher = class extends SimVarPublisher {
    /**
     * Creates an instance of an PitotPublisher.
     * @param bus The event bus to use with this instance.
     * @param pitotCount The number of pitot tubes to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pitotCount, pacer) {
      const indexedSimVars = [
        ["pitot_heat_switch_on", { name: "PITOT HEAT SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(PitotPublisher.nonIndexedSimVars);
      for (const [topic, simvar2] of indexedSimVars) {
        for (let i = 1; i <= pitotCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  PitotPublisher.nonIndexedSimVars = [
    ["pitot_heat_on", { name: "PITOT HEAT", type: SimVarValueType.Bool }],
    ["pitot_icing_pct", { name: "PITOT ICE PCT", type: SimVarValueType.Percent }]
  ];
  var PressurizationPublisher = class extends SimVarPublisher {
    /**
     * Create an PressurizationPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      super(PressurizationPublisher.simvars, bus, pacer);
    }
    /**
     * Updates the ADC publisher.
     */
    onUpdate() {
      super.onUpdate();
    }
  };
  PressurizationPublisher.simvars = /* @__PURE__ */ new Map([
    ["cabin_altitude", { name: "PRESSURIZATION CABIN ALTITUDE", type: SimVarValueType.Feet }],
    ["cabin_altitude_rate", { name: "PRESSURIZATION CABIN ALTITUDE RATE", type: SimVarValueType.FPM }],
    ["pressure_diff", { name: "PRESSURIZATION PRESSURE DIFFERENTIAL", type: SimVarValueType.PSI }]
  ]);
  var DebounceTimer = class {
    constructor() {
      this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
      return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
      this.clear();
      this.timer = setTimeout(() => {
        this.timer = null;
        action();
      }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
      if (this.timer === null) {
        return;
      }
      clearTimeout(this.timer);
      this.timer = null;
    }
  };
  var XPDRMode;
  (function(XPDRMode2) {
    XPDRMode2[XPDRMode2["OFF"] = 0] = "OFF";
    XPDRMode2[XPDRMode2["STBY"] = 1] = "STBY";
    XPDRMode2[XPDRMode2["TEST"] = 2] = "TEST";
    XPDRMode2[XPDRMode2["ON"] = 3] = "ON";
    XPDRMode2[XPDRMode2["ALT"] = 4] = "ALT";
    XPDRMode2[XPDRMode2["GROUND"] = 5] = "GROUND";
  })(XPDRMode || (XPDRMode = {}));
  var XPDRSimVarPublisher = class extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus, pacer = void 0, transponderCount = 1) {
      const vars = [];
      for (let i = 0; i < transponderCount; i++) {
        vars.push([`xpdr_mode_${i + 1}`, { name: `TRANSPONDER STATE:${i + 1}`, type: SimVarValueType.Number }]);
        vars.push([`xpdr_code_${i + 1}`, { name: `TRANSPONDER CODE:${i + 1}`, type: SimVarValueType.Number }]);
        vars.push([`xpdr_ident_${i + 1}`, { name: `TRANSPONDER IDENT:${i + 1}`, type: SimVarValueType.Bool }]);
      }
      super(new Map(vars), bus, pacer);
    }
  };
  var XPDRInstrument = class {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus, transponderCount = 1) {
      this.bus = bus;
      this.transponderCount = transponderCount;
      this.identDebounceTimers = Array.from({ length: this.transponderCount }, () => new DebounceTimer());
      this.bus = bus;
      this.simVarPublisher = new XPDRSimVarPublisher(bus);
      this.controlSubscriber = bus.getSubscriber();
    }
    /** Initialize the instrument. */
    init() {
      this.simVarPublisher.startPublish();
      for (let i = 0; i < this.transponderCount; i++) {
        this.controlSubscriber.on(`publish_xpdr_code_${i + 1}`).handle(this.setXpdrCode.bind(this, i + 1));
        this.controlSubscriber.on(`publish_xpdr_mode_${i + 1}`).handle(this.setXpdrMode.bind(this, i + 1));
        this.controlSubscriber.on(`xpdr_send_ident_${i + 1}`).handle(this.sendIdent.bind(this, i + 1));
        if (this.getXpdrMode(i + 1) === XPDRMode.OFF) {
          this.setXpdrMode(i + 1, XPDRMode.STBY);
        }
      }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
      this.simVarPublisher.onUpdate();
    }
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    setXpdrCode(index, code) {
      const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
      SimVar.SetSimVarValue(`K:${index}:XPNDR_SET`, "Frequency BCD16", bcdCode);
    }
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    setXpdrMode(index, mode) {
      SimVar.SetSimVarValue(`TRANSPONDER STATE:${index}`, "number", mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    getXpdrMode(index) {
      return SimVar.GetSimVarValue(`TRANSPONDER STATE:${index}`, "number");
    }
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    sendIdent(index) {
      if (this.getXpdrMode(index) > XPDRMode.STBY) {
        SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_ON`, "number", 1);
        this.identDebounceTimers[index - 1].schedule(() => {
          SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_OFF`, "number", 0);
        }, 18e3);
      }
    }
  };
  var Wait = class {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay) {
      return new Promise((resolve) => setTimeout(() => resolve(), delay));
    }
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate, interval = 0, timeout = 0) {
      const t0 = Date.now();
      if (interval <= 0) {
        const loopFunc = (resolve, reject) => {
          if (timeout > 0 && Date.now() - t0 >= timeout) {
            reject("Await condition timed out.");
          } else {
            predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(void 0, resolve, reject));
          }
        };
        return new Promise((resolve, reject) => {
          loopFunc(resolve, reject);
        });
      } else {
        return new Promise((resolve, reject) => {
          const timer = setInterval(() => {
            if (timeout > 0 && Date.now() - t0 > timeout) {
              clearInterval(timer);
              reject("Await condition timed out.");
            } else if (predicate()) {
              clearInterval(timer);
              resolve();
            }
          }, interval);
        });
      }
    }
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = subscribable.sub((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub.destroy();
            resolve(val);
          }
        }, false, true);
        sub.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = consumer.handle((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub.destroy();
            resolve(val);
          }
        }, true);
        sub.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent(event, predicate, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub = event.on((sender, data) => {
          if (predicate === void 0 || predicate(data, sender)) {
            sub.destroy();
            resolve(data);
          }
        }, true);
        sub.resume();
        if (timeout > 0) {
          setTimeout(() => {
            if (sub.isAlive) {
              sub.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
  };
  var TrafficInstrument = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
      this.bus = bus;
      this.tracked = /* @__PURE__ */ new Map();
      this.lastUpdateRealTime = 0;
      this.lastUpdateSimTime = 0;
      this.isBusy = false;
      this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
      return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
      this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
      this.bus.getSubscriber().on("simTime").whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
      const len = data.length;
      for (let i = 0; i < len; i++) {
        const entry = data[i];
        const contact = this.tracked.get(entry.uId);
        if (contact) {
          this.updateContact(contact, entry, simTime);
        } else {
          this.createContact(entry, simTime);
        }
      }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
      const contact = new TrafficContactClass(entry.uId, 1e3 / this.options.simTimeUpdateFreq * 5);
      this.tracked.set(contact.uid, contact);
      contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
      this.bus.pub("traffic_contact_added", contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
      contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
      this.bus.pub("traffic_contact_updated", contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
      this.tracked.forEach((contact) => {
        const dt = Math.abs(simTime - contact.lastContactTime);
        if (dt >= this.options.contactDeprecateTime) {
          this.tracked.delete(contact.uid);
          this.bus.pub("traffic_contact_removed", contact.uid, false, false);
        }
      });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
      const realTime = Date.now();
      if (this.isBusy || Math.abs(simTime - this.lastUpdateSimTime) < 1e3 / this.options.simTimeUpdateFreq || Math.abs(realTime - this.lastUpdateRealTime) < 1e3 / this.options.realTimeUpdateFreq) {
        return;
      }
      this.isBusy = true;
      try {
        const data = await Promise.race([Coherent.call("GET_AIR_TRAFFIC"), Wait.awaitDelay(1e3)]);
        if (data) {
          this.updateContacts(data, simTime);
          this.deprecateContacts(simTime);
          this.lastUpdateSimTime = simTime;
          this.lastUpdateRealTime = realTime;
        }
      } catch (e) {
        console.error(e);
        if (e instanceof Error) {
          console.error(e.stack);
        }
      }
      this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
    }
  };
  var TrafficContactClass = class {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
      this.uid = uid;
      this.contactTimeResetThreshold = contactTimeResetThreshold;
      this._lastPosition = new GeoPoint(NaN, NaN);
      this.lastPosition = this._lastPosition.readonly;
      this._lastAltitude = UnitType.FOOT.createNumber(NaN);
      this.lastAltitude = this._lastAltitude.readonly;
      this._lastHeading = NaN;
      this._lastContactTime = NaN;
      this._groundSpeed = UnitType.KNOT.createNumber(NaN);
      this.groundSpeed = this._groundSpeed.readonly;
      this._groundTrack = NaN;
      this._verticalSpeed = UnitType.FPM.createNumber(NaN);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
      return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
      return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
      return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
      if (this.groundSpeed.isNaN()) {
        positionOut.set(NaN, NaN);
        altitudeOut.set(NaN);
        return;
      }
      const dt = simTime - this.lastContactTime;
      const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 36e5), UnitType.GA_RADIAN);
      this._lastPosition.offset(this._groundTrack, distance, positionOut);
      const deltaAlt = this._verticalSpeed.number * (dt / 6e4);
      this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
      const dt = simTime - this._lastContactTime;
      if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
        this.reset(lat, lon, altitude, heading, simTime);
        return;
      }
      if (!isNaN(dt) && dt > 0) {
        this.updateComputedValues(dt / 1e3, lat, lon, altitude);
      }
      this.setReportedValues(lat, lon, altitude, heading);
      if (this.areComputedValuesValid()) {
        this._lastContactTime = simTime;
      } else {
        this.reset(lat, lon, altitude, heading, simTime);
      }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
      this.setReportedValues(lat, lon, altitude, heading);
      this._groundSpeed.set(NaN);
      this._groundTrack = NaN;
      this._verticalSpeed.set(NaN);
      this.groundSpeedSmoother.reset();
      this.groundTrackSmoother.reset();
      this.verticalSpeedSmoother.reset();
      this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
      this._lastPosition.set(lat, lon);
      this._lastAltitude.set(altitude);
      this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
      const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
      const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
      const track = pos.bearingFrom(this._lastPosition);
      this.updateGroundSpeed(dt, distanceNM);
      this.updateGroundTrack(dt, track, distanceNM);
      this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
      const dtHours = dt / 3600;
      const speedKnots = distanceNM / dtHours;
      this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
      const last = this.groundTrackSmoother.last();
      if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
        if (last !== null && !isNaN(last)) {
          let delta = track - last;
          if (delta > 180) {
            delta = delta - 360;
          } else if (delta < -180) {
            delta = delta + 360;
          }
          track = last + delta;
        }
      } else {
        track = last === null ? NaN : last;
      }
      const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
      this._groundTrack = (next + 360) % 360;
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
      const dtMin = dt / 60;
      const deltaAltFeet = altitude - this._lastAltitude.number;
      const vsFPM = deltaAltFeet / dtMin;
      this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
      const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
      const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
      return isGroundSpeedValid && isVerticalSpeedValid;
    }
  };
  TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500;
  TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 1e4;
  TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852;
  TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);
  var FuelSystemSimVarPublisher = class extends SimVarPublisher {
    /**
     * Create an FuelSystemSimvarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = void 0) {
      const simvars = /* @__PURE__ */ new Map([
        ["fuel_system_valve_open", { name: "FUELSYSTEM VALVE OPEN:#index#", type: SimVarValueType.Percent, indexed: true }]
      ]);
      super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
      super.onUpdate();
    }
  };
  var SystemAlertPublisher = class extends BasePublisher {
    /**
     * Publish an alert event.
     * @param event The event from SystemAlertEvents.
     * @param value The value for the event.
     */
    publishAlert(event, value) {
      this.publish(event, value, true, false);
    }
  };
  var Easing = class {
    /**
     * Creates a linear easing function.
     * @returns A linear easing function.
     */
    static linear() {
      return (x) => MathUtils.clamp(x, 0, 1);
    }
    /**
     * Creates a quadratic easing function.
     * @param end The end to which to apply easing.
     * @returns A quadratic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static quad(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x;
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - (1 - x) * (1 - x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 2 * x * x : 1 - 2 * (1 - x) * (1 - x);
        default:
          throw new Error(`Easing.quad(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a cubic easing function.
     * @param end The end to which to apply easing.
     * @returns A cubic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static cubic(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 4 * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 4 * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.cubic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a quartic easing function.
     * @param end The end to which to apply easing.
     * @returns A quartic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static quart(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 8 * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 8 * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quart(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a quintic easing function.
     * @param end The end to which to apply easing.
     * @returns A quintic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static quint(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 16 * x * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 16 * compl * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quint(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a polynomial easing function.
     * @param order The order of the polynomial.
     * @param end The end to which to apply easing.
     * @returns A polynomial easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static polynomial(order, end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(x, order);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(1 - x, order);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2 * x, order) : 1 - 0.5 * Math.pow(2 * (1 - x), order);
        default:
          throw new Error(`Easing.polynomial(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a sinusoid easing function.
     * @param end The end to which to apply easing.
     * @returns A sinusoid easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static sin(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.cos(x * MathUtils.HALF_PI);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sin(x * MathUtils.HALF_PI);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : (1 - Math.cos(x * Math.PI)) * 0.5;
        default:
          throw new Error(`Easing.sin(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a circular easing function.
     * @param end The end to which to apply easing.
     * @returns A circular easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static circ(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.sqrt(1 - x * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sqrt(1 - (x - 1) * (x - 1));
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? (1 - Math.sqrt(1 - 4 * x * x)) * 0.5 : (Math.sqrt(1 - 4 * (1 - x) * (1 - x)) + 1) * 0.5;
        default:
          throw new Error(`Easing.circ(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates an exponential easing function.
     * @param end The end to which to apply easing.
     * @returns An exponential easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static exp(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(2, 10 * (x - 1));
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(2, -10 * x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2, 20 * (x - 0.5)) : 1 - 0.5 * Math.pow(2, 20 * (0.5 - x));
        default:
          throw new Error(`Easing.exp(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a back easing function.
     * @param end The end to which to apply easing.
     * @returns A back easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static back(end) {
      const c1 = 2.70158;
      const c2 = 1.70158;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * x * x * x - c2 * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl + c2 * compl * compl;
            }
          };
        case "both": {
          const c3 = c2 * 1.525;
          const c4 = c3 + 1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 2 * (x * x * (2 * c4 * x - c3));
            } else {
              const compl = 1 - x;
              return 1 - 2 * compl * compl * (2 * c4 * compl - c3);
            }
          };
        }
        default:
          throw new Error(`Easing.back(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates an elastic easing function.
     * @param end The end to which to apply easing.
     * @returns An elastic easing function.
     * @throws Error if `end` is not one of `'in' | 'out' | 'both'`.
     */
    static elastic(end) {
      const c1 = MathUtils.TWO_PI / 3;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * Math.pow(2, 10 * (x - 1)) * Math.sin(10.75 - 10 * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - c1 * Math.pow(2, -10 * x) * Math.sin(0.75 - 10 * x);
        case "both": {
          const c2 = c1 * c1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 0.5 * Math.pow(2, 20 * (x - 0.5)) * Math.sin(c2 * (11.125 - 20 * x));
            } else {
              return 1 - 0.5 * Math.pow(2, 20 * (0.5 - x)) * Math.sin(c2 * (11.125 - 20 * x));
            }
          };
        }
        default:
          throw new Error(`Easing.elastic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    /**
     * Creates a cubic bezier easing function. The function follows a cubic bezier curve with the endpoints fixed at
     * `(0, 0)` and `(1, 1)`.
     *
     * The function can optionally use a precomputed lookup table. Using a lookup table may increase performance and/or
     * precision of the created function at the cost of some precomputation time and memory needed to store the lookup
     * table.
     * @param c1x The x-coordinate of the first control point. Will be clamped to the range `[0, 1]`.
     * @param c1y The y-coordinate of the first control point.
     * @param c2x The x-coordinate of the second control point. Will be clamped to the range `[0, 1]`.
     * @param c2y The y-coordinate of the second control point.
     * @param precompute Whether to precompute a lookup table. Defaults to `false`.
     * @param minXResolution The minimum resolution of the function along the x-axis. Defaults to `0.1` if `precompute`
     * is `true`, or `1e-4` if `precompute` is `false`.
     * @param epsilon The threshold of acceptable linear interpolation error used during precomputation. Ignored if
     * `precompute` is false. Defaults to `1e-4`.
     * @param maxDepth The maximum allowed recursive depth of precomputation. The number of additional lookup table
     * breakpoints generated is bounded from above by `2 ^ (maxDepth) - 1`. Ignored if `precompute` is false. Defaults
     * to `10`.
     * @returns A cubic bezier easing function.
     */
    static bezier(c1x, c1y, c2x, c2y, precompute = false, minXResolution, epsilon = 1e-3, maxDepth = 10) {
      c1x = MathUtils.clamp(c1x, 0, 1);
      c2x = MathUtils.clamp(c2x, 0, 1);
      if (precompute) {
        const minXRes = minXResolution !== null && minXResolution !== void 0 ? minXResolution : 0.1;
        const lookup = new LerpLookupTable(1);
        lookup.insertBreakpoint([0, 0]);
        lookup.insertBreakpoint([1, 1]);
        if (maxDepth > 0) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, 0, 0, 0, 1, 1, 1, 1);
        }
        return (x) => {
          return x <= 0 ? 0 : x >= 1 ? 1 : lookup.get(x);
        };
      } else {
        const minXRes = Math.max(minXResolution !== null && minXResolution !== void 0 ? minXResolution : 1e-4, 1e-6);
        return (x) => {
          if (x <= 0) {
            return 0;
          } else if (x >= 1) {
            return 1;
          }
          let t0 = 0, t1 = 1;
          let tquery = (t0 + t1) / 2;
          let xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          while (Math.abs(x - xquery) > minXRes) {
            if (x - xquery < 0) {
              t1 = tquery;
            } else {
              t0 = tquery;
            }
            tquery = (t0 + t1) / 2;
            xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          }
          return Easing.easingBezierFunc(tquery, c1y, c2y);
        };
      }
    }
    /**
     * Precomputes lookup table breakpoints for a cubic bezier easing function.
     * @param c1x The x-coordinate of the first control point.
     * @param c1y The y-coordinate of the first control point.
     * @param c2x The x-coordinate of the second control point.
     * @param c2y The y-coordinate of the second control point.
     * @param lookup A lookup table to which to add breakpoints.
     * @param minXRes The desired minimum resolution along the x-axis.
     * @param epsilon The maximum acceptable linear interpolation error. Recursion will continue if the interpolated y
     * value differs from the exact y value by more than this amount.
     * @param maxDepth The maximum allowed recursion depth.
     * @param t0 The distance value at the current left endpoint.
     * @param x0 The x value at the current left endpoint.
     * @param y0 The y value at the current left endpoint.
     * @param t1 The distance value at the current right endpoint.
     * @param x1 The x value at the current right endpoint.
     * @param y1 The y value at the current right endpoint.
     * @param depth The current recursion depth.
     */
    static precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, t1, x1, y1, depth) {
      const tmid = (t0 + t1) / 2;
      const xdelta = x1 - x0;
      const xmid = Easing.easingBezierFunc(tmid, c1x, c2x);
      const ymid = Easing.easingBezierFunc(tmid, c1y, c2y);
      const ylerp = MathUtils.lerp(xmid, x0, x1, y0, y1);
      let shouldContinue = false;
      shouldContinue = xdelta > minXRes || Math.abs(ylerp - ymid) > epsilon;
      if (shouldContinue) {
        lookup.insertBreakpoint([ymid, xmid]);
        if (depth < maxDepth) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, tmid, xmid, ymid, depth + 1);
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, tmid, xmid, ymid, t1, x1, y1, depth + 1);
        }
      }
    }
    /**
     * Computes a coordinate value along a bezier curve with P0 fixed at `(0, 0)` and P3 fixed at `(1, 1)`.
     * @param t The distance along the curve normalized to `[0, 1]`.
     * @param c1 The coordinate of the first control point.
     * @param c2 The coordinate of the second control point.
     * @returns The coordinate value along the specified bezier curve at the specified distance.
     */
    static easingBezierFunc(t, c1, c2) {
      return 3 * (1 - t) * (1 - t) * t * c1 + 3 * (1 - t) * t * t * c2 + t * t * t;
    }
    /**
     * Converts an easing function to one which supports arbitrary start and stop endpoints.
     * @param ease An easing function.
     * @returns A new easing function which generates the same shape as the specified function while supporting arbitrary
     * start and stop endpoints.
     */
    static withEndpointParams(ease) {
      return (start, stop, progress) => {
        return start + (stop - start) * ease(progress);
      };
    }
    /**
     * Converts an easing function to one which uses specific start and stop endpoints.
     * @param ease An easing function.
     * @param start The start endpoint.
     * @param stop The stop endpoint.
     * @returns A new easing function which generates the same shape as the specified function while using the specified
     * start and stop endpoints.
     */
    static withEndpoints(ease, start, stop) {
      const delta = stop - start;
      return (progress) => {
        return start + delta * ease(progress);
      };
    }
  };
  var Animator = class {
    constructor() {
      this._value = Subject.create(0);
      this._isAnimating = false;
      this.isAnimationLoopActive = false;
      this.animationEaseFunc = Animator.DEFAULT_EASE_FUNC;
      this.animationStart = 0;
      this.animationStop = 0;
      this.animationStartTime = 0;
      this.animationDuration = 0;
      this.animationLoop = () => {
        if (!this._isAnimating) {
          this.isAnimationLoopActive = false;
          return;
        }
        const progress = (Date.now() - this.animationStartTime) / this.animationDuration;
        if (progress < 1) {
          this._value.set(this.animationEaseFunc(this.animationStart, this.animationStop, progress));
          requestAnimationFrame(this.animationLoop);
        } else {
          this._isAnimating = false;
          this.isAnimationLoopActive = false;
          this._value.set(this.animationStop);
        }
      };
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This animator's current value. */
    get value() {
      return this._value;
    }
    /**
     * Checks whether this animator has an animation in progress.
     * @returns Whether this animator has an animation in progress.
     */
    isAnimating() {
      return this._isAnimating;
    }
    /**
     * Starts an animation. The animation will proceed from this animator's current value to the target value over the
     * specified duration. If another animation is currently active, it will immediately be stopped and replaced by the
     * new animation.
     * @param target The target value.
     * @param duration The duration of the animation, in milliseconds.
     * @param easeFunc The easing function to apply to the animation. Defaults to a linear easing function.
     */
    start(target, duration, easeFunc) {
      if (duration <= 0) {
        this.set(target);
        return;
      }
      this._isAnimating = true;
      this.animationStart = this._value.get();
      this.animationStop = target;
      this.animationStartTime = Date.now();
      this.animationDuration = duration;
      this.animationEaseFunc = easeFunc !== null && easeFunc !== void 0 ? easeFunc : Animator.DEFAULT_EASE_FUNC;
      if (!this.isAnimationLoopActive) {
        this.isAnimationLoopActive = true;
        requestAnimationFrame(this.animationLoop);
      }
    }
    /**
     * Immediately sets this animator's value. This will stop any animation currently in progress.
     * @param value The rotation to set, in degrees.
     */
    set(value) {
      this._isAnimating = false;
      this._value.set(value);
    }
    /**
     * Stops this animator's current in-progress animation, if any, and optionally sets this animator's value to the
     * animation's target value.
     * @param setAnimationTarget Whether to set this animator's value to the animation target value after stopping the
     * animation. Defaults to `false`.
     */
    stop(setAnimationTarget = false) {
      if (!this._isAnimating) {
        return;
      }
      this._isAnimating = false;
      if (setAnimationTarget) {
        this._value.set(this.animationStop);
      }
    }
  };
  Animator.DEFAULT_EASE_FUNC = Easing.withEndpointParams(Easing.linear());
  var BacklightLevelController = class {
    /**
     * Creates an automatic backlight controller.
     * @param bus The event bus.
     * @param paused Whether the controller should be initially paused. Defaults to `false`.
     * @param minIntensity The maximum intensity commanded by the controller. Defaults to 0.
     * @param maxIntensity The minimum intensity commanded by the controller. Defaults to 1.
     */
    constructor(bus, paused = false, minIntensity = BacklightLevelController.DEFAULT_MIN_INTENSITY, maxIntensity = BacklightLevelController.DEFAULT_MAX_INTENSITY) {
      this.simTime = ConsumerSubject.create(null, 0);
      this.ppos = new Float64Array(3);
      this.needRecalcAuto = true;
      this.lastSimTime = 0;
      this.paused = false;
      this._intensity = Subject.create(0);
      this.intensity = this._intensity;
      this._autoMinIntensity = minIntensity;
      this._autoMaxIntensity = maxIntensity;
      this._autoIntensityRange = this.autoMaxIntensity - this.autoMinIntensity;
      this.needRecalcAuto = true;
      const sub = bus.getSubscriber();
      this.simTime.setConsumer(sub.on("simTime"));
      this.pposSub = sub.on("gps-position").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onPPosChanged.bind(this));
      this.updateSub = sub.on("realTime").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));
      this.setPaused(paused);
    }
    /**
     * Get the max auto intensity value
     * @returns The maximum intensity applied by the auto backlight.
     */
    get autoMaxIntensity() {
      return this._autoMaxIntensity;
    }
    /**
     * Set the max auto intensity value.
     * @param max_intensity The maximum intensity applied by auto backlight.
     */
    set autoMaxIntensity(max_intensity) {
      this._autoMaxIntensity = max_intensity;
      this._autoIntensityRange = this._autoMaxIntensity - this._autoMinIntensity;
      this.needRecalcAuto = true;
    }
    /**
     * Get the min auto intensity value
     * @returns THe minimum intensity applied by the auto backlight.
     */
    get autoMinIntensity() {
      return this._autoMinIntensity;
    }
    /**
     * Set the min auto intensity value.
     * @param min_intensity The minimum intensity applied by the auto backlight.
     */
    set autoMinIntensity(min_intensity) {
      this._autoMinIntensity = min_intensity;
      this._autoIntensityRange = this._autoMinIntensity - min_intensity;
      this.needRecalcAuto = true;
    }
    /**
     * Pause or unpause real-time processing.
     * @param paused Whether to pause or not.
     */
    setPaused(paused) {
      if (paused !== this.paused) {
        this.paused = paused;
        if (paused) {
          this.updateSub.pause();
          this.pposSub.pause();
          this.simTime.pause();
          this.needRecalcAuto = false;
        } else {
          this.needRecalcAuto = true;
          this.simTime.resume();
          this.pposSub.resume(true);
          this.updateSub.resume(true);
        }
      }
    }
    /**
     * A callback which is called when the user's location changes.
     * @param ppos The new plane position.
     */
    onPPosChanged(ppos) {
      const pposVec = GeoPoint.sphericalToCartesian(ppos.lat, ppos.long, BacklightLevelController.tempVec3);
      if (Vec3Math.dot(pposVec, this.ppos) >= 1 - 1e-4) {
        return;
      }
      Vec3Math.copy(pposVec, this.ppos);
      this.needRecalcAuto = true;
    }
    /**
     * Updates this controller's commanded backlight intensity if necessary.
     */
    onUpdate() {
      const simTime = this.simTime.get();
      this.needRecalcAuto || (this.needRecalcAuto = Math.abs(simTime - this.lastSimTime) >= BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD);
      if (this.needRecalcAuto) {
        this.needRecalcAuto = false;
        this.updateAutoBacklightIntensity(simTime);
      }
    }
    /**
     * Updates this controller's commanded backlight intensity according to the auto setting algorithm.
     * @param simTime The current sim time.
     */
    updateAutoBacklightIntensity(simTime) {
      this.lastSimTime = simTime;
      const subSolarPoint = BacklightLevelController.calculateSubSolarPoint(simTime, BacklightLevelController.tempVec3);
      const sinSolarAngle = Vec3Math.dot(this.ppos, subSolarPoint);
      const sinSolarAngleClamped = Utils.Clamp(sinSolarAngle, BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN, BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN);
      const intensityFrac = (sinSolarAngleClamped - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN) / BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN;
      this._intensity.set(this._autoMinIntensity + intensityFrac * this._autoIntensityRange);
    }
    /**
     * Calculates the subsolar point (the point on Earth's surface directly below the Sun, where solar zenith angle = 0)
     * given a specific time.
     * @param time A UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The subsolar point at the specified time.
     */
    static calculateSubSolarPoint(time, out) {
      const PI2 = 2 * Math.PI;
      const days = (time - BacklightLevelController.EPOCH) / BacklightLevelController.DAY;
      const daysFrac = days - Math.floor(days);
      const L = 4.895055 + 0.01720279 * days;
      const g = 6.240041 + 0.01720197 * days;
      const lambda = L + 0.033423 * Math.sin(g) + 349e-6 * Math.sin(2 * g);
      const epsilon = 0.40910518 - 698e-11 * days;
      const rAscension = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
      const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
      const E = (((L - rAscension) % PI2 + 3 * Math.PI) % PI2 - Math.PI) * 0.159155;
      const lat = declination * Avionics.Utils.RAD2DEG;
      const lon = -15 * (daysFrac - 0.5 + E) * 24;
      return GeoPoint.sphericalToCartesian(lat, lon, out);
    }
  };
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE = 3;
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE = -8;
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MAX_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MIN_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN = BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN;
  BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ = 10;
  BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD = 6e4;
  BacklightLevelController.EPOCH = 9466848e5;
  BacklightLevelController.DAY = 864e5;
  BacklightLevelController.DEFAULT_MIN_INTENSITY = 0;
  BacklightLevelController.DEFAULT_MAX_INTENSITY = 1;
  BacklightLevelController.tempVec3 = new Float64Array(3);
  var LinearServo = class {
    /**
     * Creates an instance of a LinearServo.
     * @param rate The rate, in units per second, to drive the servo.
     */
    constructor(rate) {
      this.rate = rate;
    }
    /**
     * Drives the servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @returns The output value.
     */
    drive(currentValue, setValue) {
      if (this.currentTime === void 0) {
        this.currentTime = (/* @__PURE__ */ new Date()).appTime();
        return currentValue;
      }
      const currentTime = (/* @__PURE__ */ new Date()).appTime();
      const deltaTime = currentTime - this.currentTime;
      this.currentTime = currentTime;
      const deltaValue = setValue - currentValue;
      const maximumDrive = this.rate * (deltaTime / 1e3);
      const output = Math.abs(deltaValue) > maximumDrive ? currentValue + Math.sign(deltaValue) * maximumDrive : setValue;
      return output;
    }
    /**
     * Resets the servo to initial state
     */
    reset() {
      this.currentTime = void 0;
    }
  };
  var PidController = class {
    /**
     * Creates a new PidController.
     * @param kP The proportional gain of the controller.
     * @param kI The integral gain of the controller.
     * @param kD The differential gain of the controller.
     * @param maxOut The maximum output of the controller.
     * @param minOut The minumum output of the controller.
     * @param maxI The maximum integral gain.
     * @param minI The minimum integral gain.
     */
    constructor(kP, kI, kD, maxOut, minOut, maxI = Number.MAX_SAFE_INTEGER, minI = Number.MIN_SAFE_INTEGER) {
      this.kP = kP;
      this.kI = kI;
      this.kD = kD;
      this.maxOut = maxOut;
      this.minOut = minOut;
      this.maxI = maxI;
      this.minI = minI;
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    /**
     * Gets the output of the PID controller at a given time.
     * @param deltaTime The difference in time between the previous sample and this sample.
     * @param error The amount of error seen between the desired output and the current output.
     * @returns The PID output.
     */
    getOutput(deltaTime, error) {
      var _a;
      const p = this.kP * error;
      if (this.previousError !== void 0 && Math.sign(error) === Math.sign(this.previousError)) {
        this.integral += (error * deltaTime + deltaTime * (error - this.previousError) / 2) * this.kI;
        this.integral = PidController.clamp(this.integral, this.maxI, this.minI);
      } else {
        this.integral = 0;
      }
      const i = this.integral;
      const d = this.kD * ((error - ((_a = this.previousError) !== null && _a !== void 0 ? _a : error)) / deltaTime);
      const output = PidController.clamp(p + i + d, this.maxOut, this.minOut);
      this.previousError = error;
      this.previousOutput = output;
      return output;
    }
    /** Resets the controller. */
    reset() {
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    /**
     * Clamps a number to maximum and minimum values.
     * @param value The value to clamp.
     * @param max The maximum value.
     * @param min The minumum value.
     * @returns The clamped value.
     */
    static clamp(value, max, min) {
      return Math.min(Math.max(value, min), max);
    }
  };
  var InputAcceleration = class {
    /**
     * Ctor
     * @param options the knob acceleration settings
     * @param initiallyPaused whether the knob acceleration is initially paused
     */
    constructor(options = {}, initiallyPaused = false) {
      var _a;
      this.acceleration = 0;
      this.isPaused = false;
      this.maxAcceleration = 15;
      this.accelDampeningPeriod = 50;
      this.options = Object.assign({
        increment: 1,
        bigIncrement: ((_a = options.increment) !== null && _a !== void 0 ? _a : 1) * 10
      }, options);
      this.isPaused = initiallyPaused;
      if (!initiallyPaused) {
        this.resume();
      }
    }
    /** Updates the acceleration. */
    update() {
      if (this.acceleration > 0) {
        this.acceleration = MathUtils.clamp(this.acceleration - 1, 0, this.maxAcceleration);
        if (!this.isPaused) {
          setTimeout(() => {
            this.update();
          }, this.accelDampeningPeriod);
        }
      }
    }
    /**
     * Does a step and returns the increment value.
     * @returns the increment value
     */
    doStep() {
      this.acceleration += 2;
      const increment = this.acceleration > 8 ? this.options.bigIncrement : this.options.increment;
      if (this.acceleration <= 2) {
        this.update();
      }
      return increment;
    }
    /** Pauses the update loop */
    pause() {
      this.isPaused = true;
    }
    /** Resumes the update loop */
    resume() {
      this.isPaused = false;
      this.acceleration = 0;
    }
  };
  var FlightPlanPredictorStore = class {
    /**
     * Ctor
     *
     * @param bus           the event bus
     * @param flightPlanner a flight planner
     * @param planIndexSub  a subscribable regarding the index of the flight plan we want to predict for
     */
    constructor(bus, flightPlanner, planIndexSub) {
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.planIndexSub = planIndexSub;
      this.activeLegSubject = Subject.create(null);
      this.ppos = ConsumerSubject.create(null, new LatLongAlt());
      this.groundSpeed = ConsumerSubject.create(null, 150);
      this.altitude = ConsumerSubject.create(null, -1);
      this.fuelTotalQuantity = ConsumerSubject.create(null, 0);
      this.fuelFlow = ConsumerSubject.create(null, 0);
      this.fuelWeight = ConsumerSubject.create(null, 0);
      this.lnavDtg = ConsumerSubject.create(null, 0);
      this.unixSimTime = ConsumerSubject.create(null, 0);
      const sub = this.bus.getSubscriber();
      this.ppos.setConsumer(sub.on("gps-position").atFrequency(1));
      this.groundSpeed.setConsumer(sub.on("ground_speed"));
      this.altitude.setConsumer(sub.on("pressure_alt"));
      this.fuelFlow.setConsumer(sub.on("fuel_flow_total"));
      this.fuelTotalQuantity.setConsumer(sub.on("fuel_total"));
      this.fuelWeight.setConsumer(sub.on("fuel_weight_per_gallon"));
      this.lnavDtg.setConsumer(sub.on("lnavdata_waypoint_distance"));
      this.unixSimTime.setConsumer(sub.on("simTime"));
      sub.on("fplActiveLegChange").handle((data) => {
        if (data.planIndex === this.planIndexSub.get()) {
          this.handleNewActiveLeg();
        }
      });
      sub.on("fplCopied").handle((data) => {
        if (data.planIndex === this.planIndexSub.get()) {
          this.handleNewActiveLeg();
        }
      });
    }
    /**
     * Handles the active leg changing
     */
    handleNewActiveLeg() {
      const plan = this.flightPlanner.getFlightPlan(this.planIndexSub.get());
      const activeLegIndex = plan.activeLateralLeg;
      const activeLeg = plan.tryGetLeg(activeLegIndex);
      this.activeLegSubject.set(activeLeg);
    }
  };
  var FlightPlanPredictorUtils = class {
    /**
     * noop
     */
    constructor() {
    }
    /**
     * Predicts time to fly a distance at a ground speed
     *
     * @param gs       the GPS ground speed in knots
     * @param distance the distance in nautical miles
     *
     * @returns the predicted time in seconds duration
     */
    static predictTime(gs, distance) {
      return UnitType.HOUR.convertTo(distance / gs, UnitType.SECOND);
    }
    /**
     * Predicts fuel usage to fly a distance at a ground speed with a fuel flow and weight
     *
     * @param gs         the GPS ground speed in knots
     * @param distance   the distance in nautical miles
     * @param fuelFlow   the total fuel flow in gallons per hour
     * @param fuelWeight the fuel weight in pounds per gallon
     *
     * @returns the predicted fuel usage in pounds
     */
    static predictFuelUsage(gs, distance, fuelFlow, fuelWeight) {
      const fuelVolumeUsed = UnitType.SECOND.convertTo(FlightPlanPredictorUtils.predictTime(gs, distance), UnitType.HOUR) * fuelFlow;
      return fuelVolumeUsed * fuelWeight;
    }
  };
  var FlightPlanPredictor = class {
    /**
     * Ctor
     *
     * @param bus               the event bus
     * @param flightPlanner     a flight planner
     * @param planIndexSub      a subscribable regarding the index of the flight plan we want to predict for
     * @param activeLegIndexSub a subscribable regarding the index of the displayed active leg, specific to the avionics suite
     * @param config            configuration object
     */
    constructor(bus, flightPlanner, planIndexSub, activeLegIndexSub, config) {
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.planIndexSub = planIndexSub;
      this.activeLegIndexSub = activeLegIndexSub;
      this.config = config;
      this.predictions = [];
      this.facilityPredictions = /* @__PURE__ */ new Map();
      this.store = new FlightPlanPredictorStore(this.bus, this.flightPlanner, this.planIndexSub);
    }
    /**
     * Whether the flight plan exists and has an active lateral leg index >= 1
     *
     * @returns boolean
     */
    get planAndPredictionsValid() {
      if (this.flightPlanner.hasFlightPlan(this.planIndexSub.get()) && this.isAllLegsCalculated()) {
        return this.activeLegIndex >= 1;
      }
      return false;
    }
    /**
     * Obtains the flight plan to predict
     *
     * @returns a flight plan
     */
    get plan() {
      return this.flightPlanner.getFlightPlan(this.planIndexSub.get());
    }
    /**
     * Returns the active leg index to be used
     *
     * @returns the index
     */
    get activeLegIndex() {
      return this.activeLegIndexSub.get();
    }
    /**
     * Checks if all legs in the plan are calculated
     * @returns true if all legs are calculated, false otherwise
     */
    isAllLegsCalculated() {
      for (const leg of this.plan.legs(false, this.activeLegIndex)) {
        if (!leg.calculated) {
          return false;
        }
      }
      return true;
    }
    /**
     * Updates the predictor
     */
    update() {
      if (!this.planAndPredictionsValid) {
        this.clearOutValues();
        return;
      }
      const activeLegIndex = this.activeLegIndex;
      const prevLegIndex = activeLegIndex - 1;
      if (!this.plan.tryGetLeg(prevLegIndex)) {
        return;
      }
      let accumulatedDistance = this.store.lnavDtg.get();
      let maxIndex = -1;
      let lastNonDiscontinuityLeg = void 0;
      for (const [i, leg, previousLeg] of this.predictableLegs()) {
        maxIndex = i;
        if ((previousLeg === null || previousLeg === void 0 ? void 0 : previousLeg.leg.type) === LegType.Discontinuity || (previousLeg === null || previousLeg === void 0 ? void 0 : previousLeg.leg.type) === LegType.ThruDiscontinuity) {
          if (lastNonDiscontinuityLeg !== void 0 && lastNonDiscontinuityLeg.calculated && leg.calculated) {
            const termLat = lastNonDiscontinuityLeg.calculated.endLat;
            const termLon = lastNonDiscontinuityLeg.calculated.endLon;
            const startLat = leg.calculated.endLat;
            const startLon = leg.calculated.endLon;
            if (termLat && termLon && startLat && startLon) {
              const gaRadDistance = new GeoPoint(termLat, termLon).distance(new GeoPoint(startLat, startLon));
              accumulatedDistance += UnitType.NMILE.convertFrom(gaRadDistance, UnitType.GA_RADIAN);
            }
          }
        }
        lastNonDiscontinuityLeg = leg;
        const isPassedLeg = i < activeLegIndex;
        const isActiveLeg = i === activeLegIndex;
        const isUpcomingLeg = i > activeLegIndex;
        const oldPredictions = this.predictionsForLegIndex(i);
        if (oldPredictions) {
          if (isPassedLeg) {
            if (oldPredictions.kind === "activeOrUpcoming") {
              this.stampPassedLegValues(oldPredictions);
            }
            this.updatePassedLeg(oldPredictions, leg);
          } else if (isActiveLeg) {
            this.updateActiveLeg(oldPredictions);
          } else {
            this.updateUpcomingLeg(oldPredictions, leg, accumulatedDistance);
          }
          if (isActiveLeg || isUpcomingLeg) {
            accumulatedDistance += oldPredictions.distance - accumulatedDistance;
          }
        } else {
          const newPredictions = {};
          if (isPassedLeg) {
            this.updatePassedLeg(newPredictions, leg);
          } else if (isActiveLeg) {
            this.updateActiveLeg(newPredictions);
          } else {
            this.updateUpcomingLeg(newPredictions, leg, accumulatedDistance);
          }
          if (isActiveLeg || isUpcomingLeg) {
            accumulatedDistance += newPredictions.distance - accumulatedDistance;
          }
          this.predictions[i] = newPredictions;
        }
      }
      if (maxIndex > 0) {
        for (let i = maxIndex; i < this.predictions.length - 1; i++) {
          this.predictions.pop();
        }
      }
      this.clearOutDirtyValues();
    }
    /**
     * Clears out values from predictions
     *
     * @private
     */
    clearOutValues() {
      this.predictions.length = 0;
    }
    /**
     * Clears out entries that have become discontinuities
     */
    clearOutDirtyValues() {
      for (let i = 0; i < this.plan.length; i++) {
        const leg = this.plan.getLeg(i);
        if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
          this.predictions.splice(i, 1, void 0);
        }
      }
    }
    /**
     * Finds the index of the destination leg, in other words, the last non-missed-approach leg.
     *
     * @returns the index, or -1 if not applicable
     */
    findDestinationLegIndex() {
      let lastLegIndex = this.plan.length - 1;
      for (const leg of this.plan.legs(true)) {
        if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
          break;
        }
        lastLegIndex--;
      }
      return lastLegIndex < 1 ? -1 : lastLegIndex;
    }
    /**
     * Iterator for existing predictions
     *
     * @param startAtIndex the index to start at
     *
     * @returns a generator
     *
     * @yields predictions
     */
    *iteratePredictions(startAtIndex = 0) {
      for (let i = startAtIndex; i < this.predictions.length; i++) {
        yield this.predictions[i];
      }
    }
    /**
     * Returns predictions for the destination airport.
     *
     * If the dest leg (defined as the last leg that is not part of the missed approach) is not a runway,
     * then the direct distance between the termination of that leg and the provided airport facility is added to
     * the result. Otherwise, the prediction to that leg is used.
     *
     * @param destinationFacility the airport facility to use in case a direct distance needs to be calculated
     *
     * @returns predictions for the destination airport, or null if they cannot be computed
     */
    getDestinationPrediction(destinationFacility) {
      var _a, _b, _c, _d, _e;
      const destLegIndex = this.findDestinationLegIndex();
      const leg = this.plan.tryGetLeg(destLegIndex);
      if (!leg) {
        return this.getPposToFacilityPredictions(destinationFacility);
      }
      const destLegHasValidFixIcao = leg.leg.fixIcao && leg.leg.fixIcao !== ICAO.emptyIcao;
      const isDestLegRunway = destLegHasValidFixIcao ? ICAO.getFacilityType(leg.leg.fixIcao) === FacilityType.RWY : false;
      if (!isDestLegRunway && ((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && leg.calculated.endLon) {
        const legTerm = new GeoPoint((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.endLat, (_c = leg.calculated) === null || _c === void 0 ? void 0 : _c.endLon);
        const airport = new GeoPoint(destinationFacility.lat, destinationFacility.lon);
        const additionalDirectDistance = UnitType.GA_RADIAN.convertTo(legTerm.distance(airport), UnitType.NMILE);
        const predictionsToDestLeg = this.predictionsForLegIndex(destLegIndex);
        if (predictionsToDestLeg) {
          const directPredictions = {
            kind: "activeOrUpcoming",
            ident: "",
            distance: additionalDirectDistance,
            estimatedTimeOfArrival: 0,
            estimatedTimeEnroute: 0,
            fob: 0
          };
          this.predictForDistance(directPredictions, additionalDirectDistance);
          directPredictions.estimatedTimeEnroute = FlightPlanPredictorUtils.predictTime(this.currentGs(), additionalDirectDistance);
          const fuelConsumedOnDirect = Math.max(0, this.currentFuelWeight() - ((_d = directPredictions.fob) !== null && _d !== void 0 ? _d : 0));
          return {
            kind: "activeOrUpcoming",
            ident: ICAO.getIdent(destinationFacility.icao),
            estimatedTimeOfArrival: predictionsToDestLeg.estimatedTimeOfArrival + directPredictions.estimatedTimeEnroute,
            estimatedTimeEnroute: predictionsToDestLeg.estimatedTimeEnroute + directPredictions.estimatedTimeEnroute,
            distance: predictionsToDestLeg.distance + additionalDirectDistance,
            fob: Math.max(0, ((_e = predictionsToDestLeg.fob) !== null && _e !== void 0 ? _e : this.currentFuelWeight()) - fuelConsumedOnDirect)
          };
        } else {
          return null;
        }
      } else {
        const predictionsForLegIndex = this.predictionsForLegIndex(destLegIndex);
        if (predictionsForLegIndex) {
          return Object.assign(Object.assign({}, predictionsForLegIndex), { ident: ICAO.getIdent(destinationFacility.icao) });
        } else {
          return null;
        }
      }
    }
    /**
     * Returns predictions for an arbitrary facility.
     *
     * The distance used for predictions is the great circle distance between PPOS and the given facility.
     *
     * @param facility the facility to use
     *
     * @returns predictions for the facility
     */
    getPposToFacilityPredictions(facility) {
      const ppos = this.store.ppos.get();
      const distance = new GeoPoint(ppos.lat, ppos.long).distance({ lat: facility.lat, lon: facility.lon });
      const distanceNM = UnitType.NMILE.convertFrom(distance, UnitType.GA_RADIAN);
      const existingPredictions = this.facilityPredictions.get(facility.icao);
      let predictions;
      if (existingPredictions) {
        predictions = existingPredictions;
      } else {
        predictions = {
          kind: "activeOrUpcoming",
          ident: ICAO.getIdent(facility.icao),
          distance: distanceNM,
          estimatedTimeOfArrival: 0,
          estimatedTimeEnroute: 0,
          fob: 0
        };
      }
      this.predictForDistance(predictions, distanceNM);
      return predictions;
    }
    /**
     * Returns active or upcoming predictions for a given leg index
     *
     * @param index the leg index
     *
     * @returns the predictions object, or null if they cannot be computed
     */
    predictionsForLegIndex(index) {
      return this.predictions[index];
    }
    /**
     * Returns active or upcoming predictions for a given leg definition
     *
     * @param leg the leg
     *
     * @returns the predictions object, or null if they cannot be computed
     */
    predictionsForLeg(leg) {
      const index = this.plan.getLegIndexFromLeg(leg);
      if (index === -1) {
        return null;
      }
      return this.predictionsForLegIndex(index);
    }
    /**
     * Applies active or upcoming predictions for a given distance, outputting the result in the {@link out} argument
     *
     * @param distance the distance
     * @param out      the object in which to output the predictions
     */
    applyPredictionsForDistance(distance, out) {
      this.predictForDistance(out, distance);
    }
    /**
     * Whether the leg at an index is predicted
     *
     * @param legIndex the target leg index
     *
     * @returns boolean
     */
    isLegIndexPredicted(legIndex) {
      return !!this.predictions[legIndex];
    }
    /**
     * Whether the leg is predicted
     *
     * @param leg the target leg
     *
     * @returns boolean
     */
    isLegPredicted(leg) {
      const index = this.plan.getLegIndexFromLeg(leg);
      return !!this.predictions[index];
    }
    /**
     * Returns the previous index for which a prediction exists. **Note: this will force an update to happen.**
     *
     * @param legIndex the leg index to start at
     *
     * @returns the index, or -1 if none is found
     */
    findPreviousPredictedLegIndex(legIndex) {
      this.update();
      for (let i = legIndex - 1; i >= 0; i--) {
        const isPredicted = this.isLegIndexPredicted(i);
        if (isPredicted) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Returns the previous index for which a prediction exists. **Note: this will force an update to happen.**
     *
     * @param legIndex the leg index to start at
     *
     * @returns the index, or -1 if none is found
     */
    findNextPredictedLegIndex(legIndex) {
      this.update();
      for (let i = legIndex + 1; i < this.predictions.length; i++) {
        const isPredicted = this.isLegIndexPredicted(i);
        if (isPredicted) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Applies a reducer function to the predictions of active and upcoming legs
     *
     * @param initialValue initial accumulator value
     * @param reducer      reducer function
     * @param upTo         index to reduce to
     *
     * @returns reduced value
     */
    reducePredictions(initialValue, reducer, upTo = -1) {
      const limit = upTo === -1 ? this.predictions.length : upTo;
      let accumulator = initialValue;
      for (const [i] of this.predictableLegs(true)) {
        if (i > limit) {
          break;
        }
        const predictions = this.predictionsForLegIndex(i);
        accumulator = reducer(accumulator, predictions);
      }
      return accumulator;
    }
    /**
     * Generator of all predictable legs in the plan
     *
     * The yielded tuple contains the following:
     * - 0: leg index in flight plan
     * - 1: leg definition object
     * - 2: previous leg definition object, including a previous discontinuity
     *
     * @param onlyAfterActive whether to start at the active leg
     *
     * @returns generator that skips appropriate legs
     *
     * @yields legs including and after the active leg that are not discontinuities (and not in missed approach, if config asks so)
     */
    *predictableLegs(onlyAfterActive = false) {
      let prevLeg = void 0;
      for (let i = onlyAfterActive ? this.activeLegIndex + 1 : 0; i < this.plan.length; i++) {
        const leg = this.plan.getLeg(i);
        if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
          prevLeg = leg;
          continue;
        }
        if (leg.leg.type === LegType.IF && BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
          prevLeg = leg;
          continue;
        }
        if (!this.config.predictMissedApproachLegs && BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
          break;
        }
        yield [i, leg, prevLeg];
        prevLeg = leg;
      }
    }
    /**
     * Stamps the actual values from the last estimated values
     *
     * @param targetObject the object to stamp the actual values on
     *
     * @private
     */
    stampPassedLegValues(targetObject) {
      targetObject.actualFob = targetObject.fob;
      targetObject.actualTimeEnroute = targetObject.estimatedTimeEnroute;
      targetObject.actualTimeOfArrival = targetObject.estimatedTimeOfArrival;
      targetObject.actualAltitude = this.store.altitude.get();
    }
    /**
     * Creates predictions for a passed leg
     *
     * @param targetObject the object to apply the predictions to
     * @param leg          the leg
     *
     * @throws if calculated is undefined
     */
    updatePassedLeg(targetObject, leg) {
      var _a;
      if (!leg.calculated || !leg.calculated.endLat || !leg.calculated.endLon) {
        return;
      }
      const term = new GeoPoint(leg.calculated.endLat, leg.calculated.endLon);
      const ppos = this.store.ppos.get();
      const distance = term.distance(new GeoPoint(ppos.lat, ppos.long));
      targetObject.kind = "passed";
      targetObject.ident = (_a = leg.name) !== null && _a !== void 0 ? _a : "n/a";
      targetObject.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.NMILE);
    }
    /**
     * Computes predictions for the active leg
     *
     * @param targetObject the object to apply the predictions to
     *
     * @throws if no active leg in flight plan
     */
    updateActiveLeg(targetObject) {
      var _a;
      const distance = this.store.lnavDtg.get();
      const leg = this.plan.tryGetLeg(this.activeLegIndex);
      if (!leg) {
        return;
      }
      targetObject.kind = "activeOrUpcoming";
      targetObject.ident = (_a = leg.name) !== null && _a !== void 0 ? _a : "n/a";
      targetObject.distance = distance;
      this.predictForDistance(targetObject, distance);
    }
    /**
     * Creates predictions for an upcoming leg
     *
     * @param targetObject        the object to apply the predictions to
     * @param leg                 the leg
     * @param accumulatedDistance accumulated distance in previous predictions before this leg
     */
    updateUpcomingLeg(targetObject, leg, accumulatedDistance) {
      var _a, _b;
      if (!leg.calculated) {
        return;
      }
      const ownDistance = UnitType.METER.convertTo((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions, UnitType.NMILE);
      const distance = accumulatedDistance + ownDistance;
      targetObject.kind = "activeOrUpcoming";
      targetObject.ident = (_b = leg.name) !== null && _b !== void 0 ? _b : "n/a";
      targetObject.distance = distance;
      this.predictForDistance(targetObject, distance);
    }
    /**
     * Predicts performance over a distance
     *
     * @param targetObject        the object to apply the predictions to
     * @param distance            the distance flown
     */
    predictForDistance(targetObject, distance) {
      const estimatedTimeEnroute = FlightPlanPredictorUtils.predictTime(this.currentGs(), distance);
      const timeToDistance = FlightPlanPredictorUtils.predictTime(this.currentGs(), distance);
      const unixSeconds = UnitType.MILLISECOND.convertTo(this.store.unixSimTime.get(), UnitType.SECOND);
      const utcSeconds = unixSeconds % (3600 * 24);
      const estimatedTimeOfArrival = utcSeconds + timeToDistance;
      const fob = Math.max(0, this.currentFuelWeight() - FlightPlanPredictorUtils.predictFuelUsage(this.currentGs(), distance, this.store.fuelFlow.get(), this.store.fuelWeight.get()));
      targetObject.estimatedTimeEnroute = estimatedTimeEnroute;
      targetObject.estimatedTimeOfArrival = estimatedTimeOfArrival;
      targetObject.fob = fob;
    }
    /**
     * Obtains current GS with a minimum of 150
     *
     * @returns knots
     */
    currentGs() {
      return Math.max(this.config.minimumPredictionsGroundSpeed, this.store.groundSpeed.get());
    }
    /**
     * Obtains current fuel weight
     *
     * @returns pounds
     */
    currentFuelWeight() {
      return this.store.fuelTotalQuantity.get() * this.store.fuelWeight.get();
    }
  };
  var ResourceModerator = class {
    /**
     * Constructor.
     * @param resource This resource controlled by this moderator.
     */
    constructor(resource) {
      this.resource = resource;
      this.pendingConsumer = null;
      this.assignedConsumer = null;
      this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    /**
     * Makes a claim to this moderator's resource. If the resource is not currently owned, or the claiming consumer has
     * a higher priority than the current owner, access will attempt to pass to the claiming consumer. Otherwise, the
     * claiming consumer will enter a queue. After entering the queue, a consumer will gain access to the claimed
     * resource when all other consumers with a higher priority forfeit their claims to the resource.
     * @param consumer The consumer claiming the resource.
     */
    claim(consumer) {
      var _a;
      const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
      if (consumerToDisplace === consumer) {
        return;
      }
      if (this.queuedConsumers.has(consumer)) {
        return;
      }
      if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
        if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
          if (consumerToDisplace) {
            this.queuedConsumers.insert(consumerToDisplace);
            this.pendingConsumer = null;
          }
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        }
        this.assignedConsumer = null;
        this.pendingConsumer = consumer;
        this.queuedConsumers.insert(consumerToDisplace);
        consumerToDisplace.onCeded(this.resource);
        if (this.pendingConsumer === consumer) {
          this.pendingConsumer = null;
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        } else {
          return;
        }
      }
      this.queuedConsumers.insert(consumer);
    }
    /**
     * Forfeits a claim to this moderator's resource. If the consumer forfeiting its claim is the current owner of the
     * resource, it will immediately lose access to the resource, and access will attempt to pass to the next-highest
     * priority consumer with a claim to the resource. Otherwise, the forfeiting consumer will be removed from the queue
     * to gain access to the resource.
     * @param consumer The consumer that is forfeiting its claim.
     */
    forfeit(consumer) {
      var _a;
      if (this.pendingConsumer === consumer) {
        this.pendingConsumer = null;
        return;
      }
      if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
        this.queuedConsumers.remove(consumer);
        return;
      }
      const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
      this.pendingConsumer = next;
      this.assignedConsumer = null;
      consumer.onCeded(this.resource);
      if (next !== null && this.pendingConsumer === next) {
        this.pendingConsumer = null;
        this.assignedConsumer = next;
        this.assignedConsumer.onAcquired(this.resource);
      }
    }
  };
  var AuralAlertRegistrationManager = class {
    /**
     * Creates a new instance of AuralAlertRegistrationManager.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.registrations = /* @__PURE__ */ new Map();
      this.publisher = bus.getPublisher();
      const subscriber = bus.getSubscriber();
      this.requestSub = subscriber.on("aural_alert_request_all_registrations").handle(this.publishAllRegistrations.bind(this));
    }
    /**
     * Registers an aural alert.
     * @param definition The definition of the alert to register.
     */
    register(definition) {
      this.registrations.set(definition.uuid, definition);
      this.publishRegistration(definition);
    }
    /**
     * Publishes a registration event for an alert.
     * @param definition The definition of the alert to register.
     */
    publishRegistration(definition) {
      this.publisher.pub("aural_alert_register", definition, true);
    }
    /**
     * Publishes registration events for all currently registered alerts.
     */
    publishAllRegistrations() {
      for (const definition of this.registrations.values()) {
        this.publishRegistration(definition);
      }
    }
    /**
     * Destroys this manager.
     */
    destroy() {
      this.requestSub.destroy();
    }
  };
  var AuralAlertSystem = class {
    /**
     * Creates a new AuralAlertSystem. The system is asleep when created.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.bus = bus;
      this.soundServerSub = this.bus.getSubscriber();
      this.controlSub = this.bus.getSubscriber();
      this.soundServerPublisher = this.bus.getPublisher();
      this.publisher = this.bus.getPublisher();
      this.registeredAlerts = /* @__PURE__ */ new Map();
      this.queueToPacketKeyMap = /* @__PURE__ */ new Map();
      this.packetKeyToQueueMap = /* @__PURE__ */ new Map();
      this.queues = /* @__PURE__ */ new Map();
      this.playing = /* @__PURE__ */ new Map();
      this.activeAliasToUuid = /* @__PURE__ */ new Map();
      this.triggeredAliasToUuid = /* @__PURE__ */ new Map();
      this.activeSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToActiveSuffixedIds = /* @__PURE__ */ new Map();
      this.triggeredSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToTriggeredSuffixedIds = /* @__PURE__ */ new Map();
      this.activeAlerts = /* @__PURE__ */ new Map();
      this.triggeredAlerts = /* @__PURE__ */ new Map();
      this.isSoundServerInit = false;
      this.isAwake = false;
      this.controlSub.on("aural_alert_register").handle(this.onAlertRegistered.bind(this));
      this.publisher.pub("aural_alert_request_all_registrations", void 0, true, false);
      this.soundServerSub.on("sound_server_packet_ended").handle(this.onPacketEnded.bind(this));
      this.controlSub.on("aural_alert_activate").handle(this.activateAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate").handle(this.deactivateAlert.bind(this));
      this.controlSub.on("aural_alert_trigger").handle(this.triggerAlert.bind(this));
      this.controlSub.on("aural_alert_untrigger").handle(this.untriggerAlert.bind(this));
      this.controlSub.on("aural_alert_kill").handle(this.killAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate_all").handle(this.deactivateAllAlerts.bind(this));
      this.controlSub.on("aural_alert_untrigger_all").handle(this.untriggerAllAlerts.bind(this));
      this.controlSub.on("aural_alert_kill_all").handle(this.killAllAlerts.bind(this));
      Wait.awaitConsumer(this.soundServerSub.on("sound_server_initialized"), (init) => init, true).then(() => {
        this.isSoundServerInit = true;
        for (const queue of this.queues.values()) {
          this.dequeueAlert(queue);
        }
      });
    }
    /**
     * Wakes this system. All active continuous alerts will be re-queued to play. While this system is awake, activation
     * of alerts will queue them to be played. Activation of any alerts that were already active when the system woke up
     * will not queue them to be played unless the alert was deactivated in the interim.
     */
    wake() {
      if (this.isAwake) {
        return;
      }
      this.isAwake = true;
      for (const alert of this.activeAlerts.values()) {
        if (alert.repeat || alert.packet.continuous) {
          this.queueAlert(alert);
        }
      }
    }
    /**
     * Puts this system to sleep. Clears all triggered and queued alerts and stops all currently playing alerts at the
     * earliest opportunity. While this system is asleep, activating alerts will not queue them to be played and
     * triggering alerts has no effect.
     */
    sleep() {
      if (!this.isAwake) {
        return;
      }
      this.isAwake = false;
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const queueEntry of this.queues.values()) {
        queueEntry.queue.clear();
      }
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    /**
     * Responds to when an alert is registered.
     * @param alert The definition of the registered alert.
     */
    onAlertRegistered(alert) {
      this.registeredAlerts.set(alert.uuid, alert);
      !this.queues.has(alert.queue) && this.createQueue(alert.queue);
    }
    /**
     * Creates an alert queue entry.
     * @param queueName The name of the queue to create.
     * @returns The new queue entry.
     */
    createQueue(queueName) {
      const entry = {
        queue: new BinaryHeap(AuralAlertSystem.ALERT_COMPARATOR),
        debounceTimer: new DebounceTimer()
      };
      this.queues.set(queueName, entry);
      const packetKey = AuralAlertSystem.createPacketKey(queueName);
      this.queueToPacketKeyMap.set(queueName, packetKey);
      this.packetKeyToQueueMap.set(packetKey, queueName);
      return entry;
    }
    /**
     * Checks if an alias is unique. An alias is considered unique if and only if it does not match any registered
     * alert IDs and it does not match any active or triggered aliases assigned to other parent IDs.
     * @param uuid The parent ID of the alias.
     * @param alias The alias to check.
     * @returns Whether the specified alias is unique.
     */
    isAliasUnique(uuid, alias) {
      if (this.registeredAlerts.has(alias)) {
        return false;
      }
      const existingActive = this.activeAliasToUuid.get(alias);
      if (existingActive !== void 0 && existingActive !== uuid) {
        return false;
      }
      const existingTriggered = this.triggeredAliasToUuid.get(alias);
      if (existingTriggered !== void 0 && existingTriggered !== uuid) {
        return false;
      }
      return true;
    }
    /**
     * Checks if a suffixed ID is unique. A suffixed ID is considered unique if and only if it does not match any
     * registered alert IDs or aliases and it does not match any active or triggered suffixed IDs assigned to other
     * parent IDs.
     * @param id The parent ID of the suffix.
     * @param suffixedId The suffixed ID to check.
     * @returns Whether the specified suffixed ID is unique.
     */
    isSuffixedIdUnique(id, suffixedId) {
      if (this.registeredAlerts.has(suffixedId) || this.activeAliasToUuid.has(suffixedId) || this.triggeredAliasToUuid.has(suffixedId)) {
        return false;
      }
      const existingActive = this.activeSuffixedIdToId.get(suffixedId);
      if (existingActive !== void 0 && existingActive !== id) {
        return false;
      }
      const existingTriggered = this.triggeredSuffixedIdToId.get(suffixedId);
      if (existingTriggered !== void 0 && existingTriggered !== id) {
        return false;
      }
      return true;
    }
    /**
     * Activates an alert.
     * @param activation The ID of the alert to activate, or data describing the alert to activate.
     */
    activateAlert(activation) {
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.activeAliasToUuid.set(alias, uuid);
      }
      this.activateSuffix(queuedId, suffixedId);
      if (this.activeAlerts.has(queuedId)) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.activeAlerts.set(queuedId, queuedAlert);
      if (this.isAwake) {
        this.queueAlert(queuedAlert);
      }
    }
    /**
     * Activates an alert suffix.
     * @param id The ID of the suffix's parent alert.
     * @param suffixedId The suffixed ID to activate.
     */
    activateSuffix(id, suffixedId = id) {
      this.activeSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToActiveSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    /**
     * Triggers an alert.
     * @param activation The ID of the alert to trigger, or data describing the alert to trigger.
     */
    triggerAlert(activation) {
      if (!this.isAwake) {
        return;
      }
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.triggeredAliasToUuid.set(alias, uuid);
      }
      this.triggerSuffix(queuedId, suffixedId);
      const existing = this.triggeredAlerts.get(queuedId);
      if (existing && this.playing.get(existing.definition.queue) === existing) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.triggeredAlerts.set(queuedId, queuedAlert);
      this.queueAlert(queuedAlert);
    }
    /**
     * Triggers an alert suffix.
     * @param id The ID of the suffix's parent alert.
     * @param suffixedId The suffixed ID to trigger.
     */
    triggerSuffix(id, suffixedId = id) {
      this.triggeredSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToTriggeredSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    /**
     * Creates an alert to be queued.
     * @param definition The definition of the alert.
     * @param activation Data describing the alert to activate. If not defined, the alert will be activated according
     * to its definition.
     * @returns The queued alert.
     */
    createQueuedAlert(definition, activation) {
      var _a, _b, _c, _d, _e;
      return {
        definition,
        id: (_a = activation === null || activation === void 0 ? void 0 : activation.alias) !== null && _a !== void 0 ? _a : definition.uuid,
        repeat: (_b = activation === null || activation === void 0 ? void 0 : activation.repeat) !== null && _b !== void 0 ? _b : definition.repeat,
        packet: {
          key: this.queueToPacketKeyMap.get(definition.queue),
          sequence: (_c = activation === null || activation === void 0 ? void 0 : activation.sequence) !== null && _c !== void 0 ? _c : definition.sequence,
          continuous: (_d = activation === null || activation === void 0 ? void 0 : activation.continuous) !== null && _d !== void 0 ? _d : definition.continuous,
          timeout: (_e = activation === null || activation === void 0 ? void 0 : activation.timeout) !== null && _e !== void 0 ? _e : definition.timeout
        },
        timestamp: Date.now()
      };
    }
    /**
     * Queues an alert to be played.
     * @param alert The alert to queue.
     */
    queueAlert(alert) {
      var _a;
      const queueName = alert.definition.queue;
      const queueEntry = (_a = this.queues.get(queueName)) !== null && _a !== void 0 ? _a : this.createQueue(queueName);
      queueEntry.queue.insert(alert);
      if (this.isSoundServerInit) {
        const playing = this.playing.get(queueName);
        if (!playing) {
          if (!queueEntry.debounceTimer.isPending()) {
            queueEntry.debounceTimer.schedule(this.dequeueAlert.bind(this, queueEntry), 0);
          }
        }
      }
    }
    /**
     * Dequeues the next activated or triggered alert from a queue and starts playing it. If this system is asleep, then
     * the queue will be cleared instead and no alert will be played.
     * @param entry The queue entry.
     */
    dequeueAlert(entry) {
      if (this.isAwake) {
        let next = void 0;
        while (entry.queue.size > 0) {
          next = entry.queue.removeMin();
          if (this.activeAlerts.get(next.id) === next || this.triggeredAlerts.get(next.id) === next) {
            break;
          } else {
            next = void 0;
          }
        }
        if (next) {
          this.playing.set(next.definition.queue, next);
          this.soundServerPublisher.pub("sound_server_interrupt", next.packet, true, false);
        }
      } else {
        entry.queue.clear();
      }
    }
    /**
     * Deactivates an alert. Deactivating an alert will prevent queued activated instances of it from playing. In
     * addition, if an activated instance of the alert is currently playing and is continuous, it will be prevented from
     * looping.
     * @param id The (optionally suffixed) ID of the alert to deactivate.
     */
    deactivateAlert(id) {
      var _a;
      const deactivatedId = this.deactivateSuffix(id);
      if (deactivatedId === void 0) {
        return;
      }
      const deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
      if (deactivatedUuid !== deactivatedId) {
        this.activeAliasToUuid.delete(deactivatedId);
      }
      const alertDef = this.registeredAlerts.get(deactivatedUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    /**
     * Deactivates an alert suffix.
     * @param suffixedId The suffixed ID to deactivate.
     * @returns The ID of the alert that was deactivated as a result of deactivating the suffix, or `undefined` if no
     * alert was deactivated.
     */
    deactivateSuffix(suffixedId) {
      const id = this.activeSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.activeSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.activeAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.activeAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    /**
     * Untriggers an alert. Untriggering an alert will prevent queued triggered instances of it from playing. In
     * addition, if a triggered instance of the alert is currently playing and is continuous, it will be prevented from
     * looping.
     * @param uuid The (optionally suffixed) ID of the alert to untrigger.
     */
    untriggerAlert(uuid) {
      var _a;
      const untriggeredId = this.untriggerSuffix(uuid);
      if (untriggeredId === void 0) {
        return;
      }
      const untriggeredUuid = (_a = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _a !== void 0 ? _a : untriggeredId;
      if (untriggeredUuid !== untriggeredId) {
        this.triggeredAliasToUuid.delete(untriggeredId);
      }
      const alertDef = this.registeredAlerts.get(untriggeredUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    /**
     * Untriggers an alert suffix.
     * @param suffixedId The suffixed ID to untrigger.
     * @returns The ID of the alert that was untriggered as a result of deactivating the suffix, or `undefined` if no
     * alert was untriggered.
     */
    untriggerSuffix(suffixedId) {
      const id = this.triggeredSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.triggeredSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.triggeredAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.triggeredAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    /**
     * Kills an alert. Killing an alert will deactivate and untrigger it. In addition, if the alert is currently playing,
     * it will be stopped at the earliest opportunity.
     * @param uuid The (optionally suffixed) ID of the alert to kill.
     */
    killAlert(uuid) {
      var _a, _b;
      const deactivatedId = this.deactivateSuffix(uuid);
      const untriggeredId = this.untriggerSuffix(uuid);
      let deactivatedUuid = void 0;
      let untriggeredUuid = void 0;
      if (deactivatedId !== void 0) {
        deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
        if (deactivatedUuid !== deactivatedId) {
          this.activeAliasToUuid.delete(deactivatedId);
        }
      }
      if (untriggeredId !== void 0) {
        untriggeredUuid = (_b = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _b !== void 0 ? _b : untriggeredId;
        if (untriggeredUuid !== untriggeredId) {
          this.triggeredAliasToUuid.delete(untriggeredId);
        }
      }
      const deactivatedAlertDef = deactivatedUuid === void 0 ? void 0 : this.registeredAlerts.get(deactivatedUuid);
      const untriggeredAlertDef = untriggeredUuid === void 0 ? void 0 : this.registeredAlerts.get(untriggeredUuid);
      let killedPacketKey = void 0;
      if (deactivatedAlertDef) {
        const playing = this.playing.get(deactivatedAlertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
          killedPacketKey = playing.packet.key;
        }
      }
      if (untriggeredAlertDef) {
        const playing = this.playing.get(untriggeredAlertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing && killedPacketKey !== playing.packet.key) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
        }
      }
    }
    /**
     * Deactivates all alerts. This will stop all queued activated alerts from playing and prevent all currently playing
     * activated continuous alerts from looping.
     */
    deactivateAllAlerts() {
      this.activeAlerts.clear();
      this.activeAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.triggeredAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    /**
     * Untriggers all alerts. This will stop all queued triggered alerts from playing and prevent all currently playing
     * triggered continuous alerts from looping.
     */
    untriggerAllAlerts() {
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.activeAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    /**
     * Kills all alerts. This deactivates and untriggers all alerts, stopping all queued alerts from playing and stopping
     * all currently playing alerts at the earliest opportunity.
     */
    killAllAlerts() {
      this.activeAlerts.clear();
      this.triggeredAlerts.clear();
      this.activeAliasToUuid.clear();
      this.triggeredAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    /**
     * Responds to when a sound packet stops playing.
     * @param key The key of the stopped packet.
     */
    onPacketEnded(key) {
      const queueName = this.packetKeyToQueueMap.get(key);
      if (queueName === void 0) {
        return;
      }
      const queueEntry = this.queues.get(queueName);
      if (!queueEntry) {
        this.packetKeyToQueueMap.delete(key);
        this.queueToPacketKeyMap.delete(queueName);
        return;
      }
      const finishedAlert = this.playing.get(queueName);
      if (finishedAlert) {
        if (this.triggeredAlerts.get(finishedAlert.id) === finishedAlert) {
          this.triggeredAlerts.delete(finishedAlert.id);
          if (finishedAlert.id !== finishedAlert.definition.uuid) {
            this.triggeredAliasToUuid.delete(finishedAlert.id);
          }
          const suffixedIds = this.idToTriggeredSuffixedIds.get(finishedAlert.id);
          if (suffixedIds) {
            for (const suffixedId of suffixedIds) {
              this.triggeredSuffixedIdToId.delete(suffixedId);
            }
            this.idToTriggeredSuffixedIds.delete(finishedAlert.id);
          }
        }
        if (finishedAlert.repeat && this.activeAlerts.get(finishedAlert.id) === finishedAlert) {
          this.queueAlert(finishedAlert);
        }
      }
      this.playing.delete(queueName);
      this.dequeueAlert(queueEntry);
    }
    /**
     * Creates a sound packet key for a queue.
     * @param queue The name of the queue.
     * @returns A sound packet key for the specified queue.
     */
    static createPacketKey(queue) {
      return `$$aural-alert-system-queue-${queue}$$`;
    }
  };
  AuralAlertSystem.ALERT_COMPARATOR = (a, b) => {
    const priorityDiff = b.definition.priority - a.definition.priority;
    if (priorityDiff === 0) {
      return a.timestamp - b.timestamp;
    } else {
      return priorityDiff;
    }
  };
  var CasAuralAlertTransporter = class {
    /**
     * Creates a new instance of CasAuralAlertTransporter.
     * @param bus The event bus.
     * @param auralUuid The ID of this transporter's aural alert.
     * @param auralActivation A function which generates activation data for this transporter's aural alert. If the
     * function returns `undefined` or is itself not defined, the aural alert will be activated using its default
     * registered parameters.
     * @param casUuid The ID of the CAS alert to which to bind this transporter's aural alert.
     * @param casPriority The priority level of the CAS alert to which to bind this transporter's aural alert.
     * @param casSuffix The suffix, if any, of the CAS alert to which to bind this transporter's aural alert.
     * @param includeAcknowledged Whether to activate this transporter's aural alert when the bound CAS alert is
     * acknowledged.
     * @param casSystem The CAS system. If not defined, the initialization of the aural alert's state cannot be
     * guaranteed to be correct unless the transporter is created before the CAS alert can be activated.
     * @returns A new instance of CasAuralAlertTransporter.
     */
    constructor(bus, auralUuid, auralActivation, casUuid, casPriority, casSuffix, includeAcknowledged, casSystem) {
      var _a;
      this.auralUuid = auralUuid;
      this.auralActivation = auralActivation;
      this.casUuid = casUuid;
      this.casPriority = casPriority;
      this.casSuffix = casSuffix;
      this.includeAcknowledged = includeAcknowledged;
      this.publisher = bus.getPublisher();
      const sub = bus.getSubscriber();
      if (casSystem) {
        const filter = casSuffix === void 0 ? (message) => {
          return message.uuid === casUuid && message.priority === casPriority && (message.suffixes === void 0 || message.suffixes.length === 0) && (this.includeAcknowledged || !message.acknowledged);
        } : (message) => {
          return message.uuid === casUuid && message.priority === casPriority && (message.suffixes !== void 0 && message.suffixes.includes(casSuffix)) && (this.includeAcknowledged || message.acknowledgedSuffixes !== void 0 && message.acknowledgedSuffixes.includes(casSuffix));
        };
        if (casSystem.casActiveMessageSubject.getArray().find(filter)) {
          this.publisher.pub("aural_alert_activate", (_a = this.auralActivation && this.auralActivation()) !== null && _a !== void 0 ? _a : this.auralUuid, true, false);
        }
      }
      this.subs = [
        sub.on("cas_alert_displayed").handle(this.onAlertDisplayed.bind(this)),
        sub.on("cas_alert_hidden").handle(this.onAlertHidden.bind(this))
      ];
      if (!this.includeAcknowledged) {
        this.subs.push(sub.on("cas_alert_acknowledged").handle(this.onAlertAcknowledged.bind(this)));
      }
    }
    /**
     * Responds to when a CAS alert is displayed.
     * @param alert Data describing the displayed alert.
     */
    onAlertDisplayed(alert) {
      var _a;
      if (alert.uuid === this.casUuid && alert.priority === this.casPriority && alert.suffix === this.casSuffix && (this.includeAcknowledged || !alert.acknowledged)) {
        this.publisher.pub("aural_alert_activate", (_a = this.auralActivation && this.auralActivation()) !== null && _a !== void 0 ? _a : this.auralUuid, true, false);
      }
    }
    /**
     * Responds to when a CAS alert is hidden.
     * @param alert Data describing the hidden alert.
     */
    onAlertHidden(alert) {
      if (alert.uuid === this.casUuid && alert.priority === this.casPriority && alert.suffix === this.casSuffix) {
        this.publisher.pub("aural_alert_deactivate", this.auralUuid, true, false);
      }
    }
    /**
     * Responds to when a CAS alert is acknowledged.
     * @param alert Data describing the acknowledged alert.
     */
    onAlertAcknowledged(alert) {
      if (alert.uuid === this.casUuid && alert.priority === this.casPriority && alert.suffix === this.casSuffix) {
        this.publisher.pub("aural_alert_deactivate", this.auralUuid, true, false);
      }
    }
    /**
     * Destroys this transporter. Once destroyed, it will no longer automatically manage the state of its aural alert.
     */
    destroy() {
      this.subs.forEach((sub) => {
        sub.destroy();
      });
    }
    /**
     * Creates a new instance of CasAuralAlertTransporter, which will automatically activate and deactivate an aural
     * alert based on whether a bound CAS alert is being displayed as a message.
     * @param bus The event bus.
     * @param auralUuid The ID of the transporter's aural alert.
     * @param auralActivation A function which generates activation data for the transporter's aural alert. If the
     * function returns `undefined` or is itself not defined, the aural alert will be activated using its default
     * registered parameters.
     * @param casUuid The ID of the CAS alert to which to bind the transporter's aural alert.
     * @param casPriority The priority level of the CAS alert to which to bind the transporter's aural alert.
     * @param casSuffix The suffix, if any, of the CAS alert to which to bind the transporter's aural alert.
     * @param includeAcknowledged Whether to activate the transporter's aural alert when the bound CAS alert is
     * acknowledged.
     * @param casSystem The CAS system. If not defined, the transporter should be created before its bound CAS alert
     * can be activated. Otherwise the initialization of the aural alert's state cannot be guaranteed to be correct.
     * @returns A new instance of CasAuralAlertTransporter.
     */
    static create(bus, auralUuid, auralActivation, casUuid, casPriority, casSuffix, includeAcknowledged, casSystem) {
      return new CasAuralAlertTransporter(bus, auralUuid, auralActivation, casUuid, casPriority, casSuffix, includeAcknowledged, casSystem);
    }
  };
  var DefaultXmlAuralAlertParser = class {
    /**
     * Creates a new instance of DefaultXmlAuralAlertParser.
     * @param baseInstrument The BaseInstrument.
     * @param defaultQueue The default queue to assign alerts if they do not explicitly define one themselves.
     */
    constructor(baseInstrument, defaultQueue) {
      this.baseInstrument = baseInstrument;
      this.defaultQueue = defaultQueue;
    }
    /** @inheritdoc */
    parse(root) {
      const results = [];
      for (const defElement of root.querySelectorAll(":scope>Alert")) {
        const def = this.parseAlertDefinition(this.baseInstrument, defElement);
        if (def) {
          results.push(def);
        }
      }
      return results;
    }
    /**
     * Parses a single alert definition.
     * @param baseInstrument The BaseInstrument.
     * @param element The element defining the alert.
     * @returns The definition specified by the element, or `undefined` if one could not be parsed.
     */
    parseAlertDefinition(baseInstrument, element) {
      var _a, _b, _c;
      const uuid = element.getAttribute("uuid");
      if (uuid === null || uuid.length === 0) {
        console.warn('AuralAlertSystemXmlAdapter: alert is missing "uuid" attribute. Discarding alert.');
        return void 0;
      }
      let queue = element.getAttribute("queue");
      if (queue === null || queue.length === 0) {
        queue = this.defaultQueue;
      }
      let priority;
      const priorityText = element.getAttribute("priority");
      if (priorityText) {
        priority = Number(priorityText);
        if (isNaN(priority)) {
          console.warn('AuralAlertSystemXmlAdapter: unrecognized alert "priority" attribute (must be a number). Defaulting to 0.');
          priority = 0;
        }
      } else {
        priority = 0;
      }
      const sequence = this.parseSequence(element.querySelector(":scope>Sequence"));
      if (!sequence || sequence.length === 0) {
        return void 0;
      }
      let continuous;
      const continuousText = element.getAttribute("continuous");
      switch (continuousText === null || continuousText === void 0 ? void 0 : continuousText.toLowerCase()) {
        case "true":
          continuous = true;
          break;
        case "false":
        case void 0:
          continuous = false;
          break;
        default:
          console.warn('AuralAlertSystemXmlAdapter: unrecognized alert "continuous" attribute (must be a boolean). Defaulting to false.');
          continuous = false;
      }
      let repeat;
      const repeatText = element.getAttribute("requeue");
      switch (repeatText === null || repeatText === void 0 ? void 0 : repeatText.toLowerCase()) {
        case "true":
          repeat = true;
          break;
        case "false":
        case void 0:
          repeat = false;
          break;
        default:
          console.warn('AuralAlertSystemXmlAdapter: unrecognized alert "repeat" attribute (must be a boolean). Defaulting to false.');
          repeat = false;
      }
      let logic = void 0;
      const conditionElement = element.querySelector(":scope>Condition");
      if (conditionElement) {
        logic = new CompositeLogicXMLElement(baseInstrument, conditionElement);
      }
      if (logic) {
        return {
          type: "logic",
          uuid,
          queue,
          priority,
          sequence,
          continuous,
          repeat,
          logic
        };
      } else {
        const casElement = element.querySelector(":scope>CAS");
        if (casElement) {
          const casUuid = casElement.getAttribute("uuid");
          if (casUuid === null || casUuid.length === 0) {
            console.warn('AuralAlertSystemXmlAdapter: alert CAS tag is missing "uuid" attribute. Discarding alert.');
            return void 0;
          }
          let casPriority;
          switch ((_a = casElement.getAttribute("type")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {
            case "warning":
              casPriority = AnnunciationType.Warning;
              break;
            case "caution":
              casPriority = AnnunciationType.Caution;
              break;
            case "advisory":
              casPriority = AnnunciationType.Advisory;
              break;
            case "safeop":
              casPriority = AnnunciationType.SafeOp;
              break;
            default:
              console.warn('AuralAlertSystemXmlAdapter: alert CAS tag has missing or unrecognized "type" attribute. Discarding alert.');
              return void 0;
          }
          let casSuffix = (_b = casElement.getAttribute("suffix")) !== null && _b !== void 0 ? _b : void 0;
          if (casSuffix && casSuffix.length === 0) {
            casSuffix = void 0;
          }
          let casIncludeAcknowledged;
          switch ((_c = casElement.getAttribute("acknowledged")) === null || _c === void 0 ? void 0 : _c.toLowerCase()) {
            case "true":
              casIncludeAcknowledged = true;
              break;
            case "false":
              casIncludeAcknowledged = false;
              break;
            default:
              console.warn('AuralAlertSystemXmlAdapter: alert CAS tag has missing or unrecognized "acknowledged" attribute. Discarding alert.');
              return void 0;
          }
          return {
            type: "cas",
            uuid,
            queue,
            priority,
            sequence,
            continuous,
            repeat,
            casUuid,
            casPriority,
            casSuffix,
            casIncludeAcknowledged
          };
        } else {
          console.warn("AuralAlertSystemXmlAdapter: alert is missing both Condition and CAS child tags. Discarding alert.");
          return void 0;
        }
      }
    }
    /**
     * Parses a sound atom sequence.
     * @param element The element defining the sequence.
     * @returns The sound atom sequence defined by the element, or `undefined` if one could not be parsed.
     */
    parseSequence(element) {
      var _a;
      return (_a = element === null || element === void 0 ? void 0 : element.textContent) === null || _a === void 0 ? void 0 : _a.split(",").map((str) => str.trim()).filter((str) => str.length > 0);
    }
  };
  var AuralAlertSystemXmlAdapter = class {
    /**
     * Creates a new instance of AuralAlertSystemXmlAdapter.
     * @param bus The event bus.
     * @param logicHost The XML logic host used to run this adapter's XML logic.
     * @param casSystem The CAS system.
     * @param alertDefsRoot The root XML document element containing the aural alert definitions to use.
     * @param parser The parser to use to parse alert definitions from the XML document.
     */
    constructor(bus, logicHost, casSystem, alertDefsRoot, parser) {
      this.bus = bus;
      this.logicHost = logicHost;
      this.casSystem = casSystem;
      this.publisher = this.bus.getPublisher();
      if (alertDefsRoot === null) {
        return;
      }
      const defs = parser.parse(alertDefsRoot);
      if (defs.length === 0) {
        return;
      }
      this.alertDefinitions = defs;
      this.auralRegistrationManager = new AuralAlertRegistrationManager(bus);
    }
    /**
     * Registers this adapter's alerts with {@link AuralAlertSystem} and starts automatically managing alert states.
     * This method should be called before
     */
    start() {
      if (!this.auralRegistrationManager || !this.alertDefinitions) {
        return;
      }
      for (const def of this.alertDefinitions) {
        this.auralRegistrationManager.register({
          uuid: def.uuid,
          queue: def.queue,
          priority: def.priority,
          sequence: def.sequence,
          continuous: def.continuous,
          repeat: def.repeat
        });
        if (def.type === "logic") {
          this.logicHost.addLogicAsNumber(def.logic, (value) => {
            if (value === 0) {
              this.publisher.pub("aural_alert_deactivate", def.uuid, true, false);
            } else {
              this.publisher.pub("aural_alert_activate", def.uuid, true, false);
            }
          }, 0);
        } else {
          CasAuralAlertTransporter.create(this.bus, def.uuid, void 0, def.casUuid, def.casPriority, def.casSuffix, def.casIncludeAcknowledged, this.casSystem);
        }
      }
    }
  };
  var SoundServer = class {
    /**
     * Creates a new instance of SoundServer.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.bus = bus;
      this.controlSub = this.bus.getSubscriber();
      this.publisher = this.bus.getPublisher();
      this.active = /* @__PURE__ */ new Map();
      this.queued = /* @__PURE__ */ new Map();
      this.publisher.pub("sound_server_initialized", false, true, true);
      this.init();
    }
    /**
     * Waits until the sim has entered the in-game state and initializes this server. Once initialized, this server will
     * respond to commands over the event bus.
     */
    async init() {
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      await Wait.awaitDelay(500);
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      this.controlSub.on("sound_server_play").handle(this.playPacket.bind(this));
      this.controlSub.on("sound_server_queue").handle(this.queuePacket.bind(this));
      this.controlSub.on("sound_server_interrupt").handle(this.interruptPacket.bind(this));
      this.controlSub.on("sound_server_stop").handle(this.stopPacket.bind(this));
      this.controlSub.on("sound_server_kill").handle(this.killPacket.bind(this));
      this.controlSub.on("sound_server_stop_all").handle(this.stopAllPackets.bind(this));
      this.controlSub.on("sound_server_kill_all").handle(this.killAllPackets.bind(this));
      this.controlSub.on("sound_server_play_sound").handle(this.playSound.bind(this));
      this.controlSub.on("sound_server_start_sound").handle(this.startSound.bind(this));
      this.controlSub.on("sound_server_stop_sound").handle(this.stopPacket.bind(this));
      this.publisher.pub("sound_server_initialized", true, true, true);
    }
    /**
     * A callback method that responds to when the sim notifies the JS instrument that a sound file has stopped playing.
     * This method needs to be manually called for `SoundServer` to function properly.
     * @param id The ID of the sound file that stopped playing.
     */
    onSoundEnd(id) {
      const activeEntries = Array.from(this.active.values());
      for (let i = 0; i < activeEntries.length; i++) {
        const entry = activeEntries[i];
        const entrySoundPlaying = entry.sequence[entry.currentIndexPlaying];
        if (!entrySoundPlaying) {
          this.cleanupPacket(entry);
        } else if (Name_Z.compare(entrySoundPlaying, id)) {
          this.advancePacket(entry);
        }
      }
    }
    /**
     * Plays a sound packet if and only if there is no currently playing packet with the same key.
     * @param packet The packet to play.
     */
    playPacket(packet) {
      if (!this.active.get(packet.key)) {
        this.queuePacket(packet);
      }
    }
    /**
     * Plays a sound packet at the earliest opportunity. If there is no currently playing packet with the same key, it
     * will begin playing immediately. Otherwise, all queued packets with the same key are cleared, the existing packet
     * will be stopped the next time one of its sound atoms finishes playing, and the new packet will begin playing at
     * that time.
     * @param packet The packet to play.
     */
    interruptPacket(packet) {
      const active = this.active.get(packet.key);
      if (active) {
        active.alive = false;
      }
      this.queued.delete(packet.key);
      this.queuePacket(packet);
    }
    /**
     * Queues a sound packet. The queued packet will immediately start playing if there is no currently playing packet
     * with the same key. Otherwise it will be queued to play once all currently playing and previously queued packets
     * with the same key have finished playing.
     * @param packet The packet to queue.
     */
    queuePacket(packet) {
      var _a;
      const sequence = SoundServer.getSoundSequence(packet);
      const entry = {
        key: packet.key,
        sequence,
        continuous: packet.continuous,
        currentIndexPlaying: 0,
        timeout: (_a = packet.timeout) !== null && _a !== void 0 ? _a : SoundServer.DEFAULT_TIMEOUT,
        alive: true,
        timer: new DebounceTimer(),
        timeoutCallback: () => {
          this.cleanupPacket(entry);
        }
      };
      if (this.active.get(packet.key)) {
        let queue = this.queued.get(entry.key);
        if (!queue) {
          this.queued.set(entry.key, queue = []);
        }
        queue.push(entry);
      } else {
        this.startPacket(entry);
      }
    }
    /**
     * Stops a continuous packet from looping the next time its sequence finishes and clears any packets queued behind
     * it.
     * @param key The key of the packet to stop.
     */
    stopPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.continuous = false;
      }
    }
    /**
     * Stops a packet from playing the next time one of its sound atoms finishes playing and clears any packets queued
     * behind it.
     * @param key The key of the packet to kill.
     */
    killPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.alive = false;
      }
    }
    /**
     * Stops all currently playing continuous packets from looping the next time their sequences finish and clears all
     * queued packets.
     */
    stopAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.continuous = false;
      }
    }
    /**
     * Stops all packets from playing the next time one of their sound atoms finishes playing and clears all queued
     * packets.
     */
    killAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.alive = false;
      }
    }
    /**
     * Plays a non-continuous sound packet consisting of a single sound atom and whose key matches the ID of the sound
     * atom.
     * @param id The ID of the sound atom to play.
     */
    playSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: false });
    }
    /**
     * Plays a continuous sound packet consisting of a single sound atom and whose key matches the ID of the sound atom.
     * @param id The ID of the sound atom to play.
     */
    startSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: true });
    }
    /**
     * Starts playing a packet from the beginning of its sequence.
     * @param entry The entry of the packet to start playing.
     */
    startPacket(entry) {
      this.active.set(entry.key, entry);
      this.publisher.pub("sound_server_packet_started", entry.key, true, false);
      if (entry.sequence.length === 0) {
        this.cleanupPacket(entry);
      } else {
        Coherent.call("PLAY_INSTRUMENT_SOUND", entry.sequence[0].originalStr);
        entry.currentIndexPlaying = 0;
        entry.timer.schedule(entry.timeoutCallback, entry.timeout);
      }
    }
    /**
     * Attempts to advance a packet to the next sound atom in its sequence. If the end of the sequence is reached, the
     * packet will loop to the beginning if it is continuous. Otherwise it will finish playing.
     * @param entry The entry of the packet to advance.
     */
    advancePacket(entry) {
      if (!entry.alive) {
        this.cleanupPacket(entry);
        return;
      }
      let nextSoundToPlayIndex = entry.currentIndexPlaying + 1;
      if (nextSoundToPlayIndex >= entry.sequence.length) {
        if (entry.continuous) {
          nextSoundToPlayIndex = 0;
          entry.timer.schedule(entry.timeoutCallback, entry.timeout);
        } else {
          this.cleanupPacket(entry);
          return;
        }
      }
      const soundToPlay = entry.sequence[nextSoundToPlayIndex];
      Coherent.call("PLAY_INSTRUMENT_SOUND", soundToPlay.originalStr);
      entry.currentIndexPlaying = nextSoundToPlayIndex;
    }
    /**
     * Finishes playing a packet and automatically starts playing the packet queued behind the finished packet, if one
     * exists.
     * @param entry The entry of the packet to finish.
     */
    cleanupPacket(entry) {
      entry.alive = false;
      entry.timer.clear();
      const deleted = this.active.delete(entry.key);
      if (!deleted) {
        return;
      }
      this.publisher.pub("sound_server_packet_ended", entry.key, true, false);
      const queue = this.queued.get(entry.key);
      if (queue) {
        const next = queue.shift();
        if (queue.length === 0) {
          this.queued.delete(entry.key);
        }
        if (next) {
          this.startPacket(next);
        }
      }
    }
    /**
     * Gets a sound atom sequence as an array of `Name_Z` objects from a sound packet.
     * @param packet The packet defining the sound atom sequence.
     * @returns The sound atom sequence defined by a packet, as an array of `Name_Z` objects.
     */
    static getSoundSequence(packet) {
      const sequence = [];
      if (typeof packet.sequence === "string") {
        if (packet.sequence !== "") {
          sequence.push(new Name_Z(packet.sequence));
        }
      } else {
        for (let i = 0; i < packet.sequence.length; i++) {
          if (packet.sequence[i] !== "") {
            sequence.push(new Name_Z(packet.sequence[i]));
          }
        }
      }
      return sequence;
    }
  };
  SoundServer.DEFAULT_TIMEOUT = 1e4;
  var SoundServerController = class {
    /**
     * Creates a new instance of SoundServerController.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.publisher = bus.getPublisher();
      this.subscriber = bus.getSubscriber();
    }
    /**
     * Waits for the sound server to finish initialization.
     * @returns A Promise which fulfills with a value of `true` when the sound server finishes initialization.
     */
    awaitInitialized() {
      return Wait.awaitConsumer(this.subscriber.on("sound_server_initialized"), (init) => init, true);
    }
    /**
     * Requests a sound packet to be played if there is no existing packet with the same key currently being played.
     * @param packet The sound packet to play.
     */
    play(packet) {
      this.publisher.pub("sound_server_play", packet, true, false);
    }
    /**
     * Requests a sound packet to be queued. If there is no existing packet with the same key currently being played, the
     * packet will begin playing immediately. Otherwise, the new packet will begin playing after the existing packet and
     * any other queued packets with the same key are finished playing.
     * @param packet The sound packet to queue.
     */
    queue(packet) {
      this.publisher.pub("sound_server_queue", packet, true, false);
    }
    /**
     * Requests a sound packet to be played at the earliest opportunity. If there is no existing packet with the same key
     * currently being played, the packet will begin playing immediately. Otherwise, the existing packet will be stopped
     * the next time one of its sound atoms finishes playing, any queued packets with the same key will be discarded, and
     * the new packet will begin playing at that time.
     * @param packet The sound packet to play.
     */
    interrupt(packet) {
      this.publisher.pub("sound_server_interrupt", packet, true, false);
    }
    /**
     * Requests that a continuous sound packet stop playing instead of looping the next time its sequence finishes. This
     * also prevents any queued packets with the same key from
     * playing.
     * @param key The key of the sound packet to stop.
     */
    stop(key) {
      this.publisher.pub("sound_server_stop", key, true, false);
    }
    /**
     * Requests that a sound packet stop playing at the earliest opportunity (the next time one of its sound atoms
     * finishes playing). This also prevents any queued packets with the same key from playing.
     * @param key The key of the sound packet to kill.
     */
    kill(key) {
      this.publisher.pub("sound_server_kill", key, true, false);
    }
    /**
     * Requests that all currently playing continuous sound packets stop playing instead of looping the next time their
     * sequences finish. This also clears all queued packets.
     */
    stopAll() {
      this.publisher.pub("sound_server_stop_all", void 0, true, false);
    }
    /**
     * Requests that all currently playing sound packets stop playing at the earliest opportunity (the next time one of
     * their sound atoms finishes playing). This also clears all queued packets.
     */
    killAll() {
      this.publisher.pub("sound_server_kill_all", void 0, true, false);
    }
    /**
     * Requests a single sound atom to be played non-continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: false })`.
     * @param id The ID of the sound atom to play.
     */
    playSound(id) {
      this.publisher.pub("sound_server_play_sound", id, true, false);
    }
    /**
     * Requests a single sound atom to be played continuously. Calling this method is an alias for calling
     * `play({ key: id, sequence: id, continuous: true })`.
     * @param id The ID of the sound atom to play.
     */
    startSound(id) {
      this.publisher.pub("sound_server_start_sound", id, true, false);
    }
  };
  var StringUtils = class {
    /**
     * Replaces all `'0'` characters in a string with the slashed zero character.
     * @param text The string to convert.
     * @returns A string identical to the input string except with all `'0'` characters converted to the slashed zero
     * character.
     */
    static useZeroSlash(text) {
      return text === null || text === void 0 ? void 0 : text.replace(StringUtils.ZERO_REGEX, "0\u0338");
    }
    /**
     * Removes leading whitespace and line terminator characters from a string.
     * @param str The string to trim.
     * @returns A new string representing `str` with all leading whitespace and line terminator characters removed.
     */
    static trimStart(str) {
      return str.replace(StringUtils.TRIM_START_REGEX, "");
    }
    /**
     * Removes trailing whitespace and line terminator characters from a string.
     * @param str The string to trim.
     * @returns A new string representing `str` with all trailing whitespace and line terminator characters removed.
     */
    static trimEnd(str) {
      return str.replace(StringUtils.TRIM_END_REGEX, "");
    }
  };
  StringUtils.DIRECT_TO = "\xD0";
  StringUtils.DEGREE = "\xB0";
  StringUtils.EN_DASH = "\u2013";
  StringUtils.ZERO_REGEX = /0/g;
  StringUtils.TRIM_START_REGEX = /^\s+/;
  StringUtils.TRIM_END_REGEX = /\s+$/;
  var UUID = class {
    /**
     * A function to generate a spec-compliand v4 UUID in a 32-bit safe way.
     * @returns A UUID in standard 8-4-4-4-12 notation.
     */
    static GenerateUuid() {
      const scale = 2 ** 32;
      const first = UUID.bytesToHexString(Math.random() * scale);
      const fourth = UUID.bytesToHexString(Math.random() * scale);
      let secondBits = Math.random() * scale;
      let thirdBits = Math.random() * scale;
      secondBits |= 16384;
      secondBits &= 4294922239;
      const second = UUID.bytesToHexString(secondBits);
      thirdBits |= 2147483648;
      thirdBits &= 3221225471;
      const third = UUID.bytesToHexString(thirdBits);
      return `${first}-${second.substring(0, 4)}-${second.substring(4)}-${third.substring(0, 4)}-${third.substring(4)}${fourth}`;
    }
    /**
     * Take a number and return its hexadecimal representation.
     * @param bits The bytes to format.
     * @returns The input bits as a hexadecimal string.
     */
    static bytesToHexString(bits) {
      let string = (bits >>> 0).toString(16);
      string = "00000000".substring(string.length) + string;
      return string;
    }
  };
  var AnnunciationType;
  (function(AnnunciationType2) {
    AnnunciationType2[AnnunciationType2["Warning"] = 0] = "Warning";
    AnnunciationType2[AnnunciationType2["Caution"] = 1] = "Caution";
    AnnunciationType2[AnnunciationType2["Advisory"] = 2] = "Advisory";
    AnnunciationType2[AnnunciationType2["SafeOp"] = 3] = "SafeOp";
  })(AnnunciationType || (AnnunciationType = {}));
  var Annunciation = class {
    /**
     * Creates an instance of Annunciation.
     * @param type The type of annuniciaton this is.
     * @param text The text label to show.
     * @param condition The logic condition for setting it.
     * @param suffix Any suffix text to past to the end.
     * @param uuid A preset UUID, or one will be generated.
     */
    constructor(type, text, condition, suffix, uuid) {
      this.type = type;
      this.text = text;
      this.condition = condition;
      this.suffix = suffix;
      this.uuid = uuid !== null && uuid !== void 0 ? uuid : UUID.GenerateUuid();
    }
  };
  var XMLAnnunciationFactory = class {
    /**
     * Create an XMLAnnunciationFactory.
     * @param instrument The instrument that holds this engine display.
     */
    constructor(instrument) {
      this.instrument = instrument;
    }
    /**
     * Parse an panel.xml configuration
     * @param document The configuration as an XML document.
     * @returns An array of Annunciations.
     */
    parseConfig(document2) {
      const annunciations = new Array();
      const configs = document2.getElementsByTagName("Annunciations");
      if (configs.length == 0) {
        return annunciations;
      }
      const config = configs[0];
      for (const ann of config.children) {
        let type;
        let suffix;
        const uuid = UUID.GenerateUuid();
        const typeElem = ann.getElementsByTagName("Type");
        if (typeElem.length == 0) {
          continue;
        }
        switch (typeElem[0].textContent) {
          case "Warning":
            type = AnnunciationType.Warning;
            break;
          case "Caution":
            type = AnnunciationType.Caution;
            break;
          case "Advisory":
            type = AnnunciationType.Advisory;
            break;
          case "SafeOp":
            type = AnnunciationType.SafeOp;
            break;
          default:
            continue;
        }
        const textElem = ann.getElementsByTagName("Text");
        if (textElem.length == 0 || textElem[0].textContent == null) {
          continue;
        }
        const text = textElem[0].textContent;
        const condElem = ann.getElementsByTagName("Condition");
        if (condElem.length == 0) {
          continue;
        }
        for (const condition of condElem) {
          const logic = new CompositeLogicXMLElement(this.instrument, condition);
          const suffElem = condition.getAttribute("Suffix");
          if (suffElem !== null) {
            suffix = suffElem;
          } else {
            suffix = void 0;
          }
          annunciations.push(new Annunciation(type, text, logic, suffix, uuid));
        }
      }
      return annunciations;
    }
  };
  var RenderPosition;
  (function(RenderPosition2) {
    RenderPosition2[RenderPosition2["Before"] = 0] = "Before";
    RenderPosition2[RenderPosition2["After"] = 1] = "After";
    RenderPosition2[RenderPosition2["In"] = 2] = "In";
  })(RenderPosition || (RenderPosition = {}));
  var DisplayComponent = class {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
      this.context = void 0;
      this.contextType = void 0;
      this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() {
      return;
    }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) {
      return;
    }
    /**
     * Destroys this component.
     */
    destroy() {
      return;
    }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
      if (this.context !== void 0 && this.contextType !== void 0) {
        const index = this.contextType.indexOf(context);
        return this.context[index];
      }
      throw new Error("Could not find the provided context type.");
    }
  };
  var ComponentProps = class {
  };
  var NodeReference = class {
    constructor() {
      this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
      if (this._instance !== null) {
        return this._instance;
      }
      throw new Error("Instance was null.");
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
      this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
      return this._instance;
    }
  };
  var Context = class {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
      this.defaultValue = defaultValue;
      this.Provider = (props) => new ContextProvider(props, this);
    }
  };
  var ContextProvider = class extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
      super(props);
      this.parent = parent;
    }
    /** @inheritdoc */
    render() {
      var _a;
      const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
      return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
  };
  var FSComponent;
  (function(FSComponent2) {
    const svgTags = {
      "circle": true,
      "clipPath": true,
      "color-profile": true,
      "cursor": true,
      "defs": true,
      "desc": true,
      "ellipse": true,
      "g": true,
      "image": true,
      "line": true,
      "linearGradient": true,
      "marker": true,
      "mask": true,
      "path": true,
      "pattern": true,
      "polygon": true,
      "polyline": true,
      "radialGradient": true,
      "rect": true,
      "stop": true,
      "svg": true,
      "text": true
    };
    function Fragment2(props) {
      return props.children;
    }
    FSComponent2.Fragment = Fragment2;
    function buildComponent(type, props, ...children) {
      let vnode = null;
      if (typeof type === "string") {
        let element;
        if (svgTags[type] !== void 0) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
        if (props !== null) {
          for (const key in props) {
            if (key === "ref" && props.ref !== void 0) {
              props.ref.instance = element;
            } else {
              const prop = props[key];
              if (key === "class" && typeof prop === "object" && "isSubscribableSet" in prop) {
                prop.sub((set, eventType, modifiedKey) => {
                  if (eventType === SubscribableSetEventType.Added) {
                    element.classList.add(modifiedKey);
                  } else {
                    element.classList.remove(modifiedKey);
                  }
                }, true);
              } else if (typeof prop === "object" && "isSubscribable" in prop) {
                if (key === "style" && prop instanceof ObjectSubject) {
                  prop.sub((v, style, newValue) => {
                    element.style.setProperty(style.toString(), newValue);
                  }, true);
                } else {
                  prop.sub((v) => {
                    element.setAttribute(key, v);
                  }, true);
                }
              } else {
                element.setAttribute(key, prop);
              }
            }
          }
        }
        vnode = {
          instance: element,
          props,
          children: null
        };
        vnode.children = createChildNodes(vnode, children);
      } else if (typeof type === "function") {
        if (children !== null && props === null) {
          props = {
            children
          };
        } else if (props !== null) {
          props.children = children;
        }
        if (typeof type === "function" && type.name === Fragment2.name) {
          let childNodes = type(props);
          while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
            childNodes = childNodes[0];
          }
          vnode = {
            instance: null,
            props,
            children: childNodes
          };
        } else {
          let instance;
          const pluginSystem = window._pluginSystem;
          try {
            instance = type(props);
          } catch (_a) {
            let pluginInstance = void 0;
            if (pluginSystem !== void 0) {
              pluginInstance = pluginSystem.onComponentCreating(type, props);
            }
            if (pluginInstance !== void 0) {
              instance = pluginInstance;
            } else {
              instance = new type(props);
            }
          }
          if (props !== null && props.ref !== null && props.ref !== void 0) {
            props.ref.instance = instance;
          }
          if (instance.contextType !== void 0) {
            instance.context = instance.contextType.map((c) => Subject.create(c.defaultValue));
          }
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentCreated(instance);
          }
          vnode = {
            instance,
            props,
            children: [instance.render()]
          };
        }
      }
      return vnode;
    }
    FSComponent2.buildComponent = buildComponent;
    function createChildNodes(parent, children) {
      let vnodes = null;
      if (children !== null && children !== void 0 && children.length > 0) {
        vnodes = [];
        for (const child of children) {
          if (child !== null) {
            if (child instanceof Array) {
              const arrayNodes = createChildNodes(parent, child);
              if (arrayNodes !== null) {
                vnodes.push(...arrayNodes);
              }
            } else if (typeof child === "object") {
              if ("isSubscribable" in child) {
                const node = {
                  instance: child,
                  children: null,
                  props: null,
                  root: void 0
                };
                child.sub((v) => {
                  if (node.root !== void 0) {
                    node.root.nodeValue = v === "" || v === null || v === void 0 ? " " : v.toString();
                  }
                });
                vnodes.push(node);
              } else {
                vnodes.push(child);
              }
            } else if (typeof child === "string" || typeof child === "number") {
              vnodes.push(createStaticContentNode(child));
            }
          }
        }
      }
      return vnodes;
    }
    FSComponent2.createChildNodes = createChildNodes;
    function createStaticContentNode(content) {
      return {
        instance: content,
        children: null,
        props: null
      };
    }
    FSComponent2.createStaticContentNode = createStaticContentNode;
    function render(node, element, position = RenderPosition.In) {
      if (node.children && node.children.length > 0 && element !== null) {
        const componentInstance = node.instance;
        if (componentInstance !== null && componentInstance.onBeforeRender !== void 0) {
          componentInstance.onBeforeRender();
        }
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
          insertNode(node, position, element);
        } else {
          if (position === RenderPosition.After) {
            for (let i = node.children.length - 1; i >= 0; i--) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          } else {
            for (let i = 0; i < node.children.length; i++) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          }
        }
        const instance = node.instance;
        if (instance instanceof ContextProvider) {
          visitNodes(node, (n) => {
            if (n === void 0 || n === null) {
              return false;
            }
            const nodeInstance = n.instance;
            if (nodeInstance !== null && nodeInstance.contextType !== void 0) {
              const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
              if (contextSlot >= 0) {
                if (nodeInstance.context === void 0) {
                  nodeInstance.context = [];
                }
                nodeInstance.context[contextSlot].set(instance.props.value);
              }
              if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                return true;
              }
            }
            return false;
          });
        }
        if (componentInstance !== null && componentInstance.onAfterRender !== void 0) {
          const pluginSystem = window._pluginSystem;
          componentInstance.onAfterRender(node);
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentRendered(node);
          }
        }
      }
    }
    FSComponent2.render = render;
    function insertNode(node, position, element) {
      var _a, _b, _c, _d, _e, _f;
      if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
        switch (position) {
          case RenderPosition.In:
            element.appendChild(node.instance);
            node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentElement("beforebegin", node.instance);
            node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentElement("afterend", node.instance);
            node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : void 0;
            break;
        }
        if (node.children !== null) {
          for (const child of node.children) {
            insertNode(child, RenderPosition.In, node.instance);
          }
        }
      } else if (typeof node.instance === "string" || typeof node.instance === "object" && node.instance !== null && "isSubscribable" in node.instance) {
        let toRender;
        if (typeof node.instance === "string") {
          toRender = node.instance;
        } else {
          toRender = node.instance.get();
          if (toRender === "") {
            toRender = " ";
          }
        }
        switch (position) {
          case RenderPosition.In:
            element.insertAdjacentHTML("beforeend", toRender);
            node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentHTML("beforebegin", toRender);
            node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentHTML("afterend", toRender);
            node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : void 0;
            break;
        }
      } else if (Array.isArray(node)) {
        if (position === RenderPosition.After) {
          for (let i = node.length - 1; i >= 0; i--) {
            render(node[i], element, position);
          }
        } else {
          for (let i = 0; i < node.length; i++) {
            render(node[i], element, position);
          }
        }
      } else {
        render(node, element, position);
      }
    }
    function renderBefore(node, element) {
      render(node, element, RenderPosition.Before);
    }
    FSComponent2.renderBefore = renderBefore;
    function renderAfter(node, element) {
      render(node, element, RenderPosition.After);
    }
    FSComponent2.renderAfter = renderAfter;
    function remove(element) {
      if (element !== null) {
        element.remove();
      }
    }
    FSComponent2.remove = remove;
    function createRef() {
      return new NodeReference();
    }
    FSComponent2.createRef = createRef;
    function createContext(defaultValue) {
      return new Context(defaultValue);
    }
    FSComponent2.createContext = createContext;
    function visitNodes(node, visitor) {
      if (node === void 0 || node === null) {
        return;
      }
      const stopVisitation = visitor(node);
      if (!stopVisitation && node.children !== void 0 && node.children !== null) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (Array.isArray(child)) {
            for (let childIndex = 0; childIndex < child.length; childIndex++) {
              visitNodes(child[childIndex], visitor);
            }
          } else {
            visitNodes(child, visitor);
          }
        }
      }
      return;
    }
    FSComponent2.visitNodes = visitNodes;
    function parseCssClassesFromString(classString, filter) {
      return classString.split(" ").filter((str) => str !== "" && (filter === void 0 || filter(str)));
    }
    FSComponent2.parseCssClassesFromString = parseCssClassesFromString;
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
      const reservedClassSet = new Set(reservedClasses);
      if (reservedClassSet.size === 0) {
        return classesToSubscribe.sub((set, type, key) => {
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      } else {
        return classesToSubscribe.sub((set, type, key) => {
          if (reservedClassSet.has(key)) {
            return;
          }
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      }
    }
    FSComponent2.bindCssClassSet = bindCssClassSet;
    function shallowDestroy(root) {
      FSComponent2.visitNodes(root, (node) => {
        if (node !== root && node.instance instanceof DisplayComponent) {
          node.instance.destroy();
          return true;
        }
        return false;
      });
    }
    FSComponent2.shallowDestroy = shallowDestroy;
    FSComponent2.EmptyHandler = () => {
      return;
    };
  })(FSComponent || (FSComponent = {}));
  var PluginSystem = class {
    /**
     * Ctor
     */
    constructor() {
      this.scripts = [];
      this.plugins = [];
      this.creatingHandlers = [];
      this.createdHandlers = [];
      this.renderedHandlers = [];
      this.initViewListenerPromise = new Promise((resolve) => {
        this.pluginViewListener = RegisterViewListener("JS_LISTENER_PLUGINS", () => {
          resolve();
        });
      });
    }
    /**
     * Adds plugin scripts to load to the system.
     * @param document The panel.xml document to load scripts from.
     * @param instrumentId The ID of the instrument.
     * @param globalPluginTargetFunc A function that returns true if a global plugin should be loaded.
     * @example
     * await this.pluginSystem.addScripts(this.instrument.xmlConfig, this.instrument.templateID, (target) => {
     *   return target === this.instrument.templateID;
     * });
     */
    async addScripts(document2, instrumentId, globalPluginTargetFunc) {
      let pluginTags = void 0;
      await this.initViewListenerPromise;
      if (typeof PluginsListener !== "undefined") {
        if (this.pluginViewListener !== void 0) {
          const pluginsResp = await this.pluginViewListener.call("GET_PLUGINS");
          const globalPlugins = pluginsResp;
          for (let i = 0; i < globalPlugins.plugins.length; i++) {
            const plugin = globalPlugins.plugins[i];
            if (globalPluginTargetFunc(plugin.target) === true) {
              const scriptUri = plugin.path;
              if (scriptUri !== null) {
                this.scripts.push(scriptUri);
              }
            }
          }
        }
      }
      const instrumentConfigs = document2.getElementsByTagName("Instrument");
      for (let i = 0; i < instrumentConfigs.length; i++) {
        const el = instrumentConfigs.item(i);
        if (el !== null) {
          const nameEl = el.getElementsByTagName("Name");
          if (nameEl.length > 0 && nameEl[0].textContent === instrumentId) {
            pluginTags = el.getElementsByTagName("Plugin");
          }
        }
      }
      if (pluginTags !== void 0) {
        for (let i = 0; i < pluginTags.length; i++) {
          const scriptUri = pluginTags[i].textContent;
          if (scriptUri !== null) {
            this.scripts.push(scriptUri);
          }
        }
      }
    }
    /**
     * Starts the plugin system with the included avionics specific plugin binder.
     * @param binder The plugin binder to pass to the individual plugins.
     */
    async startSystem(binder) {
      window._pluginSystem = this;
      this.binder = binder;
      const loadPromises = [];
      for (const script of this.scripts) {
        const scriptTag = document.createElement("script");
        scriptTag.src = script;
        scriptTag.async = false;
        document.head.append(scriptTag);
        loadPromises.push(new Promise((resolve, reject) => {
          scriptTag.onload = () => resolve();
          scriptTag.onerror = (ev) => reject(ev);
        }).catch((e) => console.error(e)));
      }
      await Promise.all(loadPromises).then(() => {
        for (const plugin of this.plugins) {
          plugin.onInstalled();
        }
      });
    }
    /**
     * Adds a plugin to the plugin system.
     * @param plugin The plugin to add.
     */
    addPlugin(plugin) {
      this.plugins.push(plugin);
    }
    /**
     * Runs the provided function on all of the registered plugins.
     * @param fun The function to run.
     */
    callPlugins(fun) {
      for (const plugin of this.plugins) {
        fun(plugin);
      }
    }
    /**
     * Subscribes a handler to the component creating hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentCreating(handler) {
      this.creatingHandlers.push(handler);
    }
    /**
     * A hook that allows plugins to replace components that are about to be created with their own implementations.
     * @param constructor The display component constructor that is going to be used.
     * @param props The component props that will be passed into the component.
     * @returns Returns either the display component that will replace, or undefined if the component should not be replaced.
     */
    onComponentCreating(constructor, props) {
      let component = void 0;
      for (let i = 0; i < this.creatingHandlers.length; i++) {
        component = this.creatingHandlers[i](constructor, props);
        if (component !== void 0) {
          return component;
        }
      }
      return void 0;
    }
    /**
     * Subscribes a handler to the component created hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentCreated(handler) {
      this.createdHandlers.push(handler);
    }
    /**
     * A hook that allows plugins to observe components as they are created.
     * @param component The component that was created.
     */
    onComponentCreated(component) {
      for (let i = 0; i < this.creatingHandlers.length; i++) {
        this.createdHandlers[i](component);
      }
    }
    /**
     * Subscribes a handler to the component rendered hook.
     * @param handler The handler to subscribe.
     */
    subscribeOnComponentRendered(handler) {
      this.renderedHandlers.push(handler);
    }
    /**
     * A hook that allows plugins to observe built VNodes after they are rendered.
     * @param node The node that was rendered.
     */
    onComponentRendered(node) {
      for (let i = 0; i < this.creatingHandlers.length; i++) {
        this.renderedHandlers[i](node);
      }
    }
  };
  var AvionicsPlugin = class {
    /**
     * Creates an instance of a Plugin.
     * @param binder The avionics specific plugin binder to accept from the system.
     */
    constructor(binder) {
      this.binder = binder;
    }
    /**
     * Loads a CSS file into the instrument.
     * @param uri The URI to the CSS file.
     */
    async loadCss(uri) {
      const linkTag = document.createElement("link");
      linkTag.rel = "stylesheet";
      linkTag.href = uri;
      document.head.append(linkTag);
      return new Promise((resolve) => {
        linkTag.onload = () => resolve();
      });
    }
  };
  function registerPlugin(plugin) {
    const pluginSystem = window._pluginSystem;
    if (pluginSystem.binder !== void 0) {
      const instance = new plugin(pluginSystem.binder);
      pluginSystem.addPlugin(instance);
      if (instance.onComponentCreating !== void 0) {
        pluginSystem.subscribeOnComponentCreating(instance.onComponentCreating);
      }
      if (instance.onComponentCreated !== void 0) {
        pluginSystem.subscribeOnComponentCreated(instance.onComponentCreated);
      }
      if (instance.onComponentRendered !== void 0) {
        pluginSystem.subscribeOnComponentRendered(instance.onComponentRendered);
      }
    }
  }
  var Fragment = FSComponent.Fragment;
  var BingComponent = class extends DisplayComponent {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
      this.isListenerRegistered = false;
      this.imgRef = FSComponent.createRef();
      this.uid = 0;
      this._isBound = false;
      this._isAwake = true;
      this.isDestroyed = false;
      this.pos = new LatLong(0, 0);
      this.radius = 10;
      this.resolution = (_a = this.props.resolution) !== null && _a !== void 0 ? _a : Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION));
      this.earthColors = (_b = this.props.earthColors) !== null && _b !== void 0 ? _b : ArraySubject.create(ArrayUtils.create(2, () => BingComponent.hexaToRGBColor("#000000")));
      this.earthColorsElevationRange = (_c = this.props.earthColorsElevationRange) !== null && _c !== void 0 ? _c : Vec2Subject.create(Vec2Math.create(0, 3e4));
      this.skyColor = (_d = this.props.skyColor) !== null && _d !== void 0 ? _d : Subject.create(BingComponent.hexaToRGBColor("#000000"));
      this.reference = (_e = this.props.reference) !== null && _e !== void 0 ? _e : Subject.create(EBingReference.SEA);
      this.wxrMode = (_f = this.props.wxrMode) !== null && _f !== void 0 ? _f : Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 });
      this.wxrColors = (_g = this.props.wxrColors) !== null && _g !== void 0 ? _g : ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this.isoLines = (_h = this.props.isoLines) !== null && _h !== void 0 ? _h : Subject.create(false);
      this.wxrColorsArray = [];
      this.wxrRateArray = [];
      this.resolutionHandler = (resolution) => {
        Coherent.call("SET_MAP_RESOLUTION", this.uid, resolution[0], resolution[1]);
        this.positionRadiusInhibitFramesRemaining = BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;
        if (!this.positionRadiusInhibitTimer.isPending()) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        }
      };
      this.earthColorsHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        Coherent.call("SET_MAP_HEIGHT_COLORS", this.uid, colors);
      };
      this.earthColorsElevationRangeHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        const range = this.earthColorsElevationRange.get();
        const terrainColorCount = colors.length - 1;
        const desiredElevationStep = (range[1] - range[0]) / Math.max(terrainColorCount - 1, 1);
        const requiredMin = range[0] - desiredElevationStep;
        const requiredMax = range[1] + desiredElevationStep;
        Coherent.call("SET_MAP_ALTITUDE_RANGE", this.uid, requiredMin, requiredMax);
      };
      this.skyColorHandler = (color) => {
        Coherent.call("SET_MAP_CLEAR_COLOR", this.uid, color);
      };
      this.referenceHandler = (reference) => {
        const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
        this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, flags);
      };
      this.wxrModeHandler = (wxrMode) => {
        Coherent.call("SHOW_MAP_WEATHER", this.uid, wxrMode.mode, wxrMode.arcRadians);
      };
      this.wxrColorsHandler = () => {
        const array = this.wxrColors.getArray();
        if (array.length === 0) {
          return;
        }
        this.wxrColorsArray.length = array.length;
        this.wxrRateArray.length = array.length;
        for (let i = 0; i < array.length; i++) {
          this.wxrColorsArray[i] = array[i][0];
          this.wxrRateArray[i] = array[i][1];
        }
        Coherent.call("SET_MAP_WEATHER_RADAR_COLORS", this.uid, this.wxrColorsArray, this.wxrRateArray);
      };
      this.isoLinesHandler = (showIsolines) => {
        Coherent.call("SHOW_MAP_ISOLINES", this.uid, showIsolines);
      };
      this.setCurrentMapParamsTimer = null;
      this.positionRadiusInhibitFramesRemaining = 0;
      this.isPositionRadiusPending = false;
      this.positionRadiusInhibitTimer = new DebounceTimer();
      this.processPendingPositionRadius = () => {
        if (this.isPositionRadiusPending) {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
        if (--this.positionRadiusInhibitFramesRemaining > 0) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        } else {
          this.isPositionRadiusPending = false;
        }
      };
      this.onListenerBound = (binder, uid) => {
        if (this.isDestroyed) {
          return;
        }
        if (binder.friendlyName === this.props.id) {
          this.binder = binder;
          this.uid = uid;
          if (this._isBound) {
            return;
          }
          this._isBound = true;
          Coherent.call("SHOW_MAP", uid, true);
          const pause = !this._isAwake;
          this.earthColorsSub = this.earthColors.sub(() => {
            this.earthColorsHandler();
            this.earthColorsElevationRangeHandler();
          }, true, pause);
          this.earthColorsElevationRangeSub = this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler, true, pause);
          this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true, pause);
          this.referenceSub = this.reference.sub(this.referenceHandler, true, pause);
          this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true, pause);
          this.wxrColorsSub = this.wxrColors.sub(this.wxrColorsHandler, true, pause);
          this.resolutionSub = this.resolution.sub(this.resolutionHandler, true, pause);
          this.isoLinesSub = this.isoLines.sub(this.isoLinesHandler, true, pause);
          if (this.modeFlags !== 4) {
            Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
          }
          this.props.onBoundCallback && this.props.onBoundCallback(this);
        }
      };
      this.onMapUpdate = (uid, imgSrc) => {
        if (this.binder !== void 0 && this.uid === uid && this.imgRef.instance !== null) {
          if (this.imgRef.instance.src !== imgSrc) {
            this.imgRef.instance.src = imgSrc;
          }
        }
      };
      this.setCurrentMapParams = () => {
        this.setPositionRadius(this.pos, this.radius);
      };
    }
    /**
     * Checks whether this Bing component has been bound.
     * @returns whether this Bing component has been bound.
     */
    isBound() {
      return this._isBound;
    }
    /**
     * Checks whether this Bing component is awake.
     * @returns whether this Bing component is awake.
     */
    isAwake() {
      return this._isAwake;
    }
    /** @inheritdoc */
    onAfterRender() {
      if (window["IsDestroying"]) {
        this.destroy();
        return;
      }
      const gameStateSubscribable = GameStateProvider.get();
      const gameState = gameStateSubscribable.get();
      if (gameState === GameState.briefing || gameState === GameState.ingame) {
        this.registerListener();
      } else {
        this.gameStateSub = gameStateSubscribable.sub((state) => {
          var _a;
          if (this.isDestroyed) {
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.registerListener();
          }
        });
      }
      window.addEventListener("OnDestroy", this.destroy.bind(this));
    }
    /**
     * Registers this component's Bing map listener.
     */
    registerListener() {
      var _a;
      if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
        setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
        }, this.props.delay);
      } else {
        this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
      }
    }
    /**
     * A callback called when this component's Bing map listener is registered.
     */
    onListenerRegistered() {
      if (this.isDestroyed || this.isListenerRegistered) {
        return;
      }
      this.mapListener.on("MapBinded", this.onListenerBound);
      this.mapListener.on("MapUpdated", this.onMapUpdate);
      this.isListenerRegistered = true;
      this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, this.modeFlags);
    }
    /**
     * Wakes this Bing component. Upon awakening, this component will synchronize its state from when it was put to sleep
     * to the Bing instance to which it is bound.
     */
    wake() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = true;
      if (!this._isBound) {
        return;
      }
      this.setCurrentMapParams();
      if (this.modeFlags !== 4) {
        this.setCurrentMapParamsTimer = setInterval(this.setCurrentMapParams, 200);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.resume(true);
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.resume(true);
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.resume(true);
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.resume(true);
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.resume(true);
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.resume(true);
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.resume(true);
    }
    /**
     * Puts this Bing component to sleep. While asleep, this component cannot make changes to the Bing instance to which
     * it is bound.
     */
    sleep() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = false;
      if (!this._isBound) {
        return;
      }
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.pause();
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.pause();
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.pause();
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.pause();
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.pause();
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.pause();
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.pause();
    }
    /**
     * Sets the center position and radius.
     * @param pos The center position.
     * @param radius The radius, in meters.
     */
    setPositionRadius(pos, radius) {
      this.pos = pos;
      this.radius = Math.max(radius, 10);
      if (this._isBound && this._isAwake) {
        if (this.positionRadiusInhibitFramesRemaining > 0) {
          this.isPositionRadiusPending = true;
        } else {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
      }
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("img", { ref: this.imgRef, src: "", style: "position: absolute; left: 0; top: 0; width: 100%; height: 100%;", class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      this.isDestroyed = true;
      this._isBound = false;
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.earthColorsSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.earthColorsElevationRangeSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.skyColorSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.referenceSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.wxrModeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.wxrColorsSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.resolutionSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.isoLinesSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.mapListener) === null || _k === void 0 ? void 0 : _k.off("MapBinded", this.onListenerBound);
      (_l = this.mapListener) === null || _l === void 0 ? void 0 : _l.off("MapUpdated", this.onMapUpdate);
      (_m = this.mapListener) === null || _m === void 0 ? void 0 : _m.trigger("JS_UNBIND_BINGMAP", this.props.id);
      this.isListenerRegistered = false;
      this.imgRef.instance.src = "";
      (_o = this.imgRef.instance.parentNode) === null || _o === void 0 ? void 0 : _o.removeChild(this.imgRef.instance);
      super.destroy();
    }
    /**
     * Resets the img element's src attribute.
     */
    resetImgSrc() {
      const imgRef = this.imgRef.getOrDefault();
      if (imgRef !== null) {
        const currentSrc = imgRef.src;
        imgRef.src = "";
        imgRef.src = currentSrc;
      }
    }
    /**
     * Converts an HTML hex color string to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGB value equivalent of the specified hex color string, as `R + G * 256 + B * 256^2`.
     */
    static hexaToRGBColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      return BingComponent.rgbColor(r, g, b);
    }
    /**
     * Converts a numerical RGB value to an HTML hex color string.
     * @param rgb The numerical RGB value to convert, as `R + G * 256 + B * 256^2`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGB value.
     */
    static rgbToHexaColor(rgb, poundPrefix = true) {
      const b = Math.floor(rgb % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgb % (256 * 256) / 256);
      const r = rgb % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
    }
    /**
     * Converts RGB color components to a numerical RGB value, as `R + G * 256 + B * 256^2`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @returns The numerical RGB value of the specified components, as `R + G * 256 + B * 256^2`.
     */
    static rgbColor(r, g, b) {
      return 256 * 256 * b + 256 * g + r;
    }
    /**
     * Converts an HTML hex color string to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param hexColor The hex color string to convert.
     * @returns The numerical RGBA value equivalent of the specified hex color string, as
     * `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static hexaToRGBAColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      const a = parseInt(hexStringColor.substr(6 + offset, 2), 16);
      return BingComponent.rgbaColor(r, g, b, a);
    }
    /**
     * Converts a numerical RGBA value to an HTML hex color string.
     * @param rgba The numerical RGBA value to convert, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param poundPrefix Whether to include the pound (`#`) prefix in the converted string. Defaults to `true`.
     * @returns The HTML hex color string equivalent of the specified numerical RGBA value.
     */
    static rgbaToHexaColor(rgba, poundPrefix = true) {
      const a = Math.floor(rgba % (256 * 256 * 256 * 256) / (256 * 256 * 256));
      const b = Math.floor(rgba % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgba % (256 * 256) / 256);
      const r = rgba % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}${a.toString(16).padStart(2, "0")}`;
    }
    /**
     * Converts RGBA color components to a numerical RGBA value, as `R + G * 256 + B * 256^2 + A * 256^3`.
     * @param r The red component, from 0 to 255.
     * @param g The green component, from 0 to 255.
     * @param b The blue component, from 0 to 255.
     * @param a The alpha component, from 0 to 255.
     * @returns The numerical RGBA value of the specified components, as `R + G * 256 + B * 256^2 + A * 256^3`.
     */
    static rgbaColor(r, g, b, a) {
      return 256 * 256 * 256 * a + 256 * 256 * b + 256 * g + r;
    }
    /**
     * Creates a full Bing component earth colors array. The earth colors array will contain the specified water color
     * and terrain colors (including interpolated values between the explicitly defined ones, as necessary).
     * @param waterColor The desired water color, as a hex string with the format `#hhhhhh`.
     * @param terrainColors An array of desired terrain colors at specific elevations. Elevations should be specified in
     * feet and colors as hex strings with the format `#hhhhhh`.
     * @param minElevation The minimum elevation to which to assign a color, in feet. Defaults to 0.
     * @param maxElevation The maximum elevation to which to assign a color, in feet. Defaults to 30000.
     * @param stepCount The number of terrain color steps. Defaults to 61.
     * @returns a full Bing component earth colors array.
     */
    // eslint-disable-next-line jsdoc/require-jsdoc
    static createEarthColorsArray(waterColor, terrainColors, minElevation = 0, maxElevation = 3e4, stepCount = 61) {
      const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
      const curve = new Avionics.Curve();
      curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
      for (let i = 0; i < terrainColors.length; i++) {
        curve.add(terrainColors[i].elev, terrainColors[i].color);
      }
      const elevationStep = (maxElevation - minElevation) / Math.max(stepCount - 1, 1);
      for (let i = 0; i < stepCount; i++) {
        const color = curve.evaluate(minElevation + i * elevationStep);
        earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
      }
      return earthColors;
    }
  };
  BingComponent.DEFAULT_RESOLUTION = 1024;
  BingComponent.DEFAULT_WEATHER_COLORS = [
    [BingComponent.hexaToRGBAColor("#00000000"), 0.5],
    [BingComponent.hexaToRGBAColor("#004d00ff"), 2.75],
    [BingComponent.hexaToRGBAColor("#cb7300ff"), 12.5],
    [BingComponent.hexaToRGBAColor("#ff0000ff"), 12.5]
  ];
  BingComponent.POSITION_RADIUS_INHIBIT_FRAMES = 10;
  var AbstractNumberUnitDisplay = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.value = "isSubscribable" in this.props.value ? this.props.value : Subject.create(this.props.value);
      this.displayUnit = this.props.displayUnit !== null && "isSubscribable" in this.props.displayUnit ? this.props.displayUnit : Subject.create(this.props.displayUnit);
    }
    /** @inheritdoc */
    onAfterRender() {
      this.valueSub = this.value.sub(this.onValueChanged.bind(this), true);
      this.displayUnitSub = this.displayUnit.sub(this.onDisplayUnitChanged.bind(this), true);
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b;
      (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.displayUnitSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var DigitScroller = class extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
      var _a;
      super(props);
      this.digitCount = (this.props.base + 2) * 2 + 1;
      this.translationPerDigit = 100 / this.digitCount;
      this.tapeStyle = ObjectSubject.create({
        display: "",
        position: "absolute",
        left: "0",
        top: `calc(50% - var(--digit-scroller-line-height, 1em) * ${this.digitCount / 2})`,
        width: "100%",
        height: `calc(var(--digit-scroller-line-height, 1em) * ${this.digitCount})`,
        transform: "translate3d(0, 0, 0)"
      });
      this.nanTextStyle = ObjectSubject.create({
        display: "none",
        position: "absolute",
        left: "0%",
        top: "50%",
        width: "100%",
        transform: "translateY(-50%)"
      });
      this.digitPlaceFactor = this.props.factor;
      this.scrollThreshold = (_a = this.props.scrollThreshold) !== null && _a !== void 0 ? _a : 0;
      this.translateY = Subject.create(0);
      if (props.base < 3 || Math.floor(props.base) !== props.base) {
        throw new Error(`DigitScroller: invalid number base (${this.props.base})`);
      }
      if (props.factor === 0) {
        throw new Error(`DigitScroller: invalid factor (${props.factor})`);
      }
    }
    /** @inheritdoc */
    onAfterRender() {
      this.translateY.sub((translateY) => {
        this.tapeStyle.set("transform", `translate3d(0, ${translateY}%, 0)`);
      });
      this.valueSub = this.props.value.sub(this.update.bind(this), true);
    }
    /**
     * Updates this display.
     * @param value This display's value.
     */
    update(value) {
      if (isNaN(value)) {
        this.nanTextStyle.set("display", "");
        this.tapeStyle.set("display", "none");
        return;
      }
      this.nanTextStyle.set("display", "none");
      this.tapeStyle.set("display", "");
      const base = this.props.base;
      const valueSign = value < 0 ? -1 : 1;
      const valueAbs = Math.abs(value);
      let pivot = Math.floor(valueAbs / this.digitPlaceFactor) * this.digitPlaceFactor;
      let digit = Math.floor(pivot / this.digitPlaceFactor) % base;
      let digitTranslate = (valueAbs - pivot) / this.digitPlaceFactor;
      const threshold = this.scrollThreshold / this.digitPlaceFactor;
      digitTranslate = digitTranslate > threshold ? (digitTranslate - threshold) / (1 - threshold) : 0;
      if (digitTranslate >= 0.5) {
        pivot += this.digitPlaceFactor;
        digit = (digit + 1) % base;
        digitTranslate -= 1;
      }
      let tapeTranslate = 0;
      if (pivot <= this.digitPlaceFactor) {
        tapeTranslate = (digit + digitTranslate) * valueSign * this.translationPerDigit;
      } else {
        tapeTranslate = ((digit + base - 2) % base + 2 + digitTranslate) * valueSign * this.translationPerDigit;
      }
      this.translateY.set(MathUtils.round(tapeTranslate, 0.1));
    }
    /** @inheritdoc */
    render() {
      var _a, _b;
      let cssClass;
      if (this.props.class !== void 0 && typeof this.props.class === "object") {
        cssClass = SetSubject.create(["digit-scroller"]);
        this.cssClassSub = FSComponent.bindCssClassSet(cssClass, this.props.class, ["digit-scroller"]);
      } else {
        cssClass = `digit-scroller ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ""}`;
      }
      return FSComponent.buildComponent(
        "div",
        { class: cssClass, style: "overflow: hidden" },
        FSComponent.buildComponent("div", { class: "digit-scroller-digit-tape", style: this.tapeStyle }, this.renderDigits()),
        FSComponent.buildComponent("div", { class: "digit-scroller-nan", style: this.nanTextStyle }, (_b = this.props.nanString) !== null && _b !== void 0 ? _b : "\u2013")
      );
    }
    /**
     * Renders text for each of this display's individual digits.
     * @returns This display's individual digit text, as an array of VNodes.
     */
    renderDigits() {
      var _a;
      const base = this.props.base;
      const renderFunc = (_a = this.props.renderDigit) !== null && _a !== void 0 ? _a : (digit) => (Math.abs(digit) % base).toString();
      const zeroIndexOffset = base + 2;
      return Array.from({ length: this.digitCount }, (v, index) => {
        const digit = zeroIndexOffset - index;
        return FSComponent.buildComponent(
          "div",
          { style: `position: absolute; left: 0; top: calc(var(--digit-scroller-line-offset-y, 0px) + ${50 + (index - zeroIndexOffset - 0.5) * this.translationPerDigit}%); width: 100%; height: ${this.translationPerDigit}%; line-height: var(--digit-scroller-line-height, 1em);` },
          FSComponent.buildComponent("span", { class: "digit-scroller-digit", style: "vertical-align: baseline;" }, renderFunc(digit))
        );
      });
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.cssClassSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var DurationDisplayFormat;
  (function(DurationDisplayFormat2) {
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_ss"] = 0] = "hh_mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm"] = 1] = "hh_mm";
    DurationDisplayFormat2[DurationDisplayFormat2["mm_ss"] = 2] = "mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_or_mm_ss"] = 3] = "hh_mm_or_mm_ss";
  })(DurationDisplayFormat || (DurationDisplayFormat = {}));
  var DurationDisplayDelim;
  (function(DurationDisplayDelim2) {
    DurationDisplayDelim2[DurationDisplayDelim2["Colon"] = 0] = "Colon";
    DurationDisplayDelim2[DurationDisplayDelim2["ColonOrCross"] = 1] = "ColonOrCross";
    DurationDisplayDelim2[DurationDisplayDelim2["Space"] = 2] = "Space";
  })(DurationDisplayDelim || (DurationDisplayDelim = {}));
  var DurationDisplay = class extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
      super(props);
      this.value = "isSubscribable" in this.props.value ? this.props.value : Subject.create(this.props.value);
      this.options = Object.assign({}, DurationDisplay.DEFAULT_OPTIONS, this.props.options);
      this.negativeSign = this.options.useMinusSign ? "\u2212" : "-";
      this.positiveSign = this.options.forceSign ? "+" : "";
      this.text = Subject.create("");
      switch (this.options.delim) {
        case DurationDisplayDelim.Colon:
          this.delim = ":";
          break;
        case DurationDisplayDelim.Space:
          this.delim = " ";
          break;
        default:
          this.delim = "";
      }
    }
    /** @inheritdoc */
    onAfterRender() {
      this.valueSub = this.value.sub(this.onValueChanged.bind(this), true);
    }
    /**
     * A callback which is called when this component's bound value changes.
     * @param value The new value.
     */
    onValueChanged(value) {
      this.setDisplay(value);
    }
    /**
     * Displays this component's current value.
     * @param value The current value.
     */
    setDisplay(value) {
      let text;
      if (value.isNaN()) {
        text = this.options.nanString;
      } else {
        let hrText = "";
        let minText = "";
        let secText = "";
        let hrUnitText = "";
        let minUnitText = "";
        let secUnitText = "";
        let hrDelim = "";
        let minDelim = "";
        const valueAsSeconds = Math.abs(value.asUnit(UnitType.SECOND));
        const isNegative = value.number < 0;
        let hours = Math.floor(valueAsSeconds / 3600);
        if (this.options.format != DurationDisplayFormat.mm_ss && !(this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours == 0)) {
          hrText = hours.toFixed(0);
          if (this.options.delim === DurationDisplayDelim.ColonOrCross) {
            if (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss || this.options.format === DurationDisplayFormat.hh_mm) {
              hrDelim = "+";
            } else {
              hrDelim = ":";
            }
          } else {
            hrDelim = this.delim;
          }
        }
        const hoursInMinutes = hours * 60;
        let minutes;
        let seconds;
        if (this.options.format === DurationDisplayFormat.hh_mm || this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours !== 0) {
          minutes = valueAsSeconds / 60 - hoursInMinutes;
          minText = this.options.numberFormatter(minutes);
        } else {
          minutes = Math.floor(valueAsSeconds / 60 - hoursInMinutes);
          minText = minutes.toFixed(0);
          minDelim = this.options.delim === DurationDisplayDelim.ColonOrCross ? ":" : this.delim;
          seconds = valueAsSeconds - (hoursInMinutes + minutes) * 60;
          secText = this.options.numberFormatter(seconds);
        }
        if (secText && secText.replace(/\b0+/, "").substring(0, 2) === "60") {
          seconds = parseFloat(secText) - 60;
          minutes++;
          secText = this.options.numberFormatter(seconds);
          minText = `${minutes}`;
        }
        if (minText && minText.replace(/\b0+/, "").substring(0, 2) === "60" && hrText) {
          if (secText) {
            minutes = 0;
            minText = "00";
          } else {
            minutes = parseFloat(minText) - 60;
            minText = this.options.numberFormatter(minutes);
          }
          hours++;
          hrText = `${hours}`;
        }
        if (hrText) {
          hrText = hrText.padStart(this.options.pad, "0");
          if (secText) {
            minText = minText.padStart(2, "0");
            secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
          } else {
            minText = DurationDisplay.padIntegerPart(minText.replace(/^0+/, ""), 2, "0");
          }
        } else {
          minText = minText.padStart(this.options.pad, "0");
          secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
        }
        if (this.options.showUnits) {
          hrText && (hrUnitText = this.options.unitFormatter(parseFloat(hrText), UnitType.HOUR));
          minUnitText = this.options.unitFormatter(parseFloat(minText), UnitType.MINUTE);
          secText && (secUnitText = this.options.unitFormatter(parseFloat(secText), UnitType.SECOND));
        }
        const sign = isNegative ? this.negativeSign : this.positiveSign;
        text = `${sign}${hrText}${hrUnitText}${hrDelim}${minText}${minUnitText}${minDelim}${secText}${secUnitText}`;
      }
      this.text.set(text);
    }
    /**
     * Pads the integer part of a string which represents a number.
     * @param str A string which represents a number.
     * @param maxLength The length to which the integer part of the string will be padded.
     * @param fillString The string with which to pad the original string.
     * @returns a new string which is the result of padding the original string.
     */
    static padIntegerPart(str, maxLength, fillString) {
      const decimalIndex = str.indexOf(".");
      return str.padStart(decimalIndex < 0 ? maxLength : str.length - decimalIndex + maxLength, fillString);
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: "white-space: nowrap;" }, this.text);
    }
    /** @inheritdoc */
    destroy() {
      var _a;
      (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  DurationDisplay.DEFAULT_OPTIONS = {
    pad: 0,
    format: DurationDisplayFormat.hh_mm_ss,
    delim: DurationDisplayDelim.Colon,
    showUnits: false,
    numberFormatter: (value) => value.toFixed(0),
    unitFormatter: (value, unit) => unit.name[0],
    useMinusSign: false,
    forceSign: false,
    nanString: ""
  };
  var DmsDirection;
  (function(DmsDirection2) {
    DmsDirection2["NORTH"] = "N";
    DmsDirection2["SOUTH"] = "S";
    DmsDirection2["WEST"] = "W";
    DmsDirection2["EAST"] = "E";
  })(DmsDirection || (DmsDirection = {}));
  var DmsFormatter = class {
    constructor() {
      this.coordsParts = {
        direction: DmsDirection.NORTH,
        degrees: 0,
        minutes: 0,
        seconds: 0
      };
    }
    /**
     * Builds a DMS string out of the given latitude.
     * @param value The latitude.
     * @param spaceAfterDirection Whether to insert a space after the direction letter.
     * @param minuteApostrophe Whether to insert an apostrophe (') after the string.
     * @param precision Decimal precision for the minutes part.
     * @param padMinutesTo Padding applied to integer part of minutes.
     * @returns The DMS string.
     */
    getLatDmsStr(value, spaceAfterDirection = true, minuteApostrophe = true, precision = 2, padMinutesTo = 3) {
      const parts = this.parseLat(value);
      if (parts.minutes >= 59.5) {
        parts.minutes = 0;
        parts.degrees++;
      }
      return `${parts.direction}${spaceAfterDirection ? " " : ""}${parts.degrees.toString().padStart(2, "0")}\xB0${parts.minutes.toFixed(precision).padStart(padMinutesTo + precision, "0")}${minuteApostrophe ? "'" : ""}`;
    }
    /**
     * Builds a DMS string out of the given longitude.
     * @param value The longitude.
     * @param minuteApostrophe Whether to insert an apostrophe (') after the string.
     * @param precision Decimal precision for the minutes part.
     * @param padMinutesTo Padding applied to integer part of minutes.
     * @returns The DMS string.
     */
    getLonDmsStr(value, minuteApostrophe = true, precision = 2, padMinutesTo = 3) {
      const parts = this.parseLon(value);
      if (parts.minutes >= 59.5) {
        parts.minutes = 0;
        parts.degrees++;
      }
      return `${parts.direction}${parts.degrees.toString().padStart(3, "0")}\xB0${parts.minutes.toFixed(precision).padStart(padMinutesTo + precision, "0")}${minuteApostrophe ? "'" : ""}`;
    }
    /**
     * Parses a latitude in to the dms parts.
     * @param value The latitude in degrees.
     * @returns The DMS parts.
     */
    parseLat(value) {
      this.coordsParts.direction = value < 0 ? DmsDirection.SOUTH : DmsDirection.NORTH;
      return this.parse(value);
    }
    /**
     * Parses a longitude in to the dms parts.
     * @param value The longitude in degrees.
     * @returns The DMS parts.
     */
    parseLon(value) {
      this.coordsParts.direction = value < 0 ? DmsDirection.WEST : DmsDirection.EAST;
      return this.parse(value);
    }
    /**
     * Parses the latitude/longitude.
     * @private
     * @param value The value to parse.
     * @returns The DMS parts.
     */
    parse(value) {
      value = Math.abs(value);
      this.coordsParts.degrees = Math.trunc(value);
      value = (value - this.coordsParts.degrees) * 60;
      this.coordsParts.minutes = value;
      this.coordsParts.seconds = (value - this.coordsParts.minutes) * 60;
      return this.coordsParts;
    }
  };
  var LatLonDisplay = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.latPrefix = Subject.create("");
      this.latNum = Subject.create("");
      this.lonPrefix = Subject.create("");
      this.lonNum = Subject.create("");
      this.formatter = new DmsFormatter();
    }
    /** @inheritdoc */
    onAfterRender() {
      this.locationSub = this.props.location.sub(this.onLocationChanged.bind(this), true);
    }
    /**
     * A callback which is called when this component's bound location changes.
     * @param location The new location.
     */
    onLocationChanged(location) {
      if (isNaN(location.lat) || isNaN(location.lon)) {
        this.clearDisplay();
      } else {
        this.setDisplay(location);
      }
    }
    /**
     * Displays the formatted lat/lon coordinates of a location.
     * @param location A location.
     */
    setDisplay(location) {
      this.setCoordSub(this.latPrefix, this.latNum, this.formatter.parseLat(location.lat), 2);
      this.setCoordSub(this.lonPrefix, this.lonNum, this.formatter.parseLon(location.lon), 3);
    }
    /**
     * Sets coordinate subjects for a given set of coordinate values.
     * @param prefixSub The coordinate prefix subject.
     * @param numSub The coordinate number subject.
     * @param coordValues The DMS values of the coordinate.
     * @param padDeg The number of digits to which to pad the degrees value.
     */
    setCoordSub(prefixSub, numSub, coordValues, padDeg) {
      const prefix = coordValues.direction;
      let deg = coordValues.degrees;
      let minutes = Math.round((coordValues.minutes + coordValues.seconds / 60) * 100) / 100;
      if (minutes === 60) {
        deg++;
        minutes = 0;
      }
      prefixSub.set(prefix);
      numSub.set(`${deg.toString().padStart(padDeg, "0")}\xB0${minutes.toFixed(2).padStart(5, "0")}'`);
    }
    /**
     * Displays the blank default value.
     */
    clearDisplay() {
      this.latPrefix.set("_");
      this.latNum.set("__\xB0__.__'");
      this.lonPrefix.set("_");
      this.lonNum.set("___\xB0__.__'");
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent(
        "div",
        { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" },
        FSComponent.buildComponent(
          "div",
          { class: "latlon-coord latlon-lat" },
          FSComponent.buildComponent("div", { class: "latlon-prefix" }, this.latPrefix),
          FSComponent.buildComponent("div", { class: "latlon-num", style: "white-space: nowrap;" }, this.latNum)
        ),
        FSComponent.buildComponent(
          "div",
          { class: "latlon-coord latlon-lon" },
          FSComponent.buildComponent("div", { class: "latlon-prefix" }, this.lonPrefix),
          FSComponent.buildComponent("div", { class: "latlon-num", style: "white-space: nowrap;" }, this.lonNum)
        )
      );
    }
    /** @inheritdoc */
    destroy() {
      var _a;
      (_a = this.locationSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  var FocusPosition;
  (function(FocusPosition2) {
    FocusPosition2["MostRecent"] = "MostRecent";
    FocusPosition2["First"] = "First";
    FocusPosition2["Last"] = "Last";
    FocusPosition2["None"] = "None";
  })(FocusPosition || (FocusPosition = {}));
  var BlurReconciliation;
  (function(BlurReconciliation2) {
    BlurReconciliation2["First"] = "First";
    BlurReconciliation2["Last"] = "Last";
    BlurReconciliation2["Next"] = "Next";
    BlurReconciliation2["Prev"] = "Prev";
    BlurReconciliation2["None"] = "None";
  })(BlurReconciliation || (BlurReconciliation = {}));
  var HardwareUiControl = class extends DisplayComponent {
    /**
     * Creates an instance of a HardwareUiControl.
     * @param props The props for this component.
     */
    constructor(props) {
      super(props);
      this.focusedIndex = -1;
      this._isDisabled = false;
      this._isFocused = false;
      this._isIsolated = false;
      this._UICONTROL_ = true;
      this._isIsolated = this.props.isolateScroll !== void 0 && this.props.isolateScroll;
    }
    /**
     * Gets the current number of registered child controls.
     * @returns The current number of registered child controls.
     */
    get length() {
      if (this.registeredControls !== void 0) {
        return this.registeredControls.length;
      }
      return 0;
    }
    /**
     * Gets whether or not the control is currently disabled.
     * @returns True if disabled, false otherwise.
     */
    get isDisabled() {
      return this._isDisabled;
    }
    /**
     * Gets whether or not the control is currently focused.
     * @returns True if disabled, false otherwise.
     */
    get isFocused() {
      return this._isFocused;
    }
    /**
     * Gets whether or not the control is currently in scroll isolation.
     * @returns True if currently in scroll isolation, false otherwise.
     */
    get isIsolated() {
      return this._isIsolated;
    }
    /**
     * An event called when the control receives focus.
     * @param source The control that emitted this event.
     */
    onFocused(source) {
      this.props.onFocused && this.props.onFocused(source);
    }
    /**
     * An event called when the control is blurred.
     * @param source The control that emitted this event.
     */
    onBlurred(source) {
      this.props.onBlurred && this.props.onBlurred(source);
    }
    /**
     * An event called when the control is enabled.
     * @param source The control that emitted this event.
     */
    onEnabled(source) {
      this.props.onEnabled && this.props.onEnabled(source);
    }
    /**
     * An event called when the control is disabled.
     * @param source The control that emitted this event.
     */
    onDisabled(source) {
      this.props.onDisabled && this.props.onDisabled(source);
    }
    /**
     * An event called when a control is registered with this control.
     * @param source The control that emitted this event.
     */
    onRegistered(source) {
      this.props.onRegistered && this.props.onRegistered(source);
    }
    /**
     * An event called when a control is unregistered from this control.
     * @param source The control that emitted this event.
     */
    onUnregistered(source) {
      this.props.onUnregistered && this.props.onUnregistered(source);
    }
    /**
     * Gets the focus position to apply when this control is focused from a scroll.
     * @param direction The direction of the scroll.
     * @returns The focus position to apply when this control is focused from a scroll.
     */
    getFocusPositionOnScroll(direction) {
      if (this.props.getFocusPositionOnScroll) {
        return this.props.getFocusPositionOnScroll(direction);
      }
      return direction === "forward" ? FocusPosition.First : FocusPosition.Last;
    }
    /**
     * An event called when the control is scrolled.
     * @param direction The direction that is being requested to scroll.
     * @returns True if this control handled this event, false otherwise.
     */
    onScroll(direction) {
      if (this.registeredControls !== void 0 && this.registeredControls.length > 0) {
        const delta = direction === "forward" ? 1 : -1;
        for (let i = this.focusedIndex + delta; direction === "forward" ? i < this.registeredControls.length : i >= 0; i += delta) {
          const controlToFocus = this.registeredControls[i];
          if (controlToFocus.focus(controlToFocus.getFocusPositionOnScroll(direction))) {
            this.onAfterScroll(controlToFocus, i);
            return true;
          }
        }
      }
      return false;
    }
    /**
     * An event called when a scroll operation has completed.
     * @param control The control that was scrolled to.
     * @param index The index of the control in the collection of registered controls.
     */
    onAfterScroll(control, index) {
      this.props.onAfterScroll && this.props.onAfterScroll(control, index);
    }
    /**
     * Scrolls the currently focused control in the supplied direction.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    scroll(direction) {
      if (!this.isFocused) {
        return false;
      }
      const controlToScroll = this.getFocusedComponentPath()[0];
      if (controlToScroll !== void 0) {
        return controlToScroll.tryPerformScroll(direction);
      } else {
        return this.tryPerformScroll(direction);
      }
    }
    /**
     * Attempts to perform a scroll operation on the control, propagating the operation
     * upward in the tree if the control does not handle the operation.
     * @param direction The direction that is being requested to scroll.
     * @returns True if propagation should be stopped, false otherwise.
     */
    tryPerformScroll(direction) {
      let handled = false;
      if (this.props.onScroll !== void 0) {
        handled = this.props.onScroll(direction);
      } else {
        handled = this.onScroll(direction);
      }
      if (!handled) {
        const currentlyIsolated = this.isFocused && this.isIsolated;
        if (this.parent !== void 0 && !currentlyIsolated) {
          return this.parent.tryPerformScroll(direction);
        } else if (currentlyIsolated) {
          return true;
        }
      }
      return handled;
    }
    /**
     * Triggers an event on this control. The event will first be routed to the deepest focused descendent of this
     * control and will propagate up the control tree until it is handled or there are no more controls to which to
     * propagate.
     * @param event The event to trigger.
     * @param source The source of the event. Defaults to this if not supplied.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    triggerEvent(event, source, ...args) {
      const canListen = this.isFocused || this.parent === void 0;
      if (!canListen) {
        return false;
      }
      const focusedControl = this.getFocusedComponentPath()[0];
      if (focusedControl !== void 0) {
        return focusedControl.propagateEvent(event, focusedControl, args);
      }
      return false;
    }
    /**
     * Propagates an event up the control tree.
     * @param event The event to propagate.
     * @param source The source of the event.
     * @param args Additional arguments to pass to the event handler.
     * @returns True if the event was handled, false otherwise.
     */
    propagateEvent(event, source, args) {
      const handler = this[`on${event}`];
      const propHandler = this.props[`on${event}`];
      const stopPropagation = !!handler && handler.call(this, source, ...args) || !!propHandler && propHandler(source, ...args);
      if (!stopPropagation && this.parent !== void 0) {
        return this.parent.propagateEvent(event, this.parent, args);
      }
      return stopPropagation;
    }
    /**
     * Validates that the control can be focused by checking if any ancestors in the
     * control tree are disabled.
     * @returns True if there are no disabled ancestors, false otherwise.
     */
    canBeFocused() {
      let canFocus = true;
      if (!this._isDisabled) {
        if (this.parent !== void 0) {
          canFocus = this.parent.canBeFocused();
        }
      } else {
        canFocus = false;
      }
      return canFocus;
    }
    /**
     * Brings focus to the control. Focusing the control will also blur the currently
     * focused control, if any.
     * @param focusPosition The focus position to activate for descendents of this control.
     * @returns Whether this control was successfully focused.
     */
    focus(focusPosition) {
      if (!this.canBeFocused()) {
        return false;
      }
      const focusStack = this.buildFocusPath(focusPosition);
      if (focusStack.length === 0) {
        return false;
      }
      focusStack.pop();
      this.getDeepestFocusedAncestorPath(focusStack);
      const focusRoot = focusStack[focusStack.length - 1];
      const blurStack = focusRoot.getFocusedComponentPath();
      if (blurStack.length > 0) {
        blurStack.pop();
        for (let i = 0; i < blurStack.length; i++) {
          blurStack[i]._isFocused = false;
        }
      }
      if (focusRoot.isFocused) {
        focusStack.pop();
      }
      for (let i = 0; i < focusStack.length; i++) {
        const control = focusStack[i];
        const parent = control.parent;
        control._isFocused = true;
        if (parent !== void 0 && parent.registeredControls !== void 0) {
          parent.focusedIndex = parent.registeredControls.indexOf(control);
        }
      }
      while (blurStack.length > 0) {
        const control = blurStack.pop();
        if (control !== void 0) {
          control.onBlurred(control);
        }
      }
      while (focusStack.length > 0) {
        const control = focusStack.pop();
        if (control !== void 0) {
          control.onFocused(control);
        }
      }
      return true;
    }
    /**
     * Gets the path from this control to the deepest descendent control that is focused. If this control is not focused,
     * then the path is empty.
     * @param path The stack of control nodes defining the path to the currently
     * focused descendent control.
     * @returns A stack of nodes that defines the path to the deepest focused descendent
     * node, in order of deepest descendent first.
     */
    getFocusedComponentPath(path) {
      if (path === void 0) {
        path = [];
      }
      if (!this._isFocused) {
        return path;
      }
      let currentControl = this;
      while (currentControl !== void 0) {
        path.splice(0, 0, currentControl);
        if (currentControl.registeredControls !== void 0) {
          currentControl = currentControl.registeredControls.find((c) => c.isFocused);
        } else {
          currentControl = void 0;
        }
      }
      return path;
    }
    /**
     * Gets the path from this control to its deepest ancestor that is focused (including itself). If none of this
     * control's ancestors are focused, the path will contain this control and all of its ancestors up to and including
     * the root of its control tree.
     * @param path An array in which to store the path.
     * @returns A stack of controls that defines the path from this control to its deepest focused ancestor, ordered
     * from descendents to ancestors (the control at the shallowest tree depth is located at the top of the stack).
     */
    getDeepestFocusedAncestorPath(path) {
      if (path === void 0) {
        path = [];
      }
      let currentControl = this;
      while (currentControl !== void 0) {
        path.push(currentControl);
        if (currentControl !== this && currentControl.isFocused) {
          break;
        }
        currentControl = currentControl.parent;
      }
      return path;
    }
    /**
     * Builds the path of controls to focus from this control downward in children based on the provided default focus
     * position. If this control cannot be focused, the path will be empty.
     * @param focusPosition The focus position to use to build the path.
     * @param focusStack The stack in which to store the path.
     * @returns A stack of components that defines the path from the deepest descendent to focus to this control if this
     * control were to be focused with the specified focus position, ordered from descendents to ancestors (the control
     * at the shallowest tree depth is located at the top of the stack).
     */
    buildFocusPath(focusPosition, focusStack) {
      var _a;
      if (focusStack === void 0) {
        focusStack = [];
      }
      if (this._isDisabled) {
        return focusStack;
      }
      const originalStackDepth = focusStack.length;
      const childControls = this.registeredControls;
      if (childControls !== void 0) {
        switch (focusPosition) {
          case FocusPosition.MostRecent:
            (_a = childControls[this.focusedIndex]) === null || _a === void 0 ? void 0 : _a.buildFocusPath(FocusPosition.MostRecent, focusStack);
            if (focusStack.length > originalStackDepth) {
              break;
            }
          case FocusPosition.First:
            for (let i = 0; i < childControls.length; i++) {
              childControls[i].buildFocusPath(FocusPosition.First, focusStack);
              if (focusStack.length > originalStackDepth) {
                break;
              }
            }
            break;
          case FocusPosition.Last:
            for (let i = childControls.length - 1; i >= 0; i--) {
              childControls[i].buildFocusPath(FocusPosition.Last, focusStack);
              if (focusStack.length > originalStackDepth) {
                break;
              }
            }
            break;
        }
      }
      if (!this.props.requireChildFocus || focusStack.length > originalStackDepth) {
        focusStack.push(this);
      }
      return focusStack;
    }
    /**
     * Blurs, or removes focus, from the component.
     */
    blur() {
      var _a, _b;
      if (!this._isFocused) {
        return;
      }
      let indexInParent = -1;
      if (this.parent) {
        indexInParent = (_b = (_a = this.parent.registeredControls) === null || _a === void 0 ? void 0 : _a.indexOf(this)) !== null && _b !== void 0 ? _b : -1;
      }
      const blurStack = this.getFocusedComponentPath();
      for (let i = 0; i < blurStack.length; i++) {
        blurStack[i]._isFocused = false;
      }
      while (blurStack.length > 0) {
        const control = blurStack.pop();
        if (control !== void 0) {
          control.onBlurred(control);
        }
      }
      if (this.parent && indexInParent >= 0) {
        this.parent.handleNoFocusedChild(indexInParent, this);
      }
    }
    /**
     * Handles the case where this control is left focused with no focused child control after a child control is
     * blurred.
     * @param indexBlurred The index of the child control that was blurred. If the child is no longer registered, then
     * this is the index of the child prior to being unregistered.
     * @param childBlurred The child control that was blurred.
     */
    handleNoFocusedChild(indexBlurred, childBlurred) {
      var _a;
      if (!this._isFocused || this.getFocusedIndex() >= 0) {
        return;
      }
      const reconciliation = this.reconcileChildBlur(indexBlurred, childBlurred);
      if (this.registeredControls) {
        if (typeof reconciliation === "number") {
          const controlToFocus = (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[reconciliation];
          controlToFocus === null || controlToFocus === void 0 ? void 0 : controlToFocus.focus(FocusPosition.First);
        } else {
          switch (reconciliation) {
            case BlurReconciliation.First:
              this.focus(FocusPosition.First);
              break;
            case BlurReconciliation.Last:
              this.focus(FocusPosition.Last);
              break;
            case BlurReconciliation.Next:
              for (let i = Math.max(indexBlurred + (this.registeredControls[indexBlurred] === childBlurred ? 1 : 0), 0); i < this.registeredControls.length; i++) {
                if (this.registeredControls[i].focus(FocusPosition.First)) {
                  break;
                }
              }
              for (let i = Math.min(indexBlurred - 1, this.registeredControls.length - 1); i >= 0; i--) {
                if (this.registeredControls[i].focus(FocusPosition.First)) {
                  break;
                }
              }
              break;
            case BlurReconciliation.Prev:
              for (let i = Math.min(indexBlurred - 1, this.registeredControls.length - 1); i >= 0; i--) {
                if (this.registeredControls[i].focus(FocusPosition.Last)) {
                  break;
                }
              }
              for (let i = Math.max(indexBlurred + (this.registeredControls[indexBlurred] === childBlurred ? 1 : 0), 0); i < this.registeredControls.length; i++) {
                if (this.registeredControls[i].focus(FocusPosition.Last)) {
                  break;
                }
              }
              break;
          }
        }
      }
      if (this.props.requireChildFocus && this.getFocusedIndex() < 0) {
        this.blur();
      }
    }
    /**
     * Reconciles the focus state of this control's children when this control is focused with no focused children after
     * a child has been blurred.
     * @param index The index of the child control that was blurred. If the child is no longer registered, then this is
     * the index of the child prior to being unregistered.
     * @param child The child control that was blurred.
     * @returns The index of the child control to focus.
     */
    reconcileChildBlur(index, child) {
      var _a;
      if (this.props.reconcileChildBlur) {
        return this.props.reconcileChildBlur(index, child);
      }
      if (((_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[index]) !== child) {
        return BlurReconciliation.Next;
      } else {
        return -1;
      }
    }
    /**
     * Sets the component to be disabled, removing the ability for the component to scroll. Setting
     * a component to disabled will also blur the component and its children, if necessary.
     * @param isDisabled Whether or not the component is disabled.
     */
    setDisabled(isDisabled) {
      this._isDisabled = isDisabled;
      if (isDisabled) {
        this.blur();
        this.onDisabled(this);
      } else {
        this.onEnabled(this);
      }
    }
    /**
     * Registers a child control with this control.
     * @param control The control to register.
     * @param index The index at which to register the control. If none is provided,
     * the control will be registered at the end of the collection of child controls.
     */
    register(control, index) {
      if (this.registeredControls === void 0) {
        this.registeredControls = [];
      }
      if (index !== void 0) {
        this.registeredControls.splice(index, 0, control);
        if (this.focusedIndex >= index) {
          this.focusedIndex++;
        }
      } else {
        this.registeredControls.push(control);
      }
      control.setParent(this);
      control.onRegistered(control);
    }
    /**
     * Unregisters a child control with this control.
     * @param item The child control or index of a child control to unregister. If a
     * child control is provided, it will attempt to be located in the control's
     * child registry and then removed. If an index is provided, the child control
     * at that registered index will be removed.
     */
    unregister(item) {
      if (this.registeredControls !== void 0) {
        let index = -1;
        if (typeof item === "number") {
          index = item;
        } else {
          index = this.registeredControls.indexOf(item);
        }
        if (index >= 0 && index < this.length) {
          const controlToRemove = this.registeredControls[index];
          const isRemovedControlFocused = controlToRemove._isFocused;
          this.registeredControls.splice(index, 1);
          controlToRemove.parent = void 0;
          if (isRemovedControlFocused) {
            controlToRemove.blur();
            this.handleNoFocusedChild(index, controlToRemove);
          } else {
            if (this.focusedIndex === index) {
              this.focusedIndex = -1;
            } else if (this.focusedIndex > index) {
              this.focusedIndex--;
            }
          }
          this.focusedIndex = Math.min(this.focusedIndex, this.registeredControls.length - 1);
          if (controlToRemove.length > 0) {
            controlToRemove.clearRegistered();
          }
          controlToRemove.onUnregistered(controlToRemove);
          if (this.length === 0) {
            this.registeredControls = void 0;
          }
        }
      }
    }
    /**
     * Clears the list of registered components.
     */
    clearRegistered() {
      if (this.registeredControls !== void 0) {
        const registeredControls = this.registeredControls;
        this.registeredControls = void 0;
        this.focusedIndex = -1;
        for (let i = 0; i < registeredControls.length; i++) {
          const controlToRemove = registeredControls[i];
          controlToRemove.parent = void 0;
          if (controlToRemove._isFocused) {
            controlToRemove.blur();
          }
          if (controlToRemove.length > 0) {
            controlToRemove.clearRegistered();
          }
          registeredControls[i].onUnregistered(registeredControls[i]);
        }
        this.handleNoFocusedChild(0, registeredControls[registeredControls.length - 1]);
      }
    }
    /**
     * Gets the current focused index in the registered controls collection.
     * @returns The index of the focused control in the collection of registered controls.
     */
    getFocusedIndex() {
      var _a, _b;
      return ((_b = (_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a[this.focusedIndex]) === null || _b === void 0 ? void 0 : _b._isFocused) ? this.focusedIndex : -1;
    }
    /**
     * Gets the most recent focused index (including the current focused index, if one exists) in the registered controls
     * collection.
     * @returns The index of the most recently focused control in the collection of registered controls.
     */
    getMostRecentFocusedIndex() {
      return this.focusedIndex;
    }
    /**
     * Sets the current most recently focused child control index. If this control is focused and has children
     * that have focus, this will also switch child focus to the new index.
     * @param index The index of the child control to set most recent focus for.
     * @param focusPosition The focus position to focus the child for, if required.
     */
    setFocusedIndex(index, focusPosition = FocusPosition.MostRecent) {
      var _a;
      if (this.isFocused && this.length > 0 && ((_a = this.registeredControls) === null || _a === void 0 ? void 0 : _a.findIndex((c) => c.isFocused)) !== -1) {
        const child = this.getChild(index);
        if (child !== void 0) {
          child.focus(focusPosition);
        }
      } else if (this.length > 0 && index >= 0 && index < this.length) {
        this.focusedIndex = index;
      }
    }
    /**
     * Gets a child control at the specified index.
     * @param index The index of the child control to get.
     * @returns The specified child control.
     */
    getChild(index) {
      if (this.registeredControls !== void 0) {
        return this.registeredControls[index];
      }
      return void 0;
    }
    /**
     * Gets the index of a specified child control within the registered
     * child controls collection.
     * @param child The child to get the index of.
     * @returns The index of the child, or -1 if not found.
     */
    indexOf(child) {
      if (this.registeredControls !== void 0) {
        return this.registeredControls.indexOf(child);
      }
      return -1;
    }
    /**
     * Sets the parent of this control.
     * @param parent The parent to set.
     */
    setParent(parent) {
      this.parent = parent;
    }
    /**
     * Sets whether or not this control is in scroll isolation. While scroll isolation
     * is enabled, scroll events will not propagate to the control's parent when the
     * control has focus.
     * @param isolated Whether or not the control is isolated.
     */
    setIsolated(isolated) {
      this._isIsolated = isolated;
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
      FSComponent.visitNodes(thisNode, (node) => {
        const instance = node.instance;
        if (instance !== this && (instance === null || instance === void 0 ? void 0 : instance._UICONTROL_)) {
          this.register(node.instance);
          return true;
        }
        return false;
      });
    }
    /**
     * Renders the control.
     * @returns The component VNode.
     */
    render() {
      return FSComponent.buildComponent(FSComponent.Fragment, null, this.props.children);
    }
    /** @inheritdoc */
    destroy() {
      super.destroy();
      this.props.onDestroyed && this.props.onDestroyed(this);
    }
  };
  var ScrollUtils = class {
    /**
     * Scrolls the container to make sure an element is in view.
     * @param el The element to scroll into view in the container.
     * @param container The container to scroll.
     * @param pinDirection The end of the container which the element should be pinned to.
     */
    static ensureInView(el, container, pinDirection = "none") {
      const cHeight = container.offsetHeight;
      const eHeight = el.offsetHeight;
      if (eHeight > cHeight) {
        return;
      }
      const cTop = container.scrollTop;
      const cBottom = cTop + cHeight;
      try {
        const eTop = ScrollUtils.findOffsetTopRelativeToAncestor(el, container);
        const eBottom = eTop + eHeight;
        if (!this.isElementInViewport(cTop, cBottom, eTop, eBottom) || pinDirection !== "none") {
          if (eTop < cTop || pinDirection === "top") {
            container.scrollTop -= cTop - eTop;
          } else if (eBottom > cBottom || pinDirection === "bottom") {
            container.scrollTop += eBottom - cBottom;
          }
        }
      } catch (e) {
        console.warn(e);
      }
    }
    /**
     * Finds the offsetTop of an element relative to one of its ancestors.
     * @param element An element.
     * @param ancestor An ancestor of `element`.
     * @returns the offsetTop of the element relative to the ancestor.
     * @throws Error if the offsetTop could not be calculated.
     */
    static findOffsetTopRelativeToAncestor(element, ancestor) {
      const ancestorParent = ancestor.offsetParent;
      let top = element.offsetTop;
      while (element.offsetParent !== ancestorParent) {
        if (!(element.offsetParent instanceof HTMLElement)) {
          throw new Error("Element's offset ancestry does not directly lead to the specified ancestor");
        }
        element = element.offsetParent;
        top += element.offsetTop;
      }
      return top - ancestor.offsetTop;
    }
    /**
     * Checks if an element is visible.
     * @param cTop The top coordinate of the scroll container.
     * @param cBottom The bottom coordinate of the scroll container.
     * @param eTop The top coordinate of the element.
     * @param eBottom The bottom coordinate of the element.
     * @returns A boolean.
     */
    static isElementInViewport(cTop, cBottom, eTop, eBottom) {
      return eTop >= cTop && eBottom <= cBottom;
    }
  };
  var HardwareUiControlList = class extends HardwareUiControl {
    /**
     * Creates an instance of a ControlList.
     * @param props The props on the ControlList component.
     */
    constructor(props) {
      super(props);
      this.el = FSComponent.createRef();
      this.itemsContainer = FSComponent.createRef();
      this.sortControls = (a, b) => {
        if (this.controlToDataMap !== void 0 && this.props.orderBy !== void 0) {
          const aData = this.controlToDataMap.get(a);
          const bData = this.controlToDataMap.get(b);
          if (aData !== void 0 && bData !== void 0) {
            return this.props.orderBy(aData, bData);
          }
        }
        return 0;
      };
      if (props.orderBy !== void 0) {
        this.dataToControlMap = /* @__PURE__ */ new Map();
        this.controlToElementMap = /* @__PURE__ */ new Map();
        this.controlToDataMap = /* @__PURE__ */ new Map();
        this.currentControlOrder = [];
      }
    }
    /** @inheritdoc */
    onAfterRender(node) {
      super.onAfterRender(node);
      if (this.props.itemSize !== void 0 && this.props.numItems !== void 0) {
        const listSizePx = (this.props.itemSize * this.props.numItems).toFixed(4);
        this.el.instance.style.height = listSizePx;
        this.itemsContainer.instance.style.height = listSizePx;
      }
      this.renderList();
      this.props.data.sub(this.onDataChanged.bind(this));
    }
    /**
     * A callback fired when the array subject data changes.
     * @param index The index of the change.
     * @param type The type of change.
     * @param data The item that was changed.
     */
    onDataChanged(index, type, data) {
      switch (type) {
        case SubscribableArrayEventType.Added:
          this.onDataAdded(index, data);
          break;
        case SubscribableArrayEventType.Removed:
          this.onDataRemoved(index, data);
          break;
        case SubscribableArrayEventType.Cleared:
          this.onDataCleared();
          break;
      }
    }
    /**
     * An event called when data is added to the subscription.
     * @param index The index that the data was added at.
     * @param data The data that was added.
     */
    onDataAdded(index, data) {
      if (data !== void 0) {
        const currentItemElement = this.itemsContainer.instance.children.item(index);
        if (Array.isArray(data)) {
          for (let i = 0; i < data.length; i++) {
            const dataItem = data[i];
            const indexToAdd = index + i;
            this.addDataItem(dataItem, indexToAdd, currentItemElement);
          }
        } else {
          this.addDataItem(data, index, currentItemElement);
        }
      }
      this.updateOrder();
    }
    /**
     * Adds a data item to the control list and performs the required rendering and
     * ordering operations.
     * @param dataItem The data item to add to the list.
     * @param indexToAdd The index to add the item at.
     * @param currentItemElement The current DOM element that resides at the location to add to.
     */
    addDataItem(dataItem, indexToAdd, currentItemElement) {
      const controlNode = this.props.renderItem(dataItem, indexToAdd);
      const control = controlNode.instance;
      const originalOnFocused = control.onFocused.bind(control);
      control.onFocused = (source) => {
        this.onItemFocused();
        originalOnFocused && originalOnFocused(source);
      };
      const element = this.renderToDom(controlNode, indexToAdd, currentItemElement);
      this.register(controlNode.instance, indexToAdd >= 0 ? indexToAdd : void 0);
      if (element !== null && controlNode.instance !== null) {
        this.addToOrderTracking(controlNode.instance, dataItem, element);
      }
    }
    /**
     * An event called when data is removed from the subscription.
     * @param index The index that the data was removed at.
     * @param data The data that was removed;
     */
    onDataRemoved(index, data) {
      if (index >= 0 && index < this.length) {
        if (Array.isArray(data)) {
          for (let i = 0; i < data.length; i++) {
            const dataItem = data[i];
            this.removeDataItem(dataItem, index);
          }
        } else if (data !== void 0) {
          this.removeDataItem(data, index);
        }
        this.updateOrder();
      }
    }
    /**
     * Removes a data item from the control list.
     * @param data The data item to remove.
     * @param index The index of the data that was removed.
     */
    removeDataItem(data, index) {
      if (this.dataToControlMap !== void 0 && this.registeredControls !== void 0) {
        const control2 = this.dataToControlMap.get(data);
        if (control2 !== void 0) {
          index = this.registeredControls.indexOf(control2);
        }
      }
      let control;
      if (this.registeredControls !== void 0) {
        control = this.registeredControls[index];
      }
      this.unregister(index);
      this.removeDomNode(index);
      this.removeFromOrderTracking(data);
      control === null || control === void 0 ? void 0 : control.destroy();
    }
    /**
     * An event called when the data is cleared in the subscription.
     */
    onDataCleared() {
      let controls;
      if (this.registeredControls !== void 0) {
        controls = [...this.registeredControls];
      }
      this.clearRegistered();
      this.itemsContainer.instance.innerHTML = "";
      this.clearOrderTracking();
      if (controls !== void 0) {
        for (let i = 0; i < controls.length; i++) {
          controls[i].destroy();
        }
      }
      if (this.props.onItemSelected) {
        this.props.onItemSelected(null, null, -1);
      }
    }
    /**
     * Adds a data item to element order tracking information.
     * @param control The index to add the data item at.
     * @param data The data to add tracking information for.
     * @param element The DOM element to associate with this data item.
     */
    addToOrderTracking(control, data, element) {
      if (this.controlToElementMap !== void 0 && this.dataToControlMap !== void 0 && this.controlToDataMap !== void 0) {
        this.dataToControlMap.set(data, control);
        this.controlToElementMap.set(control, element);
        this.controlToDataMap.set(control, data);
      }
    }
    /**
     * Removes a data item from element order tracking information.
     * @param data The data item to remove order tracking information for.
     */
    removeFromOrderTracking(data) {
      if (this.controlToElementMap !== void 0 && this.dataToControlMap !== void 0 && this.controlToDataMap !== void 0) {
        const control = this.dataToControlMap.get(data);
        if (control !== void 0) {
          this.dataToControlMap.delete(data);
          this.controlToElementMap.delete(control);
          this.controlToDataMap.delete(control);
        }
      }
    }
    /**
     * Clears all data item element order tracking information.
     */
    clearOrderTracking() {
      if (this.controlToElementMap !== void 0 && this.dataToControlMap !== void 0 && this.controlToDataMap !== void 0) {
        this.dataToControlMap.clear();
        this.controlToElementMap.clear();
        this.controlToDataMap.clear();
      }
    }
    /**
     * Updates the order of data items in the list by the props supplied
     * comparison function, if one exists.
     */
    updateOrder() {
      if (this.controlToElementMap !== void 0 && this.dataToControlMap !== void 0 && this.controlToDataMap !== void 0) {
        const itemsContainer = this.itemsContainer.instance;
        if (this.registeredControls !== void 0) {
          const selectedControl = this.getChild(this.getFocusedIndex());
          this.registeredControls.sort(this.sortControls);
          if (!this.orderUnchanged()) {
            for (let i = 0; i < this.registeredControls.length; i++) {
              const element = this.controlToElementMap.get(this.registeredControls[i]);
              if (element !== void 0) {
                itemsContainer.appendChild(element);
              }
            }
            this.currentControlOrder = [...this.registeredControls];
            if (selectedControl !== void 0) {
              this.focusedIndex = this.registeredControls.indexOf(selectedControl);
              this.ensureIndexInView(this.focusedIndex);
            }
          }
        }
      }
    }
    /**
     * Checks whether or not the control order is the same as it was previously.
     * @returns True if the order is the same, false otherwise.
     */
    orderUnchanged() {
      if (this.registeredControls !== void 0 && this.currentControlOrder !== void 0) {
        if (this.registeredControls.length === this.currentControlOrder.length) {
          return this.registeredControls.every((control, i) => this.currentControlOrder && control === this.currentControlOrder[i]);
        }
        return false;
      }
      return true;
    }
    /**
     * Removes a dom node from the collection at the specified index.
     * @param index The index to remove.
     */
    removeDomNode(index) {
      const child = this.itemsContainer.instance.childNodes.item(index);
      this.itemsContainer.instance.removeChild(child);
    }
    /**
     * Adds a list rendered dom node to the collection.
     * @param node Item to render and add.
     * @param index The index to add at.
     * @param el The element to add to.
     * @returns The created DOM element.
     */
    renderToDom(node, index, el) {
      if (el !== null) {
        node && el && FSComponent.renderBefore(node, el);
        return el.previousElementSibling;
      } else {
        el = this.itemsContainer.instance;
        node && el && FSComponent.render(node, el);
        return this.itemsContainer.instance.lastElementChild;
      }
    }
    /**
     * Scrolls to an item.
     * @param index is the index of the list item to scroll to.
     * @param focusPosition The focus position to apply to children of the item being scrolled to.
     */
    scrollToIndex(index, focusPosition = FocusPosition.First) {
      const control = this.getChild(index);
      if (control !== void 0) {
        control.focus(focusPosition);
      }
    }
    /**
     * Ensures an indexed list item is in view.
     * @param index The index of the list item.
     * @param pinDirection The end of the container which the element should be pinned to.
     */
    ensureIndexInView(index, pinDirection = "none") {
      var _a, _b;
      const el = this.getElement(index);
      const container = (_b = (_a = this.props.scrollContainer) === null || _a === void 0 ? void 0 : _a.getOrDefault()) !== null && _b !== void 0 ? _b : this.itemsContainer.getOrDefault();
      if (el && container && !this.props.disableContainerScroll) {
        ScrollUtils.ensureInView(el, container, pinDirection);
      }
    }
    /**
     * Gets an element at the specified data/control index.
     * @param index The data/control index to get the element for.
     * @returns The request HTML element.
     */
    getElement(index) {
      var _a;
      return (_a = this.itemsContainer.instance.children[index]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the data object related to the selected DOM element.
     * @param index The index of the data to get.
     * @returns The selected item, if found.
     */
    getData(index) {
      var _a;
      const control = this.getChild(index);
      if (this.controlToDataMap !== void 0 && control !== void 0) {
        return (_a = this.controlToDataMap.get(control)) !== null && _a !== void 0 ? _a : null;
      }
      if (index > -1) {
        return this.props.data.get(index);
      }
      return null;
    }
    /**
     * Get the selected HTMLElement.
     * @returns The selected element, if found.
     */
    getSelectedElement() {
      var _a;
      return (_a = this.itemsContainer.instance.children[this.getSelectedIndex()]) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Gets the index of the currently selected element.
     * @returns Selected element index. Returns -1 if nothing found.
     */
    getSelectedIndex() {
      if (this.length > 0) {
        return this.getFocusedIndex();
      }
      return -1;
    }
    /**
     * Gets the instance of the node at the specified index.
     * @param index The index to get the instance for.
     * @returns The node instance of specified type.
     */
    getChildInstance(index) {
      const child = this.getChild(index);
      if (child !== void 0) {
        return child;
      }
      return null;
    }
    /** @inheritdoc */
    onBlurred(source) {
      if (this.props.onItemSelected) {
        this.props.onItemSelected(null, null, -1);
      }
      super.onBlurred(source);
    }
    /**
     * Responds to when a list item is focused.
     */
    onItemFocused() {
      const index = this.getFocusedIndex();
      this.ensureIndexInView(index);
      if (this.props.onItemSelected) {
        const control = this.getChild(index);
        if (control !== void 0 && control.isFocused) {
          let data = this.props.data.get(index);
          if (this.controlToDataMap !== void 0) {
            data = this.controlToDataMap.get(control);
          }
          if (data !== void 0) {
            this.props.onItemSelected(data, control, index);
          }
        }
      }
    }
    /**
     * Renders the complete list of data items as control components.
     */
    renderList() {
      this.itemsContainer.instance.textContent = "";
      this.onDataAdded(0, this.props.data.getArray());
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent(
        "div",
        { class: `ui-control-list ${(_a = this.props.class) !== null && _a !== void 0 ? _a : ""}`, ref: this.el },
        FSComponent.buildComponent("div", { ref: this.itemsContainer, class: "ui-control-list-content" }),
        !this.props.hideScrollbar && this.renderScrollbar()
      );
    }
  };
  var HorizonLayer = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this._isAttached = false;
      this._isVisible = true;
    }
    /**
     * Checks whether this layer is attached to a horizon component.
     * @returns Whether this layer is attached to a horizon component.
     */
    isAttached() {
      return this._isAttached;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
      return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
      if (this._isVisible === val) {
        return;
      }
      this._isVisible = val;
      if (this._isAttached) {
        this.onVisibilityChanged(val);
      }
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
    }
    /**
     * This method is called when this layer is attached to its parent horizon component.
     */
    onAttached() {
      this._isAttached = true;
      if (!this._isVisible) {
        this.onVisibilityChanged(this._isVisible);
      }
    }
    /**
     * This method is called when this layer's parent horizon component is awakened.
     */
    onWake() {
    }
    /**
     * This method is called when this layer's parent horizon component is put to sleep.
     */
    onSleep() {
    }
    /**
     * This method is called when this layer's horizon projection changes.
     * @param projection This layer's horizon projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onProjectionChanged(projection, changeFlags) {
    }
    /**
     * This method is called once every update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
    }
    /**
     * This method is called when this layer is detached from its parent horizon component.
     */
    onDetached() {
      this._isAttached = false;
    }
  };
  var HorizonProjectionChangeType;
  (function(HorizonProjectionChangeType2) {
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Position"] = 1] = "Position";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Altitude"] = 2] = "Altitude";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Heading"] = 4] = "Heading";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Pitch"] = 8] = "Pitch";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Roll"] = 16] = "Roll";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Offset"] = 32] = "Offset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedSize"] = 64] = "ProjectedSize";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Fov"] = 128] = "Fov";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["FovEndpoints"] = 256] = "FovEndpoints";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ScaleFactor"] = 512] = "ScaleFactor";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedOffset"] = 1024] = "ProjectedOffset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["OffsetCenterProjected"] = 2048] = "OffsetCenterProjected";
  })(HorizonProjectionChangeType || (HorizonProjectionChangeType = {}));
  var HorizonProjection = class {
    /**
     * Constructor.
     * @param projectedWidth The initial projected width of the projection, in pixels.
     * @param projectedHeight The initial projected height of the projection, in pixels.
     * @param fov The initial field of view of the projection, in degrees.
     */
    constructor(projectedWidth, projectedHeight, fov) {
      this.position = new GeoPoint(0, 0);
      this.altitude = 0;
      this.heading = 0;
      this.roll = 0;
      this.pitch = 0;
      this.offset = Vec3Math.create();
      this.fovEndpoints = VecNMath.create(4, 0.5, 0, 0.5, 1);
      this.scaleFactor = 1;
      this.projectedOffset = Vec2Math.create();
      this.offsetCenterProjected = Vec2Math.create();
      this.positionAngleTransforms = [new Transform3D(), new Transform3D()];
      this.altitudeTransform = new Transform3D();
      this.positionAltitudeTransforms = [...this.positionAngleTransforms, this.altitudeTransform];
      this.positionTransform = new Transform3D();
      this.planeAngles = Vec3Math.create();
      this.planeAngleTransforms = [new Transform3D(), new Transform3D(), new Transform3D()];
      this.planeTransform = new Transform3D();
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create();
      this.perspectiveTransform = new TransformPerspective();
      this.oldParameters = {
        position: new GeoPoint(0, 0),
        altitude: 0,
        heading: 0,
        pitch: 0,
        roll: 0,
        offset: Vec3Math.create(),
        projectedSize: Vec2Math.create(),
        fov: 0,
        fovEndpoints: VecNMath.create(4),
        scaleFactor: 1,
        projectedOffset: Vec2Math.create(),
        offsetCenterProjected: Vec2Math.create()
      };
      this.queuedParameters = {};
      this.updateQueued = false;
      this.changeEvent = new SubEvent();
      this.projectedSize = Vec2Math.create(projectedWidth, projectedHeight);
      this.fov = fov;
      this.recompute();
    }
    /**
     * Gets the position of this projection.
     * @returns The position of this projection.
     */
    getPosition() {
      return this.position.readonly;
    }
    /**
     * Gets the altitude of this projection, in meters above mean sea level.
     * @returns The altitude of this projection, in meters above mean sea level.
     */
    getAltitude() {
      return this.altitude;
    }
    /**
     * Gets the true heading of this projection, in degrees.
     * @returns The true heading of this projection, in degrees.
     */
    getHeading() {
      return this.heading;
    }
    /**
     * Gets the pitch of this projection, in degrees.
     * @returns The pitch of this projection, in degrees.
     */
    getPitch() {
      return this.pitch;
    }
    /**
     * Gets the roll of this projection, in degrees.
     * @returns The roll of this projection, in degrees.
     */
    getRoll() {
      return this.roll;
    }
    /**
     * Gets the size of the projected window, as `[width, height]` in pixels.
     * @returns The size of the projected window, as `[width, height]` in pixels.
     */
    getProjectedSize() {
      return this.projectedSize;
    }
    /**
     * Gets the field of view of this projection, in degrees.
     * @returns The field of view of this projection, in degrees.
     */
    getFov() {
      return this.fov;
    }
    /**
     * Gets the projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each component
     * expressed relative to the width or height of the projected window.
     * @returns The projected endpoints at which the field of view is measured, as `[x1, y1, x2, y2]`, with each
     * component expressed relative to the width or height of the projected window.
     */
    getFovEndpoints() {
      return this.fovEndpoints;
    }
    /**
     * Gets the focal length of this projection, in meters. The focal length is set such that one meter at a distance
     * from the camera equal to the focal length subtends an angle equal to the field of view.
     * @returns The focal length of this projection, in meters.
     */
    getFocalLength() {
      return this.surfacePos[2];
    }
    /**
     * Gets the nominal scale factor of this projection. At a distance from the camera equal to the focal length, one
     * meter will be projected to a number of pixels equal to the nominal scale factor.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
      return this.scaleFactor;
    }
    /**
     * Gets the projected offset of this projection's center, as `[x, y]` in pixels.
     * @returns The projected offset of this projection's center, as `[x, y]` in pixels.
     */
    getProjectedOffset() {
      return this.projectedOffset;
    }
    /**
     * Gets the projected center of this projection, including offset, as `[x, y]` in pixels.
     * @returns The projected center of this projection, including offset, as `[x, y]` in pixels.
     */
    getOffsetCenterProjected() {
      return this.offsetCenterProjected;
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
      Vec2Math.set(this.projectedSize[0] / 2 + this.projectedOffset[0], this.projectedSize[1] / 2 + this.projectedOffset[1], this.offsetCenterProjected);
      this.positionAngleTransforms[0].toRotationZ(-this.position.lon * Avionics.Utils.DEG2RAD);
      this.positionAngleTransforms[1].toRotationY(this.position.lat * Avionics.Utils.DEG2RAD);
      this.altitudeTransform.toTranslation(-(UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + this.altitude), 0, 0);
      Transform3D.concat(this.positionTransform, this.positionAltitudeTransforms);
      this.planeAngles[0] = -this.heading * Avionics.Utils.DEG2RAD;
      this.planeAngles[1] = this.pitch * Avionics.Utils.DEG2RAD;
      this.planeAngles[2] = this.roll * Avionics.Utils.DEG2RAD;
      this.planeAngleTransforms[0].toRotationZ(this.planeAngles[2]);
      this.planeAngleTransforms[1].toRotationY(this.planeAngles[1]);
      this.planeAngleTransforms[2].toRotationX(this.planeAngles[0]);
      Transform3D.concat(this.planeTransform, this.planeAngleTransforms);
      this.planeTransform.apply(this.offset, this.cameraPos);
      this.scaleFactor = Math.hypot(this.fovEndpoints[2] * this.projectedSize[0] - this.fovEndpoints[0] * this.projectedSize[0], this.fovEndpoints[3] * this.projectedSize[1] - this.fovEndpoints[1] * this.projectedSize[1]);
      this.surfacePos[2] = 1 / (2 * Math.tan(this.fov * 0.5 * Avionics.Utils.DEG2RAD));
      this.perspectiveTransform.set(this.cameraPos, this.planeTransform, this.surfacePos);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
      var _a, _b, _c, _d, _e;
      this.storeParameters(this.oldParameters);
      parameters.position !== void 0 && this.position.set(parameters.position);
      this.altitude = (_a = parameters.altitude) !== null && _a !== void 0 ? _a : this.altitude;
      this.heading = (_b = parameters.heading) !== null && _b !== void 0 ? _b : this.heading;
      this.pitch = (_c = parameters.pitch) !== null && _c !== void 0 ? _c : this.pitch;
      this.roll = (_d = parameters.roll) !== null && _d !== void 0 ? _d : this.roll;
      parameters.offset !== void 0 && this.offset.set(parameters.offset);
      parameters.projectedSize !== void 0 && this.projectedSize.set(parameters.projectedSize);
      this.fov = (_e = parameters.fov) !== null && _e !== void 0 ? _e : this.fov;
      parameters.fovEndpoints !== void 0 && this.fovEndpoints.set(parameters.fovEndpoints);
      parameters.projectedOffset !== void 0 && this.projectedOffset.set(parameters.projectedOffset);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        this.changeEvent.notify(this, changeFlags);
      }
    }
    /**
     * Sets the projection parameters to be applied when `applyQueued()` is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
      record.position.set(this.position);
      record.altitude = this.altitude;
      record.heading = this.heading;
      record.pitch = this.pitch;
      record.roll = this.roll;
      record.offset.set(this.offset);
      record.projectedSize.set(this.projectedSize);
      record.fov = this.fov;
      record.fovEndpoints.set(this.fovEndpoints);
      record.scaleFactor = this.scaleFactor;
      record.projectedOffset.set(this.projectedOffset);
      record.offsetCenterProjected.set(this.offsetCenterProjected);
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
      return (oldParameters.position.equals(this.position) ? 0 : HorizonProjectionChangeType.Position) | (oldParameters.altitude === this.altitude ? 0 : HorizonProjectionChangeType.Altitude) | (oldParameters.heading === this.heading ? 0 : HorizonProjectionChangeType.Heading) | (oldParameters.pitch === this.pitch ? 0 : HorizonProjectionChangeType.Pitch) | (oldParameters.roll === this.roll ? 0 : HorizonProjectionChangeType.Roll) | (Vec3Math.equals(oldParameters.offset, this.offset) ? 0 : HorizonProjectionChangeType.Offset) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : HorizonProjectionChangeType.ProjectedSize) | (oldParameters.fov === this.fov ? 0 : HorizonProjectionChangeType.Fov) | (VecNMath.equals(oldParameters.fovEndpoints, this.fovEndpoints) ? 0 : HorizonProjectionChangeType.ProjectedOffset) | (Vec2Math.equals(oldParameters.projectedOffset, this.projectedOffset) ? 0 : HorizonProjectionChangeType.ProjectedOffset);
    }
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.scaleFactor === this.scaleFactor ? 0 : HorizonProjectionChangeType.ScaleFactor) | (Vec2Math.equals(oldParameters.offsetCenterProjected, this.offsetCenterProjected) ? 0 : HorizonProjectionChangeType.OffsetCenterProjected);
    }
    /**
     * Subscribes a change listener to this projection. The listener will be called every time this projection changes.
     * A listener can be subscribed multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to subscribe.
     * @returns The new subscription.
     */
    onChange(listener) {
      return this.changeEvent.on(listener);
    }
    /**
     * Projects a point represented by a set of lat/lon coordinates and altitude.
     * @param position The lat/lon coordinates of the point to project.
     * @param altitude The altitude of the point to project, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    project(position, altitude, out) {
      const vec = GeoPoint.sphericalToCartesian(position, HorizonProjection.vec3Cache[0]);
      Vec3Math.multScalar(vec, UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + altitude, vec);
      this.positionTransform.apply(vec, vec);
      return this.projectRelativeVec(vec, out);
    }
    /**
     * Projects a point relative to the position of the airplane in spherical space.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The geodetic horizontal distance from the point to project to the airplane, in meters.
     * @param height The geodetic height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeSpherical(bearing, distance, height, out) {
      return this.project(this.position.offset(bearing, UnitType.METER.convertTo(distance, UnitType.GA_RADIAN), HorizonProjection.geoPointCache[0]), this.altitude + height, out);
    }
    /**
     * Projects a point relative to the position of the airplane in Euclidean space. The coordinate system is defined at
     * the position of the airplane, with the vertical axis perpendicular to the surface of the Earth and the horizontal
     * plane parallel to the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing from the airplane to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the airplane, in meters.
     * @param height The Euclidean height of the point to project relative to the airplane, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a 3D vector defined relative to the airplane, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    projectRelativeVec(vec, out) {
      this.perspectiveTransform.apply(vec, out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    /**
     * Projects a point relative to the position of the projection camera in Euclidean space. The coordinate system is
     * defined at the position of the camera, with the vertical axis perpendicular to the surface of the Earth and the
     * horizontal plane parallel to the Earth's surface at the point directly underneath the airplane.
     * @param bearing The true bearing from the camera to the point to project, in degrees.
     * @param distance The Euclidean horizontal distance from the point to project to the camera, in meters.
     * @param height The Euclidean height of the point to project relative to the camera, in meters.
     * @param out The 2D vector to which to write the result.
     * @returns The projected point, as `[x, y]` in pixels.
     */
    projectCameraRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    /**
     * Projects a 3D vector defined relative to the camera, as `[x, y, z]` in meters with the coordinate system
     * defined as follows for an airplane with heading/roll/pitch of zero degrees:
     * * The positive z axis points in the direction of the airplane.
     * * The positive x axis points directly upward.
     * * The positive y axis points to the right.
     * @param vec The vector to project.
     * @param out The 2D vector to which to write the result.
     * @returns The projected vector.
     */
    projectCameraRelativeVec(vec, out) {
      this.perspectiveTransform.apply(Vec3Math.add(vec, this.perspectiveTransform.getCameraPosition(), HorizonProjection.cameraRelativeVec3Cache[0]), out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isInProjectedBounds(point, arg2, arg3) {
      let bounds;
      if (point instanceof Float64Array) {
        bounds = arg2;
      } else {
        point = this.project(point, arg2, HorizonProjection.vec2Cache[0]);
        bounds = arg3;
      }
      const x = point[0];
      const y = point[1];
      if (!isFinite(x) || !isFinite(y)) {
        return false;
      }
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      return x >= left && x <= right && y >= top && y <= bottom;
    }
  };
  HorizonProjection.vec2Cache = [Vec2Math.create()];
  HorizonProjection.vec3Cache = [Vec3Math.create()];
  HorizonProjection.geoPointCache = [new GeoPoint(0, 0)];
  HorizonProjection.cameraRelativeVec3Cache = [Vec3Math.create()];
  var HorizonComponent = class extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
      var _a;
      super(props);
      this.layerEntries = [];
      this.lastUpdateTime = 0;
      this._isAwake = true;
      this.projectedSize = SubscribableUtils.toSubscribable(this.props.projectedSize, true);
      this.fov = SubscribableUtils.toSubscribable(this.props.fov, true);
      if (this.props.fovEndpoints !== void 0) {
        this.fovEndpoints = SubscribableUtils.toSubscribable(this.props.fovEndpoints, true);
      }
      if (this.props.projectedOffset !== void 0) {
        this.projectedOffset = SubscribableUtils.toSubscribable(this.props.projectedOffset, true);
      }
      const initialSize = this.projectedSize.get();
      const initialFov = this.fov.get();
      if (this.props.projection !== void 0) {
        this.props.projection.set({ projectedSize: initialSize, fov: initialFov });
      }
      this.projection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new HorizonProjection(initialSize[0], initialSize[1], initialFov);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
      return this.projection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this horizon is awake.
     */
    get isAwake() {
      return this._isAwake;
    }
    /**
     * Puts this horizon to sleep. While asleep, this horizon will not be updated.
     */
    sleep() {
      this.setAwakeState(false);
    }
    /**
     * Wakes this horizon, allowing it to be updated.
     */
    wake() {
      this.setAwakeState(true);
    }
    /**
     * Sets this horizon's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this horizon's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
      if (this._isAwake === isAwake) {
        return;
      }
      this._isAwake = isAwake;
      this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
      var _a, _b;
      this.projection.onChange(this.onProjectionChanged.bind(this));
      this.projectedSizeSub = this.projectedSize.sub((size) => {
        this.projection.set({ projectedSize: size });
      }, true);
      this.fovSub = this.fov.sub((fov) => {
        this.projection.set({ fov });
      }, true);
      this.fovEndpointsSub = (_a = this.fovEndpoints) === null || _a === void 0 ? void 0 : _a.sub((fovEndpoints) => {
        this.projection.set({ fovEndpoints });
      }, true);
      this.projectedOffsetSub = (_b = this.projectedOffset) === null || _b === void 0 ? void 0 : _b.sub((projectedOffset) => {
        this.projection.set({ projectedOffset });
      }, true);
      this.attachLayers(thisNode);
      if (!this._isAwake) {
        this.sleepLayers();
      }
    }
    /**
     * Scans this component's VNode sub-tree for HorizonLayer components and attaches them when found. Only the top-most
     * level of HorizonLayer components are attached; layers that are themselves children of other layers are not
     * attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
      FSComponent.visitNodes(thisNode, (node) => {
        if (node.instance instanceof HorizonLayer) {
          this.attachLayer(node.instance);
          return true;
        }
        return false;
      });
    }
    /**
     * This method is called when this horizon is awakened.
     */
    onWake() {
      this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this horizon's layers.
     */
    wakeLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onWake();
      }
    }
    /**
     * This method is called when this horizon is put to sleep.
     */
    onSleep() {
      this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this horizon's layers.
     */
    sleepLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onSleep();
      }
    }
    /**
     * This method is called when this horizon's projection changes.
     * @param projection This horizon's projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onProjectionChanged(projection, changeFlags) {
      if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
        this.onProjectedSizeChanged();
      }
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onProjectionChanged(projection, changeFlags);
      }
    }
    /**
     * This method is called when the size of this horizon's projected window changes.
     */
    onProjectedSizeChanged() {
    }
    /**
     * Attaches a layer to this horizon component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
      if (this.layerEntries.findIndex((entry2) => entry2.layer === layer) >= 0) {
        return;
      }
      const entry = new LayerEntry$1(layer);
      this.layerEntries.push(entry);
      entry.attach();
    }
    /**
     * Detaches a layer from this horizon component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
      const index = this.layerEntries.findIndex((entry) => entry.layer === layer);
      if (index >= 0) {
        const entry = this.layerEntries[index];
        entry.detach();
        this.layerEntries.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    /**
     * Updates this horizon.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
      if (!this._isAwake) {
        return;
      }
      this.onUpdated(time, time - this.lastUpdateTime);
      this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
      this.updateLayers(time, elapsed);
    }
    /**
     * Updates this horizon's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].update(time);
      }
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }, this.props.children);
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b, _c, _d;
      super.destroy();
      (_a = this.projectedSizeSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.fovSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.fovEndpointsSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.projectedOffsetSub) === null || _d === void 0 ? void 0 : _d.destroy();
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].destroy();
      }
    }
  };
  var LayerEntry$1 = class LayerEntry {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
      this.layer = layer;
      this.updatePeriod = 0;
      this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
      var _a, _b;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
        const clamped = Math.max(0, freq);
        this.updatePeriod = clamped === 0 ? 0 : 1e3 / clamped;
      }, true);
      this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
      if (currentTime - this.lastUpdated >= this.updatePeriod) {
        this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
        this.lastUpdated = currentTime;
      }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
      var _a;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
      this.detach();
      this.layer.destroy();
    }
  };
  var HorizonCanvasLayerCanvasInstanceClass = class {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
      this.canvas = canvas;
      this.context = context;
      this.isDisplayed = isDisplayed;
    }
    /** @inheritdoc */
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    /** @inheritdoc */
    reset() {
      const width = this.canvas.width;
      this.canvas.width = 0;
      this.canvas.width = width;
    }
  };
  var HorizonCanvasLayer = class extends HorizonLayer {
    constructor() {
      super(...arguments);
      this.displayCanvasRef = FSComponent.createRef();
      this.width = 0;
      this.height = 0;
      this.displayCanvasContext = null;
      this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
      if (!this._display) {
        throw new Error("HorizonCanvasLayer: attempted to access display before it was initialized");
      }
      return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
      if (!this._buffer) {
        throw new Error("HorizonCanvasLayer: attempted to access buffer before it was initialized");
      }
      return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
      return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
      return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
      return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
      return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
      if (width === this.width) {
        return;
      }
      this.width = width;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
      if (height === this.height) {
        return;
      }
      this.height = height;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
      if (!this.isInit || !this.props.useBuffer) {
        return;
      }
      this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
      this.displayCanvasContext = this.displayCanvasRef.instance.getContext("2d");
    }
    /** @inheritdoc */
    onVisibilityChanged() {
      if (this.isInit) {
        this.updateCanvasVisibility();
      }
    }
    /** @inheritdoc */
    onAttached() {
      super.onAttached();
      this.initCanvasInstances();
      this.isInit = true;
      this.updateCanvasVisibility();
      this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
      this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
      if (this.props.useBuffer) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        this._buffer = this.createCanvasInstance(canvas, context, false);
      }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
      return new HorizonCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
      const displayCanvas = this.display.canvas;
      displayCanvas.width = this.width;
      displayCanvas.height = this.height;
      displayCanvas.style.width = `${this.width}px`;
      displayCanvas.style.height = `${this.height}px`;
      if (this._buffer) {
        const bufferCanvas = this._buffer.canvas;
        bufferCanvas.width = this.width;
        bufferCanvas.height = this.height;
      }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", width: "0", height: "0", style: "position: absolute;" }, " ");
    }
  };
  var HorizonSyncedCanvasLayer = class extends HorizonCanvasLayer {
    /** @inheritdoc */
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.projection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the horizon projected window.
     * @param projectedSize The size of the horizon projected window.
     */
    updateFromProjectedSize(projectedSize) {
      this.setWidth(projectedSize[0]);
      this.setHeight(projectedSize[1]);
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = "0px";
      displayCanvas.style.top = "0px";
    }
    /** @inheritdoc */
    onProjectionChanged(projection, changeFlags) {
      if (BitFlags.isAll(changeFlags, HorizonProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(projection.getProjectedSize());
      }
    }
  };
  var MapLayer = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this._isVisible = true;
    }
    /**
     * Checks whether this layer is visible.
     * @returns whether this layer is visible.
     */
    isVisible() {
      return this._isVisible;
    }
    /**
     * Sets this layer's visibility.
     * @param val Whether this layer should be visible.
     */
    setVisible(val) {
      if (this._isVisible === val) {
        return;
      }
      this._isVisible = val;
      this.onVisibilityChanged(val);
    }
    /**
     * This method is called when this layer's visibility changes.
     * @param isVisible Whether the layer is now visible.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
    }
    /**
     * This method is called when this layer is attached to its parent map component.
     */
    onAttached() {
    }
    /**
     * This method is called when this layer's parent map is woken.
     */
    onWake() {
    }
    /**
     * This method is called when this layer's parent map is put to sleep.
     */
    onSleep() {
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection - this layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    /**
     * This method is called once every map update cycle.
     * @param time The current time as a UNIX timestamp.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
    }
    /**
     * This method is called when this layer is detached from its parent map component.
     */
    onDetached() {
    }
  };
  var MapProjectionChangeType;
  (function(MapProjectionChangeType2) {
    MapProjectionChangeType2[MapProjectionChangeType2["Target"] = 1] = "Target";
    MapProjectionChangeType2[MapProjectionChangeType2["Center"] = 2] = "Center";
    MapProjectionChangeType2[MapProjectionChangeType2["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType2[MapProjectionChangeType2["Range"] = 8] = "Range";
    MapProjectionChangeType2[MapProjectionChangeType2["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType2[MapProjectionChangeType2["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType2[MapProjectionChangeType2["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedResolution"] = 256] = "ProjectedResolution";
  })(MapProjectionChangeType || (MapProjectionChangeType = {}));
  var MapProjection = class {
    /**
     * Creates a new map projection.
     * @param projectedWidth The initial width of the projection window, in pixels.
     * @param projectedHeight The initial height of the projection window, in pixels.
     */
    constructor(projectedWidth, projectedHeight) {
      this.target = new GeoPoint(0, 0);
      this.targetProjectedOffset = new Float64Array(2);
      this.targetProjected = new Float64Array(2);
      this.range = 1;
      this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]);
      this.projectedSize = new Float64Array(2);
      this.center = new GeoPoint(0, 0);
      this.centerProjected = new Float64Array(2);
      this.projectedRange = 0;
      this.widthRange = 0;
      this.heightRange = 0;
      this.oldParameters = {
        target: new GeoPoint(0, 0),
        center: new GeoPoint(0, 0),
        targetProjected: new Float64Array(2),
        range: 1,
        rangeEndpoints: new Float64Array(4),
        scaleFactor: 1,
        rotation: 0,
        projectedSize: new Float64Array(2),
        projectedResolution: 0
      };
      this.queuedParameters = Object.assign({}, this.oldParameters);
      this.updateQueued = false;
      this.changeListeners = [];
      Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
      this.geoProjection = new MercatorProjection();
      Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
      this.targetProjected.set(this.centerProjected);
      this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
      this.recompute();
    }
    /**
     * Gets this map projection's GeoProjection instance.
     * @returns This map projection's GeoProjection instance.
     */
    getGeoProjection() {
      return this.geoProjection;
    }
    /**
     * Gets the target geographic point of this projection. The target is guaranteed to be projected to a specific
     * point in the projected window defined by the center of the window plus the target projected offset.
     * @returns The target geographic point of this projection.
     */
    getTarget() {
      return this.target.readonly;
    }
    /**
     * Gets the projected offset from the center of the projected window of the target of this projection.
     * @returns The projected offset from the center of the projected window of the target of this projection.
     */
    getTargetProjectedOffset() {
      return this.targetProjectedOffset;
    }
    /**
     * Gets the projected location of the target of this projection.
     * @returns The projected location of the target of this projection.
     */
    getTargetProjected() {
      return this.targetProjected;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured between the projection's two range endpoints.
     * @returns The range of this projection, in great-arc radians.
     */
    getRange() {
      return this.range;
    }
    /**
     * Gets the endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`. Each
     * component is expressed in relative projected coordinates, where `0` is the left/top of the projected window, and
     * `1` is the right/bottom of the projected window.
     * @returns The endpoints used to measure the range of the projection, as a 4-tuple `[relX1, relY1, relX2, relY2]`.
     */
    getRangeEndpoints() {
      return this.rangeEndpoints;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the center-left to the center-right of
     * the projected window.
     * @returns The range of this projection's projected window width, in great-arc radians.
     */
    getWidthRange() {
      return this.widthRange;
    }
    /**
     * Gets the range of this projection, in great-arc radians, as measured from the top-center to the bottom-center of
     * the projected window.
     * @returns The range of this projection's projected window height, in great-arc radians.
     */
    getHeightRange() {
      return this.heightRange;
    }
    /**
     * Gets the nominal scale factor of this projection. At a scale factor of 1, a distance of one great-arc radian will
     * be projected to a distance of one pixel.
     * @returns The nominal scale factor of this projection.
     */
    getScaleFactor() {
      return this.geoProjection.getScaleFactor();
    }
    /**
     * Gets the post-projected (planar) rotation angle of this projection in radians.
     * @returns The post-projected rotation angle of this projection.
     */
    getRotation() {
      return this.geoProjection.getPostRotation();
    }
    /**
     * Gets the size of the projected window, in pixels.
     * @returns The size of the projected window.
     */
    getProjectedSize() {
      return this.projectedSize;
    }
    /**
     * Gets the geographic point located at the center of this projection's projected window.
     * @returns The geographic point located at the center of this projection's projected window.
     */
    getCenter() {
      return this.center.readonly;
    }
    /**
     * Gets the center of this projection's projected window.
     * @returns The center of this projection's projected window.
     */
    getCenterProjected() {
      return this.centerProjected;
    }
    /**
     * Gets the average resolution, in great-arc radians per pixel, of the projected map along a line between the range
     * endpoints.
     * @returns The average resolution of the projected map along a line between the range endpoints.
     */
    getProjectedResolution() {
      return this.range / this.projectedRange;
    }
    /**
     * Calculates the true range of this projection, in great-arc radians, given a hypothetical projected center point.
     * @param centerProjected The projected location of the hypothetical center point to use for the calculation.
     * @returns The true range of this projection given the hypothetical projected center point.
     */
    calculateRangeAtCenter(centerProjected) {
      const endpoints = this.rangeEndpoints;
      const projectedWidth = this.projectedSize[0];
      const projectedHeight = this.projectedSize[1];
      const endpoint1 = MapProjection.tempVec2_3;
      endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
      endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
      const endpoint2 = MapProjection.tempVec2_4;
      endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
      endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
      const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
      const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
      return top.distance(bottom);
    }
    /**
     * Recomputes this projection's computed parameters.
     */
    recompute() {
      const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
      if (!isFinite(currentTargetProjected[0] + currentTargetProjected[1])) {
        const translation = this.geoProjection.getTranslation();
        if (isFinite(this.target.lat) && isFinite(this.target.lon) && isFinite(this.geoProjection.getPostRotation()) && isFinite(translation[0]) && isFinite(translation[1])) {
          this.geoProjection.setScaleFactor(MapProjection.DEFAULT_SCALE_FACTOR);
          this.geoProjection.setCenter(MapProjection.tempGeoPoint_1.set(0, 0));
          this.geoProjection.setPreRotation(Vec3Math.set(0, 0, 0, MapProjection.vec3Cache[0]));
        } else {
          return;
        }
      }
      const currentCenterProjected = MapProjection.tempVec2_2;
      currentCenterProjected.set(currentTargetProjected);
      currentCenterProjected[0] -= this.targetProjectedOffset[0];
      currentCenterProjected[1] -= this.targetProjectedOffset[1];
      let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
      let ratio = currentRange / this.range;
      if (!isFinite(ratio) || ratio === 0) {
        return;
      }
      let lastScaleFactor = this.geoProjection.getScaleFactor();
      let iterCount = 0;
      let ratioError = Math.abs(ratio - 1);
      let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
      while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
        this.geoProjection.setScaleFactor(ratio * lastScaleFactor);
        this.geoProjection.project(this.target, currentTargetProjected);
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        const newRatio = currentRange / this.range;
        const ratioDelta = newRatio - ratio;
        if (!isFinite(ratio) || ratio < 1 && ratioDelta <= 0 || ratio > 1 && ratioDelta >= 0) {
          this.geoProjection.setScaleFactor(lastScaleFactor);
        }
        lastScaleFactor = this.geoProjection.getScaleFactor();
        ratio = newRatio;
        const newRatioError = Math.abs(ratio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.invert(currentCenterProjected, this.center);
      this.geoProjection.setCenter(this.center);
      const preRotation = Vec3Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, 0, MapProjection.vec3Cache[0]);
      this.geoProjection.setPreRotation(preRotation);
      const width = this.projectedSize[0];
      const height = this.projectedSize[1];
      this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
      const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
      const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
      this.widthRange = this.geoDistance(left, right);
      const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
      const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
      this.heightRange = this.geoDistance(top, bottom);
    }
    /**
     * Sets this projection's parameters. Parameters not explicitly defined in the parameters argument will be left
     * unchanged.
     * @param parameters The new parameters.
     */
    set(parameters) {
      this.storeParameters(this.oldParameters);
      parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
      parameters.target && this.target.set(parameters.target);
      parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
      parameters.range !== void 0 && (this.range = parameters.range);
      parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
      parameters.rotation !== void 0 && this.geoProjection.setPostRotation(parameters.rotation);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        if (changeFlags !== 0) {
          this.notifyChangeListeners(changeFlags);
        }
      }
    }
    /**
     * Sets the projection parameters to be applied when applyQueued() is called.
     * @param parameters The parameter changes to queue.
     */
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    /**
     * Applies the set of queued projection changes, if any are queued.
     */
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    /**
     * Sets the size of the projected window.
     * @param size The new size, in pixels.
     */
    setProjectedSize(size) {
      this.projectedSize.set(size);
      Vec2Math.set(size[0] / 2, size[1] / 2, this.centerProjected);
      this.geoProjection.setTranslation(this.centerProjected);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Sets the projected offset from the center of the projected window of the target of this projection.
     * @param offset The new offset, in pixels.
     */
    setTargetProjectedOffset(offset) {
      this.targetProjectedOffset.set(offset);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    /**
     * Stores this projection's current parameters into a record.
     * @param record The record in which to store the parameters.
     */
    storeParameters(record) {
      record.target.set(this.target);
      record.center.set(this.center);
      record.targetProjected.set(this.targetProjected);
      record.range = this.range;
      record.rangeEndpoints.set(this.rangeEndpoints);
      record.scaleFactor = this.geoProjection.getScaleFactor();
      record.rotation = this.getRotation();
      record.projectedSize.set(this.projectedSize);
      record.projectedResolution = this.getProjectedResolution();
    }
    /**
     * Computes change flags given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags based on the specified old parameters.
     */
    computeChangeFlags(oldParameters) {
      return (oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target) | (Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected) | (oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range) | (VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints) | (oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize);
    }
    /**
     * Computes change flags for derived parameters given a set of old parameters.
     * @param oldParameters The old parameters.
     * @returns Change flags for derived parameters based on the specified old parameters.
     */
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center) | (oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor) | (oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    /**
     * Projects a set of lat/lon coordinates.
     * @param point The point to project.
     * @param out The vector to which to write the result.
     * @returns The projected point, as a vector.
     */
    project(point, out) {
      return this.geoProjection.project(point, out);
    }
    /**
     * Inverts a set of projected coordinates. This method will determine the geographic point whose projected location
     * is the equal to that described by a 2D position vector.
     * @param vec The 2D position vector describing the location of the projected coordinates.
     * @param out The point to which to write the result.
     * @returns The inverted point.
     */
    invert(vec, out) {
      return this.geoProjection.invert(vec, out);
    }
    /**
     * Checks whether a point falls within certain projected bounds. The point can be specified as either a GeoPoint
     * object or a 2D vector. If a GeoPoint object is supplied, it will be projected before the bounds check takes
     * place.
     * @param point The point to check.
     * @param bounds The bounds to check against, expressed as a vector ([left, top, right, bottom]). Defaults to the
     * bounds of the projected window.
     * @returns Whether the point falls within the projected bounds.
     */
    isInProjectedBounds(point, bounds) {
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      if (!(point instanceof Float64Array)) {
        point = this.project(point, MapProjection.tempVec2_2);
      }
      const x = point[0];
      const y = point[1];
      return x >= left && x <= right && y >= top && y <= bottom;
    }
    /**
     * Gets the geographic great-circle distance between two points in great-arc radians. The points can be specified as
     * either GeoPoint objects or 2D vectors. If 2D vectors are supplied, they are interpreted as projected points and
     * inverse projection will be used to convert them to geographic points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The geographic great-circle distance between the points.
     */
    geoDistance(point1, point2) {
      if (point1 instanceof Float64Array) {
        point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
      }
      if (point2 instanceof Float64Array) {
        point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
      }
      return point1.distance(point2);
    }
    /**
     * Gets the projected Euclidean distance between two points in pixels. The points can be specified as either GeoPoint
     * objects or 2D vectors. If GeoPoint objects are supplied, they will be projected to convert them to projected
     * points.
     * @param point1 The first point.
     * @param point2 The second point.
     * @returns The projected Euclidean distance between two points.
     */
    projectedDistance(point1, point2) {
      if (!(point1 instanceof Float64Array)) {
        point1 = this.project(point1, MapProjection.tempVec2_1);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = this.project(point2, MapProjection.tempVec2_2);
      }
      return Vec2Math.distance(point1, point2);
    }
    /**
     * Notifies all registered change listeners that this projection has been changed.
     * @param changeFlags The types of changes that were made.
     */
    notifyChangeListeners(changeFlags) {
      for (let i = 0; i < this.changeListeners.length; i++) {
        this.changeListeners[i](this, changeFlags);
      }
    }
    /**
     * Registers a change listener with this projection. The listener will be called every time this projection changes.
     * A listener can be registered multiple times; it will be called once for every time it is registered.
     * @param listener The change listener to register.
     */
    addChangeListener(listener) {
      this.changeListeners.push(listener);
    }
    /**
     * Removes a change listener from this projection. If the specified listener was registered multiple times, this
     * method will only remove one instance of the listener.
     * @param listener The listener to remove.
     * @returns Whether the listener was successfully removed.
     */
    removeChangeListener(listener) {
      const index = this.changeListeners.lastIndexOf(listener);
      if (index >= 0) {
        this.changeListeners.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
  };
  MapProjection.DEFAULT_SCALE_FACTOR = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
  MapProjection.SCALE_FACTOR_MAX_ITER = 20;
  MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
  MapProjection.tempVec2_1 = new Float64Array(2);
  MapProjection.tempVec2_2 = new Float64Array(2);
  MapProjection.tempVec2_3 = new Float64Array(2);
  MapProjection.tempVec2_4 = new Float64Array(2);
  MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
  MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);
  MapProjection.vec3Cache = [Vec3Math.create()];
  var MapComponent = class extends DisplayComponent {
    /** @inheritdoc */
    constructor(props) {
      var _a;
      super(props);
      this.layerEntries = [];
      this.lastUpdateTime = 0;
      this._isAwake = true;
      this.updateCycleHandler = this.update.bind(this);
      this.projectedSize = "isSubscribable" in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
      const initialSize = this.projectedSize.get();
      if (this.props.projection !== void 0) {
        this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
      }
      this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    /**
     * Gets the size of this map's projected window, in pixels.
     * @returns The size of this map's projected window.
     */
    getProjectedSize() {
      return this.mapProjection.getProjectedSize();
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this map is awake.
     */
    get isAwake() {
      return this._isAwake;
    }
    /**
     * Puts this map to sleep. While asleep, this map will not be updated.
     */
    sleep() {
      this.setAwakeState(false);
    }
    /**
     * Wakes this map, allowing it to be updated.
     */
    wake() {
      this.setAwakeState(true);
    }
    /**
     * Sets this map's awake state. If the new awake state is the same as the current state, nothing will happen.
     * Otherwise, this map's layers will be notified that the map has either been woken or put to sleep.
     * @param isAwake The new awake state.
     */
    setAwakeState(isAwake) {
      if (this._isAwake === isAwake) {
        return;
      }
      this._isAwake = isAwake;
      this._isAwake ? this.onWake() : this.onSleep();
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
      var _a;
      this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
      this.projectedSizeSub = this.projectedSize.sub((size) => {
        this.mapProjection.set({ projectedSize: size });
      });
      (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub((freq) => {
        var _a2;
        (_a2 = this.updateCycleSub) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.updateCycleSub = this.props.bus.getSubscriber().on("realTime").whenChanged().atFrequency(freq).handle(this.updateCycleHandler);
      }, true);
      this.attachLayers(thisNode);
    }
    /**
     * Scans this component's VNode sub-tree for MapLayer components and attaches them when found. Only the top-most
     * level of MapLayer components are attached; layers that are themselves children of other layers are not attached.
     * @param thisNode This component's VNode.
     */
    attachLayers(thisNode) {
      FSComponent.visitNodes(thisNode, (node) => {
        if (node.instance instanceof MapLayer) {
          this.attachLayer(node.instance);
          return true;
        }
        return false;
      });
    }
    /**
     * This method is called when the map is awakened.
     */
    onWake() {
      this.wakeLayers();
    }
    /**
     * Calls the onWake() method of this map's layers.
     */
    wakeLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onWake();
      }
    }
    /**
     * This method is called when the map is put to sleep.
     */
    onSleep() {
      this.sleepLayers();
    }
    /**
     * Calls the onSleep() method of this map's layers.
     */
    sleepLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onSleep();
      }
    }
    /**
     * This method is called when the map projection changes.
     * @param mapProjection This layer's map projection.
     * @param changeFlags The types of changes made to the projection.
     */
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.onProjectedSizeChanged();
      }
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
      }
    }
    /**
     * Attaches a layer to this map component. If the layer is already attached, then this method has no effect.
     * @param layer The layer to attach.
     */
    attachLayer(layer) {
      if (this.layerEntries.findIndex((entry2) => entry2.layer === layer) >= 0) {
        return;
      }
      const entry = new LayerEntry2(layer);
      this.layerEntries.push(entry);
      entry.attach();
    }
    /**
     * Detaches a layer from this map component.
     * @param layer The layer to detach.
     * @returns Whether the layer was succesfully detached.
     */
    detachLayer(layer) {
      const index = this.layerEntries.findIndex((entry) => entry.layer === layer);
      if (index >= 0) {
        const entry = this.layerEntries[index];
        entry.detach();
        this.layerEntries.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    /**
     * Updates this map.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     */
    update(time) {
      if (!this._isAwake) {
        return;
      }
      this.onUpdated(time, time - this.lastUpdateTime);
      this.lastUpdateTime = time;
    }
    /**
     * This method is called once every update cycle.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    onUpdated(time, elapsed) {
      this.updateLayers(time, elapsed);
    }
    /**
     * Updates this map's attached layers.
     * @param time The current real time as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateLayers(time, elapsed) {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].update(time);
      }
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].destroy();
      }
    }
  };
  var LayerEntry2 = class {
    /**
     * Constructor.
     * @param layer This entry's map layer.
     */
    constructor(layer) {
      this.layer = layer;
      this.updatePeriod = 0;
      this.lastUpdated = 0;
    }
    /**
     * Attaches this layer entry.
     */
    attach() {
      var _a, _b;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
        const clamped = Math.max(0, freq);
        this.updatePeriod = clamped === 0 ? 0 : 1e3 / clamped;
      }, true);
      this.layer.onAttached();
    }
    /**
     * Updates this layer entry.
     * @param currentTime The current time as a UNIX timestamp.
     */
    update(currentTime) {
      if (currentTime - this.lastUpdated >= this.updatePeriod) {
        this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
        this.lastUpdated = currentTime;
      }
    }
    /**
     * Detaches this layer entry.
     */
    detach() {
      var _a;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.layer.onDetached();
    }
    /**
     * Destroys this layer entry. This will detach this entry's layer and destroy it.
     */
    destroy() {
      this.detach();
      this.layer.destroy();
    }
  };
  var MapModel = class {
    constructor() {
      this.modules = /* @__PURE__ */ new Map();
    }
    /**
     * Gets a module instance from the model and assigns it
     * to the provided type.
     * @param nameOrModule The module to get or the name of the module.
     * @returns The requested map data module.
     * @throws An error if
     */
    getModule(nameOrModule) {
      if (typeof nameOrModule === "string") {
        return this.modules.get(nameOrModule);
      } else if (typeof nameOrModule === "function") {
        return this.modules.get(nameOrModule.name);
      }
      throw new Error("Invalid type supplied: must be a string key or a module constructor.");
    }
    /**
     * Adds a module to this model.
     * @param name The name of the module to add.
     * @param module The module to add.
     */
    addModule(name, module) {
      if (this.modules.has(name)) {
        return;
      }
      this.modules.set(name, module);
    }
  };
  var AbstractMapTextLabel = class {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.text = SubscribableUtils.toSubscribable(text, true);
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
      this.font = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.font) !== null && _b !== void 0 ? _b : "", true);
      this.fontSize = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : 10, true);
      this.fontStr = MappedSubject.create(([s, f]) => {
        return `${s}px ${f}`;
      }, this.fontSize, this.font);
      this.fontColor = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _d !== void 0 ? _d : "white", true);
      this.fontOutlineWidth = SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _e !== void 0 ? _e : 0, true);
      this.fontOutlineColor = SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _f !== void 0 ? _f : "black", true);
      this.showBg = SubscribableUtils.toSubscribable((_g = options === null || options === void 0 ? void 0 : options.showBg) !== null && _g !== void 0 ? _g : false, true);
      this.bgColor = SubscribableUtils.toSubscribable((_h = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _h !== void 0 ? _h : "black", true);
      this.bgPadding = SubscribableUtils.toSubscribable((_j = options === null || options === void 0 ? void 0 : options.bgPadding) !== null && _j !== void 0 ? _j : VecNMath.create(4), true);
      this.bgBorderRadius = SubscribableUtils.toSubscribable((_k = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _k !== void 0 ? _k : 0, true);
      this.bgOutlineWidth = SubscribableUtils.toSubscribable((_l = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _l !== void 0 ? _l : 0, true);
      this.bgOutlineColor = SubscribableUtils.toSubscribable((_m = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _m !== void 0 ? _m : "white", true);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    draw(context, mapProjection) {
      if (this.fontSize.get() !== 0) {
        this.setTextStyle(context);
        const width = context.measureText(this.text.get()).width;
        const height = this.fontSize.get();
        const showBg = this.showBg.get();
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        const bgExtraWidth = showBg ? bgPadding[1] + bgPadding[3] + bgOutlineWidth * 2 : 0;
        const bgExtraHeight = showBg ? bgPadding[0] + bgPadding[2] + bgOutlineWidth * 2 : 0;
        const anchor = this.anchor.get();
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (anchor[0] - 0.5) * (width + bgExtraWidth);
        const centerY = pos[1] - (anchor[1] - 0.5) * (height + bgExtraHeight);
        if (showBg) {
          this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
      }
    }
    /**
     * Loads this label's text style to a canvas rendering context.
     * @param context The canvas rendering context to use.
     */
    setTextStyle(context) {
      context.font = this.fontStr.get();
      context.textBaseline = "middle";
      context.textAlign = "center";
    }
    /**
     * Draws this label's text to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     */
    drawText(context, centerX, centerY) {
      const text = this.text.get();
      const fontOutlineWidth = this.fontOutlineWidth.get();
      if (fontOutlineWidth > 0) {
        context.lineWidth = fontOutlineWidth * 2;
        context.strokeStyle = this.fontOutlineColor.get();
        context.strokeText(text, centerX, centerY);
      }
      context.fillStyle = this.fontColor.get();
      context.fillText(text, centerX, centerY);
    }
    /**
     * Draws this label's background to a canvas.
     * @param context The canvas rendering context.
     * @param centerX The x-coordinate of the center of the label, in pixels.
     * @param centerY the y-coordinate of the center of the label, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     */
    drawBackground(context, centerX, centerY, width, height) {
      const bgPadding = this.bgPadding.get();
      const bgOutlineWidth = this.bgOutlineWidth.get();
      const bgBorderRadius = this.bgBorderRadius.get();
      const backgroundLeft = centerX - width / 2 - (bgPadding[3] + bgOutlineWidth);
      const backgroundTop = centerY - height / 2 - (bgPadding[0] + bgOutlineWidth);
      const backgroundWidth = width + (bgPadding[1] + bgPadding[3] + 2 * bgOutlineWidth);
      const backgroundHeight = height + (bgPadding[0] + bgPadding[2] + 2 * bgOutlineWidth);
      let isRounded = false;
      if (bgBorderRadius > 0) {
        isRounded = true;
        this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, bgBorderRadius);
      }
      if (bgOutlineWidth > 0) {
        context.lineWidth = bgOutlineWidth * 2;
        context.strokeStyle = this.bgOutlineColor.get();
        if (isRounded) {
          context.stroke();
        } else {
          context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
      }
      context.fillStyle = this.bgColor.get();
      if (isRounded) {
        context.fill();
      } else {
        context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
      }
    }
    /**
     * Loads the path of this label's background to a canvas rendering context.
     * @param context The canvas rendering context to use.
     * @param left The x-coordinate of the left edge of the background, in pixels.
     * @param top The y-coordinate of the top edge of the background, in pixels.
     * @param width The width of the background, in pixels.
     * @param height The height of the background, in pixels.
     * @param radius The border radius of the background, in pixels.
     */
    loadBackgroundPath(context, left, top, width, height, radius) {
      const right = left + width;
      const bottom = top + height;
      context.beginPath();
      context.moveTo(left + radius, top);
      context.lineTo(right - radius, top);
      context.arcTo(right, top, right, top + radius, radius);
      context.lineTo(right, bottom - radius);
      context.arcTo(right, bottom, right - radius, bottom, radius);
      context.lineTo(left + radius, bottom);
      context.arcTo(left, bottom, left, bottom - radius, radius);
      context.lineTo(left, top + radius);
      context.arcTo(left, top, left + radius, top, radius);
    }
  };
  AbstractMapTextLabel.tempVec2 = new Float64Array(2);
  var MapLocationTextLabel = class extends AbstractMapTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The render priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, options) {
      var _a;
      super(text, priority, options);
      this.location = SubscribableUtils.toSubscribable(location, true);
      this.offset = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
    }
    /** @inheritdoc */
    getPosition(mapProjection, out) {
      mapProjection.project(this.location.get(), out);
      Vec2Math.add(out, this.offset.get(), out);
      return out;
    }
  };
  var MapCullableLocationTextLabel = class extends MapLocationTextLabel {
    /**
     * Constructor.
     * @param text The text of this label, or a subscribable which provides it.
     * @param priority The priority of this label, or a subscribable which provides it.
     * @param location The geographic location of this label, or a subscribable which provides it.
     * @param alwaysShow Whether this label is immune to culling, or a subscribable which provides it.
     * @param options Options with which to initialize this label.
     */
    constructor(text, priority, location, alwaysShow, options) {
      super(text, priority, location, options);
      this.bounds = new Float64Array(4);
      this.invalidation = new SubEvent();
      this.subs = [];
      this.alwaysShow = SubscribableUtils.toSubscribable(alwaysShow, true);
      this.subs.push(this.priority.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.alwaysShow.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.location.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.text.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.fontSize.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.anchor.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.offset.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgPadding.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgOutlineWidth.sub(() => {
        this.invalidation.notify(this);
      }));
    }
    /** @inheritdoc */
    updateBounds(mapProjection) {
      const fontSize = this.fontSize.get();
      const anchor = this.anchor.get();
      const width = 0.6 * fontSize * this.text.get().length;
      const height = fontSize;
      const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
      let left = pos[0] - anchor[0] * width;
      let right = left + width;
      let top = pos[1] - anchor[1] * height;
      let bottom = top + height;
      if (this.showBg.get()) {
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        left -= bgPadding[3] + bgOutlineWidth;
        right += bgPadding[1] + bgOutlineWidth;
        top -= bgPadding[0] + bgOutlineWidth;
        bottom += bgPadding[2] + bgOutlineWidth;
      }
      this.bounds[0] = left;
      this.bounds[1] = top;
      this.bounds[2] = right;
      this.bounds[3] = bottom;
    }
    /**
     * Destroys this label.
     */
    destroy() {
      for (const sub of this.subs) {
        sub.destroy();
      }
    }
  };
  var MapCullableTextLabelManager = class {
    /**
     * Creates an instance of the MapCullableTextLabelManager.
     * @param cullingEnabled Whether or not culling of labels is enabled.
     */
    constructor(cullingEnabled = true) {
      this.cullingEnabled = cullingEnabled;
      this.registered = /* @__PURE__ */ new Map();
      this._visibleLabels = [];
      this.needUpdate = false;
      this.lastScaleFactor = 1;
      this.lastRotation = 0;
      this.invalidationHandler = () => {
        this.needUpdate = true;
      };
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** An array of labels registered with this manager that are visible. */
    get visibleLabels() {
      return this._visibleLabels;
    }
    /**
     * Registers a label with this manager. Newly registered labels will be processed with the next manager update.
     * @param label The label to register.
     */
    register(label) {
      if (this.registered.has(label)) {
        return;
      }
      this.registered.set(label, label.invalidation.on(this.invalidationHandler));
      this.needUpdate = true;
    }
    /**
     * Deregisters a label with this manager. Newly deregistered labels will be processed with the next manager update.
     * @param label The label to deregister.
     */
    deregister(label) {
      const sub = this.registered.get(label);
      if (sub === void 0) {
        return;
      }
      sub.destroy();
      this.registered.delete(label);
      this.needUpdate = true;
    }
    /**
     * Sets whether or not text label culling is enabled.
     * @param enabled Whether or not culling is enabled.
     */
    setCullingEnabled(enabled) {
      this.cullingEnabled = enabled;
      this.needUpdate = true;
    }
    /**
     * Updates this manager.
     * @param mapProjection The projection of the map to which this manager's labels are to be drawn.
     */
    update(mapProjection) {
      if (!this.needUpdate) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
        if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
          const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
          if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
            return;
          }
        }
      }
      this._visibleLabels = [];
      if (this.cullingEnabled) {
        const labelArray = Array.from(this.registered.keys());
        const len = labelArray.length;
        for (let i = 0; i < len; i++) {
          labelArray[i].updateBounds(mapProjection);
        }
        labelArray.sort(MapCullableTextLabelManager.SORT_FUNC);
        const collisionArray = [];
        for (let i = 0; i < len; i++) {
          const label = labelArray[i];
          let show = true;
          if (!label.alwaysShow.get()) {
            const len2 = collisionArray.length;
            for (let j = 0; j < len2; j++) {
              const other = collisionArray[j];
              if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                show = false;
                break;
              }
            }
          }
          if (show) {
            collisionArray.push(label.bounds);
            this._visibleLabels.push(label);
          }
        }
      } else {
        this._visibleLabels.push(...this.registered.keys());
      }
      this.lastScaleFactor = mapProjection.getScaleFactor();
      this.lastRotation = mapProjection.getRotation();
      this.needUpdate = false;
    }
    /**
     * Checks if two bounding boxes collide.
     * @param a The first bounding box, as a 4-tuple [left, top, right, bottom].
     * @param b The second bounding box, as a 4-tuple [left, top, right, bottom].
     * @returns whether the bounding boxes collide.
     */
    static doesCollide(a, b) {
      return a[0] < b[2] && a[2] > b[0] && a[1] < b[3] && a[3] > b[1];
    }
  };
  MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
  MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;
  MapCullableTextLabelManager.SORT_FUNC = (a, b) => {
    const alwaysShowA = a.alwaysShow.get();
    const alwaysShowB = b.alwaysShow.get();
    if (alwaysShowA && !alwaysShowB) {
      return -1;
    } else if (alwaysShowB && !alwaysShowA) {
      return 1;
    } else {
      return b.priority.get() - a.priority.get();
    }
  };
  var MapBlankWaypointIcon = class {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     */
    constructor(waypoint, priority) {
      this.waypoint = waypoint;
      this.priority = SubscribableUtils.toSubscribable(priority, true);
    }
    /**
     * Does nothing.
     */
    draw() {
    }
  };
  var AbstractMapWaypointIcon = class {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon, or a subscribable which provides it. Icons with higher
     * priorities should be rendered above those with lower priorities.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, size, options) {
      var _a, _b;
      this.waypoint = waypoint;
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.size = SubscribableUtils.toSubscribable(size, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(0.5, 0.5), true);
      this.offset = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.offset) !== null && _b !== void 0 ? _b : Vec2Math.create(), true);
    }
    /** @inheritdoc */
    draw(context, mapProjection) {
      const size = this.size.get();
      const offset = this.offset.get();
      const anchor = this.anchor.get();
      const projected = mapProjection.project(this.waypoint.location.get(), MapWaypointImageIcon.tempVec2);
      const left = projected[0] + offset[0] - anchor[0] * size[0];
      const top = projected[1] + offset[1] - anchor[1] * size[1];
      this.drawIconAt(context, mapProjection, left, top);
    }
  };
  AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
  var MapWaypointImageIcon = class extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's image.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     */
    constructor(waypoint, priority, img, size, options) {
      super(waypoint, priority, size, options);
      this.img = img;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
      const size = this.size.get();
      context.drawImage(this.img, left, top, size[0], size[1]);
    }
  };
  var MapWaypointSpriteIcon = class extends AbstractMapWaypointIcon {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this icon.
     * @param priority The render priority of this icon. Icons with higher priorities should be rendered above those
     * with lower priorities.
     * @param img This icon's sprite's image source.
     * @param frameWidth The frame width of the sprite, in pixels.
     * @param frameHeight The frame height of the sprite, in pixels.
     * @param size The size of this icon, as `[width, height]` in pixels, or a subscribable which provides it.
     * @param options Options with which to initialize this icon.
     * @param spriteFrameHandler An optional handler to determine the sprite frame to draw.
     */
    constructor(waypoint, priority, img, frameWidth, frameHeight, size, options, spriteFrameHandler) {
      super(waypoint, priority, size, options);
      this.img = img;
      this.frameWidth = frameWidth;
      this.frameHeight = frameHeight;
      this.spriteFrameHandler = spriteFrameHandler;
    }
    /** @inheritdoc */
    drawIconAt(context, mapProjection, left, top) {
      const size = this.size.get();
      const spriteIndex = this.getSpriteFrame(mapProjection);
      const rowCount = Math.floor(this.img.naturalHeight / this.frameHeight);
      const colCount = Math.floor(this.img.naturalWidth / this.frameWidth);
      const row = Math.min(rowCount - 1, Math.floor(spriteIndex / colCount));
      const col = Math.min(colCount - 1, spriteIndex % colCount);
      const spriteLeft = col * this.frameWidth;
      const spriteTop = row * this.frameHeight;
      context.drawImage(this.img, spriteLeft, spriteTop, this.frameWidth, this.frameHeight, left, top, size[0], size[1]);
    }
    /**
     * Gets the sprite frame to render.
     * @param mapProjection The map projection to use.
     * @returns The sprite frame to render.
     */
    getSpriteFrame(mapProjection) {
      if (this.spriteFrameHandler !== void 0) {
        return this.spriteFrameHandler(mapProjection);
      }
      return 0;
    }
  };
  var MapWaypointRenderer = class {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     * @param selectRoleToRender A function which selects roles under which to render waypoints. Defaults to
     * {@link MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR}.
     */
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
      this.textManager = textManager;
      this.selectRoleToRender = selectRoleToRender;
      this.registered = /* @__PURE__ */ new Map();
      this.toCleanUp = /* @__PURE__ */ new Set();
      this.roleDefinitions = /* @__PURE__ */ new Map();
      this.onWaypointAdded = new SubEvent();
      this.onWaypointRemoved = new SubEvent();
    }
    /**
     * Checks whether a render role has been added to this renderer.
     * @param role The render role to check.
     * @returns Whether the render role has been added to this renderer.
     */
    hasRenderRole(role) {
      return this.roleDefinitions.has(role);
    }
    /**
     * Adds a render role to this renderer. If the role has already been added to this renderer, this method does
     * nothing.
     * @param role The render role to add.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @returns Whether the render role was successfully added.
     */
    addRenderRole(role, def) {
      if (this.roleDefinitions.has(role)) {
        return false;
      }
      this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
      return true;
    }
    /**
     * Removes a render role from this renderer.
     * @param role The render role to remove.
     * @returns Whether the render role was successfully removed.
     */
    removeRenderRole(role) {
      return this.roleDefinitions.delete(role);
    }
    /**
     * Gets the definition for a render role.
     * @param role A render role.
     * @returns The definition for the specified render role, or undefined if no such role has been added to this
     * renderer.
     */
    getRenderRoleDefinition(role) {
      return this.roleDefinitions.get(role);
    }
    /**
     * Gets an iterable of render roles added to this renderer. The iterable will return the roles in the order in which
     * they were added.
     * @returns An iterable of render roles added to this renderer.
     */
    renderRoles() {
      return this.roleDefinitions.keys();
    }
    /**
     * Removes all render roles from this renderer.
     */
    clearRenderRoles() {
      this.roleDefinitions.clear();
    }
    /**
     * Sets the factory to use to create waypoint icons for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint icon factory.
     * @returns Whether the factory was set.
     */
    setIconFactory(role, factory) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.iconFactory = factory;
      return true;
    }
    /**
     * Sets the factory to use to create waypoint labels for a render role. If the render role has not been added to this
     * renderer, this method does nothing.
     * @param role A render role.
     * @param factory A waypoint label factory.
     * @returns Whether the factory was set.
     */
    setLabelFactory(role, factory) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.labelFactory = factory;
      return true;
    }
    /**
     * Sets the canvas rendering context for a render role. If the render role has not been added to this renderer, this
     * method does nothing.
     * @param role A render role.
     * @param context A canvas 2D rendering context.
     * @returns Whether the context was set.
     */
    setCanvasContext(role, context) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.canvasContext = context;
      return true;
    }
    /**
     * Sets the handler that determines if a waypoint should visible for a render role. If the render role has not been
     * added to this renderer, this method does nothing.
     * @param role A render role.
     * @param handler A function that determines if a waypoint should be visible.
     * @returns Whether the handler was set.
     */
    setVisibilityHandler(role, handler) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.visibilityHandler = handler;
      return true;
    }
    /**
     * Checks if a waypoint is registered with this renderer. A role or roles can be optionally specified such that the
     * method will only return true if the waypoint is registered under those specific roles.
     * @param waypoint A waypoint.
     * @param role The specific role(s) to check.
     * @returns whether the waypoint is registered with this renderer.
     */
    isRegistered(waypoint, role) {
      if (!waypoint) {
        return false;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return false;
      }
      if (role === void 0) {
        return true;
      }
      return entry.isAllRoles(role);
    }
    /**
     * Registers a waypoint with this renderer under a specific role or roles. Registered waypoints will be drawn as
     * appropriate the next time this renderer's update() method is called. Registering a waypoint under a role under
     * which it is already registered has no effect unless the source of the registration is different.
     * @param waypoint The waypoint to register.
     * @param role The role(s) under which the waypoint should be registered.
     * @param sourceId A unique string ID for the source of the registration.
     */
    register(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      let entry = this.registered.get(waypoint.uid);
      if (!entry) {
        entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
        this.registered.set(waypoint.uid, entry);
        this.onWaypointAdded.notify(this, waypoint);
      }
      entry.addRole(role, sourceId);
    }
    /**
     * Removes a registration for a waypoint for a specific role or roles. Once all of a waypoint's registrations for a
     * role are removed, it will no longer be rendered in that role the next this renderer's update() method is called.
     * @param waypoint The waypoint to deregister.
     * @param role The role(s) from which the waypoint should be deregistered.
     * @param sourceId The unique string ID for the source of the registration to remove.
     */
    deregister(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return;
      }
      entry.removeRole(role, sourceId);
      if (entry.roles === 0) {
        this.deleteEntry(entry);
        this.onWaypointRemoved.notify(this, waypoint);
      }
    }
    /**
     * Deletes and cleans up a registered waypoint entry.
     * @param entry The entry to delete.
     */
    deleteEntry(entry) {
      this.registered.delete(entry.waypoint.uid);
      this.toCleanUp.add(entry);
    }
    /**
     * Redraws waypoints registered with this renderer.
     * @param mapProjection The map projection to use.
     */
    update(mapProjection) {
      var _a;
      this.toCleanUp.forEach((entry) => {
        entry.destroy();
      });
      this.toCleanUp.clear();
      const entriesToDrawIcon = [];
      this.registered.forEach((entry) => {
        entry.update();
        if (entry.icon) {
          entriesToDrawIcon.push(entry);
        }
      });
      const projectedSize = mapProjection.getProjectedSize();
      for (const roleDef of this.roleDefinitions.values()) {
        const context = roleDef.canvasContext;
        if (context) {
          context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
        }
      }
      entriesToDrawIcon.sort(MapWaypointRenderer.ENTRY_SORT_FUNC);
      const len2 = entriesToDrawIcon.length;
      for (let i = 0; i < len2; i++) {
        const entry = entriesToDrawIcon[i];
        const icon = entry.icon;
        const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
        if (context) {
          icon.draw(context, mapProjection);
        }
      }
    }
    /**
     * Gets the nearest waypoint currently registered in the renderer.
     * @param pos The position to get the closest waypoint to.
     * @param first A predicate that will search the list of closest waypoints for a match, and return the first one found.
     * @returns The nearest waypoint, or undefined if none found.
     */
    getNearestWaypoint(pos, first) {
      var _a, _b;
      const ordered = [...this.registered.values()].sort((a, b) => this.orderByDistance(a.waypoint, b.waypoint, pos)).filter((w) => {
        const roleDef = this.getRenderRoleDefinition(w.lastRenderedRole);
        if (roleDef !== void 0) {
          return roleDef.visibilityHandler(w.waypoint);
        }
        return false;
      });
      if (first !== void 0) {
        return (_a = ordered.find((entry) => first(entry.waypoint))) === null || _a === void 0 ? void 0 : _a.waypoint;
      }
      return (_b = ordered[0]) === null || _b === void 0 ? void 0 : _b.waypoint;
    }
    /**
     * Orders waypoints by their distance to the plane PPOS.
     * @param a The first waypoint.
     * @param b The second waypoint.
     * @param pos The position to compare against.
     * @returns The comparison order number.
     */
    orderByDistance(a, b, pos) {
      const aDist = a.location.get().distance(pos);
      const bDist = b.location.get().distance(pos);
      return aDist - bDist;
    }
  };
  MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
  };
  MapWaypointRenderer.ENTRY_SORT_FUNC = (a, b) => {
    return a.icon.priority.get() - b.icon.priority.get();
  };
  MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
      if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
        return role;
      }
    }
    return 0;
  };
  var MapWaypointRendererEntry = class {
    /**
     * Constructor.
     * @param waypoint The waypoint associated with this entry.
     * @param textManager The text manager to which to register this entry's labels.
     * @param roleDefinitions A map of all valid render roles to their definitions.
     * @param selectRoleToRender A function to use to select roles under which to render this entry.
     */
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
      this.waypoint = waypoint;
      this.textManager = textManager;
      this.roleDefinitions = roleDefinitions;
      this.selectRoleToRender = selectRoleToRender;
      this.registrations = {};
      this._roles = 0;
      this._icon = null;
      this._label = null;
      this._lastRenderedRole = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The render role(s) assigned to this entry. */
    get roles() {
      return this._roles;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The role under which this entry was last rendered, or 0 if this entry has not yet been rendered. */
    get lastRenderedRole() {
      return this._lastRenderedRole;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint icon. */
    get icon() {
      return this._icon;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This entry's waypoint label. */
    get label() {
      return this._label;
    }
    /**
     * Checks whether this entry is assigned any of the specified render roles. Optionally, this method can also check
     * if this entry was last rendered in any of the specified roles instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAnyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAny(toCompare, roles);
    }
    /**
     * Checks whether this entry is assigned only the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in only the specified role(s) instead.
     * @param roles The render roles against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isOnlyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return toCompare === roles;
    }
    /**
     * Checks whether this entry is assigned all the specified render role(s). Optionally, this method can also check
     * if this entry was last rendered in all the specified role(s) instead.
     * @param roles - the render role(s) against which to check.
     * @param useLastRendered Whether to check the role(s) in which this entry was last rendered instead of the current
     * roles assigned to this entry. False by default.
     * @returns whether the check passed.
     */
    isAllRoles(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAll(toCompare, roles);
    }
    /**
     * Assigns one or more render roles to this entry.
     * @param roles The render role(s) to assign.
     * @param sourceId The unique string ID of the source of the assignment.
     */
    addRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        var _a;
        var _b, _c;
        ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : _b[_c] = /* @__PURE__ */ new Set()).add(sourceId);
      }, true);
      this._roles = this._roles | roles;
    }
    /**
     * Removes one or more render roles from this entry.
     * @param roles The render role(s) to remove.
     * @param sourceId The unique string ID of the soruce of the de-assignment.
     */
    removeRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        const role = 1 << index;
        const registrations = this.registrations[role];
        if (registrations) {
          registrations.delete(sourceId);
          if (registrations.size === 0) {
            this._roles = this._roles & ~role;
          }
        }
      }, true);
    }
    /**
     * Prepares this entry for rendering.
     * @param showRole The role in which this entry should be rendered.
     * @param iconFactory The factory to use to get a waypoint icon.
     * @param labelFactory The factory to use to get a waypoint label.
     */
    prepareRender(showRole, iconFactory, labelFactory) {
      var _a, _b;
      if (showRole === this._lastRenderedRole) {
        return;
      }
      this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
      const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
      if (this._label && this._label !== label) {
        this.textManager.deregister(this._label);
      }
      if (label && label !== this._label) {
        this.textManager.register(label);
      }
      this._label = label;
      this._lastRenderedRole = showRole;
    }
    /**
     * Updates this entry. An appropriate render role is selected, then the icon and label are updated as appropriate
     * for the chosen role. If the waypoint's label should be visible, it is added to the appropriate text manager.
     * Of note, this method will not draw the waypoint icon to a canvas element; it will simply ensure the .showIcon
     * property contains the correct value depending on whether the icon should be visible.
     */
    update() {
      var _a, _b;
      const showRole = this.selectRoleToRender(this, this.roleDefinitions);
      const roleDef = this.roleDefinitions.get(showRole);
      const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
      const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
      this.prepareRender(showRole, iconFactory, labelFactory);
    }
    /**
     * Destroys this entry. Any label from this entry currently registered with the text manager will be deregistered.
     */
    destroy() {
      if (this._label) {
        this.textManager.deregister(this._label);
      }
    }
  };
  var NullPathStream = class {
    /**
     * Does nothing.
     */
    beginPath() {
    }
    /**
     * Does nothing.
     */
    moveTo() {
    }
    /**
     * Does nothing.
     */
    lineTo() {
    }
    /**
     * Does nothing.
     */
    bezierCurveTo() {
    }
    /**
     * Does nothing.
     */
    quadraticCurveTo() {
    }
    /**
     * Does nothing.
     */
    arc() {
    }
    /**
     * Does nothing.
     */
    closePath() {
    }
  };
  NullPathStream.INSTANCE = new NullPathStream();
  var AbstractTransformingPathStream = class {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     */
    constructor(consumer) {
      this.consumer = consumer;
    }
    /** @inheritdoc */
    getConsumer() {
      return this.consumer;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
      this.consumer = consumer;
    }
  };
  var PassThroughPathStream = class extends AbstractTransformingPathStream {
    /** @inheritdoc */
    beginPath() {
      this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      this.consumer.moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
      this.consumer.lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      this.consumer.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
      this.consumer.closePath();
    }
  };
  var Outcode;
  (function(Outcode2) {
    Outcode2[Outcode2["Inside"] = 0] = "Inside";
    Outcode2[Outcode2["Left"] = 1] = "Left";
    Outcode2[Outcode2["Top"] = 2] = "Top";
    Outcode2[Outcode2["Right"] = 4] = "Right";
    Outcode2[Outcode2["Bottom"] = 8] = "Bottom";
  })(Outcode || (Outcode = {}));
  var ClippedPathStream = class extends AbstractTransformingPathStream {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param bounds A subscribable which provides the clipping bounds for this stream, as `[left, top, right, bottom]`.
     * Whenever the clipping bounds change, the state of this stream will be reset, as if `beginPath()` were called.
     */
    constructor(consumer, bounds) {
      super(consumer);
      this.bounds = bounds;
      this.boundsHandler = this.onBoundsChanged.bind(this);
      this.boundsLines = [
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3)
      ];
      this.isBoundingRectNonZero = false;
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.prevPointOutcode = 0;
      bounds.sub(this.boundsHandler, true);
    }
    /** @inheritdoc */
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
      if (this.prevPointOutcode === 0) {
        this.consumer.moveTo(x, y);
      }
    }
    /** @inheritdoc */
    lineTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      const outcode = this.getOutcode(x, y);
      if ((this.prevPointOutcode | outcode) === 0) {
        this.consumer.lineTo(x, y);
      } else if ((this.prevPointOutcode & outcode) === 0) {
        const bounds = this.bounds.get();
        const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
        let entryPoint, exitPoint;
        const outcodeOr = this.prevPointOutcode | outcode;
        if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              break;
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              break;
            }
          }
        } else {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                entryPoint = intersection;
                break;
              }
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                exitPoint = intersection;
                break;
              }
            }
          }
        }
        if (entryPoint) {
          this.consumer.moveTo(entryPoint[0], entryPoint[1]);
        }
        if (exitPoint) {
          this.consumer.lineTo(exitPoint[0], exitPoint[1]);
        } else if (outcode === Outcode.Inside) {
          this.consumer.lineTo(x, y);
        }
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = outcode;
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const pi2 = 2 * Math.PI;
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
      const bounds = this.bounds.get();
      const radiusSq = radius * radius;
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
      const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
      const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const intersections = ClippedPathStream.intersectionCache;
      let intersectionCount = 0;
      for (let i = 0; i < 4; i++) {
        const axisCoordIndex = i % 2;
        const crossAxisCoordIndex = (i + 1) % 2;
        const centerAxisCoord = i % 2 === 0 ? x : y;
        const centerCrossAxisCoord = i % 2 === 0 ? y : x;
        const deltaToBound = bounds[i] - centerAxisCoord;
        if (Math.abs(deltaToBound) < radius) {
          const crossAxisBoundMin = bounds[crossAxisCoordIndex];
          const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
          const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
          let intersectionRadialOffset;
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
        }
      }
      let isOutside = startPointOutcode !== Outcode.Inside;
      const startAngleNormalized = (startAngle % pi2 + pi2) % pi2;
      let lastRadial = startAngleNormalized;
      let intersectionStartIndex = -1;
      let minAngularDiff = Infinity;
      for (let i = 0; i < intersectionCount; i++) {
        const angularDiff = ((intersections[i].radial - startAngleNormalized) * directionSign + pi2) % pi2;
        if (angularDiff < minAngularDiff) {
          intersectionStartIndex = i;
          minAngularDiff = angularDiff;
        }
      }
      if (intersectionStartIndex >= 0) {
        for (let i = 0; i < intersectionCount; i++) {
          const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
          const intersection = intersections[index];
          if (((intersection.radial - startAngleNormalized) * directionSign + pi2) % pi2 >= angularWidth) {
            break;
          }
          if (isOutside) {
            this.consumer.moveTo(intersection.point[0], intersection.point[1]);
          } else {
            const segmentAngularWidth = ((intersection.radial - lastRadial) * directionSign + pi2) % pi2;
            this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
          }
          isOutside = !isOutside;
          lastRadial = intersection.radial;
        }
      }
      const endAngleNormalized = (startAngleNormalized + angularWidth * directionSign + pi2) % pi2;
      if (!isOutside) {
        const segmentAngularWidth = ((endAngleNormalized - lastRadial) * directionSign + pi2) % pi2;
        this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
        if (Math.abs((endAngleNormalized - endAngle) % pi2) > 1e-14) {
          this.consumer.moveTo(endPoint[0], endPoint[1]);
        }
      }
      Vec2Math.copy(endPoint, this.prevPoint);
      this.prevPointOutcode = endPointOutcode;
    }
    /** @inheritdoc */
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.prevPointOutcode = 0;
    }
    /**
     * Gets the Cohen-Sutherland outcode for a point.
     * @param x The x-coordinate of the query point.
     * @param y The y-coordinate of the query point.
     * @returns The outcode for the point.
     */
    getOutcode(x, y) {
      const bounds = this.bounds.get();
      let code = 0;
      if (x < bounds[0]) {
        code |= Outcode.Left;
      } else if (x > bounds[2]) {
        code |= Outcode.Right;
      }
      if (y < bounds[1]) {
        code |= Outcode.Top;
      } else if (y > bounds[3]) {
        code |= Outcode.Bottom;
      }
      return code;
    }
    /**
     * Handles clipping bounds change events.
     */
    onBoundsChanged() {
      const bounds = this.bounds.get();
      Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
      Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
      Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
      Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
      this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
      this.beginPath();
    }
    /**
     * Destroys this stream.
     */
    destroy() {
      this.bounds.unsub(this.boundsHandler);
    }
    /**
     * Gets the line coordinate vector for a line passing through two points.
     * @param x1 The x-coordinate of the first point on the line.
     * @param y1 The y-coordinate of the first point on the line.
     * @param x2 The x-coordinate of the second point on the line.
     * @param y2 The y-coordinate of the second point on the line.
     * @param out A Float64Array object to which to write the result.
     * @returns The line coordinate vector of the line passing through the two points.
     */
    static getLineCoordinates(x1, y1, x2, y2, out) {
      const a = y1 - y2;
      const b = x2 - x1;
      const c = -(a * x1 + b * y1);
      return Vec3Math.set(a, b, c, out);
    }
    /**
     * Finds the intersection point between two lines in 2D Euclidean space.
     * @param line1 The line coordinate vector of the first line.
     * @param line2 The line coordinate vector of the second line.
     * @param out A Float64Array object to which to write the result.
     * @returns The intersection point of the two lines, or undefined if the two lines are parallel.
     */
    static findLineLineIntersection(line1, line2, out) {
      const cross = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
      const w = cross[2];
      if (w === 0) {
        return void 0;
      }
      return Vec2Math.set(cross[0] / w, cross[1] / w, out);
    }
  };
  ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: 0 };
  });
  var GeoProjectionPathStream = class extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.projection = projection;
      this.firstPoint = new GeoPoint(NaN, NaN);
      this.prevPoint = new GeoPoint(NaN, NaN);
      this.prevPointProjected = new Float64Array(2);
      this.resampleHandler = this.onResampled.bind(this);
      if (arg1 instanceof GeoCircleResampler) {
        this.resampler = arg1;
      } else {
        this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
      }
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
      return this.projection;
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
      this.projection = projection;
    }
    /** @inheritdoc */
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    /**
     * Moves to a specified point.
     * @param lon The longitude of the point to which to move, in degrees.
     * @param lat The latitude of the point to which to move, in degrees.
     */
    moveTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (isNaN(this.firstPoint.lat)) {
        this.firstPoint.set(lat, lon);
      }
      this.prevPoint.set(lat, lon);
      const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
      this.consumer.moveTo(projected[0], projected[1]);
    }
    /**
     * Paths a great-circle arc from the current point to a specified point.
     * @param lon The longitude of the end point, in degrees.
     * @param lat The latitude of the end point, in degrees.
     * @throws Error if the specified point is antipodal to the last pathed point.
     */
    lineTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(lon, lat);
        return;
      }
      const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
      const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
      if (!isFinite(circle.center[0])) {
        throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
      }
      this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
      this.prevPoint.set(lat, lon);
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    bezierCurveTo() {
      throw new Error("GeodesicResamplerStream: bezierCurveTo() is not supported");
    }
    /**
     * Not supported by this path stream.
     * @throws Error when called.
     */
    quadraticCurveTo() {
      throw new Error("GeodesicResamplerStream: quadraticCurveTo() is not supported");
    }
    /**
     * Paths a small-circle arc.
     * @param lon The longitude of the center of the circle containing the arc, in degrees.
     * @param lat The latitude of the center of the circle containing the arc, in degrees.
     * @param radius The radius of the arc, in great-arc radians.
     * @param startAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the start of the arc; otherwise the longitude, in degrees, of the start
     * of the arc.
     * @param endAngle If the center of the circle containing the arc is not one of the poles, the true bearing, in
     * degrees, from the center of the circle to the end of the arc; otherwise the longitude, in degrees, of the end of
     * the arc.
     * @param counterClockwise Whether the arc should be drawn counterclockwise. False by default.
     */
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        return;
      }
      if (MathUtils.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
        const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
        this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
        this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
        return;
      }
      const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
      const start = GeoProjectionPathStream.geoPointCache[2];
      const end = GeoProjectionPathStream.geoPointCache[3];
      if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        const circleLat = Math.sign(lat) * (MathUtils.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
        start.set(circleLat, startAngle);
        end.set(circleLat, endAngle);
      } else {
        center.offset(startAngle, radius, start);
        center.offset(endAngle, radius, end);
      }
      if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(start.lon, start.lat);
      } else if (!start.equals(this.prevPoint)) {
        this.lineTo(start.lon, start.lat);
      }
      const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
      if (!counterClockwise) {
        circle.reverse();
      }
      this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
      this.prevPoint.set(end);
    }
    /**
     * Paths a great-circle arc from the current point to the first point defined by the current path.
     */
    closePath() {
      if (!isNaN(this.firstPoint.lat)) {
        this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
      }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
      this.firstPoint.set(NaN, NaN);
      this.prevPoint.set(NaN, NaN);
    }
    /**
     * Handles resampled points.
     * @param vector A vector which describes the projected path terminating at the resampled point.
     */
    onResampled(vector) {
      switch (vector.type) {
        case "start":
          return;
        case "line":
          this.consumer.lineTo(vector.projected[0], vector.projected[1]);
          break;
        case "arc":
          this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
          break;
      }
      Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
  };
  GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var AffineTransformPathStream = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.transform = new Transform2D();
      this.concatCache = [];
      this.scale = 1;
      this.rotation = 0;
    }
    /**
     * Adds a translation to this stream's transformation.
     * @param x The x translation.
     * @param y The y translation.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the translation before this stream's current transformation.
     * * `'after'` - Applies the translation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addTranslation(x, y, order = "after") {
      const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
      if (order === "before") {
        this.concatCache[0] = translation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = translation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      return this;
    }
    /**
     * Adds a uniform scaling to this stream's transformation.
     * @param factor The scaling factor.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the scaling before this stream's current transformation.
     * * `'after'` - Applies the scaling after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addScale(factor, order = "after") {
      const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
      if (order === "before") {
        this.concatCache[0] = scale;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = scale;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    /**
     * Adds a rotation to this stream's transformation.
     * @param angle The rotation angle, in radians.
     * @param order The order in which to add the translation (defaults to `'after'`):
     * * `'before'` - Applies the rotation before this stream's current transformation.
     * * `'after'` - Applies the rotation after this stream's current transformation.
     * @returns This stream, after its transformation has been changed.
     */
    addRotation(angle, order = "after") {
      const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
      if (order === "before") {
        this.concatCache[0] = rotation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = rotation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    /**
     * Resets this stream's transformation to the identity transformation.
     * @returns This stream, after its transformation has been changed.
     */
    resetTransform() {
      this.transform.toIdentity();
      this.updateScaleRotation();
      return this;
    }
    /** @inheritdoc */
    beginPath() {
      this.consumer.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.moveTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    lineTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.lineTo(transformed[0], transformed[1]);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      const cp1Transformed = this.applyTransform(cp1x, cp1y);
      cp1x = cp1Transformed[0];
      cp1y = cp1Transformed[1];
      const cp2Transformed = this.applyTransform(cp2x, cp2y);
      cp2x = cp2Transformed[0];
      cp2y = cp2Transformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
      const cpTransformed = this.applyTransform(cpx, cpy);
      cpx = cpTransformed[0];
      cpy = cpTransformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      const transformed = this.applyTransform(x, y);
      this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
      this.consumer.closePath();
    }
    /**
     * Updates this stream's cached scale and rotation values from its transformation.
     */
    updateScaleRotation() {
      const params = this.transform.getParameters();
      this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
      this.rotation = Math.atan2(params[3], params[0]);
    }
    /**
     * Applies this stream's transformation to a point.
     * @param x The x-coordinate of the point to transform.
     * @param y The y-coordinate of the point to transform.
     * @returns The transformed point.
     */
    applyTransform(x, y) {
      const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
      return this.transform.apply(vec, vec);
    }
  };
  AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
  AffineTransformPathStream.transformCache = [new Transform2D()];
  var PatternPathStream = class {
    /**
     * Constructor.
     * @param consumer The path stream that consumes this stream's transformed output.
     * @param pattern The pattern drawn by this stream. If the pattern is `null`, then this stream will pass through path
     * commands to its consumer without transforming them into a pattern.
     */
    constructor(consumer, pattern) {
      this.pattern = pattern;
      this.clipBounds = VecNSubject.createFromVector(new Float64Array([Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]));
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.distanceLeft = NaN;
      this.transformStream = new AffineTransformPathStream(consumer);
      this.clipStream = new ClippedPathStream(this.transformStream, this.clipBounds);
    }
    /**
     * Gets the pattern drawn by this stream.
     * @returns The pattern drawn by this stream.
     */
    getPattern() {
      return this.pattern;
    }
    /**
     * Sets the pattern drawn by this stream. If the pattern is `null`, then this stream will pass through path commands
     * to its consumer without transforming them into a pattern.
     * @param pattern A pattern.
     */
    setPattern(pattern) {
      if (!isNaN(this.distanceLeft) && this.pattern) {
        this.distanceLeft = Math.max(0, this.distanceLeft - this.pattern.anchor * this.pattern.length);
      }
      this.pattern = pattern;
      if (pattern) {
        if (!isNaN(this.distanceLeft)) {
          this.distanceLeft += pattern.anchor * pattern.length;
        }
      } else {
        this.distanceLeft = NaN;
      }
    }
    /** @inheritdoc */
    getConsumer() {
      return this.transformStream.getConsumer();
    }
    /** @inheritdoc */
    setConsumer(consumer) {
      this.transformStream.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
      this.reset();
      this.getConsumer().beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.distanceLeft = NaN;
    }
    /** @inheritdoc */
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.pattern) {
        const x0 = this.prevPoint[0];
        const y0 = this.prevPoint[1];
        const dx = x - x0;
        const dy = y - y0;
        const distance = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        this.transformStream.resetTransform().addRotation(angle).addTranslation(x0, y0);
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            this.transformStream.addTranslation(distanceToNextAnchor, 0, "before");
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            this.transformStream.addTranslation(distanceToPatternEnd, 0, "before");
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().lineTo(x, y);
      }
      Vec2Math.set(x, y, this.prevPoint);
    }
    /**
     * Not supported by this path stream. Calling this method will execute a `moveTo()` command to the specified end
     * point.
     * @param cp1x The x-coordinate of the first control point.
     * @param cp1y The y-coordinate of the first control point.
     * @param cp2x The x-coordinate of the second control point.
     * @param cp2y The y-coordinate of the second control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.moveTo(x, y);
    }
    /**
     * Not supported by this path stream. Calling this method will execute a `moveTo()` command to the specified end
     * point.
     * @param cpx The x-coordinate of the control point.
     * @param cpy The y-coordinate of the control point.
     * @param x The x-coordinate of the end point.
     * @param y The y-coordinate of the end point.
     */
    quadraticCurveTo(cpx, cpy, x, y) {
      this.moveTo(x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, PatternPathStream.vec2Cache[1]), PatternPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      if (this.pattern) {
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
          const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
          endAngle = startAngle + angleDiff * directionSign;
        }
        const angularWidth = (endAngle - startAngle) * directionSign;
        const distance = angularWidth * radius;
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          let angle = startAngle;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            angle += distanceToNextAnchor / radius * directionSign;
            this.transformStream.resetTransform().addRotation(Math.PI / 2 * directionSign).addTranslation(radius, 0).addRotation(angle).addTranslation(x, y);
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            angle += distanceToPatternEnd / radius * directionSign;
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().arc(x, y, radius, startAngle, endAngle, counterClockwise);
      }
      Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, endAngle, PatternPathStream.vec2Cache[1]), this.prevPoint);
    }
    /** @inheritdoc */
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.distanceLeft = NaN;
    }
  };
  PatternPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var TransformingPathStreamStack = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.stack = [];
    }
    /**
     * Adds a transforming path stream to the top of this stack.
     * @param stream A transforming path stream.
     */
    push(stream) {
      var _a;
      stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
      this.stack.push(stream);
    }
    /**
     * Removes the top-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    pop() {
      const removed = this.stack.pop();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      return removed;
    }
    /**
     * Adds a transforming path stream to the bottom of this stack.
     * @param stream A transforming path stream.
     */
    unshift(stream) {
      const displaced = this.stack[0];
      displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
      stream.setConsumer(this.consumer);
      this.stack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from this stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shift() {
      var _a;
      const removed = this.stack.shift();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
      return removed;
    }
    /** @inheritdoc */
    setConsumer(consumer) {
      var _a;
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
      this.stack[this.stack.length - 1].closePath();
    }
  };
  var GeoProjectionPathStreamStack = class extends AbstractTransformingPathStream {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.postStack = new TransformingPathStreamStack(consumer);
      if (arg1 instanceof GeoCircleResampler) {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
      } else {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
      }
      this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    /**
     * Gets the projection used by this stream.
     * @returns The projection used by this stream.
     */
    getProjection() {
      return this.projectionStream.getProjection();
    }
    /**
     * Sets the projection used by this stream.
     * @param projection A projection.
     */
    setProjection(projection) {
      this.projectionStream.setProjection(projection);
    }
    /**
     * Adds a transforming path stream to the top of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    pushPreProjected(stream) {
      this.preStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPreProjected() {
      return this.preStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the pre-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPreProjected(stream) {
      this.preStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the pre-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPreProjected() {
      return this.preStack.shift();
    }
    /**
     * Adds a transforming path stream to the top of the post-projected stack.
     * @param stream A transforming path stream.
     */
    pushPostProjected(stream) {
      this.postStack.push(stream);
    }
    /**
     * Removes the top-most path stream from the post-projected stack. The removed stream will have its consumer set to
     * {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    popPostProjected() {
      return this.postStack.pop();
    }
    /**
     * Adds a transforming path stream to the bottom of the post-projected stack.
     * @param stream A transforming path stream.
     */
    unshiftPostProjected(stream) {
      this.postStack.unshift(stream);
    }
    /**
     * Removes the bottom-most path stream from the post-projected stack. The removed stream will have its consumer set
     * to {@link NullPathStream.INSTANCE}.
     * @returns The removed path stream, or undefined if this stack was empty.
     */
    shiftPostProjected() {
      return this.postStack.shift();
    }
    /** @inheritdoc */
    setConsumer(consumer) {
      this.postStack.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    /** @inheritdoc */
    beginPath() {
      this.preStack.beginPath();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      this.preStack.moveTo(x, y);
    }
    /** @inheritdoc */
    lineTo(x, y) {
      this.preStack.lineTo(x, y);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
      this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /** @inheritdoc */
    closePath() {
      this.preStack.closePath();
    }
  };
  var GeoCirclePathRenderer = class {
    /**
     * Renders an arc along a geo circle to a path stream stack.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param streamStack The path stream stack to which to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
      if (!continuePath) {
        streamStack.beginPath();
        streamStack.moveTo(startLon, startLat);
      }
      if (circle.isGreatCircle()) {
        const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
        const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
          const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
          const midLat = midPoint.lat;
          const midLon = midPoint.lon;
          streamStack.lineTo(midLon, midLat);
          streamStack.lineTo(endLon, endLat);
        } else {
          streamStack.lineTo(endLon, endLat);
        }
      } else {
        const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
        const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
        let startAngle, endAngle;
        if (isCenterPole) {
          startAngle = startLon;
          endAngle = endLon;
        } else {
          startAngle = turnCenter.bearingTo(startLat, startLon);
          endAngle = turnCenter.bearingTo(endLat, endLon);
        }
        streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === "left");
      }
    }
  };
  GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
  GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];
  var GeoCircleLineRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
    }
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     */
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash, outlineWidth = 0, outlineStyle = "black") {
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
      if (outlineWidth > 0) {
        context.lineWidth = width + outlineWidth * 2;
        context.strokeStyle = outlineStyle;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
      context.stroke();
    }
  };
  GeoCircleLineRenderer.EMPTY_DASH = [];
  var GeoCirclePatternRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
      this.patternStream = new PatternPathStream(NullPathStream.INSTANCE, null);
    }
    /**
     * Renders an arc along a geo circle to a canvas.
     * @param circle The geo circle containing the arc to render.
     * @param startLat The latitude of the start of the arc, in degrees.
     * @param startLon The longitude of the start of the arc, in degrees.
     * @param endLat The latitude of the end of the arc, in degrees.
     * @param endLon The longitude of the end of the arc, in degrees.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param pattern The pattern to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the arc is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected arc starts. Defaults to false.
     */
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, pattern, continuePath = false) {
      this.patternStream.setPattern(pattern);
      streamStack.unshiftPostProjected(this.patternStream);
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath);
      streamStack.shiftPostProjected();
    }
  };
  var AbstractFlightPathPlanRenderer = class {
    /**
     * Constructor.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in
     * a first-to-last fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(renderOrder = "forward", renderActiveLegLast = true) {
      this.renderOrder = renderOrder;
      this.renderActiveLegLast = renderActiveLegLast;
    }
    /**
     * Renders a flight plan path to a canvas.
     * @param plan The flight plan to render.
     * @param startIndex The global index of the first flight plan leg to render, inclusive. Defaults to `0`.
     * @param endIndex The global index of the last flight plan leg to render, inclusive. Defaults to `plan.length - 1`.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param args Additional arguments.
     */
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
      startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0;
      endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = plan.length - 1;
      const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
      const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : void 0;
      const isReverse = this.renderOrder === "reverse";
      if (isReverse) {
        const oldEndIndex = endIndex;
        endIndex = startIndex;
        startIndex = oldEndIndex;
      }
      let index = startIndex;
      const delta = isReverse ? -1 : 1;
      for (const leg of plan.legs(isReverse, startIndex)) {
        if ((index - endIndex) * delta > 0) {
          break;
        }
        if (this.renderActiveLegLast && index === activeLegIndex) {
          index += delta;
          continue;
        }
        this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
        index += delta;
      }
      if (this.renderActiveLegLast && activeLeg) {
        this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
      }
    }
  };
  var FlightPathLegRenderPart;
  (function(FlightPathLegRenderPart2) {
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["None"] = 0] = "None";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Ingress"] = 1] = "Ingress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Base"] = 2] = "Base";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Egress"] = 4] = "Egress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["All"] = 7] = "All";
  })(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
  var AbstractFlightPathLegRenderer = class {
    constructor() {
      this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    /**
     * Renders a flight plan leg path to a canvas.
     * @param leg The flight plan leg to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream stack to which to render.
     * @param partsToRender The parts of the leg to render, as a combination of {@link FlightPathLegRenderPart}
     * values.
     * @param args Additional arguments.
     */
    render(leg, context, streamStack, partsToRender, ...args) {
      const legCalc = leg.calculated;
      if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
        return;
      }
      const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
      const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
      const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
      let mainVectors = legCalc.ingressToEgress;
      let mainVectorStartIndex = 0;
      let mainVectorEndIndex = legCalc.ingressToEgress.length;
      if (excludeIngress || excludeEgress) {
        mainVectors = legCalc.flightPath;
        mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
      }
      if (!excludeIngress) {
        for (let i = 0; i < legCalc.ingress.length; i++) {
          this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
        }
        if (excludeEgress && !excludeBase) {
          mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
          const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
          const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
          if (lastIngressVector && ingressJoinVector) {
            const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            if (!ingressEnd.equals(vectorEnd)) {
              const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
            mainVectorStartIndex++;
          }
        }
      }
      if (!excludeBase) {
        const len = Math.min(mainVectorEndIndex, mainVectors.length);
        for (let i = mainVectorStartIndex; i < len; i++) {
          this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
        }
      }
      if (!excludeEgress) {
        if (excludeIngress && !excludeBase) {
          const firstEgressVector = legCalc.egress[0];
          const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
          if (firstEgressVector && egressJoinVector) {
            const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
            const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
            if (!egressStart.equals(egressJoinVectorStart)) {
              const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
          }
        }
        for (let i = 0; i < legCalc.egress.length; i++) {
          this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
        }
      }
    }
  };
  AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var CustomFlightPathLegRenderer = class extends AbstractFlightPathLegRenderer {
    /**
     * Constructor.
     * @param renderVector A function which renders individual flight path vectors.
     */
    constructor(renderVector) {
      super();
      this.renderVector = renderVector;
    }
  };
  var FlightPathLegLineRenderer = class extends AbstractFlightPathLegRenderer {
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector) {
      super();
      this.styleSelector = styleSelector;
      this.pathRenderer = new GeoCirclePathRenderer();
      this.styleBuffer = [
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        },
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        }
      ];
      this.activeStyleIndex = 0;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = false;
    }
    /** @inheritdoc */
    render(leg, context, streamStack, partsToRender, ...args) {
      this.isAtLegStart = true;
      this.needStrokeLineAtLegEnd = false;
      super.render(leg, context, streamStack, partsToRender, ...args);
      if (this.needStrokeLineAtLegEnd) {
        this.strokeLine(context, this.styleBuffer[(this.activeStyleIndex + 1) % 2]);
        this.needStrokeLineAtLegEnd = false;
      }
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack, ...args) {
      const style = this.styleSelector(vector, isIngress, isEgress, leg, streamStack.getProjection(), this.styleBuffer[this.activeStyleIndex], ...args);
      const previousStyle = this.styleBuffer[(this.activeStyleIndex + 1) % 2];
      const didStyleChange = !this.isAtLegStart && !FlightPathLegLineRenderer.areStylesEqual(style, previousStyle);
      const continuePath = !this.isAtLegStart && style.isContinuous && !didStyleChange;
      if (didStyleChange) {
        this.strokeLine(context, previousStyle);
        this.needStrokeLineAtLegEnd = false;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathLegLineRenderer.geoCircleCache[1]);
      this.pathRenderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, streamStack, continuePath);
      this.activeStyleIndex = (this.activeStyleIndex + 1) % 2;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = true;
    }
    /**
     * Applies a stroke to a canvas context.
     * @param context A canvas 2D rendering context.
     * @param style The style of the line to stroke.
     */
    strokeLine(context, style) {
      var _a, _b;
      if (style.outlineWidth > 0) {
        const outlineWidth = style.strokeWidth + 2 * style.outlineWidth;
        context.lineWidth = outlineWidth;
        context.strokeStyle = style.outlineStyle;
        context.setLineDash((_a = style.outlineDash) !== null && _a !== void 0 ? _a : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      if (style.strokeWidth > 0) {
        context.lineWidth = style.strokeWidth;
        context.strokeStyle = style.strokeStyle;
        context.setLineDash((_b = style.strokeDash) !== null && _b !== void 0 ? _b : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
    }
    /**
     * Checks if two line styles are equal. Styles are considered equal if and only if their stroke and outline widths
     * are zero, or their stroke and outline widths, styles, and dash arrays are the same.
     * @param style1 The first style.
     * @param style2 The second style.
     * @returns Whether the two line styles are equal.
     */
    static areStylesEqual(style1, style2) {
      return (style1.strokeWidth === 0 && style2.strokeWidth === 0 || style1.strokeWidth === style2.strokeWidth && style1.strokeStyle === style2.strokeStyle && style1.strokeDash === style2.strokeDash) && (style1.outlineWidth === 0 && style2.outlineWidth === 0 || style1.outlineWidth === style2.outlineWidth && style1.outlineStyle === style2.outlineStyle && style1.outlineDash === style2.outlineDash);
    }
  };
  FlightPathLegLineRenderer.EMPTY_DASH = [];
  FlightPathLegLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorPatternRenderer = class {
    constructor() {
      this.renderer = new GeoCirclePatternRenderer();
    }
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param pattern The pattern to render.
     * @param continuePath Whether to continue the previously rendered path. If true, a discontinuity in the rendered
     * path will not be inserted before the vector is rendered. This may lead to undesired artifacts if the previously
     * rendered path does not terminate at the point where the projected vector starts. Defaults to false.
     */
    render(vector, context, streamStack, pattern, continuePath = false) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorPatternRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, pattern, continuePath);
    }
  };
  FlightPathVectorPatternRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathLegPatternRenderer = class extends AbstractFlightPathLegRenderer {
    /**
     * Constructor.
     * @param styleSelector A function which selects a style for each rendered vector.
     */
    constructor(styleSelector) {
      super();
      this.styleSelector = styleSelector;
      this.pathRenderer = new FlightPathVectorPatternRenderer();
      this.style = {
        pattern: null,
        isContinuous: false
      };
      this.isAtDiscontinuity = false;
    }
    /** @inheritdoc */
    render(leg, context, streamStack, partsToRender, ...args) {
      this.isAtDiscontinuity = true;
      super.render(leg, context, streamStack, partsToRender, ...args);
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack, ...args) {
      const style = this.styleSelector(vector, isIngress, isEgress, leg, streamStack.getProjection(), this.style, ...args);
      const continuePath = !this.isAtDiscontinuity && style.isContinuous;
      if (style.pattern) {
        this.pathRenderer.render(vector, context, streamStack, style.pattern, continuePath);
        this.isAtDiscontinuity = false;
      } else {
        this.isAtDiscontinuity = true;
      }
    }
  };
  var FlightPathVectorLineRenderer = class {
    constructor() {
      this.renderer = new GeoCircleLineRenderer();
    }
    /**
     * Renders a flight path vector to a canvas.
     * @param vector The flight path vector to render.
     * @param context The canvas 2D rendering context to which to render.
     * @param streamStack The path stream to which to render.
     * @param width The width of the rendered line.
     * @param style The style of the rendered line.
     * @param dash The dash array of the rendered line. Defaults to no dash.
     * @param outlineWidth The width of the outline, in pixels. Defaults to 0 pixels.
     * @param outlineStyle The style of the outline. Defaults to `'black'`.
     */
    render(vector, context, streamStack, width, style, dash, outlineWidth, outlineStyle) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash, outlineWidth, outlineStyle);
    }
  };
  FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var NullAirspaceRenderer = class {
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(airspace, projection, context, lod = 0, stream) {
    }
  };
  var MapAbstractAirspaceRenderer = class {
    /** @inheritdoc */
    render(airspace, projection, context, lod = 0, stream) {
      const shapes = airspace.lods[lod];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        this.renderShape(shapes[i], projection, context, stream);
      }
    }
  };
  var MapSingleLineAirspaceRenderer = class extends MapAbstractAirspaceRenderer {
    /**
     * Constructor.
     * @param lineWidth The stroke width of the rendered airspace line.
     * @param strokeStyle The stroke style of the rendered airspace line.
     * @param dash The dash of the rendered airspace line.
     */
    constructor(lineWidth, strokeStyle, dash) {
      super();
      this.lineWidth = lineWidth;
      this.strokeStyle = strokeStyle;
      this.dash = dash;
    }
    /** @inheritdoc */
    renderShape(shape, projection, context, stream) {
      if (shape.length < 2) {
        return;
      }
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const firstProjected = projection.project(shape[0].end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.moveTo(firstProjected[0], firstProjected[1]);
      let start = shape[0].end;
      const len = shape.length;
      for (let i = 1; i < len; i++) {
        const vector = shape[i];
        const circle = vector.circle;
        if (circle) {
          if (circle.isGreatCircle()) {
            this.pathGreatCircle(circle, start, vector.end, projection, stream);
          } else {
            this.pathSmallCircle(circle, start, vector.end, projection, stream);
          }
        } else {
          const endProjected = projection.project(vector.end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
          stream.moveTo(endProjected[0], endProjected[1]);
        }
        start = vector.end;
      }
      context.lineWidth = this.lineWidth;
      context.strokeStyle = this.strokeStyle;
      context.setLineDash(this.dash);
      context.stroke();
    }
    /**
     * Loads a projection of a great-circle path into a canvas rendering context.
     * @param circle The great circle defining the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     * @param projection The projection to use.
     * @param stream The path stream to which to load the projected path.
     */
    pathGreatCircle(circle, start, end, projection, stream) {
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.lineTo(endProjected[0], endProjected[1]);
    }
    /**
     * Loads a projection of a small-circle path into a canvas rendering context.
     * @param circle The small circle defining the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     * @param projection The projection to use.
     * @param stream The path stream to which to load the projected path.
     */
    pathSmallCircle(circle, start, end, projection, stream) {
      const center = MapSingleLineAirspaceRenderer.geoPointCache[0].setFromCartesian(circle.radius < Math.PI / 2 ? circle.center : Vec3Math.multScalar(circle.center, -1, MapSingleLineAirspaceRenderer.vec3Cache[0]));
      const centerProjected = projection.project(center, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[1]);
      if (start.equals(end)) {
        const radius = Vec2Math.distance(endProjected, centerProjected);
        const startAngle = Math.atan2(endProjected[1] - centerProjected[1], endProjected[0] - centerProjected[0]);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, startAngle + 2 * Math.PI);
        stream.moveTo(endProjected[0], endProjected[1]);
      } else {
        const startProjected = projection.project(start, MapSingleLineAirspaceRenderer.vec2Cache[2]);
        const startDelta = Vec2Math.sub(startProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[3]);
        const startDeltaMag = Vec2Math.abs(startDelta);
        const endDelta = Vec2Math.sub(endProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[4]);
        const endDeltaMag = Vec2Math.abs(endDelta);
        const radius = (startDeltaMag + endDeltaMag) / 2;
        const startAngle = Vec2Math.theta(startDelta);
        const arcStartX = centerProjected[0] + radius / startDeltaMag * startDelta[0];
        const arcStartY = centerProjected[1] + radius / startDeltaMag * startDelta[1];
        const endAngle = Vec2Math.theta(endDelta);
        const arcEndX = centerProjected[0] + radius / endDeltaMag * endDelta[0];
        const arcEndY = centerProjected[1] + radius / endDeltaMag * endDelta[1];
        stream.lineTo(arcStartX, arcStartY);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, endAngle, circle.radius < Math.PI / 2);
        stream.lineTo(arcEndX, arcEndY);
      }
    }
  };
  MapSingleLineAirspaceRenderer.geoPointCache = [new GeoPoint(0, 0)];
  MapSingleLineAirspaceRenderer.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  MapSingleLineAirspaceRenderer.vec3Cache = [new Float64Array(3)];
  var MapMultiLineAirspaceRenderer = class extends MapAbstractAirspaceRenderer {
    /** @inheritdoc */
    renderShape(shape, projection, context, stream) {
      var _a;
      if (shape.length < 2) {
        return;
      }
      const multiLineShape = (_a = MapMultiLineAirspaceRenderer.tempShape) !== null && _a !== void 0 ? _a : MapMultiLineAirspaceRenderer.tempShape = new Shape();
      multiLineShape.build(shape, projection);
      this.renderLines(multiLineShape, context, stream);
    }
  };
  var Shape = class {
    constructor() {
      this.segments = [];
      this.length = 0;
      this.isClosed = false;
      this.windingOrder = 1;
    }
    /**
     * Builds this shape from a single contiguous airspace shape. Erases the current state of this shape.
     * @param shape An airspace shape.
     * @param projection The projection to use.
     */
    build(shape, projection) {
      if (shape.length < 2) {
        return;
      }
      this.buildSegments(shape, projection);
      let signedArea = 0;
      let prev = this.segments[0];
      for (let i = 1; i < this.length; i++) {
        const segment = this.segments[i];
        signedArea += this.calculateSignedArea(segment, prev);
        prev = segment;
      }
      const first = this.segments[0].end;
      const last = this.segments[this.length - 1].end;
      this.isClosed = Vec2Math.equals(first, last);
      if (!this.isClosed) {
        signedArea += last[0] * first[1] - first[0] * last[1];
      }
      this.windingOrder = signedArea >= 0 ? 1 : -1;
      this.calculateVertices();
    }
    /**
     * Builds this shape's segments from a single contiguous airspace shape.
     * @param shape An airspace shape.
     * @param projection The projection to use.
     */
    buildSegments(shape, projection) {
      this.buildStartSegment(projection, 0, shape[0]);
      let start = shape[0].end;
      this.length = shape.length;
      for (let i = 1; i < this.length; i++) {
        const vector = shape[i];
        this.buildSegment(projection, i, vector, start);
        start = vector.end;
      }
    }
    /**
     * Builds a single segment from an airspace shape vector.
     * @param projection The projection to use.
     * @param index The index of the segment to build.
     * @param vector An airspace shape vector.
     * @param start The start point of the airspace shape vector.
     */
    buildSegment(projection, index, vector, start) {
      const circle = vector.circle;
      if (circle) {
        if (circle.isGreatCircle()) {
          this.buildSegmentFromGreatCircle(projection, index, circle, start, vector.end);
        } else {
          this.buildSegmentFromSmallCircle(projection, index, circle, start, vector.end);
        }
      } else {
        this.buildStartSegment(projection, index, vector);
      }
    }
    /**
     * Builds a start segment from an airspace shape vector.
     * @param projection The projection to use.
     * @param index The index of the segment to build.
     * @param vector An airspace shape vector.
     */
    buildStartSegment(projection, index, vector) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "start";
      projection.project(vector.end, segment.end);
    }
    /**
     * Builds a segment from a great-circle path.
     * @param projection The projection to use.
     * @param index The index of the segment to build.
     * @param circle The great circle which defines the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     */
    buildSegmentFromGreatCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "line";
      projection.project(end, segment.end);
      const delta = Vec2Math.sub(segment.end, this.segments[index - 1].end, Shape.vec2Cache[0]);
      Vec2Math.normalize(Vec2Math.normal(delta, segment.endNormal), segment.endNormal);
    }
    /**
     * Builds a segment from a small-circle path.
     * @param projection The projection to use.
     * @param index The index of the segment to build.
     * @param circle The small circle which defines the path.
     * @param start The start point of the path.
     * @param end The end point of the path.
     */
    buildSegmentFromSmallCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const isClockwise = circle.radius > Math.PI / 2;
      const center = Shape.geoPointCache[0].setFromCartesian(isClockwise ? Vec3Math.multScalar(circle.center, -1, Shape.vec3Cache[0]) : circle.center);
      const startProjected = this.segments[index - 1].end;
      const centerProjected = projection.project(center, Shape.vec2Cache[0]);
      const endProjected = projection.project(end, Shape.vec2Cache[1]);
      const startRadial = Vec2Math.sub(startProjected, centerProjected, Shape.vec2Cache[2]);
      const startRadialMag = Vec2Math.abs(startRadial);
      const endRadial = Vec2Math.sub(endProjected, centerProjected, Shape.vec2Cache[3]);
      const endRadialMag = Vec2Math.abs(endRadial);
      const radius = (startRadialMag + endRadialMag) / 2;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "arc";
      segment.radius = radius;
      segment.isClockwise = isClockwise;
      Vec2Math.copy(centerProjected, segment.center);
      Vec2Math.copy(endProjected, segment.end);
      Vec2Math.normalize(startRadial, segment.startNormal);
      Vec2Math.normalize(endRadial, segment.endNormal);
    }
    /**
     * Calculates the doubled signed area of a segment.
     * @param segment A segment.
     * @param prevSegment The segment immediately preceding `segment`.
     * @returns Twice the signed area of the segment.
     */
    calculateSignedArea(segment, prevSegment) {
      if (segment.type === "start") {
        return 0;
      }
      if (segment.type === "line") {
        return prevSegment.end[0] * segment.end[1] - segment.end[0] * prevSegment.end[1];
      }
      const startRadial = Vec2Math.sub(prevSegment.end, segment.center, Shape.vec2Cache[0]);
      const startTheta = Vec2Math.theta(startRadial);
      const endRadial = Vec2Math.sub(segment.end, segment.center, Shape.vec2Cache[1]);
      const endTheta = Vec2Math.theta(endRadial);
      const angularWidth = Shape.getAngularWidth(startTheta, endTheta, segment.isClockwise, true);
      return prevSegment.end[0] * segment.center[1] - segment.center[0] * prevSegment.end[1] + segment.center[0] * segment.end[1] - segment.end[0] * segment.center[1] + angularWidth * segment.radius * segment.radius * (segment.isClockwise ? 1 : -1);
    }
    /**
     * Calculates vertex data for this shape.
     */
    calculateVertices() {
      const max = this.isClosed ? this.length - 1 : this.length;
      for (let i = 0; i < this.length; i++) {
        const next = this.isClosed ? i % max + 1 : (i + 1) % max;
        this.calculateVertex(i, next);
      }
    }
    /**
     * Calculates data for a vertex.
     * @param currIndex The index of the segment leading to the vertex to calculate.
     * @param nextIndex The index of the segment leading away from the vertex to calculate.
     */
    calculateVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      if (curr.type === "start" && next.type === "start") {
        curr.vertex.type = "null";
        curr.vertex.fromIndex = currIndex;
        curr.vertex.toIndex = nextIndex;
      } else if (curr.type === "start" && next.type === "line") {
        this.calculateLineStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "line" && next.type === "start") {
        this.calculateLineStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "start" && next.type === "arc") {
        this.calculateArcStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "arc" && next.type === "start") {
        this.calculateArcStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "line" && next.type === "line") {
        this.calculateLineLineVertex(currIndex, nextIndex);
      } else if (curr.type === "line" && next.type === "arc") {
        this.calculateLineArcVertex(currIndex, nextIndex, false);
      } else if (curr.type === "arc" && next.type === "line") {
        this.calculateLineArcVertex(currIndex, nextIndex, true);
      } else {
        this.calculateArcArcVertex(currIndex, nextIndex);
      }
    }
    /**
     * Calculates data for a vertex connecting a line segment with a start segment.
     * @param currIndex The index of the segment leading to the vertex to calculate.
     * @param nextIndex The index of the segment leading away from the vertex to calculate.
     * @param isStartFirst Whether the start segment leads to the vertex.
     */
    calculateLineStartVertex(currIndex, nextIndex, isStartFirst) {
      const line = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "line-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.multScalar(line.endNormal, this.windingOrder, vertex.normal);
    }
    /**
     * Calculates data for a vertex connecting an arc segment with a start segment.
     * @param currIndex The index of the segment leading to the vertex to calculate.
     * @param nextIndex The index of the segment leading away from the vertex to calculate.
     * @param isStartFirst Whether the start segment leads to the vertex.
     */
    calculateArcStartVertex(currIndex, nextIndex, isStartFirst) {
      const arc = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "arc-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const arcNormal = isStartFirst ? arc.startNormal : arc.endNormal;
      Vec2Math.multScalar(arcNormal, this.windingOrder * (arc.isClockwise ? 1 : -1), vertex.normal);
    }
    /**
     * Calculates data for a vertex connecting two line segments.
     * @param currIndex The index of the segment leading to the vertex to calculate.
     * @param nextIndex The index of the segment leading away from the vertex to calculate.
     */
    calculateLineLineVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "line-line";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.normalize(Vec2Math.multScalar(Vec2Math.add(curr.endNormal, next.endNormal, vertex.normal), this.windingOrder, vertex.normal), vertex.normal);
      const deltaUnit = Vec2Math.normalize(Vec2Math.sub(next.end, curr.end, Shape.vec2Cache[0]), Shape.vec2Cache[0]);
      const scaleFactor = Math.abs(1 / (vertex.normal[0] * deltaUnit[1] - vertex.normal[1] * deltaUnit[0]));
      Vec2Math.multScalar(vertex.normal, scaleFactor, vertex.normal);
    }
    /**
     * Calculates data for a vertex connecting an arc segment with an arc segment.
     * @param currIndex The index of the segment leading to the vertex to calculate.
     * @param nextIndex The index of the segment leading away from the vertex to calculate.
     * @param isArcFirst Whether the arc segment leads to the vertex.
     */
    calculateLineArcVertex(currIndex, nextIndex, isArcFirst) {
      const curr = this.segments[currIndex];
      const line = this.segments[isArcFirst ? nextIndex : currIndex];
      const arc = this.segments[isArcFirst ? currIndex : nextIndex];
      const end = curr.end;
      const vertex = curr.vertex;
      vertex.type = "line-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      vertex.arcOffsetSign = this.windingOrder * (arc.isClockwise ? 1 : -1);
      const centerEndDelta = Vec2Math.sub(isArcFirst ? arc.end : line.end, arc.center, Shape.vec2Cache[0]);
      const dot = centerEndDelta[1] * line.endNormal[0] - centerEndDelta[0] * line.endNormal[1];
      const theta = Vec2Math.theta(line.endNormal) + (dot >= 0 ? Math.PI / 2 : -Math.PI / 2);
      Shape.transformCache[0].toTranslation(-arc.center[0], -arc.center[1]);
      const rotation = Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.r0 = arc.radius;
      vertex.y0 = vertex.transform.apply(end, Shape.vec2Cache[0])[1];
      vertex.lineOffsetSign = rotation.apply(line.endNormal, Shape.vec2Cache[0])[1] >= 0 ? this.windingOrder : -this.windingOrder;
      vertex.transform.invert();
    }
    /**
     * Calculates data for a vertex connecting two arc segments.
     * @param currIndex The index of the segment leading to the vertex to calculate.
     * @param nextIndex The index of the segment leading away from the vertex to calculate.
     */
    calculateArcArcVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "arc-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const centerDelta = Vec2Math.sub(next.center, curr.center, Shape.vec2Cache[0]);
      const centerEndDelta = Vec2Math.sub(curr.end, curr.center, Shape.vec2Cache[1]);
      const dot = centerDelta[0] * centerEndDelta[1] - centerDelta[1] * centerEndDelta[0];
      const theta = Vec2Math.theta(centerDelta) + (dot >= 0 ? 0 : Math.PI);
      Shape.transformCache[0].toTranslation(-curr.center[0], -curr.center[1]);
      Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.d = vertex.transform.apply(next.center, Shape.vec2Cache[0])[0];
      vertex.arcOffsetSign = this.windingOrder * (curr.isClockwise ? 1 : -1);
      vertex.arc2OffsetSign = this.windingOrder * (next.isClockwise ? 1 : -1);
      vertex.transform.invert();
    }
    /** @inheritdoc */
    renderLine(context, offset, lineWidth, strokeStyle, dash, stream) {
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const startPoint = Vec2Math.set(0, 0, Shape.vec2Cache[0]);
      if (this.isClosed) {
        if (offset === 0) {
          Vec2Math.copy(this.segments[0].end, startPoint);
        } else {
          const lastIndex = this.length - 1;
          const result = this.calculateOffsetVertex(lastIndex, offset, startPoint);
          if (!result || Shape.isPointInSegmentBounds(this.segments[lastIndex], this.segments[lastIndex - 1].end, result)) {
            this.calculateOffsetEndPoint(lastIndex, offset, startPoint);
          }
        }
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      for (let i = this.isClosed ? 1 : 0; i < this.length; i++) {
        const segment = this.segments[i];
        let newStartPoint;
        switch (segment.type) {
          case "start":
            newStartPoint = this.pathStartSegment(stream, i, offset);
            break;
          case "line":
            newStartPoint = this.pathLineSegment(stream, i, startPoint, offset);
            break;
          case "arc":
            newStartPoint = this.pathArcSegment(stream, i, startPoint, offset);
            break;
        }
        Vec2Math.copy(newStartPoint, startPoint);
      }
      context.lineWidth = lineWidth;
      context.strokeStyle = strokeStyle;
      context.setLineDash(dash);
      context.stroke();
    }
    /**
     * Loads a path for a start segment to a canvas rendering context.
     * @param stream The path stream to which to load the path.
     * @param index The index of the start segment.
     * @param offset The offset of the path from the segment, in pixels.
     * @returns The end point of the loaded path.
     */
    pathStartSegment(stream, index, offset) {
      const segment = this.segments[index];
      if (offset === 0) {
        stream.moveTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd) {
          stream.moveTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          stream.moveTo(segment.end[0], segment.end[1]);
          return segment.end;
        }
      }
    }
    /**
     * Loads a path for a line segment to a canvas rendering context.
     * @param stream The path stream to which to load the path.
     * @param index The index of the line segment.
     * @param start The start point of the line segment.
     * @param offset The offset of the path from the segment, in pixels.
     * @returns The end point of the loaded path.
     */
    pathLineSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      if (offset === 0) {
        stream.lineTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          stream.lineTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
          stream.lineTo(endPoint[0], endPoint[1]);
          const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
          stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
          return nextStartPoint;
        }
      }
    }
    /**
     * Loads a path for an arc segment to a canvas rendering context.
     * @param stream The path stream to which to load the path.
     * @param index The index of the arc segment.
     * @param start The start point of the arc segment.
     * @param offset The offset of the path from the segment, in pixels.
     * @returns The end point of the loaded path.
     */
    pathArcSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      let startAngle;
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
        startAngle = Math.atan2(startPoint[1] - segment.center[1], startPoint[0] - segment.center[0]);
      } else {
        startAngle = Math.atan2(start[1] - segment.center[1], start[0] - segment.center[0]);
      }
      if (offset === 0) {
        const endAngle = Vec2Math.theta(segment.endNormal);
        const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
        stream.arc(segment.center[0], segment.center[1], segment.radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), !segment.isClockwise);
        return segment.end;
      } else {
        const baseEndAngle = Vec2Math.theta(segment.endNormal);
        const baseAngularWidth = Shape.getAngularWidth(startAngle, baseEndAngle, segment.isClockwise, true);
        const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
        const radius = segment.radius + offset * sign;
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          const endAngle = Math.atan2(offsetEnd[1] - segment.center[1], offsetEnd[0] - segment.center[0]);
          const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
          const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
          stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
          return offsetEnd;
        } else {
          if (radius > 0) {
            const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
            const endAngle = Math.atan2(endPoint[1] - segment.center[1], endPoint[0] - segment.center[0]);
            const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
            const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
            stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
            const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
            stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
            return nextStartPoint;
          } else {
            stream.moveTo(segment.center[0], segment.center[1]);
            return segment.center;
          }
        }
      }
    }
    /**
     * Calculates an offset point for a vertex.
     * @param index The index of the segment leading to the vertex to offset.
     * @param offset The offset to apply, in pixels.
     * @param out The vector to which to write the result.
     * @returns The offset vertex point, or undefined if one could not be calculated.
     */
    calculateOffsetVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      switch (vertex.type) {
        case "line-start":
        case "arc-start":
        case "line-line":
          return this.calculateOffsetVertexFromNormal(index, offset, out);
        case "line-arc":
          return this.calculateOffsetLineArcVertex(index, offset, out);
        case "arc-arc":
          return this.calculateOffsetArcArcVertex(index, offset, out);
        default:
          return Vec2Math.copy(this.segments[vertex.fromIndex].end, out);
      }
    }
    /**
     * Calculates an offset point for a vertex which defines a normal vector.
     * @param index The index of the segment leading to the vertex to offset.
     * @param offset The offset to apply, in pixels.
     * @param out The vector to which to write the result.
     * @returns The offset vertex point, or undefined if one could not be calculated.
     */
    calculateOffsetVertexFromNormal(index, offset, out) {
      const segment = this.segments[index];
      const vertex = segment.vertex;
      return Vec2Math.add(segment.end, Vec2Math.multScalar(vertex.normal, offset, out), out);
    }
    /**
     * Calculates an offset point for a vertex which connects a line segment with an arc segment.
     * @param index The index of the segment leading to the vertex to offset.
     * @param offset The offset to apply, in pixels.
     * @param out The vector to which to write the result.
     * @returns The offset vertex point, or undefined if one could not be calculated.
     */
    calculateOffsetLineArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      const radius = vertex.r0 + offset * vertex.arcOffsetSign;
      if (radius <= 0) {
        return void 0;
      }
      const y = vertex.y0 + offset * vertex.lineOffsetSign;
      const xSq = radius * radius - y * y;
      if (xSq < 0) {
        return void 0;
      }
      const x = Math.sqrt(xSq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    /**
     * Calculates an offset point for a vertex which connects two arc segments.
     * @param index The index of the segment leading to the vertex to offset.
     * @param offset The offset to apply, in pixels.
     * @param out The vector to which to write the result.
     * @returns The offset vertex point, or undefined if one could not be calculated.
     */
    calculateOffsetArcArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      if (vertex.d === 0) {
        return void 0;
      }
      const segment1 = this.segments[vertex.fromIndex];
      const segment2 = this.segments[vertex.toIndex];
      const radius1 = segment1.radius + offset * vertex.arcOffsetSign;
      const radius2 = segment2.radius + offset * vertex.arc2OffsetSign;
      if (radius1 <= 0 || radius2 <= 0) {
        return void 0;
      }
      const dSq = vertex.d * vertex.d;
      const radius1Sq = radius1 * radius1;
      const radius2Sq = radius2 * radius2;
      const x = (dSq - radius2Sq + radius1Sq) / (2 * vertex.d);
      const ySq = radius1Sq - x * x;
      if (ySq < 0) {
        return void 0;
      }
      const y = Math.sqrt(ySq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    /**
     * Calculates an offset start point for a segment.
     * @param index The index of the segment to offset.
     * @param offset The offset to apply, in pixels.
     * @param out The vector to which to write the result.
     * @returns The offset start point.
     */
    calculateOffsetStartPoint(index, offset, out) {
      const prevSegment = this.segments[index - 1];
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(prevSegment.end[0] + segment.endNormal[0] * this.windingOrder * offset, prevSegment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(prevSegment.end[0] + segment.startNormal[0] * sign * offset, prevSegment.end[1] + segment.startNormal[1] * sign * offset, out);
        }
      }
    }
    /**
     * Calculates an offset end point for a segment.
     * @param index The index of the segment to offset.
     * @param offset The offset to apply, in pixels.
     * @param out The vector to which to write the result.
     * @returns The offset end point.
     */
    calculateOffsetEndPoint(index, offset, out) {
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * this.windingOrder * offset, segment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * sign * offset, segment.end[1] + segment.endNormal[1] * sign * offset, out);
        }
      }
    }
    /**
     * Checks whether a point lies within the bounds of a segment. If the segment is a start segment, all points are
     * considered to be in bounds. If the segment is a line or arc segment, a point is in bounds if and only if its
     * projection on the line or arc lies within the start and end points of the segment.
     * @param segment A segment.
     * @param start The start point of the segment.
     * @param point The query point.
     * @returns Whether the point lies within the bounds of the segment.
     */
    static isPointInSegmentBounds(segment, start, point) {
      if (segment.type === "start") {
        return true;
      }
      if (segment.type === "line") {
        const lineDeltaX = segment.end[0] - start[0];
        const lineDeltaY = segment.end[1] - start[1];
        const startDeltaX = point[0] - start[0];
        const startDeltaY = point[1] - start[1];
        const endDeltaX = point[0] - segment.end[0];
        const endDeltaY = point[1] - segment.end[1];
        const startDot = startDeltaX * lineDeltaX + startDeltaY * lineDeltaY;
        const endDot = endDeltaX * lineDeltaX + endDeltaY * lineDeltaY;
        return startDot >= 0 && endDot <= 0;
      }
      const startAngle = Vec2Math.theta(segment.startNormal);
      const endAngle = Vec2Math.theta(segment.endNormal);
      const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
      const pointAngle = Math.atan2(point[1] - segment.center[1], point[0] - segment.center[0]);
      const angleDiff = Shape.getAngularWidth(startAngle, pointAngle, segment.isClockwise);
      return angleDiff <= angularWidth;
    }
    /**
     * Gets the angle subtended by an arc.
     * @param startAngle The radial angle of the arc's start point.
     * @param endAngle The radial angle of the arc's end point.
     * @param isClockwise Whether the arc runs clockwise.
     * @param zeroIsCircle Whether to consider a zero-angular-width arc to be a full circle. False by default.
     * @param zeroTolerance The tolerance of the zero-angular-width check used when `zeroIsCircle` is true. Defaults to
     * 1e-6.
     * @returns The angle subtended by the arc, in radians.
     */
    static getAngularWidth(startAngle, endAngle, isClockwise, zeroIsCircle = false, zeroTolerance = 1e-6) {
      const width = ((isClockwise ? endAngle - startAngle : startAngle - endAngle) + 2 * Math.PI) % (2 * Math.PI);
      return zeroIsCircle && Math.min(width, 2 * Math.PI - width) < zeroTolerance ? 2 * Math.PI : width;
    }
    /**
     * Creates a new segment.
     * @returns A new segment.
     */
    static createSegment() {
      return {
        type: "arc",
        center: new Float64Array(2),
        radius: 0,
        isClockwise: false,
        end: new Float64Array(2),
        endNormal: new Float64Array(2),
        startNormal: new Float64Array(2),
        vertex: {
          type: "null",
          fromIndex: -1,
          toIndex: -1,
          normal: new Float64Array(2),
          transform: new Transform2D(),
          r0: 0,
          y0: 0,
          lineOffsetSign: 1,
          arcOffsetSign: 1,
          arc2OffsetSign: 1,
          d: 0
        }
      };
    }
  };
  Shape.geoPointCache = [new GeoPoint(0, 0)];
  Shape.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  Shape.vec3Cache = [new Float64Array(3)];
  Shape.transformCache = [new Transform2D(), new Transform2D()];
  var MapFieldOfViewCalculator = class {
    /**
     * Constructor.
     * @param maxIter The maximum number of iterations to perform when calculating fields of view. Defaults to
     * {@link MapFieldOfViewCalculator.DEFAULT_MAX_ITER}.
     * @param rangeTolerance The error tolerance of calculated field of view ranges, as a fraction of the ideal range for
     * each field of view. Defaults to {@link MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE}.
     */
    constructor(maxIter = MapFieldOfViewCalculator.DEFAULT_MAX_ITER, rangeTolerance = MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE) {
      this.maxIter = maxIter;
      this.rangeTolerance = rangeTolerance;
      this.tempProjection = new MapProjection(100, 100);
    }
    /**
     * Calculates a map field of view, consisting of a range and target location, which encompasses a given set of
     * geographic points (the focus) with the smallest possible range. If there is only one point in the specified focus,
     * then the calculated range will be equal to 0. If the specified focus contains zero points or a field of view could
     * not be calculated, `NaN` will be written to the results.
     * @param mapProjection The projection of the map for which to calculate the field of view.
     * @param focus An array of points comprising the focus of the field of view.
     * @param margins The margins around the projected map boundaries to respect, as `[left, top, right, bottom]` in
     * pixels. The field of view will be calculated in order to avoid placing any points in the focus outside of the
     * margins.
     * @param out The object to which to write the results.
     * @returns The calculated field of view for the specified focus.
     */
    calculateFov(mapProjection, focus, margins, out) {
      out.range = NaN;
      out.target.set(NaN, NaN);
      if (focus.length === 0) {
        return out;
      }
      const projectedSize = mapProjection.getProjectedSize();
      const targetWidth = projectedSize[0] - margins[0] - margins[2];
      const targetHeight = projectedSize[1] - margins[1] - margins[3];
      if (targetWidth * targetHeight <= 0) {
        return out;
      }
      const mean = Vec3Math.set(0, 0, 0, MapFieldOfViewCalculator.vec3Cache[0]);
      for (let i = 0; i < focus.length; i++) {
        Vec3Math.add(mean, GeoPoint.sphericalToCartesian(focus[i], MapFieldOfViewCalculator.vec3Cache[1]), mean);
      }
      Vec3Math.multScalar(mean, 1 / focus.length, mean);
      this.tempProjection.set({
        projectedSize: mapProjection.getProjectedSize(),
        rotation: mapProjection.getRotation(),
        target: MapFieldOfViewCalculator.geoPointCache[0].setFromCartesian(mean),
        targetProjectedOffset: Vec2Math.set(margins[0] + (targetWidth - projectedSize[0]) / 2, margins[1] + (targetHeight - projectedSize[1]) / 2, MapFieldOfViewCalculator.vec2Cache[0]),
        rangeEndpoints: mapProjection.getRangeEndpoints(),
        range: mapProjection.getRange()
      });
      let minX;
      let minY;
      let maxX;
      let maxY;
      for (let i = 0; i < focus.length; i++) {
        const projected = this.tempProjection.project(focus[i], MapFieldOfViewCalculator.vec2Cache[0]);
        minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
        minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
        maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
        maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
      }
      if (minX === void 0 || minY === void 0 || maxX === void 0 || maxY === void 0) {
        return out;
      }
      let focusWidth = maxX - minX;
      let focusHeight = maxY - minY;
      if (focusWidth === 0 && focusHeight === 0) {
        out.target.set(focus[0]);
        out.range = 0;
        return out;
      }
      this.tempProjection.invert(Vec2Math.set((minX + maxX) / 2, (minY + maxY) / 2, MapFieldOfViewCalculator.vec2Cache[0]), out.target);
      this.tempProjection.set({
        target: out.target
      });
      let widthRatio = focusWidth / targetWidth;
      let heightRatio = focusHeight / targetHeight;
      let constrainedRatio = Math.max(widthRatio, heightRatio);
      const range = out.range = this.tempProjection.getRange();
      const topLeft = this.tempProjection.invert(Vec2Math.set(minX, minY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[0]);
      const bottomRight = this.tempProjection.invert(Vec2Math.set(maxX, maxY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[1]);
      let iterCount = 0;
      const rangeParam = { range };
      let ratioError = Math.abs(constrainedRatio - 1);
      let deltaRatioError = this.rangeTolerance + 1;
      while (iterCount++ < this.maxIter && ratioError > this.rangeTolerance && deltaRatioError > this.rangeTolerance) {
        rangeParam.range = out.range = this.tempProjection.getRange() * constrainedRatio;
        if (out.range <= GeoPoint.EQUALITY_TOLERANCE) {
          out.range = GeoPoint.EQUALITY_TOLERANCE;
          return out;
        }
        this.tempProjection.set(rangeParam);
        const topLeftProjected = this.tempProjection.project(topLeft, MapFieldOfViewCalculator.vec2Cache[0]);
        const bottomRightProjected = this.tempProjection.project(bottomRight, MapFieldOfViewCalculator.vec2Cache[1]);
        focusWidth = bottomRightProjected[0] - topLeftProjected[0];
        focusHeight = bottomRightProjected[1] - topLeftProjected[1];
        widthRatio = focusWidth / targetWidth;
        heightRatio = focusHeight / targetHeight;
        constrainedRatio = Math.max(widthRatio, heightRatio);
        const newRatioError = Math.abs(constrainedRatio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.tempProjection.invert(mapProjection.getTargetProjected(), out.target);
      return out;
    }
  };
  MapFieldOfViewCalculator.DEFAULT_MAX_ITER = 20;
  MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE = 0.01;
  MapFieldOfViewCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  MapFieldOfViewCalculator.vec2Cache = [Vec2Math.create(), Vec2Math.create()];
  MapFieldOfViewCalculator.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
  var MapOwnAirplaneIconOrientation;
  (function(MapOwnAirplaneIconOrientation2) {
    MapOwnAirplaneIconOrientation2["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation2["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation2["MapUp"] = "MapUp";
  })(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));
  var MapOwnAirplaneIconModule = class {
    constructor() {
      this.show = Subject.create(true);
      this.orientation = Subject.create(MapOwnAirplaneIconOrientation.HeadingUp);
    }
  };
  var MapOwnAirplanePropsModule = class {
    constructor() {
      this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
      this.hdgTrue = Subject.create(0);
      this.turnRate = Subject.create(0);
      this.altitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.verticalSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
      this.trackTrue = Subject.create(0);
      this.groundSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0));
      this.isOnGround = Subject.create(true);
      this.magVar = Subject.create(0);
    }
  };
  var MapAutopilotPropsModule = class {
    constructor() {
      this.selectedAltitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.apSelectedAltitudeHandler = (alt) => {
        this.selectedAltitude.set(alt);
      };
    }
  };
  var MapRangeModule = class {
    constructor() {
      this.nominalRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(1));
    }
  };
  var MapIndexedRangeModule = class {
    /** @inheritdoc */
    constructor() {
      this.nominalRangeIndex = Subject.create(0);
      this.nominalRanges = Subject.create([UnitType.NMILE.createNumber(1)]);
      this.nominalRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(1));
      this.nominalRanges.sub(this.onNominalRangesChanged.bind(this));
    }
    /**
     * A callback which is called when the nominal range array changes.
     * @param array The new array.
     */
    onNominalRangesChanged(array) {
      const currentIndex = this.nominalRangeIndex.get();
      this.setNominalRangeIndex(Utils.Clamp(currentIndex, 0, array.length - 1));
    }
    /**
     * Sets the nominal range by index.
     * @param index The index of the new nominal range.
     * @returns The value of the new nominal range.
     * @throws Error if index of out of bounds.
     */
    setNominalRangeIndex(index) {
      const rangeArray = this.nominalRanges.get();
      if (index < 0 || index >= rangeArray.length) {
        throw new Error("Index out of bounds.");
      }
      const range = rangeArray[index];
      this.nominalRangeIndex.set(index);
      this.nominalRange.set(range);
      return range;
    }
  };
  var MapAirspaceModule = class {
    /**
     * Constructor.
     * @param showTypes A map of this module's airspace show types to their associated nearest boundary search filter
     * bitflags.
     */
    constructor(showTypes) {
      this.showTypes = showTypes;
      this.show = {};
      for (const type in showTypes) {
        this.show[type] = Subject.create(false);
      }
    }
  };
  var MapDataIntegrityModule = class {
    constructor() {
      this.gpsSignalValid = Subject.create(false);
      this.headingSignalValid = Subject.create(false);
      this.attitudeSignalValid = Subject.create(false);
      this.adcSignalValid = Subject.create(false);
    }
  };
  var AbstractCssTransform = class {
    /**
     * Constructor.
     * @param initialParams The transform's initial parameters.
     */
    constructor(initialParams) {
      this.params = new Float64Array(initialParams);
      this.cachedParams = new Float64Array(initialParams);
    }
    /** @inheritdoc */
    resolve() {
      if (this.stringValue !== void 0 && VecNMath.equals(this.params, this.cachedParams)) {
        return this.stringValue;
      }
      VecNMath.copy(this.params, this.cachedParams);
      this.stringValue = this.buildString(this.params);
      return this.stringValue;
    }
  };
  var CssMatrixTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    constructor() {
      super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
      let scaleX;
      if (typeof arg1 === "number") {
        scaleX = arg1;
      } else {
        [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
      }
      this.params[0] = scaleX;
      this.params[1] = skewY;
      this.params[2] = skewX;
      this.params[3] = scaleY;
      this.params[4] = translateX;
      this.params[5] = translateY;
    }
    /** @inheritdoc */
    buildString(params) {
      return `matrix(${params.join(", ")})`;
    }
  };
  CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
  var CssRotateTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
      super(CssRotateTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    /**
     * Sets this transform's rotation angle.
     * @param angle The angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(angle, precision = 0) {
      this.params[0] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `rotate(${params[0]}${this.unit})`;
    }
  };
  CssRotateTransform.DEFAULT_PARAMS = [0];
  var CssRotate3dTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for this transform.
     */
    constructor(unit) {
      super(CssRotate3dTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    /**
     * Sets this transform's rotation.
     * @param x The x component of the rotation axis vector.
     * @param y The y component of the rotation axis vector.
     * @param z The z component of the rotation axis vector.
     * @param angle The rotation angle to set.
     * @param precision The precision with which to set the angle. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, y, z, angle, precision = 0) {
      this.params[0] = x;
      this.params[1] = y;
      this.params[2] = z;
      this.params[3] = precision === 0 ? angle : MathUtils.round(angle, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
  };
  CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
  var CssTranslateXTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
      super(CssTranslateXTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param x The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `translateX(${params[0]}${this.unit})`;
    }
  };
  CssTranslateXTransform.DEFAULT_PARAMS = [0];
  var CssTranslateYTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
      super(CssTranslateYTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param y The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `translateY(${params[0]}${this.unit})`;
    }
  };
  CssTranslateYTransform.DEFAULT_PARAMS = [0];
  var CssTranslateZTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for this transform.
     */
    constructor(unit) {
      super(CssTranslateZTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    /**
     * Sets this transform's translation.
     * @param z The translation to set.
     * @param precision The precision with which to set the translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     */
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `translateZ(${params[0]}${this.unit})`;
    }
  };
  CssTranslateZTransform.DEFAULT_PARAMS = [0];
  var CssTranslateTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX) {
      super(CssTranslateTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
      return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
  };
  CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
  var CssTranslate3dTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for this transform's x translation.
     * @param unitY The unit to use for this transform's y translation. Defaults to the same unit as the x translation.
     * @param unitZ The unit to use for this transform's z translation. Defaults to the same unit as the x translation.
     */
    constructor(unitX, unitY = unitX, unitZ = unitX) {
      super(CssTranslate3dTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
      this.unitZ = unitZ;
    }
    /**
     * Sets this transform's translation.
     * @param x The x translation to set.
     * @param y The y translation to set.
     * @param z The z translation to set.
     * @param precisionX The precision with which to set the x translation. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     * @param precisionZ The precision with which to set the z translation. A value of `0` denotes infinite precision.
     * Defaults to the x translation precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils.round(z, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
      return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
  };
  CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
  var CssScaleXTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    constructor() {
      super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils.round(x, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `scaleX(${params[0]})`;
    }
  };
  CssScaleXTransform.DEFAULT_PARAMS = [1];
  var CssScaleYTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    constructor() {
      super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param y The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils.round(y, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `scaleY(${params[0]})`;
    }
  };
  CssScaleYTransform.DEFAULT_PARAMS = [1];
  var CssScaleZTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    constructor() {
      super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param z The scaling to set.
     * @param precision The precision with which to set the scaling. A value of `0` denotes infinite precision. Defaults
     * to `0`.
     */
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils.round(z, precision);
    }
    /** @inheritdoc */
    buildString(params) {
      return `scaleZ(${params[0]})`;
    }
  };
  CssScaleZTransform.DEFAULT_PARAMS = [1];
  var CssScaleTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    constructor() {
      super(CssScaleTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
    }
    /** @inheritdoc */
    buildString(params) {
      return `scale(${params[0]}, ${params[1]})`;
    }
  };
  CssScaleTransform.DEFAULT_PARAMS = [1, 1];
  var CssScale3dTransform = class extends AbstractCssTransform {
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    constructor() {
      super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    /**
     * Sets this transform's scaling.
     * @param x The x scaling to set.
     * @param y The y scaling to set.
     * @param z The z scaling to set.
     * @param precisionX The precision with which to set the x scaling. A value of `0` denotes infinite precision.
     * Defaults to `0`.
     * @param precisionY The precision with which to set the y scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     * @param precisionZ The precision with which to set the z scaling. A value of `0` denotes infinite precision.
     * Defaults to the x scaling precision value.
     */
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils.round(y, precisionZ);
    }
    /** @inheritdoc */
    buildString(params) {
      return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
  };
  CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
  var CssTransformChain = class {
    /**
     * Creates a new chain of CSS transforms.
     * @param transforms The individual child transforms that will constitute the new transform chain. The order of
     * the children passed to the constructor determines the order of concatenation. Concatenation follows the standard
     * CSS transform convention: for a concatenation of transforms `[A, B, C]`, the resulting transformation is
     * equivalent to the one produced by multiplying the transformation matrices in the order `(A * B) * C`.
     */
    constructor(...transforms) {
      this.stringValues = [];
      this.transforms = transforms;
    }
    /**
     * Gets one of this chain's child transforms.
     * @param index The index of the child to get.
     * @returns The child transform at the specified index in this chain.
     * @throws RangeError if `index` is out of bounds.
     */
    getChild(index) {
      if (index < 0 || index >= this.transforms.length) {
        throw new RangeError();
      }
      return this.transforms[index];
    }
    /** @inheritdoc */
    resolve() {
      let needRebuildString = false;
      for (let i = 0; i < this.transforms.length; i++) {
        const stringValue = this.transforms[i].resolve();
        if (this.stringValues[i] !== stringValue) {
          this.stringValues[i] = stringValue;
          needRebuildString = true;
        }
      }
      if (needRebuildString || this.chainedStringValue === void 0) {
        this.chainedStringValue = this.stringValues.join(" ");
      }
      return this.chainedStringValue;
    }
  };
  var CssTransformSubject = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param transform The new subject's CSS transform.
     */
    constructor(transform) {
      super();
      this._transform = transform;
      this.stringValue = transform.resolve();
      this.transform = transform;
    }
    /** @inheritdoc */
    get() {
      return this.stringValue;
    }
    /**
     * Resolves this subject's CSS transform to a CSS transform string, and sets this subject's value to the resolved
     * string. If this changes this subject's value, subscribers will be notified.
     */
    resolve() {
      const stringValue = this._transform.resolve();
      if (stringValue !== this.stringValue) {
        this.stringValue = stringValue;
        this.notify();
      }
    }
    /**
     * Creates a new instance of {@link CssTransformSubject} whose value is resolved from a CSS transform.
     * @param transform A CSS transform.
     * @returns A new instance of {@link CssTransformSubject} whose value is resolved from the specified CSS transform.
     */
    static create(transform) {
      return new CssTransformSubject(transform);
    }
  };
  var CssTransformBuilder = class {
    /**
     * Creates a new instance of a CSS `matrix` transform, initialized to the identity transformation.
     * @returns A new instance of a CSS `matrix` transform, initialized to the identity transformation.
     */
    static matrix() {
      return new CssMatrixTransform();
    }
    /**
     * Creates a new instance of a CSS `rotate` transform, initialized to zero rotation.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate` transform, initialized to zero rotation.
     */
    static rotate(unit) {
      return new CssRotateTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     * @param unit The angle unit to use for the new transform.
     * @returns A new instance of a CSS `rotate3d` transform, initialized to zero rotation about the z axis.
     */
    static rotate3d(unit) {
      return new CssRotate3dTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateX` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateX` transform, initialized to zero translation.
     */
    static translateX(unit) {
      return new CssTranslateXTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateY` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateY` transform, initialized to zero translation.
     */
    static translateY(unit) {
      return new CssTranslateYTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translateZ` transform, initialized to zero translation.
     * @param unit The unit to use for the new transform.
     * @returns A new instance of a CSS `translateZ` transform, initialized to zero translation.
     */
    static translateZ(unit) {
      return new CssTranslateZTransform(unit);
    }
    /**
     * Creates a new instance of a CSS `translate` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @returns A new instance of a CSS `translate` transform, initialized to zero translation.
     */
    static translate(unitX, unitY) {
      return new CssTranslateTransform(unitX, unitY);
    }
    /**
     * Creates a new instance of a CSS `translate3d` transform, initialized to zero translation.
     * @param unitX The unit to use for the new transform's x translation.
     * @param unitY The unit to use for the new transform's y translation.
     * @param unitZ The unit to use for the new transform's z translation.
     * @returns A new instance of a CSS `translate3d` transform, initialized to zero translation.
     */
    static translate3d(unitX, unitY, unitZ) {
      return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    /**
     * Creates a new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleX` transform, initialized to the identity scaling.
     */
    static scaleX() {
      return new CssScaleXTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleY` transform, initialized to the identity scaling.
     */
    static scaleY() {
      return new CssScaleYTransform();
    }
    /**
     * Creates a new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scaleZ` transform, initialized to the identity scaling.
     */
    static scaleZ() {
      return new CssScaleZTransform();
    }
    /**
     * Creates a new instance of a CSS `scale` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale` transform, initialized to the identity scaling.
     */
    static scale() {
      return new CssScaleTransform();
    }
    /**
     * Creates a new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     * @returns A new instance of a CSS `scale3d` transform, initialized to the identity scaling.
     */
    static scale3d() {
      return new CssScale3dTransform();
    }
    /**
     * Concatenates zero or more CSS transformations.
     * @param transforms The individual transforms to concatentate. The order of the transforms passed to the function
     * determines the order of concatenation. Concatenation follows the standard CSS transform convention: for a
     * concatenation of transforms `[A, B, C]`, the resulting transformation is equivalent to the one produced by
     * multiplying the transformation matrices in the order `(A * B) * C`.
     * @returns A new {@link CssTransformChain} object representing the concatenation of the specified transforms.
     */
    static concat(...transforms) {
      return new CssTransformChain(...transforms);
    }
  };
  var NumberFormatter = class {
    /**
     * Formats a number to a string.
     * @param number The number to format.
     * @param opts Options describing how to format the number.
     * @returns The formatted string representation of the specified number.
     */
    static formatNumber(number, opts) {
      if (isNaN(number)) {
        return opts.nanString;
      }
      const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
      const sign = number < 0 ? -1 : 1;
      const abs = Math.abs(number);
      let rounded = abs;
      if (precision !== 0) {
        rounded = roundFunc(abs / precision) * precision;
      }
      if (cache) {
        if (opts.cachedString !== void 0 && opts.cachedNumber === rounded) {
          return opts.cachedString;
        }
        opts.cachedNumber = rounded;
      }
      const signText = sign === -1 ? useMinusSign ? "\u2212" : "-" : "+";
      let formatted;
      if (precision != 0) {
        const precisionString = `${precision}`;
        const decimalIndex2 = precisionString.indexOf(".");
        if (decimalIndex2 >= 0) {
          formatted = rounded.toFixed(precisionString.length - decimalIndex2 - 1);
        } else {
          formatted = `${rounded}`;
        }
      } else {
        formatted = `${abs}`;
      }
      let decimalIndex = formatted.indexOf(".");
      if (!forceDecimalZeroes && decimalIndex >= 0) {
        formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, "");
        if (formatted.indexOf(".") == formatted.length - 1) {
          formatted = formatted.substring(0, formatted.length - 1);
        }
      }
      decimalIndex = formatted.indexOf(".");
      if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
        const shift = Math.max(maxDigits - decimalIndex, 0);
        const shiftPrecision = Math.pow(0.1, shift);
        formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
      }
      if (pad === 0) {
        formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, ".");
      } else if (pad > 1) {
        decimalIndex = formatted.indexOf(".");
        if (decimalIndex < 0) {
          decimalIndex = formatted.length;
        }
        formatted = formatted.padStart(pad + formatted.length - decimalIndex, "0");
      }
      if (showCommas) {
        const parts = formatted.split(".");
        parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ",");
        formatted = parts.join(".");
      }
      formatted = (forceSign || signText !== "+" ? signText : "") + formatted;
      if (cache) {
        opts.cachedString = formatted;
      }
      return formatted;
    }
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * * `cache = false`
     * @returns A function which formats numeric values to strings.
     */
    static create(options) {
      const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
      optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
      return (number) => {
        return NumberFormatter.formatNumber(number, optsToUse);
      };
    }
  };
  NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: "NaN",
    cache: false
  };
  NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
  };
  NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
  NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
  NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;
  var SvgPathStream = class {
    /**
     * Constructor.
     * @param precision The precision of this stream. All coordinates will be rounded to this stream's precision when
     * building the SVG path string. A value of `0` indicates infinite precision. Defaults to `0`.
     */
    constructor(precision = 0) {
      this.svgPath = "";
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.precision = precision;
      this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    /**
     * Gets the SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     * @returns The SVG path string describing all path commands consumed by this stream since the last call to
     * `beginPath()`.
     */
    getSvgPath() {
      return this.svgPath.trim();
    }
    /**
     * Gets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @returns The precision of this stream.
     */
    getPrecision() {
      return this.precision;
    }
    /**
     * Sets the precision of this stream. All coordinates will be rounded to this stream's precision when building the
     * SVG path string. A value of `0` indicates infinite precision.
     * @param precision The precision of this stream. Negative numbers will be converted to their absolute values.
     */
    setPrecision(precision) {
      this.precision = Math.abs(precision);
      this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    /** @inheritdoc */
    beginPath() {
      this.reset();
    }
    /** @inheritdoc */
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    /** @inheritdoc */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = counterClockwise ? MathUtils.diffAngle(endAngle, startAngle) : MathUtils.diffAngle(startAngle, endAngle);
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(MathUtils.TWO_PI, (endAngle - startAngle) * directionSign);
      if (angularWidth === MathUtils.TWO_PI) {
        const midAngle = startAngle + Math.PI * directionSign;
        this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
        this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
      const radiusString = this.formatter(radius);
      this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
      Vec2Math.copy(endPoint, this.prevPoint);
    }
    /** @inheritdoc */
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    /**
     * Resets the state of this stream.
     */
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.svgPath = "";
    }
  };
  SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var MapSystemKeys = class {
  };
  MapSystemKeys.TargetControl = "targetControlModerator";
  MapSystemKeys.RotationControl = "rotationControlModerator";
  MapSystemKeys.RangeControl = "rangeControlModerator";
  MapSystemKeys.ClockUpdate = "clockUpdate";
  MapSystemKeys.OwnAirplaneProps = "ownAirplaneProps";
  MapSystemKeys.AutopilotProps = "autopilotProps";
  MapSystemKeys.AltitudeArc = "altitudeArc";
  MapSystemKeys.TerrainColors = "terrainColors";
  MapSystemKeys.Weather = "weather";
  MapSystemKeys.FollowAirplane = "followAirplane";
  MapSystemKeys.Rotation = "rotation";
  MapSystemKeys.OwnAirplaneIcon = "ownAirplaneIcon";
  MapSystemKeys.OwnAirplaneIconOrientation = "ownAirplaneIconOrientation";
  MapSystemKeys.TextLayer = "text";
  MapSystemKeys.TextManager = "textManager";
  MapSystemKeys.Bing = "bing";
  MapSystemKeys.WaypointRenderer = "waypointRenderer";
  MapSystemKeys.IconFactory = "iconFactory";
  MapSystemKeys.LabelFactory = "labelFactory";
  MapSystemKeys.NearestWaypoints = "nearestWaypoints";
  MapSystemKeys.FlightPlan = "flightPlan";
  MapSystemKeys.FlightPlanner = "flightPlanner";
  MapSystemKeys.FlightPathRenderer = "flightPathRenderer";
  MapSystemKeys.Airspace = "airspace";
  MapSystemKeys.AirspaceManager = "airspaceRenderManager";
  MapSystemKeys.Traffic = "traffic";
  MapSystemKeys.DataIntegrity = "dataIntegrity";
  var MapCanvasLayerCanvasInstanceClass = class {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     */
    constructor(canvas, context, isDisplayed) {
      this.canvas = canvas;
      this.context = context;
      this.isDisplayed = isDisplayed;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset() {
      const width = this.canvas.width;
      this.canvas.width = 0;
      this.canvas.width = width;
    }
  };
  var MapCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.displayCanvasRef = FSComponent.createRef();
      this.width = 0;
      this.height = 0;
      this.displayCanvasContext = null;
      this.isInit = false;
    }
    /**
     * Gets this layer's display canvas instance.
     * @returns This layer's display canvas instance.
     * @throws Error if this layer's display canvas instance has not been initialized.
     */
    get display() {
      if (!this._display) {
        throw new Error("MapCanvasLayer: attempted to access display before it was initialized");
      }
      return this._display;
    }
    /**
     * Gets this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance.
     * @throws Error if this layer's buffer canvas instance has not been initialized.
     */
    get buffer() {
      if (!this._buffer) {
        throw new Error("MapCanvasLayer: attempted to access buffer before it was initialized");
      }
      return this._buffer;
    }
    /**
     * Attempts to get this layer's display canvas instance.
     * @returns This layer's display canvas instance, or undefined if it has not been initialized.
     */
    tryGetDisplay() {
      return this._display;
    }
    /**
     * Attempts to get this layer's buffer canvas instance.
     * @returns This layer's buffer canvas instance, or undefined if it has not been initialized.
     */
    tryGetBuffer() {
      return this._buffer;
    }
    /**
     * Gets the width of the canvas element, in pixels.
     * @returns the width of the canvas element.
     */
    getWidth() {
      return this.width;
    }
    /**
     * Gets the height of the canvas element, in pixels.
     * @returns the height of the canvas element.
     */
    getHeight() {
      return this.height;
    }
    /**
     * Sets the width of the canvas element, in pixels.
     * @param width The new width.
     */
    setWidth(width) {
      if (width === this.width) {
        return;
      }
      this.width = width;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    /**
     * Sets the height of the canvas element, in pixels.
     * @param height The new height.
     */
    setHeight(height) {
      if (height === this.height) {
        return;
      }
      this.height = height;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    /**
     * Copies the contents of the buffer to the display. Has no effect if this layer does not have a buffer.
     */
    copyBufferToDisplay() {
      if (!this.isInit || !this.props.useBuffer) {
        return;
      }
      this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    /**
     * A callback called after the component renders.
     */
    onAfterRender() {
      this.displayCanvasContext = this.displayCanvasRef.instance.getContext("2d");
    }
    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
      if (this.isInit) {
        this.updateCanvasVisibility();
      }
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
      this.initCanvasInstances();
      this.isInit = true;
      this.updateCanvasVisibility();
      this.updateCanvasSize();
    }
    /**
     * Initializes this layer's canvas instances.
     */
    initCanvasInstances() {
      this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
      if (this.props.useBuffer) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        this._buffer = this.createCanvasInstance(canvas, context, false);
      }
    }
    /**
     * Creates a canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @returns a canvas instance.
     */
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    /**
     * Updates the canvas element's size.
     */
    updateCanvasSize() {
      const displayCanvas = this.display.canvas;
      displayCanvas.width = this.width;
      displayCanvas.height = this.height;
      displayCanvas.style.width = `${this.width}px`;
      displayCanvas.style.height = `${this.height}px`;
      if (this._buffer) {
        const bufferCanvas = this._buffer.canvas;
        bufferCanvas.width = this.width;
        bufferCanvas.height = this.height;
      }
    }
    /**
     * Updates the visibility of the display canvas.
     */
    updateCanvasVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", width: "0", height: "0", style: "position: absolute;" });
    }
  };
  var MapSyncedCanvasLayer = class extends MapCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
      this.setWidth(projectedSize[0]);
      this.setHeight(projectedSize[1]);
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = "0px";
      displayCanvas.style.top = "0px";
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
    }
  };
  var MapAltitudeArcLayer = class extends MapLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.layerRef = FSComponent.createRef();
      this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
      this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
      this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
      this.strokeLineCap = (_e = this.props.strokeLineCap) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;
      this.outlineWidth = (_f = this.props.outlineWidth) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_g = this.props.outlineStyle) !== null && _g !== void 0 ? _g : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineLineCap = (_h = this.props.outlineLineCap) !== null && _h !== void 0 ? _h : MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;
      this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.autopilotModule = this.props.model.getModule(MapSystemKeys.AutopilotProps);
      this.vsPrecisionFpm = "isSubscribable" in this.props.verticalSpeedPrecision ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));
      this.vsThresholdFpm = "isSubscribable" in this.props.verticalSpeedThreshold ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));
      this.altDevThresholdFeet = "isSubscribable" in this.props.altitudeDeviationThreshold ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map((v) => v.asUnit(UnitType.FOOT)) : Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));
      this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map((vs) => vs.asUnit(UnitType.FPM));
      this.vsFpmQuantized = MappedSubject.create(([vsFpm, precision]) => {
        return Math.round(vsFpm / precision) * precision;
      }, this.vsFpm, this.vsPrecisionFpm);
      this.projectedPlanePosition = Vec2Subject.create(Vec2Math.create());
      this.projectPlanePositionHandler = () => {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
        this.projectedPlanePosition.set(projected);
      };
      this.isArcVisibleDynamic = MappedSubject.create(([vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
        if (Math.abs(vsFpm) < vsThreshold) {
          return false;
        }
        const altDevFeet = selectedAlt.asUnit(UnitType.FOOT) - alt.asUnit(UnitType.FOOT);
        return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
      }, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet).pause();
      this.projectedArcPosition = Vec2Subject.create(Vec2Math.create());
      this.projectedArcAngle = Subject.create(0);
      this.needUpdate = false;
      this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
      var _a;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(isVisible);
      if (isVisible) {
        this.needUpdate = true;
      }
    }
    /** @inheritdoc */
    onAttached() {
      var _a, _b;
      this.layerRef.instance.onAttached();
      this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      const altitudeArcModule = this.props.model.getModule(MapSystemKeys.AltitudeArc);
      const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
      this.isArcVisibleStatic = MappedSubject.create(([show, isGpsValid, isAdcValid]) => {
        return show && isGpsValid && isAdcValid;
      }, altitudeArcModule.show, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true));
      const isArcVisibleDynamicSub = this.isArcVisibleDynamic.sub((isVisible) => {
        this.setVisible(isVisible);
      }, false, true);
      this.isArcVisibleStatic.sub((isVisible) => {
        if (isVisible) {
          this.isArcVisibleDynamic.resume();
          isArcVisibleDynamicSub.resume(true);
        } else {
          this.isArcVisibleDynamic.pause();
          isArcVisibleDynamicSub.pause();
          this.setVisible(false);
        }
      }, true);
      this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
      this.vsFpmQuantized.sub(scheduleUpdate);
      this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
      this.layerRef.instance.setVisible(this.isVisible());
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.layerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.projectPlanePositionHandler();
      this.needUpdate = true;
    }
    /** @inheritdoc */
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const track = this.ownAirplanePropsModule.trackTrue.get();
      const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
      const altitude = this.ownAirplanePropsModule.altitude.get();
      const selectedAltitude = this.autopilotModule.selectedAltitude.get();
      const vsFpm = this.vsFpmQuantized.get();
      const timeToAltitudeMinute = (selectedAltitude.asUnit(UnitType.FOOT) - altitude.asUnit(UnitType.FOOT)) / vsFpm;
      const distanceToAltitudeFeet = groundSpeed.asUnit(UnitType.FPM) * timeToAltitudeMinute;
      const distancePx = UnitType.FOOT.convertTo(distanceToAltitudeFeet, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
      const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - MathUtils.HALF_PI;
      const projectedPlanePos = this.projectedPlanePosition.get();
      const projectedArcPos = Vec2Math.add(Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
      this.projectedArcPosition.set(projectedArcPos);
      this.projectedArcAngle.set(projectedTrackAngle);
      this.layerRef.instance.onUpdated();
      this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
      const props = {
        ref: this.layerRef,
        model: this.props.model,
        mapProjection: this.props.mapProjection,
        arcAngularWidth: this.arcAngularWidth,
        arcRadius: this.arcRadius,
        strokeWidth: this.strokeWidth,
        strokeStyle: this.strokeStyle,
        strokeLineCap: this.strokeLineCap,
        outlineWidth: this.outlineWidth,
        outlineStyle: this.outlineStyle,
        outlineLineCap: this.outlineLineCap,
        projectedArcPosition: this.projectedArcPosition,
        projectedArcAngle: this.projectedArcAngle
      };
      return this.props.renderMethod === "canvas" ? FSComponent.buildComponent(MapAltitudeArcCanvasLayer, Object.assign({}, props)) : FSComponent.buildComponent(MapAltitudeArcSvgLayer, Object.assign({}, props));
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b, _c, _d, _e;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.vsPrecisionMap) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.vsThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.altDevThresholdMap) === null || _d === void 0 ? void 0 : _d.destroy();
      this.vsFpm.destroy();
      (_e = this.isArcVisibleStatic) === null || _e === void 0 ? void 0 : _e.destroy();
      this.isArcVisibleDynamic.destroy();
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60;
  MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64;
  MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2;
  MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = "cyan";
  MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP = "butt";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1;
  MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = "#505050";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP = "butt";
  MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.canvasLayerRef = FSComponent.createRef();
      this.subscriptions = [];
      this.needUpdate = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (isVisible) {
        this.needUpdate = true;
      } else {
        (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    /** @inheritdoc */
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
      this.needUpdate = true;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const display = this.canvasLayerRef.instance.display;
      display.clear();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        return;
      }
      display.context.beginPath();
      const projectedArcAngle = this.props.projectedArcAngle.get();
      const center = Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius, projectedArcAngle, MapAltitudeArcCanvasLayer.vec2Cache[0]), arcPos, MapAltitudeArcCanvasLayer.vec2Cache[0]);
      const arcStart = Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, MapAltitudeArcCanvasLayer.vec2Cache[1]), center, MapAltitudeArcCanvasLayer.vec2Cache[1]);
      display.context.moveTo(arcStart[0], arcStart[1]);
      display.context.arc(center[0], center[1], this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, projectedArcAngle + this.arcHalfAngularWidth);
      if (this.props.outlineWidth > 0) {
        display.context.lineWidth = this.totalArcThickness;
        display.context.strokeStyle = this.props.outlineStyle;
        display.context.lineCap = this.props.outlineLineCap;
        display.context.stroke();
      }
      if (this.props.strokeWidth > 0) {
        display.context.lineWidth = this.props.strokeWidth;
        display.context.strokeStyle = this.props.strokeStyle;
        display.context.lineCap = this.props.strokeLineCap;
        display.context.stroke();
      }
      this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection });
    }
    /** @inheritdoc */
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcCanvasLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcSvgLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.width = this.props.arcRadius * (1 - Math.cos(this.arcHalfAngularWidth)) + this.totalArcThickness + 2;
      this.height = 2 * this.props.arcRadius * Math.sin(Math.min(this.arcHalfAngularWidth, MathUtils.HALF_PI)) + this.totalArcThickness + 2;
      this.svgStyle = ObjectSubject.create({
        "display": "",
        "position": "absolute",
        "left": `${this.totalArcThickness / 2 + 1 - this.width}px`,
        "top": `${-this.height / 2}px`,
        "width": `${this.width}px`,
        "height": `${this.height}px`,
        "transform": "translate3d(0px, 0px, 0px) rotate(0rad)",
        "transform-origin": `${this.width - (this.totalArcThickness / 2 + 1)}px ${this.height / 2}px`
      });
      this.svgTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("rad"));
      this.needUpdate = false;
      this.subscriptions = [];
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
      if (isVisible) {
        this.needUpdate = true;
      } else {
        this.svgStyle.set("display", "none");
      }
    }
    /** @inheritdoc */
    onAttached() {
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
    }
    /** @inheritdoc */
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        this.svgStyle.set("display", "none");
      } else {
        this.svgStyle.set("display", "");
        this.svgTransform.getChild(0).set(arcX, arcY, 0, 0.1);
        this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(), 1e-4);
        this.svgStyle.set("transform", this.svgTransform.resolve());
      }
      this.needUpdate = false;
    }
    /** @inheritdoc */
    render() {
      const svgPathStream = new SvgPathStream(0.01);
      const transformPathStream = new AffineTransformPathStream(svgPathStream);
      transformPathStream.beginPath();
      transformPathStream.addRotation(-this.arcHalfAngularWidth).addTranslation(-this.props.arcRadius, 0);
      transformPathStream.moveTo(this.props.arcRadius, 0);
      transformPathStream.arc(0, 0, this.props.arcRadius, 0, this.props.arcAngularWidth);
      const path = svgPathStream.getSvgPath();
      return FSComponent.buildComponent(
        "svg",
        { viewBox: `${this.totalArcThickness / 2 + 1 - this.width} ${-this.height / 2} ${this.width} ${this.height}`, style: this.svgStyle },
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.outlineStyle, "stroke-width": this.totalArcThickness, "stroke-linecap": this.props.outlineLineCap }),
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.strokeStyle, "stroke-width": this.props.strokeWidth, "stroke-linecap": this.props.strokeLineCap })
      );
    }
    /** @inheritdoc */
    destroy() {
      this.subscriptions.forEach((sub) => sub.destroy());
      super.destroy();
    }
  };
  var MapBingLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.bingRef = FSComponent.createRef();
      this.wrapperStyle = ObjectSubject.create({
        "position": "absolute",
        "left": "0px",
        "top": "0px",
        "width": "0px",
        "height": "0px",
        "display": "",
        "transform": ""
      });
      this.resolution = Vec2Subject.create(Vec2Math.create(1024, 1024));
      this.rotationTransform = CssTransformBuilder.rotate("rad");
      this.size = 0;
      this.needUpdate = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
      this.wrapperStyle.set("display", isVisible ? "" : "none");
    }
    /** @inheritdoc */
    onAttached() {
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      if (this.props.wxrMode !== void 0) {
        this.props.wxrMode.sub(() => {
          this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
          this.needUpdate = true;
        });
      }
    }
    /** @inheritdoc */
    onWake() {
      this.bingRef.instance.wake();
    }
    /** @inheritdoc */
    onSleep() {
      this.bingRef.instance.sleep();
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
      let offsetX, offsetY;
      if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
        const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
        const offset = this.props.mapProjection.getTargetProjectedOffset();
        offsetSize[0] += offset[0];
        offsetSize[1] += offset[1];
        this.size = this.getSize(offsetSize);
        offsetX = (projectedSize[0] - this.size) / 2 + offset[0];
        offsetY = (projectedSize[1] - this.size) / 2 + offset[1];
      } else {
        this.size = this.getSize(projectedSize);
        offsetX = (projectedSize[0] - this.size) / 2;
        offsetY = (projectedSize[1] - this.size) / 2;
      }
      this.wrapperStyle.set("left", `${offsetX}px`);
      this.wrapperStyle.set("top", `${offsetY}px`);
      this.wrapperStyle.set("width", `${this.size}px`);
      this.wrapperStyle.set("height", `${this.size}px`);
      this.resolution.set(this.size, this.size);
    }
    /**
     * Gets an appropriate size, in pixels, for this Bing layer given specific map projection window dimensions.
     * We get the length of the hypotenuse so that the map edges won't show when rotating.
     * @param projectedSize - the size of the projected map window.
     * @returns an appropriate size for this Bing layer.
     */
    getSize(projectedSize) {
      return Vec2Math.abs(projectedSize);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.TargetProjected)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
      if (this.bingRef.instance.isBound()) {
        this.needUpdate = true;
      }
    }
    /**
     * A callback which is called when the Bing component is bound.
     */
    onBingBound() {
      this.needUpdate = true;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
      if (!this.needUpdate) {
        return;
      }
      this.updatePositionRadius();
      this.needUpdate = false;
    }
    /**
     * Resets the underlying Bing component's img src attribute.
     */
    resetImgSrc() {
      this.bingRef.instance.resetImgSrc();
    }
    /**
     * Updates the Bing map center position and radius.
     */
    updatePositionRadius() {
      const center = this.props.mapProjection.getCenter();
      const radius = this.calculateDesiredRadius(this.props.mapProjection);
      this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
      if (!this.props.wxrMode || this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL) {
        this.rotationTransform.set(this.props.mapProjection.getRotation(), 1e-3);
      } else {
        this.rotationTransform.set(0);
      }
      this.wrapperStyle.set("transform", this.rotationTransform.resolve());
    }
    /**
     * Gets the desired Bing map radius in meters given a map projection model.
     * @param mapProjection - a map projection model.
     * @returns the desired Bing map radius.
     */
    calculateDesiredRadius(mapProjection) {
      const scaleFactor = mapProjection.getScaleFactor();
      const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
      const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
      return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    /** @inheritdoc */
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        "div",
        { style: this.wrapperStyle, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" },
        FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolution, mode: (_b = this.props.mode) !== null && _b !== void 0 ? _b : EBingMode.PLANE, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, reference: this.props.reference, wxrMode: this.props.wxrMode, wxrColors: this.props.wxrColors, isoLines: this.props.isoLines, delay: this.props.delay })
      );
    }
  };
  var MapCachedCanvasLayerReferenceClass = class {
    constructor() {
      this._center = new GeoPoint(0, 0);
      this._scaleFactor = 1;
      this._rotation = 0;
    }
    /** @inheritdoc */
    get center() {
      return this._center.readonly;
    }
    /** @inheritdoc */
    get scaleFactor() {
      return this._scaleFactor;
    }
    /** @inheritdoc */
    get rotation() {
      return this._rotation;
    }
    /**
     * Syncs this reference with the current state of a map projection.
     * @param mapProjection The map projection with which to sync.
     */
    syncWithMapProjection(mapProjection) {
      this._center.set(mapProjection.getCenter());
      this._scaleFactor = mapProjection.getScaleFactor();
      this._rotation = mapProjection.getRotation();
    }
    /**
     * Syncs this reference with another reference.
     * @param reference - the reference with which to sync.
     */
    syncWithReference(reference) {
      this._center.set(reference.center);
      this._scaleFactor = reference.scaleFactor;
      this._rotation = reference.rotation;
    }
  };
  var MapCachedCanvasLayerTransformClass = class {
    constructor() {
      this._scale = 0;
      this._rotation = 0;
      this._translation = new Float64Array(2);
      this._margin = 0;
      this._marginRemaining = 0;
    }
    /** @inheritdoc */
    get scale() {
      return this._scale;
    }
    /** @inheritdoc */
    get rotation() {
      return this._rotation;
    }
    /** @inheritdoc */
    get translation() {
      return this._translation;
    }
    /** @inheritdoc */
    get margin() {
      return this._margin;
    }
    /** @inheritdoc */
    get marginRemaining() {
      return this._marginRemaining;
    }
    /**
     * Updates this transform given the current map projection and a reference.
     * @param mapProjection The current map projection.
     * @param reference The reference to use.
     * @param referenceMargin The reference margin, in pixels.
     */
    update(mapProjection, reference, referenceMargin) {
      this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
      this._rotation = mapProjection.getRotation() - reference.rotation;
      mapProjection.project(reference.center, this._translation);
      Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
      this._margin = referenceMargin * this._scale;
      this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    /**
     * Copies another transform's parameters to this one.
     * @param other The other transform.
     */
    copyFrom(other) {
      this._scale = other.scale;
      this._rotation = other.rotation;
      this._translation.set(other.translation);
      this._margin = other.margin;
    }
  };
  var MapCachedCanvasLayerCanvasInstanceClass = class extends MapCanvasLayerCanvasInstanceClass {
    /**
     * Creates a new canvas instance.
     * @param canvas The canvas element.
     * @param context The canvas 2D rendering context.
     * @param isDisplayed Whether the canvas is displayed.
     * @param getReferenceMargin A function which gets this canvas instance's reference margin, in pixels. The reference
     * margin is the maximum amount of translation allowed without invalidation at a scale factor of 1.
     */
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
      super(canvas, context, isDisplayed);
      this.getReferenceMargin = getReferenceMargin;
      this._reference = new MapCachedCanvasLayerReferenceClass();
      this._transform = new MapCachedCanvasLayerTransformClass();
      this._isInvalid = false;
      this._geoProjection = new MercatorProjection();
      this.canvasTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(), CssTransformBuilder.translate("px"), CssTransformBuilder.rotate("rad")));
      this.canvasTransform.sub((transform) => {
        this.canvas.style.transform = transform;
      }, true);
    }
    /** @inheritdoc */
    get reference() {
      return this._reference;
    }
    /** @inheritdoc */
    get transform() {
      return this._transform;
    }
    /** @inheritdoc */
    get isInvalid() {
      return this._isInvalid;
    }
    /** @inheritdoc */
    get geoProjection() {
      return this._geoProjection;
    }
    /** @inheritdoc */
    syncWithMapProjection(mapProjection) {
      const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
      this._reference.syncWithMapProjection(mapProjection);
      this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      this._isInvalid = false;
      if (this.isDisplayed) {
        this.transformCanvasElement();
      }
    }
    /** @inheritdoc */
    syncWithCanvasInstance(other) {
      this._reference.syncWithReference(other.reference);
      this._geoProjection.copyParametersFrom(other.geoProjection);
      this._transform.copyFrom(other.transform);
      this._isInvalid = other.isInvalid;
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    /**
     * Updates this canvas instance's transform given the current map projection.
     * @param mapProjection The current map projection.
     */
    updateTransform(mapProjection) {
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      if (!this._isInvalid) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
        this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || this._transform.marginRemaining < 0;
      }
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    /**
     * Transforms this instance's canvas element.
     */
    transformCanvasElement() {
      const transform = this.transform;
      const offsetX = transform.translation[0] / transform.scale;
      const offsetY = transform.translation[1] / transform.scale;
      this.canvasTransform.transform.getChild(0).set(transform.scale, transform.scale, 1e-3);
      this.canvasTransform.transform.getChild(1).set(offsetX, offsetY, 0.1);
      this.canvasTransform.transform.getChild(2).set(transform.rotation, 1e-4);
      this.canvasTransform.resolve();
    }
    /** @inheritdoc */
    invalidate() {
      this._isInvalid = true;
      this.clear();
    }
  };
  MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
  MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
  var MapCachedCanvasLayer = class extends MapCanvasLayer {
    /** @inheritdoc */
    constructor(props) {
      super(props);
      this.size = 0;
      this.referenceMargin = 0;
      this.needUpdateTransforms = false;
      this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    /**
     * Gets the size, in pixels, of this layer's canvas.
     * @returns the size of this layer's canvas.
     */
    getSize() {
      return this.size;
    }
    /**
     * Gets the reference translation margin, in pixels, of this layer's display canvas. This value is the maximum amount
     * the display canvas can be translated in the x or y direction at a scale factor of 1 without invalidation.
     * @returns the reference translation margin of this layer's display canvas.
     */
    getReferenceMargin() {
      return this.referenceMargin;
    }
    /** @inheritdoc */
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    /**
     * Updates this layer according to the current size of the projected map window.
     * @param projectedSize The size of the projected map window.
     */
    updateFromProjectedSize(projectedSize) {
      const projectedWidth = projectedSize[0];
      const projectedHeight = projectedSize[1];
      const diag = Math.hypot(projectedWidth, projectedHeight);
      this.size = diag * this.props.overdrawFactor;
      this.referenceMargin = (this.size - diag) / 2;
      this.setWidth(this.size);
      this.setHeight(this.size);
      const posX = (projectedWidth - this.size) / 2;
      const posY = (projectedHeight - this.size) / 2;
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = `${posX}px`;
      displayCanvas.style.top = `${posY}px`;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      var _a;
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
        this.display.invalidate();
        (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.invalidate();
      }
      this.needUpdateTransforms = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (!this.needUpdateTransforms) {
        return;
      }
      this.updateTransforms();
    }
    /**
     * Updates this layer's canvas instances' transforms.
     */
    updateTransforms() {
      var _a;
      const mapProjection = this.props.mapProjection;
      this.display.updateTransform(mapProjection);
      (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.updateTransform(mapProjection);
      this.needUpdateTransforms = false;
    }
  };
  var MapLabeledRingLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.labelContainerRef = FSComponent.createRef();
      this.canvasLayerRef = FSComponent.createRef();
      this.center = new Float64Array(2);
      this.radius = 0;
      this.strokeWidth = 0;
      this.strokeStyle = "";
      this.strokeDash = [];
      this.outlineWidth = 0;
      this.outlineStyle = "";
      this.outlineDash = [];
      this.needUpdateRingPosition = false;
      this.isInit = false;
      this.labels = [];
    }
    /**
     * Gets the center position of this layer's ring, in pixels.
     * @returns the center position of this layer's ring.
     */
    getRingCenter() {
      return this.center;
    }
    /**
     * Gets the radius of this layer's ring, in pixels.
     * @returns the radius of this layer's ring.
     */
    getRingRadius() {
      return this.radius;
    }
    /**
     * Sets the center and radius of this layer's ring.
     * @param center The new center, in pixels.
     * @param radius The new radius, in pixels.
     */
    setRingPosition(center, radius) {
      if (Vec2Math.equals(this.center, center) && radius === this.radius) {
        return;
      }
      this.center.set(center);
      this.radius = radius;
      this.needUpdateRingPosition = true;
    }
    /**
     * Sets the styling for this layer's ring stroke. Any style that is not explicitly defined will be left unchanged.
     * @param width The new stroke width.
     * @param style The new stroke style.
     * @param dash The new stroke dash.
     */
    setRingStrokeStyles(width, style, dash) {
      this.strokeWidth = width !== null && width !== void 0 ? width : this.strokeWidth;
      this.strokeStyle = style !== null && style !== void 0 ? style : this.strokeStyle;
      this.strokeDash = dash !== null && dash !== void 0 ? dash : this.strokeDash;
      this.needUpdateRingPosition = true;
    }
    /**
     * Sets the styling for this layer's ring outline. Any style that is not explicitly defined will be left unchanged.
     * @param width The new outline width.
     * @param style The new outline style.
     * @param dash The new outline dash.
     */
    setRingOutlineStyles(width, style, dash) {
      this.outlineWidth = width !== null && width !== void 0 ? width : this.outlineWidth;
      this.outlineStyle = style !== null && style !== void 0 ? style : this.outlineStyle;
      this.outlineDash = dash !== null && dash !== void 0 ? dash : this.outlineDash;
      this.needUpdateRingPosition = true;
    }
    /**
     * Creates a ring label. Labels can only be created after this layer has been rendered.
     * @param content The content of the new label.
     * @returns the newly created ring label, or null if a label could not be created.
     */
    createLabel(content) {
      if (!this.labelContainerRef.instance) {
        return null;
      }
      const wrapperRef = FSComponent.createRef();
      FSComponent.render(FSComponent.buildComponent("div", { ref: wrapperRef, style: "position: absolute;" }, content), this.labelContainerRef.instance);
      const label = new MapLabeledRingLabelClass(content.instance, wrapperRef.instance);
      label.setRingPosition(this.center, this.radius);
      this.labels.push(label);
      return label;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
      if (this.isInit) {
        this.updateFromVisibility();
      }
    }
    /** @inheritdoc */
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      this.isInit = true;
      this.updateFromVisibility();
      this.needUpdateRingPosition = true;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.needUpdateRingPosition = true;
      }
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      if (!this.isVisible()) {
        return;
      }
      if (this.needUpdateRingPosition) {
        this.updateRingPosition();
        this.needUpdateRingPosition = false;
      }
      this.canvasLayerRef.instance.onUpdated(time, elapsed);
    }
    /**
     * Updates this layer according to its current visibility.
     */
    updateFromVisibility() {
      const isVisible = this.isVisible();
      this.canvasLayerRef.instance.setVisible(isVisible);
      this.labelContainerRef.instance.style.display = isVisible ? "block" : "none";
    }
    /**
     * Updates the position of this layer's ring.
     */
    updateRingPosition() {
      this.drawRing();
      this.updateLabelPositions();
    }
    /**
     * Draws this layer's ring to canvas.
     */
    drawRing() {
      const canvasDisplay = this.canvasLayerRef.instance.display;
      canvasDisplay.clear();
      if (!this.isRingInView()) {
        return;
      }
      canvasDisplay.context.beginPath();
      canvasDisplay.context.arc(this.center[0], this.center[1], this.radius, 0, Math.PI * 2);
      if (this.outlineWidth > 0) {
        this.applyStrokeToContext(canvasDisplay.context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
      }
      if (this.strokeWidth > 0) {
        this.applyStrokeToContext(canvasDisplay.context, this.strokeWidth, this.strokeStyle, this.strokeDash);
      }
    }
    /**
     * Checks whether this layer's ring is in view.
     * @returns whether this layer's ring is in view.
     */
    isRingInView() {
      const centerX = this.center[0];
      const centerY = this.center[1];
      const innerHalfLength = this.radius / Math.SQRT2;
      const innerLeft = centerX - innerHalfLength;
      const innerRight = centerX + innerHalfLength;
      const innerTop = centerY - innerHalfLength;
      const innerBottom = centerY + innerHalfLength;
      const outerLeft = centerX - this.radius;
      const outerRight = centerX + this.radius;
      const outerTop = centerY - this.radius;
      const outerBottom = centerY + this.radius;
      const width = this.props.mapProjection.getProjectedSize()[0];
      const height = this.props.mapProjection.getProjectedSize()[1];
      if (innerLeft < 0 && innerRight > width && innerTop < 0 && innerBottom > height) {
        return false;
      }
      if (outerLeft > width || outerRight < 0 || outerTop > height || outerBottom < 0) {
        return false;
      }
      return true;
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context The canvas to which to apply a stroke.
     * @param lineWidth The stroke width.
     * @param strokeStyle The stroke style.
     * @param dash The stroke dash.
     */
    applyStrokeToContext(context, lineWidth, strokeStyle, dash) {
      context.lineWidth = lineWidth;
      context.strokeStyle = strokeStyle;
      context.setLineDash(dash);
      context.stroke();
    }
    /**
     * Updates the position of this layer's labels based on the position of the ring.
     */
    updateLabelPositions() {
      const len = this.labels.length;
      for (let i = 0; i < len; i++) {
        this.labels[i].setRingPosition(this.center, this.radius);
      }
    }
    /** @inheritdoc */
    render() {
      return FSComponent.buildComponent(
        FSComponent.Fragment,
        null,
        FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection }),
        FSComponent.buildComponent("div", { ref: this.labelContainerRef, style: "position: absolute; left: 0; top: 0; width: 100%; height: 100%;" })
      );
    }
  };
  var MapLabeledRingLabelClass = class {
    /**
     * Constructor.
     * @param content The content of this label.
     * @param wrapper The wrapper for this label.
     */
    constructor(content, wrapper) {
      this.content = content;
      this.wrapper = wrapper;
      this.center = new Float64Array(2);
      this.radius = 0;
      this.anchor = new Float64Array(2);
      this.radialAngle = 0;
      this.radialOffset = 0;
    }
    /** @inheritdoc */
    getAnchor() {
      return this.anchor;
    }
    /** @inheritdoc */
    getRadialAngle() {
      return this.radialAngle;
    }
    /** @inheritdoc */
    getRadialOffset() {
      return this.radialOffset;
    }
    /** @inheritdoc */
    setAnchor(anchor) {
      this.anchor.set(anchor);
      this.wrapper.style.transform = `translate(${-anchor[0] * 100}%, ${-anchor[1] * 100}%)`;
    }
    /** @inheritdoc */
    setRadialAngle(angle) {
      if (this.radialAngle === angle) {
        return;
      }
      this.radialAngle = angle;
      this.updatePosition();
    }
    /** @inheritdoc */
    setRadialOffset(offset) {
      if (this.radialOffset === offset) {
        return;
      }
      this.radialOffset = offset;
      this.updatePosition();
    }
    /**
     * Updates this label with the center and radius of its parent ring.
     * @param center The center of the ring, in pixels.
     * @param radius The radius of the ring, in pixels.
     */
    setRingPosition(center, radius) {
      if (Vec2Math.equals(this.center, center) && radius === this.radius) {
        return;
      }
      this.center.set(center);
      this.radius = radius;
      this.updatePosition();
    }
    /**
     * Updates this label's position.
     */
    updatePosition() {
      const pos = MapLabeledRingLabelClass.tempVec2_1;
      Vec2Math.setFromPolar(this.radius + this.radialOffset, this.radialAngle, pos);
      Vec2Math.add(this.center, pos, pos);
      this.wrapper.style.left = `${pos[0]}px`;
      this.wrapper.style.top = `${pos[1]}px`;
    }
  };
  MapLabeledRingLabelClass.tempVec2_1 = new Float64Array(2);
  var MapOwnAirplaneLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.imageFilePath = SubscribableUtils.isSubscribable(this.props.imageFilePath) ? this.props.imageFilePath.map(SubscribableMapFunctions.identity()) : this.props.imageFilePath;
      this.style = ObjectSubject.create({
        display: "",
        position: "absolute",
        left: "0px",
        top: "0px",
        width: "0px",
        height: "0px",
        transform: "translate3d(0, 0, 0) rotate(0deg)",
        "transform-origin": "50% 50%"
      });
      this.ownAirplanePropsModule = this.props.model.getModule("ownAirplaneProps");
      this.ownAirplaneIconModule = this.props.model.getModule("ownAirplaneIcon");
      this.iconSize = SubscribableUtils.toSubscribable(this.props.iconSize, true);
      this.iconAnchor = SubscribableUtils.toSubscribable(this.props.iconAnchor, true);
      this.iconOffset = Vec2Math.create();
      this.visibilityBounds = VecNMath.create(4);
      this.iconTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("deg"));
      this.isGsAboveTrackThreshold = this.ownAirplanePropsModule.groundSpeed.map((gs) => gs.asUnit(UnitType.KNOT) >= 5).pause();
      this.showIcon = true;
      this.isInsideVisibilityBounds = true;
      this.planeRotation = 0;
      this.needUpdateVisibility = false;
      this.needUpdatePositionRotation = false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onVisibilityChanged(isVisible) {
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    /** @inheritdoc */
    onAttached() {
      this.showSub = this.ownAirplaneIconModule.show.sub((show) => {
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = this.showIcon = show && this.isVisible();
      });
      this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
        this.needUpdatePositionRotation = this.showIcon;
      });
      this.headingSub = this.ownAirplanePropsModule.hdgTrue.sub((hdg) => {
        this.planeRotation = hdg;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackSub = this.ownAirplanePropsModule.trackTrue.sub((track) => {
        this.planeRotation = track;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackThresholdSub = this.isGsAboveTrackThreshold.sub((isAboveThreshold) => {
        if (isAboveThreshold) {
          this.headingSub.pause();
          this.trackSub.resume(true);
        } else {
          this.trackSub.pause();
          this.headingSub.resume(true);
        }
      }, false, true);
      this.iconSizeSub = this.iconSize.sub((size) => {
        this.style.set("width", `${size}px`);
        this.style.set("height", `${size}px`);
        this.updateOffset();
      }, true);
      this.iconAnchorSub = this.iconAnchor.sub(() => {
        this.updateOffset();
      });
      this.orientationSub = this.ownAirplaneIconModule.orientation.sub((orientation) => {
        switch (orientation) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.trackSub.pause();
            this.headingSub.resume(true);
            break;
          case MapOwnAirplaneIconOrientation.TrackUp:
            this.headingSub.pause();
            this.trackSub.pause();
            this.isGsAboveTrackThreshold.resume();
            this.trackThresholdSub.resume(true);
            break;
          default:
            this.needUpdatePositionRotation = this.showIcon;
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.headingSub.pause();
            this.trackSub.pause();
            this.planeRotation = 0;
        }
      }, true);
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = true;
    }
    /**
     * Updates the icon's offset from the projected position of the airplane.
     */
    updateOffset() {
      const anchor = this.iconAnchor.get();
      this.iconOffset.set(anchor);
      Vec2Math.multScalar(this.iconOffset, -this.iconSize.get(), this.iconOffset);
      this.style.set("left", `${this.iconOffset[0]}px`);
      this.style.set("top", `${this.iconOffset[1]}px`);
      this.style.set("transform-origin", `${anchor[0] * 100}% ${anchor[1] * 100}%`);
      this.updateVisibilityBounds();
    }
    /**
     * Updates the boundaries within the map's projected window that define a region such that if the airplane's
     * projected position falls outside of it, the icon is not visible and therefore does not need to be updated.
     */
    updateVisibilityBounds() {
      const size = this.iconSize.get();
      const maxProtrusion = Math.max(
        Math.hypot(this.iconOffset[0], this.iconOffset[1]),
        // top left corner
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1]),
        // top right corner
        Math.hypot(this.iconOffset[0] + size, this.iconOffset[1] + size),
        // bottom right corner
        Math.hypot(this.iconOffset[0], this.iconOffset[1] + size)
      );
      const boundsOffset = maxProtrusion + 50;
      const projectedSize = this.props.mapProjection.getProjectedSize();
      this.visibilityBounds[0] = -boundsOffset;
      this.visibilityBounds[1] = -boundsOffset;
      this.visibilityBounds[2] = projectedSize[0] + boundsOffset;
      this.visibilityBounds[3] = projectedSize[1] + boundsOffset;
      this.needUpdatePositionRotation = this.showIcon;
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateVisibilityBounds();
      }
      this.needUpdatePositionRotation = this.showIcon;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
      if (this.needUpdatePositionRotation) {
        this.updateIconPositionRotation();
        this.needUpdatePositionRotation = false;
        this.needUpdateVisibility = false;
      } else if (this.needUpdateVisibility) {
        this.updateIconVisibility();
        this.needUpdateVisibility = false;
      }
    }
    /**
     * Updates the airplane icon's visibility.
     */
    updateIconVisibility() {
      this.style.set("display", this.isInsideVisibilityBounds && this.showIcon ? "" : "none");
    }
    /**
     * Updates the airplane icon's projected position and rotation.
     */
    updateIconPositionRotation() {
      const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.vec2Cache[0]);
      this.isInsideVisibilityBounds = this.props.mapProjection.isInProjectedBounds(projected, this.visibilityBounds);
      if (this.isInsideVisibilityBounds) {
        let rotation;
        switch (this.ownAirplaneIconModule.orientation.get()) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
          case MapOwnAirplaneIconOrientation.TrackUp:
            rotation = this.planeRotation + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
            break;
          default:
            rotation = 0;
        }
        this.iconTransform.getChild(0).set(projected[0], projected[1], 0, 0.1);
        this.iconTransform.getChild(1).set(rotation, 0.1);
        this.style.set("transform", this.iconTransform.resolve());
      }
      this.updateIconVisibility();
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("img", { src: this.imageFilePath, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: this.style });
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (SubscribableUtils.isSubscribable(this.imageFilePath)) {
        this.imageFilePath.destroy();
      }
      this.isGsAboveTrackThreshold.destroy();
      (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.headingSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.trackSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.trackThresholdSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.iconSizeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.iconAnchorSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.orientationSub) === null || _h === void 0 ? void 0 : _h.destroy();
      super.destroy();
    }
  };
  MapOwnAirplaneLayer.vec2Cache = [Vec2Math.create()];
  var MapCullableTextLayer = class extends MapSyncedCanvasLayer {
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      this.props.manager.update(this.props.mapProjection);
      this.redrawLabels();
    }
    /**
     * Clears this layer's canvas and redraws the currently visible labels registered to this layer's text manager.
     */
    redrawLabels() {
      const labels = this.props.manager.visibleLabels;
      const display = this.display;
      display.clear();
      for (let i = labels.length - 1; i >= 0; i--) {
        labels[i].draw(display.context, this.props.mapProjection);
      }
    }
  };
  var MapAirspaceLayer = class extends MapLayer {
    constructor() {
      var _a, _b;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
        this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
        this.isAttached && this.scheduleSearch(0, true);
      });
      this.searchedAirspaces = /* @__PURE__ */ new Map();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
      this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
      this.activeRenderProcess = null;
      this.renderTaskQueueHandler = {
        renderTimeBudget: this.renderTimeBudget,
        // eslint-disable-next-line jsdoc/require-jsdoc
        onStarted() {
        },
        // eslint-disable-next-line jsdoc/require-jsdoc
        canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
          return timeElapsed < this.renderTimeBudget;
        },
        // eslint-disable-next-line jsdoc/require-jsdoc
        onPaused: this.onRenderPaused.bind(this),
        // eslint-disable-next-line jsdoc/require-jsdoc
        onFinished: this.onRenderFinished.bind(this),
        // eslint-disable-next-line jsdoc/require-jsdoc
        onAborted: this.onRenderAborted.bind(this)
      };
      this.searchDebounceTimer = 0;
      this.isSearchScheduled = false;
      this.needRefilter = false;
      this.isSearchBusy = false;
      this.lastDesiredSearchRadius = 0;
      this.lastSearchRadius = 0;
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
      this.isDisplayInvalidated = true;
      this.isAttached = false;
    }
    /** @inheritdoc */
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      this.updateClipBounds();
      this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
      this.props.maxSearchRadius.sub((radius) => {
        const radiusMeters = radius.asUnit(UnitType.METER);
        if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
          this.scheduleSearch(0, false);
        }
      });
      this.props.maxSearchItemCount.sub(() => {
        this.scheduleSearch(0, false);
      });
      this.initModuleListeners();
      this.isAttached = true;
      this.searchSession && this.scheduleSearch(0, true);
    }
    /**
     * Initializes this layer's airspace module property listeners.
     */
    initModuleListeners() {
      const airspaceModule = this.props.model.getModule("airspace");
      for (const type of Object.values(airspaceModule.show)) {
        type.sub(this.onAirspaceTypeShowChanged.bind(this));
      }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateClipBounds();
      }
    }
    /**
     * Updates this layer's canvas clipping bounds.
     */
    updateClipBounds() {
      const size = this.canvasLayerRef.instance.getSize();
      this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    /**
     * Schedules a search. If a search was previously scheduled but not yet executed, this new scheduled search will
     * replace the old one.
     * @param delay The delay, in milliseconds, before the search is executed.
     * @param refilter Whether to update the search's boundary class filter.
     */
    scheduleSearch(delay, refilter) {
      if (!this.searchSession) {
        return;
      }
      this.searchDebounceTimer = delay;
      this.isSearchScheduled = true;
      this.needRefilter || (this.needRefilter = refilter);
    }
    /**
     * Schedules a render to be executed during the next update cycle.
     */
    scheduleRender() {
      this.isRenderScheduled = true;
    }
    /**
     * Searches for airspaces around the map center. After the search is complete, the list of search results is filtered
     * and, if necessary, rendered.
     * @param refilter Whether to update the search's boundary class filter.
     */
    async searchAirspaces(refilter) {
      this.isSearchBusy = true;
      const center = this.props.mapProjection.getCenter();
      const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
      this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
      this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
      const session = this.searchSession;
      refilter && session.setFilter(this.getBoundaryFilter());
      const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
      for (let i = 0; i < results.added.length; i++) {
        const airspace = results.added[i];
        this.searchedAirspaces.set(airspace.facility.id, airspace);
      }
      for (let i = 0; i < results.removed.length; i++) {
        this.searchedAirspaces.delete(results.removed[i]);
      }
      this.isSearchBusy = false;
      this.scheduleRender();
    }
    /**
     * Gets the boundary class filter based on the current airspace type visibility settings.
     * @returns The boundary class filter based on the current airspace type visibility settings.
     */
    getBoundaryFilter() {
      const module = this.props.model.getModule("airspace");
      const show = module.show;
      let filter = 0;
      for (const type in show) {
        if (show[type].get()) {
          filter |= module.showTypes[type];
        }
      }
      return filter;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    onUpdated(time, elapsed) {
      this.canvasLayerRef.instance.onUpdated(time, elapsed);
      this.updateFromInvalidation();
      this.updateScheduledRender();
      this.updateScheduledSearch(elapsed);
    }
    /**
     * Checks if the display and buffer canvases have been invalidated, and if so, clears them and schedules a render.
     */
    updateFromInvalidation() {
      const canvasLayer = this.canvasLayerRef.instance;
      const display = canvasLayer.display;
      const buffer = canvasLayer.buffer;
      const needBackgroundRender = !this.isBackgroundRenderScheduled && !this.activeRenderProcess && display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD;
      const shouldScheduleSearch = needBackgroundRender || display.isInvalid || buffer.isInvalid && this.activeRenderProcess;
      this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
      if (display.isInvalid) {
        this.isDisplayInvalidated = true;
        this.isBackgroundRenderScheduled = false;
        display.clear();
        display.syncWithMapProjection(this.props.mapProjection);
      }
      if (buffer.isInvalid) {
        if (this.activeRenderProcess) {
          this.activeRenderProcess.abort();
          this.cleanUpRender();
        }
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
      }
      if (shouldScheduleSearch) {
        this.scheduleSearch(this.searchDebounceDelay, false);
      }
    }
    /**
     * If a search is scheduled, decrements the delay timer and if necessary, executes the search.
     * @param elapsed The time elapsed, in milliseconds, since the last update.
     */
    updateScheduledSearch(elapsed) {
      if (!this.isSearchScheduled) {
        return;
      }
      this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
      if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
        this.searchAirspaces(this.needRefilter);
        this.isSearchScheduled = false;
        this.needRefilter = false;
      }
    }
    /**
     * Executes a render if one is scheduled.
     */
    updateScheduledRender() {
      if (!this.isRenderScheduled) {
        return;
      }
      this.startRenderProcess();
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
    }
    /**
     * Syncs this layer's display canvas instance with the current map projection and renders this layer's airspaces to
     * the display.
     */
    startRenderProcess() {
      const canvasLayer = this.canvasLayerRef.instance;
      if (this.activeRenderProcess) {
        this.activeRenderProcess.abort();
      }
      const buffer = canvasLayer.buffer;
      buffer.clear();
      buffer.syncWithMapProjection(this.props.mapProjection);
      this.props.airspaceRenderManager.clearRegisteredAirspaces();
      for (const airspace of this.searchedAirspaces.values()) {
        if (this.isAirspaceInBounds(airspace, buffer)) {
          this.props.airspaceRenderManager.registerAirspace(airspace);
        }
      }
      const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
      this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
      this.activeRenderProcess.start();
    }
    /**
     * Checks whether an airspace is within the projected bounds of a cached canvas instance.
     * @param airspace An airspace.
     * @param canvas A cached canvas instance.
     * @returns Whether the airspace is within the projected bounds of the cached canvas instance.
     */
    isAirspaceInBounds(airspace, canvas) {
      const corner = MapAirspaceLayer.geoPointCache[0];
      const cornerProjected = MapAirspaceLayer.vec2Cache[0];
      let minX, maxX, minY, maxY;
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = maxX = cornerProjected[0];
      minY = maxY = cornerProjected[1];
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      const width = canvas.canvas.width;
      const height = canvas.canvas.height;
      return minX < width && maxX > 0 && minY < height && maxY > 0;
    }
    /**
     * Selects an LOD level based on projected map resolution.
     * @param resolution A projected map resolution, in great-arc radians per pixel.
     * @returns An LOD level based on the projected map resolution.
     */
    selectLod(resolution) {
      const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
      let i = thresholds.length - 1;
      while (i >= 0) {
        if (resolution * 2 >= thresholds[i]) {
          break;
        }
        i--;
      }
      return i;
    }
    /**
     * Cleans up the active render process.
     */
    cleanUpRender() {
      this.canvasLayerRef.instance.buffer.reset();
      this.activeRenderProcess = null;
    }
    /**
     * Renders airspaces from the buffer to the display.
     */
    renderAirspacesToDisplay() {
      const display = this.canvasLayerRef.instance.display;
      const buffer = this.canvasLayerRef.instance.buffer;
      display.clear();
      display.syncWithCanvasInstance(buffer);
      this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    /**
     * This method is called when the airspace render process pauses.
     */
    onRenderPaused() {
      if (this.isDisplayInvalidated) {
        this.renderAirspacesToDisplay();
      }
    }
    /**
     * This method is called when the airspace render process finishes.
     */
    onRenderFinished() {
      this.renderAirspacesToDisplay();
      this.cleanUpRender();
      this.isDisplayInvalidated = false;
    }
    /**
     * This method is called when the airspace render process is aborted.
     */
    onRenderAborted() {
      this.cleanUpRender();
    }
    /**
     * This method is called when an airspace show property changes.
     */
    onAirspaceTypeShowChanged() {
      this.scheduleSearch(0, true);
    }
    /** @inheritdoc */
    render() {
      return FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 });
    }
  };
  MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500;
  MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2;
  MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1;
  MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10;
  MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
  MapAirspaceLayer.vec2Cache = [new Float64Array(2)];
  var MapNearestWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
      this.searchRadius = 0;
      this.searchMargin = 0;
      this.userFacilityHasChanged = false;
      this.icaosToRender = /* @__PURE__ */ new Set();
      this.cachedRenderedWaypoints = /* @__PURE__ */ new Map();
      this.isInit = false;
      this.facilityRepoSubs = [];
    }
    /**
     * A callback called when the facility loaded finishes initialization.
     */
    onFacilityLoaderInitialized() {
      Promise.all([
        this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),
        this.facLoader.startNearestSearchSession(FacilitySearchType.User)
      ]).then((value) => {
        const [airportSession, vorSession, ndbSession, intSession, userSession] = value;
        this.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      });
    }
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     * @param userSession The user facility search session.
     */
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession) {
      const callback = this.processSearchResults.bind(this);
      this.facilitySearches = {
        [FacilitySearchType.Airport]: new MapNearestWaypointsLayerSearch(airportSession, callback),
        [FacilitySearchType.Vor]: new MapNearestWaypointsLayerSearch(vorSession, callback),
        [FacilitySearchType.Ndb]: new MapNearestWaypointsLayerSearch(ndbSession, callback),
        [FacilitySearchType.Intersection]: new MapNearestWaypointsLayerSearch(intSession, callback),
        [FacilitySearchType.User]: new MapNearestWaypointsLayerSearch(userSession, callback)
      };
      const sub = this.props.bus.getSubscriber();
      this.facilityRepoSubs.push(sub.on("facility_added").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub.on("facility_changed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub.on("facility_removed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }));
      this.props.onSessionsStarted && this.props.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      if (this.isInit) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    /** @inheritdoc */
    onAttached() {
      super.onAttached();
      this.canvasLayerRef.instance.onAttached();
      this.doInit();
      this.isInit = true;
      this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    /**
     * Initializes this layer.
     */
    doInit() {
      this.initWaypointRenderer();
      this.updateSearchRadius();
    }
    /**
     * Gets the search center for the waypoint searches on this layer.
     * @returns The waypoint search center geo point.
     */
    getSearchCenter() {
      return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    /**
     * Initializes this layer's waypoint renderer.
     */
    initWaypointRenderer() {
      this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    /** Forces a refresh of all the waypoints. */
    refreshWaypoints() {
      this.tryRefreshAllSearches(void 0, void 0, true);
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.deregisterWaypoint(w, this.props.waypointRenderer);
      });
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.registerWaypoint(w, this.props.waypointRenderer);
      });
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
        this.updateSearchRadius();
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      } else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    /**
     * Updates the desired nearest facility search radius based on the current map projection.
     */
    updateSearchRadius() {
      let mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
      mapHalfDiagRange = Math.max(mapHalfDiagRange, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
      this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
      this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      var _a;
      if (this.userFacilityHasChanged) {
        const search = (_a = this.facilitySearches) === null || _a === void 0 ? void 0 : _a[FacilitySearchType.User];
        if (search !== void 0) {
          this.userFacilityHasChanged = false;
          this.scheduleSearchRefresh(FacilitySearchType.User, search, this.getSearchCenter(), this.searchRadius);
        }
      }
      this.updateSearches(elapsed);
    }
    /**
     * Updates this layer's facility searches.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    updateSearches(elapsed) {
      if (!this.facilitySearches) {
        return;
      }
      this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
      this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
      this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
      this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
      this.facilitySearches[FacilitySearchType.User].update(elapsed);
    }
    /**
     * Attempts to refresh all of the nearest facility searches. Searches will only be refreshed if the desired search
     * radius is different from the last refreshed search radius or the desired search center is outside of the margin
     * of the last refreshed search center.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshAllSearches(center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshAllSearches(center, radius, force);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if the desired search radius is different
     * from the last refreshed search radius or the desired search center is outside of the margin of the last refreshed
     * search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area. Defaults to this layer's automatically calculated search center.
     * @param radius The radius of the search area, in great-arc radians. Defaults to this layer's automatically
     * calculated search radius.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    tryRefreshSearch(type, center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshSearch(type, center, radius, force);
    }
    /**
     * Attempts to refresh all of the nearest facility searches.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    _tryRefreshAllSearches(center, radius, force) {
      this._tryRefreshSearch(FacilitySearchType.Airport, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Vor, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.User, center, radius, force);
    }
    /**
     * Attempts to refresh a nearest search. The search will only be refreshed if `this.shouldRefreshSearch()` returns
     * true and and the desired search radius is different from the last refreshed search radius or the desired search
     * center is outside of the margin of the last refreshed search center.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param force Whether to force a refresh of all waypoints. Defaults to false.
     */
    _tryRefreshSearch(type, center, radius, force) {
      const search = this.facilitySearches && this.facilitySearches[type];
      if (!search || !force && !this.shouldRefreshSearch(type, center, radius)) {
        return;
      }
      const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : void 0;
      if (radiusLimit !== void 0 && isFinite(radiusLimit)) {
        radius = Math.min(radius, Math.max(0, radiusLimit));
      }
      if (force || search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
        this.scheduleSearchRefresh(type, search, center, radius);
      }
    }
    /**
     * Checks whether one of this layer's searches should be refreshed.
     * @param type The type of nearest search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @returns Whether the search should be refreshed.
     */
    shouldRefreshSearch(type, center, radius) {
      return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    /**
     * Schedules a refresh of this one of this layer's searches.
     * @param type The type of nearest search to refresh.
     * @param search The search to refresh.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     */
    scheduleSearchRefresh(type, search, center, radius) {
      const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
      search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    /**
     * Processes nearest facility search results. New facilities are registered, while removed facilities are
     * deregistered.
     * @param results Nearest facility search results.
     */
    processSearchResults(results) {
      if (!results) {
        return;
      }
      const numAdded = results.added.length;
      for (let i = 0; i < numAdded; i++) {
        const icao = results.added[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.registerIcao(icao);
      }
      const numRemoved = results.removed.length;
      for (let i = 0; i < numRemoved; i++) {
        const icao = results.removed[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.deregisterIcao(icao);
      }
    }
    /**
     * Registers an ICAO string with this layer. Once an ICAO is registered, its corresponding facility is drawn to this
     * layer using a waypoint renderer.
     * @param icao The ICAO string to register.
     */
    async registerIcao(icao) {
      this.icaosToRender.add(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (!this.icaosToRender.has(icao)) {
          return;
        }
        this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
      }
    }
    /**
     * Registers a facility with this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to register.
     */
    registerWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.set(facility.icao, waypoint);
      this.props.registerWaypoint(waypoint, renderer);
    }
    /**
     * Deregisters an ICAO string from this layer.
     * @param icao The ICAO string to deregister.
     */
    async deregisterIcao(icao) {
      this.icaosToRender.delete(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (this.icaosToRender.has(icao)) {
          return;
        }
        this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
        if (this.icaosToRender.has(icao)) {
          return;
        }
        const cachedWaypoint = this.cachedRenderedWaypoints.get(icao);
        if (cachedWaypoint !== void 0) {
          this.cachedRenderedWaypoints.delete(icao);
          this.props.deregisterWaypoint(cachedWaypoint, this.props.waypointRenderer);
        }
      }
    }
    /**
     * Deregisters a facility from this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param facility The facility to deregister.
     */
    deregisterWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.delete(facility.icao);
      this.props.deregisterWaypoint(waypoint, renderer);
    }
    /** @inheritdoc */
    setVisible(val) {
      super.setVisible(val);
      this.canvasLayerRef.instance.setVisible(val);
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    /** @inheritdoc */
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.facilityRepoSubs.forEach((sub) => {
        sub.destroy();
      });
      super.destroy();
    }
  };
  MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
  var MapNearestWaypointsLayerSearch = class {
    /**
     * Constructor.
     * @param session The session used by this search.
     * @param refreshCallback A callback which is called every time the search refreshes.
     */
    constructor(session, refreshCallback) {
      this.session = session;
      this.refreshCallback = refreshCallback;
      this._lastCenter = new GeoPoint(0, 0);
      this._lastRadius = 0;
      this.maxItemCount = 0;
      this.refreshDebounceTimer = 0;
      this.isRefreshScheduled = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this search's last refresh.
     */
    get lastCenter() {
      return this._lastCenter.readonly;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this search's last refresh, in great-arc radians.
     */
    get lastRadius() {
      return this._lastRadius;
    }
    /**
     * Schedules a refresh of this search.  If a refresh was previously scheduled but not yet executed, this new
     * scheduled refresh will replace the old one.
     * @param center The center of the search area.
     * @param radius The radius of the search area, in great-arc radians.
     * @param maxItemCount The maximum number of results returned by the refresh.
     * @param delay The delay, in milliseconds, before the refresh is executed.
     */
    scheduleRefresh(center, radius, maxItemCount, delay) {
      this._lastCenter.set(center);
      this._lastRadius = radius;
      this.maxItemCount = maxItemCount;
      if (!this.isRefreshScheduled) {
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
      }
    }
    /**
     * Updates this search. Executes any pending refreshes if their delay timers have expired.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    update(elapsed) {
      if (!this.isRefreshScheduled) {
        return;
      }
      this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
      if (this.refreshDebounceTimer === 0) {
        this.refresh();
        this.isRefreshScheduled = false;
      }
    }
    /**
     * Refreshes this search.
     * @returns a Promise which is fulfilled when the refresh completes.
     */
    async refresh() {
      const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
      this.refreshCallback(results);
    }
  };
  var MapLineLayer = class extends MapSyncedCanvasLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(...arguments);
      this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapLineLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapLineLayer.DEFAULT_STROKE_STYLE;
      this.strokeDash = (_c = this.props.strokeDash) !== null && _c !== void 0 ? _c : MapLineLayer.DEFAULT_STROKE_DASH;
      this.outlineWidth = (_d = this.props.outlineWidth) !== null && _d !== void 0 ? _d : MapLineLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_e = this.props.outlineStyle) !== null && _e !== void 0 ? _e : MapLineLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineDash = (_f = this.props.outlineDash) !== null && _f !== void 0 ? _f : MapLineLayer.DEFAULT_OUTLINE_DASH;
      this.vec = new Float64Array([0, 0]);
      this.isUpdateScheduled = false;
    }
    /** @inheritdoc */
    onAttached() {
      super.onAttached();
      this.props.start.sub(() => {
        this.scheduleUpdate();
      });
      this.props.end.sub(() => {
        this.scheduleUpdate();
      });
      this.scheduleUpdate();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.scheduleUpdate();
    }
    /**
     * Schedules the layer for a draw update.
     */
    scheduleUpdate() {
      this.isUpdateScheduled = true;
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (this.isUpdateScheduled) {
        this.display.clear();
        const start = this.props.start.get();
        const end = this.props.end.get();
        if (start !== null && end !== null) {
          const [x1, y1] = start instanceof Float64Array ? start : this.props.mapProjection.project(start, this.vec);
          const [x2, y2] = end instanceof Float64Array ? end : this.props.mapProjection.project(end, this.vec);
          this.drawLine(x1, y1, x2, y2);
        }
        this.isUpdateScheduled = false;
      }
    }
    /**
     * Draws this layer's line.
     * @param x1 The x coordinate of the start of the line.
     * @param y1 The y coordinate of the start of the line.
     * @param x2 The x coordinate of the end of the line.
     * @param y2 The y coordinate of the end of the line.
     */
    drawLine(x1, y1, x2, y2) {
      const context = this.display.context;
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      if (this.outlineWidth > 0) {
        this.stroke(context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
      }
      if (this.strokeWidth > 0) {
        this.stroke(context, this.strokeWidth, this.strokeStyle, this.strokeDash);
      }
    }
    /**
     * Applies a stroke to a canvas rendering context.
     * @param context A canvas rendering context.
     * @param width The width of the stroke, in pixels.
     * @param style The style of the stroke.
     * @param dash The dash array of the stroke.
     */
    stroke(context, width, style, dash) {
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash);
      context.stroke();
    }
  };
  MapLineLayer.DEFAULT_STROKE_WIDTH = 2;
  MapLineLayer.DEFAULT_STROKE_STYLE = "white";
  MapLineLayer.DEFAULT_STROKE_DASH = [];
  MapLineLayer.DEFAULT_OUTLINE_WIDTH = 0;
  MapLineLayer.DEFAULT_OUTLINE_STYLE = "black";
  MapLineLayer.DEFAULT_OUTLINE_DASH = [];
  var MapGenericLayer = class extends MapLayer {
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
      this.props.onVisibilityChanged && this.props.onVisibilityChanged(this, isVisible);
    }
    /** @inheritdoc */
    onAttached() {
      this.props.onAttached && this.props.onAttached(this);
    }
    /** @inheritdoc */
    onWake() {
      this.props.onWake && this.props.onWake(this);
    }
    /** @inheritdoc */
    onSleep() {
      this.props.onSleep && this.props.onSleep(this);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.props.onMapProjectionChanged && this.props.onMapProjectionChanged(this, mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      this.props.onUpdated && this.props.onUpdated(this, time, elapsed);
    }
    /** @inheritdoc */
    onDetached() {
      this.props.onDetached && this.props.onDetached(this);
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }, this.props.children);
    }
  };
  var MapSystemController = class {
    /**
     * Constructor.
     * @param context This controller's map context.
     */
    constructor(context) {
      this._isAlive = true;
      this.context = context;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this controller is alive. */
    get isAlive() {
      return this._isAlive;
    }
    /**
     * This method is called after this controller' map is rendered.
     * @param ref A reference to the rendered map.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterMapRender(ref) {
    }
    /**
     * This method is called when the dead zone of this controller's map changes.
     * @param deadZone The map's new dead zone.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onDeadZoneChanged(deadZone) {
    }
    /**
     * This method is called when the projection of this controller's map changes.
     * @param mapProjection The map projection.
     * @param changeFlags Bit flags describing the type of change.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    /**
     * This method is called immediately before this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onBeforeUpdated(time, elapsed) {
    }
    /**
     * This method is called immediately after this controller's map updates its layers.
     * @param time The current sim time, as a UNIX timestamp in milliseconds.
     * @param elapsed The elapsed time, in milliseconds, since the last update.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterUpdated(time, elapsed) {
    }
    /**
     * This method is called when this controller's map is awakened.
     */
    onWake() {
    }
    /**
     * This method is called when this controller's map is put to sleep.
     */
    onSleep() {
    }
    /**
     * This method is called when this controller's map is destroyed.
     */
    onMapDestroyed() {
    }
    /**
     * Destroys this controller.
     */
    destroy() {
      this._isAlive = false;
    }
  };
  var MapBindingsController = class extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param bindings This controller's bindings.
     * @param onDestroy A function to execute when the controller is destroyed.
     */
    constructor(context, bindings, onDestroy) {
      super(context);
      this.bindings = bindings;
      this.onDestroy = onDestroy;
      this.maps = [];
      this.pipes = [];
    }
    /** @inheritdoc */
    onAfterMapRender() {
      for (const binding of this.bindings) {
        if ("map" in binding) {
          if ("sources" in binding) {
            const map = MappedSubject.create(...binding.sources);
            this.maps.push(map);
            this.pipes.push(map.pipe(binding.target, binding.map));
          } else {
            this.pipes.push(binding.source.pipe(binding.target, binding.map));
          }
        } else {
          this.pipes.push(binding.source.pipe(binding.target));
        }
      }
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    onWake() {
      this.maps.forEach((map) => {
        map.resume();
      });
      this.pipes.forEach((pipe) => {
        pipe.resume(true);
      });
    }
    /** @inheritdoc */
    onSleep() {
      this.maps.forEach((map) => {
        map.pause();
      });
      this.pipes.forEach((pipe) => {
        pipe.pause();
      });
    }
    /** @inheritdoc */
    destroy() {
      this.onDestroy && this.onDestroy();
      this.maps.forEach((map) => {
        map.destroy();
      });
      this.pipes.forEach((pipe) => {
        pipe.destroy();
      });
      super.destroy();
    }
  };
  var MapClockUpdateController = class extends MapSystemController {
    /** @inheritdoc */
    onAfterMapRender(ref) {
      this.freqSub = this.context.updateFreq.sub((freq) => {
        var _a;
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.clockSub = this.context.bus.getSubscriber().on("realTime").atFrequency(freq).handle((realTime) => {
          ref.update(realTime);
        });
      }, true);
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var MapFlightPlanController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
      this.planCopiedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
      };
      this.planCreatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
      };
      this.planDeletedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(void 0);
      };
      this.planChangeHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
      };
      this.planCalculatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
      };
      this.activeLegChangedHandler = (evt) => {
        if (evt.type === ActiveLegType.Lateral) {
          this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.index);
        }
      };
    }
    /** @inheritdoc */
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      this.fplCopiedSub = sub.on("fplCopied").handle(this.planCopiedHandler);
      this.fplCreatedSub = sub.on("fplCreated").handle(this.planCreatedHandler);
      this.fplDeletedSub = sub.on("fplDeleted").handle(this.planDeletedHandler);
      this.fplDirectToDataChangedSub = sub.on("fplDirectToDataChanged").handle(this.planChangeHandler);
      this.fplLoadedSub = sub.on("fplLoaded").handle(this.planCreatedHandler);
      this.fplOriginDestChangedSub = sub.on("fplOriginDestChanged").handle(this.planChangeHandler);
      this.fplProcDetailsChangedSub = sub.on("fplProcDetailsChanged").handle(this.planChangeHandler);
      this.fplSegmentChangeSub = sub.on("fplSegmentChange").handle(this.planChangeHandler);
      this.fplUserDataDeleteSub = sub.on("fplUserDataDelete").handle(this.planChangeHandler);
      this.fplUserDataSetSub = sub.on("fplUserDataSet").handle(this.planChangeHandler);
      this.fplActiveLegChangeSub = sub.on("fplActiveLegChange").handle(this.activeLegChangedHandler);
      this.fplCalculatedSub = sub.on("fplCalculated").handle(this.planCalculatedHandler);
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      super.destroy();
      (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
      (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
      (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
  };
  var MapFollowAirplaneController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
      this.mapProjectionParams = {
        target: new GeoPoint(0, 0)
      };
      this.targetControl = this.context[MapSystemKeys.TargetControl];
      this.targetControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.isFollowingAirplane.set(true);
        },
        onCeded: () => {
          this.isFollowingAirplane.set(false);
        }
      };
    }
    /** @inheritdoc */
    onAfterMapRender() {
      this.targetControl.claim(this.targetControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
      if (this.isFollowingAirplane.get()) {
        this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
        this.context.projection.setQueued(this.mapProjectionParams);
      }
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      super.destroy();
      this.targetControl.forfeit(this.targetControlConsumer);
    }
  };
  var MapRotation;
  (function(MapRotation2) {
    MapRotation2["Undefined"] = "Undefined";
    MapRotation2["NorthUp"] = "NorthUp";
    MapRotation2["TrackUp"] = "TrackUp";
    MapRotation2["HeadingUp"] = "HeadingUp";
    MapRotation2["DtkUp"] = "DtkUp";
  })(MapRotation || (MapRotation = {}));
  var MapRotationModule = class {
    constructor() {
      this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
  };
  var MapOwnAirplaneIconOrientationController = class extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     */
    constructor(context, desiredOrientation) {
      super(context);
      this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
      this.needUpdateIconOrientation = false;
      this.desiredIconOrientation = SubscribableUtils.toSubscribable(desiredOrientation, true);
      this.orientationState = MappedSubject.create(this.desiredIconOrientation, this.context.model.getModule(MapSystemKeys.Rotation).rotationType);
    }
    /** @inheritdoc */
    onAfterMapRender() {
      var _a;
      (_a = this.orientationState) === null || _a === void 0 ? void 0 : _a.sub(() => {
        this.needUpdateIconOrientation = true;
      }, true);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
      if (this.needUpdateIconOrientation) {
        const [desiredOrientation, rotation] = this.orientationState.get();
        if (desiredOrientation === MapOwnAirplaneIconOrientation.HeadingUp && rotation === MapRotation.HeadingUp || desiredOrientation === MapOwnAirplaneIconOrientation.TrackUp && rotation === MapRotation.TrackUp) {
          this.ownAirplaneIconModule.orientation.set(MapOwnAirplaneIconOrientation.MapUp);
        } else {
          this.ownAirplaneIconModule.orientation.set(desiredOrientation);
        }
        this.needUpdateIconOrientation = false;
      }
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      this.orientationState.destroy();
      super.destroy();
    }
  };
  var MapOwnAirplanePropsController = class extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz.
     */
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      this.updateFreqSub = this.updateFreq.sub((freq) => {
        var _a;
        for (const property of this.properties) {
          (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
          this.subs[property] = this.bindProperty(sub, property, freq);
        }
      }, true);
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
      switch (property) {
        case "position":
          return sub.on("gps-position").atFrequency(updateFreq).handle((lla) => {
            this.module.position.set(lla.lat, lla.long);
          });
        case "altitude":
          return sub.on("indicated_alt").atFrequency(updateFreq).handle((alt) => {
            this.module.altitude.set(alt, UnitType.FOOT);
          });
        case "groundSpeed":
          return sub.on("ground_speed").atFrequency(updateFreq).handle((gs) => {
            this.module.groundSpeed.set(gs, UnitType.KNOT);
          });
        case "hdgTrue":
          return sub.on("hdg_deg_true").atFrequency(updateFreq).handle((hdg) => {
            this.module.hdgTrue.set(hdg);
          });
        case "trackTrue":
          return sub.on("track_deg_true").atFrequency(updateFreq).handle((track) => {
            this.module.trackTrue.set(track);
          });
        case "verticalSpeed":
          return sub.on("vertical_speed").atFrequency(updateFreq).handle((vs) => {
            this.module.verticalSpeed.set(vs, UnitType.FPM);
          });
        case "turnRate":
          return sub.on("delta_heading_rate").atFrequency(updateFreq).handle((turnRate) => {
            this.module.turnRate.set(turnRate);
          });
        case "isOnGround":
          return sub.on("on_ground").atFrequency(updateFreq).handle((isOnGround2) => {
            this.module.isOnGround.set(isOnGround2);
          });
        case "magVar":
          return sub.on("magvar").atFrequency(updateFreq).handle((magVar) => {
            this.module.magVar.set(magVar);
          });
      }
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapRotationController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.rotationParam = {
        rotation: 0
      };
      this.hasRotationControl = false;
      this.rotationControl = this.context[MapSystemKeys.RotationControl];
      this.rotationControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.hasRotationControl = true;
        },
        onCeded: () => {
          this.hasRotationControl = false;
        }
      };
      this.rotationFuncs = {
        [MapRotation.NorthUp]: () => 0,
        [MapRotation.HeadingUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.TrackUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => this.ownAirplanePropsModule.groundSpeed.get().asUnit(UnitType.KNOT) < 5 ? -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD : -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.DtkUp]: () => 0
        // TODO
      };
    }
    /** @inheritdoc */
    onAfterMapRender() {
      this.rotationSub = this.rotationModule.rotationType.sub((type) => {
        this.rotationFunc = this.rotationFuncs[type];
      }, true);
      this.rotationControl.claim(this.rotationControlConsumer);
    }
    /** @inheritdoc */
    onBeforeUpdated() {
      if (this.hasRotationControl && this.rotationFunc !== void 0) {
        this.rotationParam.rotation = this.rotationFunc();
        this.context.projection.setQueued(this.rotationParam);
      }
    }
    /** @inheritdoc */
    onMapDestroyed() {
      super.onMapDestroyed();
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      var _a;
      super.destroy();
      (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.rotationControl.forfeit(this.rotationControlConsumer);
    }
  };
  var MapSystemWaypointRoles;
  (function(MapSystemWaypointRoles2) {
    MapSystemWaypointRoles2["Normal"] = "Normal";
    MapSystemWaypointRoles2["FlightPlan"] = "FlightPlan";
  })(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));
  var MapSystemFlightPlanLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.instanceId = MapSystemFlightPlanLayer.instanceId++;
      this.flightPathLayerRef = FSComponent.createRef();
      this.waypointLayerRef = FSComponent.createRef();
      this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
      this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
      this.waypointPrefix = `${MapSystemFlightPlanLayer.WAYPOINT_PREFIX}_${this.instanceId}`;
      this.legWaypoints = /* @__PURE__ */ new Map();
      this.waypointsUpdating = false;
      this.waypointId = 0;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
      this.facWaypointCache = DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.clipBounds = VecNSubject.create(new Float64Array(4));
      this.clippedPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.clipBounds);
      this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
      this.updateScheduled = false;
    }
    /** @inheritdoc */
    onAttached() {
      this.flightPathLayerRef.instance.onAttached();
      this.waypointLayerRef.instance.onAttached();
      this.pathStreamStack.pushPostProjected(this.clippedPathStream);
      this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
      this.initWaypointRenderer();
      this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
      this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
      super.onAttached();
    }
    /**
     * Initializes the waypoint renderer for this layer.
     */
    initWaypointRenderer() {
      let hasDefaultRole = false;
      const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
      for (let i = 0; i < flightPlanRoles.length; i++) {
        const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
        if (roleId !== void 0) {
          this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
          this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
          this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
          if (!hasDefaultRole) {
            this.props.flightPathRenderer.defaultRoleId = roleId;
            hasDefaultRole = true;
          }
        }
      }
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      this.flightPathLayerRef.instance.onUpdated(time, elapsed);
      this.waypointLayerRef.instance.onUpdated(time, elapsed);
      if (this.isVisible()) {
        const display = this.flightPathLayerRef.instance.display;
        if (display.isInvalid) {
          display.clear();
          display.syncWithMapProjection(this.props.mapProjection);
          this.updateScheduled = true;
        }
        if (this.updateScheduled) {
          if (!this.waypointsUpdating) {
            this.updateWaypoints();
          }
          const context = display.context;
          display.clear();
          const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
          if (plan !== void 0) {
            this.pathStreamStack.setProjection(display.geoProjection);
            this.props.flightPathRenderer.render(plan, void 0, void 0, context, this.pathStreamStack);
          }
          this.updateScheduled = false;
        }
      }
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      const size = this.flightPathLayerRef.instance.getSize();
      this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);
    }
    /** @inheritdoc */
    setVisible(val) {
      super.setVisible(val);
      this.waypointLayerRef.instance.setVisible(val);
      this.flightPathLayerRef.instance.setVisible(val);
    }
    /**
     * Updates waypoints for the flight plan.
     * @throws An error if the waypoints are already updating.
     */
    async updateWaypoints() {
      if (this.waypointsUpdating) {
        throw new Error("A flight plan waypoint update is already in progress.");
      }
      this.waypointsUpdating = true;
      const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
      const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
      if (flightPlan === void 0) {
        for (const legWaypoint of this.legWaypoints.values()) {
          const [waypoint, roleId] = legWaypoint;
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
        this.legWaypoints.clear();
        this.waypointsUpdating = false;
        return;
      }
      const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
      const legsToDisplay = /* @__PURE__ */ new Map();
      let legIndex = 0;
      for (const leg of flightPlan.legs()) {
        let roleId = this.defaultRoleId;
        const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
        if (handler !== void 0) {
          roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
        }
        if (roleId !== 0) {
          legsToDisplay.set(leg, roleId);
        }
        legIndex++;
      }
      for (const leg of this.legWaypoints) {
        const [legDefinition, legWaypoint] = leg;
        const [waypoint, roleId] = legWaypoint;
        if (!legsToDisplay.has(legDefinition)) {
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.delete(legDefinition);
        }
      }
      const waypointRefreshes = [];
      for (const leg of legsToDisplay) {
        waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
      }
      await Promise.all(waypointRefreshes);
      this.waypointsUpdating = false;
    }
    /**
     * Builds or refreshes a flight plan waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildPlanWaypoint(leg, roleId) {
      switch (leg.leg.type) {
        case LegType.CD:
        case LegType.VD:
        case LegType.CR:
        case LegType.VR:
        case LegType.FC:
        case LegType.FD:
        case LegType.FA:
        case LegType.CA:
        case LegType.VA:
        case LegType.FM:
        case LegType.VM:
        case LegType.CI:
        case LegType.VI:
          await this.buildTerminatorWaypoint(leg, roleId);
          break;
        case LegType.Discontinuity:
        case LegType.ThruDiscontinuity:
          break;
        default:
          await this.buildFixWaypoint(leg, roleId);
          break;
      }
    }
    /**
     * Builds a flight path terminator based waypoint.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildTerminatorWaypoint(leg, roleId) {
      var _a, _b, _c, _d, _e, _f;
      const currentLeg = this.legWaypoints.get(leg);
      if (currentLeg !== void 0) {
        const [waypoint, currentRoleId] = currentLeg;
        const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
        if (lastVector !== void 0) {
          if (!waypoint.location.get().equals(lastVector.endLat, lastVector.endLon)) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            const ident = (_c = leg.name) !== null && _c !== void 0 ? _c : "";
            const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
            this.legWaypoints.set(leg, [newWaypoint, roleId]);
            this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          } else if (currentRoleId !== roleId) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            this.legWaypoints.set(leg, [waypoint, roleId]);
          }
        } else {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
        }
      } else {
        const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
        if (lastVector !== void 0) {
          const ident = (_f = leg.name) !== null && _f !== void 0 ? _f : "";
          const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
      }
    }
    /**
     * Builds a standard facility fix waypoint for flight plan waypoint display.
     * @param leg The leg to build the waypoint for.
     * @param roleId The role ID to assign to the waypoint.
     */
    async buildFixWaypoint(leg, roleId) {
      var _a;
      const legWaypoint = this.legWaypoints.get(leg);
      if (legWaypoint === void 0) {
        const facIcao = leg.leg.fixIcao;
        let facility;
        try {
          facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
        } catch (err) {
        }
        if (facility !== void 0) {
          const waypoint = this.facWaypointCache.get(facility);
          const ident = (_a = leg.name) !== null && _a !== void 0 ? _a : "";
          const newWaypoint = new FlightPathWaypoint(waypoint.location, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
        }
      } else {
        const [waypoint, currentRoleId] = legWaypoint;
        if (currentRoleId !== roleId) {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
          this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [waypoint, roleId]);
        }
      }
    }
    /** @inheritdoc */
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        FSComponent.Fragment,
        null,
        FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, overdrawFactor: Math.SQRT2, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }),
        FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_b = this.props.class) !== null && _b !== void 0 ? _b : "" })
      );
    }
  };
  MapSystemFlightPlanLayer.WAYPOINT_PREFIX = "MapSystemFplLayer";
  MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10;
  MapSystemFlightPlanLayer.instanceId = 0;
  var AdsbOperatingMode;
  (function(AdsbOperatingMode2) {
    AdsbOperatingMode2["Standby"] = "Standby";
    AdsbOperatingMode2["Surface"] = "Surface";
    AdsbOperatingMode2["Airborne"] = "Airborne";
  })(AdsbOperatingMode || (AdsbOperatingMode = {}));
  var Adsb = class {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
      this.bus = bus;
      this.operatingMode = Subject.create(AdsbOperatingMode.Standby);
      this.eventSubscriber = this.bus.getSubscriber();
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
      return this.operatingMode.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
      this.operatingMode.set(mode);
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
      return this.eventSubscriber;
    }
    /**
     * Initializes this ADS-B system.
     */
    init() {
      this.operatingMode.sub((mode) => {
        this.bus.pub("adsb_operating_mode", mode, false, true);
      }, true);
    }
  };
  var TcasOperatingMode;
  (function(TcasOperatingMode2) {
    TcasOperatingMode2["Off"] = "Off";
    TcasOperatingMode2["Standby"] = "Standby";
    TcasOperatingMode2["TAOnly"] = "TAOnly";
    TcasOperatingMode2["TA_RA"] = "TA/RA";
    TcasOperatingMode2["Test"] = "Test";
    TcasOperatingMode2["Failed"] = "Failed";
  })(TcasOperatingMode || (TcasOperatingMode = {}));
  var TcasAlertLevel;
  (function(TcasAlertLevel2) {
    TcasAlertLevel2[TcasAlertLevel2["None"] = 0] = "None";
    TcasAlertLevel2[TcasAlertLevel2["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
  })(TcasAlertLevel || (TcasAlertLevel = {}));
  var TcasResolutionAdvisoryFlags;
  (function(TcasResolutionAdvisoryFlags2) {
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Corrective"] = 1] = "Corrective";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["UpSense"] = 2] = "UpSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DownSense"] = 4] = "DownSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Crossing"] = 8] = "Crossing";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Climb"] = 16] = "Climb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Descend"] = 32] = "Descend";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Increase"] = 64] = "Increase";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Reversal"] = 128] = "Reversal";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceClimb"] = 256] = "ReduceClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceDescent"] = 512] = "ReduceDescent";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotClimb"] = 1024] = "DoNotClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotDescend"] = 2048] = "DoNotDescend";
  })(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
  var TcasResolutionAdvisoryType;
  (function(TcasResolutionAdvisoryType2) {
    TcasResolutionAdvisoryType2["Climb"] = "Climb";
    TcasResolutionAdvisoryType2["CrossingClimb"] = "CrossingClimb";
    TcasResolutionAdvisoryType2["MaintainClimb"] = "MaintainClimb";
    TcasResolutionAdvisoryType2["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    TcasResolutionAdvisoryType2["IncreaseClimb"] = "IncreaseClimb";
    TcasResolutionAdvisoryType2["ReversalClimb"] = "ReversalClimb";
    TcasResolutionAdvisoryType2["ReduceDescent"] = "ReduceDescent";
    TcasResolutionAdvisoryType2["DoNotDescend0"] = "DoNotDescend0";
    TcasResolutionAdvisoryType2["DoNotDescend500"] = "DoNotDescend500";
    TcasResolutionAdvisoryType2["DoNotDescend1000"] = "DoNotDescend1000";
    TcasResolutionAdvisoryType2["DoNotDescend1500"] = "DoNotDescend1500";
    TcasResolutionAdvisoryType2["DoNotDescend2000"] = "DoNotDescend2000";
    TcasResolutionAdvisoryType2["Descend"] = "Descend";
    TcasResolutionAdvisoryType2["CrossingDescend"] = "CrossingDescend";
    TcasResolutionAdvisoryType2["MaintainDescend"] = "MaintainDescend";
    TcasResolutionAdvisoryType2["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    TcasResolutionAdvisoryType2["IncreaseDescend"] = "IncreaseDescend";
    TcasResolutionAdvisoryType2["ReversalDescend"] = "ReversalDescend";
    TcasResolutionAdvisoryType2["ReduceClimb"] = "ReduceClimb";
    TcasResolutionAdvisoryType2["DoNotClimb0"] = "DoNotClimb0";
    TcasResolutionAdvisoryType2["DoNotClimb500"] = "DoNotClimb500";
    TcasResolutionAdvisoryType2["DoNotClimb1000"] = "DoNotClimb1000";
    TcasResolutionAdvisoryType2["DoNotClimb1500"] = "DoNotClimb1500";
    TcasResolutionAdvisoryType2["DoNotClimb2000"] = "DoNotClimb2000";
    TcasResolutionAdvisoryType2["Clear"] = "Clear";
  })(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
  var Tcas = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.bus = bus;
      this.tfcInstrument = tfcInstrument;
      this.maxIntruderCount = maxIntruderCount;
      this.realTimeUpdateFreq = realTimeUpdateFreq;
      this.simTimeUpdateFreq = simTimeUpdateFreq;
      this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
      this.intrudersSorted = [];
      this.intrudersFiltered = [];
      this.intrudersRA = /* @__PURE__ */ new Set();
      this.contactCreatedHandler = this.onContactAdded.bind(this);
      this.contactRemovedHandler = this.onContactRemoved.bind(this);
      this.ownAirplaneSubs = {
        position: GeoPointSubject.create(new GeoPoint(0, 0)),
        altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        groundTrack: ConsumerSubject.create(null, 0),
        groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
        verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
        radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        isOnGround: ConsumerSubject.create(null, false)
      };
      this.simTime = ConsumerSubject.create(null, 0);
      this.lastUpdateSimTime = 0;
      this.lastUpdateRealTime = 0;
      this.alertLevelSubs = /* @__PURE__ */ new Map();
      this.eventPublisher = this.bus.getPublisher();
      this.eventSubscriber = this.bus.getSubscriber();
      this.paSeparationCache = {
        horizontal: UnitType.NMILE.createNumber(0),
        vertical: UnitType.FOOT.createNumber(0)
      };
      this.sensitivity = this.createSensitivity();
      this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
      const fullRAOptions = {
        initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
        initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
        subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
        subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
        allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : () => true,
        allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : () => true,
        allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100,
        allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450
      };
      this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
      return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
      this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
      return this.intrudersFiltered;
    }
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost() {
      return this.resolutionAdvisoryHost;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
      return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
      const sub = this.bus.getSubscriber();
      this.contactCreatedConsumer = sub.on("traffic_contact_added");
      this.contactRemovedConsumer = sub.on("traffic_contact_removed");
      this.contactCreatedConsumer.handle(this.contactCreatedHandler);
      this.contactRemovedConsumer.handle(this.contactRemovedHandler);
      this.tfcInstrument.forEachContact((contact) => {
        this.onContactAdded(contact.uid);
      });
      sub.on("gps-position").atFrequency(this.realTimeUpdateFreq).handle((lla) => {
        this.ownAirplaneSubs.position.set(lla.lat, lla.long);
        this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
      });
      sub.on("ground_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((gs) => {
        this.ownAirplaneSubs.groundSpeed.set(gs);
      });
      sub.on("vertical_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((vs) => {
        this.ownAirplaneSubs.verticalSpeed.set(vs);
      });
      sub.on("radio_alt").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((alt) => {
        this.ownAirplaneSubs.radarAltitude.set(alt);
      });
      this.ownAirplaneSubs.groundTrack.setConsumer(sub.on("track_deg_true"));
      this.ownAirplaneSubs.isOnGround.setConsumer(sub.on("on_ground"));
      this.simTime.setConsumer(sub.on("simTime"));
      this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
      sub.on("simTime").whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    onOperatingModeChanged(mode) {
      this.bus.pub("tcas_operating_mode", mode, false, true);
      if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.cancel(this.simTime.get());
        for (let i = 0; i < this.intrudersFiltered.length; i++) {
          this.cleanUpIntruder(this.intrudersFiltered[i]);
        }
        this.intrudersFiltered = [];
      }
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
      if (a.isPredictionValid && !b.isPredictionValid) {
        return -1;
      } else if (!a.isPredictionValid && b.isPredictionValid) {
        return 1;
      } else if (a.isPredictionValid) {
        let tcaPredictionA, tcaPredictionB;
        const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || a.tcaRA.isValid && a.tcaRA.isThreat;
        const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || b.tcaRA.isValid && b.tcaRA.isThreat;
        if (aRA && !bRA) {
          return -1;
        } else if (!aRA && bRA) {
          return 1;
        } else if (aRA && bRA) {
          tcaPredictionA = a.tcaRA;
          tcaPredictionB = b.tcaRA;
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || a.tcaTA.isValid && a.tcaTA.isThreat;
          const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || b.tcaTA.isValid && b.tcaTA.isThreat;
          if (aTA && !bTA) {
            return -1;
          } else if (!aTA && bTA) {
            return 1;
          } else if (aTA && bTA) {
            tcaPredictionA = a.tcaTA;
            tcaPredictionB = b.tcaTA;
          }
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
            return -1;
          } else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
            return 1;
          } else {
            return 0;
          }
        }
        const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
        const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
        let firstComparison;
        let secondComparison;
        if (tcaPredictionA.isThreat) {
          firstComparison = tcaComparison;
          secondComparison = normComparison;
        } else {
          firstComparison = normComparison;
          secondComparison = tcaComparison;
        }
        if (firstComparison === 0) {
          return secondComparison;
        } else {
          return firstComparison;
        }
      } else {
        return 0;
      }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
      const contact = this.tfcInstrument.getContact(uid);
      const intruder = this.createIntruderEntry(contact);
      this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
      const sortedIndex = this.intrudersSorted.findIndex((intruder) => intruder.contact.uid === uid);
      const culledIndex = this.intrudersFiltered.findIndex((intruder) => intruder.contact.uid === uid);
      if (sortedIndex >= 0) {
        this.intrudersSorted.splice(sortedIndex, 1);
      }
      if (culledIndex >= 0) {
        const removed = this.intrudersFiltered[culledIndex];
        this.intrudersFiltered.splice(culledIndex, 1);
        this.cleanUpIntruder(removed);
      }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
      switch (this.operatingModeSub.get()) {
        case TcasOperatingMode.Off:
        case TcasOperatingMode.Standby:
        case TcasOperatingMode.Failed:
        case TcasOperatingMode.Test:
          return;
      }
      const realTime = Date.now();
      if (Math.abs(simTime - this.lastUpdateSimTime) < 1e3 / this.simTimeUpdateFreq || Math.abs(realTime - this.lastUpdateRealTime) < 1e3 / this.realTimeUpdateFreq) {
        return;
      }
      this.doUpdate(simTime);
      this.lastUpdateSimTime = simTime;
      this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    doUpdate(simTime) {
      this.updateSensitivity();
      this.updateIntruderPredictions(simTime);
      this.updateIntruderArrays();
      this.updateFilteredIntruderAlertLevels(simTime);
      this.updateResolutionAdvisory(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateIntruderPredictions(simTime) {
      this.ownAirplane.update(simTime);
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersSorted[i];
        const sensitivity = this.sensitivity.selectParameters(intruder);
        intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
      }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
      this.intrudersSorted.sort(this.intruderComparator.bind(this));
      const oldCulled = this.intrudersFiltered;
      this.intrudersFiltered = [];
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
        const intruder = this.intrudersSorted[i];
        if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
          this.intrudersFiltered.push(intruder);
          if (!oldCulled.includes(intruder)) {
            this.initIntruder(intruder);
          }
        } else {
          if (oldCulled.includes(intruder)) {
            this.cleanUpIntruder(intruder);
          }
        }
      }
    }
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterIntruder(intruder) {
      return true;
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateFilteredIntruderAlertLevels(simTime) {
      let taCount = 0, raCount = 0;
      const len = this.intrudersFiltered.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersFiltered[i];
        this.updateIntruderAlertLevel(simTime, intruder);
        switch (intruder.alertLevel.get()) {
          case TcasAlertLevel.TrafficAdvisory:
            taCount++;
            break;
          case TcasAlertLevel.ResolutionAdvisory:
            raCount++;
            break;
        }
      }
      this.eventPublisher.pub("tcas_ta_intruder_count", taCount, false, true);
      this.eventPublisher.pub("tcas_ra_intruder_count", raCount, false, true);
    }
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    updateIntruderAlertLevel(simTime, intruder) {
      const currentAlertLevel = intruder.alertLevel.get();
      if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
        if (this.canIssueResolutionAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat) && !this.canCancelResolutionAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
        if (this.canIssueTrafficAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat) && !this.canCancelTrafficAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.isPredictionValid) {
        const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
        const radius = parametersPA.protectedRadius;
        const height = parametersPA.protectedHeight;
        if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
          intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
          if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0 && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
            intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
            return;
          }
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
        return;
      }
      intruder.alertLevel.set(TcasAlertLevel.None);
    }
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() === TcasOperatingMode.TA_RA && intruder.tcaRA.isValid && intruder.tcaRA.tcpa.number > 0 && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueTrafficAdvisory(simTime, intruder) {
      return true;
    }
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelTrafficAdvisory(simTime, intruder) {
      return true;
    }
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueProximityAdvisory(simTime, intruder) {
      return true;
    }
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelProximityAdvisory(simTime, intruder) {
      return true;
    }
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateResolutionAdvisory(simTime) {
      if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
      } else {
        this.resolutionAdvisoryHost.cancel(simTime);
      }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
      this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
      this.eventPublisher.pub("tcas_intruder_added", intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
      var _a;
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.delete(intruder);
      }
      (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
      this.eventPublisher.pub("tcas_intruder_removed", intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.add(intruder);
      } else {
        this.intrudersRA.delete(intruder);
      }
      this.eventPublisher.pub("tcas_intruder_alert_changed", intruder, false, false);
    }
  };
  Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
  };
  var TcasAirplane = class {
    constructor() {
      this._position = new GeoPoint(0, 0);
      this.position = this._position.readonly;
      this._altitude = UnitType.FOOT.createNumber(0);
      this.altitude = this._altitude.readonly;
      this._groundTrack = 0;
      this._groundSpeed = UnitType.KNOT.createNumber(0);
      this.groundSpeed = this._groundSpeed.readonly;
      this._verticalSpeed = UnitType.FPM.createNumber(0);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.positionVec = new Float64Array(3);
      this.velocityVec = new Float64Array(3);
      this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
      return this._groundTrack;
    }
  };
  var OwnAirplane = class extends TcasAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
      super();
      this.subs = subs;
      this._radarAltitude = UnitType.FOOT.createNumber(0);
      this.radarAltitude = this._radarAltitude.readonly;
      this._isOnGround = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this airplane is on the ground. */
    get isOnGround() {
      return this._isOnGround;
    }
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime, out) {
      const dt = (simTime - this.lastUpdateTime) / 1e3;
      return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
      this.updateParameters();
      this.updateVectors();
      this.lastUpdateTime = simTime;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    updateParameters() {
      this._position.set(this.subs.position.get());
      this._altitude.set(this.subs.altitude.get());
      this._groundTrack = this.subs.groundTrack.get();
      this._groundSpeed.set(this.subs.groundSpeed.get());
      this._verticalSpeed.set(this.subs.verticalSpeed.get());
      this._radarAltitude.set(this.subs.radarAltitude.get());
      this._isOnGround = this.subs.isOnGround.get();
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
      Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
    }
  };
  var AbstractTcasIntruder = class extends TcasAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
      super();
      this.contact = contact;
      this.alertLevel = Subject.create(TcasAlertLevel.None);
      this.relativePositionVec = new Float64Array(3);
      this.relativeVelocityVec = new Float64Array(3);
      this._isPredictionValid = false;
      this.tcaTA = new TcasTcaPredictionClass(this);
      this.tcaRA = new TcasTcaPredictionClass(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
      return this._isPredictionValid;
    }
    /** @inheritdoc */
    predictDisplacement(simTime, out) {
      if (!this._isPredictionValid) {
        return Vec3Math.set(NaN, NaN, NaN, out);
      }
      const dt = (simTime - this.contact.lastContactTime) / 1e3;
      return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    /** @inheritdoc */
    predictSeparation(simTime, horizontalOut, verticalOut) {
      if (!this._isPredictionValid) {
        horizontalOut.set(NaN);
        verticalOut.set(NaN);
        return;
      }
      const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
      AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
      AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime, ownAirplane, sensitivity) {
      this.updateParameters(simTime, ownAirplane);
      if (this.isPredictionValid) {
        const taParams = sensitivity.parametersTA;
        const raParams = sensitivity.parametersRA;
        this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
        this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
      } else {
        this.invalidatePredictions();
      }
      this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
      if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
        this._isPredictionValid = false;
        this._position.set(NaN, NaN);
        this._altitude.set(NaN);
        this._groundTrack = NaN;
        this._groundSpeed.set(NaN);
        this._verticalSpeed.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.positionVec);
        Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
      } else {
        this.updatePosition(simTime, ownAirplane);
        this.updateVelocity(ownAirplane);
        this._groundSpeed.set(this.contact.groundSpeed);
        this._verticalSpeed.set(this.contact.verticalSpeed);
        this._isPredictionValid = true;
      }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
      this.contact.predict(simTime, this._position, this._altitude);
      this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
      const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
      const bearing = ownAirplane.position.bearingTo(this._position);
      Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
      const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
      this.positionVec[2] = verticalPosition;
      Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    updateVelocity(ownAirplane) {
      Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
      Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePredictions() {
      this.tcaTA.invalidate();
      this.tcaRA.invalidate();
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
      return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
      return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
  };
  AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
  AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  var DefaultTcasIntruder = class extends AbstractTcasIntruder {
  };
  var TcasTcaPredictionClass = class {
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder) {
      this.intruder = intruder;
      this._isValid = false;
      this._time = NaN;
      this._tcpa = UnitType.SECOND.createNumber(NaN);
      this.tcpa = this._tcpa.readonly;
      this._tcoa = UnitType.SECOND.createNumber(NaN);
      this.tcoa = this._tcoa.readonly;
      this._isThreat = false;
      this.cpaDisplacement = new Float64Array(3);
      this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
      this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
      this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
      this.cpaVerticalSep = this._cpaVerticalSep.readonly;
      this._cpaNorm = NaN;
    }
    /** @inheritdoc */
    get isValid() {
      return this._isValid;
    }
    /** @inheritdoc */
    get time() {
      return this._time;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get isThreat() {
      return this._isThreat;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get cpaNorm() {
      return this._cpaNorm;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime, tau, dmod, zthr, hmd) {
      var _a;
      this._time = simTime;
      if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
        this.invalidate();
        return;
      }
      const tauSeconds = tau.asUnit(UnitType.SECOND);
      const s = this.intruder.relativePositionVec;
      const v = this.intruder.relativeVelocityVec;
      const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
      const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
      const h = zthr.asUnit(UnitType.METER);
      const r = dmod.asUnit(UnitType.METER);
      const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
      const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
      const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
      const rSquared = r * r;
      const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
      const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
      const tcoa = -s[2] / v[2];
      const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
      const isVerticalThreat = Math.abs(s[2]) <= h || tcoa >= 0 && tcoa <= tauSeconds;
      let passHmdFilter = true;
      if (hmd !== void 0 && isHorizontalThreat && isVerticalThreat) {
        const d = hmd.asUnit(UnitType.METER);
        const dSquared = d * d;
        if (vHorizSquared === 0) {
          passHmdFilter = sHorizSquared <= dSquared;
        } else {
          const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
          if (delta < 0) {
            passHmdFilter = false;
          } else {
            const a = vHorizSquared;
            const b = 2 * dotSHorizVHoriz;
            const c = sHorizSquared - dSquared;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) {
              passHmdFilter = false;
            } else {
              passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
            }
          }
        }
      }
      this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
      this._tcpa.set(tcpa);
      this._tcoa.set(tcoa);
      TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
      AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
      AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
      this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
      this._isValid = true;
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate() {
      this._isValid = false;
      this._isThreat = false;
      this._tcpa.set(NaN);
      this._tcoa.set(NaN);
      Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
      this._cpaHorizontalSep.set(NaN);
      this._cpaVerticalSep.set(NaN);
      this._cpaNorm = NaN;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
      return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
      const horizLength = Math.hypot(vector[0], vector[1]);
      return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
  };
  TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var TcasResolutionAdvisoryHostClass = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus, options, ownAirplane) {
      this.options = options;
      this.ownAirplane = ownAirplane;
      this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
      this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
      this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.intruders = /* @__PURE__ */ new Set();
      this.intruderArray = [];
      this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
      this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.minVerticalSpeed = this._minVerticalSpeed.readonly;
      this._flags = 0;
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._secondaryType = null;
      this._primaryFlags = 0;
      this._secondaryFlags = 0;
      this.vsConstraints = [];
      this.lastStateChangeTime = 0;
      this.stateChangeDelay = 0;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    get flags() {
      return this._flags;
    }
    /** @inheritdoc */
    get primaryType() {
      return this._primaryType;
    }
    /** @inheritdoc */
    get secondaryType() {
      return this._secondaryType;
    }
    /** @inheritdoc */
    get primaryFlags() {
      return this._primaryFlags;
    }
    /** @inheritdoc */
    get secondaryFlags() {
      return this._secondaryFlags;
    }
    /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime, intruder) {
      if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
        return false;
      }
      if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime, alim, intruders) {
      if (this.intruderArray.length === 0 && intruders.size === 0) {
        return;
      }
      if (simTime < this.lastStateChangeTime) {
        this.lastStateChangeTime = simTime;
      }
      if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
        return;
      }
      if (intruders.size === 0) {
        this.cancel(simTime);
      } else {
        const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        const alimMeters = alim.asUnit(UnitType.METER);
        const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
        const responseTimeSecondsRemaining = isInitial ? responseTimeSeconds : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1e3, 0, responseTimeSeconds);
        const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
        this.updateIntruders(intruders);
        this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
        if (isInitial) {
          this.selectInitialState(simTime, ownAirplaneVsMps);
        } else {
          if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
            this.updatePositive(simTime);
          } else if (this._secondaryType === null) {
            this.updateNegative(simTime, ownAirplaneVsMps);
          } else {
            this.updateComposite(simTime, ownAirplaneVsMps);
          }
        }
      }
    }
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    updateIntruders(intruders) {
      for (let i = 0; i < this.intruderArray.length; i++) {
        if (!intruders.has(this.intruderArray[i])) {
          this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
        }
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      for (const intruder of intruders) {
        this.intruders.add(intruder);
        this.intruderArray.push(intruder);
      }
      this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
      var _a;
      var _b;
      const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
      for (let i = 0; i < this.intruderArray.length; i++) {
        const intruder = this.intruderArray[i];
        let above = -Infinity;
        let below = Infinity;
        if (intruder.tcaRA.isValid) {
          const t0 = intruder.tcaRA.time;
          const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
          const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1e3;
          const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
          const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
          const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
          const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
          const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
          if (aboveAlimSense === 1) {
            above = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters) : NaN;
            if (isNaN(above)) {
              above = Infinity;
            }
          } else {
            above = tcpaSeconds > 0 ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : -Infinity;
          }
          if (belowAlimSense === -1) {
            below = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters) : NaN;
            if (isNaN(below)) {
              below = -Infinity;
            }
          } else {
            below = tcpaSeconds > 0 ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : Infinity;
          }
        }
        const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : _b[i] = { above: 0, below: 0 };
        constraint.above = above;
        constraint.below = below;
      }
      this.vsConstraints.length = this.intruderArray.length;
    }
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    selectInitialState(simTime, ownAirplaneVsMps) {
      let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
      let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
      let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
      const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
      const canClimb = this.options.allowClimb(simTime);
      const canDescend = this.options.allowDescend(simTime);
      const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
      const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
      minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
      maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
      let sense;
      let senseIsCrossing = false;
      let doesSenseAchieveAlim = false;
      let senseRequiredVs = 0;
      if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
        sense = 1;
      } else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
        sense = -1;
      } else {
        const closestIntruder = this.intruderArray[0];
        const t0 = closestIntruder.tcaRA.time;
        const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
        const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
        const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
        const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
        if (crossingSense === -1 && !isUpSenseInhibited) {
          sense = 1;
        } else if (crossingSense === 1 && !isDownSenseInhibited) {
          sense = -1;
        } else {
          if (!isUpSenseInhibited && isDownSenseInhibited) {
            sense = 1;
          } else if (isUpSenseInhibited && !isDownSenseInhibited) {
            sense = -1;
          } else {
            if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
              sense = 1;
            } else {
              sense = -1;
            }
          }
          senseIsCrossing = sense === crossingSense;
        }
      }
      doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
      doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
      doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
      senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
      if (this.intruderArray.length > 1) {
        const doesCompositeAchieveAlim = this.vsConstraints.every((constraint) => constraint.above <= 0 || constraint.below >= 0);
        if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
          sense = 0;
          doesSenseAchieveAlim = doesCompositeAchieveAlim;
        } else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
          if (senseIsCrossing) {
            sense = 0;
            doesSenseAchieveAlim = doesCompositeAchieveAlim;
          } else {
            if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
              sense = 0;
              doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
          }
        }
      }
      let primaryType;
      let secondaryType = null;
      switch (sense) {
        case 0:
          if (doesSenseAchieveAlim) {
            const maxVsMps = this.getCompositeRequiredMaxVs();
            const minVsMps = this.getCompositeRequiredMinVs();
            if (ownAirplaneVsMps > maxVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
            } else if (ownAirplaneVsMps < minVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            }
          } else {
            primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
          }
          break;
        case 1:
          if (ownAirplaneVsMps < minUpSenseVsMps) {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            }
          } else {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
            }
          }
          break;
        case -1:
          if (ownAirplaneVsMps > maxDownSenseVsMps) {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
            }
          } else {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
            }
          }
          break;
      }
      this.setState(simTime, primaryType, secondaryType, true);
    }
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updatePositive(simTime) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
      const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
      if (isInhibited) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
        return;
      }
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        if (requiredVsMps * sense <= 0) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
      } else {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
        let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
        }
      }
    }
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    updateNegative(simTime, ownAirplaneVsMps) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        return;
      }
      const requirePositive = requiredVsMps * sense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
      } else {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
      }
    }
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    updateComposite(simTime, ownAirplaneVsMps) {
      if (this._secondaryType === null) {
        throw new Error("TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active");
      }
      const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
      const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredMinVsMps = this.getCompositeRequiredMinVs();
      const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
      const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
      if (primarySense === 1) {
        primaryCurrentVsMps = currentMinVsMps;
        primaryRequiredVsMps = requiredMinVsMps;
        secondaryCurrentVsMps = currentMaxVsMps;
        secondaryRequiredVsMps = requiredMaxVsMps;
      } else {
        primaryCurrentVsMps = currentMaxVsMps;
        primaryRequiredVsMps = requiredMaxVsMps;
        secondaryCurrentVsMps = currentMinVsMps;
        secondaryRequiredVsMps = requiredMinVsMps;
      }
      const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
      const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
      const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0 || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      let primaryType;
      if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
      } else {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
      }
      const secondaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
      this.setState(simTime, primaryType, secondaryType);
    }
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    setState(simTime, primaryType, secondaryType, isInitial = false) {
      if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
        return;
      }
      let minSpeed, maxSpeed;
      const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
      this._primaryType = primaryType;
      this._primaryFlags = primaryTypeDef.flags;
      this._secondaryType = secondaryType;
      if (secondaryType !== null) {
        const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
        this._secondaryFlags = secondaryTypeDef.flags;
        minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
        maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
      } else {
        this._secondaryFlags = 0;
        minSpeed = primaryTypeDef.minVerticalSpeed;
        maxSpeed = primaryTypeDef.maxVerticalSpeed;
      }
      this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
      this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
      this.isInitial = isInitial;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1e3;
      if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
        this.senseReversalCount++;
      }
      if (isInitial) {
        this.publisher.pub("tcas_ra_issued", this, false, false);
      } else {
        this.publisher.pub("tcas_ra_updated", this, false, false);
      }
    }
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
        return;
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      this._maxVerticalSpeed.set(NaN);
      this._minVerticalSpeed.set(NaN);
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._primaryFlags = 0;
      this._secondaryType = null;
      this._secondaryFlags = 0;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher.pub("tcas_ra_canceled", void 0, false, false);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    getUpSenseRequiredMinVs() {
      return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    getDownSenseRequiredMaxVs() {
      return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMinVs() {
      return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMaxVs() {
      return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
      const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
      if (signedAccel === 0) {
        return vs;
      }
      const y0 = currentAlt + vs * responseTime;
      const tc = tcpa - responseTime;
      const a = signedAccel / 2;
      const b = -signedAccel * tc;
      const c = targetAlt - y0 - vs * tc;
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) {
        return NaN;
      }
      const sqrtDiscr = Math.sqrt(discriminant);
      const t1 = (-b + sqrtDiscr) / (2 * a);
      const t2 = (-b - sqrtDiscr) / (2 * a);
      if (t1 <= tc && t1 >= 0) {
        return vs + signedAccel * t1;
      }
      if (t2 <= tc && t2 >= 0) {
        return vs + signedAccel * t2;
      }
      return NaN;
    }
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    static getDoNotDescendType(minVsMps) {
      if (minVsMps > -500) {
        return TcasResolutionAdvisoryType.DoNotDescend0;
      } else if (minVsMps > -1e3) {
        return TcasResolutionAdvisoryType.DoNotDescend500;
      } else if (minVsMps > -1500) {
        return TcasResolutionAdvisoryType.DoNotDescend1000;
      } else if (minVsMps > -2e3) {
        return TcasResolutionAdvisoryType.DoNotDescend1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotDescend2000;
      }
    }
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    static getDoNotClimbType(maxVsMps) {
      if (maxVsMps < 500) {
        return TcasResolutionAdvisoryType.DoNotClimb0;
      } else if (maxVsMps < 1e3) {
        return TcasResolutionAdvisoryType.DoNotClimb500;
      } else if (maxVsMps < 1500) {
        return TcasResolutionAdvisoryType.DoNotClimb1000;
      } else if (maxVsMps < 2e3) {
        return TcasResolutionAdvisoryType.DoNotClimb1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotClimb2000;
      }
    }
  };
  TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5e3;
  TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
      return -1;
    } else if (tcpaComparison > 0) {
      return 1;
    } else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
      return -1;
    } else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
      return 1;
    } else {
      return 0;
    }
  };
  TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
      flags: 0,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 2500,
      maxVerticalSpeed: 3e3
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -3e3,
      maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1e3
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 2e3
    }
  };
  TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];
  var DefaultTcasAdvisoryDataProvider = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tcas The TCAS instance.
     */
    constructor(bus, tcas) {
      this.bus = bus;
      this.tcas = tcas;
      this._paIntruders = SetSubject.create();
      this.paIntruders = this._paIntruders;
      this._taIntruders = SetSubject.create();
      this.taIntruders = this._taIntruders;
      this._raIntruders = SetSubject.create();
      this.raIntruders = this._raIntruders;
      this.isInit = false;
      this.isAlive = true;
      this.isPaused = false;
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
      if (!this.isAlive) {
        throw new Error("DefaultTcasAdvisoryDataProvider: cannot initialize a dead provider");
      }
      if (this.isInit) {
        return;
      }
      this.isInit = true;
      this.isPaused = paused;
      this.updateIntruders();
      const sub = this.bus.getSubscriber();
      this.intruderAlertLevelSub = sub.on("tcas_intruder_alert_changed").handle((intruder) => {
        const alertLevel = intruder.alertLevel.get();
        this._paIntruders.toggle(intruder, alertLevel === TcasAlertLevel.ProximityAdvisory);
        this._taIntruders.toggle(intruder, alertLevel === TcasAlertLevel.TrafficAdvisory);
        this._raIntruders.toggle(intruder, alertLevel === TcasAlertLevel.ResolutionAdvisory);
      });
      this.intruderRemovedSub = sub.on("tcas_intruder_removed").handle((intruder) => {
        this._paIntruders.delete(intruder);
        this._taIntruders.delete(intruder);
        this._raIntruders.delete(intruder);
      });
      if (paused) {
        this.pause();
      }
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
      var _a, _b;
      if (!this.isAlive) {
        throw new Error("DefaultTcasAdvisoryDataProvider: cannot resume a dead provider");
      }
      if (!this.isPaused) {
        return;
      }
      this.isPaused = false;
      this.updateIntruders();
      (_a = this.intruderAlertLevelSub) === null || _a === void 0 ? void 0 : _a.resume();
      (_b = this.intruderRemovedSub) === null || _b === void 0 ? void 0 : _b.resume();
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
      var _a, _b;
      if (!this.isAlive) {
        throw new Error("DefaultTcasAdvisoryDataProvider: cannot pause a dead provider");
      }
      if (this.isPaused) {
        return;
      }
      this.isPaused = true;
      (_a = this.intruderAlertLevelSub) === null || _a === void 0 ? void 0 : _a.pause();
      (_b = this.intruderRemovedSub) === null || _b === void 0 ? void 0 : _b.pause();
    }
    /**
     * Updates this provider's sets of intruders associated with active advisories.
     */
    updateIntruders() {
      const paIntruders = /* @__PURE__ */ new Set();
      const taIntruders = /* @__PURE__ */ new Set();
      const raIntruders = /* @__PURE__ */ new Set();
      const intruders = this.tcas.getIntruders();
      for (let i = 0; i < intruders.length; i++) {
        const intruder = intruders[i];
        switch (intruder.alertLevel.get()) {
          case TcasAlertLevel.ProximityAdvisory:
            paIntruders.add(intruder);
            break;
          case TcasAlertLevel.TrafficAdvisory:
            taIntruders.add(intruder);
            break;
          case TcasAlertLevel.ResolutionAdvisory:
            raIntruders.add(intruder);
            break;
        }
      }
      for (const intruder of this._paIntruders.get()) {
        if (!paIntruders.delete(intruder)) {
          this._paIntruders.delete(intruder);
        }
      }
      for (const intruder of this._taIntruders.get()) {
        if (!taIntruders.delete(intruder)) {
          this._taIntruders.delete(intruder);
        }
      }
      for (const intruder of this._raIntruders.get()) {
        if (!raIntruders.delete(intruder)) {
          this._raIntruders.delete(intruder);
        }
      }
      for (const intruder of paIntruders) {
        this._paIntruders.add(intruder);
      }
      for (const intruder of taIntruders) {
        this._taIntruders.add(intruder);
      }
      for (const intruder of raIntruders) {
        this._raIntruders.add(intruder);
      }
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
      var _a, _b;
      this.isAlive = false;
      (_a = this.intruderAlertLevelSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.intruderRemovedSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var TcasIISensitivityParameters = class {
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude, radarAltitude) {
      const altFeet = altitude.asUnit(UnitType.FOOT);
      const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
      let level;
      if (radarAltFeet > 2350) {
        if (altFeet > 42e3) {
          level = 6;
        } else if (altFeet > 2e4) {
          level = 5;
        } else if (altFeet > 1e4) {
          level = 4;
        } else if (altFeet > 5e3) {
          level = 3;
        } else {
          level = 2;
        }
      } else if (radarAltFeet > 1e3) {
        level = 1;
      } else {
        level = 0;
      }
      return level;
    }
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.PA;
    }
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPA(level) {
      return TcasIISensitivityParameters.PA;
    }
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level) {
      return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
  };
  TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
  };
  TcasIISensitivityParameters.TA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.33),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.48),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(40),
      protectedRadius: UnitType.NMILE.createNumber(0.75),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(45),
      protectedRadius: UnitType.NMILE.createNumber(1),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(1200)
    }
  ];
  TcasIISensitivityParameters.RA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.35),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.55),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(350),
      hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.8),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(400),
      hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(700),
      alim: UnitType.FOOT.createNumber(600),
      hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(800),
      alim: UnitType.FOOT.createNumber(700),
      hmd: UnitType.NMILE.createNumber(0.98)
    }
  ];
  var TcasIISensitivity = class {
    constructor() {
      this.sensitivity = new TcasIISensitivityParameters();
      this.level = 0;
      this.params = {
        parametersPA: this.sensitivity.getPA(0),
        parametersTA: this.sensitivity.getTA(0),
        parametersRA: this.sensitivity.getRA(0)
      };
    }
    /** @inheritdoc */
    selectParameters() {
      return this.params;
    }
    /** @inheritdoc */
    selectRAAlim() {
      return this.sensitivity.getRAAlim(this.level);
    }
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude, radarAltitude) {
      this.level = this.sensitivity.selectLevel(altitude, radarAltitude);
      this.params.parametersPA = this.sensitivity.getPA(this.level);
      this.params.parametersTA = this.sensitivity.getTA(this.level);
      this.params.parametersRA = this.sensitivity.getRA(this.level);
    }
  };
  var MapTrafficAlertLevelVisibility;
  (function(MapTrafficAlertLevelVisibility2) {
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["All"] = 15] = "All";
  })(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
  var MapTrafficModule = class {
    /**
     * Creates an instance of a MapTrafficModule.
     * @param tcas This module's associated TCAS.
     */
    constructor(tcas) {
      this.tcas = tcas;
      this.show = Subject.create(true);
      this.operatingMode = Subject.create(TcasOperatingMode.Standby);
      this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
      this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
      this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.isAltitudeRelative = Subject.create(true);
      this.tcas.getEventSubscriber().on("tcas_operating_mode").whenChanged().handle((mode) => {
        this.operatingMode.set(mode);
      });
    }
  };
  var MapSystemTrafficLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.iconLayerRef = FSComponent.createRef();
      this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
      this.intruderIcons = {
        [TcasAlertLevel.None]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ProximityAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.TrafficAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ResolutionAdvisory]: /* @__PURE__ */ new Map()
      };
      this.needHandleOffscaleOob = this.props.offScaleIntruders !== void 0 || this.props.oobIntruders !== void 0;
      this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
      this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
      this.isInit = false;
    }
    /** @inheritdoc */
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (!isVisible) {
        if (this.isInit) {
          this.iconLayerRef.instance.display.clear();
        }
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    /** @inheritdoc */
    onAttached() {
      this.iconLayerRef.instance.onAttached();
      this.oobOffset.sub(this.updateOobBounds.bind(this), true);
      this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
      this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
      this.initCanvasStyles();
      this.initIntruders();
      this.initTCASHandlers();
      this.isInit = true;
    }
    /**
     * Initializes canvas styles.
     */
    initCanvasStyles() {
      this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    /**
     * Initializes all currently existing TCAS intruders.
     */
    initIntruders() {
      const intruders = this.trafficModule.tcas.getIntruders();
      const len = intruders.length;
      for (let i = 0; i < len; i++) {
        this.onIntruderAdded(intruders[i]);
      }
    }
    /**
     * Initializes handlers to respond to TCAS events.
     */
    initTCASHandlers() {
      const tcasSub = this.props.context.bus.getSubscriber();
      tcasSub.on("tcas_intruder_added").handle(this.onIntruderAdded.bind(this));
      tcasSub.on("tcas_intruder_removed").handle(this.onIntruderRemoved.bind(this));
      tcasSub.on("tcas_intruder_alert_changed").handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.initCanvasStyles();
        this.updateOobBounds();
      }
    }
    /**
     * Updates the boundaries of the intruder out-of-bounds area.
     */
    updateOobBounds() {
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const oobOffset = this.oobOffset.get();
      this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onUpdated(time, elapsed) {
      if (!this.isVisible()) {
        return;
      }
      this.redrawIntruders();
    }
    /**
     * Redraws all tracked intruders.
     */
    redrawIntruders() {
      const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
      const offScaleRange = this.trafficModule.offScaleRange.get();
      const oobBounds = this.oobBounds.get();
      const iconDisplay = this.iconLayerRef.instance.display;
      iconDisplay.clear();
      for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
        const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
        if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b, _c, _d, _e, _f;
            icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
            if (this.needHandleOffscaleOob) {
              if (icon.isOffScale) {
                (_a = this.props.oobIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                (_b = this.props.offScaleIntruders) === null || _b === void 0 ? void 0 : _b.add(icon.intruder);
              } else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
              } else {
                (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
              }
            }
          });
        } else if (this.needHandleOffscaleOob) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b;
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
          });
        }
      }
    }
    /**
     * Updates this layer's visibility.
     */
    updateVisibility() {
      const operatingMode = this.trafficModule.tcas.getOperatingMode();
      this.setVisible(this.trafficModule.show.get() && (operatingMode === TcasOperatingMode.TAOnly || operatingMode === TcasOperatingMode.TA_RA || operatingMode === TcasOperatingMode.Test));
    }
    /**
     * A callback which is called when a TCAS intruder is added.
     * @param intruder The new intruder.
     */
    onIntruderAdded(intruder) {
      const icon = this.props.iconFactory(intruder, this.props.context);
      this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    /**
     * A callback which is called when a TCAS intruder is removed.
     * @param intruder The removed intruder.
     */
    onIntruderRemoved(intruder) {
      var _a, _b;
      (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
      (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
      this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    /**
     * A callback which is called when the alert level of a TCAS intruder is changed.
     * @param intruder The intruder.
     */
    onIntruderAlertLevelChanged(intruder) {
      let oldAlertLevel;
      let view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.None].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ProximityAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.TrafficAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ResolutionAdvisory].get(intruder);
      if (view) {
        this.intruderIcons[oldAlertLevel].delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
      }
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
  };
  MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TcasAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TcasAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TcasAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TcasAlertLevel.ResolutionAdvisory }
  ];
  var AbstractMapTrafficIntruderIcon = class {
    /**
     * Constructor.
     * @param intruder This icon's associated intruder.
     * @param trafficModule The traffic module for this icon's parent map.
     * @param ownshipModule The ownship module for this icon's parent map.
     */
    constructor(intruder, trafficModule, ownshipModule) {
      this.intruder = intruder;
      this.trafficModule = trafficModule;
      this.ownshipModule = ownshipModule;
      this.projectedPos = new Float64Array(2);
      this.isOffScale = false;
    }
    /**
     * Draws this icon.
     * @param projection The map projection.
     * @param context The canvas rendering context to which to draw this icon.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    draw(projection, context, offScaleRange) {
      this.updatePosition(projection, offScaleRange);
      this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    /**
     * Updates this icon's intruder's projected position and off-scale status.
     * @param projection The map projection.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale. If the value is `NaN`, the intruder is never considered off-scale.
     */
    updatePosition(projection, offScaleRange) {
      const ownAirplanePos = this.ownshipModule.position.get();
      if (offScaleRange.isNaN()) {
        projection.project(this.intruder.position, this.projectedPos);
        this.isOffScale = false;
      } else {
        this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
      }
    }
    /**
     * Updates this icon's intruder's projected position and off-scale status using a specific range from the own
     * airplane to define off-scale.
     * @param projection The map projection.
     * @param ownAirplanePos The position of the own airplane.
     * @param offScaleRange The distance from the own airplane to this icon's intruder beyond which the intruder is
     * considered off-scale.
     */
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
      const intruderPos = this.intruder.position;
      const horizontalSeparation = intruderPos.distance(ownAirplanePos);
      const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
      if (horizontalSeparation > offscaleRangeRad) {
        this.isOffScale = true;
        projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
      } else {
        this.isOffScale = false;
        projection.project(intruderPos, this.projectedPos);
      }
    }
  };
  AbstractMapTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];
  var MapSystemWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.waypointsLayer = FSComponent.createRef();
      this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
      this.waypointCache = (_a = this.props.waypointCache) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.searchItemLimits = {
        [FacilitySearchType.Airport]: 500,
        [FacilitySearchType.Vor]: 250,
        [FacilitySearchType.Ndb]: 250,
        [FacilitySearchType.Intersection]: 500,
        [FacilitySearchType.User]: 100
      };
      this.searchRadiusLimits = {
        [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.User]: Number.POSITIVE_INFINITY
      };
    }
    /** @inheritdoc */
    onAttached() {
      super.onAttached();
      this.waypointsLayer.instance.onAttached();
      this.initEventHandlers();
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      if (this.isVisible()) {
        this.waypointsLayer.instance.onUpdated(time, elapsed);
      }
    }
    /** @inheritdoc */
    initEventHandlers() {
      this.displayModule.numAirports.sub((num) => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
      this.displayModule.numIntersections.sub((num) => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
      this.displayModule.numVors.sub((num) => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
      this.displayModule.numNdbs.sub((num) => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
      this.displayModule.airportsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.intersectionsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.vorsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.ndbsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.refreshWaypoints.on(() => this.waypointsLayer.instance.refreshWaypoints());
    }
    /**
     * A callback called when the nearest facility search sessions have been started.
     * @param airportSession The airport search session.
     * @param vorSession The VOR search session.
     * @param ndbSession The NDB search session.
     * @param intSession The intersection search session.
     */
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession) {
      this.displayModule.intersectionsFilter.sub((filters) => intSession.setIntersectionFilter(filters.typeMask));
      this.displayModule.vorsFilter.sub((filters) => vorSession.setVorFilter(filters.classMask, filters.typeMask));
      this.displayModule.airportsFilter.sub((filters) => {
        airportSession.setAirportFilter(filters.showClosed, filters.classMask);
      });
      this.displayModule.extendedAirportsFilter.sub((filters) => {
        airportSession.setExtendedAirportFilters(filters.runwaySurfaceTypeMask, filters.approachTypeMask, filters.toweredMask, filters.minimumRunwayLength);
      });
    }
    /**
     * Initializes this layer's waypoint renderer.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    initWaypointRenderer(renderer, canvasLayer) {
      this.defineRenderRole(renderer, canvasLayer);
      renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    /**
     * Defines the render role for this layer's waypoints.
     * @param renderer This layer's waypoint renderer.
     * @param canvasLayer The canvas layer to which to draw the waypoints.
     */
    defineRenderRole(renderer, canvasLayer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.setCanvasContext(roleId, canvasLayer.display.context);
          renderer.setIconFactory(roleId, this.props.iconFactory);
          renderer.setLabelFactory(roleId, this.props.labelFactory);
          renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
        }
      });
    }
    /** @inheritdoc */
    setVisible(val) {
      super.setVisible(val);
      this.waypointsLayer.instance.setVisible(val);
    }
    /**
     * Checks to see if a waypoint should be visible.
     * @param waypoint The waypoint to check.
     * @returns True if visible, false otherwise.
     */
    isWaypointVisible(waypoint) {
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        switch (waypoint.type) {
          case WaypointTypes.Airport:
            return this.displayModule.showAirports.get()(waypoint);
          case WaypointTypes.Intersection:
            return this.displayModule.showIntersections.get()(waypoint);
          case WaypointTypes.VOR:
            return this.displayModule.showVors.get()(waypoint);
          case WaypointTypes.NDB:
            return this.displayModule.showNdbs.get()(waypoint);
        }
      }
      return false;
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: this.registerWaypoint.bind(this), deregisterWaypoint: this.deregisterWaypoint.bind(this), searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : void 0, onSessionsStarted: this.onSessionsStarted.bind(this), class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    /**
     * Registers a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to register.
     * @param renderer The renderer to register the waypoint to.
     */
    registerWaypoint(waypoint, renderer) {
      const selector = this.displayModule.waypointRoleSelector.get();
      if (selector) {
        const id = selector(waypoint);
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.register(waypoint, roleId, "waypoints-layer");
        }
      } else {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach((id) => {
          const roleId = renderer.getRoleFromName(id);
          if (roleId !== void 0) {
            renderer.register(waypoint, roleId, "waypoints-layer");
          }
        });
      }
    }
    /**
     * Deregisters a waypoint with this layer's waypoint renderer.
     * @param waypoint The waypoint to deregister.
     * @param renderer The renderer to deregister the waypoint from.
     */
    deregisterWaypoint(waypoint, renderer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.deregister(waypoint, roleId, "waypoints-layer");
        }
      });
    }
  };
  var MapTerrainColorsModule = class {
    constructor() {
      this.reference = Subject.create(EBingReference.SEA);
      this.showIsoLines = Subject.create(false);
      this.colors = ArraySubject.create(BingComponent.createEarthColorsArray("#0000FF", [
        {
          elev: 0,
          color: "#000000"
        }
      ], 0, 3e4, 1));
      this.colorsElevationRange = Vec2Subject.create(Vec2Math.create(0, 3e4));
    }
  };
  var MapFlightPlanModule = class {
    constructor() {
      this.plans = [];
    }
    /**
     * Gets the flight plan subjects for a specified flight plan.
     * @param index The index of the flight plan.
     * @returns The subject for the specified plan index.
     */
    getPlanSubjects(index) {
      let planSubject = this.plans[index];
      if (planSubject === void 0) {
        planSubject = new PlanSubjects();
        this.plans[index] = planSubject;
      }
      return planSubject;
    }
  };
  var PlanSubjects = class {
    constructor() {
      this.flightPlan = Subject.create(void 0);
      this.planChanged = new SubEvent();
      this.planCalculated = new SubEvent();
      this.activeLeg = Subject.create(0);
    }
  };
  var MapFollowAirplaneModule = class {
    constructor() {
      this.isFollowing = Subject.create(false);
    }
  };
  var MapWaypointDisplayModule = class {
    constructor() {
      this.showAirports = Subject.create(() => true);
      this.showIntersections = Subject.create(() => false);
      this.showNdbs = Subject.create(() => true);
      this.showVors = Subject.create(() => true);
      this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.numAirports = Subject.create(40);
      this.numIntersections = Subject.create(40);
      this.numNdbs = Subject.create(40);
      this.numVors = Subject.create(40);
      this.intersectionsFilter = Subject.create({
        typeMask: NearestIntersectionSearchSession.Defaults.TypeMask,
        showTerminalWaypoints: true
      });
      this.vorsFilter = Subject.create({
        typeMask: NearestVorSearchSession.Defaults.TypeMask,
        classMask: NearestVorSearchSession.Defaults.ClassMask
      });
      this.airportsFilter = Subject.create({
        classMask: NearestAirportSearchSession.Defaults.ClassMask,
        showClosed: NearestAirportSearchSession.Defaults.ShowClosed
      });
      this.extendedAirportsFilter = Subject.create({
        runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
        approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
        minimumRunwayLength: NearestAirportSearchSession.Defaults.MinimumRunwayLength,
        toweredMask: NearestAirportSearchSession.Defaults.ToweredMask
      });
      this.waypointRoleSelector = Subject.create(void 0);
      this.refreshWaypoints = new SubEvent();
    }
  };
  var MapWxrModule = class {
    constructor() {
      this.isEnabled = Subject.create(false);
      this.weatherRadarArc = NumberUnitSubject.create(UnitType.DEGREE.createNumber(90));
      this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
      this.weatherRadarColors = ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this._wxrMode = MappedSubject.create(([isEnabled, arc, mode]) => {
        return {
          mode: isEnabled ? mode : EWeatherRadar.OFF,
          arcRadians: arc.asUnit(UnitType.RADIAN)
        };
      }, this.isEnabled, this.weatherRadarArc, this.weatherRadarMode);
    }
    /**
     * A subscribable containing the combined WxrMode from the mode and arc subjects,
     * suitable for consumption in a MapBingLayer.
     * @returns The WxrMode subscribable.
     */
    get wxrMode() {
      return this._wxrMode;
    }
  };
  var MapAltitudeArcModule = class {
    constructor() {
      this.show = Subject.create(false);
    }
  };
  var WaypointDisplayBuilder = class {
    /**
     * Creates an instance of the WaypointDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     */
    constructor(iconFactory, labelFactory, waypointRenderer) {
      this.iconFactory = iconFactory;
      this.labelFactory = labelFactory;
      this.waypointRenderer = waypointRenderer;
      this.roleGroup = MapSystemWaypointRoles.Normal;
      this.isCenterTarget = false;
    }
    /**
     * Adds a icon configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an icon for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addIcon(role, type, config) {
      this.iconFactory.addIconFactory(this.determineRoleId(role), type, config);
      return this;
    }
    /**
     * Adds a default icon configuration to the waypoint display system, if no other configuration is found.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint icon factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultIcon(role, config) {
      this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config);
      return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param type The type of waypoint to add an label for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addLabel(role, type, config) {
      this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config);
      return this;
    }
    /**
     * Adds a label configuration to the waypoint display system.
     * @param role The role to add this waypoint display config for.
     * @param config The waypoint label factory to add as a configuration.
     * @returns The modified builder.
     */
    addDefaultLabel(role, config) {
      this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config);
      return this;
    }
    /**
     * Determines the role ID given either a numeric or string based role.
     * @param role The role to determine.
     * @returns The numeric role ID.
     */
    determineRoleId(role) {
      let roleId = 0;
      if (typeof role === "string") {
        const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
        if (roleIdFromName !== void 0) {
          roleId = roleIdFromName;
        }
      } else {
        roleId = role;
      }
      return roleId;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
      this.waypointRenderer.addRenderRole(name, void 0, this.roleGroup);
      return this;
    }
    /**
     * Gets the ID of a role in the waypoint display system.
     * @param role The name of the role to get the ID for.
     * @returns The ID of the role.
     * @throws An error if an invalid role name is supplied.
     */
    getRoleId(role) {
      const roleId = this.waypointRenderer.getRoleFromName(role);
      if (roleId === void 0) {
        throw new Error(`The role with name ${role} was not defined and could not be found.`);
      }
      return roleId;
    }
    /**
     * Configures the center for waypoint searches for this display.
     * @param center If center, then waypoint searches will use the map center. If target,
     * waypoint searches will use the map target with offset.
     * @returns The modified builder.
     */
    withSearchCenter(center) {
      if (center === "center") {
        this.isCenterTarget = false;
      } else {
        this.isCenterTarget = true;
      }
      return this;
    }
    /**
     * Gets if the waypoint search is using the map target with offset as the search center.
     * @returns True if the search center is the map target, false if it is the map center.
     */
    getIsCenterTarget() {
      return this.isCenterTarget;
    }
    /**
     * Configures the facility waypoint cache to use with the waypoint display.
     * @param cache The facility waypoint cache to use, or undefined to use the default.
     * @returns The modified builder.
     */
    withWaypointCache(cache) {
      this.facilityWaypointCache = cache;
      return this;
    }
    /**
     * Gets the currently set facility waypoint cache.
     * @returns The currently set facility waypoint cache.
     */
    getWaypointCache() {
      return this.facilityWaypointCache;
    }
  };
  var FlightPlanDisplayBuilder = class extends WaypointDisplayBuilder {
    /**
     * Creates an instance of the FlightPlanDisplayBuilder.
     * @param iconFactory The icon factory to use with this builder.
     * @param labelFactory The label factory to use with this builder.
     * @param waypointRenderer The waypoint renderer to use with this builder.
     * @param flightPlanRenderer The flight plan renderer to use with this builder.
     * @param planIndex The flight plan index to be displayed by this system.
     */
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
      super(iconFactory, labelFactory, waypointRenderer);
      this.flightPlanRenderer = flightPlanRenderer;
      this.planIndex = planIndex;
      this.roleGroup = MapSystemWaypointRoles.FlightPlan;
      this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
      flightPlanRenderer.legStyleHandlers;
    }
    /**
     * Registers a waypoint display role for use with the flight plan rendering
     * system.
     * @param name The name of the role to register.
     * @returns The modified builder.
     */
    registerRole(name) {
      this.waypointRenderer.insertRenderRole(name, MapSystemWaypointRoles.Normal, void 0, this.roleGroup);
      return this;
    }
    /**
     * Configures the flight path display to use styles returned by the provided function.
     * @param handler The handler to use to return the required path rendering styles.
     * @returns The modified builder.
     */
    withLegPathStyles(handler) {
      this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
      return this;
    }
    /**
     * Configures the flight plan waypoint display to use the roles returned by the
     * provided function.
     * @param handler The handler to use to return the required waypoint display roles.
     * @returns The modified builder.
     */
    withLegWaypointRoles(handler) {
      this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
      return this;
    }
    /**
     * Configures the flight plan flight path display to set visibility of leg-to-leg
     * turn anticipation transitions.
     * @param visible Whether or not the leg-to-leg turn anticipation transitions will be visible.
     * @returns The modified builder.
     */
    withAnticipationTurns(visible) {
      const visibleSub = SubscribableUtils.toSubscribable(visible, true);
      this.flightPlanRenderer.renderEgress = visibleSub;
      this.flightPlanRenderer.renderIngress = visibleSub;
      return this;
    }
  };
  var GenericAirspaceRenderManager = class {
    /**
     * Constructor.
     * @param renderOrder A function which determines the order in which this manager renders airspaces. The function
     * should return a negative number when airspace `a` should be rendered before (below) airspace `b`, a positive
     * number when airspace `a` should be rendered after (above) airspace `b`, and `0` when the relative render order
     * of the two airspaces does not matter.
     * @param selectRenderer A function which selects airspace renderers for individual airspaces.
     */
    constructor(renderOrder, selectRenderer) {
      this.renderOrder = renderOrder;
      this.selectRenderer = selectRenderer;
      this.airspaces = /* @__PURE__ */ new Map();
    }
    /** @inheritdoc */
    getRegisteredAirspaces() {
      return Array.from(this.airspaces.values());
    }
    /** @inheritdoc */
    registerAirspace(airspace) {
      if (this.airspaces.has(airspace.facility.id)) {
        return false;
      }
      this.airspaces.set(airspace.facility.id, airspace);
      return true;
    }
    /** @inheritdoc */
    deregisterAirspace(airspace) {
      return this.airspaces.delete(airspace.facility.id);
    }
    /** @inheritdoc */
    replaceRegisteredAirspaces(airspaces) {
      let changed = false;
      let numMatched = 0;
      for (const airspace of airspaces) {
        changed || (changed = !this.airspaces.has(airspace.facility.id));
        if (changed) {
          break;
        } else {
          numMatched++;
        }
      }
      changed || (changed = numMatched !== this.airspaces.size);
      if (!changed) {
        return false;
      }
      this.airspaces.clear();
      for (const airspace of airspaces) {
        this.registerAirspace(airspace);
      }
      return true;
    }
    /** @inheritdoc */
    clearRegisteredAirspaces() {
      if (this.airspaces.size === 0) {
        return false;
      }
      this.airspaces.clear();
      return true;
    }
    /** @inheritdoc */
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
      const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
      const tasks = sorted.map((airspace) => {
        const renderer = this.selectRenderer(airspace);
        return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
      });
      return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
  };
  var MapAutopilotPropsController = class extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param properties The properties to update on the module.
     * @param updateFreq A subscribable which provides the update frequency, in hertz. If not defined, the properties
     * will be updated every frame.
     */
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
      this.subs = {};
    }
    /** @inheritdoc */
    onAfterMapRender() {
      const sub = this.context.bus.getSubscriber();
      if (this.updateFreq) {
        this.updateFreqSub = this.updateFreq.sub((freq) => {
          var _a;
          for (const property of this.properties) {
            (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
            this.subs[property] = this.bindProperty(sub, property, freq);
          }
        }, true);
      } else {
        for (const property of this.properties) {
          this.subs[property] = this.bindProperty(sub, property);
        }
      }
    }
    /**
     * Binds a module property to data received through the event bus.
     * @param sub The event bus subscriber.
     * @param property The property to bind.
     * @param updateFreq The data update frequency.
     * @returns The subscription created by the binding.
     */
    bindProperty(sub, property, updateFreq) {
      switch (property) {
        case "selectedAltitude":
          return (updateFreq === void 0 ? sub.on("ap_altitude_selected") : sub.on("ap_altitude_selected").atFrequency(updateFreq)).handle((alt) => {
            this.module.selectedAltitude.set(alt, UnitType.FOOT);
          });
      }
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.destroy();
    }
    /** @inheritdoc */
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapSystemComponent = class extends MapComponent {
    /** @inheritdoc */
    constructor(props) {
      var _a;
      super(props);
      this.rootStyles = ObjectSubject.create({
        width: "0px",
        height: "0px"
      });
      this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
      this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    /** @inheritdoc */
    onAfterRender(thisNode) {
      super.onAfterRender(thisNode);
      this.onProjectedSizeChanged();
      this.props.onAfterRender();
    }
    /**
     * This method is called when the size of this map's dead zone changes.
     * @param deadZone The dead zone.
     */
    onDeadZoneChanged(deadZone) {
      this.props.onDeadZoneChanged(deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    /**
     * Sets the size of this map's root HTML element.
     * @param size The new size, in pixels.
     */
    setRootSize(size) {
      this.rootStyles.set("width", `${size[0]}px`);
      this.rootStyles.set("height", `${size[1]}px`);
    }
    /** @inheritdoc */
    onProjectedSizeChanged() {
      this.setRootSize(this.mapProjection.getProjectedSize());
    }
    /** @inheritdoc */
    onUpdated(time, elapsed) {
      this.props.onBeforeUpdated(time, elapsed);
      super.onUpdated(time, elapsed);
      this.props.onAfterUpdated(time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
      super.onWake();
      this.props.onWake();
    }
    /** @inheritdoc */
    onSleep() {
      super.onSleep();
      this.props.onSleep();
    }
    /** @inheritdoc */
    render() {
      var _a;
      return FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }, this.props.children);
    }
    /** @inheritdoc */
    destroy() {
      super.destroy();
      this.props.onDestroy();
    }
  };
  var DefaultMapSystemContext = class {
    /**
     * Creates an instance of a MapSystemContext.
     * @param bus This context's event bus.
     * @param projection This context's map projection.
     * @param projectedSize A subscribable which provides the projected size of this context's map.
     * @param deadZone A subscribable which provides the dead zone of this context's map.
     */
    constructor(bus, projection, projectedSize, deadZone) {
      this.bus = bus;
      this.projection = projection;
      this.projectedSize = projectedSize;
      this.deadZone = deadZone;
      this.model = new MapModel();
      this.layers = /* @__PURE__ */ new Map();
      this.controllers = /* @__PURE__ */ new Map();
    }
    /**
     * Retrieves a layer from this context.
     * @param key The key of the layer to retrieve.
     * @returns The layer in this context with the specified key.
     */
    getLayer(key) {
      return this.layers.get(key);
    }
    /**
     * Retrieves a controller from this context.
     * @param key The key fo the controller to retrieve.
     * @returns The controller in this context with the specified key.
     */
    getController(key) {
      return this.controllers.get(key);
    }
    /**
     * Adds a layer to this context.
     * @param key The key of the layer to add.
     * @param layer The layer to add.
     */
    setLayer(key, layer) {
      this.layers.set(key, layer);
    }
    /**
     * Adds a controller to this context.
     * @param key The key of the controller to add.
     * @param controller The controller to add.
     */
    setController(key, controller) {
      this.controllers.set(key, controller);
    }
  };
  var MapSystemGenericController = class extends MapSystemController {
    /**
     * Constructor.
     * @param context This controller's map context.
     * @param callbacks The callback functions to which this controller delegates its behavior.
     */
    constructor(context, callbacks) {
      super(context);
      this.callbacks = callbacks;
    }
    /** @inheritdoc */
    onAfterMapRender() {
      this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    /** @inheritdoc */
    onDeadZoneChanged(deadZone) {
      this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    /** @inheritdoc */
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    /** @inheritdoc */
    onBeforeUpdated(time, elapsed) {
      this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onAfterUpdated(time, elapsed) {
      this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    /** @inheritdoc */
    onWake() {
      this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    /** @inheritdoc */
    onSleep() {
      this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    /** @inheritdoc */
    onMapDestroyed() {
      this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    /** @inheritdoc */
    destroy() {
      super.destroy();
      this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
  };
  var MapSystemPlanRenderer = class extends AbstractFlightPathPlanRenderer {
    /**
     * Creates an instance of the MapSystemPlanRenderer.
     * @param defaultRoleId The default role ID to render the plan waypoints under.
     * @param renderOrder The order which this renderer renders the flight plan legs. Forward order renders the legs in a first-to-last
     * fashion. Reverse order renders the legs in a last-to-first fashion. Defaults to forward.
     * @param renderActiveLegLast Whether to render the active leg last. Defaults to true.
     */
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
      super(renderOrder, renderActiveLegLast);
      this.defaultRoleId = defaultRoleId;
      this.legRenderer = new MapSystemLegRenderer();
      this.legStyleHandlers = /* @__PURE__ */ new Map();
      this.legWaypointHandlers = /* @__PURE__ */ new Map();
      this.renderIngress = Subject.create(false);
      this.renderEgress = Subject.create(false);
    }
    /** @inheritdoc */
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
      this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
      const handler = this.legStyleHandlers.get(plan.planIndex);
      if (handler !== void 0) {
        this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
      }
      let partsToRender = FlightPathLegRenderPart.Base | (this.renderIngress.get() ? FlightPathLegRenderPart.Ingress : 0) | (this.renderEgress.get() ? FlightPathLegRenderPart.Egress : 0);
      if (this.legRenderer.currentRenderStyle.partsToRender !== void 0) {
        partsToRender = this.legRenderer.currentRenderStyle.partsToRender;
      }
      this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
  };
  var MapSystemLegRenderer = class extends AbstractFlightPathLegRenderer {
    constructor() {
      super(...arguments);
      this.vectorRenderer = new FlightPathVectorLineRenderer();
      this.currentRenderStyle = new FlightPathRenderStyle();
    }
    /** @inheritdoc */
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
      if ("styleBuilder" in this.currentRenderStyle) {
        const currentRenderStyle = this.currentRenderStyle.styleBuilder(vector, isIngress, isEgress);
        this.vectorRenderer.render(vector, context, streamStack, currentRenderStyle.width, currentRenderStyle.style, currentRenderStyle.dash, currentRenderStyle.outlineWidth, currentRenderStyle.outlineStyle);
      } else {
        if (this.currentRenderStyle.isDisplayed) {
          this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash, this.currentRenderStyle.outlineWidth, this.currentRenderStyle.outlineStyle);
        }
      }
    }
  };
  var FlightPathRenderStyle = class {
    /**
     * Creates an instance of a FlightPathRenderStyle.
     * @param isDisplayed Whether or not the path is displayed.
     */
    constructor(isDisplayed = true) {
      this.isDisplayed = isDisplayed;
      this.width = 2;
      this.style = "";
    }
  };
  FlightPathRenderStyle.Default = new FlightPathRenderStyle();
  FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);
  var MapSystemUtils = class {
    /**
     * Converts a nominal relative projected x coordinate to a true relative projected x coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelX A nominal relative projected x coordinate.
     * @param width The width of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected x coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
      return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    /**
     * Converts a nominal relative projected y coordinate to a true relative projected y coordinate. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominalRelY A nominal relative projected y coordinate.
     * @param height The height of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @returns The true relative projected y coordinate that is equivalent to the specified nominal coordinate.
     */
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
      return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    /**
     * Converts nominal relative projected coordinates to a true relative projected coordinates. Nominal relative
     * coordinates are expressed relative to the map's projected width and height, *excluding* dead zones. True relative
     * coordinates are expressed relative to the map's projected width and height, *including* dead zones.
     * @param nominal Nominal relative projected coordinates.
     * @param size The size of the map's projected window, in pixels.
     * @param deadZone The map's dead zone, as `[left, top, right, bottom]` in pixels.
     * @param out The vector to which to write the result.
     * @returns The true relative projected coordinates that are equivalent to the specified nominal coordinates.
     */
    static nominalToTrueRelativeXY(nominal, size, deadZone, out) {
      return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size[1], deadZone), out);
    }
  };
  var MapSystemWaypointsRenderer = class extends MapWaypointRenderer {
    /**
     * Constructor.
     * @param textManager The text manager to use for waypoint labels.
     */
    constructor(textManager) {
      super(textManager, (entry, roleDefinitions) => {
        var _a;
        for (let i = 0; i < this.rolePriorityOrder.length; i++) {
          const role = this.rolePriorityOrder[i];
          if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
            return role;
          }
        }
        return 0;
      });
      this.rolePriorityOrder = [];
      this.rolesByGroup = /* @__PURE__ */ new Map();
      this.roleIdMap = /* @__PURE__ */ new Map();
      this.currentBit = 1;
      this.onRolesAdded = new SubEvent();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      if (typeof arg1 === "number") {
        return false;
      }
      this.roleIdMap.set(arg1, this.currentBit);
      super.addRenderRole(this.currentBit, def);
      this.rolePriorityOrder.push(this.currentBit);
      let roleGroup = this.rolesByGroup.get(group);
      if (roleGroup === void 0) {
        roleGroup = [];
        this.rolesByGroup.set(group, roleGroup);
      }
      roleGroup.push(arg1);
      this.currentBit *= 2;
      this.onRolesAdded.notify(this);
      return true;
    }
    /**
     * Adds a new named render role to this renderer and inserts it before an existing render role in this renderer's
     * render role selection priority order. Roles positioned earlier in the order have a higher priority for being
     * chosen when roles are selected for rendering waypoints.
     * @param name The name of the render role to add.
     * @param insertBefore The name of the role before which to insert the new role in this renderer's render role
     * selection priority order. If the name does not match any of this renderer's existing render roles, the new role
     * will be placed at the end of the priority order.
     * @param def The render role's definition. If undefined, the new role will be assigned a default definition with
     * no defined rendering context, icon, or label factories, and a visibility handler which always returns true.
     * @param group The group in which to include the new render role, if any. Defaults to
     * {@link MapSystemWaypointsRenderer.DefaultGroup}.
     * @returns Whether the role was successfully inserted.
     */
    insertRenderRole(name, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      const role = this.currentBit;
      this.addRenderRole(name, def, group);
      const roleToInsertBefore = this.roleIdMap.get(insertBefore);
      if (roleToInsertBefore !== void 0) {
        const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
        if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
          this.rolePriorityOrder.pop();
          this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
        }
      }
      return true;
    }
    /**
     * Gets a render role associated with a name.
     * @param name The name of the role.
     * @returns The render role associated with the specified name, or undefined if there is no such role.
     */
    getRoleFromName(name) {
      return this.roleIdMap.get(name);
    }
    /**
     * Gets the names of roles in a specified group.
     * @param group A render role group.
     * @returns An array of the names of all render roles belonging to the specified group.
     */
    getRoleNamesByGroup(group) {
      const roleNames = this.rolesByGroup.get(group);
      if (roleNames !== void 0) {
        return roleNames;
      }
      return [];
    }
  };
  MapSystemWaypointsRenderer.DefaultGroup = "DEFAULT_GROUP";
  var MapSystemIconFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.iconFactories = /* @__PURE__ */ new Map();
      this.defaultIconFactories = /* @__PURE__ */ new Map();
    }
    /**
     * Adds an icon factory to the container.
     * @param role The role that this icon factory will be assigned to.
     * @param iconType The unique string type name of the icon.
     * @param factory The factory that will produce the icon.
     */
    addIconFactory(role, iconType, factory) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default icon factory for a role.
     * @param role The role to add a default icon factory for.
     * @param factory The factory that will produce the icons.
     */
    addDefaultIconFactory(role, factory) {
      this.defaultIconFactories.set(role, factory);
    }
    /** @inheritdoc */
    getIcon(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let icon = roleCache.get(waypoint.uid);
      if (icon === void 0) {
        icon = this.createIcon(role, waypoint);
        roleCache.set(waypoint.uid, icon);
      }
      return icon;
    }
    /**
     * Creates a new icon for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint for which to create an icon.
     * @returns a waypoint icon.
     */
    createIcon(role, waypoint) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      const factory = roleFactories.get(waypoint.type);
      if (factory !== void 0) {
        return factory(waypoint);
      } else {
        const defaultFactory = this.defaultIconFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      const imageEl = document.createElement("img");
      imageEl.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC";
      return new MapWaypointImageIcon(waypoint, 0, imageEl, Vec2Math.create(24, 24));
    }
  };
  var MapSystemLabelFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.labelFactories = /* @__PURE__ */ new Map();
      this.defaultLabelFactories = /* @__PURE__ */ new Map();
    }
    /**
     * Adds an label factory to the container.
     * @param role The role to add this label factory for.
     * @param iconType The unique string type name of the waypoint.
     * @param factory The factory that will produce the waypoint label.
     */
    addLabelFactory(role, iconType, factory) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      roleFactories.set(iconType, factory);
    }
    /**
     * Adds a default label factory for a role.
     * @param role The role to add a default label factory for.
     * @param factory The factory that will produce the labels.
     */
    addDefaultLabelFactory(role, factory) {
      this.defaultLabelFactories.set(role, factory);
    }
    /** @inheritdoc */
    getLabel(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let label = roleCache.get(waypoint.uid);
      if (label === void 0) {
        label = this.createLabel(role, waypoint);
        roleCache.set(waypoint.uid, label);
      }
      return label;
    }
    /**
     * Creates a new label for a waypoint.
     * @param role The role that has been selected to render.
     * @param waypoint The waypoint to create a label for.
     * @returns A new waypoint label.
     */
    createLabel(role, waypoint) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      const factory = roleFactories.get(waypoint.type);
      if (factory !== void 0) {
        return factory(waypoint);
      } else {
        const defaultFactory = this.defaultLabelFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      let text = "";
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        text = ICAO.getIdent(waypoint.facility.get().icao);
      }
      return new MapCullableLocationTextLabel(text, 0, waypoint.location, false, { fontSize: 22, font: "monospace", anchor: new Float64Array([-0.25, 0.4]) });
    }
  };
  var MapSystemBuilder = class {
    /**
     * Creates an instance of a map system builder.
     * @param bus This builder's event bus.
     */
    constructor(bus) {
      this.bus = bus;
      this.moduleFactories = /* @__PURE__ */ new Map();
      this.layerFactories = /* @__PURE__ */ new Map();
      this.controllerFactories = /* @__PURE__ */ new Map();
      this.contextFactories = /* @__PURE__ */ new Map();
      this.initCallbacks = /* @__PURE__ */ new Map();
      this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map model modules added to this builder. */
    get moduleCount() {
      return this.moduleFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map layers added to this builder. */
    get layerCount() {
      return this.layerFactories.size;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of map controllers added to this builder. */
    get controllerCount() {
      return this.controllerFactories.size;
    }
    /**
     * Creates a new Garmin map builder. The builder is initialized with a default projected size of `[100, 100]` pixels.
     * @param bus The event bus.
     * @returns A new Garmin map builder.
     */
    static create(bus) {
      return new MapSystemBuilder(bus);
    }
    /**
     * Configures this builder to generate a map with a given projected window size.
     * @param size The size of the projected window, as `[width, height]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withProjectedSize(size) {
      this.projectedSize = "isSubscribable" in size ? size : Subject.create(size);
      return this;
    }
    /**
     * Configures this builder to generate a map with a given dead zone.
     * @param deadZone The dead zone, as `[left, top, right, bottom]` in pixels, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withDeadZone(deadZone) {
      this.deadZone = "isSubscribable" in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
      return this;
    }
    /**
     * Configures this builder to generate a map with an initial projected target offset.
     * @param offset The initial projected target offset, as `[x, y]` in pixels.
     * @returns This builder, after it has been configured.
     */
    withTargetOffset(offset) {
      this.targetOffset = offset;
      return this;
    }
    /**
     * Configures this builder to generate a map with specific initial range endpoints. The endpoints are defined
     * relative to the width and height of the map's projected window, *excluding* the dead zone.
     * @param endpoints The initial range endpoints, as `[x1, y1, x2, y2]`.
     * @returns This builder, after it has been configured.
     */
    withRangeEndpoints(endpoints) {
      this.nominalRangeEndpoints = endpoints;
      return this;
    }
    /**
     * Configures this build to generate a map with a specific initial range.
     * @param range The initial range.
     * @returns This builder, after it has been configured.
     */
    withRange(range) {
      this.range = range.asUnit(UnitType.GA_RADIAN);
      return this;
    }
    /**
     * Adds a map module to this builder. When this builder compiles its map, all added modules will be created and added
     * to the map's model. If an existing module has been added to this builder with the same key, it will be replaced.
     * @param key The key (name) of the module.
     * @param factory A function which creates the module.
     * @returns This builder, after the map module has been added.
     */
    withModule(key, factory) {
      this.moduleFactories.set(key, { key, factory });
      return this;
    }
    /**
     * Adds a map layer to this builder. When this builder compiles its map, all added layers will be created and
     * attached to the map. Layers with a lower assigned order will be attached before and appear below layers with
     * greater assigned order values. If an existing layer has been added to this builder with the same key, it will be
     * replaced.
     * @param key The key of the layer.
     * @param factory A function which renders the layer as a VNode.
     * @param order The order assigned to the layer. Layers with lower assigned order will be attached to the map before
     * and appear below layers with greater assigned order values. Defaults to the number of layers already added to this
     * builder.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the layer.
     */
    withLayer(key, factory, order) {
      const wasDeleted = this.layerFactories.delete(key);
      this.layerFactories.set(key, { key, factory, order: order !== null && order !== void 0 ? order : this.layerFactories.size + (wasDeleted ? 1 : 0) });
      return this;
    }
    /**
     * Adds a controller to this builder. When this builder compiles its map, all added controllers will be created and
     * hooked up to the map's lifecycle callbacks. If an existing controller has been added to this builder with the same
     * key, it will be replaced.
     * @param key The key of the controller.
     * @param factory A function which creates the controller.
     * @returns This builder, after the map layer has been added, or `never` if this builder does not have all the
     * modules required by the controller.
     */
    withController(key, factory) {
      this.controllerFactories.set(key, { factory });
      return this;
    }
    /**
     * Adds a context property to this builder. When the builder compiles its map, all added properties will be available
     * on the context. Properties are created on the context in the order they were added to the builder, and property
     * factories have access to previously created properties on the context. If an existing property has been added to
     * this builder with the same key, it will be replaced.
     * @param key The key of the property to add.
     * @param factory A function which creates the value of the property.
     * @returns This builder, after the context property has been added.
     */
    withContext(key, factory) {
      var _a;
      if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
        const existing = this.contextFactories.get(key);
        const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
        this.contextFactories.set(key, { key, factory, order });
      }
      return this;
    }
    /**
     * Configures this builder to execute a callback function immediately after it is finished compiling a map. If an
     * existing callback has been added to this builder with the same key, it will be replaced.
     * @param key The key of the callback.
     * @param callback The callback function to add.
     * @returns This builder, after the callback has been added.
     */
    withInit(key, callback) {
      this.initCallbacks.set(key, callback);
      return this;
    }
    /**
     * Assigns an order value to a layer. Layers with a lower assigned order will be attached before and appear below
     * layers with greater assigned order values.
     * @param key The key of the layer to which to assign the order value.
     * @param order The order value to assign.
     * @returns This builder, after the order value has been assigned.
     */
    withLayerOrder(key, order) {
      const factory = this.layerFactories.get(key);
      if (factory) {
        this.layerFactories.delete(key);
        factory.order = order;
        this.layerFactories.set(key, factory);
      }
      return this;
    }
    /**
     * Configures this builder to add a controller which maintains a list of bindings from source to target
     * subscribables.
     * @param key The key of the controller.
     * @param bindings The bindings to maintain.
     * @param onDestroy A function to execute when the controller is destroyed.
     * @returns This builder, after it has been configured.
     */
    withBindings(key, bindings, onDestroy) {
      return this.withController(key, (context) => new MapBindingsController(context, bindings(context), onDestroy));
    }
    /**
     * Configures this builder to generate a map which is updated at a regular frequency based on event bus clock events.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'updateFreq': Subscribable<number>`
     *
     * Controllers:
     * * `[MapSystemKeys.ClockUpdate]: MapClockUpdateController`.
     * @param updateFreq The map's update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withClockUpdate(updateFreq) {
      return this.withContext("updateFreq", () => typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq).withController(MapSystemKeys.ClockUpdate, (context) => new MapClockUpdateController(context));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's projection target.
     *
     * Adds the context property `[MapSystemKeys.TargetControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withTargetControlModerator() {
      return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(void 0));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's rotation.
     *
     * Adds the context property `[MapSystemKeys.RotationControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRotationControlModerator() {
      return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(void 0));
    }
    /**
     * Configures this builder to add a resource moderator for control of the map's range.
     *
     * Adds the context property `[MapSystemKeys.RangeControl]: ResourceModerator<void>`.
     * @returns This builder, after the resource moderator has been added.
     */
    withRangeControlModerator() {
      return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(void 0));
    }
    /**
     * Configures this builder to generate a map whose projection target follows the player airplane. The follow airplane
     * behavior will be active if and only if the controller owns the projection target control resource. The
     * controller's priority for the resource is `0`.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TargetControl]: ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneModule`
     *
     * Controllers:
     * * `[MapSystemKeys.FollowAirplane]: MapFollowAirplaneController`
     * @returns This builder, after it has been configured.
     */
    withFollowAirplane() {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule()).withTargetControlModerator().withController(MapSystemKeys.FollowAirplane, (context) => new MapFollowAirplaneController(context));
    }
    /**
     * Configures this builder to generate a map which supports common rotation behavior. The rotation behavior will be
     * active if and only if the controller owns the rotation control resource. The controller's priority for the
     * resource is `0`.
     *
     * Requires the module `'ownAirplaneProps': MapOwnAirplanePropsModule` to support player airplane-derived rotation
     * behavior, such as Heading Up and Track Up.
     *
     * Adds the following...
     *
     * Context properties:
     * * `'[MapSystemKeys.RotationControl]': ResourceModerator<void>`
     *
     * Modules:
     * * `[MapSystemKeys.Rotation]: MapRotationModule`
     *
     * Controllers:
     * * `[MapSystemKeys.Rotation]: MapRotationController`
     * @returns This builder, after it has been configured.
     */
    withRotation() {
      return this.withModule(MapSystemKeys.Rotation, () => new MapRotationModule()).withRotationControlModerator().withController(MapSystemKeys.Rotation, (context) => new MapRotationController(context));
    }
    /**
     * Configures this builder to generate a map which displays an icon depicting the position of the player airplane.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule`
     *
     * Layers:
     * * `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneLayer`
     * @param iconSize The size of the icon, in pixels.
     * @param iconFilePath The path to the icon's image asset, or a subscribable which provides it.
     * @param iconAnchor The point on the icon that is anchored to the airplane's position, or a subscribable which
     * provides it. The point is expressed as a 2-tuple relative to the icon's width and height, with `[0, 0]` at the
     * top left and `[1, 1]` at the bottom right.
     * @param cssClass The CSS class(es) to apply to the root of the airplane icon layer.
     * @param order The order assigned to the icon layer. Layers with lower assigned order will be attached to the map
     * before and appear below layers with greater assigned order values. Defaults to the number of layers already added
     * to this builder.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule()).withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
        return FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: iconFilePath, iconSize, iconAnchor, class: cssClass });
      }, order);
    }
    /**
     * Configures this builder to add a controller which controls and optimizes the orientation of the own airplane icon
     * in response to a desired orientation and the map rotation type. If the desired orientation matches the map
     * rotation (e.g. both Heading Up), the icon orientation is set to Map Up; otherwise the orientation is set to the
     * desired orientation.
     *
     * Requires the modules `[MapSystemKeys.OwnAirplaneIcon]: MapOwnAirplaneIconModule` and
     * `[MapSystemKeys.Rotation]: MapRotationModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneIconOrientation]: MapOwnAirplaneIconOrientationController`.
     * @param desiredOrientation The desired orientation of the own airplane icon.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplaneIconOrientation(desiredOrientation) {
      return this.withController(MapSystemKeys.OwnAirplaneIconOrientation, (context) => new MapOwnAirplaneIconOrientationController(context, desiredOrientation));
    }
    /**
     * Configures this builder to bind properties in an added {@link MapOwnAirplanePropsModule} to data derived from
     * event bus events.
     *
     * Requires the module `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`.
     *
     * Adds the controller `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsController`.
     * @param properties The properties to bind.
     * @param updateFreq The update frequency, in hertz, or a subscribable which provides it.
     * @returns This builder, after it has been configured.
     */
    withOwnAirplanePropBindings(properties, updateFreq) {
      return this.withController(MapSystemKeys.OwnAirplaneProps, (context) => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
    }
    /**
     * Configures this builder to add a module describing the player airplane's autopilot properties, and optionally
     * binds the module's properties to data received over the event bus.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsModule`
     *
     * Controllers:
     * * `[MapSystemKeys.AutopilotProps]: MapAutopilotPropsController` (optional)
     * @param propertiesToBind Properties on the autopilot module to bind to data received over the event bus.
     * @param updateFreq The update frequency, in hertz, of the data bindings, or a subscribable which provides it. If
     * not defined, the data bindings will update every frame. Ignored if `propertiesToBind` is undefined.
     * @returns This builder, after it has been configured.
     */
    withAutopilotProps(propertiesToBind, updateFreq) {
      this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
      if (propertiesToBind !== void 0) {
        this.withController(MapSystemKeys.AutopilotProps, (context) => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
      }
      return this;
    }
    /**
     * Configures this builder to generate a map which includes a layer displaying text.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     *
     * Layers:
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param enableCulling Whether to enable text culling. Defaults to `false`.
     * @param order The order value to assign to the text layer. Layers with lower assigned order will be attached to
     * the map before and appear below layers with greater assigned order values. Defaults to the number of layers
     * already added to this builder.
     * @param cssClass The CSS class(es) to apply to the text layer.
     * @returns This builder, after it has been configured.
     */
    withTextLayer(enableCulling, order, cssClass) {
      return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling)).withLayer(MapSystemKeys.TextLayer, (context) => {
        return FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager, class: cssClass });
      }, order);
    }
    /**
     * Configures this builder to generate a map which displays Bing Map terrain and weather.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.TerrainColors]: MapTerrainColorsModule`
     * * `[MapSystemKeys.Weather]: MapWxrModule`
     *
     * Layers:
     * * `[MapSystemKeys.Bing]: MapBingLayer`
     * @param bingId The ID to assign to the Bing Map instance bound to the layer.
     * @param delay The delay, in milliseconds, to wait after the Bing layer has been rendered before attempting to bind
     * a Bing Map instance.
     * @param mode The mode of the map, optional. If omitted, will be EBingMode.PLANE.
     * @param order The order value to assign to the Bing layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to the map builder.
     * @param cssClass The CSS class(es) to apply to the root of the map bing layer.
     * @returns This builder, after it has been configured.
     */
    withBing(bingId, delay = 0, mode, order, cssClass) {
      return this.withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule()).withModule(MapSystemKeys.Weather, () => new MapWxrModule()).withLayer(MapSystemKeys.Bing, (context) => {
        const terrainColors = context.model.getModule("terrainColors");
        const weather = context.model.getModule("weather");
        return FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, earthColorsElevationRange: terrainColors.colorsElevationRange, isoLines: terrainColors.showIsoLines, wxrMode: weather.wxrMode, wxrColors: weather.weatherRadarColors, mode, delay, class: cssClass });
      }, order);
    }
    /**
     * Configures this builder to generate a map which uses a {@link MapSystemWaypointsRenderer} to render waypoints.
     *
     * Requires the `[MapSystemKeys.TextManager]: MapCullableTextLabelManager` context property.
     *
     * Adds the `[MapSystemKeys.WaypointRenderer]: MapSystemWaypointsRenderer` context property.
     * @returns This builder, after it has been configured.
     */
    withWaypoints() {
      return this.withContext(MapSystemKeys.WaypointRenderer, (context) => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager])).withController("waypointRendererUpdate", (context) => new MapSystemGenericController(context, {
        onAfterUpdated: (contextArg) => {
          contextArg[MapSystemKeys.WaypointRenderer].update(context.projection);
        }
      }));
    }
    /**
     * Configures this builder to generate a map which displays waypoints near the map center or target. Waypoints
     * displayed in this manner are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     *
     * Modules:
     * * `[MapSystemKeys.NearestWaypoints]: MapWaypointDisplayModule`
     *
     * Layers:
     * * `[MapSystemKeys.NearestWaypoints]: MapSystemWaypointsLayer`
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     * @param configure A function to configure the waypoint display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the waypoint layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the nearest waypoints layer.
     * @returns This builder, after it has been configured.
     */
    withNearestWaypoints(configure, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling).withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule()).withWaypoints().withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory());
      let facilityWaypointCache = void 0;
      this.withContext("useTargetAsWaypointSearchCenter", (context) => {
        context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, void 0, MapSystemWaypointRoles.Normal);
        const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
        configure(builder);
        facilityWaypointCache = builder.getWaypointCache();
        return builder.getIsCenterTarget();
      });
      const layerCount = this.layerCount;
      return this.withLayer(MapSystemKeys.NearestWaypoints, (context) => {
        return FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter, waypointCache: facilityWaypointCache, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays a flight plan. Waypoints displayed as part of the flight
     * plan are rendered by a {@link MapSystemWaypointsRenderer}.
     *
     * If a text layer has already been added to the builder, its order will be changed so that it is rendered above the
     * waypoint layer. Otherwise, a text layer will be added to the builder after the waypoint layer.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.FlightPlanner]: FlightPlanner`
     * * `[MapSystemKeys.TextManager]: MapCullableTextLabelManager`
     * * `[MapSystemKeys.IconFactory]: MapSystemIconFactory`
     * * `[MapSystemKeys.LabelFactory]: MapSystemLabelFactory`
     * * `[MapSystemKeys.FlightPathRenderer]: MapSystemPlanRenderer`
     *
     * Modules:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanModule`
     *
     * Layers:
     * * `` `${[MapSystemKeys.FlightPlan]}${planIndex}`: MapSystemFlightPlanLayer ``
     * * `[MapSystemKeys.TextLayer]: MapCullableTextLayer`
     *
     * Controllers:
     * * `[MapSystemKeys.FlightPlan]: MapFlightPlanController`
     * @param configure A function to configure the waypoint display.
     * @param flightPlanner The flight planner.
     * @param planIndex The index of the flight plan to display.
     * @param enableTextCulling Whether to enable text culling on the text manager.
     * @param order The order to assign to the plan layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the flight plan canvas elements.
     * @returns This builder, after it has been configured.
     */
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling, void 0, "flight-plan-text-layer").withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule()).withWaypoints().withContext(MapSystemKeys.FlightPlanner, () => flightPlanner).withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory()).withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1)).withController(MapSystemKeys.FlightPlan, (context) => new MapFlightPlanController(context)).withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
        context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, void 0, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
        configure(builder);
      });
      const layerCount = this.layerCount;
      return this.withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        return FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    /**
     * Configures this builder to generate a map which displays airspaces.
     *
     * Adds the following...
     *
     * Context properties:
     * * `[MapSystemKeys.AirspaceManager]: GenericAirspaceRenderManager`
     *
     * Modules:
     * * `[MapSystemKeys.Airspace]: MapAirspaceModule`
     *
     * Layers:
     * * `[MapSystemKeys.Airspace]: MapAirspaceLayer`
     * @param cache The airspace cache to use to store airspaces retrieved for rendering.
     * @param showTypes The airspace show types to define in the airspace module. Each show type will be assigned a
     * {@link Subject} in the `show` property of the module. The Subject controls the visibility of airspace types
     * included in its show type. Airspace types that are not included in any defined show type will never be displayed.
     * @param selectRenderer A function which selects a {@link MapAirspaceRenderer}
     * @param renderOrder A function which determines the rendering order of airspaces. The function should return a
     * negative number when airspace `a` should be rendered before (below) airspace `b`, a positive number when airspace
     * `a` should be rendered after (above) airspace `b`, and `0` when the relative render order of the two airspaces
     * does not matter. If not defined, there will be no guarantee on the order in which airspaces are rendered.
     * @param options Options for the airspace layer. Option defaults are as follows:
     * * `maxSearchRadius`: 10 nautical miles
     * * `maxSearchItemCount`: 100
     * * `searchDebounceDelay`: 500 (milliseconds)
     * * `renderTimeBudget`: 0.2 (milliseconds)
     * @param order The order to assign to the airspace layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @returns This builder, after it has been configured.
     */
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
      return this.withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes)).withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer)).withLayer(MapSystemKeys.Airspace, (context) => {
        var _a, _b;
        const optionsToUse = Object.assign({}, options);
        (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10));
        (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : optionsToUse.maxSearchItemCount = Subject.create(100);
        return FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse));
      }, order);
    }
    /**
     * Configures this builder to generate a map which displays TCAS intruders.
     *
     * Adds the following...
     *
     * Modules:
     * * `[MapSystemKeys.OwnAirplaneProps]: MapOwnAirplanePropsModule`
     * * `[MapSystemKeys.Traffic]: MapTrafficModule`
     *
     * Layers:
     * * `[MapSystemKeys.Traffic]: MapSystemTrafficLayer`
     * @param tcas The TCAS used by the traffic display.
     * @param iconFactory A function which creates intruder icons for the traffic display.
     * @param initCanvasStyles A function which initializes global canvas styles for the traffic display.
     * @param offScaleOobOptions A function which generates options for handling off-scale and out-of-bounds intruders.
     * @param order The order to assign to the traffic layer. Layers with lower assigned order will be attached to the
     * map before and appear below layers with greater assigned order values. Defaults to the number of layers already
     * added to this builder.
     * @param cssClass The CSS class(es) to apply to the root of the traffic component.
     * @returns This builder, after it has been configured.
     */
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order, cssClass) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas)).withLayer("traffic", (context) => {
        const options = offScaleOobOptions !== void 0 ? Object.assign({}, offScaleOobOptions(context)) : {};
        if (options.oobOffset !== void 0 && !("isSubscribable" in options.oobOffset)) {
          options.oobOffset = Subject.create(options.oobOffset);
        }
        return FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context, model: context.model, mapProjection: context.projection, iconFactory, initCanvasStyles, class: cssClass }, options));
      }, order);
    }
    /**
     * Configures this builder using a custom build step.
     * @param builder A function which defines a custom build step.
     * @param args Arguments to pass to the custom build function.
     * @returns This builder, after it has been configured.
     */
    with(builder, ...args) {
      return builder(this, ...args);
    }
    /**
     * Compiles a map. The compiled map consists of a map context, a rendered map (as a VNode), and a node reference to
     * the rendered map component.
     *
     * The compiled map will be bound to a model (accessible through the map context) which contains all the modules
     * added to this builder.
     *
     * The map will also contain all layers added to this builder, with layers assigned lower order values appearing
     * below layers assigned greater order values. The layers can be retrieved by their keys from the map context.
     *
     * All controllers added to this builder will be created with the map and hooked up to the map's lifecycle callbacks.
     * The controllers can be retrieved by their keys from the map context.
     * @param cssClass The CSS class(es) to apply to the root of the rendered map component.
     * @returns A compiled map.
     */
    build(cssClass) {
      const context = this.buildContext();
      const controllers = [];
      const ref = FSComponent.createRef();
      const onAfterRender = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterMapRender(ref.instance);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDeadZoneChanged = (deadZone) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onDeadZoneChanged(deadZone);
          } catch (e) {
            console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onMapProjectionChanged = (mapProjection, changeFlags) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onBeforeUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onBeforeUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
        context.projection.applyQueued();
      };
      const onAfterUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onWake = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onWake();
          } catch (e) {
            console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onSleep = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onSleep();
          } catch (e) {
            console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDestroy = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapDestroyed();
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const map = FSComponent.buildComponent(MapSystemComponent, { ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender, onDeadZoneChanged, onMapProjectionChanged, onBeforeUpdated, onAfterUpdated, onWake, onSleep, onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map((factory) => {
        const node = factory.factory(context);
        context.setLayer(factory.key, node.instance);
        return node;
      }));
      const controllerEntries = Array.from(this.controllerFactories).map(([key, factory]) => [key, factory.factory(context)]);
      for (const [key, controller] of controllerEntries) {
        context.setController(key, controller);
      }
      controllers.push(...controllerEntries.map(([, controller]) => controller));
      for (const callback of this.initCallbacks.values()) {
        callback(context);
      }
      return { context, map, ref };
    }
    /**
     * Builds a new map context. The map context will be initialized with all context properties and modules added to
     * this builder.
     * @returns The new map context.
     */
    buildContext() {
      var _a;
      const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
      context.projection.set({
        targetProjectedOffset: this.targetOffset,
        rangeEndpoints: this.nominalRangeEndpoints !== void 0 ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create()) : void 0,
        range: this.range
      });
      for (const factory of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
        context[factory.key] = factory.factory(context);
      }
      for (const factory of this.moduleFactories.values()) {
        context.model.addModule(factory.key, factory.factory());
      }
      return context;
    }
  };
  MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = /* @__PURE__ */ new Set([
    "bus",
    "model",
    "projection",
    "projectedSize",
    "deadZone",
    "getLayer",
    "setLayer",
    "getController",
    "setController"
  ]);
  var SynVisComponent = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.bingRef = FSComponent.createRef();
      this.onBingBound = () => {
      };
    }
    /**
     * Renders the syn vis component.
     * @returns A component VNode.
     */
    render() {
      return FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, mode: EBingMode.HORIZON, onBoundCallback: this.onBingBound, resolution: this.props.resolution, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, skyColor: this.props.skyColor, delay: this.props.bingDelay, class: this.props.class });
    }
  };
  var WarningType;
  (function(WarningType2) {
    WarningType2[WarningType2["Warning"] = 0] = "Warning";
    WarningType2[WarningType2["Caution"] = 1] = "Caution";
    WarningType2[WarningType2["Test"] = 2] = "Test";
    WarningType2[WarningType2["SoundOnly"] = 3] = "SoundOnly";
  })(WarningType || (WarningType = {}));
  var Warning = class {
    /**
     * Creates an instance of a Warning.
     * @param type The type of warning this is.
     * @param condition An XML logic element with the trigger logic.
     * @param shortText The warning message in short form.
     * @param longText The warning message in long form.
     * @param soundId The sound name to use with this warning.
     * @param once True if this warning only fires once
     */
    constructor(type, condition, shortText, longText, soundId, once) {
      this.type = type;
      this.shortText = shortText;
      this.longText = longText;
      this.soundId = soundId;
      this.condition = condition;
      this.once = once;
      this._triggered = false;
      if (this.soundId) {
        this._soundEventId = new Name_Z(this.soundId);
      }
    }
    /**
     * Whether or not we have any text at all.
     * @returns True if any non-empty text strings are set.
     */
    get hasText() {
      return this.shortText || this.longText ? true : false;
    }
    /**
     * The alert is being fired, take action.
     */
    trigger() {
      this._triggered = true;
    }
    /**
     * A text description for the warning, for debugging purposes.
     * @returns A string
     */
    get description() {
      return `<${this.shortText}|${this.longText}|${this.soundId}>`;
    }
    /**
     * Whether or not the warning has been triggered in this session.
     * @returns True if the warning has been triggered.
     */
    get triggered() {
      return this._triggered;
    }
    /**
     * Can this alert fire?
     * @returns True if the current configuration allows the alert to fire.
     */
    get canTrigger() {
      return !this.once || !this._triggered;
    }
    /**
     * The event ID Coherent returns when this sound has been played.
     * @returns A Name_Z based on the sound ID.
     */
    get eventId() {
      return this._soundEventId;
    }
  };
  var WarningManager = class {
    /**
     * Create a WarningManager.
     * @param warnings An array of warnings to manage.
     * @param logicHost An event bus.
     * @param textCb A callback to display new warning text.
     * @param soundCb A callback to play an instrument sound from a sound ID.
     */
    constructor(warnings, logicHost, textCb, soundCb) {
      this.warnings = warnings;
      this.logicHost = logicHost;
      this.textCb = textCb;
      this.soundCb = soundCb;
      this.curSndIdx = null;
      this.curTxtIdx = null;
      this.warnActiveStates = new Array();
      for (let i = 0; i < warnings.length; i++) {
        this.logicHost.addLogicAsNumber(warnings[i].condition, this.handleWarning.bind(this, i), 0);
        this.warnActiveStates.push(false);
      }
    }
    /**
     * Handle a warning firing.  This is rather complex, but it basically keeps
     * track of every warning that is active, both for text and for sound, and
     * makes sure that the highest priority version of each is played or
     * displayed, masking and restoring lower priority warnings as needed.
     * @param warnIndex The index of our warnings array that's firing.
     * @param active 1 if the warning is active, 0 otherwise.
     */
    handleWarning(warnIndex, active) {
      const warning = this.warnings[warnIndex];
      if (active && warning.canTrigger) {
        this.warnActiveStates[warnIndex] = true;
        warning.trigger();
        if (warning.hasText) {
          if (this.curTxtIdx == void 0 || this.curTxtIdx > warnIndex) {
            if (this.curTxtIdx && this.warnings[this.curTxtIdx].once) {
              this.warnActiveStates[this.curTxtIdx] = false;
            }
            this.textCb(warning);
            this.curTxtIdx = warnIndex;
          }
        }
        if (this.soundCb !== void 0 && warning.soundId) {
          if (this.curSndIdx == void 0 || this.curSndIdx > warnIndex) {
            if (this.curSndIdx && this.curSndIdx > warnIndex) {
              this.soundCb(this.warnings[this.curSndIdx], false);
              if (this.warnings[this.curSndIdx].once) {
                this.warnActiveStates[this.curSndIdx] = false;
              }
            }
            this.soundCb(warning, true);
            this.curSndIdx = warnIndex;
          }
        }
        if (warning.once) {
          this.handleWarning(warnIndex, 0);
        }
      } else if (!active) {
        this.warnActiveStates[warnIndex] = false;
        let isCurSnd = this.curSndIdx == warnIndex ? true : false;
        let isCurTxt = this.curTxtIdx == warnIndex ? true : false;
        if (isCurSnd && this.soundCb) {
          this.soundCb(warning, false);
        }
        if (isCurTxt) {
          this.textCb(void 0);
        }
        if (isCurSnd || isCurTxt) {
          let i = warnIndex + 1;
          while ((isCurSnd || isCurTxt) && i < this.warnings.length) {
            if (this.warnActiveStates[i]) {
              const nextWarning = this.warnings[i];
              if (nextWarning.canTrigger) {
                if (isCurSnd && nextWarning.soundId && this.soundCb) {
                  this.soundCb(this.warnings[i], true);
                  this.curSndIdx = i;
                  isCurSnd = false;
                }
                if (isCurTxt && this.warnings[i].hasText) {
                  this.textCb(this.warnings[i]);
                  this.curTxtIdx = i;
                  isCurTxt = false;
                }
              }
            }
            i++;
          }
        }
        if (isCurSnd && this.soundCb) {
          this.curSndIdx = null;
        }
        if (isCurTxt) {
          this.curTxtIdx = null;
        }
      }
    }
  };
  var XMLWarningFactory = class {
    /**
     * Create an XMLWarningFactory.
     * @param instrument The instrument that the warnings run in.
     */
    constructor(instrument) {
      this.instrument = instrument;
    }
    /**
     * Parse a panel.xml configuration to create a list of warnings.  The warning
     * priority is defined by their order in panel.xml, with higher priority
     * warnings coming sooner in the file.
     * @param document The configuration as an XML document.
     * @returns An array of Warnings
     */
    parseConfig(document2) {
      const warnings = new Array();
      const configs = document2.getElementsByTagName("VoicesAlerts");
      if (configs.length == 0) {
        return warnings;
      }
      const config = configs[0];
      for (const warn of config.children) {
        let type;
        const typeElem = warn.getElementsByTagName("Type");
        if (typeElem.length == 0) {
          continue;
        }
        switch (typeElem[0].textContent) {
          case "Warning":
            type = WarningType.Warning;
            break;
          case "Caution":
            type = WarningType.Caution;
            break;
          case "Test":
            type = WarningType.Test;
            break;
          case "SoundOnly":
            type = WarningType.SoundOnly;
            break;
          default:
            continue;
        }
        let textElem = warn.getElementsByTagName("Condition");
        if (textElem.length == 0) {
          continue;
        }
        const condition = new CompositeLogicXMLElement(this.instrument, textElem[0]);
        textElem = warn.getElementsByTagName("ShortText");
        let shortText = void 0;
        if (textElem.length > 0 && textElem[0].textContent !== null) {
          shortText = textElem[0].textContent;
        }
        textElem = warn.getElementsByTagName("LongText");
        let longText = void 0;
        if (textElem.length > 0 && textElem[0].textContent !== null) {
          longText = textElem[0].textContent;
        }
        textElem = warn.getElementsByTagName("SoundEvent");
        let soundEvent = void 0;
        if (textElem.length > 0 && textElem[0].textContent !== null) {
          soundEvent = textElem[0].textContent;
        }
        textElem = warn.getElementsByTagName("Once");
        let once = false;
        if (textElem.length > 0 && textElem[0].textContent == "True") {
          once = true;
        }
        warnings.push(new Warning(type, condition, shortText, longText, soundEvent, once));
      }
      return warnings;
    }
  };
  var XMLCircularGaugeCursor;
  (function(XMLCircularGaugeCursor2) {
    XMLCircularGaugeCursor2[XMLCircularGaugeCursor2["Triangle"] = 1] = "Triangle";
  })(XMLCircularGaugeCursor || (XMLCircularGaugeCursor = {}));
  var XMLCircularGaugeValuePos;
  (function(XMLCircularGaugeValuePos2) {
    XMLCircularGaugeValuePos2[XMLCircularGaugeValuePos2["End"] = 1] = "End";
  })(XMLCircularGaugeValuePos || (XMLCircularGaugeValuePos = {}));
  var XMLHorizontalGaugeValuePos;
  (function(XMLHorizontalGaugeValuePos2) {
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["End"] = 1] = "End";
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLHorizontalGaugeValuePos || (XMLHorizontalGaugeValuePos = {}));
  var XMLVerticalGaugeValuePos;
  (function(XMLVerticalGaugeValuePos2) {
    XMLVerticalGaugeValuePos2[XMLVerticalGaugeValuePos2["None"] = 1] = "None";
  })(XMLVerticalGaugeValuePos || (XMLVerticalGaugeValuePos = {}));
  var XMLDoubleHorizontalGaugeValuePos;
  (function(XMLDoubleHorizontalGaugeValuePos2) {
    XMLDoubleHorizontalGaugeValuePos2[XMLDoubleHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLDoubleHorizontalGaugeValuePos || (XMLDoubleHorizontalGaugeValuePos = {}));
  var XMLGaugeType;
  (function(XMLGaugeType2) {
    XMLGaugeType2["Circular"] = "Circular";
    XMLGaugeType2["Horizontal"] = "Horizontal";
    XMLGaugeType2["DoubleHorizontal"] = "DoubleHorizontal";
    XMLGaugeType2["Vertical"] = "Vertical";
    XMLGaugeType2["DoubleVertical"] = "DoubleVertical";
    XMLGaugeType2["Text"] = "Text";
    XMLGaugeType2["ColumnGroup"] = "ColumnGroup";
    XMLGaugeType2["Column"] = "Column";
    XMLGaugeType2["Cylinder"] = "Cylinder";
    XMLGaugeType2["TwinCylinder"] = "TwinCylinder";
  })(XMLGaugeType || (XMLGaugeType = {}));
  var XMLGaugeConfigFactory = class {
    /**
     * Create an XMLGaugeConfigFactory.
     * @param instrument The instrument that holds this engine display.
     * @param bus An event bus for gauges that need it.
     */
    constructor(instrument, bus) {
      this.instrument = instrument;
      this.bus = bus;
    }
    /**
     * Convenience method to take a full XML instrument config and parse out the display config
     * section. This will check first to see if we are using an enhanced, multi-page config by
     * looking for an EnginePage tag in the EngineDisplay element.   If it finds it, it will
     * assume we have an advanced config, and return the content along with that of LeanPage
     * and SystemPag, if present.  If no EnginePage exists, we assume we're dealing with a
     * legacy configuration and just return the content of EngineDisplay itself as our engine
     * page with everything else undefined.
     * @param document The XML configuation document.
     * @returns An XMLEnhancedGaugeConfig with the full gauge configuration.
     */
    parseConfig(document2) {
      var _a;
      const gaugeSpecs = new Array();
      const functions = /* @__PURE__ */ new Map();
      const displayConfig = document2.getElementsByTagName("EngineDisplay");
      if (displayConfig.length == 0) {
        return { override: false, functions, enginePage: gaugeSpecs };
      } else {
        for (const func of document2.getElementsByTagName("Function")) {
          const funcSpec = this.makeFunction(func);
          if (funcSpec !== void 0) {
            functions.set(funcSpec.name, funcSpec);
          }
        }
        const override = ((_a = displayConfig[0].getAttribute("override")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "true";
        const enginePages = displayConfig[0].getElementsByTagName("EnginePage");
        if (enginePages.length == 0) {
          return { override, functions, enginePage: this._parseConfig(displayConfig[0]) };
        }
        const leanPages = displayConfig[0].getElementsByTagName("LeanPage");
        const systemPages = displayConfig[0].getElementsByTagName("SystemPage");
        return {
          override,
          functions,
          enginePage: this._parseConfig(enginePages[0]),
          leanPage: leanPages.length > 0 ? this._parseConfig(leanPages[0]) : void 0,
          systemPage: systemPages.length > 0 ? this._parseConfig(systemPages[0]) : void 0
        };
      }
    }
    /**
     * Parse an engine display setup.
     * @param config An instrument XML config document.
     * @returns An array of the gauges defined in the configuration.
     */
    _parseConfig(config) {
      var _a;
      const gaugeSpecs = new Array();
      if (config.children.length == 0) {
        return gaugeSpecs;
      }
      for (const gauge of config.children) {
        switch (gauge.tagName) {
          case "Gauge":
            switch ((_a = gauge.getElementsByTagName("Type")[0]) === null || _a === void 0 ? void 0 : _a.textContent) {
              case "Circular":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.Circular,
                  configuration: this.createCircularGauge(gauge)
                });
                break;
              case "Horizontal":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.Horizontal,
                  configuration: this.createHorizontalGauge(gauge)
                });
                break;
              case "DoubleHorizontal":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.DoubleHorizontal,
                  configuration: this.createDoubleHorizontalGauge(gauge)
                });
                break;
              case "Vertical":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.Vertical,
                  configuration: this.createVerticalGauge(gauge)
                });
                break;
              case "DoubleVertical":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.DoubleVertical,
                  configuration: this.createDoubleVerticalGauge(gauge)
                });
                break;
              case "Cylinder":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.Cylinder,
                  configuration: this.createCylinderGauge(gauge)
                });
                break;
              case "TwinCylinder":
                gaugeSpecs.push({
                  gaugeType: XMLGaugeType.TwinCylinder,
                  configuration: this.createCylinderGauge(gauge)
                });
                break;
            }
            break;
          case "Text":
            {
              const textProps = {};
              const className = gauge.getAttribute("id");
              if (className !== null) {
                textProps.class = className;
              }
              const leftElem = gauge.getElementsByTagName("Left");
              if (leftElem.length > 0) {
                textProps.left = this.makeTextColumn(leftElem[0]);
              }
              const centerElem = gauge.getElementsByTagName("Center");
              if (centerElem.length > 0) {
                textProps.center = this.makeTextColumn(centerElem[0]);
              }
              const rightElem = gauge.getElementsByTagName("Right");
              if (rightElem.length > 0) {
                textProps.right = this.makeTextColumn(rightElem[0]);
              }
              const style = XMLGaugeConfigFactory.parseStyleDefinition(gauge.getElementsByTagName("Style"));
              if (style !== void 0) {
                textProps.style = style;
              }
              gaugeSpecs.push({
                gaugeType: XMLGaugeType.Text,
                configuration: textProps
              });
            }
            break;
          case "ColumnGroup":
            gaugeSpecs.push({
              gaugeType: XMLGaugeType.ColumnGroup,
              configuration: this.createColumnGroup(gauge)
            });
            break;
          case "Column":
            gaugeSpecs.push({
              gaugeType: XMLGaugeType.Column,
              configuration: this.createColumn(gauge)
            });
            break;
        }
      }
      return gaugeSpecs;
    }
    /**
     * Construct a single column of text for a text element.  This can be any
     * one of Left, Right, or Center.
     * @param columnDef The XML definition for the given column.
     * @returns an XMLTextColumn configuration.
     */
    makeTextColumn(columnDef) {
      const contentElem = columnDef.getElementsByTagName("Content");
      const config = {
        content: new CompositeLogicXMLElement(this.instrument, contentElem.length > 0 ? contentElem[0] : columnDef)
      };
      const colorElem = columnDef.getElementsByTagName("Color");
      if (colorElem.length > 0) {
        config.color = new CompositeLogicXMLElement(this.instrument, colorElem[0]);
      }
      const className = columnDef.getAttribute("id");
      if (className !== null) {
        config.class = className;
      }
      const fontSize = columnDef.getAttribute("fontsize");
      if (fontSize !== null) {
        config.fontSize = fontSize;
      }
      return config;
    }
    /**
     * Make a function.
     * @param functionDef The XML definition for the function.
     * @returns an XMLFunction type or undefined if there's an error
     */
    makeFunction(functionDef) {
      const name = functionDef.getAttribute("Name");
      if (!name || functionDef.children.length == 0) {
        return void 0;
      }
      return {
        name,
        logic: new CompositeLogicXMLElement(this.instrument, functionDef)
      };
    }
    /**
     * Create a base XMLGaugeProps definition.  This will be combined with the
     * props for a speciific gauge type to fully define the config interface.
     * @param gauge The gauge definition
     * @returns A set of XMLGaugeProps
     */
    parseGaugeDefinition(gauge) {
      var _a;
      const props = {};
      const assign = (prop, tag, converter = (v) => {
        return v;
      }) => {
        XMLGaugeConfigFactory.getAndAssign(props, gauge, prop, tag, converter);
      };
      const colorZones = this.makeColorZones(gauge.getElementsByTagName("ColorZone"));
      if (colorZones !== void 0) {
        props.colorZones = colorZones;
      }
      const colorLines = this.makeColorLines(gauge.getElementsByTagName("ColorLine"));
      if (colorLines !== void 0) {
        props.colorLines = colorLines;
      }
      const referenceBugs = this.makeReferenceBugs(gauge.getElementsByTagName("ReferenceBug"));
      if (referenceBugs !== void 0) {
        props.referenceBugs = referenceBugs;
      }
      const createLogicElement = (el) => {
        if (el !== void 0) {
          return new CompositeLogicXMLElement(this.instrument, el);
        }
        return void 0;
      };
      props.minimum = createLogicElement(gauge.getElementsByTagName("Minimum")[0]);
      props.maximum = createLogicElement(gauge.getElementsByTagName("Maximum")[0]);
      props.value1 = createLogicElement(gauge.getElementsByTagName("Value")[0]);
      props.value2 = createLogicElement(gauge.getElementsByTagName("Value2")[0]);
      assign("title", "Title", (v) => {
        return v ? v : "";
      });
      assign("unit", "Unit", (v) => {
        return v ? v : "";
      });
      assign("graduationLength", "GraduationLength", parseFloat);
      props.graduationHasText = ((_a = gauge.getElementsByTagName("GraduationLength")[0]) === null || _a === void 0 ? void 0 : _a.getAttribute("text")) == "True";
      assign("beginText", "BeginText");
      assign("endText", "EndText");
      assign("cursorText1", "CursorText", (v) => {
        return v ? v : "";
      });
      assign("cursorText2", "CursorText2", (v) => {
        return v ? v : "";
      });
      assign("id", "ID");
      props.redBlink = createLogicElement(gauge.getElementsByTagName("RedBlink")[0]);
      return props;
    }
    // The logic for creating these gauges is a little intricate and repeats a number of times.
    // To avoid having redundant comments, here's the general plan for what's happening.
    //
    // First, we create an instance of the gauge's style interface in several steps. These
    // take advantage of the fact that almost all of the props on on the interfaces are optional
    // to allow us to compose the gauge-specific interface in pieces.
    //
    // 1) The gauge-specific create function passes the Style element to the generic
    //    parseStyleDefinition function, which returns an interface that has all of the
    //    universal style properties.
    // 2) The function then creates its own gauge-specific style interface using parsing logic
    //    unique to the gauge.
    // 3) The values of the generic interface are then assigned to the object-specific one so
    //    that we have one interface with all the styling information needed.
    //
    // Next, we repeat the same process with the rest of the gauge definitions.   At this point,
    // the primary way in which the shapes of the interfaces differ is in what their style
    // definitions look like, so the second phase is just another assignment compositing the
    // custom-derived style and the remainder of the generic definiton as retrieved from the
    // parseGaugeDefinition method.
    //
    // We play a bit fast and loose with properties here and don't really do any confirmation
    // that the gauge definitions we get are valid.  The user could, for example, provide a
    // <Value2> property to a gauge that only has one value and that would be populated in the
    // configuration.   It would be harmless, because it would be ignored by the gauge code,
    // but it's still kind of gross.
    //
    // This models how the standard XMLEngineDisplay.js works.  In the future we might want to
    // tighten this up with better type checking and error throwing, in which case we can expand
    // these functions to use a bit more logic in this second phase when they're composing
    // the final configuration instance.
    //
    // Ok, on with the show.
    /**
     * Create a circular gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createCircularGauge(gaugeDef) {
      const styleElem = gaugeDef.getElementsByTagName("Style");
      const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
      let style = {};
      const innerElem = styleElem[0];
      if (innerElem !== void 0) {
        const assign = (prop, tag, converter = (v) => {
          return v;
        }) => {
          XMLGaugeConfigFactory.getAndAssign(style, innerElem, prop, tag, converter);
        };
        assign("forceTextColor", "ForceTextColor");
        assign("textIncrement", "TextIncrement", parseFloat);
        assign("beginAngle", "BeginAngle", parseFloat);
        assign("endAngle", "EndAngle", parseFloat);
        assign("cursorType", "CursorType", (v) => {
          return v == "Triangle" ? XMLCircularGaugeCursor.Triangle : void 0;
        });
        assign("valuePos", "ValuePos", (v) => {
          return v == "End" ? XMLCircularGaugeValuePos.End : void 0;
        });
        assign("valuePrecision", "ValuePrecision", parseInt);
      }
      style = Object.assign(style, genericStyle);
      return Object.assign({ style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createHorizontalGauge(gaugeDef) {
      const styleElem = gaugeDef.getElementsByTagName("Style");
      const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
      let style = {};
      const innerElem = styleElem[0];
      if (innerElem !== void 0) {
        const assign = (prop, tag, converter = (v) => {
          return v;
        }) => {
          XMLGaugeConfigFactory.getAndAssign(style, innerElem, prop, tag, converter);
        };
        assign("valuePos", "ValuePos", (v) => {
          switch (v) {
            case "Right":
              return XMLHorizontalGaugeValuePos.Right;
            case "End":
              return XMLHorizontalGaugeValuePos.End;
            default:
              return void 0;
          }
        });
        assign("textIncrement", "TextIncrement", parseFloat);
        assign("cursorColor", "CursorColor");
        assign("width", "Width", parseFloat);
        assign("reverseY", "ReverseY", (v) => {
          return v == "True";
        });
        assign("valuePrecision", "ValuePrecision", parseInt);
      }
      style = Object.assign(style, genericStyle);
      return Object.assign({ style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a double horizontal gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createDoubleHorizontalGauge(gaugeDef) {
      const styleElem = gaugeDef.getElementsByTagName("Style");
      const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
      let style = {};
      if (styleElem[0] !== void 0) {
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "textIncrement", "TextIncrement", parseFloat);
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "valuePrecision", "ValuePrecision", parseInt);
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "valuePos", "ValuePos", (v) => {
          return v == "Right" ? XMLDoubleHorizontalGaugeValuePos.Right : void 0;
        });
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "pointerStyle", "PointerStyle", (v) => {
          return v == "Arrow" ? "arrow" : "standard";
        });
      }
      style = Object.assign(style, genericStyle);
      return Object.assign({ style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a single vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createVerticalGauge(gaugeDef) {
      const styleElem = gaugeDef.getElementsByTagName("Style");
      const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
      let style = {};
      if (styleElem[0] !== void 0) {
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "textIncrement", "TextIncrement", parseFloat);
      }
      style = Object.assign(style, genericStyle);
      return Object.assign({ style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a double vertical gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createDoubleVerticalGauge(gaugeDef) {
      const styleElem = gaugeDef.getElementsByTagName("Style");
      const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
      let style = {};
      if (styleElem[0] !== void 0) {
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "textIncrement", "TextIncrement", parseFloat);
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "height", "Height", parseFloat);
      }
      style = Object.assign(style, genericStyle);
      return Object.assign({ style }, this.parseGaugeDefinition(gaugeDef));
    }
    /**
     * Create a cylinder gauge.
     * @param gaugeDef An XML element defining the gauge.
     * @returns The props for this gauge.
     */
    createCylinderGauge(gaugeDef) {
      const styleElem = gaugeDef.getElementsByTagName("Style");
      const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
      const columnElems = gaugeDef.getElementsByTagName("Columns");
      const rowElems = gaugeDef.getElementsByTagName("Rows");
      const config = this.parseGaugeDefinition(gaugeDef);
      config.bus = this.bus;
      let style = {};
      if (styleElem[0] !== void 0) {
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "textIncrement", "TextIncrement", parseFloat);
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "redline", "ShowRedline", (text) => {
          return text == "True";
        });
        XMLGaugeConfigFactory.getAndAssign(style, styleElem[0], "peakTemps", "ShowPeak", (text) => {
          return text == "True";
        });
      }
      style = Object.assign(style, genericStyle);
      config.style = style;
      if (columnElems.length > 0) {
        config.numColumns = new CompositeLogicXMLElement(this.instrument, columnElems[0]);
      }
      if (rowElems.length > 0) {
        config.numRows = new CompositeLogicXMLElement(this.instrument, rowElems[0]);
      }
      XMLGaugeConfigFactory.getAndAssign(config, gaugeDef, "tempOrder", "TempOrder", (text) => {
        const tempOrder = new Array();
        for (const item of text.split(",")) {
          tempOrder.push(parseInt(item));
        }
        return tempOrder;
      });
      return config;
    }
    /**
     * Create a column group.
     * @param gaugeDef AN XML element defining the group.
     * @returns The props for the group with all contained columns.
     */
    createColumnGroup(gaugeDef) {
      const columns = new Array();
      const children = gaugeDef.children;
      for (const child of children) {
        if (child.tagName == "Column") {
          columns.push(this.createColumn(child));
        }
      }
      const group = {
        bus: this.bus,
        columns
      };
      XMLGaugeConfigFactory.getAndAssign(group, gaugeDef, "id", "id");
      return group;
    }
    /**
     * Create a column of gauges.
     * @param gaugeDef An XML element defining the column.
     * @returns The props of the column with all contained gauges.
     */
    createColumn(gaugeDef) {
      const column = { gauges: this._parseConfig(gaugeDef) };
      XMLGaugeConfigFactory.getAndAssign(column, gaugeDef, "id", "id");
      XMLGaugeConfigFactory.getAndAssign(column, gaugeDef, "width", "width", parseFloat);
      return column;
    }
    // Utility functions.
    /**
     * Check the value of a setting and, if it's defined, assign it to the
     * property of an object with optional type conversion.
     * @param obj The object to manipulate.
     * @param elem The element to get the value from.
     * @param prop The name of the property to set.
     * @param tag The tag name to retrieve.
     * @param converter A type conversion used if the value is defined.
     */
    static getAndAssign(obj, elem, prop, tag, converter = (val) => {
      return val;
    }) {
      var _a;
      const value = (_a = elem.getElementsByTagName(tag)[0]) === null || _a === void 0 ? void 0 : _a.textContent;
      if (value === null || value === void 0) {
        return;
      }
      const newVal = converter(value);
      if (newVal !== void 0) {
        obj[prop] = newVal;
      }
    }
    /**
     * Create a basic XML style from a gauge definition.
     * @param styleDoc A style definition block
     * @returns An XMLGaugeStyle
     */
    static parseStyleDefinition(styleDoc) {
      var _a;
      const style = {};
      if (styleDoc.length > 0) {
        XMLGaugeConfigFactory.getAndAssign(style, styleDoc[0], "sizePercent", "SizePercent", parseFloat);
        const marginsElem = styleDoc[0].getElementsByTagName("Margins");
        if (marginsElem.length > 0 && ((_a = marginsElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) !== null) {
          XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], "marginLeft", "Left", parseFloat);
          XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], "marginRight", "Right", parseFloat);
          XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], "marginTop", "Top", parseFloat);
          XMLGaugeConfigFactory.getAndAssign(style, marginsElem[0], "marginBottom", "Bottom", parseFloat);
        }
      }
      return style;
    }
    /**
     * Get the SmoothFactor value from a gauge definition if present.
     * @param element The HTML element to search for the parameter.
     * @returns The smoothing factor as a number, or undefined if not found.
     */
    parseSmoothFactor(element) {
      var _a;
      const smoothElem = element.getElementsByTagName("SmoothFactor");
      if (smoothElem.length > 0 && ((_a = smoothElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) !== null) {
        return smoothElem.length > 0 ? parseFloat(smoothElem[0].textContent) : void 0;
      }
      return void 0;
    }
    /**
     * Create an array of color zones if a definition exists.
     * @param zones An array of color zone definitions.
     * @returns An array of XMLGaugeColorZones
     */
    makeColorZones(zones) {
      var _a, _b;
      const zoneArray = new Array();
      for (let i = 0; i < zones.length; i++) {
        let color = "white";
        const colorElem = zones[i].getElementsByTagName("Color");
        if (colorElem.length > 0) {
          color = ((_a = colorElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) ? (_b = colorElem[0]) === null || _b === void 0 ? void 0 : _b.textContent : "white";
        }
        zoneArray.push({
          color,
          begin: new CompositeLogicXMLElement(this.instrument, zones[i].getElementsByTagName("Begin")[0]),
          end: new CompositeLogicXMLElement(this.instrument, zones[i].getElementsByTagName("End")[0]),
          smoothFactor: this.parseSmoothFactor(zones[i])
        });
      }
      return zoneArray.length > 0 ? zoneArray : void 0;
    }
    /**
     * Create an array of color lines if a definition exists.
     * @param lines An array of color line definitions.
     * @returns An array of XMLGaugeColorLines
     */
    makeColorLines(lines) {
      var _a, _b;
      const lineArray = new Array();
      for (let i = 0; i < lines.length; i++) {
        let color = "white";
        const colorElem = lines[i].getElementsByTagName("Color");
        if (colorElem.length > 0) {
          color = ((_a = colorElem[0]) === null || _a === void 0 ? void 0 : _a.textContent) ? (_b = colorElem[0]) === null || _b === void 0 ? void 0 : _b.textContent : "white";
        }
        lineArray.push({
          color,
          position: new CompositeLogicXMLElement(this.instrument, lines[i].getElementsByTagName("Position")[0]),
          smoothFactor: this.parseSmoothFactor(lines[i])
        });
      }
      return lineArray.length > 0 ? lineArray : void 0;
    }
    /**
     * Create an array of reference bugs if a definition exists.
     * @param bugs An array of reference bug definitions.
     * @returns An array of XMLGaugeReferenceBugs
     */
    makeReferenceBugs(bugs) {
      const bugArray = new Array();
      for (let i = 0; i < bugs.length; i++) {
        const styleElem = bugs[i].getElementsByTagName("Style");
        const genericStyle = XMLGaugeConfigFactory.parseStyleDefinition(styleElem);
        let bugStyle = {};
        const innerElem = styleElem[0];
        if (innerElem !== void 0) {
          XMLGaugeConfigFactory.getAndAssign(bugStyle, innerElem, "color", "Color");
        }
        bugStyle = Object.assign(bugStyle, genericStyle);
        bugArray.push({
          position: new CompositeLogicXMLElement(this.instrument, bugs[i].getElementsByTagName("Position")[0]),
          displayLogic: new CompositeLogicXMLElement(this.instrument, bugs[i].getElementsByTagName("DisplayLogic")[0]),
          style: bugStyle,
          smoothFactor: this.parseSmoothFactor(bugs[i])
        });
      }
      return bugArray;
    }
  };
  var AlertState;
  (function(AlertState2) {
    AlertState2[AlertState2["New"] = 0] = "New";
    AlertState2[AlertState2["Acked"] = 1] = "Acked";
  })(AlertState || (AlertState = {}));
  var SystemAlertManager = class {
    /**
     * Create a SystemAlertManager instance.
     * @param bus The event bus
     * @param annunciations An array of the system annunciations to monitor
     * @param logicHost An actively updated composite logic host.
     * @param warningSoundId The identifier of the warning sound, if other than default
     * @param cautionSoundId The identifier of the caution sound, if other than default
     */
    constructor(bus, annunciations, logicHost, warningSoundId = "tone_warning", cautionSoundId = "tone_caution") {
      this.initialized = false;
      this.activeAnns = [];
      this.bus = bus;
      this.logicHost = logicHost;
      this.soundPublisher = this.bus.getPublisher();
      this.alertPublisher = this.bus.getPublisher();
      this.warningSoundId = warningSoundId;
      this.cautionSoundId = cautionSoundId;
      this.annunciations = annunciations;
      KeyEventManager.getManager(this.bus).then((manager) => {
        manager.interceptKey("MASTER_CAUTION_ACKNOWLEDGE", true);
        manager.interceptKey("MASTER_WARNING_ACKNOWLEDGE", true);
      });
      this.bus.getSubscriber().on("key_intercept").handle((keyData) => {
        switch (keyData.key) {
          case "MASTER_CAUTION_ACKNOWLEDGE":
            this.handleAcknowledgement(AnnunciationType.Caution);
            break;
          case "MASTER_WARNING_ACKNOWLEDGE":
            this.handleAcknowledgement(AnnunciationType.Warning);
            break;
        }
      });
      for (let i = 0; i < this.annunciations.length; i++) {
        const ann = this.annunciations[i];
        this.logicHost.addLogicAsNumber(ann.condition, (v) => {
          if (v == 1) {
            this.handleAnnunciationActive(i);
          } else {
            this.handleAnnunciationInactive(i);
          }
        }, 0);
      }
      const gameStateSub = GameStateProvider.get().sub((state) => {
        if (state === GameState.ingame) {
          setTimeout(() => {
            this.initialized = true;
            this.alertPublisher.pub("master_acknowledge", AnnunciationType.Caution, true, false);
            this.alertPublisher.pub("master_acknowledge", AnnunciationType.Warning, true, false);
          }, 5e3);
          gameStateSub.destroy();
        }
      }, false, true);
      gameStateSub.resume(true);
      this.setMasterStatus(AnnunciationType.Caution, false);
      this.setMasterStatus(AnnunciationType.Warning, false);
    }
    /**
     * Set both sets of simvars relevant to a master caution or warning status.
     * @param type The type of the status to set
     * @param active Whether or not the status is active
     */
    setMasterStatus(type, active) {
      switch (type) {
        case AnnunciationType.Caution:
          SimVar.SetSimVarValue("K:MASTER_CAUTION_SET", "bool", active);
          SimVar.SetSimVarValue("L:Generic_Master_Caution_Active", "bool", active);
          break;
        case AnnunciationType.Warning:
          SimVar.SetSimVarValue("K:MASTER_WARNING_SET", "bool", active);
          SimVar.SetSimVarValue("L:Generic_Master_Warning_Active", "bool", active);
          break;
      }
    }
    /**
     * Handle an annunciation going active.
     * @param idx The index of the annunciations array for the annunciation.
     */
    handleAnnunciationActive(idx) {
      const type = this.annunciations[idx].type;
      if (!this.checkForActiveType(type) && this.initialized) {
        this.setMasterStatus(type, true);
        if (type == AnnunciationType.Caution) {
          this.soundPublisher.pub("sound_server_play_sound", this.cautionSoundId, true, false);
        } else if (type == AnnunciationType.Warning) {
          this.soundPublisher.pub("sound_server_start_sound", this.warningSoundId, true, false);
        }
      }
      this.addOrUpdateAnnunciation(idx);
    }
    /**
     * Handle an annunciation going inactive.
     * @param idx The index of the annunciations array for the annunciation.
     */
    handleAnnunciationInactive(idx) {
      const type = this.annunciations[idx].type;
      this.removeAnnunciation(idx);
      if (!this.checkForActiveType(type) && this.initialized) {
        this.setMasterStatus(this.annunciations[idx].type, false);
        if (type == AnnunciationType.Warning) {
          this.soundPublisher.pub("sound_server_stop_sound", this.warningSoundId, true, false);
        }
      }
    }
    /**
     * Handle a master warning or caution acknowledgement.
     * @param type The type of alert to acknowledge.
     */
    handleAcknowledgement(type) {
      let updated = false;
      this.setMasterStatus(type, false);
      this.alertPublisher.pub("master_acknowledge", type, true, false);
      for (let i = 0; i < this.activeAnns.length; i++) {
        if (this.annunciations[this.activeAnns[i].index].type === type) {
          this.activeAnns[i].state = AlertState.Acked;
          updated = true;
        }
      }
      if (updated) {
        if (type == AnnunciationType.Warning) {
          this.soundPublisher.pub("sound_server_stop_sound", this.warningSoundId, true, false);
        }
      }
    }
    /**
     * See if there is still an active, unacked annunciation of the given type.
     * @param type The annunciation type to check for.
     * @returns True if there is an active, unacked annunciation of the given type, false otherwise.
     */
    checkForActiveType(type) {
      for (let i = 0; i < this.activeAnns.length; i++) {
        if (this.annunciations[this.activeAnns[i].index].type === type && this.activeAnns[i].state === AlertState.New) {
          return true;
        }
      }
      return false;
    }
    /**
     * Add an annunciation to the active list if it's new, or update it if already there.
     * @param idx The index of the annunciations array for the annunciation.
     * @returns The index of the added or updated annunciation in the active list.
     */
    addOrUpdateAnnunciation(idx) {
      const adjustedState = this.initialized ? AlertState.New : AlertState.Acked;
      this.alertPublisher.pub("alert_triggered", idx, true, false);
      for (let i = 0; i < this.activeAnns.length; i++) {
        if (this.activeAnns[i].index === idx) {
          this.activeAnns[i].state = adjustedState;
          return i;
        }
      }
      this.activeAnns.push({
        index: idx,
        state: adjustedState
      });
      return this.activeAnns.length - 1;
    }
    /**
     * Remove an annunciation from the active list if present.
     * @param idx The index of the annunciations array for the annunciation.
     * @returns True if the annunciation was removed, false otherwise.
     */
    removeAnnunciation(idx) {
      for (let i = 0; i < this.activeAnns.length; i++) {
        if (this.activeAnns[i].index === idx) {
          this.activeAnns.splice(i, 1);
          this.alertPublisher.pub("alert_cleared", idx, true, false);
          return true;
        }
      }
      return false;
    }
  };
  var APVerticalModes;
  (function(APVerticalModes2) {
    APVerticalModes2[APVerticalModes2["NONE"] = 0] = "NONE";
    APVerticalModes2[APVerticalModes2["PITCH"] = 1] = "PITCH";
    APVerticalModes2[APVerticalModes2["VS"] = 2] = "VS";
    APVerticalModes2[APVerticalModes2["FLC"] = 3] = "FLC";
    APVerticalModes2[APVerticalModes2["ALT"] = 4] = "ALT";
    APVerticalModes2[APVerticalModes2["PATH"] = 5] = "PATH";
    APVerticalModes2[APVerticalModes2["GP"] = 6] = "GP";
    APVerticalModes2[APVerticalModes2["GS"] = 7] = "GS";
    APVerticalModes2[APVerticalModes2["CAP"] = 8] = "CAP";
    APVerticalModes2[APVerticalModes2["TO"] = 9] = "TO";
    APVerticalModes2[APVerticalModes2["GA"] = 10] = "GA";
    APVerticalModes2[APVerticalModes2["FPA"] = 11] = "FPA";
    APVerticalModes2[APVerticalModes2["FLARE"] = 12] = "FLARE";
  })(APVerticalModes || (APVerticalModes = {}));
  var APLateralModes;
  (function(APLateralModes2) {
    APLateralModes2[APLateralModes2["NONE"] = 0] = "NONE";
    APLateralModes2[APLateralModes2["ROLL"] = 1] = "ROLL";
    APLateralModes2[APLateralModes2["LEVEL"] = 2] = "LEVEL";
    APLateralModes2[APLateralModes2["GPSS"] = 3] = "GPSS";
    APLateralModes2[APLateralModes2["HEADING"] = 4] = "HEADING";
    APLateralModes2[APLateralModes2["VOR"] = 5] = "VOR";
    APLateralModes2[APLateralModes2["LOC"] = 6] = "LOC";
    APLateralModes2[APLateralModes2["BC"] = 7] = "BC";
    APLateralModes2[APLateralModes2["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes2[APLateralModes2["NAV"] = 9] = "NAV";
    APLateralModes2[APLateralModes2["TO"] = 10] = "TO";
    APLateralModes2[APLateralModes2["GA"] = 11] = "GA";
    APLateralModes2[APLateralModes2["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes2[APLateralModes2["TRACK"] = 13] = "TRACK";
    APLateralModes2[APLateralModes2["TRACK_HOLD"] = 14] = "TRACK_HOLD";
  })(APLateralModes || (APLateralModes = {}));
  var APAltitudeModes;
  (function(APAltitudeModes2) {
    APAltitudeModes2[APAltitudeModes2["NONE"] = 0] = "NONE";
    APAltitudeModes2[APAltitudeModes2["ALTS"] = 1] = "ALTS";
    APAltitudeModes2[APAltitudeModes2["ALTV"] = 2] = "ALTV";
  })(APAltitudeModes || (APAltitudeModes = {}));
  var APStates;
  (function(APStates2) {
    APStates2[APStates2["None"] = 0] = "None";
    APStates2[APStates2["APActive"] = 1] = "APActive";
    APStates2[APStates2["YawDamper"] = 2] = "YawDamper";
    APStates2[APStates2["Heading"] = 4] = "Heading";
    APStates2[APStates2["Nav"] = 8] = "Nav";
    APStates2[APStates2["NavArmed"] = 16] = "NavArmed";
    APStates2[APStates2["Approach"] = 32] = "Approach";
    APStates2[APStates2["ApproachArmed"] = 64] = "ApproachArmed";
    APStates2[APStates2["Backcourse"] = 128] = "Backcourse";
    APStates2[APStates2["BackcourseArmed"] = 256] = "BackcourseArmed";
    APStates2[APStates2["Alt"] = 512] = "Alt";
    APStates2[APStates2["AltS"] = 1024] = "AltS";
    APStates2[APStates2["AltV"] = 2048] = "AltV";
    APStates2[APStates2["VS"] = 4096] = "VS";
    APStates2[APStates2["FLC"] = 8192] = "FLC";
    APStates2[APStates2["GP"] = 16384] = "GP";
    APStates2[APStates2["GPArmed"] = 32768] = "GPArmed";
    APStates2[APStates2["GS"] = 65536] = "GS";
    APStates2[APStates2["GSArmed"] = 131072] = "GSArmed";
    APStates2[APStates2["Path"] = 262144] = "Path";
    APStates2[APStates2["PathArmed"] = 524288] = "PathArmed";
    APStates2[APStates2["PathInvalid"] = 1048576] = "PathInvalid";
    APStates2[APStates2["Pitch"] = 2097152] = "Pitch";
    APStates2[APStates2["Roll"] = 4194304] = "Roll";
    APStates2[APStates2["VNAV"] = 8388608] = "VNAV";
    APStates2[APStates2["ATSpeed"] = 16777216] = "ATSpeed";
    APStates2[APStates2["ATMach"] = 33554432] = "ATMach";
    APStates2[APStates2["ATArmed"] = 67108864] = "ATArmed";
    APStates2[APStates2["FD"] = 134217728] = "FD";
  })(APStates || (APStates = {}));
  var DirectorState;
  (function(DirectorState2) {
    DirectorState2["Inactive"] = "Inactive";
    DirectorState2["Armed"] = "Armed";
    DirectorState2["Active"] = "Active";
  })(DirectorState || (DirectorState = {}));
  var EmptyDirector = class {
    constructor() {
      this.onActivate = () => {
      };
      this.onArm = () => {
      };
      this.state = DirectorState.Inactive;
    }
    /** No-op. */
    activate() {
    }
    /** No-op. */
    deactivate() {
    }
    /** No-op. */
    update() {
    }
    /** No-op. */
    arm() {
    }
  };
  EmptyDirector.instance = new EmptyDirector();
  var APNoneVerticalDirector = class {
    constructor() {
      this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    activate() {
      this.state = DirectorState.Active;
      Coherent.call("apSetAutopilotMode", MSFSAPStates.Alt, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.AltArm, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.FLC, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.VS, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.Pitch, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.GS, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.GSArm, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.TOGAPitch, 0);
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
    }
    /** @inheritdoc */
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.activate();
      }
    }
    /** @inheritdoc */
    deactivate() {
      this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    update() {
    }
  };
  var APNoneLateralDirector = class {
    constructor() {
      this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    activate() {
      this.state = DirectorState.Active;
      Coherent.call("apSetAutopilotMode", MSFSAPStates.Bank, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.Heading, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.Nav, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.NavArm, 0);
      Coherent.call("apSetAutopilotMode", MSFSAPStates.WingLevel, 0);
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
    }
    /** @inheritdoc */
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.activate();
      }
    }
    /** @inheritdoc */
    deactivate() {
      this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    update() {
    }
  };
  var VNavState;
  (function(VNavState2) {
    VNavState2[VNavState2["Disabled"] = 0] = "Disabled";
    VNavState2[VNavState2["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    VNavState2[VNavState2["Enabled_Active"] = 2] = "Enabled_Active";
  })(VNavState || (VNavState = {}));
  var VNavPathMode;
  (function(VNavPathMode2) {
    VNavPathMode2[VNavPathMode2["None"] = 0] = "None";
    VNavPathMode2[VNavPathMode2["PathArmed"] = 1] = "PathArmed";
    VNavPathMode2[VNavPathMode2["PathActive"] = 2] = "PathActive";
    VNavPathMode2[VNavPathMode2["PathInvalid"] = 3] = "PathInvalid";
  })(VNavPathMode || (VNavPathMode = {}));
  var ApproachGuidanceMode;
  (function(ApproachGuidanceMode2) {
    ApproachGuidanceMode2[ApproachGuidanceMode2["None"] = 0] = "None";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSArmed"] = 1] = "GSArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSActive"] = 2] = "GSActive";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPArmed"] = 3] = "GPArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPActive"] = 4] = "GPActive";
  })(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
  var VNavAltCaptureType;
  (function(VNavAltCaptureType2) {
    VNavAltCaptureType2[VNavAltCaptureType2["None"] = 0] = "None";
    VNavAltCaptureType2[VNavAltCaptureType2["Selected"] = 1] = "Selected";
    VNavAltCaptureType2[VNavAltCaptureType2["VNAV"] = 2] = "VNAV";
  })(VNavAltCaptureType || (VNavAltCaptureType = {}));
  var VNavAvailability;
  (function(VNavAvailability2) {
    VNavAvailability2["Available"] = "Available";
    VNavAvailability2["InvalidLegs"] = "InvalidLegs";
  })(VNavAvailability || (VNavAvailability = {}));
  var Autopilot = class {
    /**
     * Creates an instance of the Autopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     */
    constructor(bus, flightPlanner, config, stateManager) {
      var _a;
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.config = config;
      this.stateManager = stateManager;
      this.cdiSource = { type: NavSourceType.Nav, index: 0 };
      this.lateralModes = /* @__PURE__ */ new Map();
      this.verticalModes = /* @__PURE__ */ new Map();
      this.verticalAltitudeArmed = APAltitudeModes.NONE;
      this.verticalApproachArmed = APVerticalModes.NONE;
      this.altCapArmed = false;
      this.lateralModeFailed = false;
      this.inClimb = false;
      this.currentAltitude = 0;
      this.vnavCaptureType = VNavAltCaptureType.None;
      this.flightPlanSynced = false;
      this.requireApproachIsActiveForNavToNav = true;
      this.apValues = {
        selectedAltitude: Subject.create(0),
        selectedVerticalSpeed: Subject.create(0),
        selectedFlightPathAngle: Subject.create(0),
        selectedIas: Subject.create(0),
        selectedMach: Subject.create(0),
        isSelectedSpeedInMach: Subject.create(false),
        selectedPitch: Subject.create(0),
        maxBankId: Subject.create(0),
        maxBankAngle: Subject.create(30),
        selectedHeading: Subject.create(0),
        capturedAltitude: Subject.create(0),
        approachIsActive: Subject.create(false),
        approachHasGP: Subject.create(false),
        nav1HasGs: Subject.create(false),
        nav2HasGs: Subject.create(false),
        nav3HasGs: Subject.create(false),
        nav4HasGs: Subject.create(false),
        lateralActive: Subject.create(APLateralModes.NONE),
        verticalActive: Subject.create(APVerticalModes.NONE),
        lateralArmed: Subject.create(APLateralModes.NONE),
        verticalArmed: Subject.create(APVerticalModes.NONE),
        apApproachModeOn: Subject.create(false)
      };
      this.autopilotInitialized = false;
      this.apValues.maxBankAngle.set(config.defaultMaxBankAngle);
      this.directors = this.createDirectors(config);
      this.vnavManager = config.createVNavManager(this.apValues);
      this.navToNavManager = config.createNavToNavManager(this.apValues);
      this.variableBankManager = config.createVariableBankManager(this.apValues);
      this.apValues.navToNavLocArm = (_a = this.navToNavManager) === null || _a === void 0 ? void 0 : _a.canLocArm.bind(this.navToNavManager);
      this.stateManager.stateManagerInitialized.sub((v) => {
        if (v) {
          this.autopilotInitialized = true;
        } else {
          this.autopilotInitialized = false;
        }
        this.onInitialized();
      });
      this.flightPlanner.flightPlanSynced.on((sender, v) => {
        if (!this.flightPlanSynced && v) {
          this.stateManager.stateManagerInitialized.set(false);
          this.stateManager.initialize(true);
          this.flightPlanSynced = true;
        }
      });
      this.initLateralModes();
      this.initVerticalModes();
      this.initNavToNavManager();
      this.initVNavManager();
      this.monitorEvents();
    }
    /**
     * Creates this autopilot's directors.
     * @param config This autopilot's configuration.
     * @returns This autopilot's directors.
     */
    createDirectors(config) {
      return {
        headingDirector: config.createHeadingDirector(this.apValues),
        headingHoldDirector: config.createHeadingHoldDirector(this.apValues),
        trackDirector: config.createTrackDirector(this.apValues),
        trackHoldDirector: config.createTrackHoldDirector(this.apValues),
        rollDirector: config.createRollDirector(this.apValues),
        wingLevelerDirector: config.createWingLevelerDirector(this.apValues),
        gpssDirector: config.createGpssDirector(this.apValues),
        vorDirector: config.createVorDirector(this.apValues),
        locDirector: config.createLocDirector(this.apValues),
        bcDirector: config.createBcDirector(this.apValues),
        rolloutDirector: config.createRolloutDirector(),
        pitchDirector: config.createPitchDirector(this.apValues),
        vsDirector: config.createVsDirector(this.apValues),
        fpaDirector: config.createFpaDirector(this.apValues),
        flcDirector: config.createFlcDirector(this.apValues),
        altHoldDirector: config.createAltHoldDirector(this.apValues),
        altCapDirector: config.createAltCapDirector(this.apValues),
        vnavPathDirector: config.createVNavPathDirector(this.apValues),
        gpDirector: config.createGpDirector(this.apValues),
        gsDirector: config.createGsDirector(this.apValues),
        toVerticalDirector: config.createToVerticalDirector(this.apValues),
        gaVerticalDirector: config.createGaVerticalDirector(this.apValues),
        toLateralDirector: config.createToLateralDirector(this.apValues),
        gaLateralDirector: config.createGaLateralDirector(this.apValues),
        flareDirector: config.createFlareDirector()
      };
    }
    /**
     * Update method for the Autopilot.
     */
    update() {
      if (this.autopilotInitialized) {
        this.onBeforeUpdate();
        this.checkModes();
        this.manageAltitudeCapture();
        this.updateModes();
        this.onAfterUpdate();
      }
    }
    /**
     * This method runs each update cycle before the update occurs.
     */
    onBeforeUpdate() {
    }
    /**
     * This method runs each update cycle after the update occurs.
     */
    onAfterUpdate() {
    }
    /**
     * This method runs whenever the initialized state of the Autopilot changes.
     */
    onInitialized() {
    }
    /**
     * Handles input from the State Manager when a lateral mode button is pressed.
     * @param data is the AP Lateral Mode Event Data
     */
    lateralPressed(data) {
      var _a, _b, _c, _d;
      const mode = data.mode;
      if (mode !== APLateralModes.NAV && !this.lateralModes.has(mode)) {
        return;
      }
      const set = data.set;
      if (set === void 0 || set === false) {
        if (this.isLateralModeActivatedOrArmed(mode)) {
          return;
        }
      }
      if (set === void 0 || set === true) {
        if (!this.stateManager.isFlightDirectorOn.get()) {
          this.stateManager.setFlightDirector(true);
        }
        switch (mode) {
          case APLateralModes.NONE:
            break;
          case APLateralModes.LEVEL:
          case APLateralModes.ROLL:
          case APLateralModes.HEADING:
          case APLateralModes.HEADING_HOLD:
          case APLateralModes.TRACK:
          case APLateralModes.TRACK_HOLD:
          case APLateralModes.LOC:
          case APLateralModes.BC:
            (_a = this.lateralModes.get(mode)) === null || _a === void 0 ? void 0 : _a.arm();
            break;
          case APLateralModes.NAV:
            if (this.cdiSource.type === NavSourceType.Gps) {
              (_b = this.lateralModes.get(APLateralModes.GPSS)) === null || _b === void 0 ? void 0 : _b.arm();
            } else {
              (_c = this.lateralModes.get(APLateralModes.VOR)) === null || _c === void 0 ? void 0 : _c.arm();
              (_d = this.lateralModes.get(APLateralModes.LOC)) === null || _d === void 0 ? void 0 : _d.arm();
            }
            break;
        }
      }
    }
    /**
     * Handles input from the State Manager when a vertical mode button is pressed.
     * @param data is the AP Vertical Mode Event Data
     */
    verticalPressed(data) {
      var _a, _b, _c, _d, _e;
      const mode = data.mode;
      if (!this.verticalModes.has(mode)) {
        return;
      }
      const set = data.set;
      if ((set === void 0 || set === false) && mode !== APVerticalModes.TO) {
        if (this.deactivateArmedOrActiveVerticalMode(mode)) {
          return;
        }
      }
      if (set === void 0 || set === true) {
        if (!this.stateManager.isFlightDirectorOn.get()) {
          this.stateManager.setFlightDirector(true);
        }
        switch (mode) {
          case APVerticalModes.NONE:
          case APVerticalModes.PATH:
            break;
          case APVerticalModes.ALT:
            if (((_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.state) !== VNavState.Enabled_Active || this.vnavManager && this.vnavManager.state === VNavState.Enabled_Active && this.vnavManager.canVerticalModeActivate(mode)) {
              this.setAltHold();
            }
            break;
          case APVerticalModes.PITCH:
          case APVerticalModes.VS:
          case APVerticalModes.FPA:
          case APVerticalModes.FLC:
            if (((_b = this.vnavManager) === null || _b === void 0 ? void 0 : _b.state) === VNavState.Enabled_Active && !this.vnavManager.canVerticalModeActivate(mode)) {
              (_c = this.verticalModes.get(mode)) === null || _c === void 0 ? void 0 : _c.arm();
            } else {
              (_d = this.verticalModes.get(mode)) === null || _d === void 0 ? void 0 : _d.activate();
            }
            break;
          case APVerticalModes.GP:
          case APVerticalModes.GS:
            (_e = this.verticalModes.get(mode)) === null || _e === void 0 ? void 0 : _e.arm();
            break;
          case APVerticalModes.TO:
          case APVerticalModes.GA:
            this.togaPressed();
        }
      }
    }
    /**
     * Checks if a mode is active or armed and optionally deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    isLateralModeActivatedOrArmed(mode) {
      var _a, _b, _c, _d, _e, _f;
      const { lateralActive, lateralArmed } = this.apValues;
      switch (mode) {
        case lateralActive.get():
          (_a = this.lateralModes.get(mode)) === null || _a === void 0 ? void 0 : _a.deactivate();
          (_b = this.lateralModes.get(this.getDefaultLateralMode())) === null || _b === void 0 ? void 0 : _b.arm();
          return true;
        case lateralArmed.get():
          (_c = this.lateralModes.get(mode)) === null || _c === void 0 ? void 0 : _c.deactivate();
          lateralArmed.set(APLateralModes.NONE);
          return true;
        case APLateralModes.NAV: {
          const activeNavMode = lateralActive.get() === APLateralModes.LOC ? APLateralModes.LOC : lateralActive.get() === APLateralModes.VOR ? APLateralModes.VOR : lateralActive.get() === APLateralModes.GPSS ? APLateralModes.GPSS : APLateralModes.NONE;
          if (activeNavMode !== APLateralModes.NONE) {
            (_d = this.lateralModes.get(activeNavMode)) === null || _d === void 0 ? void 0 : _d.deactivate();
            (_e = this.lateralModes.get(this.getDefaultLateralMode())) === null || _e === void 0 ? void 0 : _e.arm();
            lateralActive.set(this.getDefaultLateralMode());
          }
          const armedNavMode = lateralArmed.get() === APLateralModes.LOC ? APLateralModes.LOC : lateralArmed.get() === APLateralModes.VOR ? APLateralModes.VOR : lateralArmed.get() === APLateralModes.GPSS ? APLateralModes.GPSS : APLateralModes.NONE;
          if (armedNavMode !== APLateralModes.NONE) {
            (_f = this.lateralModes.get(armedNavMode)) === null || _f === void 0 ? void 0 : _f.deactivate();
            lateralArmed.set(APLateralModes.NONE);
          }
          if (armedNavMode !== APLateralModes.NONE || activeNavMode !== APLateralModes.NONE) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Checks if a mode is active or armed and deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    deactivateArmedOrActiveVerticalMode(mode) {
      var _a, _b, _c, _d;
      const { verticalActive, verticalArmed } = this.apValues;
      switch (mode) {
        case verticalActive.get():
          (_a = this.verticalModes.get(mode)) === null || _a === void 0 ? void 0 : _a.deactivate();
          verticalActive.set(this.getDefaultVerticalMode());
          (_b = this.verticalModes.get(verticalActive.get())) === null || _b === void 0 ? void 0 : _b.arm();
          return true;
        case verticalArmed.get():
          if (mode !== APVerticalModes.ALT) {
            (_c = this.verticalModes.get(mode)) === null || _c === void 0 ? void 0 : _c.deactivate();
            verticalArmed.set(APVerticalModes.NONE);
            return true;
          }
          break;
        case this.verticalApproachArmed:
          (_d = this.verticalModes.get(mode)) === null || _d === void 0 ? void 0 : _d.deactivate();
          this.verticalApproachArmed = APVerticalModes.NONE;
          return true;
      }
      return false;
    }
    /**
     * Handles input from the State Manager when the APPR button is pressed.
     * @param set is whether this event commands a specific set
     */
    approachPressed(set) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if ((set === void 0 || set === false) && this.deactivateArmedOrActiveVerticalMode(APVerticalModes.GP)) {
        (_a = this.lateralModes.get(APLateralModes.GPSS)) === null || _a === void 0 ? void 0 : _a.deactivate();
        return;
      }
      if ((set === void 0 || set === false) && this.deactivateArmedOrActiveVerticalMode(APVerticalModes.GS)) {
        (_b = this.lateralModes.get(APLateralModes.LOC)) === null || _b === void 0 ? void 0 : _b.deactivate();
        return;
      }
      if (set === void 0 || set === true) {
        switch (this.getArmableApproachType()) {
          case APLateralModes.LOC:
            if (((_c = this.lateralModes.get(APLateralModes.LOC)) === null || _c === void 0 ? void 0 : _c.state) === DirectorState.Inactive) {
              (_d = this.lateralModes.get(APLateralModes.LOC)) === null || _d === void 0 ? void 0 : _d.arm();
            }
            (_e = this.verticalModes.get(APVerticalModes.GS)) === null || _e === void 0 ? void 0 : _e.arm();
            break;
          case APLateralModes.GPSS:
            if (((_f = this.lateralModes.get(APLateralModes.GPSS)) === null || _f === void 0 ? void 0 : _f.state) === DirectorState.Inactive) {
              (_g = this.lateralModes.get(APLateralModes.GPSS)) === null || _g === void 0 ? void 0 : _g.arm();
            }
            (_h = this.verticalModes.get(APVerticalModes.GP)) === null || _h === void 0 ? void 0 : _h.arm();
            break;
        }
      }
    }
    /**
     * Handles input from the State Manager when the TOGA button is pressed
     * (K event AUTO_THROTTLE_TO_GA)
     */
    togaPressed() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      const hasToMode = this.verticalModes.has(APVerticalModes.TO) && this.lateralModes.has(APLateralModes.TO);
      const hasGaMode = this.verticalModes.has(APVerticalModes.GA) && this.lateralModes.has(APLateralModes.GA);
      const verticalActive = this.apValues.verticalActive.get();
      const lateralActive = this.apValues.lateralActive.get();
      let toGaWasActive = false;
      if (hasToMode && hasGaMode) {
        if (verticalActive === APVerticalModes.TO || verticalActive === APVerticalModes.GA) {
          (_a = this.verticalModes.get(verticalActive)) === null || _a === void 0 ? void 0 : _a.deactivate();
          toGaWasActive = true;
        }
        if (lateralActive === APLateralModes.GA || lateralActive === APLateralModes.TO) {
          (_b = this.lateralModes.get(lateralActive)) === null || _b === void 0 ? void 0 : _b.deactivate();
          toGaWasActive = true;
        }
        if (!toGaWasActive) {
          if (Simplane.getIsGrounded()) {
            (_c = this.verticalModes.get(APVerticalModes.TO)) === null || _c === void 0 ? void 0 : _c.arm();
            (_d = this.lateralModes.get(APLateralModes.TO)) === null || _d === void 0 ? void 0 : _d.arm();
          } else {
            SimVar.SetSimVarValue("K:AUTOPILOT_OFF", "number", 0);
            (_e = this.verticalModes.get(APVerticalModes.GA)) === null || _e === void 0 ? void 0 : _e.arm();
            (_f = this.lateralModes.get(APLateralModes.GA)) === null || _f === void 0 ? void 0 : _f.arm();
          }
        }
      } else if (hasToMode) {
        if (verticalActive === APVerticalModes.TO) {
          (_g = this.verticalModes.get(APVerticalModes.TO)) === null || _g === void 0 ? void 0 : _g.deactivate();
          toGaWasActive = true;
        }
        if (lateralActive === APLateralModes.TO) {
          (_h = this.lateralModes.get(APLateralModes.TO)) === null || _h === void 0 ? void 0 : _h.deactivate();
          toGaWasActive = true;
        }
        if (!toGaWasActive) {
          (_j = this.verticalModes.get(APVerticalModes.TO)) === null || _j === void 0 ? void 0 : _j.arm();
          (_k = this.lateralModes.get(APLateralModes.TO)) === null || _k === void 0 ? void 0 : _k.arm();
        }
      }
    }
    /**
     * Returns the AP Lateral Mode that can be armed.
     * @returns The AP Lateral Mode that can be armed.
     */
    getArmableApproachType() {
      switch (this.cdiSource.type) {
        case NavSourceType.Nav:
          if (this.cdiSource.index === 1 && this.apValues.nav1HasGs.get()) {
            return APLateralModes.LOC;
          } else if (this.cdiSource.index === 2 && this.apValues.nav2HasGs.get()) {
            return APLateralModes.LOC;
          } else if (this.cdiSource.index === 3 && this.apValues.nav3HasGs.get()) {
            return APLateralModes.LOC;
          } else if (this.cdiSource.index === 4 && this.apValues.nav4HasGs.get()) {
            return APLateralModes.LOC;
          }
          break;
        case NavSourceType.Gps:
          if (this.apValues.approachIsActive.get() && this.apValues.approachHasGP.get()) {
            return APLateralModes.GPSS;
          } else if (this.navToNavManager && this.navToNavManager.canLocArm()) {
            return APLateralModes.LOC;
          }
      }
      return APLateralModes.NONE;
    }
    /**
     * Callback to set the lateral active mode.
     * @param mode is the mode being set.
     */
    setLateralActive(mode) {
      const { lateralActive, lateralArmed } = this.apValues;
      this.checkRollModeActive();
      if (lateralArmed.get() === mode) {
        lateralArmed.set(APLateralModes.NONE);
      }
      if (mode !== lateralActive.get()) {
        const currentMode = this.lateralModes.get(lateralActive.get());
        currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        lateralActive.set(mode);
      }
    }
    /**
     * Callback to set the lateral armed mode.
     * @param mode is the mode being set.
     */
    setLateralArmed(mode) {
      const { lateralArmed } = this.apValues;
      const currentMode = this.lateralModes.get(lateralArmed.get());
      currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
      lateralArmed.set(mode);
    }
    /**
     * Callback to set the vertical active mode.
     * @param mode is the mode being set.
     */
    setVerticalActive(mode) {
      const { verticalActive, verticalArmed } = this.apValues;
      this.checkPitchModeActive();
      if (verticalArmed.get() === mode) {
        verticalArmed.set(APVerticalModes.NONE);
      } else if (this.verticalApproachArmed === mode) {
        this.verticalApproachArmed = APVerticalModes.NONE;
      }
      if (mode !== verticalActive.get()) {
        const currentMode = this.verticalModes.get(verticalActive.get());
        if ((currentMode === null || currentMode === void 0 ? void 0 : currentMode.state) !== DirectorState.Inactive) {
          currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        }
        verticalActive.set(mode);
      }
    }
    /**
     * Callback to set the vertical armed mode.
     * @param mode is the mode being set.
     */
    setVerticalArmed(mode) {
      const { verticalArmed } = this.apValues;
      if (mode !== verticalArmed.get()) {
        const currentMode = this.verticalModes.get(verticalArmed.get());
        if ((currentMode === null || currentMode === void 0 ? void 0 : currentMode.state) !== DirectorState.Inactive) {
          currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        }
      }
      verticalArmed.set(mode);
    }
    /**
     * Callback to set the vertical approach armed mode.
     * @param mode is the mode being set.
     */
    setVerticalApproachArmed(mode) {
      const currentMode = this.verticalModes.get(this.verticalApproachArmed);
      currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
      this.verticalApproachArmed = mode;
    }
    /**
     * Method called when the ALT button is pressed.
     */
    setAltHold() {
      var _a;
      if (this.verticalModes.has(APVerticalModes.ALT)) {
        const currentAlt = 10 * (this.inClimb ? Math.ceil(this.currentAltitude / 10) : Math.floor(this.currentAltitude / 10));
        this.apValues.capturedAltitude.set(currentAlt);
        (_a = this.verticalModes.get(APVerticalModes.ALT)) === null || _a === void 0 ? void 0 : _a.activate();
      }
    }
    /**
     * Initializes the Autopilot with the available lateral modes from the config.
     */
    initLateralModes() {
      if (this.directors.rollDirector) {
        this.lateralModes.set(APLateralModes.ROLL, this.directors.rollDirector);
        this.directors.rollDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.ROLL);
        };
      }
      if (this.directors.wingLevelerDirector) {
        this.lateralModes.set(APLateralModes.LEVEL, this.directors.wingLevelerDirector);
        this.directors.wingLevelerDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.LEVEL);
        };
      }
      if (this.directors.headingDirector) {
        this.lateralModes.set(APLateralModes.HEADING, this.directors.headingDirector);
        this.directors.headingDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.HEADING);
        };
      }
      if (this.directors.headingHoldDirector) {
        this.lateralModes.set(APLateralModes.HEADING_HOLD, this.directors.headingHoldDirector);
        this.directors.headingHoldDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.HEADING_HOLD);
        };
      }
      if (this.directors.trackDirector) {
        this.lateralModes.set(APLateralModes.TRACK, this.directors.trackDirector);
        this.directors.trackDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.TRACK);
        };
      }
      if (this.directors.trackHoldDirector) {
        this.lateralModes.set(APLateralModes.TRACK_HOLD, this.directors.trackHoldDirector);
        this.directors.trackHoldDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.TRACK_HOLD);
        };
      }
      if (this.directors.gpssDirector) {
        this.lateralModes.set(APLateralModes.GPSS, this.directors.gpssDirector);
        this.directors.gpssDirector.onArm = () => {
          this.setLateralArmed(APLateralModes.GPSS);
        };
        this.directors.gpssDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.GPSS);
        };
      }
      if (this.directors.vorDirector) {
        this.lateralModes.set(APLateralModes.VOR, this.directors.vorDirector);
        this.directors.vorDirector.onArm = () => {
          this.setLateralArmed(APLateralModes.VOR);
        };
        this.directors.vorDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.VOR);
        };
      }
      if (this.directors.locDirector) {
        this.lateralModes.set(APLateralModes.LOC, this.directors.locDirector);
        this.directors.locDirector.onArm = () => {
          this.setLateralArmed(APLateralModes.LOC);
        };
        this.directors.locDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.LOC);
        };
      }
      if (this.directors.bcDirector) {
        this.lateralModes.set(APLateralModes.BC, this.directors.bcDirector);
        this.directors.bcDirector.onArm = () => {
          this.setLateralArmed(APLateralModes.BC);
        };
        this.directors.bcDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.BC);
        };
      }
      if (this.directors.rolloutDirector) {
        this.lateralModes.set(APLateralModes.ROLLOUT, this.directors.rolloutDirector);
        this.directors.rolloutDirector.onArm = () => {
          this.setLateralArmed(APLateralModes.ROLLOUT);
        };
        this.directors.rolloutDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.ROLLOUT);
        };
      }
      if (this.directors.toLateralDirector) {
        this.lateralModes.set(APLateralModes.TO, this.directors.toLateralDirector);
        this.directors.toLateralDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.TO);
        };
      }
      if (this.directors.gaLateralDirector) {
        this.lateralModes.set(APLateralModes.GA, this.directors.gaLateralDirector);
        this.directors.gaLateralDirector.onActivate = () => {
          this.setLateralActive(APLateralModes.GA);
        };
      }
      this.lateralModes.set(APLateralModes.NONE, new APNoneLateralDirector());
    }
    /**
     * Initializes the Autopilot with the available Nav To Nav Manager.
     */
    initNavToNavManager() {
      if (this.navToNavManager) {
        this.navToNavManager.onTransferred = () => {
          var _a;
          if (this.apValues.lateralActive.get() === APLateralModes.GPSS) {
            (_a = this.lateralModes.get(APLateralModes.LOC)) === null || _a === void 0 ? void 0 : _a.activate();
          }
        };
      }
    }
    /**
     * Initializes the Autopilot with the available VNav Manager.
     */
    initVNavManager() {
      if (this.vnavManager) {
        this.vnavManager.armMode = (mode) => {
          var _a;
          const armedMode = this.apValues.verticalArmed.get();
          if (mode === APVerticalModes.NONE && (armedMode === APVerticalModes.PATH || armedMode === APVerticalModes.FLC)) {
            this.setVerticalArmed(mode);
          } else {
            (_a = this.verticalModes.get(mode)) === null || _a === void 0 ? void 0 : _a.arm();
          }
        };
        this.vnavManager.activateMode = (mode) => {
          var _a, _b;
          if (mode === APVerticalModes.NONE && this.apValues.verticalActive.get() === APVerticalModes.PATH) {
            (_a = this.verticalModes.get(this.getDefaultVerticalMode())) === null || _a === void 0 ? void 0 : _a.activate();
          } else {
            (_b = this.verticalModes.get(mode)) === null || _b === void 0 ? void 0 : _b.activate();
          }
        };
      }
    }
    /**
     * Initializes the Autopilot with the available vertical modes from the config.
     */
    initVerticalModes() {
      if (this.directors.pitchDirector) {
        this.verticalModes.set(APVerticalModes.PITCH, this.directors.pitchDirector);
        this.directors.pitchDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.PITCH);
        };
      }
      if (this.directors.vsDirector) {
        this.verticalModes.set(APVerticalModes.VS, this.directors.vsDirector);
        this.directors.vsDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.VS);
        };
      }
      if (this.directors.fpaDirector) {
        this.verticalModes.set(APVerticalModes.FPA, this.directors.fpaDirector);
        this.directors.fpaDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.FPA);
        };
      }
      if (this.directors.flcDirector) {
        this.verticalModes.set(APVerticalModes.FLC, this.directors.flcDirector);
        this.directors.flcDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.FLC);
        };
        this.directors.flcDirector.onArm = () => {
          this.setVerticalArmed(APVerticalModes.FLC);
        };
      }
      if (this.directors.altHoldDirector) {
        this.verticalModes.set(APVerticalModes.ALT, this.directors.altHoldDirector);
        this.directors.altHoldDirector.onArm = () => {
          this.setVerticalArmed(APVerticalModes.ALT);
        };
        this.directors.altHoldDirector.onActivate = () => {
          this.altCapArmed = false;
          this.setVerticalActive(APVerticalModes.ALT);
        };
      }
      if (this.directors.altCapDirector) {
        this.verticalModes.set(APVerticalModes.CAP, this.directors.altCapDirector);
        this.directors.altCapDirector.onArm = () => {
          var _a;
          this.altCapArmed = true;
          const verticalArmed = this.apValues.verticalArmed.get();
          if (verticalArmed === APVerticalModes.ALT) {
            (_a = this.verticalModes.get(verticalArmed)) === null || _a === void 0 ? void 0 : _a.deactivate();
          }
        };
        this.directors.altCapDirector.onActivate = () => {
          var _a;
          this.altCapArmed = false;
          this.setVerticalActive(APVerticalModes.CAP);
          (_a = this.verticalModes.get(APVerticalModes.ALT)) === null || _a === void 0 ? void 0 : _a.arm();
        };
      }
      if (this.directors.vnavPathDirector) {
        this.verticalModes.set(APVerticalModes.PATH, this.directors.vnavPathDirector);
        this.directors.vnavPathDirector.onArm = () => {
          this.setVerticalArmed(APVerticalModes.PATH);
        };
        this.directors.vnavPathDirector.onDeactivate = () => {
          var _a;
          (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.onPathDirectorDeactivated();
        };
        this.directors.vnavPathDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.PATH);
        };
      }
      if (this.directors.gpDirector) {
        this.verticalModes.set(APVerticalModes.GP, this.directors.gpDirector);
        this.directors.gpDirector.onArm = () => {
          this.setVerticalApproachArmed(APVerticalModes.GP);
        };
        this.directors.gpDirector.onActivate = () => {
          var _a;
          (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.tryDeactivate(APVerticalModes.NONE);
          this.setVerticalActive(APVerticalModes.GP);
          this.setVerticalArmed(APVerticalModes.NONE);
        };
      }
      if (this.directors.gsDirector) {
        this.verticalModes.set(APVerticalModes.GS, this.directors.gsDirector);
        this.directors.gsDirector.onArm = () => {
          this.setVerticalApproachArmed(APVerticalModes.GS);
        };
        this.directors.gsDirector.onActivate = () => {
          var _a;
          this.setVerticalActive(APVerticalModes.GS);
          (_a = this.verticalModes.get(APVerticalModes.PATH)) === null || _a === void 0 ? void 0 : _a.deactivate();
          this.setVerticalArmed(APVerticalModes.NONE);
          this.setVerticalApproachArmed(APVerticalModes.NONE);
        };
      }
      if (this.directors.flareDirector) {
        this.verticalModes.set(APVerticalModes.FLARE, this.directors.flareDirector);
        this.directors.flareDirector.onArm = () => {
          this.setVerticalArmed(APVerticalModes.FLARE);
        };
        this.directors.flareDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.FLARE);
          this.setVerticalArmed(APVerticalModes.NONE);
          this.setVerticalApproachArmed(APVerticalModes.NONE);
        };
      }
      if (this.directors.toVerticalDirector) {
        this.verticalModes.set(APVerticalModes.TO, this.directors.toVerticalDirector);
        this.directors.toVerticalDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.TO);
        };
      }
      if (this.directors.gaVerticalDirector) {
        this.verticalModes.set(APVerticalModes.GA, this.directors.gaVerticalDirector);
        this.directors.gaVerticalDirector.onActivate = () => {
          this.setVerticalActive(APVerticalModes.GA);
        };
      }
      this.verticalModes.set(APVerticalModes.NONE, new APNoneVerticalDirector());
    }
    /**
     * Checks if all the active and armed modes are still in their proper state
     * and takes corrective action if not.
     */
    checkModes() {
      var _a, _b, _c, _d, _e, _f, _g;
      if (this.lateralModeFailed) {
        this.lateralModeFailed = false;
      }
      if (!this.stateManager.apMasterOn.get() && !this.stateManager.isFlightDirectorOn.get()) {
        return;
      }
      const { lateralActive, lateralArmed, verticalActive, verticalArmed } = this.apValues;
      if (!this.lateralModes.has(lateralActive.get()) || ((_a = this.lateralModes.get(lateralActive.get())) === null || _a === void 0 ? void 0 : _a.state) !== DirectorState.Active) {
        if (lateralActive.get() !== APLateralModes.NONE) {
          this.lateralModeFailed = true;
        }
        (_b = this.lateralModes.get(this.getDefaultLateralMode())) === null || _b === void 0 ? void 0 : _b.arm();
      }
      if (lateralArmed.get() !== APLateralModes.NONE && (!this.lateralModes.has(lateralArmed.get()) || ((_c = this.lateralModes.get(lateralArmed.get())) === null || _c === void 0 ? void 0 : _c.state) !== DirectorState.Armed)) {
        this.setLateralArmed(APLateralModes.NONE);
      }
      if (!this.verticalModes.has(verticalActive.get()) || ((_d = this.verticalModes.get(verticalActive.get())) === null || _d === void 0 ? void 0 : _d.state) !== DirectorState.Active) {
        (_e = this.verticalModes.get(this.getDefaultVerticalMode())) === null || _e === void 0 ? void 0 : _e.arm();
      }
      if (verticalArmed.get() !== APVerticalModes.NONE && (!this.verticalModes.has(verticalArmed.get()) || ((_f = this.verticalModes.get(verticalArmed.get())) === null || _f === void 0 ? void 0 : _f.state) !== DirectorState.Armed)) {
        this.setVerticalArmed(APVerticalModes.NONE);
      }
      if (this.verticalApproachArmed !== APVerticalModes.NONE && (!this.verticalModes.has(this.verticalApproachArmed) || ((_g = this.verticalModes.get(this.verticalApproachArmed)) === null || _g === void 0 ? void 0 : _g.state) !== DirectorState.Armed)) {
        this.setVerticalApproachArmed(APVerticalModes.NONE);
      }
    }
    /**
     * Runs update on each of the active and armed modes.
     */
    updateModes() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const { lateralActive, lateralArmed, verticalActive, verticalArmed } = this.apValues;
      if (lateralActive.get() !== APLateralModes.NONE && lateralActive.get() !== APLateralModes.GPSS && this.lateralModes.has(lateralActive.get())) {
        (_a = this.lateralModes.get(lateralActive.get())) === null || _a === void 0 ? void 0 : _a.update();
      }
      if (lateralArmed.get() !== APLateralModes.NONE && lateralArmed.get() !== APLateralModes.GPSS && this.lateralModes.has(lateralArmed.get())) {
        (_b = this.lateralModes.get(lateralArmed.get())) === null || _b === void 0 ? void 0 : _b.update();
      }
      if (verticalActive.get() !== APVerticalModes.NONE && this.verticalModes.has(verticalActive.get())) {
        (_c = this.verticalModes.get(verticalActive.get())) === null || _c === void 0 ? void 0 : _c.update();
      }
      if (verticalArmed.get() !== APVerticalModes.NONE && this.verticalModes.has(verticalArmed.get())) {
        (_d = this.verticalModes.get(verticalArmed.get())) === null || _d === void 0 ? void 0 : _d.update();
      }
      if (this.verticalApproachArmed !== APVerticalModes.NONE && this.verticalModes.has(this.verticalApproachArmed)) {
        (_e = this.verticalModes.get(this.verticalApproachArmed)) === null || _e === void 0 ? void 0 : _e.update();
      }
      if (this.altCapArmed) {
        (_f = this.verticalModes.get(APVerticalModes.CAP)) === null || _f === void 0 ? void 0 : _f.update();
      }
      (_g = this.vnavManager) === null || _g === void 0 ? void 0 : _g.update();
      (_h = this.lateralModes.get(APLateralModes.GPSS)) === null || _h === void 0 ? void 0 : _h.update();
    }
    /**
     * Checks and sets the proper armed altitude mode.
     */
    manageAltitudeCapture() {
      var _a, _b, _c;
      let altCapType = APAltitudeModes.NONE;
      let armAltCap = false;
      switch (this.apValues.verticalActive.get()) {
        case APVerticalModes.VS:
        case APVerticalModes.FPA:
        case APVerticalModes.FLC:
        case APVerticalModes.PITCH:
        case APVerticalModes.TO:
        case APVerticalModes.GA:
          if (this.inClimb && this.apValues.selectedAltitude.get() > this.currentAltitude) {
            altCapType = APAltitudeModes.ALTS;
            armAltCap = true;
          } else if (!this.inClimb && this.apValues.selectedAltitude.get() < this.currentAltitude) {
            altCapType = APAltitudeModes.ALTS;
            armAltCap = true;
          }
          break;
        case APVerticalModes.PATH: {
          if (!this.inClimb) {
            altCapType = this.vnavCaptureType === VNavAltCaptureType.VNAV ? APAltitudeModes.ALTV : APAltitudeModes.ALTS;
          }
          break;
        }
        case APVerticalModes.CAP:
          altCapType = this.verticalAltitudeArmed;
          break;
      }
      if (this.verticalAltitudeArmed !== altCapType) {
        this.verticalAltitudeArmed = altCapType;
      }
      if (armAltCap && (!this.altCapArmed || ((_a = this.verticalModes.get(APVerticalModes.CAP)) === null || _a === void 0 ? void 0 : _a.state) === DirectorState.Inactive)) {
        (_b = this.verticalModes.get(APVerticalModes.CAP)) === null || _b === void 0 ? void 0 : _b.arm();
      } else if (!armAltCap && this.altCapArmed) {
        (_c = this.verticalModes.get(APVerticalModes.CAP)) === null || _c === void 0 ? void 0 : _c.deactivate();
        this.altCapArmed = false;
      }
    }
    /**
     * Monitors subevents and bus events.
     */
    monitorEvents() {
      var _a;
      this.stateManager.lateralPressed.on((sender, data) => {
        if (this.autopilotInitialized && data !== void 0) {
          this.lateralPressed(data);
        }
      });
      this.stateManager.verticalPressed.on((sender, data) => {
        if (this.autopilotInitialized && data !== void 0) {
          this.verticalPressed(data);
        }
      });
      this.stateManager.approachPressed.on((sender, data) => {
        if (this.autopilotInitialized) {
          this.approachPressed(data);
        }
      });
      this.stateManager.vnavPressed.on((sender, data) => {
        var _a2, _b;
        if (this.autopilotInitialized) {
          if (data === true) {
            (_a2 = this.vnavManager) === null || _a2 === void 0 ? void 0 : _a2.tryActivate();
          } else {
            (_b = this.vnavManager) === null || _b === void 0 ? void 0 : _b.tryDeactivate();
          }
        }
      });
      this.monitorApSpeedValues();
      const ap = this.bus.getSubscriber();
      ap.on(`ap_altitude_selected_${(_a = this.config.altitudeHoldSlotIndex) !== null && _a !== void 0 ? _a : 1}`).withPrecision(0).handle((alt) => {
        this.apValues.selectedAltitude.set(alt);
      });
      ap.on("ap_heading_selected").withPrecision(0).handle((hdg) => {
        this.apValues.selectedHeading.set(hdg);
      });
      ap.on("ap_pitch_selected").withPrecision(1).handle((pitch) => {
        this.apValues.selectedPitch.set(pitch);
      });
      ap.on("ap_vs_selected").withPrecision(0).handle((ias) => {
        this.apValues.selectedVerticalSpeed.set(ias);
      });
      ap.on("ap_fpa_selected").withPrecision(1).handle((fpa) => {
        this.apValues.selectedFlightPathAngle.set(fpa);
      });
      ap.on("ap_max_bank_id").handle((id) => {
        this.apValues.maxBankId.set(id);
      });
      const nav = this.bus.getSubscriber();
      nav.on("cdi_select").handle((src) => {
        this.cdiSource = src;
      });
      const navproc = this.bus.getSubscriber();
      navproc.on("nav_glideslope_1").whenChanged().handle((hasgs) => {
        this.apValues.nav1HasGs.set(hasgs);
      });
      navproc.on("nav_glideslope_2").whenChanged().handle((hasgs) => {
        this.apValues.nav2HasGs.set(hasgs);
      });
      navproc.on("nav_glideslope_3").whenChanged().handle((hasgs) => {
        this.apValues.nav3HasGs.set(hasgs);
      });
      navproc.on("nav_glideslope_4").whenChanged().handle((hasgs) => {
        this.apValues.nav4HasGs.set(hasgs);
      });
      const adc = this.bus.getSubscriber();
      adc.on("vertical_speed").withPrecision(0).handle((vs) => {
        this.inClimb = vs < 1 ? false : true;
      });
      adc.on("indicated_alt").withPrecision(0).handle((alt) => {
        this.currentAltitude = alt;
      });
      const vnav = this.bus.getSubscriber();
      vnav.on("vnav_altitude_capture_type").whenChanged().handle((v) => {
        this.vnavCaptureType = v;
      });
      this.stateManager.apMasterOn.sub(() => {
        if (this.autopilotInitialized) {
          this.handleApFdStateChange();
        }
      });
      this.stateManager.isFlightDirectorOn.sub(() => {
        if (this.autopilotInitialized) {
          this.handleApFdStateChange();
        }
      });
      this.bus.getSubscriber().on("approach_available").handle((available) => {
        this.apValues.approachIsActive.set(available);
      });
    }
    /**
     * Overridable method for setting the selected speed values for the A/P to follow.
     */
    monitorApSpeedValues() {
      const ap = this.bus.getSubscriber();
      ap.on("ap_ias_selected").withPrecision(0).handle((ias) => {
        this.apValues.selectedIas.set(ias);
      });
      ap.on("ap_mach_selected").withPrecision(3).handle((mach) => {
        this.apValues.selectedMach.set(mach);
      });
      ap.on("ap_selected_speed_is_mach").whenChanged().handle((inMach) => {
        this.apValues.isSelectedSpeedInMach.set(inMach);
      });
    }
    /**
     * Additional events to be monitored (to be overridden).
     */
    monitorAdditionalEvents() {
    }
    /**
     * Manages the FD state and the modes when AP/FD are off.
     */
    handleApFdStateChange() {
      const ap = this.stateManager.apMasterOn.get();
      const fd = this.stateManager.isFlightDirectorOn.get();
      if (ap && !fd) {
        this.stateManager.setFlightDirector(true);
      } else if (!ap && !fd) {
        this.lateralModes.forEach((mode) => {
          if (mode.state !== DirectorState.Inactive) {
            mode.deactivate();
          }
        });
        this.verticalModes.forEach((mode) => {
          if (mode.state !== DirectorState.Inactive) {
            mode.deactivate();
          }
        });
        this.apValues.lateralActive.set(APLateralModes.NONE);
        this.apValues.lateralArmed.set(APLateralModes.NONE);
        this.apValues.verticalActive.set(APVerticalModes.NONE);
        this.apValues.verticalArmed.set(APVerticalModes.NONE);
        this.verticalApproachArmed = APVerticalModes.NONE;
        this.verticalAltitudeArmed = APAltitudeModes.NONE;
        this.altCapArmed = false;
      }
    }
    /**
     * Sets a sim AP mode.
     * @param mode The mode to set.
     * @param enabled Whether or not the mode is enabled or disabled.
     */
    setSimAP(mode, enabled) {
      Coherent.call("apSetAutopilotMode", mode, enabled ? 1 : 0);
    }
    /**
     * Checks if the sim AP is in roll mode and sets it if not.
     */
    checkRollModeActive() {
      if (!APController.apGetAutopilotModeActive(MSFSAPStates.Bank)) {
        this.setSimAP(MSFSAPStates.Bank, true);
      }
    }
    /**
     * Checks if the sim AP is in pitch mode and sets it if not.
     */
    checkPitchModeActive() {
      if (!APController.apGetAutopilotModeActive(MSFSAPStates.Pitch)) {
        this.setSimAP(MSFSAPStates.Pitch, true);
      }
    }
    /**
     * Get the default lateral mode from APConfig
     * @returns default lateral mode
     */
    getDefaultLateralMode() {
      if (typeof this.config.defaultLateralMode === "number") {
        return this.config.defaultLateralMode;
      } else {
        return this.config.defaultLateralMode();
      }
    }
    /**
     * Get the default vertical mode from APConfig
     * @returns default vertical mode
     */
    getDefaultVerticalMode() {
      if (typeof this.config.defaultVerticalMode === "number") {
        return this.config.defaultVerticalMode;
      } else {
        return this.config.defaultVerticalMode();
      }
    }
  };
  var VNavUtils = class {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg) {
      if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1 || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
        return true;
      }
      return false;
    }
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
      const delta = targetAltitude - currentAltitude;
      const minutesToConstraint = distance / groundSpeed * 60;
      return delta / minutesToConstraint;
    }
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
      return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs, groundspeed) {
      return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets the flight path angle for a given distance and altitude. Positive flight path angles represent an ascending
     * flight path.
     * @param distance The distance to get the angle for, in the same unit as `altitude`.
     * @param altitude The altitude to get the angle for, in the same unit as `distance`.
     * @returns The required flight path angle, in degrees.
     */
    static getFpa(distance, altitude) {
      return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance covered.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance covered.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance covered,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa, distance) {
      return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets the lateral distance covered along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance covered along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa, altitude) {
      return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
            return l;
          }
        }
      }
      return Math.max(0, plan.length - 1);
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
            return l;
          }
        }
      }
      return void 0;
    }
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan, iterator) {
      let fafIndex = -1;
      iterator.iterateReverse(lateralPlan, (cursor) => {
        if (fafIndex === -1 && cursor.legDefinition && cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF) {
          fafIndex = cursor.legIndex + cursor.segment.offset;
        }
      });
      fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
      return fafIndex;
    }
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
        if (verticalPlan.constraints[c].index >= globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        if (verticalPlan.constraints[c].index < globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan, globalLegIndex) {
      const constraintIndex = verticalPlan.constraints.findIndex((c) => c.index === globalLegIndex);
      if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
        return true;
      }
      return false;
    }
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
      var _a, _b;
      return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint) {
      let distance = 0;
      for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
        distance += constraint.legs[legIndex].distance;
      }
      return distance;
    }
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
      let distance = 0;
      const startGlobalIndex = previousConstraint !== void 0 ? previousConstraint.index + 1 : 0;
      for (let i = startGlobalIndex; i <= constraint.index; i++) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
        distance += verticalLeg.distance;
      }
      return distance;
    }
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
      if (activeLegIndex > constraint.index) {
        return 0;
      }
      let distance = 0;
      let index = activeLegIndex;
      for (const leg of lateralPlan.legs(false, activeLegIndex)) {
        if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
          return Number.POSITIVE_INFINITY;
        } else if (leg.calculated !== void 0) {
          distance += leg.calculated.distanceWithTransitions;
        }
        if (++index > constraint.index) {
          break;
        }
      }
      distance -= distanceAlongLeg;
      return distance;
    }
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint, out) {
      if (constraint.maxAltitude === constraint.minAltitude) {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      } else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
        switch (constraint.type) {
          case "climb":
          case "missed":
            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            }
            break;
          default:
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            }
        }
      } else {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      }
      return out;
    }
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
      if (verticalPlan.constraints.length > 0) {
        if (selectedGlobalLegIndex < activeLegIndex) {
          return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
        }
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
          const constraint = verticalPlan.constraints[c];
          if (constraint.index === selectedGlobalLegIndex || c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index) {
            return constraint;
          } else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
            return verticalPlan.constraints[c + 1];
          }
        }
      }
      return void 0;
    }
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if ((constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.minAltitude : void 0;
    }
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint) {
        if (currentConstraint.type === "climb" && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return currentConstraint;
        } else if (currentConstraint.type === "climb" && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
          const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== void 0 ? VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
          for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === "climb" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              return constraint;
            }
          }
        }
      }
      return void 0;
    }
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if (constraint.type === "missed" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint.targetAltitude;
      }
      const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
      return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan) {
      if (verticalPlan.fafLegIndex !== void 0) {
        return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
      }
      return void 0;
    }
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
      var _a;
      out.todLegIndex = -1;
      out.bodLegIndex = -1;
      out.todLegDistance = 0;
      out.distanceFromTod = 0;
      out.distanceFromBod = 0;
      out.currentConstraintLegIndex = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (
        // ... there is no active VNAV constraint.
        !activeConstraint || (activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== void 0 && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex
      ) {
        return out;
      }
      out.currentConstraintLegIndex = activeConstraint.index;
      const altitude = currentAltitude - currentVS / 20;
      let bodConstraintIndex, bodConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
          bodConstraintIndex = i;
          bodConstraint = constraint;
          break;
        }
      }
      if (!bodConstraint) {
        return out;
      }
      out.bodLegIndex = bodConstraint.index;
      let todConstraintIndex = bodConstraintIndex;
      for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const prevConstraint = verticalPlan.constraints[i + 1];
        if (!prevConstraint || prevConstraint.index < activeLegIndex || prevConstraint.type === "climb" || prevConstraint.type === "missed" || prevConstraint.targetAltitude > altitude || prevConstraint.fpa <= 0 || prevConstraint.isPathEnd) {
          todConstraintIndex = i;
          break;
        }
      }
      const todConstraint = verticalPlan.constraints[todConstraintIndex];
      let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
      let constraintIndex = todConstraintIndex;
      let todLegIndex = todConstraint.index;
      let todLegDistance = 0;
      let todLeg = todConstraint.legs[0];
      while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
        const constraint = verticalPlan.constraints[constraintIndex];
        for (let i = 0; i < constraint.legs.length; i++) {
          if (!constraint.legs[i].isEligible) {
            constraintIndex = verticalPlan.constraints.length;
            break;
          }
          todLeg = constraint.legs[i];
          distance -= todLeg.distance;
          if (distance <= 0) {
            todLegIndex = constraint.index - i;
            todLegDistance = todLeg.distance + distance;
            break;
          }
        }
        constraintIndex++;
      }
      if (distance > 0) {
        todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
        todLegDistance = todLeg.distance;
      }
      out.todLegIndex = todLegIndex;
      out.todLegDistance = todLegDistance;
      let globalLegIndex = bodConstraint.index;
      let distanceToBOD = 0, distanceToTOD = 0;
      let hasReachedTOD = false;
      let isDone = false;
      for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const constraint = verticalPlan.constraints[i];
        for (let j = 0; j < constraint.legs.length; j++) {
          const leg = constraint.legs[j];
          if (globalLegIndex === todLegIndex) {
            distanceToTOD -= todLegDistance;
            hasReachedTOD = true;
          }
          if (globalLegIndex > activeLegIndex) {
            distanceToBOD += leg.distance;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance;
            }
          } else if (globalLegIndex === activeLegIndex) {
            distanceToBOD += leg.distance - distanceAlongLeg;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance - distanceAlongLeg;
              isDone = true;
            } else {
              distanceToTOD -= distanceAlongLeg;
            }
          } else {
            if (hasReachedTOD) {
              isDone = true;
            } else {
              distanceToTOD -= leg.distance;
            }
          }
          if (isDone) {
            break;
          } else {
            globalLegIndex--;
          }
        }
        if (isDone) {
          break;
        }
      }
      out.distanceFromBod = distanceToBOD;
      out.distanceFromTod = distanceToTOD;
      return out;
    }
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
      var _a, _b;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (
        // ... there is no active VNAV constraint.
        !activeConstraint || activeConstraint.type !== "climb" && activeConstraint.type !== "missed"
      ) {
        return out;
      }
      let tocConstraintIndex, tocConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (isFinite(constraint.maxAltitude)) {
          tocConstraintIndex = i;
          tocConstraint = constraint;
          break;
        }
      }
      if (!tocConstraint) {
        return out;
      }
      out.tocConstraintIndex = tocConstraintIndex;
      out.tocAltitude = tocConstraint.maxAltitude;
      const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
      let tocLegIndex;
      let currentConstraintIndex = activeConstraintIndex;
      let currentConstraint;
      let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
      let currentLeg = activeLeg;
      const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
      if (distanceRemaining > activeLegDistanceRemaining) {
        distanceRemaining -= activeLegDistanceRemaining;
        if (currentConstraintLegIndex <= 0) {
          --currentConstraintIndex;
        } else {
          currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
        }
        while (currentConstraintIndex >= tocConstraintIndex) {
          currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          currentLeg = currentConstraint.legs[currentConstraintLegIndex];
          if (currentLeg !== void 0) {
            if (distanceRemaining > currentLeg.distance) {
              out.distanceFromToc += currentLeg.distance;
              distanceRemaining -= currentLeg.distance;
            } else {
              out.distanceFromToc += distanceRemaining;
              tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
              distanceRemaining -= currentLeg.distance;
              break;
            }
          }
          if (currentConstraintLegIndex <= 0) {
            --currentConstraintIndex;
          } else {
            currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
          }
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = tocConstraint.index;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      let lastClimbConstraintIndex = tocConstraintIndex;
      let bocConstraintIndex, bocConstraint;
      for (let i = tocConstraintIndex - 1; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (constraint.maxAltitude > tocConstraint.maxAltitude) {
          bocConstraintIndex = i;
          bocConstraint = constraint;
          break;
        }
        lastClimbConstraintIndex = i;
      }
      let bocDistanceStopConstraintIndex = void 0;
      if (bocConstraint) {
        out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
        bocDistanceStopConstraintIndex = bocConstraintIndex;
      } else {
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
          out.bocLegIndex = lastClimbConstraint.index + 1;
          bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
        }
      }
      if (bocDistanceStopConstraintIndex !== void 0) {
        let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
          distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
        }
        out.distanceFromBoc = distanceToEndOfActiveConstraint;
        for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
          out.distanceFromBoc += verticalPlan.constraints[i].distance;
        }
      }
      return out;
    }
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
      const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
      const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
      const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
      if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
        return out;
      }
      const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
      const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
      if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
        const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
        out.bocLegIndex = lastClimbConstraint.index + 1;
        out.distanceFromBoc = activeLegDistanceRemaining + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
      }
      const deltaAltitude = cruiseAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      let tocLegIndex;
      const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
      if (distanceRemaining > activeLegDistanceRemaining) {
        let legIndex = activeLegIndex + 1;
        for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
          const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
          if (distanceRemaining > legDistance) {
            out.distanceFromToc += legDistance;
            distanceRemaining -= legDistance;
          } else {
            out.distanceFromToc += distanceRemaining;
            tocLegIndex = legIndex;
            distanceRemaining -= legDistance;
            break;
          }
          legIndex++;
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = lastLegIndex;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      out.tocAltitude = cruiseAltitude;
      return out;
    }
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset] !== void 0;
        }
      }
      return false;
    }
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset];
        }
      }
      throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
      const segment = verticalPlan.segments[segmentIndex];
      const leg = segment.legs[legIndex];
      if (segment && leg) {
        return leg;
      } else {
        throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
      }
    }
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
      return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan) {
      return verticalPlan.segments;
    }
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
      if (lateralLeg.leg !== void 0) {
        switch (lateralLeg.leg.type) {
          case LegType.HA:
          case LegType.HF:
          case LegType.HM:
          case LegType.PI:
            return true;
        }
      }
      return false;
    }
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index, minAltitude, maxAltitude, name, type = "descent") {
      return {
        index,
        minAltitude,
        maxAltitude,
        targetAltitude: 0,
        name,
        isTarget: false,
        isPathEnd: false,
        distance: 0,
        fpa: 0,
        legs: [],
        type,
        isBeyondFaf: false
      };
    }
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
      return {
        segmentIndex,
        legIndex,
        fpa: 0,
        altitude: 0,
        isUserDefined: false,
        isDirectToTarget: false,
        distance,
        isEligible: true,
        isBod: false,
        isAdvisory: true,
        name
      };
    }
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan) {
      for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan) {
      let index = -1;
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        const type = verticalPlan.constraints[c].type;
        if (type === "descent" || type === "manual") {
          index = c;
        }
        if (type === "direct") {
          return c;
        }
      }
      return index;
    }
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        const type = verticalPlan.constraints[i].type;
        if (type === "descent" || type === "direct" || type === "manual") {
          return i;
        }
      }
      return -1;
    }
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a, b) {
      return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a, b) {
      return a.type === b.type && a.altitude === b.altitude;
    }
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a, b) {
      return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint) && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed) {
      if (groundSpeed <= 190) {
        return 100;
      } else if (groundSpeed >= 210) {
        return 250;
      } else {
        return 100 + (groundSpeed - 190) / 20 * 150;
      }
    }
  };
  var GpsSynchronizer = class {
    /**
     * Creates an instance of GpsSynchronizer.
     * @param bus The bus to source events from.
     * @param flightPlanner An instance of the flight planner.
     * @param facLoader An instance of the facility loader.
     */
    constructor(bus, flightPlanner, facLoader) {
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.facLoader = facLoader;
      this.magvar = 0;
      this.distanceToCurrentLeg = -1;
      this.groundSpeed = 0;
      this.trueTrack = 0;
      this.zuluTime = 0;
      this.numPlanLegs = Subject.create(0);
      this.hasReachedDestination = Subject.create(false);
      this.isDestinationLegActive = Subject.create(false);
      this.isDirectToActive = Subject.create(false);
      this.gpFpa = ConsumerSubject.create(this.bus.getSubscriber().on("gp_fpa").whenChanged(), 0);
      this.gpDeviation = ConsumerSubject.create(this.bus.getSubscriber().on("gp_vertical_deviation").whenChangedBy(1), 0);
      this.isApproachActive = Subject.create(false);
      this.gpAvailable = ConsumerSubject.create(this.bus.getSubscriber().on("gp_available").whenChanged(), false);
      this.gsiScaling = ConsumerSubject.create(this.bus.getSubscriber().on("gp_gsi_scaling").whenChanged(), UnitType.FOOT.convertTo(1e3, UnitType.METER));
      this.onDirectToActive = (state) => {
        SimVar.SetSimVarValue("GPS IS DIRECTTO FLIGHTPLAN", SimVarValueType.Bool, state);
      };
      this.onDestinationReached = (state) => {
        SimVar.SetSimVarValue("GPS IS ARRIVED", SimVarValueType.Bool, state);
      };
      this.onGpDeviation = (deviation) => {
        const deviationMeters = UnitType.FOOT.convertTo(deviation, UnitType.METER);
        SimVar.SetSimVarValue("GPS VERTICAL ERROR", SimVarValueType.Meters, -deviationMeters);
      };
      this.onGpFpa = (fpa) => {
        SimVar.SetSimVarValue("GPS VERTICAL ANGLE", SimVarValueType.Degree, fpa);
      };
      this.onApproachActive = (isApproachActive) => {
        SimVar.SetSimVarValue("GPS IS APPROACH ACTIVE", SimVarValueType.Bool, isApproachActive);
      };
      this.onApproachHasGp = (approachHasGp) => {
        SimVar.SetSimVarValue("GPS HAS GLIDEPATH", SimVarValueType.Bool, approachHasGp);
      };
      this.onGsiScaling = (gsiScaling) => {
        SimVar.SetSimVarValue("GPS GSI SCALING", SimVarValueType.Meters, gsiScaling);
      };
      const lnav = bus.getSubscriber();
      lnav.on("lnavdata_dtk_mag").handle(this.onDtkChanged.bind(this));
      lnav.on("lnavdata_xtk").handle(this.onXtkChanged.bind(this));
      lnav.on("lnavdata_waypoint_distance").handle(this.onLnavDistanceChanged.bind(this));
      lnav.on("lnavdata_waypoint_bearing_mag").handle(this.onLnavBearingChanged.bind(this));
      lnav.on("lnavdata_destination_distance").handle(this.onLnavDistanceToDestinationChanged.bind(this));
      lnav.on("lnav_course_to_steer").handle(this.onLNavCourseToSteerChanged.bind(this));
      lnav.on("lnavdata_cdi_scale").whenChanged().handle(this.onCdiScaleChanged.bind(this));
      const ahrs = bus.getSubscriber();
      ahrs.on("hdg_deg_true").handle(this.onTrueHeadingChanged.bind(this));
      const vnav = bus.getSubscriber();
      vnav.on("vnav_required_vs").handle((vs) => {
        if (!this.isApproachActive.get() || !this.gpAvailable.get()) {
          this.requiredVsChanged(vs);
        }
      });
      vnav.on("gp_required_vs").handle((vs) => {
        if (this.isApproachActive.get() && this.gpAvailable.get()) {
          this.requiredVsChanged(vs);
        }
      });
      vnav.on("vnav_target_altitude").handle(this.onTargetAltChanged.bind(this));
      vnav.on("vnav_active_leg_alt").handle(this.onActiveLegAltChanged.bind(this));
      vnav.on("gp_distance").handle(this.onGpDistanceChanged.bind(this));
      const gnss = bus.getSubscriber();
      gnss.on("gps-position").handle(this.onPositionChanged.bind(this));
      gnss.on("zulu_time").handle((t) => this.zuluTime = t);
      gnss.on("track_deg_true").handle(this.onTrackTrueChanged.bind(this));
      gnss.on("ground_speed").handle(this.onGroundSpeedChanged.bind(this));
      gnss.on("magvar").handle(this.onMagvarChanged.bind(this));
      const plan = bus.getSubscriber();
      plan.on("fplActiveLegChange").handle(() => {
        this.hasReachedDestination.set(false);
        if (this.flightPlanner.hasActiveFlightPlan()) {
          const activeFlightplan = this.flightPlanner.getActiveFlightPlan();
          this.checkDestinationLegActive(activeFlightplan);
          this.checkDirectToState(activeFlightplan);
          this.onIsPrevLegChanged(activeFlightplan);
          this.onWaypointIndexChanged(activeFlightplan);
        }
      });
      plan.on("fplSegmentChange").handle(this.onPlanChanged.bind(this));
      plan.on("fplIndexChanged").handle(this.onPlanChanged.bind(this));
      this.numPlanLegs.sub(this.onNumLegsChanged.bind(this));
      this.isDirectToActive.sub(this.onDirectToActive, true);
      this.hasReachedDestination.sub(this.onDestinationReached, true);
      this.gpDeviation.sub(this.onGpDeviation, true);
      this.gpFpa.sub(this.onGpFpa, true);
      this.isApproachActive.sub(this.onApproachActive, true);
      this.gpAvailable.sub(this.onApproachHasGp, true);
      this.gsiScaling.sub(this.onGsiScaling, true);
    }
    /**
     * Updates the GpsSynchronizer.
     */
    update() {
      const isGpsOverridden = SimVar.GetSimVarValue("GPS OVERRIDDEN", SimVarValueType.Bool);
      if (!isGpsOverridden) {
        SimVar.SetSimVarValue("GPS OVERRIDDEN", SimVarValueType.Bool, true);
      }
      let numPlanLegs = 0;
      if (this.flightPlanner.hasActiveFlightPlan()) {
        const plan = this.flightPlanner.getActiveFlightPlan();
        numPlanLegs = plan.length;
      }
      this.numPlanLegs.set(numPlanLegs);
    }
    /**
     * Handles when the active plan segments are changed.
     */
    onPlanChanged() {
      const plan = this.flightPlanner.getActiveFlightPlan();
      const approachSegments = [...plan.segmentsOfType(FlightPlanSegmentType.Approach)];
      if (approachSegments && approachSegments.length > 0) {
        SimVar.SetSimVarValue("GPS IS APPROACH LOADED", SimVarValueType.Bool, true);
      } else {
        SimVar.SetSimVarValue("GPS IS APPROACH LOADED", SimVarValueType.Bool, false);
      }
      this.checkApproachTypeAndTimezone(plan, plan.procedureDetails.approachIndex);
      this.hasReachedDestination.set(false);
      this.checkDestinationLegActive(plan);
      this.checkDirectToState(plan);
      this.onIsPrevLegChanged(plan);
      this.onWaypointIndexChanged(plan);
    }
    /**
     * Handles when the course steered by LNAV changes.
     * @param course The course steered by LNAV, in degrees true.
     */
    onLNavCourseToSteerChanged(course) {
      SimVar.SetSimVarValue("GPS COURSE TO STEER", SimVarValueType.Radians, UnitType.DEGREE.convertTo(course, UnitType.RADIAN));
    }
    /**
     * Checks to see if we are in a direct to state.
     * @param plan The Active Flight Plan.
     */
    checkDirectToState(plan) {
      let isDirectToActive = false;
      if (plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
        const activeLeg = plan.getLeg(plan.activeLateralLeg);
        isDirectToActive = BitFlags.isAll(activeLeg.flags, LegDefinitionFlags.DirectTo);
      }
      this.isDirectToActive.set(isDirectToActive);
    }
    /**
     * Checks to see if we have reached the plan destination.
     * @param plan The Active Flight Plan
     */
    checkDestinationLegActive(plan) {
      if (plan.length > 1) {
        const finalSegment = plan.getSegment(plan.getSegmentIndex(plan.length - 1));
        const isApproachActive = plan.activeLateralLeg > finalSegment.offset && finalSegment.segmentType === FlightPlanSegmentType.Approach;
        this.isApproachActive.set(isApproachActive);
        let destinationLegIndex = plan.length - 1;
        let fafIndex = -1;
        if (isApproachActive) {
          for (let i = finalSegment.legs.length - 1; i >= 0; i--) {
            const leg = finalSegment.legs[i];
            if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
              destinationLegIndex = i + finalSegment.offset;
            }
            if (leg.leg.fixTypeFlags === FixTypeFlags.FAF) {
              fafIndex = i + finalSegment.offset;
              break;
            }
          }
        }
        this.checkApproachMode(plan, isApproachActive, fafIndex);
        if (!this.hasReachedDestination.get() && destinationLegIndex === plan.activeLateralLeg) {
          this.isDestinationLegActive.set(true);
          return;
        }
      } else {
        this.checkApproachMode(plan, false, -1);
      }
      this.isDestinationLegActive.set(false);
    }
    /**
     * Checks the approach mode on leg change.
     * @param plan The Active Flight Plan.
     * @param isApproachActive Whether the approach is active.
     * @param fafIndex The destination leg index.
     */
    checkApproachMode(plan, isApproachActive, fafIndex) {
      let approachMode = 0;
      let currentLeg;
      if (isApproachActive && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
        currentLeg = plan.getLeg(plan.activeLateralLeg);
        if (BitFlags.isAll(currentLeg.flags, LegDefinitionFlags.MissedApproach)) {
          approachMode = 3;
        } else if (fafIndex > -1 && plan.activeLateralLeg >= fafIndex) {
          approachMode = 2;
        } else {
          approachMode = 1;
        }
      }
      this.checkApproachWaypointType(currentLeg);
      SimVar.SetSimVarValue("GPS APPROACH MODE", SimVarValueType.Number, approachMode);
      SimVar.SetSimVarValue("GPS APPROACH IS FINAL", SimVarValueType.Bool, approachMode === 2);
    }
    /**
     * Handles when the active leg index changes.
     * @param plan The Active Flight Plan.
     */
    onWaypointIndexChanged(plan) {
      var _a;
      let name = "";
      if (plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
        const leg = plan.getLeg(plan.activeLateralLeg);
        name = (_a = leg.name) !== null && _a !== void 0 ? _a : "";
        if (leg === null || leg === void 0 ? void 0 : leg.calculated) {
          SimVar.SetSimVarValue("GPS WP NEXT LAT", SimVarValueType.Degree, leg.calculated.endLat);
          SimVar.SetSimVarValue("GPS WP NEXT LON", SimVarValueType.Degree, leg.calculated.endLon);
        }
      }
      SimVar.SetSimVarValue("GPS WP NEXT ID", SimVarValueType.String, name);
    }
    /**
     * Handles when the number of active plan legs changes.
     * @param numLegs The number of active plan legs.
     */
    onNumLegsChanged(numLegs) {
      SimVar.SetSimVarValue("GPS IS ACTIVE FLIGHT PLAN", SimVarValueType.Bool, numLegs > 0);
      SimVar.SetSimVarValue("GPS IS ACTIVE WAY POINT", SimVarValueType.Bool, this.isDirectToActive.get() || numLegs > 1);
      if (this.flightPlanner.hasActiveFlightPlan()) {
        const plan = this.flightPlanner.getActiveFlightPlan();
        this.onIsPrevLegChanged(plan);
      }
    }
    /**
     * Handles when the previous leg changes.
     * @param plan The Active Flight Plan
     */
    onIsPrevLegChanged(plan) {
      var _a;
      const numLegs = this.numPlanLegs.get();
      let name = "";
      if (numLegs > 1 && plan.activeLateralLeg > 0 && plan.activeLateralLeg < plan.length) {
        const prevLeg = plan.getLeg(plan.activeLateralLeg - 1);
        if (!FlightPlanUtils.isDiscontinuityLeg(prevLeg.leg.type)) {
          SimVar.SetSimVarValue("GPS WP PREV VALID", SimVarValueType.Bool, true);
          name = (_a = prevLeg.name) !== null && _a !== void 0 ? _a : "";
          if (prevLeg.calculated) {
            SimVar.SetSimVarValue("GPS WP PREV LAT", SimVarValueType.Degree, prevLeg.calculated.endLat);
            SimVar.SetSimVarValue("GPS WP PREV LON", SimVarValueType.Degree, prevLeg.calculated.endLon);
          }
        }
      }
      SimVar.SetSimVarValue("GPS WP PREV ID", SimVarValueType.String, name);
    }
    /**
     * Handles when the LNAV Distance to Destination Changes.
     * @param dis The new distance to destination.
     */
    onLnavDistanceToDestinationChanged(dis) {
      const eteSeconds = this.groundSpeed > 1 ? 3600 * dis / this.groundSpeed : 0;
      if (isNaN(eteSeconds)) {
        return;
      }
      SimVar.SetSimVarValue("GPS ETE", SimVarValueType.Seconds, eteSeconds);
      SimVar.SetSimVarValue("GPS ETA", SimVarValueType.Seconds, eteSeconds + this.zuluTime);
    }
    /**
     * Handles when the LNAV DTK changes.
     * @param dtk The new DTK.
     */
    onDtkChanged(dtk) {
      SimVar.SetSimVarValue("GPS WP DESIRED TRACK", SimVarValueType.Radians, UnitType.DEGREE.convertTo(dtk, UnitType.RADIAN));
    }
    /**
     * Handles when the LNAV XTK changes.
     * @param xtk The new XTK.
     */
    onXtkChanged(xtk) {
      SimVar.SetSimVarValue("GPS WP CROSS TRK", SimVarValueType.Meters, UnitType.NMILE.convertTo(xtk, UnitType.METER) * -1);
    }
    /**
     * Handles when the LNAV DIS to WP changes.
     * @param dis The distance.
     */
    onLnavDistanceChanged(dis) {
      if (this.isDestinationLegActive.get() && Math.abs(dis) < 2) {
        this.hasReachedDestination.set(true);
      }
      const distanceMeters = UnitType.NMILE.convertTo(dis, UnitType.METER);
      SimVar.SetSimVarValue("GPS WP DISTANCE", SimVarValueType.Meters, distanceMeters);
      const eteSeconds = this.groundSpeed > 1 ? 3600 * dis / this.groundSpeed : 0;
      SimVar.SetSimVarValue("GPS WP ETE", SimVarValueType.Seconds, eteSeconds);
      SimVar.SetSimVarValue("GPS WP ETA", SimVarValueType.Seconds, eteSeconds + this.zuluTime);
    }
    /**
     * Handles when the LNAV Bearing to WP changes.
     * @param brg The bearing.
     */
    onLnavBearingChanged(brg) {
      SimVar.SetSimVarValue("GPS WP BEARING", SimVarValueType.Radians, UnitType.DEGREE.convertTo(brg, UnitType.RADIAN));
    }
    /**
     * Handles when the True Ground Track Changes.
     * @param trk The true track.
     */
    onTrackTrueChanged(trk) {
      SimVar.SetSimVarValue("GPS GROUND TRUE TRACK", SimVarValueType.Radians, UnitType.DEGREE.convertTo(trk, UnitType.RADIAN));
    }
    /**
     * Handles when the Ground Speed changes.
     * @param gs The current ground speed.
     */
    onGroundSpeedChanged(gs) {
      this.groundSpeed = gs;
      SimVar.SetSimVarValue("GPS GROUND SPEED", SimVarValueType.MetersPerSecond, UnitType.KNOT.convertTo(gs, UnitType.MPS));
    }
    /**
     * Handles when the true heading changes.
     * @param hdg The true heading.
     */
    onTrueHeadingChanged(hdg) {
      SimVar.SetSimVarValue("GPS GROUND TRUE HEADING", SimVarValueType.Radians, UnitType.DEGREE.convertTo(hdg, UnitType.RADIAN));
    }
    /**
     * Handles when the magvar changes.
     * @param magvar The new magvar.
     */
    onMagvarChanged(magvar) {
      this.magvar = magvar;
      SimVar.SetSimVarValue("GPS MAGVAR", SimVarValueType.Radians, UnitType.DEGREE.convertTo(magvar, UnitType.RADIAN));
    }
    /**
     * Handle when the VNAV Target Altitude changes.
     * @param targetAlt Target Altitude [feet] (can be -1 if none is defined or available)
     */
    onTargetAltChanged(targetAlt) {
      SimVar.SetSimVarValue("GPS TARGET ALTITUDE", SimVarValueType.Meters, targetAlt > 0 ? UnitType.FOOT.convertTo(targetAlt, UnitType.METER) : 0);
    }
    /**
     * Handle when the VNAV Active Leg Altitude Changes.
     * @param alt The active leg altitude in meters.
     */
    onActiveLegAltChanged(alt) {
      SimVar.SetSimVarValue("GPS WP NEXT ALT", SimVarValueType.Meters, alt > 0 ? alt : 0);
    }
    /**
     * Handles when the VNAV required VS changes.
     * @param vs The required vertical speed.
     */
    requiredVsChanged(vs) {
      SimVar.SetSimVarValue("GPS WP VERTICAL SPEED", SimVarValueType.MetersPerSecond, UnitType.FPM.convertTo(vs, UnitType.MPS));
    }
    /**
     * Handles when the distance to the GlidePath Target changes.
     * @param dis The distance to the glidepath target (runway).
     */
    onGpDistanceChanged(dis) {
      let verticalAngleError = 0;
      const fpa = this.gpFpa.get();
      if (fpa > 0) {
        const deviation = this.gpDeviation.get();
        const fpaAltitude = VNavUtils.altitudeForDistance(fpa, dis);
        const calculatedFpaToTarget = VNavUtils.getFpa(dis, fpaAltitude + deviation);
        verticalAngleError = fpa - calculatedFpaToTarget;
      }
      SimVar.SetSimVarValue("GPS VERTICAL ANGLE ERROR", SimVarValueType.Degree, verticalAngleError);
    }
    /**
     * Handles when the plane position changes.
     * @param pos The new plane position.
     */
    onPositionChanged(pos) {
      SimVar.SetSimVarValue("GPS POSITION LAT", SimVarValueType.Degree, pos.lat);
      SimVar.SetSimVarValue("GPS POSITION LON", SimVarValueType.Degree, pos.long);
      SimVar.SetSimVarValue("GPS POSITION ALT", SimVarValueType.Meters, pos.alt);
    }
    /**
     * Handles when the GPS CDI scale changes.
     * @param scaleNm The scale, in nautical miles.
     */
    onCdiScaleChanged(scaleNm) {
      SimVar.SetSimVarValue("GPS CDI SCALING", SimVarValueType.Meters, UnitType.NMILE.convertTo(scaleNm, UnitType.METER));
    }
    /**
     * Handles checking the approach type and timezone.
     * @param plan The active flight plan.
     * @param approachIndex The approach index in the active plan.
     */
    async checkApproachTypeAndTimezone(plan, approachIndex) {
      let approachType = 0;
      if (plan.getUserData("visual_approach") !== void 0) {
        approachType = ApproachType.APPROACH_TYPE_RNAV;
      } else if (approachIndex > -1 && plan.destinationAirport) {
        const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
        approachType = facility.approaches[approachIndex].approachType;
        if (approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL) {
          approachType = ApproachType.APPROACH_TYPE_RNAV;
        }
      }
      SimVar.SetSimVarValue("GPS APPROACH APPROACH TYPE", SimVarValueType.Number, approachType);
    }
    /**
     * Handles checking the approach waypoint type.
     * @param leg The active lateral leg.
     */
    checkApproachWaypointType(leg) {
      let legType = 0;
      let segmentType = 0;
      if (leg) {
        switch (leg.leg.type) {
          case LegType.AF:
            legType = leg.leg.turnDirection === LegTurnDirection.Left ? 4 : 5;
            segmentType = leg.leg.turnDirection === LegTurnDirection.Left ? 2 : 1;
            break;
          case LegType.RF:
            legType = 1;
            segmentType = leg.leg.turnDirection === LegTurnDirection.Left ? 2 : 1;
            break;
          case LegType.CA:
          case LegType.FA:
          case LegType.VA:
            legType = 9;
            break;
          case LegType.FM:
          case LegType.VM:
            legType = 10;
            break;
          case LegType.CD:
          case LegType.FD:
          case LegType.VD:
            legType = 8;
            break;
          case LegType.PI:
            legType = leg.leg.turnDirection === LegTurnDirection.Left ? 2 : 3;
            break;
          case LegType.HA:
          case LegType.HM:
          case LegType.HF:
            legType = leg.leg.turnDirection === LegTurnDirection.Left ? 6 : 7;
            break;
          default:
            legType = 1;
        }
      }
      SimVar.SetSimVarValue("GPS APPROACH WP TYPE", SimVarValueType.Number, legType);
      SimVar.SetSimVarValue("GPS APPROACH SEGMENT TYPE", SimVarValueType.Number, segmentType);
      SimVar.SetSimVarValue("GPS APPROACH IS WP RUNWAY", SimVarValueType.Bool, (leg === null || leg === void 0 ? void 0 : leg.leg.fixIcao[0]) === "R");
    }
  };
  var LNavTransitionMode;
  (function(LNavTransitionMode2) {
    LNavTransitionMode2[LNavTransitionMode2["None"] = 0] = "None";
    LNavTransitionMode2[LNavTransitionMode2["Ingress"] = 1] = "Ingress";
    LNavTransitionMode2[LNavTransitionMode2["Egress"] = 2] = "Egress";
    LNavTransitionMode2[LNavTransitionMode2["Unsuspend"] = 3] = "Unsuspend";
  })(LNavTransitionMode || (LNavTransitionMode = {}));
  var LNavVars;
  (function(LNavVars2) {
    LNavVars2["DTK"] = "L:WTAP_LNav_DTK";
    LNavVars2["XTK"] = "L:WTAP_LNav_XTK";
    LNavVars2["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    LNavVars2["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    LNavVars2["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    LNavVars2["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    LNavVars2["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    LNavVars2["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    LNavVars2["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    LNavVars2["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    LNavVars2["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    LNavVars2["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    LNavVars2["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    LNavVars2["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
  })(LNavVars || (LNavVars = {}));
  var LNavSimVarPublisher = class extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
      super(LNavSimVarPublisher.simvars, bus);
    }
  };
  LNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnav_dtk", { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ["lnav_xtk", { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ["lnav_is_tracking", { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ["lnav_tracked_leg_index", { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ["lnav_transition_mode", { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ["lnav_tracked_vector_index", { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ["lnav_course_to_steer", { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ["lnav_is_suspended", { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ["lnav_leg_distance_along", { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_leg_distance_remaining", { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_distance_along", { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_vector_distance_remaining", { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_anticipation_distance", { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ["lnav_along_track_speed", { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
  ]);
  var LNavUtils = class {
    /**
     * Gets the flight path vectors to navigate for a leg and a given transition mode.
     * @param calc The calculations for a flight plan leg.
     * @param mode A transition mode.
     * @param isSuspended Whether sequencing is suspended.
     * @returns The flight path vectors to navigate for the given leg and transition mode.
     */
    static getVectorsForTransitionMode(calc, mode, isSuspended) {
      switch (mode) {
        case LNavTransitionMode.None:
          return isSuspended ? calc.flightPath : calc.ingressToEgress;
        case LNavTransitionMode.Ingress:
          return calc.ingress;
        case LNavTransitionMode.Egress:
          return calc.egress;
        case LNavTransitionMode.Unsuspend:
          return calc.flightPath;
      }
    }
    /**
     * Checks whether two LNAV tracking states are equal.
     * @param a The first state.
     * @param b The second state.
     * @returns Whether the two LNAV tracking states are equal.
     */
    static lnavTrackingStateEquals(a, b) {
      return a.isTracking === b.isTracking && a.globalLegIndex === b.globalLegIndex && a.transitionMode === b.transitionMode && a.vectorIndex === b.vectorIndex && a.isSuspended === b.isSuspended;
    }
  };
  var APAltCapDirector = class {
    /**
     * Creates an instance of the APAltCapDirector.
     * @param bus The event bus to use with this director.
     * @param apValues Autopilot data for this director.
     * @param captureAltitude A function which calculates desired pitch angles to capture a target altitude. If not
     * defined, a default function is used.
     */
    constructor(bus, apValues, captureAltitude = APAltCapDirector.captureAltitude) {
      this.bus = bus;
      this.apValues = apValues;
      this.captureAltitude = captureAltitude;
      this.capturedAltitude = 0;
      this.initialFpa = 0;
      this.selectedAltitude = 0;
      this.verticalWindAverage = new SimpleMovingAverage(10);
      this.state = DirectorState.Inactive;
      this.apValues.capturedAltitude.sub((cap) => {
        this.capturedAltitude = Math.round(cap);
      });
      this.apValues.selectedAltitude.sub((alt) => {
        this.selectedAltitude = alt;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setCaptureFpa(SimVar.GetSimVarValue("VERTICAL SPEED", SimVarValueType.FPM));
      SimVar.SetSimVarValue("AUTOPILOT ALTITUDE LOCK", "Bool", true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      this.state = DirectorState.Armed;
      if (this.onArm !== void 0) {
        this.onArm();
      }
    }
    /**
     * Deactivates this director.
     * @param captured is whether the altitude was captured.
     */
    deactivate(captured = false) {
      this.state = DirectorState.Inactive;
      if (!captured) {
        SimVar.SetSimVarValue("AUTOPILOT ALTITUDE LOCK", "Bool", false);
      }
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        const tas = SimVar.GetSimVarValue("AIRSPEED TRUE", SimVarValueType.Knots);
        this.setPitch(this.captureAltitude(this.capturedAltitude, SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet), this.initialFpa, SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree), SimVar.GetSimVarValue("VERTICAL SPEED", SimVarValueType.FPM), tas), tas);
      }
      if (this.state === DirectorState.Armed) {
        this.tryActivate();
      }
    }
    /**
     * Attempts to activate altitude capture.
     */
    tryActivate() {
      const indicatedAlt = SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet);
      const vs = SimVar.GetSimVarValue("VERTICAL SPEED", SimVarValueType.FPM);
      const deviationFromTarget = Math.abs(this.selectedAltitude - indicatedAlt);
      if (deviationFromTarget <= Math.abs(vs / 6)) {
        this.apValues.capturedAltitude.set(Math.round(this.selectedAltitude));
        this.activate();
      }
    }
    /**
     * Sets the initial capture FPA from the current vs value when capture is initiated.
     * @param vs target vertical speed.
     */
    setCaptureFpa(vs) {
      const indicatedAlt = SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet);
      const altCapDeviation = indicatedAlt - this.selectedAltitude;
      if (altCapDeviation < 0) {
        vs = Math.max(400, vs);
      } else {
        vs = Math.min(-400, vs);
      }
      const tas = SimVar.GetSimVarValue("AIRSPEED TRUE", SimVarValueType.FPM);
      this.initialFpa = VNavUtils.getFpa(tas, vs);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     * @param tas The airplane's current true airspeed, in knots.
     */
    setPitch(targetPitch, tas) {
      if (isFinite(targetPitch)) {
        const verticalWindComponent = this.verticalWindAverage.getAverage(SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.FPM));
        const verticalWindPitchAdjustment = VNavUtils.getFpa(UnitType.KNOT.convertTo(tas, UnitType.FPM), -verticalWindComponent);
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -(targetPitch + verticalWindPitchAdjustment));
      }
    }
    /**
     * Calculates a desired pitch angle, in degrees, to capture a target altitude.
     * @param targetAltitude The altitude to capture, in feet.
     * @param indicatedAltitude The current indicated altitude, in feet.
     * @param initialFpa The flight path angle of the airplane, in degrees, when altitude capture was first activated.
     * Positive values indicate a descending path.
     * @param aoa The current angle of attack, in degrees. Positive values indicate nose-up attitude.
     * @param verticalSpeed The current vertical speed of the airplane, in feet per minute.
     * @param tas The current true airspeed of the airplane, in knots.
     * @returns The desired pitch angle, in degrees, to capture the specified altitude. Positive values indicate nose-up
     * pitch.
     */
    static captureAltitude(targetAltitude, indicatedAltitude, initialFpa, aoa, verticalSpeed, tas) {
      const initialFpaAbs = Math.abs(initialFpa);
      let deltaAltitude = targetAltitude - indicatedAltitude;
      if (deltaAltitude >= 0 && deltaAltitude < 10) {
        deltaAltitude = 10;
      } else if (deltaAltitude < 0 && deltaAltitude > -10) {
        deltaAltitude = -10;
      }
      const desiredClosureTime = MathUtils.lerp(Math.abs(deltaAltitude), 100, 1e3, 5, 10, true, true);
      const desiredVs = deltaAltitude / (desiredClosureTime / 60);
      const desiredFpa = MathUtils.clamp(Math.asin(desiredVs / UnitType.KNOT.convertTo(tas, UnitType.FPM)) * Avionics.Utils.RAD2DEG, -initialFpaAbs, initialFpaAbs);
      return MathUtils.clamp(aoa + desiredFpa, -15, 15);
    }
  };
  var APAltDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
      this.bus = bus;
      this.tas = 0;
      this.capturedAltitude = 0;
      this.indicatedAltitude = 0;
      this.verticalWindAverage = new SimpleMovingAverage(10);
      this.state = DirectorState.Inactive;
      this.bus.getSubscriber().on("tas").withPrecision(0).handle((tas) => {
        this.tas = tas;
      });
      this.bus.getSubscriber().on("indicated_alt").withPrecision(0).handle((alt) => {
        this.indicatedAltitude = alt;
      });
      apValues.capturedAltitude.sub((cap) => {
        this.capturedAltitude = Math.round(cap);
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT ALTITUDE LOCK", "Bool", true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      this.state = DirectorState.Armed;
      if (this.onArm !== void 0) {
        this.onArm();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT ALTITUDE LOCK", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        this.holdAltitude(this.capturedAltitude);
      }
      if (this.state === DirectorState.Armed) {
        this.tryActivate();
      }
    }
    /**
     * Attempts to activate altitude capture.
     */
    tryActivate() {
      const deviationFromTarget = Math.abs(this.capturedAltitude - this.indicatedAltitude);
      if (deviationFromTarget <= 20) {
        this.activate();
      }
    }
    /**
     * Holds a captured altitude.
     * @param targetAltitude is the captured targed altitude
     */
    holdAltitude(targetAltitude) {
      const deltaAlt = this.indicatedAltitude - targetAltitude;
      let setVerticalSpeed = 0;
      const correction = MathUtils.clamp(10 * Math.abs(deltaAlt), 100, 500);
      if (deltaAlt > 10) {
        setVerticalSpeed = 0 - correction;
      } else if (deltaAlt < -10) {
        setVerticalSpeed = correction;
      }
      this.setPitch(this.getDesiredPitch(setVerticalSpeed));
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @param vs target vertical speed.
     * @returns The desired pitch angle.
     */
    getDesiredPitch(vs) {
      const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
      const verticalWindComponent = this.verticalWindAverage.getAverage(SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.FPM));
      const desiredPitch = this.getFpa(UnitType.NMILE.convertTo(this.tas / 60, UnitType.FOOT), vs - verticalWindComponent);
      return NavMath.clamp(aoa + desiredPitch, -10, 10);
    }
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    getFpa(distance, altitude) {
      return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      }
    }
  };
  var APFLCDirector = class {
    /**
     * Creates an instance of the FLC Director.
     * @param bus The event bus to use with this instance.
     * @param apValues is the AP selected values subject.
     * @param pitchClamp is the maximum pitch angle, in degrees, to clamp FLC at.
     * @param forceCurrentIasOnActivation Whether this director should force set the current IAS as the target speed on activation.
     */
    constructor(bus, apValues, pitchClamp = 15, forceCurrentIasOnActivation = true) {
      this.bus = bus;
      this.pitchClamp = pitchClamp;
      this.forceCurrentIasOnActivation = forceCurrentIasOnActivation;
      this._lastTime = 0;
      this.currentIas = 0;
      this.selectedIas = 0;
      this.selectedMach = 0;
      this.isSelectedSpeedInMach = false;
      this.selectedAltitude = 0;
      this.currentAltitude = 0;
      this.currentPitch = 0;
      this.pitchController = new PidController(2, 0, 0, 15, -15);
      this.filter = new ExpSmoother(2.5);
      this.state = DirectorState.Inactive;
      const sub = this.bus.getSubscriber();
      sub.on("indicated_alt").withPrecision(0).handle((alt) => {
        this.currentAltitude = alt;
      });
      sub.on("ias").withPrecision(2).handle((ias) => {
        this.currentIas = ias;
      });
      sub.on("pitch_deg").withPrecision(1).handle((pitch) => {
        this.currentPitch = -pitch;
      });
      apValues.selectedIas.sub((ias) => {
        this.selectedIas = ias;
      });
      apValues.selectedMach.sub((mach) => {
        this.selectedMach = mach;
      });
      apValues.isSelectedSpeedInMach.sub((isMach) => {
        this.isSelectedSpeedInMach = isMach;
      });
      apValues.selectedAltitude.sub((alt) => {
        this.selectedAltitude = alt;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      this.initialize();
      this.onActivate && this.onActivate();
      SimVar.SetSimVarValue("AUTOPILOT FLIGHT LEVEL CHANGE", "Bool", true);
      this.forceCurrentIasOnActivation && SimVar.SetSimVarValue("K:AP_SPD_VAR_SET", "number", this.currentIas);
    }
    /**
     * Arms this director.
     * This director can be armed, but it will never automatically activate and remain in the armed state.
     */
    arm() {
      this.state = DirectorState.Armed;
      this.onArm && this.onArm();
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT FLIGHT LEVEL CHANGE", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        this.setPitch(this.getDesiredPitch());
      }
    }
    /**
     * Initializes this director on activation.
     */
    initialize() {
      this.resetFilter();
      this.pitchController.reset();
    }
    /**
     * Gets a desired pitch from the current AP speed target
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
      const targetIas = this.isSelectedSpeedInMach ? Simplane.getMachToKias(this.selectedMach) : this.selectedIas;
      return this.getDesiredPitchFromSpeed(targetIas);
    }
    /**
     * Gets a desired pitch from a given speed target
     * @param targetIas target airspeed in knots
     * @returns The desired pitch angle.
     */
    getDesiredPitchFromSpeed(targetIas) {
      const time = performance.now() / 1e3;
      let dt = time - this._lastTime;
      if (this._lastTime === 0) {
        dt = 0;
      }
      const iasError = this.currentIas - targetIas;
      const targetAcceleration = MathUtils.clamp(iasError / 5, -2, 2) * -1;
      const acceleration = UnitType.FOOT.convertTo(SimVar.GetSimVarValue("ACCELERATION BODY Z", "feet per second squared"), UnitType.NMILE) * 3600;
      const accelerationError = acceleration - targetAcceleration;
      const pitchCorrection = this.pitchController.getOutput(dt, accelerationError);
      const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
      this._lastTime = time;
      let targetPitch = isNaN(pitchCorrection) ? this.currentPitch - aoa : this.currentPitch - aoa + pitchCorrection;
      targetPitch = this.filter.next(targetPitch, dt);
      if (this.selectedAltitude > this.currentAltitude) {
        return MathUtils.clamp(targetPitch + aoa, aoa, this.pitchClamp);
      } else {
        return MathUtils.clamp(targetPitch + aoa, -this.pitchClamp, aoa);
      }
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      }
    }
    /** Reset the pitch filter */
    resetFilter() {
      this._lastTime = 0;
    }
  };
  var APFPADirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxFpa`: `undefined`
     */
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.tas = 0;
      this.selectedFpa = 0;
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxFpaFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxFpaFunc = maxBankAngleOpt;
          break;
        default:
          this.maxFpaFunc = () => Infinity;
      }
      this.state = DirectorState.Inactive;
      this.bus.getSubscriber().on("tas").withPrecision(0).handle((tas) => {
        this.tas = tas;
      });
      apValues.selectedFlightPathAngle.sub((fpa) => {
        const maxFpa = this.maxFpaFunc();
        this.selectedFpa = MathUtils.clamp(fpa, -maxFpa, maxFpa);
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      const fpa = this.getFpaFromVs(Simplane.getVerticalSpeed());
      SimVar.SetSimVarValue("L:WT_AP_FPA_Target:1", "degree", fpa);
      SimVar.SetSimVarValue("AUTOPILOT VERTICAL HOLD", "Bool", true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT VERTICAL HOLD", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        this.setPitch(this.getDesiredPitch());
      }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
      const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
      const desiredPitch = this.selectedFpa;
      return MathUtils.clamp(aoa + (isNaN(desiredPitch) ? 9.9 : desiredPitch), -18, 18);
    }
    /**
     * Gets a desired fpa.
     * @param vs Vertical speed in feet/min to calculate as FPA for
     * @returns The desired pitch angle.
     */
    getFpaFromVs(vs) {
      if (this.tas < 60) {
        return 0;
      }
      const verticalWindComponent = SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.FPM);
      const distance = UnitType.NMILE.convertTo(this.tas / 60, UnitType.FOOT);
      const altitude = vs - verticalWindComponent;
      const maxFpa = this.maxFpaFunc();
      return MathUtils.clamp(UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE), -maxFpa, maxFpa);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      }
    }
  };
  var VNavVars;
  (function(VNavVars2) {
    VNavVars2["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    VNavVars2["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    VNavVars2["PathMode"] = "L:WTAP_VNav_Path_Mode";
    VNavVars2["VNAVState"] = "L:WTAP_VNav_State";
    VNavVars2["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    VNavVars2["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    VNavVars2["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    VNavVars2["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    VNavVars2["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    VNavVars2["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    VNavVars2["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    VNavVars2["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    VNavVars2["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    VNavVars2["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    VNavVars2["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    VNavVars2["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    VNavVars2["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    VNavVars2["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    VNavVars2["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    VNavVars2["FPA"] = "L:WTAP_VNav_FPA";
    VNavVars2["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    VNavVars2["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    VNavVars2["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    VNavVars2["GPDistance"] = "L:WTAP_GP_Distance";
    VNavVars2["GPFpa"] = "L:WTAP_GP_FPA";
    VNavVars2["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    VNavVars2["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
  })(VNavVars || (VNavVars = {}));
  var VNavSimVarPublisher = class extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
      super(VNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
  };
  VNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["vnav_vertical_deviation", { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ["vnav_target_altitude", { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ["vnav_path_mode", { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ["vnav_path_available", { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ["vnav_state", { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ["vnav_altitude_capture_type", { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ["vnav_tod_distance", { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_leg_distance", { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_bod_distance", { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_global_leg_index", { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ["vnav_bod_global_leg_index", { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ["vnav_toc_distance", { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_leg_distance", { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_boc_distance", { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_global_leg_index", { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_boc_global_leg_index", { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_global_leg_index", { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_altitude", { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_next_constraint_altitude", { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_fpa", { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ["vnav_required_vs", { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ["gp_approach_mode", { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ["gp_vertical_deviation", { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ["gp_distance", { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ["gp_fpa", { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ["gp_required_vs", { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ["gp_service_level", { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
  ]);
  var APGPDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
      this.bus = bus;
      this.apValues = apValues;
      this.gpDeviation = 0;
      this.fpa = 0;
      this.verticalWindAverage = new SimpleMovingAverage(10);
      this.state = DirectorState.Inactive;
      this.bus.getSubscriber().on("gp_vertical_deviation").whenChanged().handle((dev) => this.gpDeviation = dev);
      this.bus.getSubscriber().on("gp_fpa").whenChanged().handle((fpa) => this.fpa = fpa);
      apValues.approachHasGP.sub((v) => {
        if (this.state !== DirectorState.Inactive && !v) {
          this.deactivate();
        }
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GPActive);
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ACTIVE", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ARM", "Bool", false);
    }
    /**
     * Arms this director.
     */
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.state = DirectorState.Armed;
        SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GPArmed);
        if (this.onArm !== void 0) {
          this.onArm();
        }
        SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ARM", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ACTIVE", "Bool", false);
        SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.None);
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ARM", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ACTIVE", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Armed) {
        if (this.apValues.lateralActive.get() === APLateralModes.GPSS && this.gpDeviation <= 100 && this.gpDeviation >= -15 && this.fpa !== 0) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        if (this.apValues.lateralActive.get() !== APLateralModes.GPSS) {
          this.deactivate();
        }
        this.setPitch(this.getDesiredPitch());
      }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
      const vsRequiredForFpa = SimVar.GetSimVarValue("GROUND VELOCITY", SimVarValueType.FPM) * Math.tan(-this.fpa * Avionics.Utils.DEG2RAD);
      const desiredClosureRate = MathUtils.lerp(Math.abs(this.gpDeviation), 0, 100, 0, 850, true, true);
      const desiredVs = MathUtils.clamp(Math.sign(this.gpDeviation) * desiredClosureRate + vsRequiredForFpa, -3e3, 0);
      const verticalWindComponent = this.verticalWindAverage.getAverage(SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.FPM));
      const vsRequiredWithVerticalWind = desiredVs - verticalWindComponent;
      const pitchForVerticalSpeed = Math.asin(MathUtils.clamp(vsRequiredWithVerticalWind / SimVar.GetSimVarValue("AIRSPEED TRUE", SimVarValueType.FPM), -1, 1)) * Avionics.Utils.RAD2DEG;
      const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
      return aoa + MathUtils.clamp(pitchForVerticalSpeed, -8, 3);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      }
    }
  };
  var APGSDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues is the APValues object from the Autopilot.
     * @param options APGSDirector options.
     */
    constructor(bus, apValues, options) {
      this.bus = bus;
      this.apValues = apValues;
      this.gsLocation = new GeoPoint(NaN, NaN);
      this.verticalWindAverage = new SimpleMovingAverage(10);
      this.state = DirectorState.Inactive;
      const nav = this.bus.getSubscriber();
      if (options === null || options === void 0 ? void 0 : options.forceNavSource) {
        nav.on(`nav_radio_glideslope_${options.forceNavSource}`).handle((gs) => this.glideslope = gs);
        nav.on(`nav_radio_gs_location_${options.forceNavSource}`).handle((loc) => {
          this.gsLocation.set(loc.lat, loc.long);
        });
      } else {
        nav.on("nav_radio_active_glideslope").handle((gs) => this.glideslope = gs);
        nav.on("nav_radio_active_gs_location").handle((loc) => {
          this.gsLocation.set(loc.lat, loc.long);
        });
      }
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GSActive);
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ACTIVE", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ARM", "Bool", false);
    }
    /**
     * Arms this director.
     */
    arm() {
      if (this.canArm() && this.state === DirectorState.Inactive) {
        this.state = DirectorState.Armed;
        SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GSArmed);
        if (this.onArm !== void 0) {
          this.onArm();
        }
        SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ARM", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ACTIVE", "Bool", false);
        SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.None);
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ARM", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT GLIDESLOPE ACTIVE", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Armed) {
        if (this.apValues.lateralActive.get() === APLateralModes.LOC && this.glideslope !== void 0 && this.glideslope.isValid && this.glideslope.deviation <= 0.1 && this.glideslope.deviation >= -0.1) {
          this.activate();
        }
        if (!this.canArm()) {
          this.deactivate();
        }
      }
      if (this.state === DirectorState.Active) {
        if (this.apValues.lateralActive.get() !== APLateralModes.LOC) {
          this.deactivate();
        }
        this.trackGlideslope();
      }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
      if (this.apValues.navToNavLocArm && this.apValues.navToNavLocArm() || this.glideslope !== void 0 && this.glideslope.isValid) {
        return true;
      }
      return false;
    }
    /**
     * Tracks the Glideslope.
     */
    trackGlideslope() {
      if (this.glideslope !== void 0 && this.glideslope.isValid && !isNaN(this.gsLocation.lat + this.gsLocation.lon)) {
        const distanceM = UnitType.GA_RADIAN.convertTo(this.gsLocation.distance(SimVar.GetSimVarValue("PLANE LATITUDE", SimVarValueType.Degree), SimVar.GetSimVarValue("PLANE LONGITUDE", SimVarValueType.Degree)), UnitType.METER);
        const altitudeM = distanceM * Math.tan((this.glideslope.gsAngle + this.glideslope.deviation) * Avionics.Utils.DEG2RAD);
        const groundSpeedMps = SimVar.GetSimVarValue("GROUND VELOCITY", SimVarValueType.MetersPerSecond);
        const desiredClosureRate = MathUtils.lerp(Math.abs(this.glideslope.deviation), 0, 0.7, 0, 0.1, true, true);
        const desiredAngleRate = Math.sign(this.glideslope.deviation) * -1 * desiredClosureRate;
        const vsRequiredForClosure = MathUtils.clamp((Avionics.Utils.DEG2RAD * desiredAngleRate * (distanceM * distanceM + altitudeM * altitudeM) - altitudeM * groundSpeedMps) / distanceM, -3e3, 0);
        const verticalWindComponent = this.verticalWindAverage.getAverage(SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.MetersPerSecond));
        const vsRequiredWithVerticalWind = vsRequiredForClosure - verticalWindComponent;
        const pitchForVerticalSpeed = Math.asin(MathUtils.clamp(vsRequiredWithVerticalWind / SimVar.GetSimVarValue("AIRSPEED TRUE", SimVarValueType.MetersPerSecond), -1, 1)) * Avionics.Utils.RAD2DEG;
        const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
        const targetPitch = aoa + MathUtils.clamp(pitchForVerticalSpeed, -8, 3);
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      } else {
        this.deactivate();
      }
    }
  };
  var APHdgDirector = class {
    /**
     * Creates a new instance of APHdgDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.toGaHeading = 0;
      this.bankServo = new LinearServo(APHdgDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaHeading = this.currentHeading;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaHeading = this.currentHeading;
          }
          this.setBank(this.desiredBank(this.toGaHeading));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgDirector.BANK_SERVO_RATE = 10;
  var APHdgHoldDirector = class {
    /**
     * Creates an instance of the heading hold director.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APHdgHoldDirector.BANK_SERVO_RATE);
      this.capturedHeading = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentHeadingSub = this.bus.getSubscriber().on("hdg_deg").withPrecision(0).handle((h) => this.currentHeading = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentHeadingSub.resume();
      this.capturedHeading = null;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentHeadingSub.pause();
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedHeading === null && Math.abs(this.currentBank) < APHdgHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedHeading = this.currentHeading;
        }
        this.setBank(this.capturedHeading !== null ? this.desiredBank(this.capturedHeading) : 0);
      }
    }
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgHoldDirector.BANK_SERVO_RATE = 10;
  APHdgHoldDirector.MIN_BANK_THRESHOLD = 1;
  var APNavDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param mode The APLateralMode for this instance of the director.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     * * `disableArming`: `false`
     */
    constructor(bus, apValues, mode, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APNavDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      this.isNavLock = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.disableArming = (_b = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _b !== void 0 ? _b : false;
      this.forceNavSource = options === null || options === void 0 ? void 0 : options.forceNavSource;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     */
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        this.setNavLock(true);
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      this.setNavLock(false);
    }
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    /**
     * Updates this director.
     */
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.disableArming || this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (this.mode === APLateralModes.LOC && typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      if (this.mode === APLateralModes.VOR && typeIsCorrect) {
        const indexIsCorrect = index == ((_f = this.cdi) === null || _f === void 0 ? void 0 : _f.source.index) && !((_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) && index == ((_h = this.obs) === null || _h === void 0 ? void 0 : _h.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(false);
          return true;
        }
      }
      if (this.mode === APLateralModes.LOC && this.apValues.navToNavLocArm && this.apValues.navToNavLocArm()) {
        this.isApproachMode.set(true);
        return true;
      }
      this.isApproachMode.set(false);
      return false;
    }
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index) || !((_f = this.loc) === null || _f === void 0 ? void 0 : _f.isValid) && index == ((_g = this.obs) === null || _g === void 0 ? void 0 : _g.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && (((_h = this.obs) === null || _h === void 0 ? void 0 : _h.heading) || ((_j = this.loc) === null || _j === void 0 ? void 0 : _j.course))) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? this.loc.course * Avionics.Utils.RAD2DEG : (_k = this.obs) === null || _k === void 0 ? void 0 : _k.heading;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_m = (_l = this.loc) === null || _l === void 0 ? void 0 : _l.isValid) !== null && _m !== void 0 ? _m : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    desiredBank() {
      var _a, _b, _c, _d, _e, _f, _g;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      const hasValidObs = this.obs !== void 0 && this.obs.heading !== null;
      let zoneOfConfusion = false;
      if (isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (!isLoc && (!hasValidDeviation || !hasValidObs)) {
        if (!this.checkForZoneOfConfusion()) {
          this.deactivate();
          return NaN;
        } else {
          zoneOfConfusion = true;
        }
      }
      if (zoneOfConfusion || this.cdi && this.cdi.deviation !== null) {
        const xtk = zoneOfConfusion ? 0 : this.cdi && this.cdi.deviation !== null ? this.getXtk(this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? this.loc.course * Avionics.Utils.RAD2DEG : (_d = this.obs) === null || _d === void 0 ? void 0 : _d.heading;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_f = (_e = this.cdi) === null || _e === void 0 ? void 0 : _e.deviation) !== null && _f !== void 0 ? _f : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_g = this.magVar) !== null && _g !== void 0 ? _g : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    monitorEvents() {
      const sub = this.bus.getSubscriber();
      if (this.forceNavSource) {
        this.navSource = {
          index: this.forceNavSource,
          type: NavSourceType.Nav
        };
        sub.on(`nav_radio_cdi_${this.forceNavSource}`).handle((cdi) => this.cdi = cdi);
        sub.on(`nav_radio_obs_${this.forceNavSource}`).handle((obs) => this.obs = obs);
        sub.on(`nav_radio_localizer_${this.forceNavSource}`).handle((loc) => this.loc = loc);
        sub.on(`nav_radio_nav_location_${this.forceNavSource}`).handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub.on(`nav_radio_magvar_${this.forceNavSource}`).handle((magVar) => {
          this.magVar = magVar;
        });
      } else {
        sub.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
        sub.on("nav_radio_active_obs_setting").handle((obs) => this.obs = obs);
        sub.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
        sub.on("cdi_select").handle((source) => {
          this.navSource = source;
          if (this.state === DirectorState.Active) {
            this.deactivate();
          }
        });
        sub.on("nav_radio_active_nav_location").handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub.on("nav_radio_active_magvar").handle((magVar) => {
          this.magVar = magVar;
        });
      }
      sub.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub.on("tas").handle((s) => this.tas = s);
      sub.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APNavDirector.BANK_SERVO_RATE = 10;
  var APPitchDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the AP Values subjects.
     * @param pitchIncrement is the pitch increment, in degrees, to use when the user presses the pitch inc/dec keys (default: 0.5)
     * @param minPitch is the negative minimum pitch angle, in degrees, to clamp the pitch to. (default: -15)
     * @param maxPitch is the positive maximum pitch angle, in degrees, to clamp the pitch to. (default: 20)
     */
    constructor(bus, apValues, pitchIncrement = 0.5, minPitch = -15, maxPitch = 20) {
      this.bus = bus;
      this.apValues = apValues;
      this.pitchIncrement = pitchIncrement;
      this.minPitch = minPitch;
      this.maxPitch = maxPitch;
      this.selectedPitch = 0;
      this.currentPitch = 0;
      this.state = DirectorState.Inactive;
      this.apValues.selectedPitch.sub((p) => {
        this.selectedPitch = p;
        if (this.state == DirectorState.Active) {
          this.setPitch(p);
        }
      });
      const ahrsSub = this.bus.getSubscriber();
      ahrsSub.on("pitch_deg").withPrecision(1).handle((p) => {
        this.currentPitch = p;
      });
      KeyEventManager.getManager(bus).then((manager) => {
        this.keyEventManager = manager;
        manager.interceptKey("AP_PITCH_REF_INC_UP", false);
        manager.interceptKey("AP_PITCH_REF_INC_DN", false);
        const keySub = this.bus.getSubscriber();
        keySub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setPitch(this.currentPitch);
      SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD", "Bool", true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD", "Bool", false);
    }
    /**
     * Responds to key intercepted events.
     * @param k the key event data
     */
    onKeyIntercepted(k) {
      switch (k.key) {
        case "AP_PITCH_REF_INC_UP":
        case "AP_PITCH_REF_INC_DN":
          this.setPitch(this.selectedPitch + (k.key === "AP_PITCH_REF_INC_UP" ? -this.pitchIncrement : this.pitchIncrement));
          break;
        default:
          return;
      }
    }
    /**
     * Updates this director.
     */
    update() {
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, MathUtils.clamp(targetPitch, -this.maxPitch, -this.minPitch));
      }
    }
  };
  var APRollDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `minBankAngle`: `0`
     * * `maxBankAngle`: `undefined`
     */
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.actualBank = 0;
      this.bankServo = new LinearServo(APRollDirector.BANK_SERVO_RATE);
      const minBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.minBankAngle) !== null && _a !== void 0 ? _a : 0;
      if (typeof minBankAngleOpt === "number") {
        this.minBankAngleFunc = () => minBankAngleOpt;
      } else {
        this.minBankAngleFunc = minBankAngleOpt;
      }
      const maxBankAngleOpt = options === null || options === void 0 ? void 0 : options.maxBankAngle;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
      const sub = this.bus.getSubscriber();
      sub.on("roll_deg").withPrecision(1).handle((roll) => {
        this.actualBank = roll;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      const maxBank = this.maxBankAngleFunc();
      const minBank = this.minBankAngleFunc();
      if (Math.abs(this.actualBank) < minBank) {
        this.desiredBank = 0;
      } else {
        this.desiredBank = MathUtils.clamp(this.actualBank, -maxBank, maxBank);
      }
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", true);
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        const maxBank = this.maxBankAngleFunc();
        const minBank = this.minBankAngleFunc();
        if (Math.abs(this.actualBank) < minBank) {
          this.desiredBank = 0;
        } else {
          this.desiredBank = MathUtils.clamp(this.actualBank, -maxBank, maxBank);
        }
        this.setBank(this.desiredBank);
      }
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APRollDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APRollDirector.BANK_SERVO_RATE = 10;
  var APTrkDirector = class {
    /**
     * Creates a new instance of APHdgDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.toGaTrack = 0;
      this.bankServo = new LinearServo(APTrkDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("track_deg_magnetic").withPrecision(0).handle((h) => {
        this.currentTrack = h;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaTrack = this.currentTrack;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaTrack = this.currentTrack;
          }
          this.setBank(this.desiredBank(this.toGaTrack));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    /**
     * Gets a desired bank from a Target Selected Track.
     * @param targetTrack The target track.
     * @returns The desired bank angle.
     */
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkDirector.BANK_SERVO_RATE = 10;
  var APTrkHoldDirector = class {
    /**
     * Creates an instance of the track hold director.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APTrkHoldDirector.BANK_SERVO_RATE);
      this.capturedTrack = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentTrackSub = this.bus.getSubscriber().on("track_deg_magnetic").withPrecision(0).handle((h) => this.currentTrack = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentTrackSub.resume();
      this.capturedTrack = null;
      this.currentBankRef = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentTrackSub.pause();
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedTrack === null && Math.abs(this.currentBank) < APTrkHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedTrack = this.currentTrack;
        }
        this.setBank(this.capturedTrack !== null ? this.desiredBank(this.capturedTrack) : 0);
      }
    }
    /**
     * Gets a desired bank from a Target Selected Track.
     * @param targetTrack The target track.
     * @returns The desired bank angle.
     */
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkHoldDirector.BANK_SERVO_RATE = 10;
  APTrkHoldDirector.MIN_BANK_THRESHOLD = 1;
  var APVSDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
      this.bus = bus;
      this.tas = 0;
      this.selectedVS = 0;
      this.verticalWindAverage = new SimpleMovingAverage(10);
      this.state = DirectorState.Inactive;
      this.bus.getSubscriber().on("tas").withPrecision(0).handle((tas) => {
        this.tas = tas;
      });
      apValues.selectedVerticalSpeed.sub((vs) => {
        this.selectedVS = vs;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      Coherent.call("AP_VS_VAR_SET_ENGLISH", 1, Simplane.getVerticalSpeed());
      SimVar.SetSimVarValue("AUTOPILOT VERTICAL HOLD", "Bool", true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT VERTICAL HOLD", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        this.setPitch(this.getDesiredPitch());
      }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
      const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
      const verticalWindComponent = this.verticalWindAverage.getAverage(SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.FPM));
      const desiredPitch = this.getFpa(UnitType.NMILE.convertTo(this.tas / 60, UnitType.FOOT), this.selectedVS - verticalWindComponent);
      return MathUtils.clamp(aoa + (isNaN(desiredPitch) ? 10 : desiredPitch), -10, 10);
    }
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    getFpa(distance, altitude) {
      return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      }
    }
  };
  var ArcTurnController = class {
    constructor() {
      this.bankController = new PidController(1.5, 0, 0, 15, -15);
      this.precessionController = new PidController(0.025, 0, 0, 300, -300);
      this.filter = new ExpSmoother(500);
    }
    /**
     * Gets the bank angle output for a given radius error.
     * @param radiusError The radius error.
     * @returns The bank angle output.
     */
    getOutput(radiusError) {
      var _a;
      const currentTime = (/* @__PURE__ */ new Date()).appTime();
      let bankAngle = 0;
      if (this.previousRadiusError !== void 0 && this.previousTime !== void 0) {
        const dTime = currentTime - this.previousTime;
        const input = (radiusError - this.previousRadiusError) / dTime * 1e3;
        const precessionRate = isNaN((_a = this.filter.last()) !== null && _a !== void 0 ? _a : NaN) ? this.filter.reset(input) : this.filter.next(input, dTime);
        const targetPrecessionRate = -this.precessionController.getOutput(dTime, radiusError);
        const precessionError = targetPrecessionRate - precessionRate;
        bankAngle = this.bankController.getOutput(dTime, precessionError);
      }
      this.previousTime = currentTime;
      this.previousRadiusError = radiusError;
      return -bankAngle;
    }
    /**
     * Resets the controller.
     */
    reset() {
      this.previousTime = void 0;
      this.previousRadiusError = void 0;
      this.precessionController.reset();
      this.bankController.reset();
      this.filter.reset();
    }
  };
  var LNavDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param flightPlanner The flight planner to use with this instance.
     * @param obsDirector The OBS Director.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     * * `hasVectorAnticipation`: `false`
     * * `minimumActivationAltitude`: `undefined`
     * * `disableArming`: `false`
     */
    constructor(bus, apValues, flightPlanner, obsDirector, options) {
      var _a, _b, _c;
      this.bus = bus;
      this.apValues = apValues;
      this.flightPlanner = flightPlanner;
      this.obsDirector = obsDirector;
      this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.publisher = this.bus.getPublisher();
      this.aircraftState = {
        tas: 0,
        gs: 0,
        track: 0,
        magvar: 0,
        windSpeed: 0,
        windDirection: 0,
        planePos: new GeoPoint(0, 0),
        hdgTrue: 0,
        altAgl: 0,
        bank: 0
      };
      this.currentLeg = void 0;
      this.currentVector = void 0;
      this.dtk = 0;
      this.xtk = 0;
      this.bearingToVectorEnd = 0;
      this.courseToSteer = 0;
      this.alongVectorDistance = 0;
      this.vectorDistanceRemaining = 0;
      this.vectorAnticipationDistance = 0;
      this.alongTrackSpeed = 0;
      this.anticipationVector = void 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      this.inhibitNextSequence = false;
      this.currentBankRef = 0;
      this.bankServo = new LinearServo(LNavDirector.BANK_SERVO_RATE);
      this.currentState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.anticipationState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.currentBankAngleState = {
        arcController: new ArcTurnController(),
        isInterceptingFromArmedState: false,
        trackAtActivation: 0,
        desiredBankAngle: 0
      };
      this.lnavData = ObjectSubject.create({
        dtk: 0,
        xtk: 0,
        trackingState: {
          isTracking: false,
          globalLegIndex: 0,
          transitionMode: LNavTransitionMode.None,
          vectorIndex: 0,
          isSuspended: false
        },
        isTracking: false,
        legIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        courseToSteer: 0,
        isSuspended: false,
        alongLegDistance: 0,
        legDistanceRemaining: 0,
        alongVectorDistance: 0,
        vectorDistanceRemaining: 0,
        vectorAnticipationDistance: 0,
        alongTrackSpeed: 0
      });
      this.isObsDirectorTracking = false;
      this.canArm = false;
      this.awaitCalculateId = 0;
      this.isAwaitingCalculate = false;
      this.isNavLock = Subject.create(false);
      this.lnavDataHandler = (obj, key, value) => {
        switch (key) {
          case "dtk":
            SimVar.SetSimVarValue(LNavVars.DTK, SimVarValueType.Degree, value);
            break;
          case "xtk":
            SimVar.SetSimVarValue(LNavVars.XTK, SimVarValueType.NM, value);
            break;
          case "isTracking":
            SimVar.SetSimVarValue(LNavVars.IsTracking, SimVarValueType.Bool, value);
            break;
          case "legIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number, value);
            break;
          case "transitionMode":
            SimVar.SetSimVarValue(LNavVars.TransitionMode, SimVarValueType.Number, value);
            break;
          case "vectorIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedVectorIndex, SimVarValueType.Number, value);
            break;
          case "courseToSteer":
            SimVar.SetSimVarValue(LNavVars.CourseToSteer, SimVarValueType.Degree, value);
            break;
          case "isSuspended":
            SimVar.SetSimVarValue(LNavVars.IsSuspended, SimVarValueType.Bool, value);
            break;
          case "alongLegDistance":
            SimVar.SetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM, value);
            break;
          case "legDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "alongVectorDistance":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceAlong, SimVarValueType.NM, value);
            break;
          case "vectorDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "vectorAnticipationDistance":
            SimVar.SetSimVarValue(LNavVars.VectorAnticipationDistance, SimVarValueType.NM, value);
            break;
          case "alongTrackSpeed":
            SimVar.SetSimVarValue(LNavVars.AlongTrackSpeed, SimVarValueType.Knots, value);
            break;
          case "trackingState":
            this.publisher.pub("lnav_tracking_state", value, true, true);
            break;
        }
      };
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.hasVectorAnticipation = (_b = options === null || options === void 0 ? void 0 : options.hasVectorAnticipation) !== null && _b !== void 0 ? _b : false;
      this.minimumActivationAltitude = options === null || options === void 0 ? void 0 : options.minimumActivationAltitude;
      this.disableArming = (_c = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _c !== void 0 ? _c : false;
      const sub = bus.getSubscriber();
      this.lnavData.sub(this.lnavDataHandler, true);
      sub.on("ambient_wind_velocity").handle((w) => this.aircraftState.windSpeed = w);
      sub.on("ambient_wind_direction").handle((wd) => this.aircraftState.windDirection = wd);
      sub.on("tas").handle((tas) => this.aircraftState.tas = tas);
      sub.on("hdg_deg_true").handle((hdg) => this.aircraftState.hdgTrue = hdg);
      sub.on("ground_speed").handle((gs) => this.aircraftState.gs = gs);
      sub.on("radio_alt").handle((alt) => this.aircraftState.altAgl = alt);
      sub.on("roll_deg").handle((roll) => this.aircraftState.bank = roll);
      const nav = this.bus.getSubscriber();
      nav.on("cdi_select").handle((src) => {
        if (this.state !== DirectorState.Inactive && src.type !== NavSourceType.Gps) {
          this.deactivate();
        }
      });
      sub.on("suspend_sequencing").handle((suspend) => {
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
        if (flightPlan) {
          if (suspend) {
            this.currentState.inhibitedSuspendLegIndex = -1;
          }
          this.trySetSuspended(flightPlan, this.currentState, suspend, this.currentState, false, false);
        }
      });
      sub.on("activate_missed_approach").handle((v) => {
        this.currentState.isMissedApproachActive = v;
      });
      sub.on("lnav_inhibit_next_sequence").handle((inhibit) => {
        this.inhibitNextSequence = inhibit;
        if (inhibit) {
          this.currentState.inhibitedSuspendLegIndex = -1;
        }
      });
      sub.on("fplActiveLegChange").handle((e) => {
        if (e.planIndex === this.flightPlanner.activePlanIndex && e.type === ActiveLegType.Lateral) {
          this.currentState.inhibitedSuspendLegIndex = -1;
          this.resetVectors();
        }
      });
      sub.on("fplIndexChanged").handle(() => {
        this.resetVectors();
      });
      sub.on("fplCopied").handle((e) => {
        if (e.targetPlanIndex === this.flightPlanner.activePlanIndex) {
          this.resetVectors();
        }
      });
      sub.on("gps-position").handle((lla) => {
        this.aircraftState.planePos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => this.aircraftState.track = t);
      sub.on("magvar").handle((m) => this.aircraftState.magvar = m);
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
      this.state = DirectorState.Inactive;
    }
    /**
     * Resets the current vectors and transition mode.
     */
    resetVectors() {
      this.currentState.vectorIndex = 0;
      this.currentState.transitionMode = LNavTransitionMode.Ingress;
      this.inhibitNextSequence = false;
      this.awaitCalculate();
    }
    /**
     * Activates the LNAV director.
     */
    activate() {
      this.currentBankAngleState.isInterceptingFromArmedState = !this.disableArming;
      this.currentBankAngleState.trackAtActivation = this.aircraftState.track;
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.bankServo.reset();
    }
    /**
     * Arms the LNAV director.
     */
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.currentBankAngleState.isInterceptingFromArmedState = false;
        if (this.canArm) {
          this.state = DirectorState.Armed;
          if (this.onArm !== void 0) {
            this.onArm();
          }
          this.setNavLock(true);
        }
      }
    }
    /**
     * Deactivates the LNAV director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      if (this.obsDirector && this.obsDirector.state !== DirectorState.Inactive) {
        this.obsDirector.deactivate();
      }
      this.currentBankAngleState.isInterceptingFromArmedState = false;
      this.setNavLock(false);
    }
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    /**
     * Updates the lateral director.
     */
    update() {
      var _a;
      let clearInhibitNextSequence = false;
      const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
      this.currentState.globalLegIndex = flightPlan ? flightPlan.activeLateralLeg : 0;
      let isTracking = !!flightPlan && this.currentState.globalLegIndex <= flightPlan.length - 1;
      if (flightPlan && isTracking) {
        if (this.isAwaitingCalculate) {
          return;
        }
        this.currentLeg = flightPlan.getLeg(this.currentState.globalLegIndex);
        clearInhibitNextSequence = !!this.currentLeg.calculated;
        this.calculateTracking(flightPlan);
        if (this.isAwaitingCalculate) {
          return;
        }
        if (this.hasVectorAnticipation) {
          this.updateVectorAnticipation(flightPlan);
        }
        isTracking = this.currentState.globalLegIndex < flightPlan.length && this.currentVector !== void 0 && this.currentVector.radius > LNavDirector.ANGULAR_TOLERANCE && this.currentVector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
        if (isTracking) {
          const calcs = this.currentLeg.calculated;
          if (this.obsDirector) {
            this.obsDirector.setLeg(this.currentState.globalLegIndex, this.currentLeg);
            if (this.obsDirector.obsActive) {
              this.currentState.isSuspended = true;
              this.currentState.inhibitedSuspendLegIndex = this.currentState.globalLegIndex;
              if (!this.isObsDirectorTracking) {
                this.lnavData.unsub(this.lnavDataHandler);
                this.isObsDirectorTracking = true;
                this.obsDirector.startTracking();
              }
              if (this.state === DirectorState.Active && this.obsDirector.state !== DirectorState.Active) {
                this.obsDirector.activate();
                this.setNavLock(true);
              }
              if (this.state === DirectorState.Armed && this.obsDirector.canActivate()) {
                this.obsDirector.activate();
                this.state = DirectorState.Active;
                if (this.onActivate !== void 0) {
                  this.onActivate();
                }
                this.setNavLock(true);
              }
              this.obsDirector.update();
              return;
            }
          }
          isTracking = calcs !== void 0;
          if (this.state !== DirectorState.Inactive) {
            this.navigateFlightPath();
          }
        }
      } else {
        this.currentState.isSuspended = false;
        clearInhibitNextSequence = true;
      }
      if (this.isObsDirectorTracking) {
        this.currentState.isSuspended = false;
      }
      this.canArm = isTracking;
      this.lnavData.set("isTracking", isTracking);
      this.lnavData.set("isSuspended", this.currentState.isSuspended);
      if (isTracking) {
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking !== isTracking || trackingState.globalLegIndex !== this.currentState.globalLegIndex || trackingState.transitionMode !== this.currentState.transitionMode || trackingState.vectorIndex !== this.currentState.vectorIndex || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking,
            globalLegIndex: this.currentState.globalLegIndex,
            transitionMode: this.currentState.transitionMode,
            vectorIndex: this.currentState.vectorIndex,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", this.dtk);
        this.lnavData.set("xtk", this.xtk);
        this.lnavData.set("legIndex", this.currentState.globalLegIndex);
        this.lnavData.set("vectorIndex", this.currentState.vectorIndex);
        this.lnavData.set("transitionMode", this.currentState.transitionMode);
        this.lnavData.set("courseToSteer", this.courseToSteer);
        this.lnavData.set("alongVectorDistance", this.alongVectorDistance);
        this.lnavData.set("vectorDistanceRemaining", this.vectorDistanceRemaining);
        this.lnavData.set("vectorAnticipationDistance", this.vectorAnticipationDistance);
        this.lnavData.set("alongTrackSpeed", this.alongTrackSpeed);
        this.lnavData.set("alongLegDistance", this.getAlongLegDistance(flightPlan, this.currentState, this.alongVectorDistance));
        this.lnavData.set("legDistanceRemaining", this.getLegDistanceRemaining(flightPlan, this.currentState, this.vectorDistanceRemaining));
      } else {
        this.currentLeg = void 0;
        this.currentVector = void 0;
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking || trackingState.globalLegIndex !== 0 || trackingState.transitionMode !== LNavTransitionMode.None || trackingState.vectorIndex !== 0 || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking: false,
            globalLegIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", 0);
        this.lnavData.set("xtk", 0);
        this.lnavData.set("legIndex", 0);
        this.lnavData.set("vectorIndex", 0);
        this.lnavData.set("transitionMode", LNavTransitionMode.None);
        this.lnavData.set("courseToSteer", 0);
        this.lnavData.set("alongLegDistance", 0);
        this.lnavData.set("vectorDistanceRemaining", 0);
        this.lnavData.set("alongVectorDistance", 0);
        this.lnavData.set("legDistanceRemaining", 0);
        this.lnavData.set("vectorAnticipationDistance", 0);
        this.lnavData.set("alongTrackSpeed", 0);
      }
      if (this.isObsDirectorTracking) {
        (_a = this.obsDirector) === null || _a === void 0 ? void 0 : _a.stopTracking();
        this.lnavData.sub(this.lnavDataHandler, true);
        this.isObsDirectorTracking = false;
      }
      if (this.state === DirectorState.Armed) {
        this.tryActivate();
      }
      this.inhibitNextSequence && (this.inhibitNextSequence = !clearInhibitNextSequence);
    }
    /**
     * Navigates the currently tracked flight path.
     */
    navigateFlightPath() {
      let bankAngle;
      if (this.anticipationVector && this.vectorAnticipationDistance > 0 && this.vectorDistanceRemaining <= this.vectorAnticipationDistance && Math.abs(this.xtk) < UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)) {
        this.updateBankAngle(this.anticipationVector, this.anticipationDtk, this.anticipationXtk, this.anticipationBearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (bankAngle === void 0) {
        if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
          return;
        }
        this.updateBankAngle(this.currentVector, this.dtk, this.xtk, this.bearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (this.state === DirectorState.Active) {
        this.setBank(bankAngle);
      }
    }
    /**
     * Updates a bank angle state for a tracked flight path vector.
     * @param vector The tracked flight path vector.
     * @param dtk The desired track, in degrees true.
     * @param xtk The cross-track error, in nautical miles.
     * @param bearingToVectorEnd The bearing from the airplane to the end of the tracked vector, in degrees true.
     * @param bankAngleState The bank angle state to udpate.
     * @returns The updated bank angle state.
     */
    updateBankAngle(vector, dtk, xtk, bearingToVectorEnd, bankAngleState) {
      let absInterceptAngle;
      let naturalAbsInterceptAngle = 0;
      if (this.lateralInterceptCurve !== void 0) {
        naturalAbsInterceptAngle = this.lateralInterceptCurve(dtk, xtk, this.aircraftState.tas);
      } else {
        naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
        if (naturalAbsInterceptAngle <= 2.5) {
          naturalAbsInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
        }
      }
      if (bankAngleState.isInterceptingFromArmedState) {
        absInterceptAngle = Math.abs(NavMath.diffAngle(bankAngleState.trackAtActivation, dtk));
        if (absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5 || absInterceptAngle < Math.abs(NavMath.diffAngle(dtk, bearingToVectorEnd))) {
          absInterceptAngle = naturalAbsInterceptAngle;
          bankAngleState.isInterceptingFromArmedState = false;
        }
      } else {
        absInterceptAngle = naturalAbsInterceptAngle;
      }
      const interceptAngle = xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
      const courseToSteer = NavMath.normalizeHeading(dtk + interceptAngle);
      bankAngleState.desiredBankAngle = this.desiredBank(courseToSteer);
      if (vector !== void 0 && !FlightPathUtils.isVectorGreatCircle(vector)) {
        this.adjustBankAngleForArc(vector, bankAngleState);
      }
      return bankAngleState;
    }
    /**
     * Gets a desired bank from a desired track.
     * @param desiredTrack The desired track.
     * @returns The desired bank angle.
     */
    desiredBank(desiredTrack) {
      const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
      const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    /**
     * Adjusts a bank angle state's desired bank angle for arc vectors.
     * @param vector The arc vector to adjust for.
     * @param bankAngleState The bank angle state to adjust.
     * @returns The adjusted bank angle state.
     */
    adjustBankAngleForArc(vector, bankAngleState) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
      const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const radius = UnitType.GA_RADIAN.convertTo(FlightPathUtils.getTurnRadiusFromCircle(circle), UnitType.METER);
      const relativeWindHeading = NavMath.normalizeHeading(this.aircraftState.windDirection - this.aircraftState.hdgTrue);
      const headwind = this.aircraftState.windSpeed * Math.cos(relativeWindHeading * Avionics.Utils.DEG2RAD);
      const distance = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.METER);
      const bankAdjustment = bankAngleState.arcController.getOutput(distance);
      const turnBankAngle = NavMath.bankAngle(this.aircraftState.tas - headwind, radius) * (turnDirection === "left" ? 1 : -1);
      const turnRadius = NavMath.turnRadius(this.aircraftState.tas - headwind, 25);
      const bankBlendFactor = Math.max(1 - Math.abs(UnitType.NMILE.convertTo(this.xtk, UnitType.METER)) / turnRadius, 0);
      const maxBank = this.maxBankAngleFunc();
      bankAngleState.desiredBankAngle = MathUtils.clamp(bankAngleState.desiredBankAngle * (1 - bankBlendFactor) + turnBankAngle * bankBlendFactor + bankAdjustment, -maxBank, maxBank);
      return bankAngleState;
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = LNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    /**
     * Calculates the tracking from the current leg.
     * @param plan The active flight plan.
     */
    calculateTracking(plan) {
      var _a, _b;
      let didAdvance;
      do {
        didAdvance = false;
        if (!this.currentLeg) {
          break;
        }
        if (this.currentLeg.leg.type === LegType.IF && this.currentState.globalLegIndex === 0 && plan.length > 1) {
          this.currentLeg = plan.getLeg(++this.currentState.globalLegIndex);
          plan.setCalculatingLeg(this.currentState.globalLegIndex);
          plan.setLateralLeg(this.currentState.globalLegIndex);
          continue;
        }
        const transitionMode = this.currentState.transitionMode;
        const legIndex = this.currentState.globalLegIndex;
        const vectorIndex = this.currentState.vectorIndex;
        const isSuspended = this.currentState.isSuspended;
        const calcs = this.currentLeg.calculated;
        if (calcs) {
          const vectors = LNavUtils.getVectorsForTransitionMode(calcs, this.currentState.transitionMode, this.currentState.isSuspended);
          const vector = vectors[this.currentState.vectorIndex];
          const isVectorValid = vector && vector.radius > LNavDirector.ANGULAR_TOLERANCE && vector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
          const isUnsuspendInvalid = this.currentState.transitionMode === LNavTransitionMode.Unsuspend && (calcs.ingress.length === 0 || calcs.flightPath[calcs.ingressJoinIndex] === void 0);
          if (isVectorValid && !isUnsuspendInvalid) {
            const planePos = this.aircraftState.planePos;
            const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
            let endLat, endLon;
            let end;
            let vectorDistanceNM;
            if (transitionMode === LNavTransitionMode.Unsuspend && vectorIndex === calcs.ingressJoinIndex && calcs.ingress.length > 0) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              endLat = lastIngressVector.endLat;
              endLon = lastIngressVector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.NMILE);
            } else {
              endLat = vector.endLat;
              endLon = vector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.METER.convertTo(vector.distance, UnitType.NMILE);
            }
            this.xtk = UnitType.GA_RADIAN.convertTo(circle.distance(planePos), UnitType.NMILE);
            this.dtk = circle.bearingAt(planePos, Math.PI);
            this.bearingToVectorEnd = planePos.bearingTo(endLat, endLon);
            const alongTrackSpeed = FlightPathUtils.projectVelocityToCircle(this.aircraftState.gs, planePos, this.aircraftState.track, circle);
            this.alongTrackSpeed = isNaN(alongTrackSpeed) ? this.aircraftState.gs : alongTrackSpeed;
            const normDist = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, planePos);
            this.alongVectorDistance = normDist * vectorDistanceNM;
            this.vectorDistanceRemaining = (1 - normDist) * vectorDistanceNM;
            if (normDist > 1) {
              this.advanceToNextVector(plan, this.currentState, true, this.currentState);
            }
          } else {
            this.alongVectorDistance = 0;
            this.vectorDistanceRemaining = 0;
            this.vectorAnticipationDistance = 0;
            this.advanceToNextVector(plan, this.currentState, true, this.currentState);
          }
          didAdvance = transitionMode !== this.currentState.transitionMode || legIndex !== this.currentState.globalLegIndex || vectorIndex !== this.currentState.vectorIndex || isSuspended !== this.currentState.isSuspended;
          if (legIndex !== this.currentState.globalLegIndex) {
            this.currentLeg = (_a = plan.tryGetLeg(this.currentState.globalLegIndex)) !== null && _a !== void 0 ? _a : void 0;
            plan.setCalculatingLeg(this.currentState.globalLegIndex);
            plan.setLateralLeg(this.currentState.globalLegIndex);
          }
        }
      } while (!this.isAwaitingCalculate && didAdvance && this.currentState.globalLegIndex <= plan.length - 1);
      if (this.currentState.transitionMode === LNavTransitionMode.Egress && this.currentState.globalLegIndex + 1 < plan.length && plan.activeCalculatingLeg !== this.currentState.globalLegIndex + 1) {
        plan.setCalculatingLeg(this.currentState.globalLegIndex + 1);
      }
      this.currentVector = ((_b = this.currentLeg) === null || _b === void 0 ? void 0 : _b.calculated) ? LNavUtils.getVectorsForTransitionMode(this.currentLeg.calculated, this.currentState.transitionMode, this.currentState.isSuspended)[this.currentState.vectorIndex] : void 0;
    }
    /**
     * Updates this director's vector anticipation data, including the anticipation distance, DTK and XTK for the
     * anticipated vector, and bearing from the airplane to the end of the anticipated vector.
     * @param plan The active flight plan.
     */
    updateVectorAnticipation(plan) {
      var _a;
      this.anticipationVector = void 0;
      this.vectorAnticipationDistance = 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        return;
      }
      this.advanceToNextVector(plan, this.currentState, false, this.anticipationState);
      const anticipationCalcs = (_a = plan.tryGetLeg(this.anticipationState.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!anticipationCalcs) {
        return;
      }
      const anticipationVectors = LNavUtils.getVectorsForTransitionMode(anticipationCalcs, this.anticipationState.transitionMode, this.anticipationState.isSuspended);
      this.anticipationVector = anticipationVectors[this.anticipationState.vectorIndex];
      if (!this.anticipationVector || this.anticipationVector === this.currentVector || this.anticipationVector.radius === 0 || this.anticipationVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        this.anticipationVector = void 0;
        return;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(this.anticipationVector, this.geoCircleCache[0]);
      this.anticipationXtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.NMILE);
      this.anticipationDtk = circle.bearingAt(this.aircraftState.planePos, Math.PI);
      this.anticipationBearingToVectorEnd = this.aircraftState.planePos.bearingTo(this.anticipationVector.endLat, this.anticipationVector.endLon);
      const maxBankAngle = this.maxBankAngleFunc();
      const currentVectorIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.currentVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const anticipationIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.anticipationVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const deltaBank = Math.abs(currentVectorIdealBankAngle - anticipationIdealBankAngle);
      const rollTimeSeconds = deltaBank / LNavDirector.VECTOR_ANTICIPATION_BANK_RATE;
      this.vectorAnticipationDistance = Math.min(
        rollTimeSeconds / 3600 * this.alongTrackSpeed,
        // Limit vector anticipation to the radius of the anticipated vector so that we don't start flying anticipated
        // arc/turn vectors too early with a large XTK error and veer off in the wrong direction.
        UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)
      );
    }
    /**
     * Applies suspends that apply at the end of a leg.
     * @param plan The active flight plan.
     * @param state The current LNAV state.
     * @param out The LNAV state to which to write.
     * @returns The LNAV state after applying end-of-leg suspends.
     */
    applyEndOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      const inhibitNextSequence = this.inhibitNextSequence && leg.leg.type !== LegType.ThruDiscontinuity;
      if (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM || leg.leg.type === LegType.Discontinuity) {
        return this.trySetSuspended(plan, state, true, out, true, false);
      } else if (inhibitNextSequence) {
        return this.trySetSuspended(plan, state, true, out, false, true);
      } else if (state.globalLegIndex < plan.length - 1) {
        const nextLeg = plan.getLeg(state.globalLegIndex + 1);
        if (!state.isMissedApproachActive && (leg.leg.fixTypeFlags === FixTypeFlags.MAP || !BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach) && BitFlags.isAll(nextLeg.flags, LegDefinitionFlags.MissedApproach))) {
          return this.trySetSuspended(plan, state, true, out, true, false);
        }
      }
      return out;
    }
    /**
     * Applies suspends that apply at the beginning of a leg.
     * @param plan The active flight plan.
     * @param state The current LNAV state.
     * @param out The LNAV state to which to write.
     * @returns The LNAV state after applying start-of-leg suspends.
     */
    applyStartOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.getLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      if (leg.leg.type === LegType.HM || state.globalLegIndex === plan.length - 1) {
        return this.trySetSuspended(plan, state, true, out, false, false);
      }
      return out;
    }
    /**
     * Advances an LNAV state to the next trackable vector.
     * @param plan The active flight plan.
     * @param state The state from which to advance.
     * @param awaitCalculateOnNextLeg Whether to await leg calculations when advancing to the next leg. If `true`, the
     * state will only advance as far as the first vector of the next leg.
     * @param out The state to which to write the results.
     * @returns The LNAV state after advancing to the next trackable vector.
     */
    advanceToNextVector(plan, state, awaitCalculateOnNextLeg, out) {
      var _a, _b, _c, _d, _e, _f;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      let leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      let legIndex = state.globalLegIndex;
      let transitionMode = state.transitionMode;
      let isSuspended = state.isSuspended;
      let vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
      let vectorIndex = state.vectorIndex + 1;
      let vectorEndIndex = (_a = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _a !== void 0 ? _a : 0;
      let didAdvance = false;
      let isDone = false;
      if (transitionMode === LNavTransitionMode.Unsuspend && leg.calculated) {
        if (leg.calculated.ingressJoinIndex < 0) {
          vectorEndIndex = 0;
        } else {
          const ingress = leg.calculated.ingress;
          const ingressJoinVector = leg.calculated.flightPath[leg.calculated.ingressJoinIndex];
          if (ingress.length > 0 && ingressJoinVector && GeoPoint.equals(ingress[ingress.length - 1].endLat, ingress[ingress.length - 1].endLon, ingressJoinVector.startLat, ingressJoinVector.startLon)) {
            vectorEndIndex = leg.calculated.ingressJoinIndex;
          } else {
            vectorEndIndex = leg.calculated.ingressJoinIndex + 1;
          }
        }
      }
      while (!vectors || vectorIndex >= vectorEndIndex || vectors[vectorIndex].radius === 0 || vectors[vectorIndex].distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        switch (transitionMode) {
          case LNavTransitionMode.Ingress:
            transitionMode = LNavTransitionMode.None;
            vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
            vectorIndex = Math.max(0, isSuspended ? (_c = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.ingressJoinIndex) !== null && _c !== void 0 ? _c : 0 : 0);
            didAdvance = true;
            break;
          case LNavTransitionMode.Unsuspend:
            transitionMode = LNavTransitionMode.None;
            vectors = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.ingressToEgress;
            vectorIndex = 0;
            didAdvance = true;
            break;
          case LNavTransitionMode.None:
            if (!isSuspended) {
              transitionMode = LNavTransitionMode.Egress;
              vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
              vectorIndex = 0;
              didAdvance = true;
            } else if (leg.leg.type === LegType.HM) {
              vectors = (_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath;
              vectorIndex = 0;
              didAdvance = true;
            } else {
              if (!didAdvance && vectors) {
                vectorIndex = Math.max(0, vectors.length - 1);
              }
              isDone = true;
            }
            break;
          case LNavTransitionMode.Egress:
            out.globalLegIndex = legIndex;
            out.transitionMode = transitionMode;
            out.vectorIndex = vectorIndex;
            out.isSuspended = isSuspended;
            this.advanceToNextLeg(plan, out, out);
            if (awaitCalculateOnNextLeg || out.globalLegIndex === legIndex) {
              return out;
            }
            leg = plan.tryGetLeg(out.globalLegIndex);
            if (!(leg === null || leg === void 0 ? void 0 : leg.calculated)) {
              return out;
            } else {
              legIndex = out.globalLegIndex;
              transitionMode = out.transitionMode;
              vectors = LNavUtils.getVectorsForTransitionMode(leg.calculated, out.transitionMode, out.isSuspended);
              vectorIndex = out.vectorIndex;
              isSuspended = out.isSuspended;
              didAdvance = false;
            }
        }
        if (isDone) {
          break;
        }
        vectorEndIndex = (_f = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _f !== void 0 ? _f : 0;
      }
      out.globalLegIndex = legIndex;
      out.transitionMode = transitionMode;
      out.vectorIndex = vectorIndex;
      out.isSuspended = isSuspended;
      return out;
    }
    /**
     * Advances an LNAV state to the next leg.
     * @param plan The active flight plan.
     * @param state The state from which to advance.
     * @param out The state to which to write the results.
     * @returns The LNAV state after advancing to the next leg.
     */
    advanceToNextLeg(plan, state, out) {
      var _a, _b, _c;
      this.applyEndOfLegSuspends(plan, state, out);
      if (!out.isSuspended) {
        if (out.globalLegIndex + 1 >= plan.length) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = Math.max(0, ((_c = (_b = (_a = plan.tryGetLeg(out.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) !== null && _c !== void 0 ? _c : 0) - 1);
          return out;
        }
        out.globalLegIndex++;
        out.transitionMode = LNavTransitionMode.Ingress;
        out.vectorIndex = 0;
        out.inhibitedSuspendLegIndex = -1;
        this.applyStartOfLegSuspends(plan, out, out);
      }
      return out;
    }
    /**
     * Attempts to activate/deactivate suspend on an LNAV state.
     * @param plan The active flight plan.
     * @param state The state for which to set suspended.
     * @param suspend The suspended state to set.
     * @param out The state to which to write the results.
     * @param inhibitResuspend Whether to inhibit resuspend of the suspended leg once suspend ends on that leg. Ignored
     * if `suspend` is `false`. Defaults to `false`.
     * @param resetVectorsOnSuspendEnd Whether to reset the tracked vector to the beginning of the suspended leg once
     * suspend ends on that leg. Ignored if `suspend` is `false`. Defaults to `false`.
     * @returns The LNAV state after the suspend state has been set.
     */
    trySetSuspended(plan, state, suspend, out, inhibitResuspend = false, resetVectorsOnSuspendEnd = false) {
      var _a;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      if (suspend && state.globalLegIndex === state.inhibitedSuspendLegIndex) {
        return out;
      }
      if (suspend) {
        out.inhibitedSuspendLegIndex = inhibitResuspend ? state.globalLegIndex : -1;
        out.resetVectorsOnSuspendEnd = resetVectorsOnSuspendEnd;
      }
      if (state.isSuspended !== suspend) {
        out.isSuspended = suspend;
        if (!suspend && state.resetVectorsOnSuspendEnd) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = 0;
          out.resetVectorsOnSuspendEnd = false;
        } else {
          const leg = plan.tryGetLeg(state.globalLegIndex);
          const legCalc = leg === null || leg === void 0 ? void 0 : leg.calculated;
          const ingressJoinVector = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath[legCalc.ingressJoinIndex];
          if (legCalc && state.transitionMode === LNavTransitionMode.None && legCalc.ingressJoinIndex >= 0 && ingressJoinVector && legCalc.ingress.length > 0) {
            const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
            let vectors;
            let offset;
            if (suspend) {
              vectors = legCalc.flightPath;
              if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                offset = legCalc.ingressJoinIndex + 1;
              } else {
                offset = legCalc.ingressJoinIndex;
              }
            } else {
              let pastIngressJoin = state.vectorIndex > legCalc.ingressJoinIndex;
              if (!pastIngressJoin && state.vectorIndex === legCalc.ingressJoinIndex && legCalc.flightPath[legCalc.ingressJoinIndex]) {
                const vector = legCalc.flightPath[legCalc.ingressJoinIndex];
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                const end = GeoPoint.sphericalToCartesian(ingressJoinVector.endLat, ingressJoinVector.endLon, this.vec3Cache[1]);
                pastIngressJoin = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.aircraftState.planePos) >= 1;
              }
              if (pastIngressJoin) {
                vectors = legCalc.ingressToEgress;
                if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                  offset = -(legCalc.ingressJoinIndex + 1);
                } else {
                  offset = -legCalc.ingressJoinIndex;
                }
              } else {
                vectors = legCalc.flightPath;
                offset = 0;
                out.transitionMode = LNavTransitionMode.Unsuspend;
              }
            }
            out.vectorIndex = Math.max(0, Math.min(state.vectorIndex + offset, vectors.length - 1));
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Unsuspend) {
            out.transitionMode = LNavTransitionMode.None;
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Egress) {
            out.transitionMode = LNavTransitionMode.None;
            out.vectorIndex = Math.max(0, ((_a = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath.length) !== null && _a !== void 0 ? _a : 1) - 1);
          }
        }
      }
      return out;
    }
    /**
     * Tries to activate when armed.
     */
    tryActivate() {
      if (this.disableArming) {
        this.activate();
        return;
      }
      if (this.minimumActivationAltitude === void 0 || this.aircraftState.altAgl >= this.minimumActivationAltitude) {
        const headingDiff = NavMath.diffAngle(this.aircraftState.track, this.dtk);
        if (Math.abs(this.xtk) < 0.6 && Math.abs(headingDiff) < 110) {
          this.activate();
        }
      }
    }
    /**
     * Awaits a flight plan calculation. Starts a calculation of the active flight plan and suspends all tracking and
     * sequencing until the calculation is finished. If this method is called while a previous execution is still
     * awaiting, the new await takes precedence.
     */
    async awaitCalculate() {
      if (!this.flightPlanner.hasActiveFlightPlan()) {
        return;
      }
      this.isAwaitingCalculate = true;
      const id = ++this.awaitCalculateId;
      const plan = this.flightPlanner.getActiveFlightPlan();
      try {
        await plan.calculate();
      } catch (_a) {
      }
      if (id !== this.awaitCalculateId) {
        return;
      }
      this.isAwaitingCalculate = false;
    }
    /**
     * Gets an along-track distance from the start of a tracked flight plan leg given a distance along a tracked vector.
     * @param plan The active flight plan.
     * @param state The LNAV state.
     * @param alongVectorDistance The along-track distance from the start of the tracked vector, in nautical miles.
     * @returns The along-track distance, in nautical miles, from the start of the specified flight plan leg given the
     * specified state and along-vector distance.
     */
    getAlongLegDistance(plan, state, alongVectorDistance) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, false);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let distanceAlong = 0;
      for (let i = state.vectorIndex - 1; i >= 0; i--) {
        distanceAlong += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Egress:
          vectors = calcs.ingressToEgress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          vectors = calcs.ingress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
      }
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex; i < calcs.ingressJoinIndex; i++) {
            distanceAlong -= vectors[i].distance;
          }
          if (state.vectorIndex <= calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceAlong -= UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
        }
      }
      return UnitType.METER.convertTo(distanceAlong, UnitType.NMILE) + alongVectorDistance;
    }
    /**
     * Gets an along-track distance from the end of a tracked flight plan leg given a distance remaining along a tracked
     * vector.
     * @param plan The active flight plan.
     * @param state The LNAV state.
     * @param vectorDistanceRemaining The along-track distance from the end of the tracked vector, in nautical miles.
     * @returns The along-track distance, in nautical miles, from the end of the specified flight plan leg given the
     * specified state and along-vector distance.
     */
    getLegDistanceRemaining(plan, state, vectorDistanceRemaining) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, state.isSuspended);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let vectorIndex = state.vectorIndex;
      let distanceRemaining = 0;
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex + 1; i < calcs.ingressJoinIndex; i++) {
            distanceRemaining += vectors[i].distance;
          }
          if (state.vectorIndex < calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
          vectorIndex = -1;
        }
        vectors = calcs.ingressToEgress;
      }
      for (let i = vectorIndex + 1; i < vectors.length; i++) {
        distanceRemaining += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Ingress:
          vectors = LNavUtils.getVectorsForTransitionMode(calcs, LNavTransitionMode.None, state.isSuspended);
          for (let i = Math.max(0, state.isSuspended ? calcs.ingressJoinIndex : 0); i < vectors.length; i++) {
            const currentVector = vectors[i];
            if (state.isSuspended && i === calcs.ingressJoinIndex) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              if (lastIngressVector) {
                const circle = FlightPathUtils.setGeoCircleFromVector(currentVector, this.geoCircleCache[0]);
                distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(this.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon), this.geoPointCache[1].set(currentVector.endLat, currentVector.endLon), Math.PI), UnitType.METER);
                continue;
              }
            }
            distanceRemaining += currentVector.distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          if (!state.isSuspended) {
            vectors = calcs.egress;
            for (let i = 0; i < vectors.length; i++) {
              distanceRemaining += vectors[i].distance;
            }
          }
      }
      return UnitType.METER.convertTo(distanceRemaining, UnitType.NMILE) + vectorDistanceRemaining;
    }
    /**
     * Copies one LNAV state object to another.
     * @param source The LNAV state from which to copy.
     * @param target The LNAV state to which to copy.
     * @returns The target LNAV state of the copy operation.
     */
    static copyStateInfo(source, target) {
      target.globalLegIndex = source.globalLegIndex;
      target.transitionMode = source.transitionMode;
      target.vectorIndex = source.vectorIndex;
      target.isSuspended = source.isSuspended;
      target.inhibitedSuspendLegIndex = source.inhibitedSuspendLegIndex;
      target.resetVectorsOnSuspendEnd = source.resetVectorsOnSuspendEnd;
      target.isMissedApproachActive = source.isMissedApproachActive;
      return target;
    }
    /**
     * Gets the ideal bank angle, in degrees, to follow a flight path vector under conditions of no cross-track error
     * and no wind, at a given ground speed.
     * @param vector The flight path vector to follow.
     * @param groundSpeed Ground speed, in knots.
     * @returns The ideal bank angle, in degrees, to follow the specified flight path vector at the specified ground
     * speed.
     */
    static getVectorIdealBankAngle(vector, groundSpeed) {
      if (FlightPathUtils.isVectorGreatCircle(vector)) {
        return 0;
      }
      if (vector.radius < MathUtils.HALF_PI) {
        return NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(vector.radius, UnitType.METER));
      } else {
        return -NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(Math.PI - vector.radius, UnitType.METER));
      }
    }
  };
  LNavDirector.ANGULAR_TOLERANCE = GeoCircle.ANGULAR_TOLERANCE;
  LNavDirector.ANGULAR_TOLERANCE_METERS = UnitType.GA_RADIAN.convertTo(GeoCircle.ANGULAR_TOLERANCE, UnitType.METER);
  LNavDirector.BANK_SERVO_RATE = 10;
  LNavDirector.VECTOR_ANTICIPATION_BANK_RATE = 5;
  var APBackCourseDirector = class {
    /**
     * Creates a new instance of APBackCourseDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param mode The APLateralMode for this instance of the director.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     */
    constructor(bus, apValues, mode, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APBackCourseDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
    }
    /**
     * Activates this director.
     */
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     */
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
      var _a, _b, _c, _d, _e;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      this.isApproachMode.set(false);
      return false;
    }
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && ((_f = this.loc) === null || _f === void 0 ? void 0 : _f.course)) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_h = (_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) !== null && _h !== void 0 ? _h : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    desiredBank() {
      var _a, _b, _c, _d, _e, _f;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      if (!isLoc || isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (this.cdi && this.cdi.deviation !== null) {
        const xtk = this.cdi && this.cdi.deviation !== null ? this.getXtk(-this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_e = -((_d = this.cdi) === null || _d === void 0 ? void 0 : _d.deviation)) !== null && _e !== void 0 ? _e : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_f = this.magVar) !== null && _f !== void 0 ? _f : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    /**
     * Gets a xtk value from the nav input data.
     * @param deviation is the input deviation value
     * @param isLoc is whether this is a LOC signal.
     * @returns The xtk value.
     */
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APBackCourseDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    /**
     * Checks if we might be getting a wild deviation because of the zone of confusion and allows APNavDirector some time to resolve.
     * @returns Whether we might be in the zone of confusion.
     */
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    /**
     * Method to monitor nav events to keep track of NAV related data needed for guidance.
     */
    monitorEvents() {
      const sub = this.bus.getSubscriber();
      sub.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
      sub.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
      sub.on("cdi_select").handle((source) => {
        this.navSource = source;
        if (this.state === DirectorState.Active) {
          this.deactivate();
        }
      });
      sub.on("nav_radio_active_nav_location").handle((loc) => {
        this.navLocation.set(loc.lat, loc.long);
      });
      sub.on("nav_radio_active_magvar").handle((magVar) => {
        this.magVar = magVar;
      });
      sub.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub.on("tas").handle((s) => this.tas = s);
      sub.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APBackCourseDirector.BANK_SERVO_RATE = 10;
  var APLvlDirector = class {
    /**
     * Creates an instance of the wing leveler.
     * @param bus The event bus to use with this instance.
     * @param isToGaMode Whether this director is being used as a TO/GA lateral mode
     * (and thus shouldn't set the 'AUTOPILOT WING LEVELER' simvar)
     */
    constructor(bus, isToGaMode = false) {
      this.bus = bus;
      this.isToGaMode = isToGaMode;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.bankServo = new LinearServo(APLvlDirector.BANK_SERVO_RATE);
      this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      this.desiredBank = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", true);
      }
      this.bankServo.reset();
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", false);
      }
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank);
      }
    }
    /**
     * Sets the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APLvlDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APLvlDirector.BANK_SERVO_RATE = 10;
  var APVNavPathDirector = class {
    /**
     * Creates an instance of the APVNavPathDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
      this.bus = bus;
      this.apValues = apValues;
      this.deviation = 0;
      this.fpa = 0;
      this.verticalWindAverage = new SimpleMovingAverage(10);
      this.tas = 0;
      this.groundSpeed = 0;
      this.state = DirectorState.Inactive;
      this.bus.getSubscriber().on("vnav_vertical_deviation").whenChanged().handle((dev) => this.deviation = dev);
      this.bus.getSubscriber().on("vnav_fpa").whenChanged().handle((fpa) => this.fpa = fpa);
      this.bus.getSubscriber().on("tas").withPrecision(0).handle((tas) => {
        this.tas = tas;
      });
      this.bus.getSubscriber().on("ground_speed").withPrecision(0).handle((gs) => {
        this.groundSpeed = gs;
      });
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD", "Bool", 0);
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
    }
    /**
     * Arms this director.
     */
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      this.onDeactivate && this.onDeactivate();
    }
    /**
     * Updates this director.
     */
    update() {
      if (this.state === DirectorState.Active) {
        this.setPitch(this.getDesiredPitch());
      }
    }
    /**
     * Gets a desired pitch from the FPA, AOA and Deviation.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
      const fpaVsRequired = VNavUtils.getVerticalSpeedFromFpa(this.fpa, this.groundSpeed) * -1;
      const fpaPercentage = Math.max(this.deviation / (VNavUtils.getPathErrorDistance(this.groundSpeed) * -1), -1) + 1;
      const vsRequiredForFpa = MathUtils.clamp(fpaVsRequired * fpaPercentage, fpaVsRequired - 1500, 1e3);
      const verticalWindComponent = this.verticalWindAverage.getAverage(SimVar.GetSimVarValue("AMBIENT WIND Y", SimVarValueType.FPM));
      const vsRequiredWithVerticalWind = vsRequiredForFpa - verticalWindComponent;
      const pitchForVerticalSpeed = VNavUtils.getFpa(UnitType.NMILE.convertTo(this.tas / 60, UnitType.FOOT), vsRequiredWithVerticalWind);
      const aoa = SimVar.GetSimVarValue("INCIDENCE ALPHA", SimVarValueType.Degree);
      return aoa + pitchForVerticalSpeed;
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, -targetPitch);
      }
    }
  };
  var APTogaPitchDirector = class {
    /**
     * Creates an instance of the LateralDirector.
     * @param targetPitchValue the pitch to set, in positive degrees, by this director.
     */
    constructor(targetPitchValue = 10) {
      this.targetPitchValue = targetPitchValue;
      this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setPitch(-this.targetPitchValue);
      SimVar.SetSimVarValue("AUTOPILOT TAKEOFF POWER ACTIVE", "Bool", true);
      SimVar.SetSimVarValue("L:WT_TOGA_ACTIVE", "Bool", true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT TAKEOFF POWER ACTIVE", "Bool", false);
      SimVar.SetSimVarValue("L:WT_TOGA_ACTIVE", "Bool", false);
    }
    /**
     * Updates this director.
     */
    update() {
    }
    /**
     * Sets the desired AP pitch angle.
     * @param targetPitch The desired AP pitch angle.
     */
    setPitch(targetPitch) {
      if (isFinite(targetPitch)) {
        SimVar.SetSimVarValue("AUTOPILOT PITCH HOLD REF", SimVarValueType.Degree, targetPitch);
      }
    }
  };
  var BottomTargetPathCalculator = class {
    /**
     * Creates an instance of the VNavPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param defaultFpa The default FPA for this path calculator.
     * @param defaultMaxFpa The default maximum FPA value for this path calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, defaultFpa, defaultMaxFpa) {
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.primaryPlanIndex = primaryPlanIndex;
      this.verticalFlightPlans = [];
      this.currentAltitude = 0;
      this.planBuilt = new SubEvent();
      this.vnavCalculated = new SubEvent();
      this.flightPlanIterator = new FlightPlanLegIterator();
      this.setFpaHandler = (fpa) => {
        const lateralPlan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
        const verticalPlan = this.verticalFlightPlans[this.primaryPlanIndex];
        const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
        const leg = lateralPlan.tryGetLeg(lateralPlan.activeLateralLeg);
        if (leg && constraint) {
          leg.verticalData.fpa = fpa;
          constraint.fpa = fpa;
          constraint.type = "manual";
          this.computeVnavPath(verticalPlan, lateralPlan);
        }
      };
      this.flightPathAngle = defaultFpa;
      this.maxFlightPathAngle = defaultMaxFpa;
      const fpl = bus.getSubscriber();
      fpl.on("fplCreated").handle((e) => e.planIndex === 0 && this.createVerticalPlan(e.planIndex));
      fpl.on("fplCopied").handle((e) => e.targetPlanIndex === 0 && this.onPlanChanged(e.targetPlanIndex));
      fpl.on("fplLoaded").handle((e) => e.planIndex === 0 && this.onPlanChanged(e.planIndex));
      fpl.on("fplLegChange").handle((e) => e.planIndex === 0 && this.onPlanChanged(e.planIndex, e));
      fpl.on("fplSegmentChange").handle((e) => e.planIndex === 0 && this.onPlanChanged(e.planIndex, void 0, e));
      fpl.on("fplIndexChanged").handle((e) => e.planIndex === 0 && this.onPlanChanged(e.planIndex));
      fpl.on("fplCalculated").handle((e) => e.planIndex === 0 && this.onPlanCalculated(e));
      bus.getSubscriber().on("indicated_alt").whenChangedBy(1).handle((alt) => this.currentAltitude = UnitType.FOOT.convertTo(alt, UnitType.METER));
      bus.getSubscriber().on("vnav_set_current_fpa").handle(this.setFpaHandler);
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
      if (this.verticalFlightPlans[planIndex] !== void 0) {
        return this.verticalFlightPlans[planIndex];
      } else {
        return this.createVerticalPlan(planIndex);
      }
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
      const verticalFlightPlan = {
        planIndex,
        length: 0,
        constraints: [],
        segments: [],
        destLegIndex: void 0,
        fafLegIndex: void 0,
        firstDescentConstraintLegIndex: void 0,
        lastDescentConstraintLegIndex: void 0,
        missedApproachStartIndex: void 0,
        currentAlongLegDistance: void 0,
        verticalDirectIndex: void 0,
        verticalDirectFpa: void 0,
        planChanged: true
      };
      this.verticalFlightPlans[planIndex] = verticalFlightPlan;
      return this.verticalFlightPlans[planIndex];
    }
    /** @inheritdoc */
    setCurrentAlongLegDistance(planIndex, distance) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      verticalPlan.currentAlongLegDistance = distance;
    }
    /** @inheritdoc */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return priorConstraintIndex;
      }
      let i = verticalPlan.constraints.length - 1;
      while (i >= 0) {
        const constraint = verticalPlan.constraints[i];
        if (globalLegIndex <= constraint.index && constraint.isTarget && !constraint.isBeyondFaf) {
          return i;
        }
        i--;
      }
      return -1;
    }
    /** @inheritdoc */
    getTargetConstraint(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
      var _a;
      return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (this.flightPlanner.hasFlightPlan(0)) {
        const plan = this.flightPlanner.getFlightPlan(0);
        const index = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, plan.activeLateralLeg);
        if (index > -1) {
          const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, index);
          switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
            case "climb":
            case "missed":
              return VerticalFlightPhase.Climb;
          }
        }
      }
      return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint.targetAltitude;
      } else {
        return currentConstraint && currentConstraint.targetAltitude ? currentConstraint.targetAltitude : void 0;
      }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return { type: AltitudeRestrictionType.At, altitude: Math.round(UnitType.METER.convertTo(priorConstraint.targetAltitude, UnitType.FOOT)) };
      } else if (currentConstraint && currentConstraint.targetAltitude) {
        return { type: AltitudeRestrictionType.At, altitude: Math.round(UnitType.METER.convertTo(currentConstraint.targetAltitude, UnitType.FOOT)) };
      } else {
        return { type: AltitudeRestrictionType.Unused, altitude: 0 };
      }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      return currentConstraint && currentConstraint.targetAltitude ? currentConstraint.targetAltitude : void 0;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
      if (currentConstraint) {
        const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
        if (currentConstraintIndex > -1) {
          if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "climb" || constraint.type === "missed") {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          } else {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
                if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          }
        }
      }
      return void 0;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
      const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
      this.buildVerticalPath(plan, verticalPlan, verticalPlan.verticalDirectIndex);
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
      const plan = this.flightPlanner.getFlightPlan(planIndex);
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex !== void 0) {
        if (legChangeEvent !== void 0) {
          const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
          if (globalIndex <= verticalPlan.verticalDirectIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        } else if (segmentChangeEvent !== void 0) {
          const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
          if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        }
      }
      verticalPlan.planChanged = true;
      verticalPlan.currentAlongLegDistance = void 0;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
      const lateralPlan = this.flightPlanner.getFlightPlan(event.planIndex);
      const verticalPlan = this.getVerticalFlightPlan(event.planIndex);
      if (verticalPlan.planChanged) {
        this.buildVerticalPath(lateralPlan, verticalPlan, verticalPlan.verticalDirectIndex);
      } else {
        this.computeVnavPath(verticalPlan, lateralPlan);
      }
    }
    /**
     * Resets the VNAV plan segments, legs, and constraints based on the new plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param verticalDirectIndex The vertical direct index, if any
     */
    buildVerticalPath(lateralPlan, verticalPlan, verticalDirectIndex) {
      var _a, _b, _c, _d, _e, _f;
      verticalPlan.fafLegIndex = VNavUtils.getFafIndexReverse(lateralPlan, this.flightPlanIterator);
      verticalPlan.constraints.length = 0;
      let currentConstraintAlt = 0;
      let priorConstraintAlt = Number.POSITIVE_INFINITY;
      let pathIsDirect = false;
      let constraintContainsManualLeg = false;
      let currentConstraint = this.createConstraint(0, 0, "$DEFAULT", "descent");
      verticalPlan.segments.length = 0;
      verticalPlan.destLegIndex = Math.max(0, lateralPlan.length - 1);
      verticalPlan.missedApproachStartIndex = verticalPlan.destLegIndex;
      const directToData = lateralPlan.directToData;
      const directToGlobalLegIndex = directToData.segmentIndex > 0 && directToData.segmentLegIndex > -1 ? lateralPlan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex : -1;
      for (const segment of lateralPlan.segments()) {
        verticalPlan.segments[segment.segmentIndex] = {
          offset: segment.offset,
          legs: []
        };
        let missedApproachFound = false;
        for (let legIndex = 0; legIndex < segment.legs.length; legIndex++) {
          const planLeg = segment.legs[legIndex];
          const leg = this.createLeg(segment.segmentIndex, legIndex, (_a = planLeg.name) !== null && _a !== void 0 ? _a : "", (_c = (_b = planLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : void 0);
          const globalLegIndex = segment.offset + legIndex;
          switch (planLeg.leg.type) {
            case LegType.CI:
            case LegType.VI:
            case LegType.FM:
            case LegType.VM:
              constraintContainsManualLeg = true;
          }
          if (segment.segmentType === FlightPlanSegmentType.Approach && !missedApproachFound && BitFlags.isAll(planLeg.flags, LegDefinitionFlags.MissedApproach)) {
            verticalPlan.missedApproachStartIndex = globalLegIndex;
            verticalPlan.destLegIndex = Math.max(0, globalLegIndex - 1);
            missedApproachFound = true;
          }
          if (verticalDirectIndex !== void 0 && verticalDirectIndex === globalLegIndex) {
            currentConstraint.type = "direct";
            pathIsDirect = true;
          }
          if (directToData.segmentIndex === segment.segmentIndex && legIndex === directToData.segmentLegIndex + 3 && BitFlags.isAll(planLeg.flags, LegDefinitionFlags.DirectTo)) {
            currentConstraint.type = "direct";
            pathIsDirect = true;
            currentConstraint.legs.length = 0;
            if (verticalPlan.constraints.length > 0) {
              verticalPlan.constraints.length = 0;
            }
          }
          let legIsConstraint = false;
          if (segment.segmentType !== FlightPlanSegmentType.Origin && segment.segmentType !== FlightPlanSegmentType.Departure && planLeg.verticalData && planLeg.verticalData.altDesc !== AltitudeRestrictionType.Unused && globalLegIndex <= verticalPlan.fafLegIndex && !missedApproachFound) {
            currentConstraintAlt = this.getConstraintAltitude(planLeg);
            const tempConstraintDistance = VNavUtils.getConstraintDistanceFromConstraint(currentConstraint);
            const fpaTempValue = VNavUtils.getFpa(leg.distance + tempConstraintDistance, Math.abs(currentConstraintAlt - priorConstraintAlt));
            const currentWithPrecision = Math.round(currentConstraintAlt * 10) / 10;
            const priorWithPrecision = Math.round(priorConstraintAlt * 10) / 10;
            if (verticalDirectIndex !== void 0 && verticalDirectIndex > globalLegIndex || globalLegIndex <= directToGlobalLegIndex) {
              legIsConstraint = false;
            } else if (currentWithPrecision > priorWithPrecision || !constraintContainsManualLeg && (priorConstraintAlt < Number.POSITIVE_INFINITY && fpaTempValue > 6)) {
              leg.invalidConstraintAltitude = currentConstraintAlt;
            } else {
              legIsConstraint = true;
            }
          }
          currentConstraint.legs.unshift(leg);
          verticalPlan.segments[segment.segmentIndex].legs.push(leg);
          switch (planLeg.leg.type) {
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
            case LegType.VM:
            case LegType.FM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
              leg.isEligible = false;
              if (verticalPlan.constraints.length > 0) {
                const priorConstraint = verticalPlan.constraints[0];
                priorConstraint.isPathEnd = true;
                priorConstraint.isTarget = true;
                priorConstraint.nextVnavEligibleLegIndex = globalLegIndex + 1;
              }
          }
          const isLastLeg = globalLegIndex === lateralPlan.length - 1;
          if (legIsConstraint || isLastLeg) {
            currentConstraint.index = globalLegIndex;
            currentConstraint.name = isLastLeg ? "$DEST" : (_d = planLeg.name) !== null && _d !== void 0 ? _d : "";
            currentConstraint.type = isLastLeg ? "dest" : pathIsDirect ? "direct" : "descent";
            currentConstraint.targetAltitude = globalLegIndex > verticalPlan.fafLegIndex ? priorConstraintAlt : currentConstraintAlt;
            currentConstraint.minAltitude = currentConstraint.targetAltitude;
            currentConstraint.maxAltitude = currentConstraint.targetAltitude;
            if (pathIsDirect) {
              currentConstraint.isTarget = true;
            }
            if (globalLegIndex === verticalPlan.fafLegIndex) {
              currentConstraint.isTarget = true;
              currentConstraint.isPathEnd = true;
            }
            if (planLeg.verticalData.fpa && lateralPlan.activeLateralLeg <= globalLegIndex && lateralPlan.activeLateralLeg >= currentConstraint.legs[currentConstraint.legs.length - 1].legIndex) {
              currentConstraint.fpa = planLeg.verticalData.fpa;
              currentConstraint.type = "manual";
            } else if (planLeg.verticalData.fpa) {
              planLeg.verticalData.fpa = void 0;
            }
            if (!isLastLeg || isLastLeg && verticalPlan.fafLegIndex === lateralPlan.length - 1) {
              verticalPlan.constraints.unshift(currentConstraint);
              constraintContainsManualLeg = false;
              pathIsDirect = false;
            }
            priorConstraintAlt = currentConstraint.targetAltitude;
            if (!isLastLeg) {
              currentConstraint = this.createConstraint(lateralPlan.length - 1, 0, "$DEFAULT", "descent");
            }
          }
        }
      }
      verticalPlan.length = lateralPlan.length;
      verticalPlan.firstDescentConstraintLegIndex = (_e = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _e === void 0 ? void 0 : _e.index;
      verticalPlan.lastDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
      verticalPlan.planChanged = false;
      this.notifyBuilt(verticalPlan.planIndex);
      this.computeVnavPath(verticalPlan, lateralPlan);
    }
    /**
     * Computes the VNAV descent path.
     * @param verticalPlan The Vertical Flight Plan
     * @param lateralPlan The Lateral Flight Plan
     */
    computeVnavPath(verticalPlan, lateralPlan) {
      this.fillLegAndConstraintDistances(verticalPlan, lateralPlan);
      if (this.needRevalidateConstraints(verticalPlan, lateralPlan) || !this.computeFlightPathAngles(verticalPlan)) {
        this.buildVerticalPath(lateralPlan, verticalPlan, verticalPlan.verticalDirectIndex);
        return;
      }
      for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
        const constraint = verticalPlan.constraints[constraintIndex];
        if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual" || constraint.type === "dest") {
          let altitude = constraint.targetAltitude;
          for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
            const leg = constraint.legs[legIndex];
            leg.fpa = verticalPlan.fafLegIndex !== void 0 && constraint.index <= verticalPlan.fafLegIndex ? constraint.fpa : 0;
            leg.altitude = altitude;
            altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
            if (legIndex === 0) {
              leg.isAdvisory = false;
            } else {
              leg.isAdvisory = true;
            }
            if (legIndex === 0 && constraint.isTarget) {
              leg.isBod = true;
            } else {
              leg.isBod = false;
            }
          }
        }
      }
      this.notifyCalculated(verticalPlan.planIndex);
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param verticalPlan The Vertical Flight Plan
     * @param lateralPlan The Lateral Flight Plan
     */
    fillLegAndConstraintDistances(verticalPlan, lateralPlan) {
      this.flightPlanIterator.iterateReverse(lateralPlan, (cursor) => {
        var _a, _b, _c;
        return verticalPlan.segments[cursor.segment.segmentIndex].legs[cursor.legIndex].distance = (_c = (_b = (_a = cursor.legDefinition) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
      });
      for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
        const constraint = verticalPlan.constraints[constraintIndex];
        constraint.distance = VNavUtils.getConstraintDistanceFromConstraint(constraint);
      }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
      let isCurrentlyDirect = false;
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        const currentConstraint = verticalPlan.constraints[i];
        const nextConstraint = verticalPlan.constraints[i + 1];
        currentConstraint.legs.forEach((leg) => {
          if (leg.invalidConstraintAltitude) {
            return false;
          }
        });
        if (currentConstraint.type === "manual") {
          continue;
        }
        if (currentConstraint.type !== "direct") {
          currentConstraint.fpa = this.flightPathAngle;
        }
        currentConstraint.isTarget = isCurrentlyDirect ? false : true;
        if (currentConstraint.index === verticalPlan.fafLegIndex) {
          currentConstraint.isTarget = true;
        }
        if (verticalPlan.fafLegIndex !== void 0 && currentConstraint.index > verticalPlan.fafLegIndex) {
          currentConstraint.isBeyondFaf = true;
        }
        if (nextConstraint !== void 0 && nextConstraint.type !== "climb" && !nextConstraint.isPathEnd) {
          const directFpa = VNavUtils.getFpa(currentConstraint.distance, nextConstraint.targetAltitude - currentConstraint.targetAltitude);
          const endAltitude = currentConstraint.targetAltitude + VNavUtils.altitudeForDistance(this.flightPathAngle, currentConstraint.distance);
          if (Math.abs(directFpa - this.flightPathAngle) <= 0.5 || endAltitude < nextConstraint.targetAltitude) {
            if (directFpa > this.maxFlightPathAngle && i !== 0) {
              return false;
            } else {
              currentConstraint.fpa = directFpa;
              isCurrentlyDirect = true;
            }
          } else if (currentConstraint.targetAltitude === nextConstraint.targetAltitude || currentConstraint.isBeyondFaf) {
            currentConstraint.fpa = 0;
            isCurrentlyDirect = false;
          } else {
            isCurrentlyDirect = false;
          }
        } else {
          isCurrentlyDirect = false;
        }
        if (currentConstraint.type === "direct" && currentConstraint.fpa === 0 && verticalPlan.currentAlongLegDistance !== void 0) {
          const plan = this.flightPlanner.getActiveFlightPlan();
          const legsToConstraint = currentConstraint.index - plan.activeLateralLeg;
          let distance = 0;
          for (let l = 0; l <= legsToConstraint; l++) {
            const leg = currentConstraint.legs[l];
            distance += leg.distance;
          }
          distance -= verticalPlan.currentAlongLegDistance;
          const fpaRequired = VNavUtils.getFpa(distance, 50 + this.currentAltitude - currentConstraint.targetAltitude);
          const minFpaClamp = verticalPlan.verticalDirectIndex === currentConstraint.index ? 0 : 3;
          currentConstraint.fpa = Utils.Clamp(fpaRequired, minFpaClamp, this.maxFlightPathAngle);
        }
      }
      return true;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.constraints.length > 0) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
          const constraint = verticalPlan.constraints[i];
          if (constraint.type !== "climb" && constraint.type !== "missed") {
            return constraint.targetAltitude;
          }
        }
      }
      return void 0;
    }
    /**
     * Gets the constraint for a leg altitude restriction.
     * @param leg The leg to get the constraint for.
     * @returns The altitude constraint.
     */
    getConstraintAltitude(leg) {
      switch (leg.verticalData.altDesc) {
        case AltitudeRestrictionType.At:
        case AltitudeRestrictionType.AtOrAbove:
        case AltitudeRestrictionType.AtOrBelow:
          return leg.verticalData.altitude1;
        case AltitudeRestrictionType.Between:
          return leg.verticalData.altitude2;
      }
      return Number.POSITIVE_INFINITY;
    }
    /**
     * Checks whether any previously invalid constraints in the flight plan have become valid.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @returns Whether any previously invalid constraints in the flight plan have become valid.
     */
    needRevalidateConstraints(verticalPlan, lateralPlan) {
      if (verticalPlan.constraints.length > 0 && lateralPlan.length > 0) {
        const lastGlobalLegIndex = Math.max(0, lateralPlan.length - 1);
        for (let l = 0; l <= lastGlobalLegIndex; l++) {
          const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, l);
          if (verticalLeg.invalidConstraintAltitude !== void 0) {
            const previousConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, l) + 1;
            const previousConstraint = verticalPlan.constraints[previousConstraintIndex];
            const lateralLeg = lateralPlan.tryGetLeg(l);
            if (lateralLeg !== null) {
              const constraintAltitude = this.getConstraintAltitude(lateralLeg);
              if (isFinite(constraintAltitude)) {
                const proposedConstraint = this.createConstraint(l, constraintAltitude, verticalLeg.name, "descent");
                proposedConstraint.distance = VNavUtils.getConstraintDistanceFromLegs(proposedConstraint, previousConstraint, verticalPlan);
                if (!BottomTargetPathCalculator.isConstraintHigherThanPriorConstraint(previousConstraint, proposedConstraint) && !BottomTargetPathCalculator.doesConstraintRequireInvalidFpa(previousConstraint, proposedConstraint, verticalPlan, this.maxFlightPathAngle)) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
      const currentWithPrecision = Math.round(currentConstraint.targetAltitude * 10) / 10;
      const priorWithPrecision = Math.round(previousConstrant.targetAltitude * 10) / 10;
      if (currentWithPrecision > priorWithPrecision) {
        return true;
      }
      return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
      if (currentConstraint.targetAltitude < Number.POSITIVE_INFINITY && previousConstrant.targetAltitude >= 0) {
        const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
        const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.targetAltitude - previousConstrant.targetAltitude));
        if (minFpaTempValue > maxFpa) {
          return true;
        }
      }
      return false;
    }
    /**
     * Creates a new empty constraint.
     * @param index The leg index of the constraint.
     * @param targetAltitude The altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    createConstraint(index, targetAltitude, name, type) {
      return {
        index,
        targetAltitude,
        minAltitude: Number.NEGATIVE_INFINITY,
        maxAltitude: Number.POSITIVE_INFINITY,
        name,
        isTarget: false,
        isPathEnd: false,
        distance: 0,
        fpa: 0,
        legs: [],
        type,
        isBeyondFaf: false
      };
    }
    /**
     * Creates a new VNAV plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    createLeg(segmentIndex, legIndex, name, distance = 0) {
      return {
        segmentIndex,
        legIndex,
        fpa: 0,
        altitude: 0,
        isUserDefined: false,
        isDirectToTarget: false,
        distance,
        isEligible: true,
        isBod: false,
        isAdvisory: true,
        name
      };
    }
    /**
     * Sends an event when a vertical plan has been built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
      this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event when a vertical plan has been calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
      this.vnavCalculated.notify(this, planIndex);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    requestPathCompute(planIndex) {
      return false;
    }
  };
  var GlidePathCalculator = class {
    /**
     * Creates an instance of the GlidePathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary plan index to use for calculating GlidePath.
     */
    constructor(bus, flightPlanner, primaryPlanIndex) {
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.primaryPlanIndex = primaryPlanIndex;
      this.mapLegIndex = 0;
      this.fafLegIndex = 0;
      this.planePos = new GeoPoint(0, 0);
      this.glidepathFpa = 0;
      this.flightPlanIterator = new FlightPlanLegIterator();
      this.onPlanChanged = () => {
        if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
          const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
          this.mapLegIndex = VNavUtils.getMissedApproachLegIndex(plan);
          const faf = VNavUtils.getFafIndex(plan);
          this.fafLegIndex = faf !== void 0 ? faf : Math.max(0, plan.length - 1);
        }
      };
      this.onPlanCalculated = () => {
        if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
          const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
          this.calcGlidepathFpa(plan);
        }
      };
      const fpl = bus.getSubscriber();
      fpl.on("fplCopied").handle((e) => e.planIndex === 0 || e.targetPlanIndex === 0 && this.onPlanChanged());
      fpl.on("fplCreated").handle((e) => e.planIndex === 0 && this.onPlanChanged());
      fpl.on("fplLegChange").handle((e) => {
        if (e.planIndex === 0) {
          this.onPlanChanged();
        }
      });
      fpl.on("fplLoaded").handle((e) => e.planIndex === 0 && this.onPlanChanged());
      fpl.on("fplSegmentChange").handle((e) => {
        if (e.planIndex === 0) {
          this.onPlanChanged();
        }
      });
      fpl.on("fplIndexChanged").handle(() => this.onPlanChanged());
      fpl.on("fplCalculated").handle((e) => e.planIndex === 0 && this.onPlanCalculated());
      const gnss = this.bus.getSubscriber();
      gnss.on("gps-position").handle((lla) => {
        this.planePos.set(lla.lat, lla.long);
      });
    }
    /**
     * Gets the current Glidepath distance in meters.
     * @param index The global index of the active leg.
     * @param distanceAlongLeg The aircraft's current distance along the active leg, in meters.
     * @returns The current Glidepath distance in meters.
     */
    getGlidepathDistance(index, distanceAlongLeg) {
      var _a, _b;
      let globalLegIndex = 0;
      let distance = 0;
      const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
      const destLeg = plan.getLeg(this.mapLegIndex);
      if (index <= this.mapLegIndex) {
        for (let segmentIndex = 0; segmentIndex < plan.segmentCount; segmentIndex++) {
          const segment = plan.getSegment(segmentIndex);
          for (let legIndex = 0; legIndex < segment.legs.length; legIndex++) {
            const leg = segment.legs[legIndex];
            if (leg.calculated !== void 0 && globalLegIndex <= this.mapLegIndex) {
              if (index === globalLegIndex) {
                distance += ((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) - distanceAlongLeg;
              } else if (globalLegIndex > index) {
                distance += (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions;
              }
            }
            globalLegIndex++;
          }
        }
        if (ICAO.isFacility(destLeg.leg.fixIcao) && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY && plan.procedureDetails.destinationRunway !== void 0 && destLeg.calculated && destLeg.calculated.endLat !== void 0 && destLeg.calculated.endLon !== void 0) {
          const runway = plan.procedureDetails.destinationRunway;
          const runwayGeoPoint = new GeoPoint(runway.latitude, runway.longitude);
          if (index === this.mapLegIndex && distanceAlongLeg >= destLeg.calculated.distanceWithTransitions - 1) {
            const destEnd = new GeoPoint(destLeg.calculated.endLat, destLeg.calculated.endLon);
            distance = UnitType.NMILE.convertTo(NavMath.alongTrack(runwayGeoPoint, destEnd, this.planePos), UnitType.METER);
          } else {
            distance += UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(destLeg.calculated.endLat, destLeg.calculated.endLon), UnitType.METER);
          }
        }
      }
      return distance;
    }
    /**
     * Gets the Glidepath desired altitude in meters.
     * @param distance The current Glidepath distance in meters.
     * @returns The current Glidepath desired altitude in meters.
     */
    getDesiredGlidepathAltitude(distance) {
      return this.getRunwayAltitude() + VNavUtils.altitudeForDistance(this.glidepathFpa, distance);
    }
    /**
     * Gets the Glidepath runway altitude in meters.
     * @returns The Glidepath runway altitude in meters.
     */
    getRunwayAltitude() {
      const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
      const destLeg = plan.getLeg(this.mapLegIndex);
      let destAltitude = destLeg.leg.altitude1;
      if (ICAO.isFacility(destLeg.leg.fixIcao) && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY && plan.procedureDetails.destinationRunway !== void 0) {
        destAltitude = plan.procedureDetails.destinationRunway.elevation;
      }
      return destAltitude;
    }
    /**
     * Calculates the Glidepath flight path angle using the destination elevation
     * and FAF altitude restriction.
     * @param plan The plan to calculate from.
     */
    calcGlidepathFpa(plan) {
      if (plan.length < 2 || this.fafLegIndex > plan.length || this.mapLegIndex > plan.length) {
        return;
      }
      const fafLeg = plan.tryGetLeg(this.fafLegIndex);
      const destLeg = plan.tryGetLeg(this.mapLegIndex);
      if (!fafLeg || !destLeg) {
        return;
      }
      let fafToDestDistance = 0;
      for (let i = this.fafLegIndex + 1; i <= this.mapLegIndex; i++) {
        const leg = plan.getLeg(i);
        if (leg.calculated !== void 0) {
          fafToDestDistance += leg.calculated.distance;
        }
      }
      let destAltitude = destLeg.leg.altitude1;
      if (ICAO.isFacility(destLeg.leg.fixIcao) && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY && plan.procedureDetails.destinationRunway !== void 0 && destLeg.calculated && destLeg.calculated.endLat !== void 0 && destLeg.calculated.endLon !== void 0) {
        const runway = plan.procedureDetails.destinationRunway;
        const runwayGeoPoint = new GeoPoint(runway.latitude, runway.longitude);
        destAltitude = runway.elevation;
        fafToDestDistance += UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(destLeg.calculated.endLat, destLeg.calculated.endLon), UnitType.METER);
      }
      this.glidepathFpa = VNavUtils.getFpa(fafToDestDistance, fafLeg.leg.altitude1 - destAltitude);
    }
  };
  var SmoothingPathCalculator = class {
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator. Options that are not explicitly provided default to the following:
     * * `defaultFpa`: 3 degrees.
     * * `minFpa`: 1.5 degrees.
     * * `maxFpa`: 6 degrees.
     * * `excludeFirstLegConstraint`: `false`.
     * * `forceFirstApproachAtConstraint`: `false`.
     * * `directToLegOffset`: `3`.
     * * `isLegEligible`: a function which designates a leg as eligible if and only if it is not a discontinuity leg or
     * a manual termination leg that ends in a discontinuity.
     * * `shouldUseConstraint`: a function which always returns `true`.
     * * `invalidateClimbConstraint`: a function which does not invalidate any climb constraint.
     * * `invalidateDescentConstraint`: a function which invalidates a descent constraint if and only if it requires an
     * ascending path or a flight path angle greater than the maximum in order to meet it from the preceding constraint.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.primaryPlanIndex = primaryPlanIndex;
      this.verticalFlightPlans = [];
      this.planBuilt = new SubEvent();
      this.vnavCalculated = new SubEvent();
      this.legAltitudes = [0, 0];
      this.applyPathValuesResult = [void 0, 0];
      this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
      this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
      this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
      this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
      this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
      this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
      this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : () => true;
      this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
      this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
      const fpl = this.bus.getSubscriber();
      fpl.on("fplCreated").handle((e) => this.createVerticalPlan(e.planIndex));
      fpl.on("fplCopied").handle((e) => this.onPlanChanged(e.targetPlanIndex));
      fpl.on("fplLoaded").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplLegChange").handle((e) => this.onPlanChanged(e.planIndex, e));
      fpl.on("fplSegmentChange").handle((e) => this.onPlanChanged(e.planIndex, void 0, e));
      fpl.on("fplIndexChanged").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplCalculated").handle((e) => this.onPlanCalculated(e));
      bus.getSubscriber().on("vnav_set_default_fpa").handle(this.setDefaultFpa.bind(this));
      bus.getSubscriber().on("vnav_set_vnav_direct_to").handle((data) => {
        if (data.globalLegIndex < 0) {
          this.cancelVerticalDirect(data.planIndex);
        } else {
          this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
        }
      });
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
      var _a;
      var _b;
      return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : _b[planIndex] = this.createVerticalPlan(planIndex);
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
      const verticalFlightPlan = {
        planIndex,
        length: 0,
        constraints: [],
        segments: [],
        destLegIndex: void 0,
        fafLegIndex: void 0,
        firstDescentConstraintLegIndex: void 0,
        lastDescentConstraintLegIndex: void 0,
        missedApproachStartIndex: void 0,
        currentAlongLegDistance: void 0,
        verticalDirectIndex: void 0,
        verticalDirectFpa: void 0,
        planChanged: true
      };
      this.verticalFlightPlans[planIndex] = verticalFlightPlan;
      return verticalFlightPlan;
    }
    /** @inheritdoc */
    requestPathCompute(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== void 0) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        this.computePathAndNotify(lateralPlan, verticalPlan);
        return true;
      }
      return false;
    }
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
          const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
          if (priorConstraint && priorConstraint.type !== "climb" && priorConstraint.type !== "missed") {
            return priorConstraintIndex;
          } else {
            return -1;
          }
        }
        let i = verticalPlan.constraints.length - 1;
        while (i >= 0) {
          const constraint = verticalPlan.constraints[i];
          if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== "climb" && constraint.type !== "missed") {
            return i;
          }
          i--;
        }
      } else {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraintIndex >= 0) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isMissed = currentConstraint.type === "missed";
          for (let i = currentConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === "climb" || isMissed && constraint.type === "missed") {
              if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return i;
              }
            } else {
              return -1;
            }
          }
        }
      }
      return -1;
    }
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
      var _a, _b;
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
      } else {
        return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
      }
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex)) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
        if (globalLegIndex > -1) {
          const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
          switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
            case "climb":
            case "missed":
              return VerticalFlightPhase.Climb;
          }
        }
      }
      return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return void 0;
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
      } else {
        return currentConstraint.targetAltitude;
      }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return { type: AltitudeRestrictionType.Unused, altitude: 0 };
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        if (priorConstraint) {
          return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        } else {
          return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
      } else {
        return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
      }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint !== void 0) {
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
          if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
            return currentConstraint.maxAltitude;
          } else {
            return currentConstraint.minAltitude;
          }
        } else {
          if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
            return currentConstraint.minAltitude;
          } else {
            return currentConstraint.maxAltitude;
          }
        }
      }
      return void 0;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
      if (currentConstraint) {
        const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
        if (currentConstraintIndex > -1) {
          if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "climb" || constraint.type === "missed") {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          } else {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
                if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          }
        }
      }
      return void 0;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
      if (constraintGlobalLegIndex < 0) {
        return;
      }
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
      verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex === void 0) {
        return;
      }
      verticalPlan.verticalDirectIndex = void 0;
      verticalPlan.verticalDirectFpa = void 0;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    setDefaultFpa(fpa) {
      const newFpa = Math.max(0, fpa);
      if (newFpa !== this.flightPathAngle) {
        this.flightPathAngle = newFpa;
        for (let i = 0; i < this.verticalFlightPlans.length; i++) {
          const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : void 0;
          const verticalPlan = this.verticalFlightPlans[i];
          if (lateralPlan && verticalPlan) {
            if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
              verticalPlan.planChanged = true;
              this.notifyCalculated(i);
            }
          }
        }
      }
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
      const plan = this.flightPlanner.getFlightPlan(planIndex);
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex !== void 0) {
        if (legChangeEvent !== void 0) {
          const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
          if (globalIndex <= verticalPlan.verticalDirectIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        } else if (segmentChangeEvent !== void 0) {
          const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
          if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        }
      }
      verticalPlan.planChanged = true;
      verticalPlan.currentAlongLegDistance = void 0;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
      const lateralPlan = this.flightPlanner.getFlightPlan(event.planIndex);
      const verticalPlan = this.getVerticalFlightPlan(event.planIndex);
      if (verticalPlan.planChanged) {
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      } else {
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      }
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
      this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
      this.vnavCalculated.notify(this, planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
      this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
      this.notifyBuilt(verticalPlan.planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
      this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
      SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
      verticalPlan.planChanged = false;
    }
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
      var _a, _b, _c, _d, _e, _f, _g;
      verticalPlan.constraints.length = 0;
      verticalPlan.segments.length = 0;
      verticalPlan.destLegIndex = void 0;
      verticalPlan.firstDescentConstraintLegIndex = void 0;
      verticalPlan.lastDescentConstraintLegIndex = void 0;
      verticalPlan.missedApproachStartIndex = void 0;
      verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
      const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
      let firstApproachGlobalLegIndex;
      for (const segment of lateralPlan.segments()) {
        verticalPlan.segments[segment.segmentIndex] = {
          offset: segment.offset,
          legs: []
        };
        if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === void 0) {
          firstApproachGlobalLegIndex = segment.offset;
        }
        for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
          const globalLegIndex = segment.offset + segmentLegIndex;
          const lateralLeg = segment.legs[segmentLegIndex];
          const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : "", (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : void 0);
          if (verticalPlan.missedApproachStartIndex === void 0 && segment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            verticalPlan.missedApproachStartIndex = globalLegIndex;
          }
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
          verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
          const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== void 0 && globalLegIndex < verticalPlan.verticalDirectIndex;
          const legPrecedesDirectTo = directToTargetLegIndex !== void 0 && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
          if (constraintAltitudes !== void 0 && !legPrecedesVerticalDirectIndex && !legPrecedesDirectTo && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
            verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
            const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.unshift(verticalConstraint);
          }
          verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
        }
      }
      verticalPlan.length = lateralPlan.length;
      if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== void 0) {
        const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
        if (firstApproachConstraint && firstApproachConstraint.type !== "climb" && firstApproachConstraint.type !== "missed") {
          SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
        }
      }
      verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
      verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
      var _a;
      const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? "missed" : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? "descent" : "climb");
      constraint.isBeyondFaf = verticalPlan.fafLegIndex === void 0 ? false : globalLegIndex > verticalPlan.fafLegIndex;
      if (verticalPlan.verticalDirectIndex === globalLegIndex) {
        constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
        constraint.type = "direct";
      }
      const userFpa = lateralLeg.verticalData.fpa;
      if (userFpa !== void 0 && constraint.type !== "climb" && constraint.type !== "missed") {
        constraint.fpa = userFpa;
        constraint.type = "manual";
      }
      return constraint;
    }
    /**
     * Computes the vertical path for a flight plan and if successful, sends an event notifying subscribers that the plan
     * was calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     * @returns Whether a path was successfully computed.
     */
    computePathAndNotify(lateralPlan, verticalPlan) {
      if (this.computePath(lateralPlan, verticalPlan)) {
        this.notifyCalculated(lateralPlan.planIndex);
        return true;
      } else {
        return false;
      }
    }
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     * @returns Whether a path was successfully computed.
     */
    computePath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return false;
      }
      this.computeDescentPath(lateralPlan, verticalPlan);
      return true;
    }
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computeDescentPath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return;
      }
      this.fillLegDistances(lateralPlan, verticalPlan);
      this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
      this.findAndRemoveInvalidConstraints(verticalPlan);
      this.populateConstraints(verticalPlan);
      if (this.computeFlightPathAngles(verticalPlan)) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
          const constraint = verticalPlan.constraints[constraintIndex];
          if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
            let altitude = constraint.targetAltitude;
            let constraintIsBod = true;
            if (constraintIndex > 0) {
              const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
              if (nextConstraint !== void 0 && nextConstraint.type !== "climb") {
                const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                if (nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25 || constraint.fpa === 0) {
                  constraintIsBod = false;
                }
              }
            }
            if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
              constraint.isPathEnd = true;
              constraint.isTarget = true;
              constraintIsBod = true;
            }
            for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
              const leg = constraint.legs[legIndex];
              leg.fpa = constraint.fpa;
              leg.altitude = altitude;
              altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
              if (legIndex === 0) {
                leg.isAdvisory = false;
              } else {
                leg.isAdvisory = true;
              }
              if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                leg.isBod = true;
              } else {
                leg.isBod = false;
              }
            }
          }
        }
      }
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    fillLegDistances(lateralPlan, verticalPlan) {
      var _a, _b, _c;
      if (lateralPlan.length > 0) {
        for (const segment of lateralPlan.segments()) {
          if (segment) {
            const vnavSegment = verticalPlan.segments[segment.segmentIndex];
            for (let l = 0; l < segment.legs.length; l++) {
              const leg = segment.legs[l];
              if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
              } else if (leg && leg.calculated && leg.calculated.endLat !== void 0 && leg.calculated.endLon !== void 0) {
                let prevLeg;
                for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                  if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== void 0 && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== void 0) {
                    prevLeg = checkLeg;
                    break;
                  }
                }
                if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                  vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                }
              } else {
                vnavSegment.legs[l].distance = 0;
              }
            }
          }
        }
      }
    }
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    findAndRemoveInvalidConstraints(verticalPlan) {
      var _a, _b, _c;
      let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? firstDescentConstraintIndex : verticalPlan.constraints.length - 1;
      let phase = "climb";
      let priorMinAltitude = -Infinity;
      let priorMaxAltitude = Infinity;
      let distanceFromPriorMinAltitude = 0;
      let requiredFpa = 0;
      for (let i = startIndex; i >= 0; i--) {
        const currentConstraint = verticalPlan.constraints[i];
        const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
        let currentPhase;
        switch (currentConstraint.type) {
          case "climb":
          case "missed":
            currentPhase = currentConstraint.type;
            break;
          default:
            currentPhase = "descent";
        }
        if (currentPhase !== phase) {
          phase = currentPhase;
          priorMinAltitude = -Infinity;
          priorMaxAltitude = Infinity;
          distanceFromPriorMinAltitude = currentConstraintDistance;
        } else {
          distanceFromPriorMinAltitude += currentConstraintDistance;
        }
        let isDescentConstraint;
        let shouldInvalidate;
        switch (phase) {
          case "climb":
          case "missed":
            isDescentConstraint = false;
            shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
            break;
          default:
            isDescentConstraint = true;
            if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
              requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
            } else {
              requiredFpa = 0;
            }
            shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
        }
        const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
        if (shouldInvalidate) {
          constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
          verticalPlan.constraints.splice(i, 1);
          distanceFromPriorMinAltitude -= currentConstraintDistance;
          if (isDescentConstraint && i === firstDescentConstraintIndex) {
            firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
            verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
          }
        } else {
          constraintLeg.invalidConstraintAltitude = void 0;
          if (isFinite(currentConstraint.minAltitude)) {
            priorMinAltitude = currentConstraint.minAltitude;
            distanceFromPriorMinAltitude = 0;
          }
          if (isFinite(currentConstraint.maxAltitude)) {
            priorMaxAltitude = currentConstraint.maxAltitude;
          }
        }
      }
      verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
      var _a;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? verticalPlan.firstDescentConstraintLegIndex + 1 : 0;
      let globalLegIndex = startIndex;
      for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        if (verticalLeg.invalidConstraintAltitude !== void 0) {
          const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          if (constraintAltitudes !== void 0) {
            const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
            if (proposedConstraint.type === "descent" || proposedConstraint.type === "manual" || proposedConstraint.type === "direct" || proposedConstraint.type === "dest") {
              if (verticalPlan.firstDescentConstraintLegIndex === void 0 || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
              }
              if (verticalPlan.lastDescentConstraintLegIndex === void 0 || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
              }
            }
          }
        }
        globalLegIndex++;
      }
    }
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    populateConstraints(verticalPlan) {
      for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
        const constraint = verticalPlan.constraints[constraintIndex];
        const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
        constraint.legs.length = 0;
        constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
        let eligibleLegIndex;
        let ineligibleLegIndex;
        for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== void 0 ? previousConstraint.index : -1); globalLegIndex--) {
          const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
          constraint.legs.push(verticalLeg);
          if (ineligibleLegIndex === void 0 && verticalLeg.isEligible) {
            eligibleLegIndex = globalLegIndex;
          }
          if (ineligibleLegIndex === void 0 && !verticalLeg.isEligible) {
            ineligibleLegIndex = globalLegIndex;
          }
        }
        if (ineligibleLegIndex !== void 0 && eligibleLegIndex !== void 0) {
          constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
        }
      }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
      let currentTargetConstraint;
      let currentPathSegmentDistance = 0;
      let currentPathSegmentMinFpa = this.minFlightPathAngle;
      let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
      let currentTargetConstraintHasFixedFpa = false;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
      if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
        return false;
      }
      for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
        const constraint = verticalPlan.constraints[targetConstraintIndex];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (!currentTargetConstraint) {
          if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
            currentTargetConstraint = constraint;
            currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
            currentTargetConstraint.isTarget = true;
          } else {
            continue;
          }
        }
        currentPathSegmentMinFpa = this.minFlightPathAngle;
        currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        currentPathSegmentDistance = currentTargetConstraint.distance;
        const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
        if (currentTargetConstraintIsFirstDescentConstraint) {
          if (currentTargetConstraint.type === "descent") {
            currentTargetConstraint.fpa = this.flightPathAngle;
          }
          return true;
        }
        if (currentTargetConstraint.type === "manual") {
          currentPathSegmentMinFpa = currentTargetConstraint.fpa;
          currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
          currentTargetConstraintHasFixedFpa = true;
        } else {
          currentTargetConstraintHasFixedFpa = false;
        }
        let pathSegmentIsFlat = false;
        for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
          const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
          const isCurrentConstraintClimb = currentConstraint.type === "climb" || currentConstraint.type === "missed";
          const isCurrentConstraintManual = currentConstraint.type === "manual";
          const isCurrentConstraintDirect = currentConstraint.type === "direct";
          if (isCurrentConstraintClimb) {
            if (currentConstraintIndex - 1 > targetConstraintIndex) {
              currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
              const maxAltitude2 = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
              const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude2, false);
              if (terminatedIndex < currentConstraintIndex) {
                targetConstraintIndex = terminatedIndex - 1;
                currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                break;
              }
            } else {
              currentTargetConstraint.fpa = this.flightPathAngle;
            }
            targetConstraintIndex = currentConstraintIndex;
            currentTargetConstraint = void 0;
            break;
          }
          const minAltitude = currentConstraint.minAltitude;
          const maxAltitude = currentConstraint.maxAltitude;
          if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
            const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
            const newTargetConstraintIndex = currentConstraintIndex - 1;
            SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
            targetConstraintIndex = newTargetConstraintIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            currentTargetConstraint.targetAltitude = flatSegmentAltitude;
            currentTargetConstraint.isTarget = true;
            break;
          } else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
            pathSegmentIsFlat = true;
            currentTargetConstraint.fpa = 0;
            if (isCurrentConstraintFirstDescent) {
              const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
              SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
              targetConstraintIndex = currentConstraintIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
              currentTargetConstraint.targetAltitude = flatSegmentAltitude;
              currentTargetConstraint.isTarget = true;
              break;
            }
            continue;
          }
          const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
          const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
          const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
          if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
            if (isFpaOutOfBounds) {
              if (minFpa > currentPathSegmentMaxFpa) {
                currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
              } else {
                currentTargetConstraint.fpa = currentPathSegmentMinFpa;
              }
            } else {
              currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
              currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
              currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            }
            const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
            targetConstraintIndex = terminatedIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
            break;
          } else if (isCurrentConstraintFirstDescent) {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
            if (terminatedIndex < currentConstraintIndex + 1) {
              targetConstraintIndex = terminatedIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
              break;
            } else {
              return true;
            }
          } else {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentPathSegmentDistance += currentConstraint.distance;
          }
        }
      }
      return true;
    }
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
      const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
      if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== void 0) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
        const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
        const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
        newTargetConstraint.isTarget = true;
        newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
      }
      return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.constraints.length > 0) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
          const constraint = verticalPlan.constraints[i];
          if (constraint.type !== "climb") {
            return constraint.targetAltitude;
          }
        }
      }
      return void 0;
    }
    // Start of buildVerticalFlightPlan helper methods
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    static getConstraintAltitudes(leg, out) {
      if (leg.verticalData !== void 0) {
        switch (leg.verticalData.altDesc) {
          case AltitudeRestrictionType.At:
            out[0] = leg.verticalData.altitude1;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.AtOrAbove:
            out[0] = leg.verticalData.altitude1;
            out[1] = Number.POSITIVE_INFINITY;
            return out;
          case AltitudeRestrictionType.AtOrBelow:
            out[0] = Number.NEGATIVE_INFINITY;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.Between:
            out[0] = leg.verticalData.altitude2;
            out[1] = leg.verticalData.altitude1;
            return out;
        }
      }
      return void 0;
    }
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    static forceAtConstraint(constraint) {
      if (constraint.minAltitude !== constraint.maxAltitude) {
        if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          constraint.maxAltitude = constraint.minAltitude;
        } else {
          constraint.minAltitude = constraint.maxAltitude;
        }
      }
    }
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    static getDirectToTargetLegIndex(lateralPlan) {
      const directToData = lateralPlan.directToData;
      if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
        const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
        if (segment !== null) {
          return segment.offset + directToData.segmentLegIndex;
        }
      }
      return void 0;
    }
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
      if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
        const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
        if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
          const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
          directVerticalLeg.isDirectToTarget = true;
          const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
          if (segment !== void 0) {
            const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type !== "climb" && constraint.type !== "missed" && constraint.index >= globalLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                return;
              }
            }
            verticalPlan.firstDescentConstraintLegIndex = void 0;
          }
        }
      }
    }
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
      if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
        return true;
      }
      return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
      const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
      const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
      if (currentMinWithPrecision > priorMaxWithPrecision) {
        return true;
      }
      return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
      if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
        const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
        const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
        if (minFpaTempValue > maxFpa) {
          return true;
        }
      }
      return false;
    }
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg) {
      switch (lateralLeg.leg.type) {
        case LegType.VM:
        case LegType.FM:
        case LegType.Discontinuity:
        case LegType.ThruDiscontinuity:
          return false;
        default:
          return true;
      }
    }
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint() {
      return false;
    }
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
      return isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10) || requiredFpa > maxFpa;
    }
    // Start of computeFlightPathAngles helper methods
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
      for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.maxAltitude < Infinity) {
          return constraint.maxAltitude;
        }
        if (i === firstDescentConstraintIndex && constraint.type === "direct") {
          if (constraint.minAltitude > -Infinity) {
            return constraint.minAltitude;
          }
        }
      }
      return Infinity;
    }
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
      const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
      let distance = currentTargetConstraint.distance;
      for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
        const smoothedConstraint = verticalPlan.constraints[i];
        const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
        if (targetAltitude < maxAltitude) {
          smoothedConstraint.fpa = currentTargetConstraint.fpa;
          smoothedConstraint.targetAltitude = targetAltitude;
          distance += smoothedConstraint.distance;
        } else {
          out[0] = i;
          out[1] = distance;
          return out;
        }
      }
      out[0] = void 0;
      out[1] = distance;
      return out;
    }
  };
  SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
  SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
  SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
  SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;
  var LNavDataVars;
  (function(LNavDataVars2) {
    LNavDataVars2["DTKTrue"] = "L:WT_LNavData_DTK_True";
    LNavDataVars2["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    LNavDataVars2["XTK"] = "L:WT_LNavData_XTK";
    LNavDataVars2["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    LNavDataVars2["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    LNavDataVars2["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    LNavDataVars2["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    LNavDataVars2["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
  })(LNavDataVars || (LNavDataVars = {}));
  var LNavDataSimVarPublisher = class extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
      super(LNavDataSimVarPublisher.simvars, bus);
    }
  };
  LNavDataSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnavdata_dtk_true", { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ["lnavdata_dtk_mag", { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_xtk", { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ["lnavdata_cdi_scale", { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ["lnavdata_waypoint_bearing_true", { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_bearing_mag", { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_distance", { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ["lnavdata_destination_distance", { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
  ]);
  var VNavDataEventPublisher = class extends BasePublisher {
    /**
     * Create a publisher for VNAV-related data.
     * @param bus The EventBus to publish to.
     */
    constructor(bus) {
      super(bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
  };
  var VNavControlEventPublisher = class extends BasePublisher {
    /**
     * Create a publisher for VNAV-related data.
     * @param bus The EventBus to publish to.
     */
    constructor(bus) {
      super(bus);
    }
    /**
     * Publish a VNav Control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
  };
  var AltitudeSelectManager = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param settingsManager The user settings manager controlling metric altitude preselector setting.
     * @param options Configuration options for this manager.
     * @param stops Additional altitude stops, in feet, to respect when the selected altitude is incremented or
     * decremented.
     */
    constructor(bus, settingsManager, options, stops) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.stops = new SortedArray((a, b) => a - b);
      this.isEnabled = true;
      this.isInitialized = false;
      this.isPaused = false;
      this.isLocked = false;
      this.lockDebounceTimer = new DebounceTimer();
      this.consecIncrSmallCount = 0;
      this.lastIncrSmallDirection = 1;
      this.lastIncrSmallInputTime = 0;
      this.selectedAltitudeChangedHandler = () => {
        setTimeout(() => {
          this.isLocked = false;
          this.lockDebounceTimer.clear();
        });
      };
      this.altitudeHoldSlotIndex = (_a = options.altitudeHoldSlotIndex) !== null && _a !== void 0 ? _a : 1;
      this.altitudeHoldSlotSimVar = `AUTOPILOT ALTITUDE LOCK VAR:${this.altitudeHoldSlotIndex}`;
      this.minValue = Math.round(options.minValue.asUnit(UnitType.FOOT));
      this.maxValue = Math.round(options.maxValue.asUnit(UnitType.FOOT));
      this.minValueMetric = Math.round(((_b = options.minValueMetric) !== null && _b !== void 0 ? _b : options.minValue).asUnit(UnitType.METER));
      this.maxValueMetric = Math.round(((_c = options.maxValueMetric) !== null && _c !== void 0 ? _c : options.maxValue).asUnit(UnitType.METER));
      this.inputIncrLargeThreshold = options.inputIncrLargeThreshold;
      this.incrSmall = Math.round(options.incrSmall.asUnit(UnitType.FOOT));
      this.incrLarge = Math.round(options.incrLarge.asUnit(UnitType.FOOT));
      this.incrSmallMetric = Math.round(((_d = options.incrSmallMetric) !== null && _d !== void 0 ? _d : options.incrSmall).asUnit(UnitType.METER));
      this.incrLargeMetric = Math.round(((_e = options.incrLargeMetric) !== null && _e !== void 0 ? _e : options.incrLarge).asUnit(UnitType.METER));
      this.lockAltToStepOnIncr = (_f = options.lockAltToStepOnIncr) !== null && _f !== void 0 ? _f : true;
      this.lockAltToStepOnIncrMetric = (_g = options.lockAltToStepOnIncrMetric) !== null && _g !== void 0 ? _g : this.lockAltToStepOnIncr;
      this.accelInputCountThreshold = (_h = options.accelInputCountThreshold) !== null && _h !== void 0 ? _h : 0;
      this.accelResetOnDirectionChange = (_j = options.accelResetOnDirectionChange) !== null && _j !== void 0 ? _j : false;
      this.initToIndicatedAlt = (_k = options.initToIndicatedAlt) !== null && _k !== void 0 ? _k : false;
      this.transformSetToIncDec = (_l = options.transformSetToIncDec) !== null && _l !== void 0 ? _l : true;
      this.altimeterMetricSetting = options.supportMetric ? settingsManager.getSetting("altMetric") : void 0;
      if (stops !== void 0) {
        if ("isSubscribableSet" in stops) {
          stops.sub((set, type, key) => {
            if (type === SubscribableSetEventType.Added) {
              this.stops.insert(key);
            } else {
              this.stops.remove(key);
            }
          }, true);
        } else {
          this.stops.insertAll(new Set(stops));
        }
      }
      this.isInitialized = !((_m = options.initOnInput) !== null && _m !== void 0 ? _m : false);
      KeyEventManager.getManager(bus).then((manager) => {
        this.keyEventManager = manager;
        manager.interceptKey("AP_ALT_VAR_SET_ENGLISH", false);
        manager.interceptKey("AP_ALT_VAR_SET_METRIC", false);
        manager.interceptKey("AP_ALT_VAR_INC", false);
        manager.interceptKey("AP_ALT_VAR_DEC", false);
        const sub = this.bus.getSubscriber();
        if (this.transformSetToIncDec) {
          sub.on(`ap_altitude_selected_${this.altitudeHoldSlotIndex}`).whenChanged().handle(this.selectedAltitudeChangedHandler);
        }
        sub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        this.publisher.pub("alt_select_is_initialized", !this.isEnabled || this.isInitialized, true);
      });
    }
    /**
     * Sets whether this manager is enabled. When this manager is disabled, all key events to change the selected
     * altitude setting are processed "as-is".
     * @param isEnabled Whether this manager is enabled.
     */
    setEnabled(isEnabled) {
      this.isEnabled = isEnabled;
      this.publisher.pub("alt_select_is_initialized", !isEnabled || this.isInitialized, true);
    }
    /**
     * Resumes this manager. When resumed, this manager will respond to key events that manipulate selected altitude.
     */
    resume() {
      this.isPaused = false;
    }
    /**
     * Pauses this manager. When paused, this manager will not respond to key events that manipulate selected altitude.
     * If this manager is disabled, it will still pass through key events while paused.
     */
    pause() {
      this.isPaused = true;
    }
    /**
     * Resets the selected altitude to a specific value and optionally sets the initialized state of the selected
     * altitude to uninitialized.
     * @param altitude The altitude, in feet, to which to reset the selected altitude.
     * @param resetInitialized Whether to reset the initialized state of the selected altitude to uninitialized. Defaults
     * to `false`.
     */
    reset(altitude, resetInitialized = false) {
      if (!this.isEnabled) {
        return;
      }
      SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, altitude);
      if (resetInitialized) {
        this.isInitialized = false;
        this.publisher.pub("alt_select_is_initialized", false, true);
      }
    }
    /**
     * Responds to key intercepted events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.value0 The value of the intercepted key event.
     * @param data.value1 The index of the intercepted key event.
     */
    onKeyIntercepted({ key, value0: value, value1: index }) {
      switch (key) {
        case "AP_ALT_VAR_INC":
        case "AP_ALT_VAR_DEC":
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          break;
        default:
          return;
      }
      index !== null && index !== void 0 ? index : index = 1;
      index = Math.max(1, index);
      if (!this.isEnabled || index !== this.altitudeHoldSlotIndex) {
        this.passThroughKeyEvent(key, index, value);
        return;
      }
      if (!this.isPaused && !this.isLocked) {
        this.handleKeyEvent(key, value);
      }
    }
    /**
     * Handles a key event.
     * @param key The key.
     * @param value The value of the key event.
     */
    handleKeyEvent(key, value) {
      const currentValue = SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet);
      let startValue = currentValue;
      if (!this.isInitialized) {
        if (this.initToIndicatedAlt) {
          startValue = SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet);
        } else {
          startValue = 0;
        }
        this.publisher.pub("alt_select_is_initialized", true, true);
        this.isInitialized = true;
      }
      let direction = 0;
      let useLargeIncrement = false;
      let setAltitude = void 0;
      switch (key) {
        case "AP_ALT_VAR_INC":
          direction = 1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_DEC":
          direction = -1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC": {
          if (value !== void 0 && value !== currentValue) {
            if (this.transformSetToIncDec) {
              const delta = value - currentValue;
              direction = delta < 0 ? -1 : 1;
              useLargeIncrement = Math.abs(delta) > this.inputIncrLargeThreshold;
            } else {
              setAltitude = value;
            }
          }
          break;
        }
      }
      if (setAltitude !== void 0) {
        this.setSelectedAltitude(setAltitude);
        return;
      }
      if (this.accelInputCountThreshold > 0) {
        const time = Date.now();
        let isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (useLargeIncrement || direction === 0 || this.consecIncrSmallCount > 0 && time - this.lastIncrSmallInputTime > AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD || (isAccelActive ? this.accelResetOnDirectionChange : this.consecIncrSmallCount > 0) && this.lastIncrSmallDirection !== direction) {
          this.consecIncrSmallCount = 0;
        }
        if (!useLargeIncrement) {
          this.consecIncrSmallCount++;
          this.lastIncrSmallDirection = direction;
          this.lastIncrSmallInputTime = time;
        }
        isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (isAccelActive) {
          useLargeIncrement = true;
        }
      }
      if (direction !== 0) {
        this.changeSelectedAltitude(startValue, direction, useLargeIncrement);
      }
    }
    /**
     * Sets the selected altitude to a specific value.
     * @param altitudeFeet The altitude to set, in feet.
     */
    setSelectedAltitude(altitudeFeet) {
      var _a, _b;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min, max, unit;
      if (isMetric) {
        min = this.minValueMetric;
        max = this.maxValueMetric;
        unit = UnitType.METER;
      } else {
        min = this.minValue;
        max = this.maxValue;
        unit = UnitType.FOOT;
      }
      const valueToSet = UnitType.FOOT.convertFrom(MathUtils.clamp(UnitType.FOOT.convertTo(altitudeFeet, unit), min, max), unit);
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
      }
    }
    /**
     * Increments or decrements the selected altitude setting. The amount the setting is changed depends on whether the
     * PFD altimeter metric mode is enabled. The value of the setting after the change is guaranteed to be a round number
     * in the appropriate units (nearest 100 feet or 50 meters).
     * @param startValue The value from which to change, in feet.
     * @param direction The direction of the change: `1` for increment, `-1` for decrement.
     * @param useLargeIncrement Whether to change the altitude by the large increment (1000 feet/500 meters) instead of
     * the small increment (100 feet/50 meters). False by default.
     */
    changeSelectedAltitude(startValue, direction, useLargeIncrement = false) {
      var _a, _b;
      const roundFunc = direction === 1 ? Math.floor : Math.ceil;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min, max, incrSmall, incrLarge, units, lockAlt;
      if (isMetric) {
        min = this.minValueMetric;
        max = this.maxValueMetric;
        incrSmall = this.incrSmallMetric;
        incrLarge = this.incrLargeMetric;
        units = UnitType.METER;
        lockAlt = this.lockAltToStepOnIncrMetric;
      } else {
        min = this.minValue;
        max = this.maxValue;
        incrSmall = this.incrSmall;
        incrLarge = this.incrLarge;
        units = UnitType.FOOT;
        lockAlt = this.lockAltToStepOnIncr;
      }
      const startValueConverted = Math.round(UnitType.FOOT.convertTo(startValue, units));
      useLargeIncrement && (useLargeIncrement = !lockAlt || startValueConverted % incrSmall === 0);
      let valueToSet = UnitType.FOOT.convertFrom(Utils.Clamp((lockAlt ? roundFunc(startValueConverted / incrSmall) * incrSmall : startValueConverted) + direction * (useLargeIncrement ? incrLarge : incrSmall), min, max), units);
      if (this.stops.length > 0) {
        let nextStopIndex = this.stops.matchIndex(startValue);
        if (direction === 1) {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 1;
          } else {
            nextStopIndex++;
          }
        } else {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 2;
          } else {
            nextStopIndex--;
          }
        }
        const nextStop = this.stops.peek(nextStopIndex);
        if (nextStop !== void 0 && Math.abs(valueToSet - startValue) > Math.abs(nextStop - startValue)) {
          valueToSet = nextStop;
        }
      }
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
        if (this.transformSetToIncDec) {
          this.isLocked = true;
          this.lockDebounceTimer.schedule(() => {
            this.isLocked = false;
          }, 250);
        }
      }
    }
    /**
     * Processes a key event "as-is".
     * @param key The key that was pressed.
     * @param index The index of the key event.
     * @param value The value of the key event.
     */
    passThroughKeyEvent(key, index, value) {
      index = Math.max(1, index);
      const currentValue = SimVar.GetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet);
      let valueToSet = currentValue;
      switch (key) {
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          if (value !== void 0) {
            valueToSet = value;
          }
          break;
        case "AP_ALT_VAR_INC":
          valueToSet += value === 0 || value === void 0 ? 100 : value;
          break;
        case "AP_ALT_VAR_DEC":
          valueToSet -= value === 0 || value === void 0 ? 100 : value;
          break;
      }
      SimVar.SetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet, valueToSet);
    }
  };
  AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD = 300;
  var APModeType;
  (function(APModeType2) {
    APModeType2[APModeType2["LATERAL"] = 0] = "LATERAL";
    APModeType2[APModeType2["VERTICAL"] = 1] = "VERTICAL";
    APModeType2[APModeType2["APPROACH"] = 2] = "APPROACH";
  })(APModeType || (APModeType = {}));
  var APStateManager = class {
    /**
     * Creates an instance of the APStateManager.
     * @param bus An instance of the event bus.
     * @param apConfig This autopilot's configuration.
     */
    constructor(bus, apConfig) {
      this.bus = bus;
      this.apConfig = apConfig;
      this.apListenerRegistered = false;
      this.managedModeSet = false;
      this.stateManagerInitialized = Subject.create(false);
      this.lateralPressed = new SubEvent();
      this.verticalPressed = new SubEvent();
      this.approachPressed = new SubEvent();
      this.vnavPressed = new SubEvent();
      this.apMasterOn = Subject.create(false);
      this.isFlightDirectorOn = Subject.create(false);
      this.isFlightDirectorCoPilotOn = Subject.create(false);
      KeyEventManager.getManager(bus).then((manager) => {
        this.keyEventManager = manager;
        this.setupKeyIntercepts(manager);
        this.bus.getSubscriber().on("key_intercept").handle(this.handleKeyIntercepted.bind(this));
      });
      this.apListener = RegisterViewListener("JS_LISTENER_AUTOPILOT", () => {
        this.onAPListenerRegistered();
        this.apListenerRegistered = true;
      });
    }
    /**
     * A callback which is called when the autopilot listener has been registered.
     */
    onAPListenerRegistered() {
      const ap = this.bus.getSubscriber();
      ap.on("ap_lock_set").handle((lock) => {
        if (lock === APLockType.VNav) {
          this.vnavPressed.notify(this, true);
        }
      });
      ap.on("ap_lock_release").handle((lock) => {
        if (lock === APLockType.VNav) {
          this.vnavPressed.notify(this, false);
        }
      });
      ap.on("ap_master_disengage").handle(() => {
        this.apMasterOn.set(false);
      });
      ap.on("ap_master_engage").handle(() => {
        this.apMasterOn.set(true);
      });
      ap.on("flight_director_is_active_1").whenChanged().handle((fd) => {
        this.isFlightDirectorOn.set(fd);
        this.setFlightDirector(fd);
      });
      ap.on("flight_director_is_active_2").whenChanged().handle((fd) => {
        this.isFlightDirectorCoPilotOn.set(fd);
        this.setFlightDirector(fd);
      });
    }
    /**
     * Checks whether the AP State Manager has completed listerner steps,
     * and if so, finishes initializing and then notifies Autopilot of the same.
     * @param force forces the initialize
     */
    initialize(force = false) {
      this.onBeforeInitialize();
      if (force || this.keyEventManager && this.apListenerRegistered) {
        this.setManagedMode(true).then(() => {
          var _a;
          SimVar.SetSimVarValue("AUTOPILOT ALTITUDE LOCK VAR", SimVarValueType.Feet, (_a = this.apConfig.altitudeHoldDefaultAltitude) !== null && _a !== void 0 ? _a : 0);
          this.setFlightDirector(false);
          this.stateManagerInitialized.set(true);
        });
      }
    }
    /**
     * Sets the Flight Director State
     * @param on is wheter to set the FD On.
     */
    setFlightDirector(on) {
      setTimeout(() => {
        if (on !== this.isFlightDirectorOn.get()) {
          SimVar.SetSimVarValue("K:TOGGLE_FLIGHT_DIRECTOR", "number", 1);
          this.isFlightDirectorOn.set(on);
        }
        if (on !== this.isFlightDirectorCoPilotOn.get()) {
          SimVar.SetSimVarValue("K:TOGGLE_FLIGHT_DIRECTOR", "number", 2);
          this.isFlightDirectorCoPilotOn.set(on);
        }
      }, 0);
    }
    /**
     * Sets Managed Mode.
     * @param set is wheter to set or unset managed mode.
     */
    async setManagedMode(set) {
      return new Promise((resolve) => {
        setTimeout(() => {
          if (set) {
            Coherent.call("apSetAutopilotMode", MSFSAPStates.AvionicsManaged, 1).then(() => resolve());
          } else {
            Coherent.call("apSetAutopilotMode", MSFSAPStates.AvionicsManaged, 0).then(() => resolve());
          }
          this.managedModeSet = set;
        }, 1e3);
      });
    }
    /**
     * Toggles VNAV L Var value.
     */
    toggleVnav() {
      const vnavXmlVarValue = SimVar.GetSimVarValue("L:XMLVAR_VNAVButtonValue", "Bool");
      SimVar.SetSimVarValue("L:XMLVAR_VNAVButtonValue", "Bool", vnavXmlVarValue ? 0 : 1);
    }
    /**
     * Sends AP Mode Events from the Intercept to the Autopilot.
     * @param type is the AP Mode Type for this event
     * @param mode is the mode to set/unset.
     * @param set is whether to actively set or unset this mode.
     */
    sendApModeEvent(type, mode, set) {
      switch (type) {
        case APModeType.LATERAL:
          if (mode !== void 0) {
            this.lateralPressed.notify(this, { mode, set });
          }
          break;
        case APModeType.VERTICAL:
          if (mode !== void 0) {
            this.verticalPressed.notify(this, { mode, set });
          }
          break;
        case APModeType.APPROACH:
          this.approachPressed.notify(this, set);
          break;
      }
    }
    /**
     * Method to override with steps to run before initialze method is run.
     */
    onBeforeInitialize() {
    }
  };
  var AutothrottleTargetMode;
  (function(AutothrottleTargetMode2) {
    AutothrottleTargetMode2["None"] = "None";
    AutothrottleTargetMode2["Speed"] = "Speed";
    AutothrottleTargetMode2["Power"] = "Power";
    AutothrottleTargetMode2["ThrottlePos"] = "ThrottlePos";
  })(AutothrottleTargetMode || (AutothrottleTargetMode = {}));
  var AbstractAutothrottle = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param airspeedIndex The index of the sim airspeed indicator from which this autothrottle should source airspeed
     * data.
     * @param throttleInfos Information on the throttles controlled by this autothrottle. Each entry in the array should
     * describe a single unique throttle. Order does not matter.
     * @param options Options with which to initialize this autothrottle.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for virtual throttle
     * levers. If not defined, position changes for virtual throttle levers will be requested using key events
     * (specifically the `THROTTLE[N]_SET` event).
     */
    constructor(bus, airspeedIndex, throttleInfos, options, throttleLeverManager) {
      var _a, _b, _c, _d, _e, _f;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.isOverspeedProtActive = Subject.create(false);
      this.isUnderspeedProtActive = Subject.create(false);
      this.isOverpowerProtActive = Subject.create(false);
      this.targetMode = Subject.create(AutothrottleTargetMode.None);
      this.selectedSpeedIsMach = Subject.create(false);
      this.selectedIas = Subject.create(0);
      this.selectedMach = Subject.create(0);
      this.selectedPower = Subject.create(0);
      this.selectedThrottlePos = Subject.create(0);
      this.maxIas = Subject.create(0);
      this.minIas = Subject.create(0);
      this.maxMach = Subject.create(0);
      this.minMach = Subject.create(0);
      this.maxPower = Subject.create(0);
      this.maxThrottlePos = Subject.create(1);
      this.minThrottlePos = Subject.create(0);
      this.lastSmoothedIas = void 0;
      this.realTime = ConsumerSubject.create(this.bus.getSubscriber().on("realTime"), 0);
      this.updateTimer = null;
      this.lastUpdateTime = 0;
      this.updateHandler = this.update.bind(this);
      this.speedCommand = {
        selectedSpeedPowerTarget: void 0,
        overspeedProtPowerTarget: void 0,
        underspeedProtPowerTarget: void 0,
        isOverspeed: false,
        isUnderspeed: false
      };
      this.powerCommand = {
        speed: void 0,
        targetPos: void 0,
        isOverspeedProtEngaged: false,
        isUnderspeedProtEngaged: false,
        isOverpowerProtEngaged: false
      };
      this.isAlive = true;
      this.airspeedIndex = SubscribableUtils.toSubscribable(airspeedIndex, true);
      this.airspeedIndex.sub((index) => {
        this.airspeedSimVar = `AIRSPEED INDICATED:${index}`;
      }, true);
      this.powerLookahead = SubscribableUtils.toSubscribable(options.powerLookahead, true);
      this.throttles = throttleInfos.map((info) => {
        return this.createThrottle(bus, info, options.servoSpeed, options.powerSmoothingConstant, this.powerLookahead, throttleLeverManager);
      });
      this.machToKiasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.iasLookahead = SubscribableUtils.toSubscribable(options.speedLookahead, true);
      this.iasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lookaheadIasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lastIasLookahead = this.iasLookahead.get();
      this.selectedSpeedPid = AbstractAutothrottle.createPidFromParams(options.speedTargetPid);
      this.overspeedPid = AbstractAutothrottle.createPidFromParams((_a = options.overspeedPid) !== null && _a !== void 0 ? _a : options.speedTargetPid);
      this.underspeedPid = AbstractAutothrottle.createPidFromParams((_b = options.underspeedPid) !== null && _b !== void 0 ? _b : options.speedTargetPid);
      this.selectedPowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid)
      };
      this.overpowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams((_c = options.overpowerPid) !== null && _c !== void 0 ? _c : options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams((_d = options.overpowerPid) !== null && _d !== void 0 ? _d : options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams((_e = options.overpowerPid) !== null && _e !== void 0 ? _e : options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams((_f = options.overpowerPid) !== null && _f !== void 0 ? _f : options.powerTargetPid)
      };
      this.selectedSpeedPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.overspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.underspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.hysteresis = Math.max(0, options.hysteresis);
      this.hysteresisRecord = {
        [1]: 0,
        [2]: 0,
        [3]: 0,
        [4]: 0
      };
      this.publisher.pub("at_master_is_active", false, true, true);
      this.isOverspeedProtActive.sub((val) => this.publisher.pub("at_overspeed_prot_is_active", val, true, true), true);
      this.isUnderspeedProtActive.sub((val) => this.publisher.pub("at_underspeed_prot_is_active", val, true, true), true);
      this.isOverpowerProtActive.sub((val) => this.publisher.pub("at_overpower_prot_is_active", val, true, true), true);
      this.targetMode.sub((val) => this.publisher.pub("at_target_mode", val, true, true), true);
      this.selectedIas.sub((val) => this.publisher.pub("at_selected_ias", val, true, true), true);
      this.selectedMach.sub((val) => this.publisher.pub("at_selected_mach", val, true, true), true);
      this.selectedSpeedIsMach.sub((val) => this.publisher.pub("at_selected_speed_is_mach", val, true, true), true);
      this.selectedPower.sub((val) => this.publisher.pub("at_selected_power", val, true, true), true);
      this.selectedThrottlePos.sub((val) => this.publisher.pub("at_selected_throttle_pos", val, true, true), true);
      this.maxIas.sub((val) => this.publisher.pub("at_max_ias", val, true, true), true);
      this.maxMach.sub((val) => this.publisher.pub("at_max_mach", val, true, true), true);
      this.minIas.sub((val) => this.publisher.pub("at_min_ias", val, true, true), true);
      this.minMach.sub((val) => this.publisher.pub("at_min_mach", val, true, true), true);
      this.maxPower.sub((val) => this.publisher.pub("at_max_power", val, true, true), true);
      this.maxThrottlePos.sub((val) => this.publisher.pub("at_max_throttle_pos", val, true, true), true);
      this.minThrottlePos.sub((val) => this.publisher.pub("at_min_throttle_pos", val, true, true), true);
    }
    /**
     * Sets whether this autothrottle's overspeed protection is active.
     * @param val Whether overspeed protection is active.
     */
    setOverspeedProtActive(val) {
      this.isOverspeedProtActive.set(val);
    }
    /**
     * Sets whether this autothrottle's underspeed protection is active.
     * @param val Whether underspeed protection is active.
     */
    setUnderspeedProtActive(val) {
      this.isUnderspeedProtActive.set(val);
    }
    /**
     * Sets whether this autothrottle's overpower protection is active.
     * @param val Whether overpower protection is active.
     */
    setOverpowerProtActive(val) {
      this.isOverpowerProtActive.set(val);
    }
    /**
     * Sets this autothrottle's target mode.
     * @param mode A target mode.
     */
    setTargetMode(mode) {
      this.targetMode.set(mode);
    }
    /**
     * Sets whether this autothrottle's selected speed target is a mach number.
     * @param val Whether the selected speed target is a mach number.
     */
    setSelectedSpeedIsMach(val) {
      this.selectedSpeedIsMach.set(val);
    }
    /**
     * Sets this autothrottle's selected indicated airspeed target, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setSelectedIas(ias) {
      this.selectedIas.set(ias);
    }
    /**
     * Sets this autothrottle's selected mach number target.
     * @param mach A mach number.
     */
    setSelectedMach(mach) {
      this.selectedMach.set(mach);
    }
    /**
     * Sets this autothrottle's selected engine power target.
     * @param power An engine power value.
     */
    setSelectedPower(power) {
      this.selectedPower.set(power);
    }
    /**
     * Sets this autothrottle's selected normalized throttle lever position target.
     * @param pos A normalized throttle lever position.
     */
    setSelectedThrottlePos(pos) {
      this.selectedThrottlePos.set(pos);
    }
    /**
     * Sets this autothrottle's maximum allowed indicated airspeed, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setMaxIas(ias) {
      this.maxIas.set(ias);
    }
    /**
     * Sets this autothrottle's minimum allowed indicated airspeed, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setMinIas(ias) {
      this.minIas.set(ias);
    }
    /**
     * Sets this autothrottle's maximum allowed mach number.
     * @param mach A mach number.
     */
    setMaxMach(mach) {
      this.maxMach.set(mach);
    }
    /**
     * Sets this autothrottle's minimum allowed mach number.
     * @param mach A mach number.
     */
    setMinMach(mach) {
      this.minMach.set(mach);
    }
    /**
     * Sets this autothrottle's maximum allowed engine power.
     * @param power An engine power value.
     */
    setMaxPower(power) {
      this.maxPower.set(power);
    }
    /**
     * Sets this autothrottle's maximum allowed normalized throttle lever position.
     * @param pos A normalized throttle lever position.
     */
    setMaxThrottlePos(pos) {
      this.maxThrottlePos.set(pos);
    }
    /**
     * Sets this autothrottle's minimum allowed normalized throttle lever position.
     * @param pos A normalized throttle lever position.
     */
    setMinThrottlePos(pos) {
      this.minThrottlePos.set(pos);
    }
    /**
     * Sets whether one of this autothrottle's throttle servos are active.
     * @param index The index of the throttle servo to activate/deactivate.
     * @param active Whether the servo should be activated.
     */
    setServoActive(index, active) {
      const throttle = this.throttles.find((query) => query.index === index);
      if (throttle !== void 0) {
        throttle.isServoActive = active;
      }
    }
    /**
     * Turns this autothrottle on with a specified update frequency. If this autothrottle is already running, then it
     * will be turned off before turning on again with the specified frequency.
     * @param frequency The frequency, in hertz, at which this autothrottle will update.
     * @throws Error if this autothrottle has been destroyed.
     */
    start(frequency) {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot start a dead autothrottle");
      }
      this.stop();
      this.publisher.pub("at_master_is_active", true, true, true);
      this.updateTimer = setInterval(this.updateHandler, 1e3 / frequency);
    }
    /**
     * Turns this autothrottle off.
     * @throws Error if this autothrottle has been destroyed.
     */
    stop() {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot stop a dead autothrottle");
      }
      if (this.updateTimer === null) {
        return;
      }
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      this.machToKiasSmoother.reset();
      this.iasSmoother.reset();
      this.lookaheadIasSmoother.reset();
      this.lastSmoothedIas = void 0;
      this.selectedSpeedPid.reset();
      this.overspeedPid.reset();
      this.underspeedPid.reset();
      this.selectedSpeedPowerTargetSmoother.reset();
      this.overspeedProtPowerTargetSmoother.reset();
      this.underspeedProtPowerTargetSmoother.reset();
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].resetPowerSmoothing();
      }
      for (const index of AbstractAutothrottle.ALL_THROTTLE_INDEXES) {
        this.selectedPowerPids[index].reset();
        this.overpowerPids[index].reset();
        this.hysteresisRecord[index] = 0;
      }
      this.publisher.pub("at_master_is_active", false, true, true);
    }
    /**
     * Updates this autothrottle.
     */
    update() {
      const realTime = Date.now();
      const dt = (realTime - this.lastUpdateTime) / 1e3;
      if (dt <= 0) {
        return;
      }
      this.lastUpdateTime = realTime;
      if (realTime - this.realTime.get() >= 1e3) {
        return;
      }
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].update(dt);
      }
      const targetMode = this.targetMode.get();
      const speedCommand = this.calculateSpeedTargetPower(dt, this.speedCommand);
      const isOverpowerProtActive = this.isOverpowerProtActive.get();
      const isPowerTargetActive = targetMode === AutothrottleTargetMode.Power;
      const isThrottlePosTargetActive = targetMode === AutothrottleTargetMode.ThrottlePos;
      const minThrottlePos = this.minThrottlePos.get();
      const maxThrottlePos = this.maxThrottlePos.get();
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          const powerCommand = this.calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, this.powerCommand);
          let targetPos = powerCommand.targetPos;
          let speed = powerCommand.speed;
          const isThrottlePosOob = throttle.normPosition < minThrottlePos || throttle.normPosition > maxThrottlePos;
          const isTargetPosOob = targetPos !== void 0 && (targetPos < minThrottlePos || targetPos > maxThrottlePos);
          if (isTargetPosOob) {
            targetPos = MathUtils.clamp(targetPos, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          } else if (isThrottlePosOob && targetPos === void 0) {
            targetPos = MathUtils.clamp(throttle.normPosition, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          }
          if (targetPos !== void 0 && speed !== void 0) {
            const lastCommandedSpeed = this.hysteresisRecord[throttle.index];
            if (isThrottlePosOob || lastCommandedSpeed === 0 || Math.sign(lastCommandedSpeed) === Math.sign(speed) || Math.abs(speed) > this.hysteresis) {
              throttle.drive(targetPos, dt);
              this.hysteresisRecord[throttle.index] = speed;
            }
          } else {
            this.hysteresisRecord[throttle.index] = 0;
          }
        } else {
          this.selectedPowerPids[throttle.index].reset();
          this.overpowerPids[throttle.index].reset();
          this.hysteresisRecord[throttle.index] = 0;
        }
      }
    }
    /**
     * Calculates the engine power for all throttles commanded by this autothrottle's speed controller. The speed
     * controller incorporates the speed target and over-/under-speed protection if active.
     * @param dt The elapsed time since the last update.
     * @param out The object to which to write the results.
     * @returns The engine power for all throttles commanded by this autothrottle's speed controller.
     */
    calculateSpeedTargetPower(dt, out) {
      out.selectedSpeedPowerTarget = void 0;
      out.overspeedProtPowerTarget = void 0;
      out.underspeedProtPowerTarget = void 0;
      out.isOverspeed = false;
      out.isUnderspeed = false;
      const ias = SimVar.GetSimVarValue(this.airspeedSimVar, SimVarValueType.Knots);
      const mach = SimVar.GetSimVarValue("AIRSPEED MACH", SimVarValueType.Number);
      const currentMachToKias = ias > 1 && mach > 0 ? ias / mach : Simplane.getMachToKias(1);
      const machToKias = this.machToKiasSmoother.next(isFinite(currentMachToKias) ? currentMachToKias : 1, dt);
      const lookahead = Math.max(0, this.iasLookahead.get());
      const smoothedIas = this.iasSmoother.next(ias, dt);
      if (lookahead !== this.lastIasLookahead) {
        this.lookaheadIasSmoother.reset();
        this.lastIasLookahead = lookahead;
      }
      let effectiveIas;
      if (lookahead > 0 && this.lastSmoothedIas !== void 0) {
        const delta = smoothedIas - this.lastSmoothedIas;
        const last = this.lookaheadIasSmoother.last();
        effectiveIas = last === null || isFinite(last) ? this.lookaheadIasSmoother.next(ias + delta * lookahead / dt, dt) : this.lookaheadIasSmoother.reset(ias + delta * lookahead / dt);
      } else {
        effectiveIas = smoothedIas;
      }
      this.lastSmoothedIas = smoothedIas;
      const isTargetSpeed = this.targetMode.get() === AutothrottleTargetMode.Speed;
      const isOverspeedProtActive = this.isOverspeedProtActive.get();
      const isUnderspeedProtActive = this.isUnderspeedProtActive.get();
      let overspeedProtDelta;
      let underspeedProtDelta;
      let selectedSpeedDelta;
      if (isOverspeedProtActive) {
        const maxIas = Math.min(this.maxMach.get() * machToKias, this.maxIas.get());
        overspeedProtDelta = this.overspeedPid.getOutput(dt, maxIas - effectiveIas);
        out.isOverspeed = effectiveIas > maxIas;
      } else {
        this.overspeedPid.reset();
      }
      if (isUnderspeedProtActive) {
        const minIas = Math.max(this.minMach.get() * machToKias, this.minIas.get());
        underspeedProtDelta = this.underspeedPid.getOutput(dt, minIas - effectiveIas);
        out.isUnderspeed = effectiveIas < minIas;
      } else {
        this.underspeedPid.reset();
      }
      if (isTargetSpeed) {
        const targetIas = this.selectedSpeedIsMach.get() ? this.selectedMach.get() * machToKias : this.selectedIas.get();
        selectedSpeedDelta = this.selectedSpeedPid.getOutput(dt, targetIas - effectiveIas);
      } else {
        this.selectedSpeedPid.reset();
      }
      let throttlePowerSum = 0;
      let throttlePowerCount = 0;
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          throttlePowerSum += throttle.effectivePower;
          throttlePowerCount++;
        }
      }
      if (throttlePowerCount === 0) {
        this.overspeedProtPowerTargetSmoother.reset();
        this.underspeedProtPowerTargetSmoother.reset();
        this.selectedSpeedPowerTargetSmoother.reset();
        return out;
      }
      if (selectedSpeedDelta !== void 0) {
        out.selectedSpeedPowerTarget = this.selectedSpeedPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + selectedSpeedDelta, dt);
      } else {
        this.selectedSpeedPowerTargetSmoother.reset();
      }
      if (overspeedProtDelta !== void 0) {
        out.overspeedProtPowerTarget = this.overspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + overspeedProtDelta, dt);
      } else {
        this.overspeedProtPowerTargetSmoother.reset();
      }
      if (underspeedProtDelta !== void 0) {
        out.underspeedProtPowerTarget = this.underspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + underspeedProtDelta, dt);
      } else {
        this.underspeedProtPowerTargetSmoother.reset();
      }
      return out;
    }
    /**
     * Calculates the throttle position for a specific throttle commanded by this autothrottle's power controller. The
     * power controller incorporates the power target if active and overpower protection.
     * @param throttle The throttle for which to calculate commanded throttle position.
     * @param speedCommand The engine power commanded by this autothrottle's speed controller.
     * @param isOverpowerProtActive Whether overpower protection is active.
     * @param isPowerTargetActive Whether power target is active.
     * @param isThrottlePosTargetActive Whether throttle lever position target is active.
     * @param dt The elapsed time since the last update.
     * @param out The object to which to write the results.
     * @returns The throttle position for the specified throttle commanded by this autothrottle's power controller.
     */
    calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, out) {
      out.speed = void 0;
      out.targetPos = void 0;
      out.isOverspeedProtEngaged = false;
      out.isUnderspeedProtEngaged = false;
      out.isOverpowerProtEngaged = false;
      const targetPid = this.selectedPowerPids[throttle.index];
      const overpowerPid = this.overpowerPids[throttle.index];
      const power = throttle.power;
      const effectivePower = throttle.effectivePower;
      let overpowerProtDelta;
      let isOverpower = false;
      if (isOverpowerProtActive) {
        const maxPower = this.maxPower.get();
        overpowerProtDelta = overpowerPid.getOutput(dt, maxPower - effectivePower);
        isOverpower = power > maxPower;
      } else {
        overpowerPid.reset();
      }
      let targetDelta;
      let delta;
      let isUsingOverspeedProtCommand = false;
      let isUsingUnderspeedProtCommand = false;
      let isUsingOverpowerProtCommand = false;
      let powerTarget;
      if (isPowerTargetActive) {
        powerTarget = this.selectedPower.get();
      } else {
        powerTarget = speedCommand.selectedSpeedPowerTarget;
      }
      if (powerTarget === void 0) {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isOverspeed && speedCommand.overspeedProtPowerTarget < effectivePower)) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isUnderspeed && speedCommand.underspeedProtPowerTarget > effectivePower)) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      } else {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && speedCommand.overspeedProtPowerTarget < powerTarget) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && speedCommand.underspeedProtPowerTarget > powerTarget) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      }
      if (powerTarget !== void 0) {
        targetDelta = targetPid.getOutput(dt, powerTarget - effectivePower);
      } else {
        targetPid.reset();
      }
      if (targetDelta === void 0) {
        if (overpowerProtDelta !== void 0 && (isThrottlePosTargetActive || isOverpower && overpowerProtDelta < 0)) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        }
      } else {
        if (overpowerProtDelta !== void 0 && overpowerProtDelta < targetDelta) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        } else {
          delta = targetDelta;
        }
      }
      if (isThrottlePosTargetActive) {
        const selectedTarget = this.selectedThrottlePos.get();
        const selectedTargetDelta = MathUtils.clamp((selectedTarget - throttle.normPosition) / dt, -throttle.servoSpeed, throttle.servoSpeed);
        if (
          // ... the power controller is not commanding any adjustment
          delta === void 0 || (isUsingOverspeedProtCommand || isUsingOverpowerProtCommand) && selectedTargetDelta < delta || isUsingUnderspeedProtCommand && selectedTargetDelta > delta
        ) {
          delta = selectedTargetDelta;
          isUsingOverspeedProtCommand = false;
          isUsingUnderspeedProtCommand = false;
          isUsingOverpowerProtCommand = false;
        }
      }
      if (delta === void 0) {
        return out;
      }
      out.speed = delta;
      out.targetPos = throttle.normPosition + delta * dt;
      out.isOverspeedProtEngaged = isUsingOverspeedProtCommand;
      out.isUnderspeedProtEngaged = isUsingUnderspeedProtCommand;
      out.isOverpowerProtEngaged = isUsingOverpowerProtCommand;
      return out;
    }
    /**
     * Destroys this autothrottle.
     */
    destroy() {
      this.isAlive = false;
      this.stop();
      this.realTime.destroy();
      this.throttles.forEach((throttle) => {
        throttle.destroy();
      });
    }
    /**
     * Creates a PID controller using a given set of parameters.
     * @param params A set of PID parameters.
     * @returns A new PID controller created using the specified parameters.
     */
    static createPidFromParams(params) {
      return new PidController(params.kP, params.kI, params.kD, params.maxOut, params.minOut, params.maxI, params.minI);
    }
  };
  AbstractAutothrottle.ALL_THROTTLE_INDEXES = [1, 2, 3, 4];
  var AutothrottleThrottle = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param info Information describing this throttle.
     * @param servoSpeed The speed delivered by the servo controlling this throttle, in units of normalized position per
     * second.
     * @param powerSmoothingConstant The smoothing time constant, in seconds, to use to smooth engine power data.
     * @param powerLookahead The lookahead time, in seconds, to use for engine power data.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for this throttle's
     * lever. If not defined, position changes for the lever will be requested using key events (specifically the
     * `THROTTLE[N]_SET` event).
     */
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      this.servoSpeed = servoSpeed;
      this.powerLookahead = powerLookahead;
      this._position = 0;
      this._power = 0;
      this._effectivePower = 0;
      this._isServoActive = Subject.create(false);
      this.lastPowerLookahead = this.powerLookahead.get();
      this.lastSmoothedPower = void 0;
      this.initKeyManager(bus);
      ({ index: this.index, idlePosition: this.idlePosition, maxThrustPosition: this.maxThrustPosition } = info);
      if (info.isVirtual) {
        this.virtualPos = ConsumerSubject.create(bus.getSubscriber().on(`v_throttle_lever_pos_${this.index}`), 0), this.getPosition = () => {
          return this.virtualPos.get();
        };
      } else {
        this.throttlePosSimVar = `GENERAL ENG THROTTLE LEVER POSITION:${this.index}`;
        this.getPosition = () => {
          return SimVar.GetSimVarValue(this.throttlePosSimVar, SimVarValueType.Percent) / 100;
        };
      }
      this.normRange = this.maxThrustPosition - this.idlePosition;
      this.throttleSetKVar = `THROTTLE${this.index}_SET`;
      this.throttleLeverManager = info.isVirtual ? throttleLeverManager : void 0;
      const isServoActiveTopic = `at_servo_${this.index}_is_active`;
      this._isServoActive.sub((val) => {
        bus.getPublisher().pub(isServoActiveTopic, val, true, true);
      });
      this.powerSmoother = new ExpSmoother(powerSmoothingConstant);
      this.lookaheadPowerSmoother = new ExpSmoother(powerSmoothingConstant);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The current position of this throttle. */
    get position() {
      return this._position;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The position of this throttle, normalized such that `0` is the idle position and `1` is the maximum thrust
     * position.
     */
    get normPosition() {
      return (this._position - this.idlePosition) / this.normRange;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The power delivered by this throttle's engine. */
    get power() {
      return this._power;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The effective power delivered by this throttle's engine, after smoothing and lookahead have been applied. */
    get effectivePower() {
      return this._effectivePower;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether the autothrottle servo for this throttle is active. */
    get isServoActive() {
      return this._isServoActive.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set isServoActive(val) {
      this._isServoActive.set(val);
    }
    /**
     * Initializes the key event manager used by this throttle.
     * @param bus The event bus.
     */
    async initKeyManager(bus) {
      this.keyEventManager = await KeyEventManager.getManager(bus);
    }
    /**
     * Updates this throttle's current position and delivered power properties.
     * @param dt The elapsed time since the last update, in seconds.
     */
    update(dt) {
      this._position = this.getPosition();
      this._power = this.getPower();
      const lookahead = Math.max(0, this.powerLookahead.get());
      const smoothedPower = this.powerSmoother.next(this._power, dt);
      if (lookahead !== this.lastPowerLookahead) {
        this.lookaheadPowerSmoother.reset();
        this.lastPowerLookahead = lookahead;
      }
      if (lookahead > 0 && this.lastSmoothedPower !== void 0) {
        const delta = smoothedPower - this.lastSmoothedPower;
        this._effectivePower = this.lookaheadPowerSmoother.next(this._power + delta * lookahead / dt, dt);
      } else {
        this._effectivePower = smoothedPower;
      }
      this.lastSmoothedPower = smoothedPower;
    }
    /**
     * Drives this throttle toward a target normalized position over a period of time.
     * @param targetNormPos The target normalized position. Will be clamped to the range `[0, 1]`.
     * @param dt The amount of time over which to drive the throttle, in seconds.
     */
    drive(targetNormPos, dt) {
      var _a;
      const current = this.normPosition;
      const delta = targetNormPos - current;
      if (delta === 0) {
        return;
      }
      const deltaSign = Math.sign(delta);
      const toDrive = Math.min(dt * this.servoSpeed, (targetNormPos - current) * deltaSign) * deltaSign;
      const finalPos = this.idlePosition + (current + toDrive) * this.normRange;
      if (Math.abs(finalPos - this._position) < 0.5 / AutothrottleThrottle.RAW_AXIS_MAX) {
        return;
      }
      if (this.throttleLeverManager !== void 0) {
        this.throttleLeverManager.setThrottleLeverPosRaw(this.index, finalPos * AutothrottleThrottle.RAW_AXIS_MAX);
      } else {
        (_a = this.keyEventManager) === null || _a === void 0 ? void 0 : _a.triggerKey(this.throttleSetKVar, false, Math.round(finalPos * AutothrottleThrottle.RAW_AXIS_MAX));
      }
    }
    /**
     * Resets this throttle's power smoothing.
     */
    resetPowerSmoothing() {
      this.powerSmoother.reset();
      this.lookaheadPowerSmoother.reset();
      this.lastSmoothedPower = void 0;
    }
    /**
     * Destroys this throttle.
     */
    destroy() {
      var _a;
      (_a = this.virtualPos) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  AutothrottleThrottle.RAW_AXIS_MAX = 16384;
  var JetAutothrottle = class extends AbstractAutothrottle {
    /** @inheritdoc */
    createThrottle(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      return new JetAutothrottleThrottle(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager);
    }
  };
  var JetAutothrottleThrottle = class extends AutothrottleThrottle {
    /** @inheritdoc */
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      super(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager);
      this.commandedN1SimVar = `TURB ENG THROTTLE COMMANDED N1:${this.index}`;
    }
    /** @inheritdoc */
    getPower() {
      return SimVar.GetSimVarValue(this.commandedN1SimVar, SimVarValueType.Percent);
    }
  };
  var TurbopropAutothrottle = class extends AbstractAutothrottle {
    /** @inheritdoc */
    createThrottle(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      return new TurbopropAutothrottleThrottle(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager);
    }
  };
  var TurbopropAutothrottleThrottle = class extends AutothrottleThrottle {
    /** @inheritdoc */
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      super(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager);
      this.torqueSimVar = `TURB ENG MAX TORQUE PERCENT:${this.index}`;
    }
    /** @inheritdoc */
    getPower() {
      return SimVar.GetSimVarValue(this.torqueSimVar, SimVarValueType.Percent);
    }
  };
  var CasAlertTransporter = class {
    /**
     * Creates an instance of a CasAlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     */
    constructor(bus, uuid, priority, suffix) {
      this.bus = bus;
      this.uuid = uuid;
      this.priority = priority;
      this.suffix = suffix;
      this.currentValue = false;
      this.subs = [];
      this.updateEntries = [];
      this.isAlive = true;
      this.isPaused = false;
    }
    /**
     * Sets whether or not the alert is active.
     * @param active Whether or not the alert is active.
     * @throws Error if this transporter has been destroyed.
     */
    set(active) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot change an alert with a dead transporter");
      }
      if (this.currentValue !== active) {
        if (active) {
          this.bus.getPublisher().pub("cas_activate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        } else {
          this.bus.getPublisher().pub("cas_deactivate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        }
        this.currentValue = active;
      }
    }
    /**
     * Binds an alert state to a subscribable value.
     * @param toWatch The subscribable value to watch.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bind(toWatch, predicate) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      this.subs.push(toWatch.sub((v) => this.set(predicate(v)), true, this.isPaused));
      return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindUpdate(predicate) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: false,
        func: (deltaTime) => this.set(predicate(deltaTime))
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @param state The optional state to pass into the predicate.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindStateUpdate(predicate, state) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: true,
        func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
        state
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    /**
     * Resumes this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also resumed. On resumption, the values of bound subscribables are evaluated
     * immediately, while the values of bound update loops will be evaluated during the next update cycle.
     * @returns This transporter, after it has been resumed.
     * @throws Error if this transporter has been destroyed.
     */
    resume() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot resume a dead transporter");
      }
      if (!this.isPaused) {
        return this;
      }
      this.isPaused = false;
      this.subs.forEach((sub) => {
        sub.resume(true);
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = false;
      });
      return this;
    }
    /**
     * Pauses this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also paused.
     * @returns This transporter, after it has been paused.
     * @throws Error if this transporter has been destroyed.
     */
    pause() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot pause a dead transporter");
      }
      if (this.isPaused) {
        return this;
      }
      this.isPaused = true;
      this.subs.forEach((sub) => {
        sub.pause();
      });
      if (CasAlertTransporter.updateEntries) {
        this.updateEntries.forEach((entry) => {
          const index = CasAlertTransporter.updateEntries.indexOf(entry);
          if (index >= 0) {
            CasAlertTransporter.updateEntries.splice(index, 1);
          }
        });
      }
      return this;
    }
    /**
     * Destroys this transporter. This will destroy any subscribables or update loops used to bind the state of this
     * transporter's alert. Once this transporter has been destroyed, it cannot be used to change the state of its alert,
     * bind the state of its alert, or be paused or resumed.
     */
    destroy() {
      this.isAlive = false;
      this.subs.forEach((sub) => {
        sub.destroy();
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = true;
      });
    }
    /**
     * Creates an instance of an AlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     * @returns The created AlertTransporter.
     */
    static create(bus, uuid, priority, suffix) {
      return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    /**
     * Initializes the update functions.
     */
    initUpdateFuncs() {
      if (CasAlertTransporter.updateEntries === void 0) {
        CasAlertTransporter.updateEntries = [];
        this.bus.getSubscriber().on("simTime").handle((timestamp) => {
          if (CasAlertTransporter.previousTimestamp === -1) {
            CasAlertTransporter.previousTimestamp = timestamp;
          }
          const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 1e4);
          if (CasAlertTransporter.updateEntries !== void 0) {
            for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
              const entry = CasAlertTransporter.updateEntries[i];
              if (entry.isPaused) {
                continue;
              }
              if (entry.hasState) {
                entry.func(deltaTime, entry.state);
              } else {
                entry.func(deltaTime);
              }
            }
          }
          CasAlertTransporter.previousTimestamp = timestamp;
        });
      }
    }
  };
  CasAlertTransporter.previousTimestamp = -1;
  var CasRegistrationManager = class {
    /**
     * Create a CasRegistrationManager
     * @param bus The event bus
     */
    constructor(bus) {
      this.registrations = /* @__PURE__ */ new Map();
      this.publisher = bus.getPublisher();
      const subscriber = bus.getSubscriber();
      subscriber.on("cas_publish_registration").handle((uuid) => this.publishRegistration(uuid));
      subscriber.on("cas_publish_all_registrations").handle(() => this.publishAllRegistrations());
    }
    /**
     * Register an alert for management.
     * @param definition The CasAlertDefinition for this alert.
     */
    register(definition) {
      this.registrations.set(definition.uuid, definition);
      this.publishRegistration(definition.uuid);
    }
    /**
     * Handle publishing information for a single alert.
     * @param uuid The UUID of the registation to publish.
     */
    publishRegistration(uuid) {
      const definition = this.registrations.get(uuid);
      if (definition) {
        this.publisher.pub("cas_register_alert", definition, true);
      }
    }
    /**
     * Publish all current registrations.
     */
    publishAllRegistrations() {
      for (const uuid of this.registrations.keys()) {
        this.publishRegistration(uuid);
      }
    }
  };
  var CasSystem = class {
    /**
     * Create a CasSystem.
     * @param bus The event bus.
     * @param primary Whether or not this is the system responsible for managing alerts at the sim level.
     */
    constructor(bus, primary = false) {
      this.registeredAlerts = /* @__PURE__ */ new Map();
      this.activeInhibitStates = /* @__PURE__ */ new Set();
      this.scheduledSuffixedAlerts = /* @__PURE__ */ new Map();
      this.scheduledUnsuffixedAlerts = /* @__PURE__ */ new Map();
      this.previousScheduleCheckTime = -1;
      this.initialAcknowledge = true;
      this.masterWarningActive = void 0;
      this.masterCautionActive = void 0;
      this.allMessages = /* @__PURE__ */ new Map([
        [AnnunciationType.Warning, /* @__PURE__ */ new Map()],
        [AnnunciationType.Caution, /* @__PURE__ */ new Map()],
        [AnnunciationType.Advisory, /* @__PURE__ */ new Map()],
        [AnnunciationType.SafeOp, /* @__PURE__ */ new Map()]
      ]);
      this.displayedCasMessages = ArraySubject.create();
      this.prevDisplayedCasMessages = [];
      this._casActiveMessageSubject = SortedMappedSubscribableArray.create(this.displayedCasMessages, (a, b) => {
        if (a.uuid && b.uuid && a.lastActive !== void 0 && b.lastActive !== void 0) {
          if (a.priority === b.priority) {
            return b.lastActive - a.lastActive;
          }
          return a.priority - b.priority;
        } else {
          return 0;
        }
      }, (a, b) => a.uuid === b.uuid);
      this.casActiveMessageSubject = this._casActiveMessageSubject;
      this.bus = bus;
      this.casSubscriber = this.bus.getSubscriber();
      this.casPublisher = this.bus.getPublisher();
      this.casStatePublisher = this.bus.getPublisher();
      this.isPrimary = primary;
      this.setMasterStatus(AnnunciationType.Caution, false);
      this.setMasterStatus(AnnunciationType.Warning, false);
      this.bus.getSubscriber().on("simTime").handle((t) => this.checkScheduledAlerts(t));
      if (this.isPrimary) {
        KeyEventManager.getManager(this.bus).then((manager) => {
          manager.interceptKey("MASTER_CAUTION_ACKNOWLEDGE", true);
          manager.interceptKey("MASTER_WARNING_ACKNOWLEDGE", true);
        });
        this.bus.getSubscriber().on("key_intercept").handle((keyData) => {
          switch (keyData.key) {
            case "MASTER_CAUTION_ACKNOWLEDGE":
              this.handleAcknowledgement(AnnunciationType.Caution);
              break;
            case "MASTER_WARNING_ACKNOWLEDGE":
              this.handleAcknowledgement(AnnunciationType.Warning);
              break;
          }
        });
      }
      this.casSubscriber.on("cas_register_alert").handle((alertConfig) => {
        if (!this.registeredAlerts.has(alertConfig.uuid)) {
          this.registeredAlerts.set(alertConfig.uuid, alertConfig);
        }
      });
      this.casSubscriber.on("cas_activate_alert").handle((eventData) => {
        this.scheduleAlert(eventData.key, eventData.priority);
      });
      this.casSubscriber.on("cas_deactivate_alert").handle((eventData) => {
        this.deactivateAlert(eventData.key, eventData.priority);
      });
      this.casSubscriber.on("cas_activate_inhibit_state").handle((state) => {
        this.handleInhibitState(state, true);
      });
      this.casSubscriber.on("cas_deactivate_inhibit_state").handle((state) => {
        this.handleInhibitState(state, false);
      });
      this.casSubscriber.on("cas_set_initial_acknowledge").handle((v) => {
        this.initialAcknowledge = v;
      });
      if (!this.isPrimary) {
        this.casSubscriber.on("cas_master_acknowledge").handle((ackType) => {
          this.handleAcknowledgement(ackType);
        });
      }
      this.casSubscriber.on("cas_suppress_priority").handle((priority) => {
        this.suppressType(priority);
      });
      this.casSubscriber.on("cas_unsuppress_priority").handle((priority) => {
        this.unsuppressAllSuppressed(priority);
      });
      this.casPublisher.pub("cas_publish_all_registrations", true, true);
    }
    /**
     * Suppress all messages of a given type.
     * @param priority The type of messages which shall be suppressed.
     */
    suppressType(priority) {
      for (const [, message] of this.allMessages.get(priority) || []) {
        message.suppressed = true;
      }
      this.refreshDisplayedAlerts();
    }
    /**
     * Unsuppress all messages of a given type.
     * @param priority The type of messages which shall be suppressed.
     */
    unsuppressAllSuppressed(priority) {
      for (const [, message] of this.allMessages.get(priority) || []) {
        message.suppressed = false;
      }
      this.refreshDisplayedAlerts();
    }
    /**
     * Create a new message from an alert key at a given priority.
     * @param alertKey The alert key.
     * @param priority The priority.
     * @returns A new CasActiveMessage or undefined if the key was invalid.
     */
    createNewMessage(alertKey, priority) {
      var _a;
      const def = this.registeredAlerts.get(alertKey.uuid);
      if (def === void 0) {
        return void 0;
      }
      let inhibited = false;
      for (const state of def.inhibitedBy || []) {
        if (this.activeInhibitStates.has(state)) {
          inhibited = true;
          break;
        }
      }
      return {
        uuid: alertKey.uuid,
        message: (_a = def.message) !== null && _a !== void 0 ? _a : "MISSING MESSAGE",
        priority,
        acknowledged: this.initialAcknowledge,
        inhibited,
        suppressed: false,
        lastActive: Date.now(),
        suffixes: alertKey.suffix !== void 0 ? [alertKey.suffix] : void 0,
        acknowledgedSuffixes: alertKey.suffix !== void 0 ? this.initialAcknowledge ? [alertKey.suffix] : [] : void 0
      };
    }
    /**
     * Schedule an alert to go active at the end of its debounce time.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to fire.
     */
    scheduleAlert(alertKey, priority) {
      var _a;
      const debounceTime = (_a = this.registeredAlerts.get(alertKey.uuid)) === null || _a === void 0 ? void 0 : _a.debounceTime;
      if (debounceTime === void 0) {
        this.activateAlert(alertKey, priority);
        return;
      }
      if (alertKey.suffix !== void 0) {
        let uuidMap = this.scheduledSuffixedAlerts.get(alertKey.uuid);
        if (uuidMap === void 0) {
          uuidMap = /* @__PURE__ */ new Map();
          this.scheduledSuffixedAlerts.set(alertKey.uuid, uuidMap);
        }
        let suffixMap = uuidMap.get(alertKey.suffix);
        if (suffixMap === void 0) {
          suffixMap = /* @__PURE__ */ new Map();
          uuidMap.set(alertKey.suffix, suffixMap);
        }
        const time = suffixMap.get(priority);
        if (time !== void 0) {
          return;
        }
        suffixMap.set(priority, debounceTime);
      } else {
        let uuidMap = this.scheduledUnsuffixedAlerts.get(alertKey.uuid);
        if (uuidMap === void 0) {
          uuidMap = /* @__PURE__ */ new Map();
          this.scheduledUnsuffixedAlerts.set(alertKey.uuid, uuidMap);
        }
        const time = uuidMap.get(priority);
        if (time !== void 0) {
          return;
        }
        uuidMap.set(priority, debounceTime);
      }
    }
    /**
     * Check the scheduled alerts to see if there's anything that needs to fire.
     * @param timestamp The current sim time.
     */
    checkScheduledAlerts(timestamp) {
      if (this.previousScheduleCheckTime !== -1) {
        const deltaTime = NavMath.clamp(timestamp - this.previousScheduleCheckTime, 0, 1e4);
        for (const [uuid, uuidMap] of this.scheduledUnsuffixedAlerts) {
          for (const [priority, delay] of uuidMap) {
            const newDelay = delay - deltaTime;
            if (newDelay <= 0) {
              this.activateAlert({ uuid }, priority);
              uuidMap.delete(priority);
            } else {
              uuidMap.set(priority, newDelay);
            }
          }
        }
        for (const [uuid, uuidMap] of this.scheduledSuffixedAlerts) {
          for (const [suffix, suffixMap] of uuidMap) {
            for (const [priority, delay] of suffixMap) {
              const newDelay = delay - deltaTime;
              if (newDelay <= 0) {
                this.activateAlert({ uuid, suffix }, priority);
                suffixMap.delete(priority);
              } else {
                suffixMap.set(priority, newDelay);
              }
            }
          }
        }
      }
      this.previousScheduleCheckTime = timestamp;
    }
    /**
     * Handle an alert going active.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to fire.
     */
    activateAlert(alertKey, priority) {
      var _a;
      if (!this.checkValidAlertKey(alertKey)) {
        return;
      }
      const messagesAtPriority = this.allMessages.get(priority);
      const uuidMessageAtPriority = messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.get(alertKey.uuid);
      if (uuidMessageAtPriority === void 0) {
        const newMessage = this.createNewMessage(alertKey, priority);
        if (newMessage !== void 0) {
          messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.set(alertKey.uuid, newMessage);
        }
      } else {
        uuidMessageAtPriority.acknowledged && (uuidMessageAtPriority.acknowledged = this.initialAcknowledge);
        uuidMessageAtPriority.lastActive = Date.now();
        if (alertKey.suffix !== void 0) {
          const suffixes = uuidMessageAtPriority.suffixes;
          const acknowledgedSuffixes = uuidMessageAtPriority.acknowledgedSuffixes;
          if (!suffixes.includes(alertKey.suffix)) {
            suffixes.push(alertKey.suffix);
            if (this.initialAcknowledge) {
              acknowledgedSuffixes.push(alertKey.suffix);
            }
            const suffixOrder = (_a = this.registeredAlerts.get(alertKey.uuid)) === null || _a === void 0 ? void 0 : _a.suffixes;
            if (suffixOrder !== void 0) {
              const comparator = (a, b) => suffixOrder.indexOf(a) - suffixOrder.indexOf(b);
              suffixes.sort(comparator);
              if (this.initialAcknowledge) {
                acknowledgedSuffixes.sort(comparator);
              }
            }
          }
        }
      }
      this.refreshDisplayedAlerts();
    }
    /**
     * Handle an alert going inactive.
     * @param alertKey The UUID and optional suffix of the alert to handle.
     * @param priority The priority of the alert to clear.
     */
    deactivateAlert(alertKey, priority) {
      var _a, _b, _c, _d;
      if (!this.checkValidAlertKey(alertKey)) {
        return;
      }
      if (alertKey.suffix === void 0) {
        (_a = this.allMessages.get(priority)) === null || _a === void 0 ? void 0 : _a.delete(alertKey.uuid);
        (_b = this.scheduledUnsuffixedAlerts.get(alertKey.uuid)) === null || _b === void 0 ? void 0 : _b.delete(priority);
      } else {
        (_d = (_c = this.scheduledSuffixedAlerts.get(alertKey.uuid)) === null || _c === void 0 ? void 0 : _c.get(alertKey.suffix)) === null || _d === void 0 ? void 0 : _d.delete(priority);
        const messagesAtPriority = this.allMessages.get(priority);
        const uuidMessageAtPriority = messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.get(alertKey.uuid);
        if (uuidMessageAtPriority !== void 0) {
          const suffixes = uuidMessageAtPriority.suffixes;
          const acknowledgedSuffixes = uuidMessageAtPriority.acknowledgedSuffixes;
          suffixes.splice(suffixes.indexOf(alertKey.suffix), 1);
          if (suffixes.length == 0) {
            messagesAtPriority === null || messagesAtPriority === void 0 ? void 0 : messagesAtPriority.delete(alertKey.uuid);
          } else {
            acknowledgedSuffixes.splice(acknowledgedSuffixes.indexOf(alertKey.suffix), 1);
          }
        }
      }
      this.refreshDisplayedAlerts();
    }
    /**
     * Handle a master warning or caution acknowledgement.
     * @param type The type of alert to acknowledge.
     */
    handleAcknowledgement(type) {
      if (this.isPrimary && [AnnunciationType.Caution, AnnunciationType.Warning].includes(type)) {
        this.casPublisher.pub("cas_master_acknowledge", type, true);
      }
      this.setMasterStatus(type, false);
      const messagesAtPriority = this.allMessages.get(type);
      if (messagesAtPriority !== void 0) {
        for (const uuid of messagesAtPriority.keys()) {
          const message = messagesAtPriority.get(uuid);
          if (message !== void 0 && !message.inhibited) {
            message.acknowledged = true;
            if (message.suffixes && message.acknowledgedSuffixes) {
              message.acknowledgedSuffixes.length = message.suffixes.length;
              for (let i = 0; i < message.suffixes.length; i++) {
                const suffix = message.suffixes[i];
                if (message.acknowledgedSuffixes[i] !== suffix) {
                  message.acknowledgedSuffixes.splice(i, 0, suffix);
                  this.casStatePublisher.pub("cas_alert_acknowledged", {
                    uuid: message.uuid,
                    suffix: message.suffixes[i],
                    priority: message.priority,
                    acknowledged: true
                  }, false, false);
                }
              }
            } else {
              this.casStatePublisher.pub("cas_alert_acknowledged", {
                uuid: message.uuid,
                priority: message.priority,
                acknowledged: true
              }, false, false);
            }
          }
        }
      }
      this.refreshDisplayedAlerts();
    }
    /**
     * Handle the setting of a new inhibit state.
     * @param state The name of the inhibited state to set.
     * @param active Whether the state is active or not.
     */
    handleInhibitState(state, active) {
      var _a, _b, _c, _d;
      if (active && !this.activeInhibitStates.has(state) || !active && this.activeInhibitStates.has(state)) {
        if (active) {
          this.activeInhibitStates.add(state);
        } else {
          this.activeInhibitStates.delete(state);
        }
        for (const priority of this.allMessages.keys()) {
          for (const message of (_b = (_a = this.allMessages.get(priority)) === null || _a === void 0 ? void 0 : _a.values()) !== null && _b !== void 0 ? _b : []) {
            if (message !== void 0) {
              let isInhibited = false;
              for (const candidateState of (_d = (_c = this.registeredAlerts.get(message.uuid)) === null || _c === void 0 ? void 0 : _c.inhibitedBy) !== null && _d !== void 0 ? _d : []) {
                if (this.activeInhibitStates.has(candidateState)) {
                  isInhibited = true;
                  break;
                }
              }
              message.inhibited = isInhibited;
            }
          }
        }
      }
      this.refreshDisplayedAlerts();
    }
    /**
     * Set both sets of simvars relevant to a master caution or warning status.
     * @param type The type of the status to set
     * @param active Whether or not the status is active
     */
    setMasterStatus(type, active) {
      switch (type) {
        case AnnunciationType.Caution:
          if (this.masterCautionActive !== active) {
            if (this.isPrimary) {
              SimVar.SetSimVarValue("K:MASTER_CAUTION_SET", SimVarValueType.Number, active ? 1 : 0);
              SimVar.SetSimVarValue("L:Generic_Master_Caution_Active", SimVarValueType.Bool, active);
            }
            this.masterCautionActive = active;
            this.casStatePublisher.pub("cas_master_caution_active", active, false, true);
          }
          break;
        case AnnunciationType.Warning:
          if (this.masterWarningActive !== active) {
            if (this.isPrimary) {
              SimVar.SetSimVarValue("K:MASTER_WARNING_SET", SimVarValueType.Number, active ? 1 : 0);
              SimVar.SetSimVarValue("L:Generic_Master_Warning_Active", SimVarValueType.Bool, active);
            }
            this.masterWarningActive = active;
            this.casStatePublisher.pub("cas_master_warning_active", active, false, true);
          }
          break;
      }
    }
    /**
     * Get the full registered definition of an alert based on its key.
     * @param alertKey The key of the alert definition to retrieve.
     * @returns The full alert definition, or undefined if not found.
     */
    getAlertDefinition(alertKey) {
      const alertDefinition = this.registeredAlerts.get(alertKey.uuid);
      if (alertDefinition === void 0) {
        console.warn(`Trying to access an unregistered alert UUID: ${alertKey.uuid}`);
        return void 0;
      } else {
        return alertDefinition;
      }
    }
    /**
     * Check whether a provided alert key is valid according to the alert's suffix definition.
     * @param alertKey The key of the alert to check.
     * @returns A boolean indicating whether the key is valid.
     */
    checkValidAlertKey(alertKey) {
      const alertDefinition = this.getAlertDefinition(alertKey);
      if (alertDefinition === void 0) {
        return false;
      }
      const suffixes = alertDefinition.suffixes;
      if (alertKey.suffix === void 0 && suffixes !== void 0) {
        console.warn(`Trying to access a suffixed alert without a suffix: '${alertDefinition.message}'`);
        return false;
      } else if (alertKey.suffix !== void 0 && suffixes === void 0) {
        console.warn(`Trying to access a non-suffixed alert with a suffix: '${alertDefinition.message}:${alertKey.suffix}'`);
        return false;
      } else if (alertKey.suffix !== void 0 && !(suffixes === null || suffixes === void 0 ? void 0 : suffixes.includes(alertKey.suffix))) {
        console.warn(`Trying to access a suffixed alert with an invalid suffix: '${alertDefinition.message}:${alertKey.suffix}'`);
        return false;
      }
      return true;
    }
    /**
     * See if there is still an active, unacked annunciation of the given type.
     * @param type The annunciation type to check for.
     * @returns True if there is an active, unacked annunciation of the given type, false otherwise.
     */
    checkForActiveType(type) {
      const messagesAtPriority = this.allMessages.get(type);
      if (messagesAtPriority !== void 0) {
        for (const message of messagesAtPriority.values()) {
          if (!message.acknowledged) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * Reprocess all active alerts to generate a list consisting only of those which are displayable.
     * At the same time, keep track of whether or not the master warning or caution lights should be
     * active and, if the primary CasSystem, set them appropriately when done.
     */
    refreshDisplayedAlerts() {
      this.displayedCasMessages.clear();
      const unsuffixedDisplayedKeys = /* @__PURE__ */ new Set();
      const suffixedDisplayedKeys = /* @__PURE__ */ new Map();
      let unackedWarnings = false;
      let unackedCautions = false;
      for (const priority of [
        AnnunciationType.Warning,
        AnnunciationType.Caution,
        AnnunciationType.Advisory,
        AnnunciationType.SafeOp
      ]) {
        for (const [uuid, message] of this.allMessages.get(priority) || []) {
          if (message.inhibited || message.suppressed) {
            continue;
          }
          if (message.suffixes === void 0) {
            if (!unsuffixedDisplayedKeys.has(uuid)) {
              unsuffixedDisplayedKeys.add(uuid);
              this.displayedCasMessages.insert(message);
              if (!message.acknowledged) {
                switch (priority) {
                  case AnnunciationType.Warning:
                    unackedWarnings = true;
                    break;
                  case AnnunciationType.Caution:
                    unackedCautions = true;
                    break;
                }
              }
            }
          } else {
            const origSuffixes = message.suffixes;
            message.suffixes = [];
            for (const suffix of origSuffixes) {
              const suffixesDisplayed = suffixedDisplayedKeys.get(uuid);
              if (suffixesDisplayed === void 0) {
                suffixedDisplayedKeys.set(uuid, /* @__PURE__ */ new Set([suffix]));
                message.suffixes.push(suffix);
              } else {
                if (!suffixesDisplayed.has(suffix)) {
                  suffixesDisplayed.add(suffix);
                  message.suffixes.push(suffix);
                }
              }
            }
            if (message.suffixes.length > 0) {
              this.displayedCasMessages.insert(message);
              if (!message.acknowledged) {
                switch (priority) {
                  case AnnunciationType.Warning:
                    unackedWarnings = true;
                    break;
                  case AnnunciationType.Caution:
                    unackedCautions = true;
                    break;
                }
              }
            }
          }
        }
      }
      this.setMasterStatus(AnnunciationType.Caution, unackedCautions);
      this.setMasterStatus(AnnunciationType.Warning, unackedWarnings);
      const oldMessages = this.prevDisplayedCasMessages;
      const newMessages = this.displayedCasMessages.getArray();
      this.diffAlerts(newMessages, oldMessages, "cas_alert_hidden");
      this.diffAlerts(oldMessages, newMessages, "cas_alert_displayed");
      CasSystem.copyMessageArray(newMessages, this.prevDisplayedCasMessages);
    }
    /**
     * Finds alerts displayed in a query message array that are not displayed in a reference message array and publishes
     * them.
     * @param referenceMessages The reference message array.
     * @param queryMessages The query message array.
     * @param topic The event bus topic to publish to.
     */
    diffAlerts(referenceMessages, queryMessages, topic) {
      for (let i = 0; i < queryMessages.length; i++) {
        const queryMessage = queryMessages[i];
        let matchedReferenceMessage = void 0;
        for (let j = 0; j < referenceMessages.length; j++) {
          const referenceMessage = referenceMessages[j];
          if (referenceMessage.priority === queryMessage.priority && referenceMessage.uuid === queryMessage.uuid) {
            matchedReferenceMessage = referenceMessage;
            break;
          }
        }
        if (queryMessage.suffixes && queryMessage.suffixes.length > 0) {
          for (let k = 0; k < queryMessage.suffixes.length; k++) {
            const suffix = queryMessage.suffixes[k];
            if (!matchedReferenceMessage || !matchedReferenceMessage.suffixes || !matchedReferenceMessage.suffixes.includes(suffix)) {
              this.casStatePublisher.pub(topic, {
                uuid: queryMessage.uuid,
                suffix,
                priority: queryMessage.priority,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                acknowledged: queryMessage.acknowledgedSuffixes.includes(suffix)
              }, false, false);
            }
          }
        } else if (!matchedReferenceMessage || matchedReferenceMessage.suffixes && matchedReferenceMessage.suffixes.length > 0) {
          this.casStatePublisher.pub(topic, {
            uuid: queryMessage.uuid,
            priority: queryMessage.priority,
            acknowledged: queryMessage.acknowledged
          }, false, false);
        }
      }
    }
    /**
     * Copies a CAS message.
     * @param source The source message to copy from.
     * @param target The target message to copy to. If not defined, a new message object will be created.
     * @returns The message copy.
     */
    static copyMessage(source, target) {
      target !== null && target !== void 0 ? target : target = {};
      target.uuid = source.uuid;
      target.message = source.message;
      target.priority = source.priority;
      target.acknowledged = source.acknowledged;
      target.inhibited = source.inhibited;
      target.suppressed = source.suppressed;
      target.lastActive = source.lastActive;
      if (source.suffixes) {
        target.suffixes = ArrayUtils.shallowCopy(source.suffixes, target.suffixes);
      } else {
        target.suffixes = void 0;
      }
      if (source.acknowledgedSuffixes) {
        target.acknowledgedSuffixes = ArrayUtils.shallowCopy(source.acknowledgedSuffixes, target.acknowledgedSuffixes);
      } else {
        target.acknowledgedSuffixes = void 0;
      }
      return target;
    }
    /**
     * Performs a deep copy of a CAS message array.
     * @param source The source array to copy from.
     * @param target The target array to copy to. If not defined, a new array will be created.
     * @returns The array copy.
     */
    static copyMessageArray(source, target) {
      target !== null && target !== void 0 ? target : target = [];
      target.length = source.length;
      for (let i = 0; i < source.length; i++) {
        target[i] = CasSystem.copyMessage(source[i], target[i]);
      }
      return target;
    }
  };
  var CasSystemLegacyAdapter = class {
    /**
     * Create a CasSystemLegacyAdapter
     * @param bus The event bus.
     * @param logicHost A CompositeLogicXMLHost for running the events.
     * @param annunciationDefs An array of system annunciations to monitor.
     */
    constructor(bus, logicHost, annunciationDefs) {
      var _a;
      this.nonSuffixLogic = /* @__PURE__ */ new Map();
      this.suffixLogic = /* @__PURE__ */ new Map();
      this.annunciations = /* @__PURE__ */ new Map();
      this.logicHost = logicHost;
      this.legacyAnnunciations = annunciationDefs;
      this.regManager = new CasRegistrationManager(bus);
      this.pub = bus.getPublisher();
      for (let i = 0; i < this.legacyAnnunciations.length; i++) {
        const legacy = this.legacyAnnunciations[i];
        const annunciation = this.annunciations.get(legacy.uuid);
        if (annunciation === void 0) {
          this.annunciations.set(legacy.uuid, {
            def: {
              uuid: legacy.uuid,
              message: legacy.text,
              suffixes: legacy.suffix !== void 0 ? [legacy.suffix] : void 0
            },
            priority: legacy.type
          });
          if (legacy.suffix === void 0) {
            this.nonSuffixLogic.set(legacy.uuid, legacy.condition);
          } else {
            this.suffixLogic.set(legacy.uuid, /* @__PURE__ */ new Map([[legacy.suffix, legacy.condition]]));
          }
        } else {
          if (legacy.suffix !== void 0) {
            (_a = annunciation.def.suffixes) === null || _a === void 0 ? void 0 : _a.push(legacy.suffix);
            const suffixLogicMap = this.suffixLogic.get(legacy.uuid);
            if (suffixLogicMap === void 0) {
              console.warn(`Trying to add logic to a UUID that doesn't exist: ${legacy.uuid}`);
            } else {
              suffixLogicMap.set(legacy.suffix, legacy.condition);
            }
          }
        }
      }
    }
    /** Register all the alerts and begin monitoring. */
    start() {
      for (const [uuid, info] of this.annunciations) {
        this.regManager.register({
          uuid,
          message: info.def.message,
          suffixes: info.def.suffixes
        });
        if (info.def.suffixes === void 0) {
          const logic = this.nonSuffixLogic.get(uuid);
          if (logic === void 0) {
            console.warn(`Logic missing for non-suffixed UUID ${uuid}`);
          } else {
            this.logicHost.addLogicAsNumber(logic, (v) => {
              if (v == 1) {
                this.pub.pub("cas_activate_alert", { key: { uuid }, priority: info.priority }, true, false);
              } else {
                this.pub.pub("cas_deactivate_alert", { key: { uuid }, priority: info.priority }, true, false);
              }
            }, 0);
          }
        } else {
          const suffixMap = this.suffixLogic.get(uuid);
          if (suffixMap === void 0) {
            console.warn(`Cannot find suffix logic for UUID ${uuid}`);
          } else {
            for (const suffix of info.def.suffixes) {
              const logic = suffixMap.get(suffix);
              if (logic === void 0) {
                console.warn(`Could not find suffix lock '${suffix}' for UUID ${uuid}`);
              } else {
                this.logicHost.addLogicAsNumber(logic, (v) => {
                  if (v == 1) {
                    this.pub.pub("cas_activate_alert", { key: { uuid, suffix }, priority: info.priority }, true, false);
                  } else {
                    this.pub.pub("cas_deactivate_alert", { key: { uuid, suffix }, priority: info.priority }, true, false);
                  }
                }, 0);
              }
            }
          }
        }
      }
    }
  };
  var JetFadec = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param modes The modes supported by this FADEC, ordered from highest to lowest priority.
     * @param throttleInfos An array containing information pertaining to the throttles controlled by this FADEC. The
     * order of modes in the array determines their priority during mode selection. On every update cycle, the FADEC
     * iterates through the modes array in order, calling `accept()` on each mode until a value of `true` is returned.
     * Therefore, modes positioned earlier in the array have a higher priority for selection.
     */
    constructor(bus, modes, throttleInfos) {
      this.bus = bus;
      this.modes = modes;
      this.publisher = this.bus.getPublisher();
      this.updateHandler = this.update.bind(this);
      this.realTimeSub = ConsumerSubject.create(this.bus.getSubscriber().on("realTime"), 0);
      this.updateTimer = null;
      this.lastUpdateTime = 0;
      this.throttleInfos = throttleInfos.map((info) => {
        return Object.assign(Object.assign({}, info), { throttleSimVar: `GENERAL ENG THROTTLE LEVER POSITION:${info.index}`, thrustSimVar: `TURB ENG JET THRUST:${info.index}`, n1SimVar: `TURB ENG N1:${info.index}`, correctedN1SimVar: `TURB ENG CORRECTED N1:${info.index}`, fadecModeTopic: `fadec_mode_${info.index}` });
      });
      this.lastModes = this.throttleInfos.map(() => null);
      const sub = this.bus.getSubscriber();
      this.throttleLeverPositionValues = throttleInfos.map((info) => {
        return ConsumerValue.create(sub.on(info.leverPosTopic), 0);
      });
      this.engineStates = {};
      for (const throttle of throttleInfos) {
        this.engineStates[throttle.index] = {
          throttleLeverPos: 0,
          throttle: 0,
          thrust: 0,
          n1: 0,
          n1Corrected: 0
        };
      }
    }
    /**
     * Turns this FADEC on. If this FADEC is already running, then it will be turned off before turning on again with
     * the specified frequency.
     * @param frequency The frequency, in hertz, at which this FADEC will update.
     */
    start(frequency) {
      this.stop();
      this.publisher.pub("fadec_active", true, true, true);
      this.updateTimer = setInterval(this.updateHandler, 1e3 / frequency);
    }
    /**
     * Turns this FADEC off.
     */
    stop() {
      if (this.updateTimer === null) {
        return;
      }
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      for (let i = 0; i < this.throttleInfos.length; i++) {
        this.setMode(i, null);
      }
      this.publisher.pub("fadec_active", false, true, true);
    }
    /**
     * Updates this FADEC.
     */
    update() {
      const realTime = Date.now();
      if (realTime - this.realTimeSub.get() >= 1e3) {
        return;
      }
      const dt = realTime - this.lastUpdateTime;
      this.onUpdate(dt);
      this.lastUpdateTime = realTime;
    }
    /**
     * A method called when this FADEC is updated.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    onUpdate(dt) {
      this.updateEngineStates();
      this.updateThrottles(dt);
    }
    /**
     * Updates the states for this FADEC's engines.
     */
    updateEngineStates() {
      for (let i = 0; i < this.throttleInfos.length; i++) {
        const info = this.throttleInfos[i];
        const state = this.engineStates[info.index];
        state.throttleLeverPos = this.throttleLeverPositionValues[i].get();
        state.throttle = SimVar.GetSimVarValue(info.throttleSimVar, SimVarValueType.Percent) / 100;
        state.thrust = SimVar.GetSimVarValue(info.thrustSimVar, SimVarValueType.Pounds);
        state.n1 = SimVar.GetSimVarValue(info.n1SimVar, SimVarValueType.Percent);
        state.n1Corrected = SimVar.GetSimVarValue(info.correctedN1SimVar, SimVarValueType.Percent);
      }
    }
    /**
     * Updates this FADEC's engine throttles.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateThrottles(dt) {
      for (let i = 0; i < this.throttleInfos.length; i++) {
        this.updateThrottle(i, dt);
      }
    }
    /**
     * Updates a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateThrottle(index, dt) {
      const info = this.throttleInfos[index];
      const { throttleLeverPos, throttle, thrust, n1, n1Corrected } = this.engineStates[info.index];
      let desiredThrottle = throttleLeverPos;
      let visibleThrottlePos = throttleLeverPos;
      for (let i = 0; i < this.modes.length; i++) {
        const mode = this.modes[i];
        if (mode.accept(info.index, throttleLeverPos, throttle, thrust, n1, n1Corrected)) {
          this.setMode(index, mode);
          desiredThrottle = mode.computeDesiredThrottle(info.index, throttleLeverPos, throttle, thrust, n1, n1Corrected, dt);
          visibleThrottlePos = mode.getVisibleThrottlePos(info.index, throttleLeverPos);
          break;
        }
      }
      SimVar.SetSimVarValue(info.throttleSimVar, SimVarValueType.Percent, MathUtils.clamp(desiredThrottle * 100, -100, 100));
      SimVar.SetSimVarValue(info.visiblePosSimVar, "number", MathUtils.clamp(visibleThrottlePos, -1, 1));
    }
    /**
     * Sets a FADEC mode for a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param mode The mode to set.
     */
    setMode(index, mode) {
      var _a;
      if (mode === this.lastModes[index]) {
        return;
      }
      this.lastModes[index] = mode;
      this.publisher.pub(this.throttleInfos[index].fadecModeTopic, (_a = mode === null || mode === void 0 ? void 0 : mode.name) !== null && _a !== void 0 ? _a : "", true, true);
    }
  };
  var ThrottleLeverManager = class {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param onInitCallback A callback function to be executed once this manager is initialized.
     * @param throttleLeverHandler A callback function which handles requested changes to throttle lever position. The
     * function should take three arguments: the index of the throttle lever, the current lever position (-1 to +1), and
     * the requested new lever position (-1 to +1), and return the position the lever should be set to. If not defined,
     * all requested changes to throttle lever position will be processed as-is.
     */
    constructor(bus, onInitCallback, throttleLeverHandler) {
      this.bus = bus;
      this.throttleLeverHandler = throttleLeverHandler;
      this.publisher = this.bus.getPublisher();
      this.throttleLevers = ArrayUtils.create(ThrottleLeverManager.THROTTLE_COUNT, (index) => {
        return {
          index: index + 1,
          topic: `v_throttle_lever_pos_${index + 1}`,
          rawPosition: 0
        };
      });
      const sub = bus.getSubscriber();
      const virtualPositions = this.throttleLevers.map((lever) => {
        return ConsumerValue.create(sub.on(lever.topic), NaN);
      });
      KeyEventManager.getManager(bus).then((manager) => {
        for (let i = 0; i < this.throttleLevers.length; i++) {
          const lever = this.throttleLevers[i];
          const virtualPosition = virtualPositions[i].get();
          const initialPosition = isNaN(virtualPosition) ? MathUtils.clamp(SimVar.GetSimVarValue(`GENERAL ENG THROTTLE LEVER POSITION:${lever.index}`, "Percent") / 100, 0, 1) : virtualPosition;
          virtualPositions[i].destroy();
          this.setRawThrottleLeverPosition(initialPosition * ThrottleLeverManager.RAW_MAX, i + 1);
        }
        this.keyEventManager = manager;
        manager.interceptKey("AXIS_THROTTLE_SET", false);
        manager.interceptKey("AXIS_THROTTLE1_SET", false);
        manager.interceptKey("AXIS_THROTTLE2_SET", false);
        manager.interceptKey("AXIS_THROTTLE3_SET", false);
        manager.interceptKey("AXIS_THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE1_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE2_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE3_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE4_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE_SET", false);
        manager.interceptKey("THROTTLE1_SET", false);
        manager.interceptKey("THROTTLE2_SET", false);
        manager.interceptKey("THROTTLE3_SET", false);
        manager.interceptKey("THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_FULL", false);
        manager.interceptKey("THROTTLE1_FULL", false);
        manager.interceptKey("THROTTLE2_FULL", false);
        manager.interceptKey("THROTTLE3_FULL", false);
        manager.interceptKey("THROTTLE4_FULL", false);
        manager.interceptKey("THROTTLE_INCR", false);
        manager.interceptKey("THROTTLE1_INCR", false);
        manager.interceptKey("THROTTLE2_INCR", false);
        manager.interceptKey("THROTTLE3_INCR", false);
        manager.interceptKey("THROTTLE4_INCR", false);
        manager.interceptKey("THROTTLE_DECR", false);
        manager.interceptKey("THROTTLE1_DECR", false);
        manager.interceptKey("THROTTLE2_DECR", false);
        manager.interceptKey("THROTTLE3_DECR", false);
        manager.interceptKey("THROTTLE4_DECR", false);
        manager.interceptKey("THROTTLE_CUT", false);
        manager.interceptKey("THROTTLE1_CUT", false);
        manager.interceptKey("THROTTLE2_CUT", false);
        manager.interceptKey("THROTTLE3_CUT", false);
        manager.interceptKey("THROTTLE4_CUT", false);
        manager.interceptKey("INCREASE_THROTTLE", false);
        manager.interceptKey("DECREASE_THROTTLE", false);
        manager.interceptKey("THROTTLE_10", false);
        manager.interceptKey("THROTTLE_20", false);
        manager.interceptKey("THROTTLE_30", false);
        manager.interceptKey("THROTTLE_40", false);
        manager.interceptKey("THROTTLE_50", false);
        manager.interceptKey("THROTTLE_60", false);
        manager.interceptKey("THROTTLE_70", false);
        manager.interceptKey("THROTTLE_80", false);
        manager.interceptKey("THROTTLE_90", false);
        sub.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        onInitCallback && onInitCallback();
      });
    }
    /**
     * Sets the position of a throttle lever.
     * @param index The index of the throttle lever to set, from 1 to 4, inclusive.
     * @param pos The position to set, in the range -1 to +1.
     * @returns The throttle lever position at the end of the operation, in the range -1 to +1.
     * @throws Error if `index` is out of bounds.
     */
    setThrottleLeverPos(index, pos) {
      return this.setThrottleLeverPosRaw(index, pos * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    /**
     * Changes the position of a throttle lever.
     * @param index The index of the throttle lever to change, from 1 to 4, inclusive.
     * @param delta The amount by which to change the lever position. The full lever range is expressed as -1 to +1.
     * @returns The throttle lever position at the end of the operation, in the range -1 to +1.
     * @throws Error if `index` is out of bounds.
     */
    changeThrottleLeverPos(index, delta) {
      return this.changeThrottleLeverPosRaw(index, delta * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    /**
     * Sets the raw position of a throttle lever.
     * @param index The index of the throttle lever to set, from 1 to 4, inclusive.
     * @param pos The raw position to set, in the range -16384 to +16384.
     * @returns The raw throttle lever position at the end of the operation, in the range -16384 to +16384.
     * @throws Error if `index` is out of bounds.
     */
    setThrottleLeverPosRaw(index, pos) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.setRawThrottleLeverPosition(pos, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    /**
     * Changes the raw position of a throttle lever.
     * @param index The index of the throttle lever to change, from 1 to 4, inclusive.
     * @param delta The amount by which to change the raw lever position. The full lever range is expressed as -16384 to
     * +16384.
     * @returns The raw throttle lever position at the end of the operation, in the range -16384 to +16384.
     * @throws Error if `index` is out of bounds.
     */
    changeThrottleLeverPosRaw(index, delta) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.changeRawThrottleLeverPosition(delta, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    /**
     * Responds to key intercept events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.value0 The value of the intercepted key event.
     */
    onKeyIntercepted({ key, value0 }) {
      switch (key) {
        case "AXIS_THROTTLE_SET":
        case "THROTTLE_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, void 0, key);
          }
          break;
        case "AXIS_THROTTLE1_SET":
        case "THROTTLE1_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 1, key);
          }
          break;
        case "AXIS_THROTTLE2_SET":
        case "THROTTLE2_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 2, key);
          }
          break;
        case "AXIS_THROTTLE3_SET":
        case "THROTTLE3_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 3, key);
          }
          break;
        case "AXIS_THROTTLE4_SET":
        case "THROTTLE4_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 4, key);
          }
          break;
        case "THROTTLE_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, void 0, key);
          }
          break;
        case "THROTTLE1_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 1, key);
          }
          break;
        case "THROTTLE2_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 2, key);
          }
          break;
        case "THROTTLE3_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 3, key);
          }
          break;
        case "THROTTLE4_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 4, key);
          }
          break;
        case "THROTTLE_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, void 0, key);
          break;
        case "THROTTLE1_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 1, key);
          break;
        case "THROTTLE2_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 2, key);
          break;
        case "THROTTLE3_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 3, key);
          break;
        case "THROTTLE4_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 4, key);
          break;
        case "THROTTLE_CUT":
          this.setRawThrottleLeverPosition(0, void 0, key);
          break;
        case "THROTTLE1_CUT":
          this.setRawThrottleLeverPosition(0, 1, key);
          break;
        case "THROTTLE2_CUT":
          this.setRawThrottleLeverPosition(0, 2, key);
          break;
        case "THROTTLE3_CUT":
          this.setRawThrottleLeverPosition(0, 3, key);
          break;
        case "THROTTLE4_CUT":
          this.setRawThrottleLeverPosition(0, 4, key);
          break;
        case "THROTTLE_INCR":
        case "INCREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_DECR":
        case "DECREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_10":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.1, void 0, key);
          break;
        case "THROTTLE_20":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.2, void 0, key);
          break;
        case "THROTTLE_30":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.3, void 0, key);
          break;
        case "THROTTLE_40":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.4, void 0, key);
          break;
        case "THROTTLE_50":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.5, void 0, key);
          break;
        case "THROTTLE_60":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.6, void 0, key);
          break;
        case "THROTTLE_70":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.7, void 0, key);
          break;
        case "THROTTLE_80":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.8, void 0, key);
          break;
        case "THROTTLE_90":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.9, void 0, key);
          break;
      }
    }
    /**
     * Sets a raw throttle lever position.
     * @param rawPosition The raw position to set.
     * @param index The index of the throttle lever to set. If undefined, the positions of all throttle levers will be
     * set.
     * @param keyEvent The key event responsible for this change, or `undefined` if this change was not triggered by a
     * key event.
     */
    setRawThrottleLeverPosition(rawPosition, index, keyEvent) {
      rawPosition = MathUtils.clamp(Math.round(rawPosition), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        const lever = this.throttleLevers[i - 1];
        if (this.throttleLeverHandler) {
          rawPosition = MathUtils.clamp(Math.round(this.throttleLeverHandler(lever.index, lever.rawPosition / ThrottleLeverManager.RAW_MAX, rawPosition / ThrottleLeverManager.RAW_MAX, keyEvent) * ThrottleLeverManager.RAW_MAX), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
        }
        if (rawPosition !== lever.rawPosition) {
          lever.rawPosition = rawPosition;
          this.publishThrottleLeverPosition(lever);
        }
      }
    }
    /**
     * Changes a raw throttle lever position.
     * @param delta The amount by which to change the raw lever position.
     * @param index The index of the throttle lever to change. If undefined, the positions of all throttle levers will be
     * changed.
     * @param keyEvent The key event responsible for this change, or `undefined` if this change was not triggered by a
     * key event.
     */
    changeRawThrottleLeverPosition(delta, index, keyEvent) {
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        this.setRawThrottleLeverPosition(this.throttleLevers[i - 1].rawPosition + delta, i, keyEvent);
      }
    }
    /**
     * Publishes a virtual throttle lever position to the event bus.
     * @param lever The lever whose position to publish.
     */
    publishThrottleLeverPosition(lever) {
      this.publisher.pub(lever.topic, lever.rawPosition / ThrottleLeverManager.RAW_MAX, true, true);
    }
  };
  ThrottleLeverManager.THROTTLE_COUNT = 4;
  ThrottleLeverManager.RAW_MAX = 16384;
  ThrottleLeverManager.RAW_STEP = 256;
  var DataInterface = class {
    /**
     * Constructs a new `ModifiableDataSource`
     *
     * @param input  an input for data
     * @param modify a callback when the data needs to be modified
     */
    constructor(input, modify) {
      this.input = input;
      this.modify = modify;
    }
    /** Creates a new DataInterface with a new modifier
     * @deprecated
     * @param modify the new modifier
     * @returns the new DataInterface
     */
    modifiable(modify) {
      return new DataInterface(this.input, modify);
    }
    /**
     * Creates a {@link DataInterface} from a {@link MutableSubscribable}
     * @param sub the {@link MutableSubscribable} to bind to
     * @returns the {@link DataInterface}
     */
    static fromMutSubscribable(sub) {
      return new DataInterface(sub, (value) => sub.set(value));
    }
    /**
     * Creates a {@link DataInterface} from a {@link Consumer}
     * @param consumer the {@link Consumer} to bind to (get)
     * @param modifier the modifier to use when the value is modified (set)
     * @returns the {@link DataInterface}
     */
    static fromConsumer(consumer, modifier) {
      return new DataInterface(consumer, (value) => modifier(value));
    }
  };
  var Binding = class {
    /**
     * Constructs a `Binding`
     *
     * @param input   a {@link DataSource} for the binding
     * @param valueHandler a handler for when the value changes from the `DataSource`
     * */
    constructor(input, valueHandler) {
      this.input = input;
      this.valueHandler = valueHandler;
      this.canInitialNotify = false;
      if ("isConsumer" in this.input) {
        this.sub = this.input.handle((data) => this.valueHandler(data));
      } else {
        this.canInitialNotify = true;
        this.sub = this.input.sub((data) => this.valueHandler(data), this.canInitialNotify, true);
      }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this binding is paused. */
    get isPaused() {
      return this.sub.isPaused;
    }
    /** @inheritDoc */
    get isAlive() {
      return this.sub.isAlive;
    }
    // /**
    //  * @param value
    //  */
    // private proxyValueHandler(value: T): void {
    //   this.valueHandler(this, value);
    // }
    /**
     * Stops the binding and cancels the handler.
     * @returns This binding, after it has been paused.
     */
    pause() {
      this.sub.pause();
      return this;
    }
    /**
     * Restarts the binding and re-instates the handler.
     * @returns This binding, after it has been resumed.
     */
    resume() {
      this.sub.resume(true);
      return this;
    }
    /**
     * Destroys this binding.
     */
    destroy() {
      this.sub.destroy();
    }
  };
  var TwoWayBinding = class extends Binding {
    /**
     * Constructs a new `TwoWayBinding`
     *
     * @param dataSource   a {@link DataInterface} for the binding
     * @param valueHandler a handler for when the value changes from the `DataSource`
     * @param valueEditor  a consumer for receiving new values to set using the source
     */
    constructor(dataSource, valueHandler, valueEditor) {
      super(dataSource.input, valueHandler);
      this.valueHandler = valueHandler;
      this.valueEditor = valueEditor;
      if ("isConsumer" in this.valueEditor) {
        this.editSub = this.valueEditor.handle(dataSource.modify, true);
      } else if (this.valueEditor instanceof SubEvent) {
        this.editSub = this.valueEditor.on((sender, data) => dataSource.modify(data));
      } else {
        this.editSub = this.valueEditor.sub(dataSource.modify, false, true);
      }
    }
    /** @inheritDoc */
    pause() {
      super.pause();
      this.editSub.pause();
      return this;
    }
    /** @inheritDoc */
    resume() {
      super.resume();
      this.editSub.resume();
      return this;
    }
    /** @inheritDoc */
    destroy() {
      super.destroy();
      this.editSub.destroy();
    }
  };
  var FmcComponent = class {
    /** @inheritDoc */
    constructor(page, options) {
      this.page = page;
      this.options = options;
    }
    /**
     * Invalidates the component and queues a re-render if one is not already queued
     */
    invalidate() {
      this.page.invalidate();
    }
    /** @inheritDoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async handleSelectKey(event) {
      var _a, _b;
      if (this.options.disabled) {
        return false;
      }
      if (event.isDelete) {
        if (this.options.onDelete) {
          const result = await this.options.onDelete();
          if (result === true || typeof result === "string") {
            if ((_a = this.options.clearScratchpadOnSelectedHandled) !== null && _a !== void 0 ? _a : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        }
      }
      if (this.options.onSelected) {
        try {
          const result = await this.options.onSelected(event.scratchpadContents);
          if (result === true || typeof result === "string") {
            if ((_b = this.options.clearScratchpadOnSelectedHandled) !== null && _b !== void 0 ? _b : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        } catch (error) {
          return Promise.reject(error);
        }
      }
      return this.onHandleSelectKey(event);
    }
    /**
     * Returns the component's options
     * @returns The options.
     */
    getOptions() {
      return this.options;
    }
  };
  var DisplayField = class extends FmcComponent {
    /** @inheritDoc */
    constructor(page, options) {
      super(page, options);
      this.options = options;
      this.value = null;
    }
    /**
     * Gets the raw value of this display field
     * @returns the value
     */
    get rawValue() {
      return this.value;
    }
    // /**
    //  * Creates an {@link DisplayField}
    //  *
    //  * @param page    the parent {@link FmcPage}
    //  * @param options parameters for the display field
    //  *
    //  * @returns the {@link DisplayField}
    //  */
    // public static create<T>(page: FmcPage, options: DisplayFieldOptions<T>): DisplayField<T> {
    //   return new DisplayField<T>(page, options);
    // }
    /**
     * Creates and registers a binding on the page, linking this field with a subscribable
     * @param subscribable the subscribable to bind to
     * @returns the created binding (usually not needed)
     */
    bind(subscribable) {
      const binding = new Binding(subscribable, (value) => this.takeValue(value, true));
      this.page.addBinding(binding);
      return this;
    }
    /**
     * Takes an input value, displays it and stores it
     * @param value the new input value
     * @param shouldInvalidate whether or not to invalidate the page
     */
    takeValue(value, shouldInvalidate = false) {
      this.value = value;
      if (shouldInvalidate) {
        this.invalidate();
      }
    }
    /** @inheritDoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onHandleSelectKey(event) {
      return false;
    }
    /** @inheritDoc */
    render() {
      var _a, _b;
      const renderStr = this.value !== null ? this.options.formatter.format(this.value) : this.options.formatter.nullValueString;
      const styleStr = typeof this.options.style === "function" ? this.options.style(this.value) : this.options.style;
      return `${(_a = this.options.prefix) !== null && _a !== void 0 ? _a : ""}${renderStr}${(_b = this.options.suffix) !== null && _b !== void 0 ? _b : ""}${styleStr !== null && styleStr !== void 0 ? styleStr : ""}`;
    }
  };
  var EditableField = class extends DisplayField {
    /** @inheritDoc */
    constructor(page, options) {
      super(page, options);
      this.page = page;
      this.options = options;
      this.valueChanged = new SubEvent();
    }
    /**
     * Binds the input field to a mutable subscribable.
     * @param subscribable the mutable subscribable
     * @returns the instance of this {@link EditableField}
     */
    bind(subscribable) {
      return this.bindSource(DataInterface.fromMutSubscribable(subscribable));
    }
    /**
     * Binds the input field to a Consumer.
     * @param consumer the consumer to bind to (get)
     * @param modifier the modifier to use when the value is modified (set)
     * @returns the instance of this {@link EditableField}
     */
    bindConsumer(consumer, modifier) {
      return this.bindSource(DataInterface.fromConsumer(consumer, modifier));
    }
    /**
     * Binds the input field to a data interface.
     * @param source the data interface
     * @returns the instance of this {@link EditableField}
     */
    bindSource(source) {
      const binding = new TwoWayBinding(source, (value) => this.takeValue(value, true), this.valueChanged);
      this.page.addBinding(binding);
      return this;
    }
  };
  var RawValidator = {
    /** @inheritDoc */
    parse(input) {
      return input !== null && input !== void 0 ? input : "";
    }
  };
  var RawFormatter = {
    nullValueString: "",
    /** @inheritDoc */
    format(value) {
      return value !== null && value !== void 0 ? value : "";
    }
  };
  var PageLinkField = class extends DisplayField {
    /** @inheritDoc */
    constructor(page, options) {
      var _a;
      const opts = {
        formatter: RawFormatter,
        style: options.disabled ? "[disabled]" : "",
        disabled: options.disabled,
        clearScratchpadOnSelectedHandled: false,
        onSelected: (_a = options.onSelected) !== null && _a !== void 0 ? _a : async () => {
          page.screen.navigateTo(options.route);
          return true;
        }
      };
      super(page, opts);
      this.takeValue(options.label);
    }
    /**
     * Creates an {@link PageLinkField}
     * @param page    the parent {@link FmcPage}
     * @param label  the label to display
     * @param route the route to navigate to (will disable link when empty)
     * @param disabled whether the link is disabled
     * @returns the {@link PageLinkField}
     */
    static createLink(page, label, route, disabled = false) {
      if (route === "") {
        disabled = true;
      }
      return new PageLinkField(page, { label, route, disabled });
    }
  };
  var SwitchLabel = class extends EditableField {
    /** @inheritDoc */
    constructor(page, options = {}) {
      super(page, Object.assign({
        formatter: RawFormatter,
        activeStyle: "green",
        caret: "none",
        separator: "slash"
      }, options));
      this.page = page;
    }
    /** @inheritDoc */
    render() {
      let string = "";
      if (this.value !== null) {
        for (let i = 0; i < this.options.optionStrings.length; i++) {
          const choice = this.options.optionStrings[i];
          string += choice;
          if (i === this.value) {
            string += `[${this.options.activeStyle} d-text]`;
          } else {
            string += "[s-text]";
          }
          if (i !== this.options.optionStrings.length - 1) {
            switch (this.options.separator) {
              case "slash":
                string += "/[d-text]";
                break;
              case "arrows":
                string += "\u2190\u2192[d-text]";
                break;
            }
          }
        }
        switch (this.options.caret) {
          case "left":
            string = `<${string}`;
            break;
          case "right":
            string = `${string}>`;
            break;
        }
      }
      return string;
    }
    /** @inheritDoc */
    async onHandleSelectKey() {
      if (this.value === null) {
        this.value = 0;
      } else {
        this.value = (this.value + 1) % this.options.optionStrings.length;
      }
      this.valueChanged.notify(this, this.value);
      this.invalidate();
      return true;
    }
  };
  var TextInputField = class extends EditableField {
    /** @inheritDoc */
    constructor(page, options) {
      super(page, options);
      this.options = options;
      if (this.options.onDelete === void 0) {
        this.options.onDelete = async () => {
          var _a;
          if ((_a = this.options.deleteAllowed) !== null && _a !== void 0 ? _a : true) {
            this.valueChanged.notify(this, null);
            this.page.screen.clearScratchpad();
            return true;
          } else {
            return Promise.reject("INVALID DELETE");
          }
        };
      }
    }
    /**
     * Creates an {@link TextInputField} that uses a {@link RawValidator} and {@link RawFormatter}
     * @param page the parent {@link FmcPage}
     * @returns the {@link TextInputField}
     */
    static createRawTextInput(page) {
      return new TextInputField(page, {
        formatter: Object.assign(Object.assign({}, RawFormatter), RawValidator)
      });
    }
    /** @inheritDoc */
    async onHandleSelectKey(event) {
      var _a, _b, _c, _d;
      if (event.isDelete === true) {
        if ((_a = this.options.deleteAllowed) !== null && _a !== void 0 ? _a : true) {
          this.valueChanged.notify(this, null);
          this.page.screen.clearScratchpad();
          return true;
        } else {
          return Promise.reject("INVALID DELETE");
        }
      }
      const parsedValue = await this.options.formatter.parse(event.scratchpadContents);
      if (parsedValue !== null) {
        if (this.options.onModified) {
          const onModifiedResult = await this.options.onModified(parsedValue);
          if (onModifiedResult === true || typeof onModifiedResult === "string") {
            if ((_b = this.options.clearScratchpadOnValueAccepted) !== null && _b !== void 0 ? _b : true) {
              this.page.screen.clearScratchpad();
            }
          } else {
            this.valueChanged.notify(this, parsedValue);
          }
          if (onModifiedResult === false) {
            if ((_c = this.options.clearScratchpadOnValueAccepted) !== null && _c !== void 0 ? _c : true) {
              this.page.screen.clearScratchpad();
            }
            return true;
          }
          return onModifiedResult;
        } else {
          this.valueChanged.notify(this, parsedValue);
          if ((_d = this.options.clearScratchpadOnValueAccepted) !== null && _d !== void 0 ? _d : true) {
            this.page.screen.clearScratchpad();
          }
          return true;
        }
      } else {
        return Promise.reject("INVALID ENTRY");
      }
    }
  };
  var ToggleLabel = class extends EditableField {
    /** @inheritDoc */
    constructor(page, options = {}) {
      const opts = Object.assign({
        formatter: RawFormatter,
        activeStyle: "green"
      }, options);
      super(page, opts);
    }
    /** @inheritDoc */
    render() {
      var _a;
      const value = this.value;
      return `${value && this.options.text[1] !== void 0 ? this.options.text[1] : this.options.text[0]}[${value ? `${(_a = this.options.activeStyle) !== null && _a !== void 0 ? _a : "green"} d-text` : "s-text"}]`;
    }
    /** @inheritDoc */
    async onHandleSelectKey() {
      this.value = !this.value;
      this.valueChanged.notify(this, this.value);
      this.invalidate();
      return true;
    }
  };
  var FmcPageLifecyclePolicy;
  (function(FmcPageLifecyclePolicy2) {
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Singleton"] = 0] = "Singleton";
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Transient"] = 1] = "Transient";
  })(FmcPageLifecyclePolicy || (FmcPageLifecyclePolicy = {}));
  var AbstractFmcPage = class {
    /**
     * Ctor
     * @param bus the event bus
     * @param screen the FMC screen instance
     */
    constructor(bus, screen) {
      this.bus = bus;
      this.screen = screen;
      this.memorizedComponents = [];
      this.bindings = [];
      this.params = /* @__PURE__ */ new Map();
      this.isDirty = false;
      this.clockHandler = (d) => {
        if (this.isDirty) {
          this.isDirty = false;
          this.initialRender();
        }
      };
      this.isInitialized = false;
      this.currentOutput = [];
      this.screen = screen;
      this.clockConsumer = this.bus.getSubscriber().on("realTime").atFrequency(10, false);
    }
    /**
     * Initializes the page.
     *
     * Use this for setting up subscriptions and such.
     */
    init() {
      this.onInit();
      this.addBinding(new Binding(this.screen.currentSubpageIndex, () => this.invalidate()));
    }
    /**
     * Init lifecycle hook
     */
    onInit() {
    }
    /**
     * Pauses the page and calls appropriate event handlers
     */
    pause() {
      for (const binding of this.bindings) {
        binding.pause();
      }
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      this.onPause();
    }
    /**
     * Pause lifecycle hook
     */
    onPause() {
    }
    /**
     * Resumes the page and calls appropriate event handlers
     */
    resume() {
      for (const binding of this.bindings) {
        binding.resume(true);
      }
      this.onResume();
      this.isDirty = true;
      this.clockConsumer.handle(this.clockHandler);
    }
    /**
     * Resume lifecycle hook
     */
    onResume() {
    }
    /** Is called when the page button for the current page is pressed while already on that page. */
    onPageButtonPressed() {
    }
    /**
     * Destroys the page and calls appropriate event handlers
     */
    destroy() {
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      for (const binding of this.bindings) {
        binding.destroy();
      }
      this.onDestroy();
    }
    /**
     * Destroy lifecycle hook
     */
    onDestroy() {
    }
    /**
     * Invalidates the render and sets the component into the dirty state
     */
    invalidate() {
      this.isDirty = true;
    }
    /**
     * Initial render function
     */
    initialRender() {
      if (!this.isInitialized) {
        return;
      }
      const templates = this.render();
      this.screen.currentSubpageCount.set(templates.length);
      const template = templates[this.screen.currentSubpageIndex.get() - 1];
      const render = [];
      this.memorizedComponents.length = 0;
      for (let i = 0; i < template.length; i++) {
        if (!render[i]) {
          render[i] = [];
        }
        const row = template[i];
        const renderRow = render[i];
        for (let j = 0; j < row.length; j++) {
          const col = row[j];
          if (col instanceof FmcComponent) {
            if (!this.memorizedComponents[i]) {
              this.memorizedComponents[i] = [null, null, null];
            }
            this.memorizedComponents[i][j] = col;
            const componentRender = col.render();
            if (Array.isArray(componentRender)) {
              for (let k = 0; k < componentRender.length; k++) {
                const componentRenderRow = componentRender[k];
                for (let l = 0; l < componentRenderRow.length; l++) {
                  if (!render[i + k]) {
                    render[i + k] = [];
                  }
                  render[i + k][l] = componentRenderRow[l];
                }
              }
            } else {
              renderRow[row.indexOf(col)] = componentRender;
            }
          } else {
            renderRow[j] = col;
          }
        }
      }
      this.currentOutput = render;
      this.renderCallback(this.currentOutput, template, 0);
    }
    /**
     * Registers a binding on the page
     *
     * @param binding a {@link Binding}
     */
    addBinding(binding) {
      this.bindings.push(binding);
    }
    /**
     * Handles a line select key recieved by the FMC, before passing it on to components
     *
     * @param event the LSK event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async handleLineSelectKey(event) {
      var _a;
      const componentAtSk = (_a = this.memorizedComponents[event.row]) === null || _a === void 0 ? void 0 : _a[event.col];
      if (componentAtSk) {
        const selectKeyHandled = await componentAtSk.handleSelectKey(event);
        if (selectKeyHandled !== false) {
          return selectKeyHandled;
        }
      }
      const handledByPage = await this.onHandleSelectKey(event);
      if (!handledByPage) {
        return Promise.reject("KEY NOT ACTIVE");
      }
      return handledByPage;
    }
    /**
     * Handles a line select key recieved by the FMC, before passing it on to components
     *
     * @param event the LSK event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onHandleSelectKey(event) {
      return false;
    }
    /**
     * Handles a scrolling event recieved by the FMC, before passing it on to components
     *
     * @param event the scrolling event
     */
    async handleScrolling(event) {
      return this.onHandleScrolling(event);
    }
    /**
     * Handles a scrolling event recieved by the FMC, before passing it on to components
     *
     * @param event the scrolling event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onHandleScrolling(event) {
      return false;
    }
  };
  AbstractFmcPage.lifecyclePolicy = FmcPageLifecyclePolicy.Singleton;
  var FmcListUtility = class {
    /**
     * FMC List Utility Class
     * @param page                  The Fmc Page
     * @param data                  The row input data (SubscribableArray<T>)
     * @param renderRow             Function to call when the list needs to be re-rendered with new data
     * @param size                  row count of the list per page
     * @param firstPageSize         row count of the first page of the list
     */
    constructor(page, data, renderRow, size = 5, firstPageSize = void 0) {
      this.page = page;
      this.data = data;
      this.renderRow = renderRow;
      this.size = size;
      this.firstPageSize = firstPageSize;
    }
    /**
     * Returns a rendered list page for a specified page
     * @param page The page number to render
     * @returns The FmcRenderTemplate
     */
    renderList(page) {
      const rows = [];
      let startIndex = (page - 1) * this.size;
      if (this.firstPageSize !== void 0 && page > 1) {
        startIndex = this.firstPageSize + (page - 2) * this.size;
      }
      for (let i = startIndex; i < startIndex + this.size; i++) {
        const prevData = this.data.tryGet(i - 1);
        const data = this.data.tryGet(i);
        const nextData = this.data.tryGet(i + 1);
        const subRows = this.renderRow(this.page, i - startIndex, prevData, data, nextData);
        subRows.forEach((row) => rows.push(row));
      }
      return rows;
    }
    /**
     * Handles when the Select Key is pressed.
     * @param event The Select Key Event.
     * @returns Whether the event was handled by this component.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async handleSelectKey(event) {
      return false;
    }
  };
  var FmcPageFactory = class {
  };
  var FmcRouter = class {
    constructor() {
      this.routes = {};
      this.currentRoute = Subject.create("/");
      this.currentSubpageIndex = Subject.create(1);
      this.currentSubpageCount = Subject.create(1);
    }
    /**
     * Adds a route to the router
     *
     * @param route the route string
     * @param page the target page constructor
     */
    addRoute(route, page) {
      this.routes[route] = page;
    }
    /**
     * Gets the associated page (or undefined) for a route
     *
     * @param routeString the route string
     *
     * @returns the associated page
     */
    getPageForRoute(routeString) {
      return this.routes[routeString.split("#", 2)[0].trim()];
    }
    /**
     * Gets the associated subpage index (after the hash) or 1 by default
     *
     * @param routeString the route string
     *
     * @returns the associated subpage index
     */
    getSubpageForRoute(routeString) {
      var _a;
      return parseInt((_a = routeString.split("#", 2)[1]) !== null && _a !== void 0 ? _a : "1");
    }
    /**
     * Moves to the previous subpage if there is one available
     *
     * @returns whether or not the subpage was changed
     */
    prevSubpage() {
      const currentIndex = this.currentSubpageIndex.get();
      if (currentIndex === 1) {
        this.currentSubpageIndex.set(this.currentSubpageCount.get());
      } else {
        this.currentSubpageIndex.set(currentIndex - 1);
      }
      return true;
    }
    /**
     * Moves to the next subpage if there is one available
     *
     * @returns whether or not the subpage was changed
     */
    nextSubpage() {
      const currentIndex = this.currentSubpageIndex.get();
      if (currentIndex >= this.currentSubpageCount.get()) {
        this.currentSubpageIndex.set(1);
      } else {
        this.currentSubpageIndex.set(currentIndex + 1);
      }
      return true;
    }
    /**
     * Moves to the specified subpage if there is one available
     *
     * @param index Desired subpage index (1-based)
     *
     * @returns whether or not the subpage was changed
     */
    setSubpage(index) {
      const currentIndex = this.currentSubpageIndex.get();
      if (index < 1 || index > this.currentSubpageCount.get() || currentIndex === index) {
        return false;
      }
      this.currentSubpageIndex.set(index);
      return true;
    }
  };
  var FmcScratchpad = class {
    /**
     * Ctor
     * @param bus the event bus
     * @param options the options
     * @param renderCallback the render callback
     */
    constructor(bus, options, renderCallback) {
      this.bus = bus;
      this.renderCallback = renderCallback;
      this.options = {
        cellWidth: 16,
        style: "white d-text",
        deleteText: "DELETE",
        surroundingText: ["", ""],
        errorTextCentered: false
      };
      this.contents = Subject.create("");
      this.errorContents = Subject.create("");
      this.renderedText = Subject.create("");
      this.isInDelete = Subject.create(false);
      Object.assign(this.options, options);
      MappedSubject.create(this.contents, this.errorContents, this.isInDelete).sub(() => this.renderText());
    }
    /**
     * Appends a string on the scratchpad
     * @param char the string to append
     */
    typeContents(char) {
      this.isInDelete.set(false);
      this.clearError();
      const contents = this.contents.get();
      this.contents.set(`${contents}${char}`);
    }
    /**
     * Deletes the last character on the scratchpad
     */
    backspace() {
      this.clearError();
      const contents = this.contents.get();
      this.contents.set(contents.substring(0, Math.max(0, contents.length - 1)));
    }
    /**
     * Clears the scratchpad
     */
    clear() {
      this.clearError();
      this.delete(false);
      this.contents.set("");
    }
    /**
     * Clears the scratchpad error
     */
    clearError() {
      this.errorContents.set("");
    }
    /**
     * Sets the scratchpad in DELETE mode (or not)
     *
     * @param value optional value to force, otherwise the value is set to `true`
     */
    delete(value) {
      this.clearError();
      this.isInDelete.set(value !== null && value !== void 0 ? value : !this.isInDelete.get());
    }
    /**
     * Renders the scratchpad and sets the subject
     */
    renderText() {
      const surroundingTextWidth = this.options.surroundingText[0].length + this.options.surroundingText[1].length;
      const spaceToPadTo = this.options.cellWidth - surroundingTextWidth;
      let renderText;
      if (this.isInDelete.get()) {
        renderText = this.options.deleteText;
      } else if (this.errorContents.get()) {
        const errorContents = this.errorContents.get();
        const leftPad = "\xA0".repeat(Math.floor((spaceToPadTo - errorContents.length) / 2));
        const rightPad = "\xA0".repeat(Math.ceil((spaceToPadTo - errorContents.length) / 2));
        renderText = `${leftPad}${errorContents}${rightPad}`;
      } else {
        renderText = this.contents.get().padEnd(spaceToPadTo, "\xA0");
      }
      const leftText = this.options.surroundingText[0];
      const rightText = this.options.surroundingText[1];
      const styleString = this.options.style ? `[${this.options.style}]` : "";
      this.renderedText.set(`${leftText}${renderText}${styleString}${rightText}`);
    }
  };
  var FmcScreen = class {
    /**
     * Ctor
     * @param bus the event bus
     * @param pageFactory the page factory to be used for creating FMC pages for this screen
     * @param options the screen options
     * @param renderer the renderer to use for this screen
     * @param scratchpad the scratchpad to use for this screen
     */
    constructor(bus, pageFactory, options, renderer, scratchpad) {
      this.bus = bus;
      this.pageFactory = pageFactory;
      this.renderer = renderer;
      this.scratchpad = scratchpad;
      this.router = new FmcRouter();
      this.pageInstanceCache = /* @__PURE__ */ new Map();
      this.options = {
        screenDimensions: {
          cellWidth: 24,
          cellHeight: 12
        },
        enableScratchpad: true,
        eventPrefix: ""
      };
      this.currentlyDisplayedPage = null;
      Object.assign(this.options, options);
      if (this.options.enableScratchpad) {
        this.scratchpad.renderedText.sub((text) => {
          this.renderer.editOutputTemplate([[text]], this.options.screenDimensions.cellHeight - 1);
        });
      }
    }
    /**
     * Gets the current route
     *
     * @returns a string subject
     */
    get currentRoute() {
      return this.router.currentRoute;
    }
    /**
     * Gets the current subpage index for the current displayed page
     *
     * @returns a number
     */
    get currentSubpageIndex() {
      return this.router.currentSubpageIndex;
    }
    /**
     * Gets the current number of subpages for the current displayed page
     *
     * @returns a number
     */
    get currentSubpageCount() {
      return this.router.currentSubpageCount;
    }
    /**
     * Navigates to a given route and displays the associated page, if available
     *
     * @param route the route
     * @param params the parameters to pass to the page
     */
    navigateTo(route, params) {
      const pageCtor = this.router.getPageForRoute(route);
      if (pageCtor) {
        this.router.currentRoute.set(route);
        let instance;
        if (pageCtor.lifecyclePolicy === FmcPageLifecyclePolicy.Singleton) {
          const existingInstance = this.pageInstanceCache.get(pageCtor);
          instance = existingInstance !== null && existingInstance !== void 0 ? existingInstance : this.instantiatePage(pageCtor);
          this.pageInstanceCache.set(pageCtor, instance);
        } else {
          instance = this.instantiatePage(pageCtor);
        }
        if (this.currentlyDisplayedPage) {
          this.currentlyDisplayedPage.pause();
        }
        this.currentlyDisplayedPage = instance;
        instance.params.clear();
        if (params) {
          for (const key of Object.keys(params)) {
            instance.params.set(key, params[key]);
          }
        }
        if (!instance.isInitialized) {
          instance.init();
        }
        this.router.currentSubpageCount.set(instance.render().length);
        this.router.setSubpage(this.router.getSubpageForRoute(route));
        instance.isInitialized = true;
        instance.resume();
      }
    }
    /**
     * Clears the scratchpad, if applicable
     */
    clearScratchpad() {
      this.scratchpad.clear();
    }
    /**
     * Declares a route for a page class
     *
     * @param route the route to set
     * @param page the page to associate with it
     * @param routeEvent the event to associate with it
     */
    addPageRoute(route, page, routeEvent) {
      this.router.addRoute(route, page);
      if (routeEvent) {
        this.bus.getSubscriber().on(`${this.options.eventPrefix}${routeEvent}`).handle(() => {
          var _a;
          if (this.currentRoute.get() === route) {
            (_a = this.currentlyDisplayedPage) === null || _a === void 0 ? void 0 : _a.onPageButtonPressed();
          } else {
            this.navigateTo(route);
          }
        });
      }
    }
    /**
     * Adds a list of LSK events bound to certain positions on the rendering grid
     *
     * @param array the LSK events and their positions
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    addLskEvents(array) {
      for (const lsk of array) {
        this.bus.getSubscriber().on(`${this.options.eventPrefix}${lsk[0]}`).handle(() => {
          this.handleLineSelectKey(lsk[1], lsk[2]);
        });
      }
    }
    /**
     * Adds paging events bound the page slewing
     *
     * @param events the events to bind
     */
    addPagingEvents(events) {
      const subs = this.bus.getSubscriber();
      events.pageLeft && subs.on(`${this.options.eventPrefix}${events.pageLeft}`).handle(() => this.handlePagingKey("pageLeft"));
      events.pageRight && subs.on(`${this.options.eventPrefix}${events.pageRight}`).handle(() => this.handlePagingKey("pageRight"));
      events.pageUp && subs.on(`${this.options.eventPrefix}${events.pageUp}`).handle(() => this.handlePagingKey("pageUp"));
      events.pageDown && subs.on(`${this.options.eventPrefix}${events.pageDown}`).handle(() => this.handlePagingKey("pageDown"));
    }
    /**
     * Returns a consumer for an event prefixed for this particular screen.
     * @param event The event to subscribe to.
     * @returns A consumer for an event prefixed for this particular screen.
     * */
    onPrefixedEvent(event) {
      return this.bus.getSubscriber().on(`${this.options.eventPrefix}${event}`);
    }
    /**
     * Instantiates a page for this screen
     *
     * @param page the page constructor
     *
     * @returns the created page
     */
    instantiatePage(page) {
      return this.pageFactory.createPage(page, this.bus, this, this.acceptPageOutput.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    acceptPageOutput(output, template, atRowIndex) {
      const rows = [...output];
      for (let i = rows.length; i < this.renderer.options.screenCellHeight - 2; i++) {
        rows.push([""]);
      }
      this.renderer.editOutputTemplate(rows, atRowIndex);
      if (this.options.enableScratchpad) {
        this.renderer.editOutputTemplate([[this.scratchpad.renderedText.get()]], this.options.screenDimensions.cellHeight - 1);
      }
    }
    /**
     * Handles a line select key recieved by the FMC, before passing it on to pages
     *
     * @param row the row of the LSK
     * @param col the side of the lSK (0 or 1)
     */
    handleLineSelectKey(row, col) {
      if (this.currentlyDisplayedPage) {
        const event = {
          row,
          col,
          scratchpadContents: this.scratchpad.contents.get(),
          isDelete: this.scratchpad.isInDelete.get()
        };
        this.currentlyDisplayedPage.handleLineSelectKey(event).then((returnValue) => {
          if (typeof returnValue === "string") {
            this.scratchpad.contents.set(returnValue);
          } else if (!returnValue) {
            this.onLineSelectKeyUnhandled(event);
          }
        }).catch((error) => this.onLineSelectKeyError(error));
      }
    }
    /**
     * Called when an LSK event is not handled by any code. Does nothing unless overridden.
     *
     * @param selectKeyEvent the LSK event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLineSelectKeyUnhandled(selectKeyEvent) {
    }
    /**
     * Called when an LSK error is thrown. Sets `this.scratchpad.errorContents` (if error is a string; otherwise throws) by default.
     *
     * @param error the LSK error
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLineSelectKeyError(error) {
      if (typeof error === "string") {
        this.scratchpad.errorContents.set(error);
      } else {
        console.error(`Unhandled error in LSK handler: ${error}`);
      }
    }
    /**
     * Handles a paging key recieved by the FMC
     *
     * @param event the paging key event
     */
    async handlePagingKey(event) {
      var _a;
      const handledByPage = await ((_a = this.currentlyDisplayedPage) === null || _a === void 0 ? void 0 : _a.handleScrolling(event));
      if (handledByPage) {
        return;
      }
      if (event === "pageLeft") {
        this.router.prevSubpage();
      }
      if (event === "pageRight") {
        this.router.nextSubpage();
      }
    }
  };
  var SimpleFmcRenderer = class {
    /**
     * Ctor
     * @param eventBus The event bus.
     * @param targetElement The target element of the renderer.
     * @param options The options for the renderer.
     */
    constructor(eventBus, targetElement, options) {
      var _a;
      this.targetElement = targetElement;
      this.options = options;
      this.currentOutput = [];
      this.columnData = [];
      this.prevColumnData = [];
      this.hasChanges = false;
      this.colElArr = [];
      this.colElNodeArr = [];
      this.rowElArr = [];
      this.containerTemplate = this.createContainerTemplate();
      this.columnData = this.createColumnInformation();
      this.prevColumnData = this.createColumnInformation();
      this.containerRef = this.targetElement;
      this.initializeContainer();
      this.clockConsumer = eventBus.getSubscriber().on("realTime").atFrequency((_a = this.options.updateFrequency) !== null && _a !== void 0 ? _a : 10, false);
      this.clockConsumer.handle(this.onClockUpdate.bind(this));
    }
    /** Initializes the container we will render to. */
    initializeContainer() {
      const container = this.containerTemplate.cloneNode(true);
      this.containerRef.replaceWith(container);
      this.containerRef = container;
      for (let r = 0; r < this.options.screenCellHeight; r++) {
        const rowEl = this.containerRef.childNodes[r];
        this.rowElArr.push(rowEl);
        const colArr = [];
        const colNodeArr = [];
        for (let c = 0; c < this.options.screenCellWidth; c++) {
          const colEl = rowEl.childNodes[c + 1];
          colArr.push(colEl);
          colNodeArr.push(colEl.firstChild);
        }
        this.colElArr.push(colArr);
        this.colElNodeArr.push(colNodeArr);
      }
    }
    /** Handles the clock update event. */
    onClockUpdate() {
      if (this.hasChanges) {
        this.hasChanges = false;
        this.renderToDom();
      }
    }
    /**
     * Edits part of the row output
     * @param output the output to insert
     * @param rowIndex the row index to insert at
     * @throws if `rowIndex` is too high
     */
    editOutputTemplate(output, rowIndex) {
      const rowsAvailable = this.options.screenCellHeight - rowIndex;
      if (rowsAvailable <= 0 || rowsAvailable < output.length) {
        throw new Error(`[FmcRenderer](editTemplate) Tried to write ${output.length - rowsAvailable} too many rows.`);
      }
      for (let i = rowIndex, c = 0; i < rowIndex + rowsAvailable && output[c]; i++, c++) {
        if (this.currentOutput[i] !== output[c]) {
          this.currentOutput[i] = output[c];
          this.hasChanges = true;
        }
      }
    }
    /** Renders the current template */
    renderToDom() {
      this.columnData = this.createColumnInformation();
      for (let index = 0; index < this.options.screenCellHeight; index++) {
        this.buildRowInfo(this.currentOutput[index], index);
      }
      for (let r = 0; r < this.options.screenCellHeight; r++) {
        for (let c = 0; c < this.options.screenCellWidth; c++) {
          const colData = this.columnData[r][c];
          const prevColData = this.prevColumnData[r][c];
          if (colData.content !== prevColData.content || colData.styles !== prevColData.styles) {
            if (colData.content !== prevColData.content) {
              const colNodeEl = this.colElNodeArr[r][c];
              colNodeEl.nodeValue = colData.content;
            }
            if (colData.styles !== prevColData.styles) {
              const colEl = this.colElArr[r][c];
              colEl.className = `fmc-letter ${colData.styles}`;
            }
          }
        }
      }
      this.prevColumnData = this.columnData;
    }
    /**
     * Parse row templates and build the column information.
     * @param template the template to parse
     * @param rowIndex the row index
     */
    buildRowInfo(template, rowIndex) {
      if (rowIndex < this.options.screenCellHeight && template) {
        if (template[0] !== "") {
          this.buildColumnInformation(template[0], rowIndex, "left");
        }
        if (template[1] && template[1] !== "") {
          this.buildColumnInformation(template[1], rowIndex, "right");
        }
        if (template[2] && template[2] !== "") {
          this.buildColumnInformation(template[2], rowIndex, "center");
        }
      }
    }
    /**
     * Builds the data struct for the row's columns.
     * @param templateRowColumn template
     * @param rowIndex the row index
     * @param dir direction
     */
    buildColumnInformation(templateRowColumn, rowIndex, dir = "left") {
      const content = this.parseContent(templateRowColumn);
      let charCount = 0;
      content.forEach((x) => {
        var _a, _b;
        charCount += (_b = (_a = x.content) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      });
      charCount = Math.min(charCount, this.options.screenCellWidth);
      let charIndex = 0;
      if (dir === "right") {
        charIndex = this.options.screenCellWidth - charCount;
      } else if (dir == "center") {
        charIndex = Math.round((this.options.screenCellWidth - 1) / 2 - charCount / 2);
      }
      const row = this.columnData[rowIndex];
      content.forEach((x) => {
        const letters = x.content.split("");
        letters.forEach((c) => {
          if (charIndex >= this.options.screenCellWidth) {
            return;
          }
          const colInfo = row[charIndex];
          colInfo.styles = x.styles;
          colInfo.content = c === "" ? " " : c;
          charIndex++;
        });
      });
    }
    /**
     * Parses content into intermediate information blocks
     * @param content the content to parse
     * @returns a list of information blocks
     */
    parseContent(content) {
      const resultInfo = [];
      if (content.startsWith("[")) {
        return resultInfo;
      }
      const regex = /([^\[\]\n]+)(\[[^\[\]\n]+\])*/g;
      let match = regex.exec(content);
      if (match) {
        while (match != null) {
          const el = {
            content: match[1].replace("__LSB", "[").replace("__RSB", "]"),
            styles: ""
          };
          if (match[2]) {
            const classes = match[2].match(/[^\s\[\]]+/g);
            if (classes) {
              el.styles = classes.join(" ");
            }
          }
          resultInfo.push(el);
          match = regex.exec(content);
        }
      }
      return resultInfo;
    }
    /**
     * Builds the template for the whole container.
     * @param defaultAlternatingLayout if the rows should alternate
     * @returns the container template
     */
    createContainerTemplate(defaultAlternatingLayout = true) {
      const container = document.createElement("div");
      container.id = "fmc-container";
      this.colTemplate = this.createColumnTemplate();
      this.rowTemplate = this.createRowTemplate();
      for (let r = 0; r < this.options.screenCellHeight; r++) {
        const row = this.rowTemplate.cloneNode(true);
        if (defaultAlternatingLayout && r % 2 == 1) {
          row.classList.remove("d-text");
          row.classList.add("s-text");
        }
        container.appendChild(row);
      }
      return container;
    }
    /**
     * Builds the template for a single row.
     * @returns the row template
     */
    createRowTemplate() {
      const rowTemplate = document.createElement("div");
      rowTemplate.classList.add("fmc-row");
      rowTemplate.classList.add("d-text");
      const cellHeight = this.options.screenPXHeight / this.options.screenCellHeight;
      rowTemplate.style.height = `${cellHeight}px`;
      rowTemplate.style.lineHeight = `${cellHeight}px`;
      const cellWidth = this.options.screenPXWidth / this.options.screenCellWidth;
      const lostDecimalWidth = cellWidth - Math.trunc(cellWidth);
      const paddingElemLeft = document.createElement("span");
      paddingElemLeft.style.width = `${Math.ceil(lostDecimalWidth * this.options.screenCellWidth / 2)}px`;
      paddingElemLeft.style.display = "inline-block";
      rowTemplate.appendChild(paddingElemLeft);
      for (let c = 0; c < this.options.screenCellWidth; c++) {
        const col = this.colTemplate.cloneNode(true);
        rowTemplate.appendChild(col);
      }
      return rowTemplate;
    }
    /**
     * Builds the template for a single column.
     * @returns the column template
     */
    createColumnTemplate() {
      const colEl = document.createElement("div");
      colEl.classList.add("fmc-letter");
      colEl.style.width = `${this.options.screenPXWidth / this.options.screenCellWidth}px`;
      colEl.style.height = `${this.options.screenPXHeight / this.options.screenCellHeight}px`;
      colEl.style.lineHeight = `${this.options.screenPXHeight / this.options.screenCellHeight}px`;
      colEl.textContent = " ";
      return colEl;
    }
    /**
     * Builds the data structure representing the content and looks.
     * @returns the data structure
     */
    createColumnInformation() {
      const columnInformation = [];
      for (let r = 0; r < this.options.screenCellHeight; r++) {
        const rowColumns = [];
        for (let c = 0; c < this.options.screenCellWidth; c++) {
          const colInfo = {
            content: " ",
            styles: ""
          };
          rowColumns.push(colInfo);
        }
        columnInformation.push(rowColumns);
      }
      return columnInformation;
    }
  };
  var ImageCache = class {
    /**
     * Loads the image from the url and adds it to the cache.
     * @static
     * @param key The image key to access it later.
     * @param url The url to load the image from.
     */
    static addToCache(key, url) {
      if (this.cache[key] === void 0) {
        const img = new Image();
        img.src = url;
        this.cache[key] = img;
      }
    }
    /**
     * Gets a cached image element.
     * @static
     * @param key The key of the cached image.
     * @returns The cached image element.
     */
    static get(key) {
      return this.cache[key];
    }
  };
  ImageCache.cache = {};
  var SVGUtils = class {
    /**
     * Creates an arc using an SVG path.
     * From https://stackoverflow.com/questions/5736398/how-to-calculate-the-svg-path-for-an-arc-of-a-circle
     * @param x Arc center x position.
     * @param y Arc center y position.
     * @param radius Arc radius.
     * @param startAngle Arc start angle.
     * @param endAngle Arc end angle.
     * @returns The d value for and SVG path element.
     */
    static describeArc(x, y, radius, startAngle, endAngle) {
      const start = polarToCartesian(x, y, radius, endAngle);
      const end = polarToCartesian(x, y, radius, startAngle);
      const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
      const d = [
        "M",
        start[0],
        start[1],
        "A",
        radius,
        radius,
        0,
        largeArcFlag,
        0,
        end[0],
        end[1]
      ].join(" ");
      return d;
    }
  };
  function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    const angleInRadians = (angleInDegrees - 90) * Math.PI / 180;
    return new Float64Array([
      centerX + radius * Math.cos(angleInRadians),
      centerY + radius * Math.sin(angleInRadians)
    ]);
  }
  var DmsFormatter2 = class {
    /**
     * Creates a function which formats angles, expressed as numeric values, to strings. The formatting behavior of
     * the function is defined by a specified format template. For more information on format templates and their syntax,
     * please refer to the {@link DmsFormatter2} class documentation.
     * @param format A template defining how the function formats angles.
     * @param unit The unit type in which the input angle values are expressed.
     * @param precision The precision of the formatter, in the unit type defined by the `unit` argument. Input values
     * will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be
     * taken to mean infinite precision (i.e. no rounding will take place).
     * @param nanString The string to output when the input angle is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats angles, expressed as numeric values, to strings.
     */
    static create(format, unit, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format, precision, unit);
      return (angle) => {
        if (isNaN(angle)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle, unit), "");
      };
    }
    /**
     * Creates a function which formats angles, expressed as {@link NumberUnitInterface} objects, to strings. The
     * formatting behavior of the function is defined by a specified format template. For more information on format
     * templates and their syntax, please refer to the {@link DmsFormatter2} class documentation.
     * @param format A template defining how the function formats angles.
     * @param precision The precision of the formatter. Input values will be rounded to the nearest multiple of this
     * quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding
     * will take place).
     * @param nanString The string to output when the input angle is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats angles, expressed as {@link NumberUnitInterface} objects, to strings.
     */
    static createForNumberUnit(format, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format, precision.number, precision.unit);
      return (angle) => {
        if (angle.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle.number, angle.unit), "");
      };
    }
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns An output string builder which conforms to the specified format template.
     */
    static createBuilder(format, precision, precisionUnit) {
      const split = format.split(DmsFormatter2.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DmsFormatter2.FORMAT_REGEXP)) {
          return DmsFormatter2.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input angle according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns A function which generates a string from an input angle in milliseconds according to the rules defined
     * by the template fragment.
     */
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DmsFormatter2.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          // Matches the positive sign char ('+')
          posStringMatch,
          // Matches the string assigned to represent the positive sign
          negStringMatch
          // Matches the string assigned to represent the negative sign
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DmsFormatter2.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        // Matches unit chars to the left of the decimal point
        unitMatch,
        // Matches the unit char ('D', 'M', 'S', etc)
        leftOptionalMatch,
        // Matches the question mark just to the left of the decimal point
        rightMatch,
        // Matches the decimal point and all chars to the right
        rightForcedMatch,
        // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch
        // Matches unit chars to the right of the decimal point surrounded by parens
      ] = numericMatch;
      const unitInfo = DmsFormatter2.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (angle, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
      } : (angle, unit, epsilon) => {
        return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(angle), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (angle, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (angle, unit) => {
          const converted = convertFunc(angle, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (angle, unit) => {
          return formatLeftFunc(convertFunc(angle, unit, epsilon));
        };
      }
    }
  };
  DmsFormatter2.FORMAT_REGEXP = /({[^{}]*})/;
  DmsFormatter2.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DmsFormatter2.NUM_FRAGMENT_REGEXP = /^(([DMSdms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DmsFormatter2.NUM_FRAGMENT_UNIT_INFO = {
    ["d"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["m"]: { unit: UnitType.ARC_MIN, mod: 60 },
    ["s"]: { unit: UnitType.ARC_SEC, mod: 60 },
    ["D"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["M"]: { unit: UnitType.ARC_MIN, mod: Infinity },
    ["S"]: { unit: UnitType.ARC_SEC, mod: Infinity }
  };
  var DurationFormatter = class {
    /**
     * Creates a function which formats durations, expressed as numeric values, to strings. The formatting behavior of
     * the function is defined by a specified format template. For more information on format templates and their syntax,
     * please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param unit The unit type in which the input duration values are expressed.
     * @param precision The precision of the formatter, in the unit type defined by the `unit` argument. Input values
     * will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be
     * taken to mean infinite precision (i.e. no rounding will take place).
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as numeric values, to strings.
     */
    static create(format, unit, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format, precision, unit);
      return (duration) => {
        if (isNaN(duration)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration, unit), "");
      };
    }
    /**
     * Creates a function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings. The
     * formatting behavior of the function is defined by a specified format template. For more information on format
     * templates and their syntax, please refer to the {@link DurationFormatter} class documentation.
     * @param format A template defining how the function formats durations.
     * @param precision The precision of the formatter. Input values will be rounded to the nearest multiple of this
     * quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding
     * will take place).
     * @param nanString The string to output when the input duration is `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats durations, expressed as {@link NumberUnitInterface} objects, to strings.
     */
    static createForNumberUnit(format, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format, precision.number, precision.unit);
      return (duration) => {
        if (duration.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration.number, duration.unit), "");
      };
    }
    /**
     * Creates an output string builder from a format template.
     * @param format A format template.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns An output string builder which conforms to the specified format template.
     */
    static createBuilder(format, precision, precisionUnit) {
      const split = format.split(DurationFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DurationFormatter.FORMAT_REGEXP)) {
          return DurationFormatter.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input duration according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param precision The desired precision.
     * @param precisionUnit The unit type of the desired precision.
     * @returns A function which generates a string from an input duration in milliseconds according to the rules defined
     * by the template fragment.
     */
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          // Matches the positive sign char ('+')
          posStringMatch,
          // Matches the string assigned to represent the positive sign
          negStringMatch
          // Matches the string assigned to represent the negative sign
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        // Matches unit chars to the left of the decimal point
        unitMatch,
        // Matches the unit char ('H', 'M', 'S', etc)
        leftOptionalMatch,
        // Matches the question mark just to the left of the decimal point
        rightMatch,
        // Matches the decimal point and all chars to the right
        rightForcedMatch,
        // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch
        // Matches unit chars to the right of the decimal point surrounded by parens
      ] = numericMatch;
      const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (duration, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
      } : (duration, unit, epsilon) => {
        return (MathUtils.round(unitInfo.unit.convertFrom(Math.abs(duration), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (duration, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (duration, unit) => {
          const converted = convertFunc(duration, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (duration, unit) => {
          return formatLeftFunc(convertFunc(duration, unit, epsilon));
        };
      }
    }
  };
  DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DurationFormatter.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ["h"]: { unit: UnitType.HOUR, mod: Infinity },
    ["m"]: { unit: UnitType.MINUTE, mod: 60 },
    ["s"]: { unit: UnitType.SECOND, mod: 60 },
    ["H"]: { unit: UnitType.HOUR, mod: Infinity },
    ["M"]: { unit: UnitType.MINUTE, mod: Infinity },
    ["S"]: { unit: UnitType.SECOND, mod: Infinity }
  };
  DurationFormatter.NUM_FRAGMENT_ROUND_FUNCS = {
    ["+"]: Math.ceil,
    ["-"]: Math.floor,
    ["~"]: Math.round
  };
  var DateTimeFormatter = class {
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format, options) {
      const optsToUse = Object.assign({}, DateTimeFormatter.DEFAULT_OPTIONS, options);
      const builder = DateTimeFormatter.createBuilder(format, optsToUse);
      const date = /* @__PURE__ */ new Date();
      return (time) => {
        if (isNaN(time)) {
          return optsToUse.nanString;
        }
        date.setTime(time);
        return builder.reduce((string, part) => string + part(date), "");
      };
    }
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    static createBuilder(format, options) {
      const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
          return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
        } else {
          return () => string;
        }
      });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    static parseFragment(fragment, options) {
      const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
      if (match) {
        if (match[1]) {
          return DateTimeFormatter.parseNumFragment(match);
        } else if (match[4]) {
          return DateTimeFormatter.parseYearFragment(match);
        } else if (match[5]) {
          return DateTimeFormatter.parseMonthFragment(match, options);
        } else if (match[6]) {
          return DateTimeFormatter.parseDayFragment(match, options);
        } else if (match[7]) {
          return DateTimeFormatter.parseAMPMFragment(match);
        }
      }
      return () => "";
    }
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    static parseNumFragment(match) {
      const numGetter = DateTimeFormatter.NUM_GETTERS[match[3]];
      const pad = match[2].length;
      return (date) => {
        return numGetter(date).toString().padStart(pad, "0");
      };
    }
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    static parseYearFragment(match) {
      if (match[4].length === 2) {
        return (date) => (date.getUTCFullYear() % 100).toString();
      } else {
        return (date) => date.getUTCFullYear().toString();
      }
    }
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    static parseMonthFragment(match, options) {
      const isUpperCase = match[5][0] === "M";
      if (match[5].length === 3) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => text[date.getUTCMonth()];
      } else if (match[5].length === 4) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => {
          const month = date.getUTCMonth();
          return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.monthNames.map((str) => str.toUpperCase()) : options.monthNames;
        return (date) => text[date.getUTCMonth()];
      }
    }
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    static parseDayFragment(match, options) {
      const isUpperCase = match[6][0] === "D";
      if (match[6] === "dy") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => text[date.getUTCDay()];
      } else if (match[6] === "dy.") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => {
          const day = date.getUTCDay();
          return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.dayNames.map((str) => str.toUpperCase()) : options.dayNames;
        return (date) => text[date.getUTCDay()];
      }
    }
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    static parseAMPMFragment(match) {
      const isUpperCase = match[7][0] === "A";
      const usePeriod = match[7].length > 2;
      let text = usePeriod ? ["a.m.", "p.m."] : ["am", "pm"];
      if (isUpperCase) {
        text = text.map((str) => str.toUpperCase());
      }
      return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
  };
  DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DateTimeFormatter.FRAGMENT_REGEXP = /^(?:((([MdwHhms])+))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
  DateTimeFormatter.NUM_GETTERS = {
    ["s"]: (date) => date.getUTCSeconds(),
    ["m"]: (date) => date.getUTCMinutes(),
    ["h"]: (date) => date.getUTCHours() % 12,
    ["H"]: (date) => date.getUTCHours(),
    ["w"]: (date) => date.getUTCDay() + 1,
    ["d"]: (date) => date.getUTCDate(),
    ["M"]: (date) => date.getUTCMonth() + 1
  };
  DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    nanString: "NaN"
  };
  var RadioFrequencyFormatter = class {
    /**
     * Creates a function which formats NAV radio frequencies in hertz. The formatted string created by the function
     * displays the frequency in megahertz to two decimal places.
     * @param nanString The string to output for an input of `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats NAV radio frequencies in hertz.
     */
    static createNav(nanString = "NaN") {
      return (freqHz) => {
        return isNaN(freqHz) ? nanString : (freqHz / 1e6).toFixed(2);
      };
    }
    /**
     * Creates a function which formats COM radio frequencies in hertz. The formatted string created by the function
     * displays the frequency in megahertz to either two decimal places (with the third decimal place truncated) for
     * 25 kHz spacing, or three decimal places for 8.33 kHz spacing.
     * @param spacing The COM channel spacing mode to use.
     * @param nanString The string to output for an input of `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats COM radio frequencies in hertz.
     */
    static createCom(spacing, nanString = "NaN") {
      if (spacing === ComSpacing.Spacing833Khz) {
        return (freqHz) => {
          return isNaN(freqHz) ? nanString : (freqHz / 1e6).toFixed(3);
        };
      } else {
        return (freqHz) => {
          return isNaN(freqHz) ? nanString : (freqHz / 1e6).toFixed(3).slice(0, -1);
        };
      }
    }
    /**
     * Creates a function which formats ADF radio frequencies in hertz. The formatted string created by the function
     * displays the frequency in kilohertz to one decimal place.
     * @param nanString The string to output for an input of `NaN`. Defaults to `'NaN'`.
     * @returns A function which formats ADF radio frequencies in hertz.
     */
    static createAdf(nanString = "NaN") {
      return (freqHz) => {
        return isNaN(freqHz) ? nanString : (freqHz / 1e3).toFixed(1);
      };
    }
  };
  var DefaultUserSettingManager = class {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus, settingDefs, keepLocal = false) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.subscriber = this.bus.getSubscriber();
      this.syncPublisher = this.bus.getPublisher();
      this.syncSubscriber = this.bus.getSubscriber();
      this.keepLocal = keepLocal;
      this.settings = new Map(settingDefs.map((def) => {
        const initTopic = `usersetting_init_${def.name}`;
        const syncTopic = `usersetting_sync_${def.name}`;
        const entry = {
          syncTopic,
          syncTime: 0,
          initUid: Math.round(Math.random() * Number.MAX_SAFE_INTEGER)
        };
        entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
        entry.initSub = this.syncSubscriber.on(initTopic).handle((data) => {
          if (data.uid === entry.initUid) {
            return;
          }
          this.syncPublisher.pub(entry.syncTopic, { value: entry.setting.value, syncTime: entry.syncTime, initUid: data.uid }, !this.keepLocal, true);
        }, true);
        this.syncSubscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
        if (entry.syncTime === 0) {
          const sub = this.syncSubscriber.on(initTopic).handle((data) => {
            this.onSettingValueSynced(entry, { value: data.value, syncTime: 0 });
          });
          sub.destroy();
        }
        if (entry.syncTime === 0) {
          this.syncPublisher.pub(initTopic, { value: entry.setting.value, syncTime: Date.now(), uid: entry.initUid }, !this.keepLocal, true);
          this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
        }
        entry.initSub.resume();
        return [def.name, entry];
      }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
      var _a;
      return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
      const setting = this.tryGetSetting(name);
      if (setting === void 0) {
        throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
      }
      return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
      return Array.from(this.settings.values(), (entry) => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
      const setting = this.settings.get(name);
      if (!setting) {
        throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
      }
      return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
      return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
      entry.syncTime = Date.now();
      this.syncPublisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, !this.keepLocal, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
      if (data.initUid !== void 0 && entry.syncTime !== 0 || data.initUid === void 0 && data.syncTime < entry.syncTime) {
        return;
      }
      this.syncSettingFromEvent(entry, data);
    }
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    syncSettingFromEvent(entry, data) {
      entry.syncTime = data.syncTime;
      entry.setting.syncValue(data.value);
      this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
    }
  };
  var MappedUserSettingManager = class {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
      this.parent = parent;
      this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
      var _a;
      const mappedName = (_a = this.map[name]) !== null && _a !== void 0 ? _a : name;
      return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
      var _a;
      const mappedName = (_a = this.map[name]) !== null && _a !== void 0 ? _a : name;
      return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
      var _a;
      const mappedName = (_a = this.map[name]) !== null && _a !== void 0 ? _a : name;
      return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
      return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
      return new MappedUserSettingManager(this, map);
    }
  };
  var SyncableUserSetting = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
      super();
      this.definition = definition;
      this.valueChangedCallback = valueChangedCallback;
      this.isMutableSubscribable = true;
      this._value = definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
      return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
      if (this._value === v) {
        return;
      }
      this._value = v;
      this.valueChangedCallback(v);
      this.notify();
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
      if (this._value === value) {
        return;
      }
      this._value = value;
      this.notify();
    }
    /** @inheritdoc */
    get() {
      return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
      this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
      this.set(this.definition.defaultValue);
    }
  };
  var AliasedUserSettingManager = class {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings. The definitions should
     * define the settings' aliased names.
     */
    constructor(bus, settingDefs) {
      this.bus = bus;
      this.aliasedSettings = new Map(settingDefs.map((def) => [def.name, new AliasedUserSetting(def)]));
    }
    /**
     * Defines the mappings from this manager's aliased settings to their source settings. Once the mappings are defined,
     * each aliased setting will take the value of its source setting, and setting the value of the aliased setting will
     * also set the value of the source setting. If a source setting cannot be defined for an aliased setting, the
     * aliased setting's value will be fixed to its default value and cannot be changed.
     * @param masterManager The manager hosting the settings from which this manager's aliased settings will be sourced.
     * @param map The mappings for this manager's aliased settings, as a set of key-value pairs where the keys are the
     * aliased setting names and the values are the source setting names. For any aliased setting whose name does not
     * appear as a key in the mapping, its source setting is assumed to have the same name.
     */
    useAliases(masterManager, map) {
      this.manager = masterManager.mapTo(map);
      for (const aliasedSetting of this.aliasedSettings.values()) {
        aliasedSetting.useSource(this.manager.tryGetSetting(aliasedSetting.definition.name));
      }
    }
    /** @inheritdoc */
    tryGetSetting(name) {
      return this.aliasedSettings.get(name);
    }
    /** @inheritdoc */
    getSetting(name) {
      const setting = this.tryGetSetting(name);
      if (setting === void 0) {
        throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
      }
      return setting;
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
      const setting = this.aliasedSettings.get(name);
      if (!setting) {
        throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
      }
      return new BasicConsumer((handler, paused) => {
        return setting.sub(handler, true, paused);
      }).whenChanged();
    }
    /** @inheritdoc */
    getAllSettings() {
      return Array.from(this.aliasedSettings.values());
    }
    /** @inheritdoc */
    mapTo(map) {
      return new MappedUserSettingManager(this, map);
    }
  };
  var AliasedUserSetting = class extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     */
    constructor(definition) {
      super();
      this.definition = definition;
      this.isMutableSubscribable = true;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
      var _a, _b;
      return (_b = (_a = this.setting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
      this.setting && (this.setting.value = v);
    }
    /**
     * Sets this setting's source.
     * @param setting The user setting to use as the new source, or `undefined` to leave this setting without a source.
     */
    useSource(setting) {
      var _a;
      const oldValue = this.value;
      (_a = this.settingSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.setting = setting;
      if (setting !== void 0) {
        this.settingSub = setting.sub(() => {
          this.notify();
        });
      } else {
        this.settingSub = void 0;
      }
      if (oldValue !== this.value) {
        this.notify();
      }
    }
    /** @inheritdoc */
    get() {
      return this.value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
      this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
      this.set(this.definition.defaultValue);
    }
  };
  var UserSettingSaveManager = class {
    /**
     * Constructor.
     * @param settings This manager's managed settings.
     * @param bus The event bus.
     */
    constructor(settings, bus) {
      this.autoSaveKeys = /* @__PURE__ */ new Set();
      this.isAlive = true;
      const subscriber = bus.getSubscriber();
      this.entries = Array.from(settings, (setting) => {
        const autoSaveDataStoreKeys = [];
        return {
          setting,
          subscription: subscriber.on(setting.definition.name).whenChanged().handle(this.onSettingChanged.bind(this, autoSaveDataStoreKeys), true),
          autoSaveDataStoreKeys
        };
      });
    }
    /**
     * A callback which is called when a setting's value changes.
     * @param autoSaveDataStoreKeys The data store keys to which the setting's value should be automatically saved.
     * @param value The new value of the setting.
     */
    onSettingChanged(autoSaveDataStoreKeys, value) {
      const len = autoSaveDataStoreKeys.length;
      for (let i = 0; i < len; i++) {
        DataStore.set(autoSaveDataStoreKeys[i], value);
      }
    }
    /**
     * Loads the saved values of this manager's settings.
     * @param key The key from which to load the values.
     * @throws Error if this manager has been destroyed.
     */
    load(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot load using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        const storedValue = DataStore.get(dataStoreKey);
        if (storedValue !== void 0) {
          entry.setting.value = storedValue;
        }
      }
    }
    /**
     * Saves the current values of this manager's settings.
     * @param key The key to which to save the values.
     * @throws Error if this manager has been destroyed.
     */
    save(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot save using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        DataStore.set(dataStoreKey, entry.setting.value);
      }
    }
    /**
     * Starts automatically saving this manager's settings when their values change.
     * @param key The key to which to save the values.
     * @throws Error if this manager has been destroyed.
     */
    startAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot start autosave using a destroyed manager.");
      }
      if (this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.push(UserSettingSaveManager.getDataStoreKey(entry.setting, key));
        if (entry.autoSaveDataStoreKeys.length === 1) {
          entry.subscription.resume();
        }
      }
    }
    /**
     * Stops automatically saving this manager's settings when their values change.
     * @param key The key to which to stop saving the values.
     * @throws Error if this manager has been destroyed.
     */
    stopAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot stop autosave using a destroyed manager.");
      }
      if (!this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.splice(entry.autoSaveDataStoreKeys.indexOf(UserSettingSaveManager.getDataStoreKey(entry.setting, key)), 1);
        if (entry.autoSaveDataStoreKeys.length === 0) {
          entry.subscription.pause();
        }
      }
    }
    /**
     * Destroys this manager. Once this manager is destroyed, all active autosaves will be stopped, and attempting to
     * save, load, or start another autosave from this manager will cause an error to be thrown.
     */
    destroy() {
      const len = this.entries.length;
      for (let i = 0; i < len; i++) {
        this.entries[i].subscription.destroy();
      }
      this.entries.length = 0;
      this.isAlive = false;
    }
    /**
     * Gets a data store key for a specific setting and save key.
     * @param setting A user setting.
     * @param saveKey The save key.
     * @returns the data store key for the setting and save key.
     */
    static getDataStoreKey(setting, saveKey) {
      return `${UserSettingSaveManager.DATASTORE_PREFIX}.${saveKey}.${setting.definition.name}`;
    }
  };
  UserSettingSaveManager.DATASTORE_PREFIX = "persistent-setting";
  var AvionicsSystemState;
  (function(AvionicsSystemState2) {
    AvionicsSystemState2["Off"] = "Off";
    AvionicsSystemState2["Initializing"] = "Initializing";
    AvionicsSystemState2["On"] = "On";
    AvionicsSystemState2["Failed"] = "Failed";
  })(AvionicsSystemState || (AvionicsSystemState = {}));
  var BasicAvionicsSystem = class {
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index, bus, stateEvent) {
      this.index = index;
      this.bus = bus;
      this.stateEvent = stateEvent;
      this.initializationTime = 0;
      this.initializationTimer = new DebounceTimer();
      this.publisher = this.bus.getPublisher();
      this.isPowerValid = false;
      this.bus.pub(this.stateEvent, { previous: void 0, current: void 0 });
      const gameStateSub = GameStateProvider.get().sub((state) => {
        var _a;
        if (state === GameState.briefing || state === GameState.ingame) {
          gameStateSub.destroy();
          this.isPowerValid = true;
          (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        }
      }, false, true);
      gameStateSub.resume(true);
    }
    /** @inheritdoc */
    get state() {
      return this._state;
    }
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic or electricity logic element.
     * @param source The source to which to connect this system's power state.
     */
    connectToPower(source) {
      var _a;
      (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.electricalPowerSub = void 0;
      this.electricalPowerLogic = void 0;
      if (typeof source === "string") {
        this.electricalPowerSub = this.bus.getSubscriber().on(source).whenChanged().handle(this.onPowerChanged.bind(this), !this.isPowerValid);
      } else {
        this.electricalPowerLogic = source;
        this.updatePowerFromLogic();
      }
    }
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    setState(state) {
      if (this._state !== state) {
        const previous = this._state;
        this._state = state;
        this.onStateChanged(previous, state);
        this.bus.pub(this.stateEvent, { previous, current: state });
      }
    }
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
    }
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    onPowerChanged(isPowered) {
      const wasPowered = this.isPowered;
      this.isPowered = isPowered;
      if (wasPowered === void 0) {
        this.initializationTimer.clear();
        if (isPowered) {
          this.setState(AvionicsSystemState.On);
        } else {
          this.setState(AvionicsSystemState.Off);
        }
      } else {
        if (isPowered) {
          this.setState(AvionicsSystemState.Initializing);
          this.initializationTimer.schedule(() => this.setState(AvionicsSystemState.On), this.initializationTime);
        } else {
          this.initializationTimer.clear();
          this.setState(AvionicsSystemState.Off);
        }
      }
    }
    /** @inheritdoc */
    onUpdate() {
      this.updatePowerFromLogic();
    }
    /**
     * Updates this system's power state from an electricity logic element.
     */
    updatePowerFromLogic() {
      if (!this.isPowerValid || this.electricalPowerLogic === void 0) {
        return;
      }
      const isPowered = this.electricalPowerLogic.getValue() !== 0;
      if (isPowered !== this.isPowered) {
        this.onPowerChanged(isPowered);
      }
    }
  };
  var CollectionComponent = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this.items = new Array();
      this.itemCounter = 0;
    }
    /**
     * Add a new child element.
     * @param node A VNode to add to the container.
     * @returns An identifier for the added element.
     */
    addItem(node) {
      const id = `${this.props.id}_${this.itemCounter++}`;
      FSComponent.render(FSComponent.buildComponent("div", { id }, node), document.getElementById(this.props.id));
      return id;
    }
    /**
     * Remove a child element.
     * @param id The ID of the child to remove.
     */
    removeItem(id) {
      FSComponent.remove(document.getElementById(id));
    }
    /**
     * Insert a child before an element.
     * @param node The node to insert
     * @param before The element to insert before.
     * @returns An identifier for the added element.
     */
    insertBefore(node, before) {
      const id = `${this.props.id}_${this.itemCounter++}`;
      FSComponent.renderBefore(FSComponent.buildComponent("div", { id }, node), document.getElementById(before));
      return id;
    }
    /**
     * Insert a child after an element.
     * @param node The node to insert
     * @param after The element to insert after.
     * @returns An identifier for the added element.
     */
    insertAfter(node, after) {
      const id = `${this.props.id}_${this.itemCounter++}`;
      FSComponent.renderAfter(FSComponent.buildComponent("div", { id }, node), document.getElementById(after));
      return id;
    }
    /**
     * Render the element.
     * @returns A VNode.
     */
    render() {
      return FSComponent.buildComponent("div", { id: this.props.id });
    }
  };
  var FsBaseInstrument = class extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
      super.connectedCallback();
      this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
      super.Update();
      if (this.fsInstrument) {
        this.fsInstrument.Update();
      }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
      if (this.fsInstrument) {
        this.fsInstrument.onInteractionEvent(_args);
      }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
      super.onGameStateChanged(oldState, newState);
      if (this.fsInstrument) {
        this.fsInstrument.onGameStateChanged(oldState, newState);
      }
    }
    /** @inheritdoc */
    onFlightStart() {
      super.onFlightStart();
      if (this.fsInstrument) {
        this.fsInstrument.onFlightStart();
      }
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
      super.onSoundEnd(soundEventId);
      if (this.fsInstrument) {
        this.fsInstrument.onSoundEnd(soundEventId);
      }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
      return false;
    }
  };

  // ../../../../../fbw-common/src/systems/datalink/common/src/msfs/SimVarHandling.ts
  var SimVarSources = /* @__PURE__ */ ((SimVarSources2) => {
    SimVarSources2["utcYear"] = "E:ZULU YEAR";
    SimVarSources2["utcMonth"] = "E:ZULU MONTH OF YEAR";
    SimVarSources2["utcDayOfMonth"] = "E:ZULU DAY OF MONTH";
    SimVarSources2["utcSeconds"] = "E:ZULU TIME";
    SimVarSources2["presentPositionLatitude"] = "L:A32NX_ADIRS_IR_1_LATITUDE";
    SimVarSources2["presentPositionLongitude"] = "L:A32NX_ADIRS_IR_1_LONGITUDE";
    SimVarSources2["presentAltitude"] = "L:A32NX_ADIRS_ADR_1_ALTITUDE";
    SimVarSources2["presentHeading"] = "L:A32NX_ADIRS_IR_1_HEADING";
    SimVarSources2["presentTrack"] = "L:A32NX_ADIRS_IR_1_TRACK";
    SimVarSources2["computedAirspeed"] = "L:A32NX_ADIRS_ADR_1_COMPUTED_AIRSPEED";
    SimVarSources2["presentMach"] = "L:A32NX_ADIRS_ADR_1_MACH";
    SimVarSources2["groundSpeed"] = "L:A32NX_ADIRS_IR_1_GROUND_SPEED";
    SimVarSources2["verticalSpeed"] = "L:A32NX_ADIRS_IR_1_VERTICAL_SPEED";
    SimVarSources2["autopilotActive"] = "L:A32NX_AUTOPILOT_ACTIVE";
    SimVarSources2["autothrustMode"] = "L:A32NX_AUTOTHRUST_MODE";
    SimVarSources2["autothrustSelectedMach"] = "L:A32NX_MachPreselVal";
    SimVarSources2["autothrustSelectedKnots"] = "L:A32NX_SpeedPreselVal";
    SimVarSources2["windDirection"] = "L:A32NX_ADIRS_IR_1_WIND_DIRECTION";
    SimVarSources2["windSpeed"] = "L:A32NX_ADIRS_IR_1_WIND_SPEED";
    SimVarSources2["staticAirTemperature"] = "L:A32NX_ADIRS_ADR_1_STATIC_AIR_TEMPERATURE";
    SimVarSources2["flightPhase"] = "L:A32NX_FMGC_FLIGHT_PHASE";
    SimVarSources2["vhf3Powered"] = "L:A32NX_ELEC_DC_1_BUS_IS_POWERED";
    SimVarSources2["vhf3Frequency"] = "A:COM ACTIVE FREQUENCY:3";
    SimVarSources2["transponderCode"] = "TRANSPONDER CODE:1";
    SimVarSources2["companyMessageCount"] = "L:A32NX_COMPANY_MSG_COUNT";
    SimVarSources2["atcMessageButtonActive"] = "L:A32NX_DCDU_ATC_MSG_WAITING";
    SimVarSources2["atcMessageButtonPressed"] = "L:A32NX_DCDU_ATC_MSG_ACK";
    return SimVarSources2;
  })(SimVarSources || {});
  var _SimVarHandling = class extends SimVarPublisher {
    constructor(eventBus) {
      super(_SimVarHandling.simvars, eventBus);
      this.eventBus = eventBus;
      __publicField(this, "subscriber", null);
      __publicField(this, "datalinkPublisher", null);
    }
    connectedCallback() {
      super.subscribe("msfsUtcYear");
      super.subscribe("msfsUtcMonth");
      super.subscribe("msfsUtcDayOfMonth");
      super.subscribe("msfsUtcSeconds");
      super.subscribe("msfsPresentPositionLatitude");
      super.subscribe("msfsPresentPositionLongitude");
      super.subscribe("msfsPresentAltitude");
      super.subscribe("msfsPresentHeading");
      super.subscribe("msfsPresentTrack");
      super.subscribe("msfsComputedAirspeed");
      super.subscribe("msfsPresentMach");
      super.subscribe("msfsGroundSpeed");
      super.subscribe("msfsVerticalSpeed");
      super.subscribe("msfsAutopilotActive");
      super.subscribe("msfsAutothrustMode");
      super.subscribe("msfsAutothrustSelectedMach");
      super.subscribe("msfsAutothrustSelectedKnots");
      super.subscribe("msfsWindDirection");
      super.subscribe("msfsWindSpeed");
      super.subscribe("msfsStaticAirTemperature");
      super.subscribe("msfsFlightPhase");
      super.subscribe("msfsVhf3Powered");
      super.subscribe("msfsVhf3Frequency");
      super.subscribe("msfsTransponderCode");
      super.subscribe("msfsCompanyMessageCount");
      super.subscribe("msfsAtcMessageButtonActive");
      super.subscribe("msfsAtcMessageButtonPressed");
    }
    initialize() {
      this.datalinkPublisher = this.eventBus.getPublisher();
      this.subscriber = this.eventBus.getSubscriber();
      this.subscriber.on("msfsUtcYear").handle((year) => this.datalinkPublisher.pub("utcYear", year, false, false));
      this.subscriber.on("msfsUtcMonth").handle((month) => this.datalinkPublisher.pub("utcMonth", month, false, false));
      this.subscriber.on("msfsUtcDayOfMonth").handle((day) => this.datalinkPublisher.pub("utcDayOfMonth", day, false, false));
      this.subscriber.on("msfsUtcSeconds").handle((seconds) => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor(seconds / 60) % 60;
        const secondsOfMinute = Math.floor(seconds) - hours * 3600 + minutes * 60;
        this.datalinkPublisher.pub("utcHour", hours, false, false);
        this.datalinkPublisher.pub("utcMinute", minutes, false, false);
        this.datalinkPublisher.pub("utcSecond", secondsOfMinute, false, false);
        this.datalinkPublisher.pub("utcSecondsOfDay", seconds, false, false);
      });
      this.subscriber.on("msfsPresentPositionLatitude").handle((latitude) => {
        this.datalinkPublisher.pub("presentPositionLatitude", new Arinc429Word(latitude), false, false);
      });
      this.subscriber.on("msfsPresentPositionLongitude").handle((longitude) => {
        this.datalinkPublisher.pub("presentPositionLongitude", new Arinc429Word(longitude), false, false);
      });
      this.subscriber.on("msfsPresentAltitude").handle((altitude) => {
        this.datalinkPublisher.pub("presentAltitude", new Arinc429Word(altitude), false, false);
      });
      this.subscriber.on("msfsPresentHeading").handle((heading) => {
        this.datalinkPublisher.pub("presentHeading", new Arinc429Word(heading), false, false);
      });
      this.subscriber.on("msfsPresentTrack").handle((track) => {
        this.datalinkPublisher.pub("presentTrack", new Arinc429Word(track), false, false);
      });
      this.subscriber.on("msfsComputedAirspeed").handle((cas) => {
        this.datalinkPublisher.pub("computedAirspeed", new Arinc429Word(cas), false, false);
      });
      this.subscriber.on("msfsPresentMach").handle((mach) => {
        this.datalinkPublisher.pub("presentMach", new Arinc429Word(mach), false, false);
      });
      this.subscriber.on("msfsGroundSpeed").handle((groundSpeed) => {
        this.datalinkPublisher.pub("groundSpeed", new Arinc429Word(groundSpeed), false, false);
      });
      this.subscriber.on("msfsVerticalSpeed").handle((verticalSpeed) => {
        this.datalinkPublisher.pub("verticalSpeed", new Arinc429Word(verticalSpeed), false, false);
      });
      this.subscriber.on("msfsAutopilotActive").handle((active) => {
        this.datalinkPublisher.pub("autopilotActive", new Arinc429Word(active === true ? 1 : 0), false, false);
      });
      this.subscriber.on("msfsAutothrustMode").handle((mode) => {
        this.datalinkPublisher.pub("autothrustMode", new Arinc429Word(mode), false, false);
      });
      this.subscriber.on("msfsAutothrustSelectedMach").handle((mach) => {
        const word = new Arinc429Word(0);
        word.ssm = 3 /* NormalOperation */;
        word.value = mach;
        this.datalinkPublisher.pub("autothrustSelectedMach", word, false, false);
      });
      this.subscriber.on("msfsAutothrustSelectedKnots").handle((knots) => {
        const word = new Arinc429Word(0);
        word.ssm = 3 /* NormalOperation */;
        word.value = knots;
        this.datalinkPublisher.pub("autothrustSelectedKnots", word, false, false);
      });
      this.subscriber.on("msfsWindDirection").handle((direction) => {
        this.datalinkPublisher.pub("windDirection", new Arinc429Word(direction), false, false);
      });
      this.subscriber.on("msfsWindSpeed").handle((speed) => {
        this.datalinkPublisher.pub("windSpeed", new Arinc429Word(speed), false, false);
      });
      this.subscriber.on("msfsStaticAirTemperature").handle((sat) => {
        this.datalinkPublisher.pub("staticAirTemperature", new Arinc429Word(sat), false, false);
      });
      this.subscriber.on("msfsFlightPhase").handle((phase) => {
        this.datalinkPublisher.pub("flightPhase", new Arinc429Word(phase), false, false);
      });
      this.subscriber.on("msfsVhf3Powered").handle((powered) => this.datalinkPublisher.pub("vhf3Powered", powered !== 0, false, false));
      this.subscriber.on("msfsVhf3Frequency").handle((frequency) => this.datalinkPublisher.pub("vhf3DataMode", frequency === 0, false, false));
      this.subscriber.on("msfsTransponderCode").handle((code) => this.datalinkPublisher.pub("transponderCode", code, false, false));
      this.subscriber.on("msfsCompanyMessageCount").handle((count) => this.datalinkPublisher.pub("companyMessageCount", count, false, false));
      this.subscriber.on("msfsAtcMessageButtonActive").handle((active) => this.datalinkPublisher.pub("atcMessageButtonActive", active, false, false));
      this.subscriber.on("msfsAtcMessageButtonPressed").handle((pressed) => this.datalinkPublisher.pub("atcMessageButtonPressed", pressed !== 0, false, false));
      this.connectedCallback();
    }
    startPublish() {
      super.startPublish();
    }
    update() {
      super.onUpdate();
    }
  };
  var SimVarHandling = _SimVarHandling;
  __publicField(SimVarHandling, "simvars", /* @__PURE__ */ new Map([
    ["msfsUtcYear", { name: "E:ZULU YEAR" /* utcYear */, type: SimVarValueType.Number }],
    ["msfsUtcMonth", { name: "E:ZULU MONTH OF YEAR" /* utcMonth */, type: SimVarValueType.Number }],
    ["msfsUtcDayOfMonth", { name: "E:ZULU DAY OF MONTH" /* utcDayOfMonth */, type: SimVarValueType.Number }],
    ["msfsUtcSeconds", { name: "E:ZULU TIME" /* utcSeconds */, type: SimVarValueType.Number }],
    ["msfsPresentPositionLatitude", { name: "L:A32NX_ADIRS_IR_1_LATITUDE" /* presentPositionLatitude */, type: SimVarValueType.Number }],
    ["msfsPresentPositionLongitude", { name: "L:A32NX_ADIRS_IR_1_LONGITUDE" /* presentPositionLongitude */, type: SimVarValueType.Number }],
    ["msfsPresentAltitude", { name: "L:A32NX_ADIRS_ADR_1_ALTITUDE" /* presentAltitude */, type: SimVarValueType.Number }],
    ["msfsPresentHeading", { name: "L:A32NX_ADIRS_IR_1_HEADING" /* presentHeading */, type: SimVarValueType.Number }],
    ["msfsPresentTrack", { name: "L:A32NX_ADIRS_IR_1_TRACK" /* presentTrack */, type: SimVarValueType.Number }],
    ["msfsComputedAirspeed", { name: "L:A32NX_ADIRS_ADR_1_COMPUTED_AIRSPEED" /* computedAirspeed */, type: SimVarValueType.Number }],
    ["msfsPresentMach", { name: "L:A32NX_ADIRS_ADR_1_MACH" /* presentMach */, type: SimVarValueType.Number }],
    ["msfsGroundSpeed", { name: "L:A32NX_ADIRS_IR_1_GROUND_SPEED" /* groundSpeed */, type: SimVarValueType.Number }],
    ["msfsAutopilotActive", { name: "L:A32NX_AUTOPILOT_ACTIVE" /* autopilotActive */, type: SimVarValueType.Number }],
    ["msfsAutothrustMode", { name: "L:A32NX_AUTOTHRUST_MODE" /* autothrustMode */, type: SimVarValueType.Number }],
    ["msfsAutothrustSelectedMach", { name: "L:A32NX_MachPreselVal" /* autothrustSelectedMach */, type: SimVarValueType.Number }],
    ["msfsAutothrustSelectedKnots", { name: "L:A32NX_SpeedPreselVal" /* autothrustSelectedKnots */, type: SimVarValueType.Knots }],
    ["msfsWindDirection", { name: "L:A32NX_ADIRS_IR_1_WIND_DIRECTION" /* windDirection */, type: SimVarValueType.Number }],
    ["msfsWindSpeed", { name: "L:A32NX_ADIRS_IR_1_WIND_SPEED" /* windSpeed */, type: SimVarValueType.Number }],
    ["msfsStaticAirTemperature", { name: "L:A32NX_ADIRS_ADR_1_STATIC_AIR_TEMPERATURE" /* staticAirTemperature */, type: SimVarValueType.Number }],
    ["msfsFlightPhase", { name: "L:A32NX_FMGC_FLIGHT_PHASE" /* flightPhase */, type: SimVarValueType.Number }],
    ["msfsVhf3Powered", { name: "L:A32NX_ELEC_DC_1_BUS_IS_POWERED" /* vhf3Powered */, type: SimVarValueType.Number }],
    ["msfsVhf3Frequency", { name: "A:COM ACTIVE FREQUENCY:3" /* vhf3Frequency */, type: SimVarValueType.MHz }],
    ["msfsTransponderCode", { name: "TRANSPONDER CODE:1" /* transponderCode */, type: SimVarValueType.Number }],
    ["msfsCompanyMessageCount", { name: "L:A32NX_COMPANY_MSG_COUNT" /* companyMessageCount */, type: SimVarValueType.Number }],
    ["msfsAtcMessageButtonActive", { name: "L:A32NX_DCDU_ATC_MSG_WAITING" /* atcMessageButtonActive */, type: SimVarValueType.Bool }],
    ["msfsAtcMessageButtonPressed", { name: "L:A32NX_DCDU_ATC_MSG_ACK" /* atcMessageButtonPressed */, type: SimVarValueType.Number }]
  ]));

  // ../../fmgc/src/guidance/ControlLaws.ts
  var ControlLaw = /* @__PURE__ */ ((ControlLaw2) => {
    ControlLaw2[ControlLaw2["HEADING"] = 1] = "HEADING";
    ControlLaw2[ControlLaw2["TRACK"] = 2] = "TRACK";
    ControlLaw2[ControlLaw2["LATERAL_PATH"] = 3] = "LATERAL_PATH";
    return ControlLaw2;
  })(ControlLaw || {});
  var RequestedVerticalMode = /* @__PURE__ */ ((RequestedVerticalMode2) => {
    RequestedVerticalMode2[RequestedVerticalMode2["None"] = 0] = "None";
    RequestedVerticalMode2[RequestedVerticalMode2["SpeedThrust"] = 1] = "SpeedThrust";
    RequestedVerticalMode2[RequestedVerticalMode2["VpathThrust"] = 2] = "VpathThrust";
    RequestedVerticalMode2[RequestedVerticalMode2["VpathSpeed"] = 3] = "VpathSpeed";
    RequestedVerticalMode2[RequestedVerticalMode2["FpaSpeed"] = 4] = "FpaSpeed";
    RequestedVerticalMode2[RequestedVerticalMode2["VsSpeed"] = 5] = "VsSpeed";
    return RequestedVerticalMode2;
  })(RequestedVerticalMode || {});

  // ../../shared/src/autopilot.ts
  var LateralMode = /* @__PURE__ */ ((LateralMode2) => {
    LateralMode2[LateralMode2["NONE"] = 0] = "NONE";
    LateralMode2[LateralMode2["HDG"] = 10] = "HDG";
    LateralMode2[LateralMode2["TRACK"] = 11] = "TRACK";
    LateralMode2[LateralMode2["NAV"] = 20] = "NAV";
    LateralMode2[LateralMode2["LOC_CPT"] = 30] = "LOC_CPT";
    LateralMode2[LateralMode2["LOC_TRACK"] = 31] = "LOC_TRACK";
    LateralMode2[LateralMode2["LAND"] = 32] = "LAND";
    LateralMode2[LateralMode2["FLARE"] = 33] = "FLARE";
    LateralMode2[LateralMode2["ROLL_OUT"] = 34] = "ROLL_OUT";
    LateralMode2[LateralMode2["RWY"] = 40] = "RWY";
    LateralMode2[LateralMode2["RWY_TRACK"] = 41] = "RWY_TRACK";
    LateralMode2[LateralMode2["GA_TRACK"] = 50] = "GA_TRACK";
    return LateralMode2;
  })(LateralMode || {});
  var ArmedLateralMode = /* @__PURE__ */ ((ArmedLateralMode2) => {
    ArmedLateralMode2[ArmedLateralMode2["NAV"] = 0] = "NAV";
    ArmedLateralMode2[ArmedLateralMode2["LOC"] = 1] = "LOC";
    return ArmedLateralMode2;
  })(ArmedLateralMode || {});
  var VerticalMode = /* @__PURE__ */ ((VerticalMode2) => {
    VerticalMode2[VerticalMode2["NONE"] = 0] = "NONE";
    VerticalMode2[VerticalMode2["ALT"] = 10] = "ALT";
    VerticalMode2[VerticalMode2["ALT_CPT"] = 11] = "ALT_CPT";
    VerticalMode2[VerticalMode2["OP_CLB"] = 12] = "OP_CLB";
    VerticalMode2[VerticalMode2["OP_DES"] = 13] = "OP_DES";
    VerticalMode2[VerticalMode2["VS"] = 14] = "VS";
    VerticalMode2[VerticalMode2["FPA"] = 15] = "FPA";
    VerticalMode2[VerticalMode2["ALT_CST"] = 20] = "ALT_CST";
    VerticalMode2[VerticalMode2["ALT_CST_CPT"] = 21] = "ALT_CST_CPT";
    VerticalMode2[VerticalMode2["CLB"] = 22] = "CLB";
    VerticalMode2[VerticalMode2["DES"] = 23] = "DES";
    VerticalMode2[VerticalMode2["FINAL"] = 24] = "FINAL";
    VerticalMode2[VerticalMode2["GS_CPT"] = 30] = "GS_CPT";
    VerticalMode2[VerticalMode2["GS_TRACK"] = 31] = "GS_TRACK";
    VerticalMode2[VerticalMode2["LAND"] = 32] = "LAND";
    VerticalMode2[VerticalMode2["FLARE"] = 33] = "FLARE";
    VerticalMode2[VerticalMode2["ROLL_OUT"] = 34] = "ROLL_OUT";
    VerticalMode2[VerticalMode2["SRS"] = 40] = "SRS";
    VerticalMode2[VerticalMode2["SRS_GA"] = 41] = "SRS_GA";
    VerticalMode2[VerticalMode2["TCAS"] = 50] = "TCAS";
    return VerticalMode2;
  })(VerticalMode || {});
  var ArmedVerticalMode = /* @__PURE__ */ ((ArmedVerticalMode2) => {
    ArmedVerticalMode2[ArmedVerticalMode2["ALT"] = 0] = "ALT";
    ArmedVerticalMode2[ArmedVerticalMode2["ALT_CST"] = 1] = "ALT_CST";
    ArmedVerticalMode2[ArmedVerticalMode2["CLB"] = 2] = "CLB";
    ArmedVerticalMode2[ArmedVerticalMode2["DES"] = 3] = "DES";
    ArmedVerticalMode2[ArmedVerticalMode2["GS"] = 4] = "GS";
    ArmedVerticalMode2[ArmedVerticalMode2["FINAL"] = 5] = "FINAL";
    ArmedVerticalMode2[ArmedVerticalMode2["TCAS"] = 6] = "TCAS";
    return ArmedVerticalMode2;
  })(ArmedVerticalMode || {});
  function isArmed(bitmask, armedBit) {
    return (bitmask >> armedBit & 1) === 1;
  }
  var AutoThrustMode = /* @__PURE__ */ ((AutoThrustMode2) => {
    AutoThrustMode2[AutoThrustMode2["NONE"] = 0] = "NONE";
    AutoThrustMode2[AutoThrustMode2["MAN_TOGA"] = 1] = "MAN_TOGA";
    AutoThrustMode2[AutoThrustMode2["MAN_GA_SOFT"] = 2] = "MAN_GA_SOFT";
    AutoThrustMode2[AutoThrustMode2["MAN_FLEX"] = 3] = "MAN_FLEX";
    AutoThrustMode2[AutoThrustMode2["MAN_DTO"] = 4] = "MAN_DTO";
    AutoThrustMode2[AutoThrustMode2["MAN_MCT"] = 5] = "MAN_MCT";
    AutoThrustMode2[AutoThrustMode2["MAN_THR"] = 6] = "MAN_THR";
    AutoThrustMode2[AutoThrustMode2["SPEED"] = 7] = "SPEED";
    AutoThrustMode2[AutoThrustMode2["MACH"] = 8] = "MACH";
    AutoThrustMode2[AutoThrustMode2["THR_MCT"] = 9] = "THR_MCT";
    AutoThrustMode2[AutoThrustMode2["THR_CLB"] = 10] = "THR_CLB";
    AutoThrustMode2[AutoThrustMode2["THR_LVR"] = 11] = "THR_LVR";
    AutoThrustMode2[AutoThrustMode2["THR_IDLE"] = 12] = "THR_IDLE";
    AutoThrustMode2[AutoThrustMode2["A_FLOOR"] = 13] = "A_FLOOR";
    AutoThrustMode2[AutoThrustMode2["TOGA_LK"] = 14] = "TOGA_LK";
    return AutoThrustMode2;
  })(AutoThrustMode || {});

  // ../../shared/src/flightphase.ts
  var FmgcFlightPhase = /* @__PURE__ */ ((FmgcFlightPhase2) => {
    FmgcFlightPhase2[FmgcFlightPhase2["Preflight"] = 0] = "Preflight";
    FmgcFlightPhase2[FmgcFlightPhase2["Takeoff"] = 1] = "Takeoff";
    FmgcFlightPhase2[FmgcFlightPhase2["Climb"] = 2] = "Climb";
    FmgcFlightPhase2[FmgcFlightPhase2["Cruise"] = 3] = "Cruise";
    FmgcFlightPhase2[FmgcFlightPhase2["Descent"] = 4] = "Descent";
    FmgcFlightPhase2[FmgcFlightPhase2["Approach"] = 5] = "Approach";
    FmgcFlightPhase2[FmgcFlightPhase2["GoAround"] = 6] = "GoAround";
    FmgcFlightPhase2[FmgcFlightPhase2["Done"] = 7] = "Done";
    return FmgcFlightPhase2;
  })(FmgcFlightPhase || {});
  function isReady() {
    return SimVar.GetSimVarValue("L:A32NX_IS_READY", "number") === 1;
  }
  function isSlewActive() {
    return SimVar.GetSimVarValue("IS SLEW ACTIVE", "bool");
  }
  function isOnGround() {
    return SimVar.GetSimVarValue("L:A32NX_LGCIU_1_NOSE_GEAR_COMPRESSED", "bool") || SimVar.GetSimVarValue("L:A32NX_LGCIU_2_NOSE_GEAR_COMPRESSED", "bool");
  }
  function isEngineOn(index) {
    return SimVar.GetSimVarValue(`L:A32NX_ENGINE_N2:${index}`, "number") > 20;
  }
  function isEngineOnTakeOffThrust(index) {
    return SimVar.GetSimVarValue(`L:A32NX_ENGINE_N1:${index}`, "number") >= 70;
  }
  function isAnEngineOn() {
    return isEngineOn(1) || isEngineOn(2);
  }
  function isAllEngineOn() {
    return isEngineOn(1) && isEngineOn(2);
  }
  function getAutopilotVerticalMode() {
    return SimVar.GetSimVarValue("L:A32NX_FMA_VERTICAL_MODE", "Enum");
  }
  function conditionTakeOff() {
    return getAutopilotVerticalMode() === 40 /* SRS */ && isEngineOnTakeOffThrust(1) && isEngineOnTakeOffThrust(2) || Math.abs(Simplane.getGroundSpeed()) > 90;
  }

  // src/FlightPlanSynchronization.ts
  var FlightPlanSynchronization = class {
    constructor(bus, flightPlanManager, flightPhaseManager) {
      this.bus = bus;
      this.flightPlanManager = flightPlanManager;
      this.flightPhaseManager = flightPhaseManager;
      __publicField(this, "publisher");
      __publicField(this, "originIdent", "");
      __publicField(this, "lastWaypoint", { ident: "", altitude: 0, utc: 0 });
      __publicField(this, "activeWaypoint", { ident: "", altitude: 0, utc: 0 });
      __publicField(this, "nextWaypoint", { ident: "", altitude: 0, utc: 0 });
      __publicField(this, "destination", { ident: "", altitude: 0, utc: 0 });
      this.publisher = this.bus.getPublisher();
      setInterval(() => {
        const activeFlightPlan = this.flightPlanManager.getCurrentFlightPlan();
        const phase = this.flightPhaseManager.phase;
        const isFlying = phase >= 1 /* Takeoff */ && phase !== 7 /* Done */;
        if (activeFlightPlan && activeFlightPlan.waypoints.length !== 0) {
          let flightPlanStats = null;
          if (isFlying) {
            const latitude = new Arinc429Word(SimVar.GetSimVarValue("L:A32NX_ADIRS_IR_1_LATITUDE", "number"));
            const longitude = new Arinc429Word(SimVar.GetSimVarValue("L:A32NX_ADIRS_IR_1_LONGITUDE", "number"));
            if (latitude.isNormalOperation() && longitude.isNormalOperation()) {
              const ppos = {
                lat: latitude.value,
                long: longitude.value
              };
              flightPlanStats = activeFlightPlan.computeWaypointStatistics(ppos);
            }
          }
          const origin = activeFlightPlan.originAirfield;
          const lastWaypoint = FlightPlanSynchronization.findLastWaypoint(activeFlightPlan);
          const activeWaypoint = FlightPlanSynchronization.findActiveWaypoint(activeFlightPlan, flightPlanStats);
          const nextWaypoint = FlightPlanSynchronization.findNextWaypoint(activeFlightPlan, flightPlanStats);
          const destination = FlightPlanSynchronization.findDestinationWaypoint(activeFlightPlan, flightPlanStats);
          if (origin) {
            if (origin.ident !== this.originIdent || destination.ident !== this.destination.ident) {
              this.publisher.pub("atcResetAtisAutoUpdate", true, true, false);
            }
            const updateRoute = this.lastWaypoint.ident !== lastWaypoint.ident || this.activeWaypoint.ident !== activeWaypoint.ident || this.nextWaypoint.ident !== nextWaypoint.ident || this.destination.ident !== destination.ident || Math.abs(this.activeWaypoint.utc - activeWaypoint.utc) >= 60 || Math.abs(this.nextWaypoint.utc - nextWaypoint.utc) >= 60;
            if (updateRoute) {
              this.publisher.pub("atcRouteData", {
                lastWaypoint,
                activeWaypoint,
                nextWaypoint,
                destination
              }, true, false);
            }
          }
        }
      }, 1e3);
    }
    static findLastWaypoint(flightPlan) {
      let idx = flightPlan.activeWaypointIndex;
      while (idx >= 0) {
        const wp = flightPlan.getWaypoint(idx);
        if (wp && wp.waypointReachedAt !== 0) {
          return {
            ident: wp.ident,
            altitude: wp.legAltitude1,
            utc: wp.waypointReachedAt
          };
        }
        idx -= 1;
      }
      return { ident: "", altitude: 0, utc: 0 };
    }
    static findActiveWaypoint(flightPlan, flightPlanStats) {
      if (flightPlan.activeWaypoint) {
        return {
          ident: flightPlan.activeWaypoint.ident,
          altitude: flightPlan.activeWaypoint.legAltitude1,
          utc: flightPlanStats !== null ? flightPlanStats.get(flightPlan.activeWaypointIndex).etaFromPpos : -1
        };
      }
      return { ident: "", altitude: 0, utc: 0 };
    }
    static findNextWaypoint(flightPlan, flightPlanStats) {
      let idx = flightPlan.activeWaypointIndex + 1;
      while (idx < flightPlan.waypoints.length) {
        const wp = flightPlan.getWaypoint(idx);
        if (wp) {
          return {
            ident: wp.ident,
            altitude: wp.legAltitude1,
            utc: flightPlanStats !== null ? flightPlanStats.get(idx).etaFromPpos : -1
          };
        }
        idx += 1;
      }
      return { ident: "", altitude: 0, utc: 0 };
    }
    static findDestinationWaypoint(flightPlan, flightPlanStats) {
      let idx = flightPlan.activeWaypointIndex;
      while (idx < flightPlan.waypoints.length) {
        const wp = flightPlan.getWaypoint(idx);
        if (wp && wp.ident === flightPlan.destinationAirfield.ident) {
          return {
            ident: wp.ident,
            altitude: wp.legAltitude1,
            utc: flightPlanStats !== null ? flightPlanStats.get(idx).etaFromPpos : -1
          };
        }
        idx += 1;
      }
      return { ident: "", altitude: 0, utc: 0 };
    }
  };

  // src/MessageStorage.ts
  var MessageStorage = class {
    constructor(subscriber) {
      this.subscriber = subscriber;
      __publicField(this, "atisReports", /* @__PURE__ */ new Map());
      __publicField(this, "atcMessagesBuffer", []);
      __publicField(this, "atcMonitoredMessages", []);
      __publicField(this, "aocUplinkMessages", []);
      __publicField(this, "aocDownlinkMessages", []);
      this.subscriber.on("atcAtisReports").handle((reports) => {
        this.atisReports = /* @__PURE__ */ new Map();
        reports.forEach((message) => {
          const enhancedMessage = Conversion.messageDataToMessage(message);
          if (this.atisReports.has(enhancedMessage.Reports[0].airport)) {
            this.atisReports.get(enhancedMessage.Reports[0].airport).push(enhancedMessage);
          } else {
            this.atisReports.set(enhancedMessage.Reports[0].airport, [enhancedMessage]);
          }
        });
      });
      this.subscriber.on("atcMonitoredMessages").handle((messages) => {
        this.atcMonitoredMessages = [];
        messages.forEach((message) => this.atcMonitoredMessages.push(Conversion.messageDataToMessage(message)));
      });
      this.subscriber.on("aocResynchronizeWeatherMessage").handle((message) => this.resynchronizeAocMessage(Conversion.messageDataToMessage(message)));
      this.subscriber.on("aocResynchronizeFreetextMessage").handle((message) => this.resynchronizeAocMessage(Conversion.messageDataToMessage(message)));
      this.subscriber.on("atcResynchronizeCpdlcMessage").handle((message) => this.resynchronizeAtcMessage(Conversion.messageDataToMessage(message)));
      this.subscriber.on("atcResynchronizeDclMessage").handle((message) => this.resynchronizeAtcMessage(Conversion.messageDataToMessage(message)));
      this.subscriber.on("atcResynchronizeOclMessage").handle((message) => this.resynchronizeAtcMessage(Conversion.messageDataToMessage(message)));
      this.subscriber.on("atcDeleteMessage").handle((uid) => this.deleteMessageFromQueue(uid, this.atcMessagesBuffer));
      this.subscriber.on("aocDeleteMessage").handle((uid) => this.deleteAocMessage(uid));
    }
    resynchronizeAocMessageQueue(message, queue) {
      const index = queue.findIndex((entry) => entry.UniqueMessageID === message.UniqueMessageID);
      if (index !== -1) {
        queue[index] = message;
      } else {
        queue.unshift(message);
      }
    }
    resynchronizeAocMessage(message) {
      if (message.Direction === 1 /* Downlink */) {
        this.resynchronizeAocMessageQueue(message, this.aocDownlinkMessages);
      } else {
        this.resynchronizeAocMessageQueue(message, this.aocUplinkMessages);
      }
    }
    resynchronizeAtcMessage(message) {
      const index = this.atcMessagesBuffer.findIndex((entry) => entry.UniqueMessageID === message.UniqueMessageID);
      if (index !== -1) {
        this.atcMessagesBuffer[index] = message;
      } else {
        this.atcMessagesBuffer.unshift(message);
      }
    }
    deleteMessageFromQueue(uid, queue) {
      const index = queue.findIndex((entry) => entry.UniqueMessageID === uid);
      if (index !== -1) {
        queue.splice(index, 1);
      }
      return index !== -1;
    }
    deleteAocMessage(uid) {
      if (this.deleteMessageFromQueue(uid, this.aocDownlinkMessages))
        return;
      this.deleteMessageFromQueue(uid, this.aocUplinkMessages);
    }
    resetAocData() {
      this.aocUplinkMessages = [];
      this.aocDownlinkMessages = [];
    }
    resetAtcData() {
      this.atisReports = /* @__PURE__ */ new Map();
      this.atcMessagesBuffer = [];
      this.atcMonitoredMessages = [];
    }
  };

  // src/index.ts
  var FmsClient = class {
    constructor(fms, flightPlanManager, flightPhaseManager) {
      __publicField(this, "bus");
      __publicField(this, "messageStorage");
      __publicField(this, "flightPlan");
      __publicField(this, "publisher");
      __publicField(this, "subscriber");
      __publicField(this, "requestId", 0);
      __publicField(this, "routerResponseCallbacks", []);
      __publicField(this, "genericRequestResponseCallbacks", []);
      __publicField(this, "requestAtsuStatusCodeCallbacks", []);
      __publicField(this, "requestSentToGroundCallbacks", []);
      __publicField(this, "weatherResponseCallbacks", []);
      __publicField(this, "positionReportDataCallbacks", []);
      __publicField(this, "atisAutoUpdates", []);
      __publicField(this, "atisReportsPrintActive", false);
      __publicField(this, "atcStationStatus", {
        current: "",
        next: "",
        notificationTime: 0,
        mode: 0 /* FansNone */,
        logonInProgress: false
      });
      __publicField(this, "automaticPositionReportIsActive", false);
      __publicField(this, "fms", null);
      __publicField(this, "datalinkStatus", {
        vhf: 0 /* NotInstalled */,
        satellite: 0 /* NotInstalled */,
        hf: 0 /* NotInstalled */
      });
      __publicField(this, "datalinkMode", {
        vhf: 0 /* None */,
        satellite: 0 /* None */,
        hf: 0 /* None */
      });
      __publicField(this, "maxUplinkDelay", -1);
      __publicField(this, "modificationMessage", null);
      this.bus = new EventBus();
      this.publisher = this.bus.getPublisher();
      this.subscriber = this.bus.getSubscriber();
      this.fms = fms;
      this.flightPlan = new FlightPlanSynchronization(this.bus, flightPlanManager, flightPhaseManager);
      this.messageStorage = new MessageStorage(this.subscriber);
      this.subscriber.on("aocResetData").handle(() => this.messageStorage.resetAocData());
      this.subscriber.on("atcResetData").handle(() => {
        this.messageStorage.resetAtcData();
        this.atisAutoUpdates = [];
        this.atisReportsPrintActive = false;
        this.automaticPositionReportIsActive = false;
        this.atcStationStatus = {
          current: "",
          next: "",
          notificationTime: 0,
          mode: 0 /* FansNone */,
          logonInProgress: false
        };
        this.datalinkStatus = {
          vhf: 0 /* NotInstalled */,
          satellite: 0 /* NotInstalled */,
          hf: 0 /* NotInstalled */
        };
        this.datalinkMode = {
          vhf: 0 /* None */,
          satellite: 0 /* None */,
          hf: 0 /* None */
        };
      });
      this.subscriber.on("atcSystemStatus").handle((status) => this.fms.addNewAtsuMessage(status));
      this.subscriber.on("aocSystemStatus").handle((status) => this.fms.addNewAtsuMessage(status));
      this.subscriber.on("atcMessageModify").handle((message) => this.modificationMessage = message);
      this.subscriber.on("atcPrintMessage").handle((message) => this.printMessage(message));
      this.subscriber.on("aocPrintMessage").handle((message) => this.printMessage(message));
      this.subscriber.on("atcActiveAtisAutoUpdates").handle((airports) => this.atisAutoUpdates = airports);
      this.subscriber.on("atcPrintAtisReportsPrint").handle((active) => this.atisReportsPrintActive = active);
      this.subscriber.on("atcStationStatus").handle((status) => this.atcStationStatus = status);
      this.subscriber.on("atcMaxUplinkDelay").handle((delay) => this.maxUplinkDelay = delay);
      this.subscriber.on("atcAutomaticPositionReportActive").handle((active) => this.automaticPositionReportIsActive = active);
      this.subscriber.on("routerManagementResponse").handle((data) => {
        this.routerResponseCallbacks.every((callback, index) => {
          if (callback(data.status, data.requestId)) {
            this.routerResponseCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
      this.subscriber.on("routerDatalinkStatus").handle((data) => this.datalinkStatus = data);
      this.subscriber.on("routerDatalinkMode").handle((data) => this.datalinkMode = data);
      this.subscriber.on("atcGenericRequestResponse").handle((response) => {
        this.genericRequestResponseCallbacks.every((callback, index) => {
          if (callback(response)) {
            this.genericRequestResponseCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
      this.subscriber.on("atcRequestAtsuStatusCode").handle((response) => {
        this.requestAtsuStatusCodeCallbacks.every((callback, index) => {
          if (callback(response.code, response.requestId)) {
            this.requestAtsuStatusCodeCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
      this.subscriber.on("aocTransmissionResponse").handle((response) => {
        this.requestAtsuStatusCodeCallbacks.every((callback, index) => {
          if (callback(response.status, response.requestId)) {
            this.requestAtsuStatusCodeCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
      this.subscriber.on("aocRequestSentToGround").handle((response) => {
        this.requestSentToGroundCallbacks.every((callback, index) => {
          if (callback(response)) {
            this.requestSentToGroundCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
      this.subscriber.on("aocWeatherResponse").handle((response) => {
        this.weatherResponseCallbacks.every((callback, index) => {
          if (callback(response.data, response.requestId)) {
            this.weatherResponseCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
      this.subscriber.on("atcPositionReport").handle((response) => {
        this.positionReportDataCallbacks.every((callback, index) => {
          if (callback(response.data, response.requestId)) {
            this.positionReportDataCallbacks.splice(index, 1);
            return false;
          }
          return true;
        });
      });
    }
    async sendMessage(message) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("aocSendFreetextMessage", { message, requestId }, true, false);
        this.requestAtsuStatusCodeCallbacks.push((code, id) => {
          if (id === requestId)
            resolve(code);
          return id === requestId;
        });
      });
    }
    messageRead(uid, aocMessage) {
      this.publisher.pub(aocMessage ? "aocMessageRead" : "atcMessageRead", uid, true, false);
    }
    printMessage(message) {
      const text = message.serialize(3 /* Printer */);
      this.fms.printPage(text.split("\n"));
    }
    removeMessage(uid, aocMessage) {
      this.publisher.pub(aocMessage ? "aocRemoveMessage" : "atcRemoveMessage", uid, true, false);
    }
    async receiveAocAtis(airport, type, sentCallback) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("aocRequestAtis", { icao: airport, type, requestId }, true, false);
        this.requestSentToGroundCallbacks.push((id) => {
          if (id === requestId)
            sentCallback();
          return id === requestId;
        });
        this.weatherResponseCallbacks.push((response, id) => {
          if (id === requestId)
            resolve(response);
          return id === requestId;
        });
      });
    }
    async receiveAtcAtis(airport, type) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcRequestAtis", { icao: airport, type, requestId }, true, false);
        this.requestAtsuStatusCodeCallbacks.push((response, id) => {
          if (id === requestId)
            resolve(response);
          return id === requestId;
        });
      });
    }
    async receiveWeather(requestMetar, icaos, sentCallback) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("aocRequestWeather", { icaos, requestMetar, requestId }, true, false);
        this.requestSentToGroundCallbacks.push((id) => {
          if (id === requestId)
            sentCallback();
          return id === requestId;
        });
        this.weatherResponseCallbacks.push((response, id) => {
          if (id === requestId)
            resolve(response);
          return id === requestId;
        });
      });
    }
    registerMessages(messages) {
      if (messages[0].Type === 5 /* CPDLC */) {
        this.publisher.pub("atcRegisterCpdlcMessages", messages, true, false);
      } else if (messages[0].Type === 6 /* DCL */) {
        this.publisher.pub("atcRegisterDclMessages", messages, true, false);
      } else if (messages[0].Type === 7 /* OCL */) {
        this.publisher.pub("atcRegisterOclMessages", messages, true, false);
      } else if (messages[0].Type === 3 /* ATIS */ || messages[0].Type === 1 /* METAR */ || messages[0].Type === 2 /* TAF */) {
        this.publisher.pub("aocRegisterWeatherMessages", messages, true, false);
      }
    }
    atisAutoUpdateActive(icao) {
      return this.atisAutoUpdates.findIndex((airport) => icao === airport) !== -1;
    }
    async deactivateAtisAutoUpdate(icao) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcDeactivateAtisAutoUpdate", { icao, requestId }, true, false);
        this.genericRequestResponseCallbacks.push((id) => {
          if (id === requestId)
            resolve(0 /* Ok */);
          return id === requestId;
        });
      });
    }
    async activateAtisAutoUpdate(icao, type) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcActivateAtisAutoUpdate", { icao, type, requestId }, true, false);
        this.genericRequestResponseCallbacks.push((id) => {
          if (id === requestId)
            resolve(0 /* Ok */);
          return id === requestId;
        });
      });
    }
    atisReports(icao) {
      if (this.messageStorage.atisReports.has(icao)) {
        return this.messageStorage.atisReports.get(icao);
      }
      return [];
    }
    printAtisReportsPrint() {
      return this.atisReportsPrintActive;
    }
    async togglePrintAtisReports() {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcTogglePrintAtisReportsPrint", requestId, true, false);
        this.genericRequestResponseCallbacks.push((id) => {
          if (id === requestId)
            resolve(0 /* Ok */);
          return id === requestId;
        });
      });
    }
    currentStation() {
      return this.atcStationStatus.current;
    }
    fansMode() {
      return this.atcStationStatus.mode;
    }
    nextStationNotificationTime() {
      return this.atcStationStatus.notificationTime;
    }
    nextStation() {
      return this.atcStationStatus.next;
    }
    flightNumber() {
      return SimVar.GetSimVarValue("ATC FLIGHT NUMBER", "string");
    }
    logonInProgress() {
      return this.atcStationStatus.logonInProgress;
    }
    async logon(callsign) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcLogon", { station: callsign, requestId }, true, false);
        this.requestAtsuStatusCodeCallbacks.push((code, id) => {
          if (id === requestId)
            resolve(code);
          return id === requestId;
        });
      });
    }
    async logoff() {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcLogoff", requestId, true, false);
        this.requestAtsuStatusCodeCallbacks.push((code, id) => {
          if (id === requestId)
            resolve(code);
          return id === requestId;
        });
      });
    }
    async isRemoteStationAvailable(callsign) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("routerRequestStationAvailable", { callsign, requestId }, true, false);
        this.routerResponseCallbacks.push((code, id) => {
          if (id === requestId)
            resolve(code);
          return id === requestId;
        });
      });
    }
    updateMessage(message) {
      if (this.modificationMessage !== null && message.UniqueMessageID === this.modificationMessage.UniqueMessageID) {
        this.modificationMessage = null;
      }
      this.publisher.pub("atcUpdateMessage", message, true, false);
    }
    aocInputMessages() {
      return this.messageStorage.aocUplinkMessages;
    }
    aocOutputMessages() {
      return this.messageStorage.aocDownlinkMessages;
    }
    atcMessages() {
      return this.messageStorage.atcMessagesBuffer;
    }
    monitoredMessages() {
      return this.messageStorage.atcMonitoredMessages;
    }
    cleanupAtcMessages() {
      this.publisher.pub("atcCleanupMessages", true, true, false);
    }
    async setMaxUplinkDelay(delay) {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcSetMaxUplinkDelay", { delay, requestId }, true, false);
        this.genericRequestResponseCallbacks.push((id) => {
          if (id === requestId)
            resolve(0 /* Ok */);
          return id === requestId;
        });
      });
    }
    automaticPositionReportActive() {
      return this.automaticPositionReportIsActive;
    }
    async toggleAutomaticPositionReport() {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcToggleAutomaticPositionReport", requestId, true, false);
        this.genericRequestResponseCallbacks.push((id) => {
          if (id === requestId)
            resolve(0 /* Ok */);
          return id === requestId;
        });
      });
    }
    async receivePositionReportData() {
      return new Promise((resolve, _reject) => {
        const requestId = this.requestId++;
        this.publisher.pub("atcRequestPositionReport", requestId, true, false);
        this.positionReportDataCallbacks.push((response, id) => {
          if (id === requestId)
            resolve(response);
          return id === requestId;
        });
      });
    }
    resetAtisAutoUpdate() {
      this.publisher.pub("atcResetAtisAutoUpdate", true, true, false);
    }
    async connectToNetworks(callsign) {
      return new Promise((resolve, _reject) => {
        const disconnectRequestId = this.requestId++;
        this.publisher.pub("routerDisconnect", disconnectRequestId, true, false);
        this.routerResponseCallbacks.push((_code, id) => {
          if (id === disconnectRequestId) {
            const connectRequestId = this.requestId++;
            this.publisher.pub("routerConnect", { callsign, requestId: connectRequestId }, true, false);
            this.routerResponseCallbacks.push((code, id2) => {
              if (id2 === connectRequestId)
                resolve(code);
              return id2 === connectRequestId;
            });
          }
          return id === disconnectRequestId;
        });
      });
    }
    getDatalinkStatus(value) {
      switch (value) {
        case "vhf":
          return this.datalinkStatus.vhf;
        case "satcom":
          return this.datalinkStatus.satellite;
        case "hf":
          return this.datalinkStatus.hf;
        default:
          return 99;
      }
    }
    getDatalinkMode(value) {
      switch (value) {
        case "vhf":
          return this.datalinkMode.vhf;
        case "satcom":
          return this.datalinkMode.satellite;
        case "hf":
          return this.datalinkMode.hf;
        default:
          return 99;
      }
    }
  };
  return __toCommonJS(src_exports);
})();
//# sourceMappingURL=fmsclient.js.map
