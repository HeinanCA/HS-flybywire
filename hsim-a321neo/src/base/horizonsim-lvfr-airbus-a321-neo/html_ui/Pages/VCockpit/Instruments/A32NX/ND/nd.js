'use strict';
/* global BaseInstrument */
/* global registerInstrument */
class InstrumentLogic extends BaseInstrument {
    constructor() {
        super();
        let lastTime = this._lastTime;
        this.getDeltaTime = () => {
            const nowTime = Date.now();
            const deltaTime = nowTime - lastTime;
            lastTime = nowTime;
            return deltaTime;
        };
    }

    get templateID() {
        return 'ND';
    }

    get isInteractive() {
        return true;
    }

    get IsGlassCockpit() {
        return true;
    }

    connectedCallback() {
        super.connectedCallback();
        (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __commonJS = (cb, mod4) => function __require() {
    return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
  };
  var __export = (target, all) => {
    for (var name69 in all)
      __defProp(target, name69, { get: all[name69], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
    isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
    mod4
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "../node_modules/object-assign/index.js"(exports, module2) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // ../node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "../node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      var l = require_object_assign();
      var n = 60103;
      var p = 60106;
      exports.Fragment = 60107;
      exports.StrictMode = 60108;
      exports.Profiler = 60114;
      var q = 60109;
      var r = 60110;
      var t = 60112;
      exports.Suspense = 60113;
      var u = 60115;
      var v = 60116;
      if ("function" === typeof Symbol && Symbol.for) {
        w = Symbol.for;
        n = w("react.element");
        p = w("react.portal");
        exports.Fragment = w("react.fragment");
        exports.StrictMode = w("react.strict_mode");
        exports.Profiler = w("react.profiler");
        q = w("react.provider");
        r = w("react.context");
        t = w("react.forward_ref");
        exports.Suspense = w("react.suspense");
        u = w("react.memo");
        v = w("react.lazy");
      }
      var w;
      var x = "function" === typeof Symbol && Symbol.iterator;
      function y(a) {
        if (null === a || "object" !== typeof a)
          return null;
        a = x && a[x] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      function z(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
          b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var A = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var B = {};
      function C(a, b, c) {
        this.props = a;
        this.context = b;
        this.refs = B;
        this.updater = c || A;
      }
      C.prototype.isReactComponent = {};
      C.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a)
          throw Error(z(85));
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      C.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function D() {
      }
      D.prototype = C.prototype;
      function E(a, b, c) {
        this.props = a;
        this.context = b;
        this.refs = B;
        this.updater = c || A;
      }
      var F = E.prototype = new D();
      F.constructor = E;
      l(F, C.prototype);
      F.isPureReactComponent = true;
      var G = { current: null };
      var H = Object.prototype.hasOwnProperty;
      var I = { key: true, ref: true, __self: true, __source: true };
      function J(a, b, c) {
        var e, d = {}, k = null, h = null;
        if (null != b)
          for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
            H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
        var g = arguments.length - 2;
        if (1 === g)
          d.children = c;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++)
            f[m] = arguments[m + 2];
          d.children = f;
        }
        if (a && a.defaultProps)
          for (e in g = a.defaultProps, g)
            void 0 === d[e] && (d[e] = g[e]);
        return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G.current };
      }
      function K(a, b) {
        return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function L(a) {
        return "object" === typeof a && null !== a && a.$$typeof === n;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var M = /\/+/g;
      function N(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function O(a, b, c, e, d) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k)
          a = null;
        var h = false;
        if (null === a)
          h = true;
        else
          switch (k) {
            case "string":
            case "number":
              h = true;
              break;
            case "object":
              switch (a.$$typeof) {
                case n:
                case p:
                  h = true;
              }
          }
        if (h)
          return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function(a2) {
            return a2;
          })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
        h = 0;
        e = "" === e ? "." : e + ":";
        if (Array.isArray(a))
          for (var g = 0; g < a.length; g++) {
            k = a[g];
            var f = e + N(k, g);
            h += O(k, b, c, f, d);
          }
        else if (f = y(a), "function" === typeof f)
          for (a = f.call(a), g = 0; !(k = a.next()).done; )
            k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
        else if ("object" === k)
          throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
        return h;
      }
      function P2(a, b, c) {
        if (null == a)
          return a;
        var e = [], d = 0;
        O(a, e, "", "", function(a2) {
          return b.call(c, a2, d++);
        });
        return e;
      }
      function Q(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          a._status = 0;
          a._result = b;
          b.then(function(b2) {
            0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
          }, function(b2) {
            0 === a._status && (a._status = 2, a._result = b2);
          });
        }
        if (1 === a._status)
          return a._result;
        throw a._result;
      }
      var R = { current: null };
      function S() {
        var a = R.current;
        if (null === a)
          throw Error(z(321));
        return a;
      }
      var T = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G, IsSomeRendererActing: { current: false }, assign: l };
      exports.Children = { map: P2, forEach: function(a, b, c) {
        P2(a, function() {
          b.apply(this, arguments);
        }, c);
      }, count: function(a) {
        var b = 0;
        P2(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return P2(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!L(a))
          throw Error(z(143));
        return a;
      } };
      exports.Component = C;
      exports.PureComponent = E;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;
      exports.cloneElement = function(a, b, c) {
        if (null === a || void 0 === a)
          throw Error(z(267, a));
        var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = G.current);
          void 0 !== b.key && (d = "" + b.key);
          if (a.type && a.type.defaultProps)
            var g = a.type.defaultProps;
          for (f in b)
            H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f)
          e.children = c;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++)
            g[m] = arguments[m + 2];
          e.children = g;
        }
        return {
          $$typeof: n,
          type: a.type,
          key: d,
          ref: k,
          props: e,
          _owner: h
        };
      };
      exports.createContext = function(a, b) {
        void 0 === b && (b = null);
        a = { $$typeof: r, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
        a.Provider = { $$typeof: q, _context: a };
        return a.Consumer = a;
      };
      exports.createElement = J;
      exports.createFactory = function(a) {
        var b = J.bind(null, a);
        b.type = a;
        return b;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a) {
        return { $$typeof: t, render: a };
      };
      exports.isValidElement = L;
      exports.lazy = function(a) {
        return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
      };
      exports.memo = function(a, b) {
        return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
      };
      exports.useCallback = function(a, b) {
        return S().useCallback(a, b);
      };
      exports.useContext = function(a, b) {
        return S().useContext(a, b);
      };
      exports.useDebugValue = function() {
      };
      exports.useEffect = function(a, b) {
        return S().useEffect(a, b);
      };
      exports.useImperativeHandle = function(a, b, c) {
        return S().useImperativeHandle(a, b, c);
      };
      exports.useLayoutEffect = function(a, b) {
        return S().useLayoutEffect(a, b);
      };
      exports.useMemo = function(a, b) {
        return S().useMemo(a, b);
      };
      exports.useReducer = function(a, b, c) {
        return S().useReducer(a, b, c);
      };
      exports.useRef = function(a) {
        return S().useRef(a);
      };
      exports.useState = function(a) {
        return S().useState(a);
      };
      exports.version = "17.0.2";
    }
  });

  // ../node_modules/react/index.js
  var require_react = __commonJS({
    "../node_modules/react/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_react_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // ../node_modules/typed-function/typed-function.js
  var require_typed_function = __commonJS({
    "../node_modules/typed-function/typed-function.js"(exports, module2) {
      "use strict";
      (function(root, factory2) {
        if (typeof define === "function" && define.amd) {
          define([], factory2);
        } else if (typeof exports === "object") {
          module2.exports = factory2();
        } else {
          root.typed = factory2();
        }
      })(exports, function() {
        function ok() {
          return true;
        }
        function notOk() {
          return false;
        }
        function undef() {
          return void 0;
        }
        function create() {
          var _types = [
            { name: "number", test: function(x) {
              return typeof x === "number";
            } },
            { name: "string", test: function(x) {
              return typeof x === "string";
            } },
            { name: "boolean", test: function(x) {
              return typeof x === "boolean";
            } },
            { name: "Function", test: function(x) {
              return typeof x === "function";
            } },
            { name: "Array", test: Array.isArray },
            { name: "Date", test: function(x) {
              return x instanceof Date;
            } },
            { name: "RegExp", test: function(x) {
              return x instanceof RegExp;
            } },
            { name: "Object", test: function(x) {
              return typeof x === "object" && x !== null && x.constructor === Object;
            } },
            { name: "null", test: function(x) {
              return x === null;
            } },
            { name: "undefined", test: function(x) {
              return x === void 0;
            } }
          ];
          var anyType = {
            name: "any",
            test: ok
          };
          var _ignore = [];
          var _conversions = [];
          var typed2 = {
            types: _types,
            conversions: _conversions,
            ignore: _ignore
          };
          function findTypeByName(typeName) {
            var entry = findInArray(typed2.types, function(entry2) {
              return entry2.name === typeName;
            });
            if (entry) {
              return entry;
            }
            if (typeName === "any") {
              return anyType;
            }
            var hint = findInArray(typed2.types, function(entry2) {
              return entry2.name.toLowerCase() === typeName.toLowerCase();
            });
            throw new TypeError('Unknown type "' + typeName + '"' + (hint ? '. Did you mean "' + hint.name + '"?' : ""));
          }
          function findTypeIndex(type) {
            if (type === anyType) {
              return 999;
            }
            return typed2.types.indexOf(type);
          }
          function findTypeName(value) {
            var entry = findInArray(typed2.types, function(entry2) {
              return entry2.test(value);
            });
            if (entry) {
              return entry.name;
            }
            throw new TypeError("Value has unknown type. Value: " + value);
          }
          function find(fn, signature) {
            if (!fn.signatures) {
              throw new TypeError("Function is no typed-function");
            }
            var arr;
            if (typeof signature === "string") {
              arr = signature.split(",");
              for (var i = 0; i < arr.length; i++) {
                arr[i] = arr[i].trim();
              }
            } else if (Array.isArray(signature)) {
              arr = signature;
            } else {
              throw new TypeError("String array or a comma separated string expected");
            }
            var str = arr.join(",");
            var match = fn.signatures[str];
            if (match) {
              return match;
            }
            throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + arr.join(", ") + "))");
          }
          function convert(value, type) {
            var from = findTypeName(value);
            if (type === from) {
              return value;
            }
            for (var i = 0; i < typed2.conversions.length; i++) {
              var conversion = typed2.conversions[i];
              if (conversion.from === from && conversion.to === type) {
                return conversion.convert(value);
              }
            }
            throw new Error("Cannot convert from " + from + " to " + type);
          }
          function stringifyParams(params) {
            return params.map(function(param) {
              var typeNames = param.types.map(getTypeName);
              return (param.restParam ? "..." : "") + typeNames.join("|");
            }).join(",");
          }
          function parseParam(param, conversions) {
            var restParam = param.indexOf("...") === 0;
            var types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
            var typeNames = types.split("|").map(trim).filter(notEmpty).filter(notIgnore);
            var matchingConversions = filterConversions(conversions, typeNames);
            var exactTypes = typeNames.map(function(typeName) {
              var type = findTypeByName(typeName);
              return {
                name: typeName,
                typeIndex: findTypeIndex(type),
                test: type.test,
                conversion: null,
                conversionIndex: -1
              };
            });
            var convertibleTypes = matchingConversions.map(function(conversion) {
              var type = findTypeByName(conversion.from);
              return {
                name: conversion.from,
                typeIndex: findTypeIndex(type),
                test: type.test,
                conversion,
                conversionIndex: conversions.indexOf(conversion)
              };
            });
            return {
              types: exactTypes.concat(convertibleTypes),
              restParam
            };
          }
          function parseSignature(signature, fn, conversions) {
            var params = [];
            if (signature.trim() !== "") {
              params = signature.split(",").map(trim).map(function(param, index, array) {
                var parsedParam = parseParam(param, conversions);
                if (parsedParam.restParam && index !== array.length - 1) {
                  throw new SyntaxError('Unexpected rest parameter "' + param + '": only allowed for the last parameter');
                }
                return parsedParam;
              });
            }
            if (params.some(isInvalidParam)) {
              return null;
            }
            return {
              params,
              fn
            };
          }
          function hasRestParam(params) {
            var param = last(params);
            return param ? param.restParam : false;
          }
          function hasConversions(param) {
            return param.types.some(function(type) {
              return type.conversion != null;
            });
          }
          function compileTest(param) {
            if (!param || param.types.length === 0) {
              return ok;
            } else if (param.types.length === 1) {
              return findTypeByName(param.types[0].name).test;
            } else if (param.types.length === 2) {
              var test0 = findTypeByName(param.types[0].name).test;
              var test1 = findTypeByName(param.types[1].name).test;
              return function or(x) {
                return test0(x) || test1(x);
              };
            } else {
              var tests = param.types.map(function(type) {
                return findTypeByName(type.name).test;
              });
              return function or(x) {
                for (var i = 0; i < tests.length; i++) {
                  if (tests[i](x)) {
                    return true;
                  }
                }
                return false;
              };
            }
          }
          function compileTests(params) {
            var tests, test0, test1;
            if (hasRestParam(params)) {
              tests = initial(params).map(compileTest);
              var varIndex = tests.length;
              var lastTest = compileTest(last(params));
              var testRestParam = function(args) {
                for (var i = varIndex; i < args.length; i++) {
                  if (!lastTest(args[i])) {
                    return false;
                  }
                }
                return true;
              };
              return function testArgs(args) {
                for (var i = 0; i < tests.length; i++) {
                  if (!tests[i](args[i])) {
                    return false;
                  }
                }
                return testRestParam(args) && args.length >= varIndex + 1;
              };
            } else {
              if (params.length === 0) {
                return function testArgs(args) {
                  return args.length === 0;
                };
              } else if (params.length === 1) {
                test0 = compileTest(params[0]);
                return function testArgs(args) {
                  return test0(args[0]) && args.length === 1;
                };
              } else if (params.length === 2) {
                test0 = compileTest(params[0]);
                test1 = compileTest(params[1]);
                return function testArgs(args) {
                  return test0(args[0]) && test1(args[1]) && args.length === 2;
                };
              } else {
                tests = params.map(compileTest);
                return function testArgs(args) {
                  for (var i = 0; i < tests.length; i++) {
                    if (!tests[i](args[i])) {
                      return false;
                    }
                  }
                  return args.length === tests.length;
                };
              }
            }
          }
          function getParamAtIndex(signature, index) {
            return index < signature.params.length ? signature.params[index] : hasRestParam(signature.params) ? last(signature.params) : null;
          }
          function getExpectedTypeNames(signature, index, excludeConversions) {
            var param = getParamAtIndex(signature, index);
            var types = param ? excludeConversions ? param.types.filter(isExactType) : param.types : [];
            return types.map(getTypeName);
          }
          function getTypeName(type) {
            return type.name;
          }
          function isExactType(type) {
            return type.conversion === null || type.conversion === void 0;
          }
          function mergeExpectedParams(signatures, index) {
            var typeNames = uniq(flatMap(signatures, function(signature) {
              return getExpectedTypeNames(signature, index, false);
            }));
            return typeNames.indexOf("any") !== -1 ? ["any"] : typeNames;
          }
          function createError(name69, args, signatures) {
            var err, expected;
            var _name = name69 || "unnamed";
            var matchingSignatures = signatures;
            var index;
            for (index = 0; index < args.length; index++) {
              var nextMatchingDefs = matchingSignatures.filter(function(signature) {
                var test = compileTest(getParamAtIndex(signature, index));
                return (index < signature.params.length || hasRestParam(signature.params)) && test(args[index]);
              });
              if (nextMatchingDefs.length === 0) {
                expected = mergeExpectedParams(matchingSignatures, index);
                if (expected.length > 0) {
                  var actualType = findTypeName(args[index]);
                  err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualType + ", index: " + index + ")");
                  err.data = {
                    category: "wrongType",
                    fn: _name,
                    index,
                    actual: actualType,
                    expected
                  };
                  return err;
                }
              } else {
                matchingSignatures = nextMatchingDefs;
              }
            }
            var lengths = matchingSignatures.map(function(signature) {
              return hasRestParam(signature.params) ? Infinity : signature.params.length;
            });
            if (args.length < Math.min.apply(null, lengths)) {
              expected = mergeExpectedParams(matchingSignatures, index);
              err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
              err.data = {
                category: "tooFewArgs",
                fn: _name,
                index: args.length,
                expected
              };
              return err;
            }
            var maxLength = Math.max.apply(null, lengths);
            if (args.length > maxLength) {
              err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
              err.data = {
                category: "tooManyArgs",
                fn: _name,
                index: args.length,
                expectedLength: maxLength
              };
              return err;
            }
            err = new TypeError('Arguments of type "' + args.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
            err.data = {
              category: "mismatch",
              actual: args.map(findTypeName)
            };
            return err;
          }
          function getLowestTypeIndex(param) {
            var min2 = 999;
            for (var i = 0; i < param.types.length; i++) {
              if (isExactType(param.types[i])) {
                min2 = Math.min(min2, param.types[i].typeIndex);
              }
            }
            return min2;
          }
          function getLowestConversionIndex(param) {
            var min2 = 999;
            for (var i = 0; i < param.types.length; i++) {
              if (!isExactType(param.types[i])) {
                min2 = Math.min(min2, param.types[i].conversionIndex);
              }
            }
            return min2;
          }
          function compareParams(param1, param2) {
            var c;
            c = param1.restParam - param2.restParam;
            if (c !== 0) {
              return c;
            }
            c = hasConversions(param1) - hasConversions(param2);
            if (c !== 0) {
              return c;
            }
            c = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
            if (c !== 0) {
              return c;
            }
            return getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
          }
          function compareSignatures(signature1, signature2) {
            var len = Math.min(signature1.params.length, signature2.params.length);
            var i;
            var c;
            c = signature1.params.some(hasConversions) - signature2.params.some(hasConversions);
            if (c !== 0) {
              return c;
            }
            for (i = 0; i < len; i++) {
              c = hasConversions(signature1.params[i]) - hasConversions(signature2.params[i]);
              if (c !== 0) {
                return c;
              }
            }
            for (i = 0; i < len; i++) {
              c = compareParams(signature1.params[i], signature2.params[i]);
              if (c !== 0) {
                return c;
              }
            }
            return signature1.params.length - signature2.params.length;
          }
          function filterConversions(conversions, typeNames) {
            var matches = {};
            conversions.forEach(function(conversion) {
              if (typeNames.indexOf(conversion.from) === -1 && typeNames.indexOf(conversion.to) !== -1 && !matches[conversion.from]) {
                matches[conversion.from] = conversion;
              }
            });
            return Object.keys(matches).map(function(from) {
              return matches[from];
            });
          }
          function compileArgsPreprocessing(params, fn) {
            var fnConvert = fn;
            if (params.some(hasConversions)) {
              var restParam = hasRestParam(params);
              var compiledConversions = params.map(compileArgConversion);
              fnConvert = function convertArgs() {
                var args = [];
                var last2 = restParam ? arguments.length - 1 : arguments.length;
                for (var i = 0; i < last2; i++) {
                  args[i] = compiledConversions[i](arguments[i]);
                }
                if (restParam) {
                  args[last2] = arguments[last2].map(compiledConversions[last2]);
                }
                return fn.apply(this, args);
              };
            }
            var fnPreprocess = fnConvert;
            if (hasRestParam(params)) {
              var offset = params.length - 1;
              fnPreprocess = function preprocessRestParams() {
                return fnConvert.apply(
                  this,
                  slice(arguments, 0, offset).concat([slice(arguments, offset)])
                );
              };
            }
            return fnPreprocess;
          }
          function compileArgConversion(param) {
            var test0, test1, conversion0, conversion1;
            var tests = [];
            var conversions = [];
            param.types.forEach(function(type) {
              if (type.conversion) {
                tests.push(findTypeByName(type.conversion.from).test);
                conversions.push(type.conversion.convert);
              }
            });
            switch (conversions.length) {
              case 0:
                return function convertArg(arg) {
                  return arg;
                };
              case 1:
                test0 = tests[0];
                conversion0 = conversions[0];
                return function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  return arg;
                };
              case 2:
                test0 = tests[0];
                test1 = tests[1];
                conversion0 = conversions[0];
                conversion1 = conversions[1];
                return function convertArg(arg) {
                  if (test0(arg)) {
                    return conversion0(arg);
                  }
                  if (test1(arg)) {
                    return conversion1(arg);
                  }
                  return arg;
                };
              default:
                return function convertArg(arg) {
                  for (var i = 0; i < conversions.length; i++) {
                    if (tests[i](arg)) {
                      return conversions[i](arg);
                    }
                  }
                  return arg;
                };
            }
          }
          function createSignaturesMap(signatures) {
            var signaturesMap = {};
            signatures.forEach(function(signature) {
              if (!signature.params.some(hasConversions)) {
                splitParams(signature.params, true).forEach(function(params) {
                  signaturesMap[stringifyParams(params)] = signature.fn;
                });
              }
            });
            return signaturesMap;
          }
          function splitParams(params, ignoreConversionTypes) {
            function _splitParams(params2, index, types) {
              if (index < params2.length) {
                var param = params2[index];
                var filteredTypes = ignoreConversionTypes ? param.types.filter(isExactType) : param.types;
                var typeGroups;
                if (param.restParam) {
                  var exactTypes = filteredTypes.filter(isExactType);
                  typeGroups = exactTypes.length < filteredTypes.length ? [exactTypes, filteredTypes] : [filteredTypes];
                } else {
                  typeGroups = filteredTypes.map(function(type) {
                    return [type];
                  });
                }
                return flatMap(typeGroups, function(typeGroup) {
                  return _splitParams(params2, index + 1, types.concat([typeGroup]));
                });
              } else {
                var splittedParams = types.map(function(type, typeIndex) {
                  return {
                    types: type,
                    restParam: typeIndex === params2.length - 1 && hasRestParam(params2)
                  };
                });
                return [splittedParams];
              }
            }
            return _splitParams(params, 0, []);
          }
          function hasConflictingParams(signature1, signature2) {
            var ii = Math.max(signature1.params.length, signature2.params.length);
            for (var i = 0; i < ii; i++) {
              var typesNames1 = getExpectedTypeNames(signature1, i, true);
              var typesNames2 = getExpectedTypeNames(signature2, i, true);
              if (!hasOverlap(typesNames1, typesNames2)) {
                return false;
              }
            }
            var len1 = signature1.params.length;
            var len2 = signature2.params.length;
            var restParam1 = hasRestParam(signature1.params);
            var restParam2 = hasRestParam(signature2.params);
            return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
          }
          function createTypedFunction(name69, signaturesMap) {
            if (Object.keys(signaturesMap).length === 0) {
              throw new SyntaxError("No signatures provided");
            }
            var parsedSignatures = [];
            Object.keys(signaturesMap).map(function(signature) {
              return parseSignature(signature, signaturesMap[signature], typed2.conversions);
            }).filter(notNull).forEach(function(parsedSignature) {
              var conflictingSignature = findInArray(parsedSignatures, function(s) {
                return hasConflictingParams(s, parsedSignature);
              });
              if (conflictingSignature) {
                throw new TypeError('Conflicting signatures "' + stringifyParams(conflictingSignature.params) + '" and "' + stringifyParams(parsedSignature.params) + '".');
              }
              parsedSignatures.push(parsedSignature);
            });
            var signatures = flatMap(parsedSignatures, function(parsedSignature) {
              var params = parsedSignature ? splitParams(parsedSignature.params, false) : [];
              return params.map(function(params2) {
                return {
                  params: params2,
                  fn: parsedSignature.fn
                };
              });
            }).filter(notNull);
            signatures.sort(compareSignatures);
            var ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
            var ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
            var ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
            var ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
            var ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
            var ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
            var allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
            var tests = signatures.map(function(signature) {
              return compileTests(signature.params);
            });
            var test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
            var test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
            var test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
            var test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
            var test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
            var test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
            var test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
            var test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
            var test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
            var test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
            var test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
            var test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
            var fns = signatures.map(function(signature) {
              return compileArgsPreprocessing(signature.params, signature.fn);
            });
            var fn0 = ok0 ? fns[0] : undef;
            var fn1 = ok1 ? fns[1] : undef;
            var fn2 = ok2 ? fns[2] : undef;
            var fn3 = ok3 ? fns[3] : undef;
            var fn4 = ok4 ? fns[4] : undef;
            var fn5 = ok5 ? fns[5] : undef;
            var len0 = ok0 ? signatures[0].params.length : -1;
            var len1 = ok1 ? signatures[1].params.length : -1;
            var len2 = ok2 ? signatures[2].params.length : -1;
            var len3 = ok3 ? signatures[3].params.length : -1;
            var len4 = ok4 ? signatures[4].params.length : -1;
            var len5 = ok5 ? signatures[5].params.length : -1;
            var iStart = allOk ? 6 : 0;
            var iEnd = signatures.length;
            var generic = function generic2() {
              "use strict";
              for (var i = iStart; i < iEnd; i++) {
                if (tests[i](arguments)) {
                  return fns[i].apply(this, arguments);
                }
              }
              return typed2.onMismatch(name69, arguments, signatures);
            };
            var fn = function fn6(arg0, arg1) {
              "use strict";
              if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                return fn0.apply(fn6, arguments);
              }
              if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                return fn1.apply(fn6, arguments);
              }
              if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                return fn2.apply(fn6, arguments);
              }
              if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                return fn3.apply(fn6, arguments);
              }
              if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                return fn4.apply(fn6, arguments);
              }
              if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                return fn5.apply(fn6, arguments);
              }
              return generic.apply(fn6, arguments);
            };
            try {
              Object.defineProperty(fn, "name", { value: name69 });
            } catch (err) {
            }
            fn.signatures = createSignaturesMap(signatures);
            return fn;
          }
          function _onMismatch(name69, args, signatures) {
            throw createError(name69, args, signatures);
          }
          function notIgnore(typeName) {
            return typed2.ignore.indexOf(typeName) === -1;
          }
          function trim(str) {
            return str.trim();
          }
          function notEmpty(str) {
            return !!str;
          }
          function notNull(value) {
            return value !== null;
          }
          function isInvalidParam(param) {
            return param.types.length === 0;
          }
          function initial(arr) {
            return arr.slice(0, arr.length - 1);
          }
          function last(arr) {
            return arr[arr.length - 1];
          }
          function slice(arr, start, end) {
            return Array.prototype.slice.call(arr, start, end);
          }
          function contains(array, item) {
            return array.indexOf(item) !== -1;
          }
          function hasOverlap(array1, array2) {
            for (var i = 0; i < array1.length; i++) {
              if (contains(array2, array1[i])) {
                return true;
              }
            }
            return false;
          }
          function findInArray(arr, test) {
            for (var i = 0; i < arr.length; i++) {
              if (test(arr[i])) {
                return arr[i];
              }
            }
            return void 0;
          }
          function uniq(arr) {
            var entries = {};
            for (var i = 0; i < arr.length; i++) {
              entries[arr[i]] = true;
            }
            return Object.keys(entries);
          }
          function flatMap(arr, callback) {
            return Array.prototype.concat.apply([], arr.map(callback));
          }
          function getName(fns) {
            var name69 = "";
            for (var i = 0; i < fns.length; i++) {
              var fn = fns[i];
              if ((typeof fn.signatures === "object" || typeof fn.signature === "string") && fn.name !== "") {
                if (name69 === "") {
                  name69 = fn.name;
                } else if (name69 !== fn.name) {
                  var err = new Error("Function names do not match (expected: " + name69 + ", actual: " + fn.name + ")");
                  err.data = {
                    actual: fn.name,
                    expected: name69
                  };
                  throw err;
                }
              }
            }
            return name69;
          }
          function extractSignatures(fns) {
            var err;
            var signaturesMap = {};
            function validateUnique(_signature, _fn) {
              if (signaturesMap.hasOwnProperty(_signature) && _fn !== signaturesMap[_signature]) {
                err = new Error('Signature "' + _signature + '" is defined twice');
                err.data = { signature: _signature };
                throw err;
              }
            }
            for (var i = 0; i < fns.length; i++) {
              var fn = fns[i];
              if (typeof fn.signatures === "object") {
                for (var signature in fn.signatures) {
                  if (fn.signatures.hasOwnProperty(signature)) {
                    validateUnique(signature, fn.signatures[signature]);
                    signaturesMap[signature] = fn.signatures[signature];
                  }
                }
              } else if (typeof fn.signature === "string") {
                validateUnique(fn.signature, fn);
                signaturesMap[fn.signature] = fn;
              } else {
                err = new TypeError("Function is no typed-function (index: " + i + ")");
                err.data = { index: i };
                throw err;
              }
            }
            return signaturesMap;
          }
          typed2 = createTypedFunction("typed", {
            "string, Object": createTypedFunction,
            "Object": function(signaturesMap) {
              var fns = [];
              for (var signature in signaturesMap) {
                if (signaturesMap.hasOwnProperty(signature)) {
                  fns.push(signaturesMap[signature]);
                }
              }
              var name69 = getName(fns);
              return createTypedFunction(name69, signaturesMap);
            },
            "...Function": function(fns) {
              return createTypedFunction(getName(fns), extractSignatures(fns));
            },
            "string, ...Function": function(name69, fns) {
              return createTypedFunction(name69, extractSignatures(fns));
            }
          });
          typed2.create = create;
          typed2.types = _types;
          typed2.conversions = _conversions;
          typed2.ignore = _ignore;
          typed2.onMismatch = _onMismatch;
          typed2.throwMismatchError = _onMismatch;
          typed2.createError = createError;
          typed2.convert = convert;
          typed2.find = find;
          typed2.addType = function(type, beforeObjectTest) {
            if (!type || typeof type.name !== "string" || typeof type.test !== "function") {
              throw new TypeError("Object with properties {name: string, test: function} expected");
            }
            if (beforeObjectTest !== false) {
              for (var i = 0; i < typed2.types.length; i++) {
                if (typed2.types[i].name === "Object") {
                  typed2.types.splice(i, 0, type);
                  return;
                }
              }
            }
            typed2.types.push(type);
          };
          typed2.addConversion = function(conversion) {
            if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
              throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
            }
            typed2.conversions.push(conversion);
          };
          return typed2;
        }
        return create();
      });
    }
  });

  // ../node_modules/complex.js/complex.js
  var require_complex = __commonJS({
    "../node_modules/complex.js/complex.js"(exports, module2) {
      (function(root) {
        "use strict";
        var cosh2 = Math.cosh || function(x) {
          return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
        };
        var sinh2 = Math.sinh || function(x) {
          return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
        };
        var cosm1 = function(x) {
          var b = Math.PI / 4;
          if (-b > x || x > b) {
            return Math.cos(x) - 1;
          }
          var xx = x * x;
          return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
        };
        var hypot2 = function(x, y) {
          var a = Math.abs(x);
          var b = Math.abs(y);
          if (a < 3e3 && b < 3e3) {
            return Math.sqrt(a * a + b * b);
          }
          if (a < b) {
            a = b;
            b = x / y;
          } else {
            b = y / x;
          }
          return a * Math.sqrt(1 + b * b);
        };
        var parser_exit = function() {
          throw SyntaxError("Invalid Param");
        };
        function logHypot(a, b) {
          var _a = Math.abs(a);
          var _b = Math.abs(b);
          if (a === 0) {
            return Math.log(_b);
          }
          if (b === 0) {
            return Math.log(_a);
          }
          if (_a < 3e3 && _b < 3e3) {
            return Math.log(a * a + b * b) * 0.5;
          }
          a = a / 2;
          b = b / 2;
          return 0.5 * Math.log(a * a + b * b) + Math.LN2;
        }
        var parse = function(a, b) {
          var z = { "re": 0, "im": 0 };
          if (a === void 0 || a === null) {
            z["re"] = z["im"] = 0;
          } else if (b !== void 0) {
            z["re"] = a;
            z["im"] = b;
          } else
            switch (typeof a) {
              case "object":
                if ("im" in a && "re" in a) {
                  z["re"] = a["re"];
                  z["im"] = a["im"];
                } else if ("abs" in a && "arg" in a) {
                  if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                    return Complex3["INFINITY"];
                  }
                  z["re"] = a["abs"] * Math.cos(a["arg"]);
                  z["im"] = a["abs"] * Math.sin(a["arg"]);
                } else if ("r" in a && "phi" in a) {
                  if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                    return Complex3["INFINITY"];
                  }
                  z["re"] = a["r"] * Math.cos(a["phi"]);
                  z["im"] = a["r"] * Math.sin(a["phi"]);
                } else if (a.length === 2) {
                  z["re"] = a[0];
                  z["im"] = a[1];
                } else {
                  parser_exit();
                }
                break;
              case "string":
                z["im"] = z["re"] = 0;
                var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
                var plus = 1;
                var minus = 0;
                if (tokens === null) {
                  parser_exit();
                }
                for (var i = 0; i < tokens.length; i++) {
                  var c = tokens[i];
                  if (c === " " || c === "	" || c === "\n") {
                  } else if (c === "+") {
                    plus++;
                  } else if (c === "-") {
                    minus++;
                  } else if (c === "i" || c === "I") {
                    if (plus + minus === 0) {
                      parser_exit();
                    }
                    if (tokens[i + 1] !== " " && !isNaN(tokens[i + 1])) {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i + 1]);
                      i++;
                    } else {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                    }
                    plus = minus = 0;
                  } else {
                    if (plus + minus === 0 || isNaN(c)) {
                      parser_exit();
                    }
                    if (tokens[i + 1] === "i" || tokens[i + 1] === "I") {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                      i++;
                    } else {
                      z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                    }
                    plus = minus = 0;
                  }
                }
                if (plus + minus > 0) {
                  parser_exit();
                }
                break;
              case "number":
                z["im"] = 0;
                z["re"] = a;
                break;
              default:
                parser_exit();
            }
          if (isNaN(z["re"]) || isNaN(z["im"])) {
          }
          return z;
        };
        function Complex3(a, b) {
          if (!(this instanceof Complex3)) {
            return new Complex3(a, b);
          }
          var z = parse(a, b);
          this["re"] = z["re"];
          this["im"] = z["im"];
        }
        Complex3.prototype = {
          "re": 0,
          "im": 0,
          "sign": function() {
            var abs3 = this["abs"]();
            return new Complex3(
              this["re"] / abs3,
              this["im"] / abs3
            );
          },
          "add": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isInfinite"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            return new Complex3(
              this["re"] + z["re"],
              this["im"] + z["im"]
            );
          },
          "sub": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isInfinite"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            return new Complex3(
              this["re"] - z["re"],
              this["im"] - z["im"]
            );
          },
          "mul": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            if (z["im"] === 0 && this["im"] === 0) {
              return new Complex3(this["re"] * z["re"], 0);
            }
            return new Complex3(
              this["re"] * z["re"] - this["im"] * z["im"],
              this["re"] * z["im"] + this["im"] * z["re"]
            );
          },
          "div": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isZero"]()) {
              return Complex3["INFINITY"];
            }
            if (this["isZero"]() || z["isInfinite"]()) {
              return Complex3["ZERO"];
            }
            a = this["re"];
            b = this["im"];
            var c = z["re"];
            var d = z["im"];
            var t, x;
            if (0 === d) {
              return new Complex3(a / c, b / c);
            }
            if (Math.abs(c) < Math.abs(d)) {
              x = c / d;
              t = c * x + d;
              return new Complex3(
                (a * x + b) / t,
                (b * x - a) / t
              );
            } else {
              x = d / c;
              t = d * x + c;
              return new Complex3(
                (a + b * x) / t,
                (b - a * x) / t
              );
            }
          },
          "pow": function(a, b) {
            var z = new Complex3(a, b);
            a = this["re"];
            b = this["im"];
            if (z["isZero"]()) {
              return Complex3["ONE"];
            }
            if (z["im"] === 0) {
              if (b === 0 && a > 0) {
                return new Complex3(Math.pow(a, z["re"]), 0);
              } else if (a === 0) {
                switch ((z["re"] % 4 + 4) % 4) {
                  case 0:
                    return new Complex3(Math.pow(b, z["re"]), 0);
                  case 1:
                    return new Complex3(0, Math.pow(b, z["re"]));
                  case 2:
                    return new Complex3(-Math.pow(b, z["re"]), 0);
                  case 3:
                    return new Complex3(0, -Math.pow(b, z["re"]));
                }
              }
            }
            if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
              return Complex3["ZERO"];
            }
            var arg = Math.atan2(b, a);
            var loh = logHypot(a, b);
            a = Math.exp(z["re"] * loh - z["im"] * arg);
            b = z["im"] * loh + z["re"] * arg;
            return new Complex3(
              a * Math.cos(b),
              a * Math.sin(b)
            );
          },
          "sqrt": function() {
            var a = this["re"];
            var b = this["im"];
            var r = this["abs"]();
            var re2, im2;
            if (a >= 0) {
              if (b === 0) {
                return new Complex3(Math.sqrt(a), 0);
              }
              re2 = 0.5 * Math.sqrt(2 * (r + a));
            } else {
              re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
            }
            if (a <= 0) {
              im2 = 0.5 * Math.sqrt(2 * (r - a));
            } else {
              im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
            }
            return new Complex3(re2, b < 0 ? -im2 : im2);
          },
          "exp": function() {
            var tmp = Math.exp(this["re"]);
            if (this["im"] === 0) {
            }
            return new Complex3(
              tmp * Math.cos(this["im"]),
              tmp * Math.sin(this["im"])
            );
          },
          "expm1": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              Math.expm1(a) * Math.cos(b) + cosm1(b),
              Math.exp(a) * Math.sin(b)
            );
          },
          "log": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0 && a > 0) {
            }
            return new Complex3(
              logHypot(a, b),
              Math.atan2(b, a)
            );
          },
          "abs": function() {
            return hypot2(this["re"], this["im"]);
          },
          "arg": function() {
            return Math.atan2(this["im"], this["re"]);
          },
          "sin": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              Math.sin(a) * cosh2(b),
              Math.cos(a) * sinh2(b)
            );
          },
          "cos": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              Math.cos(a) * cosh2(b),
              -Math.sin(a) * sinh2(b)
            );
          },
          "tan": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = Math.cos(a) + cosh2(b);
            return new Complex3(
              Math.sin(a) / d,
              sinh2(b) / d
            );
          },
          "cot": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = Math.cos(a) - cosh2(b);
            return new Complex3(
              -Math.sin(a) / d,
              sinh2(b) / d
            );
          },
          "sec": function() {
            var a = this["re"];
            var b = this["im"];
            var d = 0.5 * cosh2(2 * b) + 0.5 * Math.cos(2 * a);
            return new Complex3(
              Math.cos(a) * cosh2(b) / d,
              Math.sin(a) * sinh2(b) / d
            );
          },
          "csc": function() {
            var a = this["re"];
            var b = this["im"];
            var d = 0.5 * cosh2(2 * b) - 0.5 * Math.cos(2 * a);
            return new Complex3(
              Math.sin(a) * cosh2(b) / d,
              -Math.cos(a) * sinh2(b) / d
            );
          },
          "asin": function() {
            var a = this["re"];
            var b = this["im"];
            var t1 = new Complex3(
              b * b - a * a + 1,
              -2 * a * b
            )["sqrt"]();
            var t2 = new Complex3(
              t1["re"] - b,
              t1["im"] + a
            )["log"]();
            return new Complex3(t2["im"], -t2["re"]);
          },
          "acos": function() {
            var a = this["re"];
            var b = this["im"];
            var t1 = new Complex3(
              b * b - a * a + 1,
              -2 * a * b
            )["sqrt"]();
            var t2 = new Complex3(
              t1["re"] - b,
              t1["im"] + a
            )["log"]();
            return new Complex3(Math.PI / 2 - t2["im"], t2["re"]);
          },
          "atan": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0) {
              if (b === 1) {
                return new Complex3(0, Infinity);
              }
              if (b === -1) {
                return new Complex3(0, -Infinity);
              }
            }
            var d = a * a + (1 - b) * (1 - b);
            var t1 = new Complex3(
              (1 - b * b - a * a) / d,
              -2 * a / d
            ).log();
            return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
          },
          "acot": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0) {
              return new Complex3(Math.atan2(1, a), 0);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).atan() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).atan();
          },
          "asec": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex3(0, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).acos() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).acos();
          },
          "acsc": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex3(Math.PI / 2, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).asin() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).asin();
          },
          "sinh": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              sinh2(a) * Math.cos(b),
              cosh2(a) * Math.sin(b)
            );
          },
          "cosh": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              cosh2(a) * Math.cos(b),
              sinh2(a) * Math.sin(b)
            );
          },
          "tanh": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = cosh2(a) + Math.cos(b);
            return new Complex3(
              sinh2(a) / d,
              Math.sin(b) / d
            );
          },
          "coth": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = cosh2(a) - Math.cos(b);
            return new Complex3(
              sinh2(a) / d,
              -Math.sin(b) / d
            );
          },
          "csch": function() {
            var a = this["re"];
            var b = this["im"];
            var d = Math.cos(2 * b) - cosh2(2 * a);
            return new Complex3(
              -2 * sinh2(a) * Math.cos(b) / d,
              2 * cosh2(a) * Math.sin(b) / d
            );
          },
          "sech": function() {
            var a = this["re"];
            var b = this["im"];
            var d = Math.cos(2 * b) + cosh2(2 * a);
            return new Complex3(
              2 * cosh2(a) * Math.cos(b) / d,
              -2 * sinh2(a) * Math.sin(b) / d
            );
          },
          "asinh": function() {
            var tmp = this["im"];
            this["im"] = -this["re"];
            this["re"] = tmp;
            var res = this["asin"]();
            this["re"] = -this["im"];
            this["im"] = tmp;
            tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
            return res;
          },
          "acosh": function() {
            var res = this["acos"]();
            if (res["im"] <= 0) {
              var tmp = res["re"];
              res["re"] = -res["im"];
              res["im"] = tmp;
            } else {
              var tmp = res["im"];
              res["im"] = -res["re"];
              res["re"] = tmp;
            }
            return res;
          },
          "atanh": function() {
            var a = this["re"];
            var b = this["im"];
            var noIM = a > 1 && b === 0;
            var oneMinus = 1 - a;
            var onePlus = 1 + a;
            var d = oneMinus * oneMinus + b * b;
            var x = d !== 0 ? new Complex3(
              (onePlus * oneMinus - b * b) / d,
              (b * oneMinus + onePlus * b) / d
            ) : new Complex3(
              a !== -1 ? a / 0 : 0,
              b !== 0 ? b / 0 : 0
            );
            var temp = x["re"];
            x["re"] = logHypot(x["re"], x["im"]) / 2;
            x["im"] = Math.atan2(x["im"], temp) / 2;
            if (noIM) {
              x["im"] = -x["im"];
            }
            return x;
          },
          "acoth": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex3(0, Math.PI / 2);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).atanh() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).atanh();
          },
          "acsch": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0) {
              return new Complex3(
                a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
                0
              );
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).asinh() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).asinh();
          },
          "asech": function() {
            var a = this["re"];
            var b = this["im"];
            if (this["isZero"]()) {
              return Complex3["INFINITY"];
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).acosh() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).acosh();
          },
          "inverse": function() {
            if (this["isZero"]()) {
              return Complex3["INFINITY"];
            }
            if (this["isInfinite"]()) {
              return Complex3["ZERO"];
            }
            var a = this["re"];
            var b = this["im"];
            var d = a * a + b * b;
            return new Complex3(a / d, -b / d);
          },
          "conjugate": function() {
            return new Complex3(this["re"], -this["im"]);
          },
          "neg": function() {
            return new Complex3(-this["re"], -this["im"]);
          },
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.ceil(this["re"] * places) / places,
              Math.ceil(this["im"] * places) / places
            );
          },
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.floor(this["re"] * places) / places,
              Math.floor(this["im"] * places) / places
            );
          },
          "round": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.round(this["re"] * places) / places,
              Math.round(this["im"] * places) / places
            );
          },
          "equals": function(a, b) {
            var z = new Complex3(a, b);
            return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
          },
          "clone": function() {
            return new Complex3(this["re"], this["im"]);
          },
          "toString": function() {
            var a = this["re"];
            var b = this["im"];
            var ret = "";
            if (this["isNaN"]()) {
              return "NaN";
            }
            if (this["isInfinite"]()) {
              return "Infinity";
            }
            if (Math.abs(a) < Complex3["EPSILON"]) {
              a = 0;
            }
            if (Math.abs(b) < Complex3["EPSILON"]) {
              b = 0;
            }
            if (b === 0) {
              return ret + a;
            }
            if (a !== 0) {
              ret += a;
              ret += " ";
              if (b < 0) {
                b = -b;
                ret += "-";
              } else {
                ret += "+";
              }
              ret += " ";
            } else if (b < 0) {
              b = -b;
              ret += "-";
            }
            if (1 !== b) {
              ret += b;
            }
            return ret + "i";
          },
          "toVector": function() {
            return [this["re"], this["im"]];
          },
          "valueOf": function() {
            if (this["im"] === 0) {
              return this["re"];
            }
            return null;
          },
          "isNaN": function() {
            return isNaN(this["re"]) || isNaN(this["im"]);
          },
          "isZero": function() {
            return this["im"] === 0 && this["re"] === 0;
          },
          "isFinite": function() {
            return isFinite(this["re"]) && isFinite(this["im"]);
          },
          "isInfinite": function() {
            return !(this["isNaN"]() || this["isFinite"]());
          }
        };
        Complex3["ZERO"] = new Complex3(0, 0);
        Complex3["ONE"] = new Complex3(1, 0);
        Complex3["I"] = new Complex3(0, 1);
        Complex3["PI"] = new Complex3(Math.PI, 0);
        Complex3["E"] = new Complex3(Math.E, 0);
        Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
        Complex3["NAN"] = new Complex3(NaN, NaN);
        Complex3["EPSILON"] = 1e-15;
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Complex3;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Complex3, "__esModule", { "value": true });
          Complex3["default"] = Complex3;
          Complex3["Complex"] = Complex3;
          module2["exports"] = Complex3;
        } else {
          root["Complex"] = Complex3;
        }
      })(exports);
    }
  });

  // ../node_modules/fraction.js/fraction.js
  var require_fraction = __commonJS({
    "../node_modules/fraction.js/fraction.js"(exports, module2) {
      (function(root) {
        "use strict";
        var MAX_CYCLE_LEN = 2e3;
        var P2 = {
          "s": 1,
          "n": 0,
          "d": 1
        };
        function assign(n, s) {
          if (isNaN(n = parseInt(n, 10))) {
            throw Fraction3["InvalidParameter"];
          }
          return n * s;
        }
        function newFraction(n, d) {
          if (d === 0) {
            throw Fraction3["DivisionByZero"];
          }
          var f = Object.create(Fraction3.prototype);
          f["s"] = n < 0 ? -1 : 1;
          n = n < 0 ? -n : n;
          var a = gcd(n, d);
          f["n"] = n / a;
          f["d"] = d / a;
          return f;
        }
        function factorize(num) {
          var factors = {};
          var n = num;
          var i = 2;
          var s = 4;
          while (s <= n) {
            while (n % i === 0) {
              n /= i;
              factors[i] = (factors[i] || 0) + 1;
            }
            s += 1 + 2 * i++;
          }
          if (n !== num) {
            if (n > 1)
              factors[n] = (factors[n] || 0) + 1;
          } else {
            factors[num] = (factors[num] || 0) + 1;
          }
          return factors;
        }
        var parse = function(p1, p2) {
          var n = 0, d = 1, s = 1;
          var v = 0, w = 0, x = 0, y = 1, z = 1;
          var A = 0, B = 1;
          var C = 1, D = 1;
          var N = 1e7;
          var M;
          if (p1 === void 0 || p1 === null) {
          } else if (p2 !== void 0) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
              throw Fraction3["NonIntegerParameter"];
            }
          } else
            switch (typeof p1) {
              case "object": {
                if ("d" in p1 && "n" in p1) {
                  n = p1["n"];
                  d = p1["d"];
                  if ("s" in p1)
                    n *= p1["s"];
                } else if (0 in p1) {
                  n = p1[0];
                  if (1 in p1)
                    d = p1[1];
                } else {
                  throw Fraction3["InvalidParameter"];
                }
                s = n * d;
                break;
              }
              case "number": {
                if (p1 < 0) {
                  s = p1;
                  p1 = -p1;
                }
                if (p1 % 1 === 0) {
                  n = p1;
                } else if (p1 > 0) {
                  if (p1 >= 1) {
                    z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                    p1 /= z;
                  }
                  while (B <= N && D <= N) {
                    M = (A + C) / (B + D);
                    if (p1 === M) {
                      if (B + D <= N) {
                        n = A + C;
                        d = B + D;
                      } else if (D > B) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                      break;
                    } else {
                      if (p1 > M) {
                        A += C;
                        B += D;
                      } else {
                        C += A;
                        D += B;
                      }
                      if (B > N) {
                        n = C;
                        d = D;
                      } else {
                        n = A;
                        d = B;
                      }
                    }
                  }
                  n *= z;
                } else if (isNaN(p1) || isNaN(p2)) {
                  d = n = NaN;
                }
                break;
              }
              case "string": {
                B = p1.match(/\d+|./g);
                if (B === null)
                  throw Fraction3["InvalidParameter"];
                if (B[A] === "-") {
                  s = -1;
                  A++;
                } else if (B[A] === "+") {
                  A++;
                }
                if (B.length === A + 1) {
                  w = assign(B[A++], s);
                } else if (B[A + 1] === "." || B[A] === ".") {
                  if (B[A] !== ".") {
                    v = assign(B[A++], s);
                  }
                  A++;
                  if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                    w = assign(B[A], s);
                    y = Math.pow(10, B[A].length);
                    A++;
                  }
                  if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                    x = assign(B[A + 1], s);
                    z = Math.pow(10, B[A + 1].length) - 1;
                    A += 3;
                  }
                } else if (B[A + 1] === "/" || B[A + 1] === ":") {
                  w = assign(B[A], s);
                  y = assign(B[A + 2], 1);
                  A += 3;
                } else if (B[A + 3] === "/" && B[A + 1] === " ") {
                  v = assign(B[A], s);
                  w = assign(B[A + 2], s);
                  y = assign(B[A + 4], 1);
                  A += 5;
                }
                if (B.length <= A) {
                  d = y * z;
                  s = n = x + d * v + z * w;
                  break;
                }
              }
              default:
                throw Fraction3["InvalidParameter"];
            }
          if (d === 0) {
            throw Fraction3["DivisionByZero"];
          }
          P2["s"] = s < 0 ? -1 : 1;
          P2["n"] = Math.abs(n);
          P2["d"] = Math.abs(d);
        };
        function modpow(b, e, m) {
          var r = 1;
          for (; e > 0; b = b * b % m, e >>= 1) {
            if (e & 1) {
              r = r * b % m;
            }
          }
          return r;
        }
        function cycleLen(n, d) {
          for (; d % 2 === 0; d /= 2) {
          }
          for (; d % 5 === 0; d /= 5) {
          }
          if (d === 1)
            return 0;
          var rem = 10 % d;
          var t = 1;
          for (; rem !== 1; t++) {
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN)
              return 0;
          }
          return t;
        }
        function cycleStart(n, d, len) {
          var rem1 = 1;
          var rem2 = modpow(10, len, d);
          for (var t = 0; t < 300; t++) {
            if (rem1 === rem2)
              return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
          }
          return 0;
        }
        function gcd(a, b) {
          if (!a)
            return b;
          if (!b)
            return a;
          while (1) {
            a %= b;
            if (!a)
              return b;
            b %= a;
            if (!b)
              return a;
          }
        }
        ;
        function Fraction3(a, b) {
          parse(a, b);
          if (this instanceof Fraction3) {
            a = gcd(P2["d"], P2["n"]);
            this["s"] = P2["s"];
            this["n"] = P2["n"] / a;
            this["d"] = P2["d"] / a;
          } else {
            return newFraction(P2["s"] * P2["n"], P2["d"]);
          }
        }
        Fraction3["DivisionByZero"] = new Error("Division by Zero");
        Fraction3["InvalidParameter"] = new Error("Invalid argument");
        Fraction3["NonIntegerParameter"] = new Error("Parameters must be integer");
        Fraction3.prototype = {
          "s": 1,
          "n": 0,
          "d": 1,
          "abs": function() {
            return newFraction(this["n"], this["d"]);
          },
          "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
          },
          "add": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"],
              this["d"] * P2["d"]
            );
          },
          "sub": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"],
              this["d"] * P2["d"]
            );
          },
          "mul": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * P2["s"] * this["n"] * P2["n"],
              this["d"] * P2["d"]
            );
          },
          "div": function(a, b) {
            parse(a, b);
            return newFraction(
              this["s"] * P2["s"] * this["n"] * P2["d"],
              this["d"] * P2["n"]
            );
          },
          "clone": function() {
            return newFraction(this["s"] * this["n"], this["d"]);
          },
          "mod": function(a, b) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            if (a === void 0) {
              return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse(a, b);
            if (0 === P2["n"] && 0 === this["d"]) {
              throw Fraction3["DivisionByZero"];
            }
            return newFraction(
              this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]),
              P2["d"] * this["d"]
            );
          },
          "gcd": function(a, b) {
            parse(a, b);
            return newFraction(gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]), P2["d"] * this["d"]);
          },
          "lcm": function(a, b) {
            parse(a, b);
            if (P2["n"] === 0 && this["n"] === 0) {
              return newFraction(0, 1);
            }
            return newFraction(P2["n"] * this["n"], gcd(P2["n"], this["n"]) * gcd(P2["d"], this["d"]));
          },
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
          },
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
          },
          "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
          },
          "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
          },
          "pow": function(a, b) {
            parse(a, b);
            if (P2["d"] === 1) {
              if (P2["s"] < 0) {
                return newFraction(Math.pow(this["s"] * this["d"], P2["n"]), Math.pow(this["n"], P2["n"]));
              } else {
                return newFraction(Math.pow(this["s"] * this["n"], P2["n"]), Math.pow(this["d"], P2["n"]));
              }
            }
            if (this["s"] < 0)
              return null;
            var N = factorize(this["n"]);
            var D = factorize(this["d"]);
            var n = 1;
            var d = 1;
            for (var k in N) {
              if (k === "1")
                continue;
              if (k === "0") {
                n = 0;
                break;
              }
              N[k] *= P2["n"];
              if (N[k] % P2["d"] === 0) {
                N[k] /= P2["d"];
              } else
                return null;
              n *= Math.pow(k, N[k]);
            }
            for (var k in D) {
              if (k === "1")
                continue;
              D[k] *= P2["n"];
              if (D[k] % P2["d"] === 0) {
                D[k] /= P2["d"];
              } else
                return null;
              d *= Math.pow(k, D[k]);
            }
            if (P2["s"] < 0) {
              return newFraction(d, n);
            }
            return newFraction(n, d);
          },
          "equals": function(a, b) {
            parse(a, b);
            return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
          },
          "compare": function(a, b) {
            parse(a, b);
            var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
            return (0 < t) - (t < 0);
          },
          "simplify": function(eps) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return this;
            }
            eps = eps || 1e-3;
            var thisABS = this["abs"]();
            var cont = thisABS["toContinued"]();
            for (var i = 1; i < cont.length; i++) {
              var s = newFraction(cont[i - 1], 1);
              for (var k = i - 2; k >= 0; k--) {
                s = s["inverse"]()["add"](cont[k]);
              }
              if (s["sub"](thisABS)["abs"]().valueOf() < eps) {
                return s["mul"](this["s"]);
              }
            }
            return this;
          },
          "divisible": function(a, b) {
            parse(a, b);
            return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
          },
          "valueOf": function() {
            return this["s"] * this["n"] / this["d"];
          },
          "toFraction": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                str += " ";
                n %= d;
              }
              str += n;
              str += "/";
              str += d;
            }
            return str;
          },
          "toLatex": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                n %= d;
              }
              str += "\\frac{";
              str += n;
              str += "}{";
              str += d;
              str += "}";
            }
            return str;
          },
          "toContinued": function() {
            var t;
            var a = this["n"];
            var b = this["d"];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
              return res;
            }
            do {
              res.push(Math.floor(a / b));
              t = a % b;
              a = b;
              b = t;
            } while (a !== 1);
            return res;
          },
          "toString": function(dec) {
            var N = this["n"];
            var D = this["d"];
            if (isNaN(N) || isNaN(D)) {
              return "NaN";
            }
            dec = dec || 15;
            var cycLen = cycleLen(N, D);
            var cycOff = cycleStart(N, D, cycLen);
            var str = this["s"] < 0 ? "-" : "";
            str += N / D | 0;
            N %= D;
            N *= 10;
            if (N)
              str += ".";
            if (cycLen) {
              for (var i = cycOff; i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += "(";
              for (var i = cycLen; i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
              str += ")";
            } else {
              for (var i = dec; N && i--; ) {
                str += N / D | 0;
                N %= D;
                N *= 10;
              }
            }
            return str;
          }
        };
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Fraction3;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Fraction3, "__esModule", { "value": true });
          Fraction3["default"] = Fraction3;
          Fraction3["Fraction"] = Fraction3;
          module2["exports"] = Fraction3;
        } else {
          root["Fraction"] = Fraction3;
        }
      })(exports);
    }
  });

  // ../node_modules/geolib/es/constants.js
  var require_constants = __commonJS({
    "../node_modules/geolib/es/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.areaConversion = exports.timeConversion = exports.distanceConversion = exports.altitudeKeys = exports.latitudeKeys = exports.longitudeKeys = exports.MAXLON = exports.MINLON = exports.MAXLAT = exports.MINLAT = exports.earthRadius = exports.sexagesimalPattern = void 0;
      var sexagesimalPattern = /^([0-9]{1,3})°\s*([0-9]{1,3}(?:\.(?:[0-9]{1,}))?)['′]\s*(([0-9]{1,3}(\.([0-9]{1,}))?)["″]\s*)?([NEOSW]?)$/;
      exports.sexagesimalPattern = sexagesimalPattern;
      var earthRadius = 6378137;
      exports.earthRadius = earthRadius;
      var MINLAT = -90;
      exports.MINLAT = MINLAT;
      var MAXLAT = 90;
      exports.MAXLAT = MAXLAT;
      var MINLON = -180;
      exports.MINLON = MINLON;
      var MAXLON = 180;
      exports.MAXLON = MAXLON;
      var longitudeKeys = ["lng", "lon", "longitude", 0];
      exports.longitudeKeys = longitudeKeys;
      var latitudeKeys = ["lat", "latitude", 1];
      exports.latitudeKeys = latitudeKeys;
      var altitudeKeys = ["alt", "altitude", "elevation", "elev", 2];
      exports.altitudeKeys = altitudeKeys;
      var distanceConversion = { m: 1, km: 1e-3, cm: 100, mm: 1e3, mi: 1 / 1609.344, sm: 1 / 1852.216, ft: 100 / 30.48, in: 100 / 2.54, yd: 1 / 0.9144 };
      exports.distanceConversion = distanceConversion;
      var timeConversion = { m: 60, h: 3600, d: 86400 };
      exports.timeConversion = timeConversion;
      var areaConversion = { m2: 1, km2: 1e-6, ha: 1e-4, a: 0.01, ft2: 10.763911, yd2: 1.19599, in2: 1550.0031 };
      exports.areaConversion = areaConversion;
      areaConversion.sqm = areaConversion.m2;
      areaConversion.sqkm = areaConversion.km2;
      areaConversion.sqft = areaConversion.ft2;
      areaConversion.sqyd = areaConversion.yd2;
      areaConversion.sqin = areaConversion.in2;
    }
  });

  // ../node_modules/geolib/es/getCoordinateKey.js
  var require_getCoordinateKey = __commonJS({
    "../node_modules/geolib/es/getCoordinateKey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var getCoordinateKey = function getCoordinateKey2(point, keysToLookup) {
        return keysToLookup.reduce(function(foundKey, key) {
          if (typeof point === "undefined" || point === null) {
            throw new Error("'".concat(point, "' is no valid coordinate."));
          }
          if (Object.prototype.hasOwnProperty.call(point, key) && typeof key !== "undefined" && typeof foundKey === "undefined") {
            foundKey = key;
            return key;
          }
          return foundKey;
        }, void 0);
      };
      var _default = getCoordinateKey;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isDecimal.js
  var require_isDecimal = __commonJS({
    "../node_modules/geolib/es/isDecimal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var isDecimal2 = function isDecimal3(value) {
        var checkedValue = value.toString().trim();
        if (isNaN(parseFloat(checkedValue))) {
          return false;
        }
        return parseFloat(checkedValue) === Number(checkedValue);
      };
      var _default = isDecimal2;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isSexagesimal.js
  var require_isSexagesimal = __commonJS({
    "../node_modules/geolib/es/isSexagesimal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var isSexagesimal = function isSexagesimal2(value) {
        return _constants.sexagesimalPattern.test(value.toString().trim());
      };
      var _default = isSexagesimal;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/sexagesimalToDecimal.js
  var require_sexagesimalToDecimal = __commonJS({
    "../node_modules/geolib/es/sexagesimalToDecimal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var sexagesimalToDecimal = function sexagesimalToDecimal2(sexagesimal) {
        var data = new RegExp(_constants.sexagesimalPattern).exec(sexagesimal.toString().trim());
        if (typeof data === "undefined" || data === null) {
          throw new Error("Given value is not in sexagesimal format");
        }
        var min2 = Number(data[2]) / 60 || 0;
        var sec = Number(data[4]) / 3600 || 0;
        var decimal = parseFloat(data[1]) + min2 + sec;
        return ["S", "W"].includes(data[7]) ? -decimal : decimal;
      };
      var _default = sexagesimalToDecimal;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getCoordinateKeys.js
  var require_getCoordinateKeys = __commonJS({
    "../node_modules/geolib/es/getCoordinateKeys.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var _getCoordinateKey = _interopRequireDefault(require_getCoordinateKey());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var getCoordinateKeys = function getCoordinateKeys2(point) {
        var keysToLookup = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { longitude: _constants.longitudeKeys, latitude: _constants.latitudeKeys, altitude: _constants.altitudeKeys };
        var longitude = (0, _getCoordinateKey.default)(point, keysToLookup.longitude);
        var latitude = (0, _getCoordinateKey.default)(point, keysToLookup.latitude);
        var altitude = (0, _getCoordinateKey.default)(point, keysToLookup.altitude);
        return _objectSpread({ latitude, longitude }, altitude ? { altitude } : {});
      };
      var _default = getCoordinateKeys;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isValidLatitude.js
  var require_isValidLatitude = __commonJS({
    "../node_modules/geolib/es/isValidLatitude.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _isDecimal = _interopRequireDefault(require_isDecimal());
      var _isSexagesimal = _interopRequireDefault(require_isSexagesimal());
      var _sexagesimalToDecimal = _interopRequireDefault(require_sexagesimalToDecimal());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isValidLatitude = function isValidLatitude2(value) {
        if ((0, _isDecimal.default)(value)) {
          if (parseFloat(value) > _constants.MAXLAT || value < _constants.MINLAT) {
            return false;
          }
          return true;
        }
        if ((0, _isSexagesimal.default)(value)) {
          return isValidLatitude2((0, _sexagesimalToDecimal.default)(value));
        }
        return false;
      };
      var _default = isValidLatitude;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isValidLongitude.js
  var require_isValidLongitude = __commonJS({
    "../node_modules/geolib/es/isValidLongitude.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _isDecimal = _interopRequireDefault(require_isDecimal());
      var _isSexagesimal = _interopRequireDefault(require_isSexagesimal());
      var _sexagesimalToDecimal = _interopRequireDefault(require_sexagesimalToDecimal());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isValidLongitude = function isValidLongitude2(value) {
        if ((0, _isDecimal.default)(value)) {
          if (parseFloat(value) > _constants.MAXLON || value < _constants.MINLON) {
            return false;
          }
          return true;
        }
        if ((0, _isSexagesimal.default)(value)) {
          return isValidLongitude2((0, _sexagesimalToDecimal.default)(value));
        }
        return false;
      };
      var _default = isValidLongitude;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isValidCoordinate.js
  var require_isValidCoordinate = __commonJS({
    "../node_modules/geolib/es/isValidCoordinate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getCoordinateKeys2 = _interopRequireDefault(require_getCoordinateKeys());
      var _isValidLatitude = _interopRequireDefault(require_isValidLatitude());
      var _isValidLongitude = _interopRequireDefault(require_isValidLongitude());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isValidCoordinate = function isValidCoordinate2(point) {
        var _getCoordinateKeys = (0, _getCoordinateKeys2.default)(point), latitude = _getCoordinateKeys.latitude, longitude = _getCoordinateKeys.longitude;
        if (Array.isArray(point) && point.length >= 2) {
          return (0, _isValidLongitude.default)(point[0]) && (0, _isValidLatitude.default)(point[1]);
        }
        if (typeof latitude === "undefined" || typeof longitude === "undefined") {
          return false;
        }
        var lon = point[longitude];
        var lat = point[latitude];
        if (typeof lat === "undefined" || typeof lon === "undefined") {
          return false;
        }
        if ((0, _isValidLatitude.default)(lat) === false || (0, _isValidLongitude.default)(lon) === false) {
          return false;
        }
        return true;
      };
      var _default = isValidCoordinate;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/toDecimal.js
  var require_toDecimal = __commonJS({
    "../node_modules/geolib/es/toDecimal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _isDecimal = _interopRequireDefault(require_isDecimal());
      var _isSexagesimal = _interopRequireDefault(require_isSexagesimal());
      var _sexagesimalToDecimal = _interopRequireDefault(require_sexagesimalToDecimal());
      var _isValidCoordinate = _interopRequireDefault(require_isValidCoordinate());
      var _getCoordinateKeys = _interopRequireDefault(require_getCoordinateKeys());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var toDecimal = function toDecimal2(value) {
        if ((0, _isDecimal.default)(value)) {
          return Number(value);
        }
        if ((0, _isSexagesimal.default)(value)) {
          return (0, _sexagesimalToDecimal.default)(value);
        }
        if ((0, _isValidCoordinate.default)(value)) {
          var keys = (0, _getCoordinateKeys.default)(value);
          if (Array.isArray(value)) {
            return value.map(function(v, index) {
              return [0, 1].includes(index) ? toDecimal2(v) : v;
            });
          }
          return _objectSpread(_objectSpread(_objectSpread({}, value), keys.latitude && _defineProperty({}, keys.latitude, toDecimal2(value[keys.latitude]))), keys.longitude && _defineProperty({}, keys.longitude, toDecimal2(value[keys.longitude])));
        }
        if (Array.isArray(value)) {
          return value.map(function(point) {
            return (0, _isValidCoordinate.default)(point) ? toDecimal2(point) : point;
          });
        }
        return value;
      };
      var _default = toDecimal;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getLatitude.js
  var require_getLatitude = __commonJS({
    "../node_modules/geolib/es/getLatitude.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var _getCoordinateKey = _interopRequireDefault(require_getCoordinateKey());
      var _toDecimal = _interopRequireDefault(require_toDecimal());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getLatitude = function getLatitude2(point, raw) {
        var latKey = (0, _getCoordinateKey.default)(point, _constants.latitudeKeys);
        if (typeof latKey === "undefined" || latKey === null) {
          return;
        }
        var value = point[latKey];
        return raw === true ? value : (0, _toDecimal.default)(value);
      };
      var _default = getLatitude;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getLongitude.js
  var require_getLongitude = __commonJS({
    "../node_modules/geolib/es/getLongitude.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var _getCoordinateKey = _interopRequireDefault(require_getCoordinateKey());
      var _toDecimal = _interopRequireDefault(require_toDecimal());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getLongitude = function getLongitude2(point, raw) {
        var latKey = (0, _getCoordinateKey.default)(point, _constants.longitudeKeys);
        if (typeof latKey === "undefined" || latKey === null) {
          return;
        }
        var value = point[latKey];
        return raw === true ? value : (0, _toDecimal.default)(value);
      };
      var _default = getLongitude;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/toRad.js
  var require_toRad = __commonJS({
    "../node_modules/geolib/es/toRad.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var toRad = function toRad2(value) {
        return value * Math.PI / 180;
      };
      var _default = toRad;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/toDeg.js
  var require_toDeg = __commonJS({
    "../node_modules/geolib/es/toDeg.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var toDeg = function toDeg2(value) {
        return value * 180 / Math.PI;
      };
      var _default = toDeg;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/computeDestinationPoint.js
  var require_computeDestinationPoint = __commonJS({
    "../node_modules/geolib/es/computeDestinationPoint.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _toDeg = _interopRequireDefault(require_toDeg());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var computeDestinationPoint = function computeDestinationPoint2(start, distance, bearing) {
        var radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 6371e3;
        var lat = (0, _getLatitude.default)(start);
        var lng = (0, _getLongitude.default)(start);
        var delta = distance / radius;
        var theta = (0, _toRad.default)(bearing);
        var phi1 = (0, _toRad.default)(lat);
        var lambda1 = (0, _toRad.default)(lng);
        var phi2 = Math.asin(Math.sin(phi1) * Math.cos(delta) + Math.cos(phi1) * Math.sin(delta) * Math.cos(theta));
        var lambda2 = lambda1 + Math.atan2(Math.sin(theta) * Math.sin(delta) * Math.cos(phi1), Math.cos(delta) - Math.sin(phi1) * Math.sin(phi2));
        var longitude = (0, _toDeg.default)(lambda2);
        if (longitude < _constants.MINLON || longitude > _constants.MAXLON) {
          lambda2 = (lambda2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI;
          longitude = (0, _toDeg.default)(lambda2);
        }
        return { latitude: (0, _toDeg.default)(phi2), longitude };
      };
      var _default = computeDestinationPoint;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/convertArea.js
  var require_convertArea = __commonJS({
    "../node_modules/geolib/es/convertArea.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var convertArea = function convertArea2(squareMeters) {
        var targetUnit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "m";
        var factor = _constants.areaConversion[targetUnit];
        if (factor) {
          return squareMeters * factor;
        }
        throw new Error("Invalid unit used for area conversion.");
      };
      var _default = convertArea;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/convertDistance.js
  var require_convertDistance = __commonJS({
    "../node_modules/geolib/es/convertDistance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var convertDistance = function convertDistance2(meters) {
        var targetUnit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "m";
        var factor = _constants.distanceConversion[targetUnit];
        if (factor) {
          return meters * factor;
        }
        throw new Error("Invalid unit used for distance conversion.");
      };
      var _default = convertDistance;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/convertSpeed.js
  var require_convertSpeed = __commonJS({
    "../node_modules/geolib/es/convertSpeed.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _constants = require_constants();
      var convertSpeed = function convertSpeed2(metersPerSecond) {
        var targetUnit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "kmh";
        switch (targetUnit) {
          case "kmh":
            return metersPerSecond * _constants.timeConversion.h * _constants.distanceConversion.km;
          case "mph":
            return metersPerSecond * _constants.timeConversion.h * _constants.distanceConversion.mi;
          default:
            return metersPerSecond;
        }
      };
      var _default = convertSpeed;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/decimalToSexagesimal.js
  var require_decimalToSexagesimal = __commonJS({
    "../node_modules/geolib/es/decimalToSexagesimal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      var imprecise = function imprecise2(number2) {
        var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;
        var factor = Math.pow(10, decimals);
        return Math.round(number2 * factor) / factor;
      };
      var decimal2sexagesimalNext = function decimal2sexagesimalNext2(decimal) {
        var _decimal$toString$spl = decimal.toString().split("."), _decimal$toString$spl2 = _slicedToArray(_decimal$toString$spl, 2), pre = _decimal$toString$spl2[0], post = _decimal$toString$spl2[1];
        var deg = Math.abs(Number(pre));
        var min0 = Number("0." + (post || 0)) * 60;
        var sec0 = min0.toString().split(".");
        var min2 = Math.floor(min0);
        var sec = imprecise(Number("0." + (sec0[1] || 0)) * 60).toString();
        var _sec$split = sec.split("."), _sec$split2 = _slicedToArray(_sec$split, 2), secPreDec = _sec$split2[0], _sec$split2$ = _sec$split2[1], secDec = _sec$split2$ === void 0 ? "0" : _sec$split2$;
        return deg + "\xB0 " + min2.toString().padStart(2, "0") + "' " + secPreDec.padStart(2, "0") + "." + secDec.padEnd(1, "0") + '"';
      };
      var _default = decimal2sexagesimalNext;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/robustAcos.js
  var require_robustAcos = __commonJS({
    "../node_modules/geolib/es/robustAcos.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var robustAcos2 = function robustAcos3(value) {
        if (value > 1) {
          return 1;
        }
        if (value < -1) {
          return -1;
        }
        return value;
      };
      var _default = robustAcos2;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getDistance.js
  var require_getDistance = __commonJS({
    "../node_modules/geolib/es/getDistance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _robustAcos = _interopRequireDefault(require_robustAcos());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getDistance = function getDistance2(from, to) {
        var accuracy = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
        var fromLat = (0, _getLatitude.default)(from);
        var fromLon = (0, _getLongitude.default)(from);
        var toLat = (0, _getLatitude.default)(to);
        var toLon = (0, _getLongitude.default)(to);
        var distance = Math.acos((0, _robustAcos.default)(Math.sin((0, _toRad.default)(toLat)) * Math.sin((0, _toRad.default)(fromLat)) + Math.cos((0, _toRad.default)(toLat)) * Math.cos((0, _toRad.default)(fromLat)) * Math.cos((0, _toRad.default)(fromLon) - (0, _toRad.default)(toLon)))) * _constants.earthRadius;
        return Math.round(distance / accuracy) * accuracy;
      };
      var _default = getDistance;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/orderByDistance.js
  var require_orderByDistance = __commonJS({
    "../node_modules/geolib/es/orderByDistance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistance = _interopRequireDefault(require_getDistance());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var orderByDistance = function orderByDistance2(point, coords) {
        var distanceFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _getDistance.default;
        distanceFn = typeof distanceFn === "function" ? distanceFn : _getDistance.default;
        return coords.slice().sort(function(a, b) {
          return distanceFn(point, a) - distanceFn(point, b);
        });
      };
      var _default = orderByDistance;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/findNearest.js
  var require_findNearest = __commonJS({
    "../node_modules/geolib/es/findNearest.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _orderByDistance = _interopRequireDefault(require_orderByDistance());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var findNearest = function findNearest2(point, coords) {
        return (0, _orderByDistance.default)(point, coords)[0];
      };
      var _default = findNearest;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getAreaOfPolygon.js
  var require_getAreaOfPolygon = __commonJS({
    "../node_modules/geolib/es/getAreaOfPolygon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _toRad = _interopRequireDefault(require_toRad());
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getAreaOfPolygon = function getAreaOfPolygon2(points) {
        var area = 0;
        if (points.length > 2) {
          var lowerIndex;
          var middleIndex;
          var upperIndex;
          for (var i = 0; i < points.length; i++) {
            if (i === points.length - 2) {
              lowerIndex = points.length - 2;
              middleIndex = points.length - 1;
              upperIndex = 0;
            } else if (i === points.length - 1) {
              lowerIndex = points.length - 1;
              middleIndex = 0;
              upperIndex = 1;
            } else {
              lowerIndex = i;
              middleIndex = i + 1;
              upperIndex = i + 2;
            }
            var p1lon = (0, _getLongitude.default)(points[lowerIndex]);
            var p2lat = (0, _getLatitude.default)(points[middleIndex]);
            var p3lon = (0, _getLongitude.default)(points[upperIndex]);
            area += ((0, _toRad.default)(p3lon) - (0, _toRad.default)(p1lon)) * Math.sin((0, _toRad.default)(p2lat));
          }
          area = area * _constants.earthRadius * _constants.earthRadius / 2;
        }
        return Math.abs(area);
      };
      var _default = getAreaOfPolygon;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getBounds.js
  var require_getBounds = __commonJS({
    "../node_modules/geolib/es/getBounds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getBounds = function getBounds2(points) {
        if (Array.isArray(points) === false || points.length === 0) {
          throw new Error("No points were given.");
        }
        return points.reduce(function(stats, point) {
          var latitude = (0, _getLatitude.default)(point);
          var longitude = (0, _getLongitude.default)(point);
          return { maxLat: Math.max(latitude, stats.maxLat), minLat: Math.min(latitude, stats.minLat), maxLng: Math.max(longitude, stats.maxLng), minLng: Math.min(longitude, stats.minLng) };
        }, { maxLat: -Infinity, minLat: Infinity, maxLng: -Infinity, minLng: Infinity });
      };
      var _default = getBounds;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getBoundsOfDistance.js
  var require_getBoundsOfDistance = __commonJS({
    "../node_modules/geolib/es/getBoundsOfDistance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _toDeg = _interopRequireDefault(require_toDeg());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getBoundsOfDistance = function getBoundsOfDistance2(point, distance) {
        var latitude = (0, _getLatitude.default)(point);
        var longitude = (0, _getLongitude.default)(point);
        var radLat = (0, _toRad.default)(latitude);
        var radLon = (0, _toRad.default)(longitude);
        var radDist = distance / _constants.earthRadius;
        var minLat = radLat - radDist;
        var maxLat = radLat + radDist;
        var MAX_LAT_RAD = (0, _toRad.default)(_constants.MAXLAT);
        var MIN_LAT_RAD = (0, _toRad.default)(_constants.MINLAT);
        var MAX_LON_RAD = (0, _toRad.default)(_constants.MAXLON);
        var MIN_LON_RAD = (0, _toRad.default)(_constants.MINLON);
        var minLon;
        var maxLon;
        if (minLat > MIN_LAT_RAD && maxLat < MAX_LAT_RAD) {
          var deltaLon = Math.asin(Math.sin(radDist) / Math.cos(radLat));
          minLon = radLon - deltaLon;
          if (minLon < MIN_LON_RAD) {
            minLon += Math.PI * 2;
          }
          maxLon = radLon + deltaLon;
          if (maxLon > MAX_LON_RAD) {
            maxLon -= Math.PI * 2;
          }
        } else {
          minLat = Math.max(minLat, MIN_LAT_RAD);
          maxLat = Math.min(maxLat, MAX_LAT_RAD);
          minLon = MIN_LON_RAD;
          maxLon = MAX_LON_RAD;
        }
        return [{ latitude: (0, _toDeg.default)(minLat), longitude: (0, _toDeg.default)(minLon) }, { latitude: (0, _toDeg.default)(maxLat), longitude: (0, _toDeg.default)(maxLon) }];
      };
      var _default = getBoundsOfDistance;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getCenter.js
  var require_getCenter = __commonJS({
    "../node_modules/geolib/es/getCenter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _toDeg = _interopRequireDefault(require_toDeg());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getCenter = function getCenter2(points) {
        if (Array.isArray(points) === false || points.length === 0) {
          return false;
        }
        var numberOfPoints = points.length;
        var sum2 = points.reduce(function(acc, point) {
          var pointLat = (0, _toRad.default)((0, _getLatitude.default)(point));
          var pointLon = (0, _toRad.default)((0, _getLongitude.default)(point));
          return { X: acc.X + Math.cos(pointLat) * Math.cos(pointLon), Y: acc.Y + Math.cos(pointLat) * Math.sin(pointLon), Z: acc.Z + Math.sin(pointLat) };
        }, { X: 0, Y: 0, Z: 0 });
        var X = sum2.X / numberOfPoints;
        var Y = sum2.Y / numberOfPoints;
        var Z = sum2.Z / numberOfPoints;
        return { longitude: (0, _toDeg.default)(Math.atan2(Y, X)), latitude: (0, _toDeg.default)(Math.atan2(Z, Math.sqrt(X * X + Y * Y))) };
      };
      var _default = getCenter;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getCenterOfBounds.js
  var require_getCenterOfBounds = __commonJS({
    "../node_modules/geolib/es/getCenterOfBounds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getBounds = _interopRequireDefault(require_getBounds());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getCenterOfBounds = function getCenterOfBounds2(coords) {
        var bounds = (0, _getBounds.default)(coords);
        var latitude = bounds.minLat + (bounds.maxLat - bounds.minLat) / 2;
        var longitude = bounds.minLng + (bounds.maxLng - bounds.minLng) / 2;
        return { latitude: parseFloat(latitude.toFixed(6)), longitude: parseFloat(longitude.toFixed(6)) };
      };
      var _default = getCenterOfBounds;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getRhumbLineBearing.js
  var require_getRhumbLineBearing = __commonJS({
    "../node_modules/geolib/es/getRhumbLineBearing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _toDeg = _interopRequireDefault(require_toDeg());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getRhumbLineBearing = function getRhumbLineBearing2(origin, dest) {
        var diffLon = (0, _toRad.default)((0, _getLongitude.default)(dest)) - (0, _toRad.default)((0, _getLongitude.default)(origin));
        var diffPhi = Math.log(Math.tan((0, _toRad.default)((0, _getLatitude.default)(dest)) / 2 + Math.PI / 4) / Math.tan((0, _toRad.default)((0, _getLatitude.default)(origin)) / 2 + Math.PI / 4));
        if (Math.abs(diffLon) > Math.PI) {
          if (diffLon > 0) {
            diffLon = (Math.PI * 2 - diffLon) * -1;
          } else {
            diffLon = Math.PI * 2 + diffLon;
          }
        }
        return ((0, _toDeg.default)(Math.atan2(diffLon, diffPhi)) + 360) % 360;
      };
      var _default = getRhumbLineBearing;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getCompassDirection.js
  var require_getCompassDirection = __commonJS({
    "../node_modules/geolib/es/getCompassDirection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getRhumbLineBearing = _interopRequireDefault(require_getRhumbLineBearing());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getCompassDirection = function getCompassDirection2(origin, dest) {
        var bearingFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _getRhumbLineBearing.default;
        var bearing = typeof bearingFn === "function" ? bearingFn(origin, dest) : (0, _getRhumbLineBearing.default)(origin, dest);
        if (isNaN(bearing)) {
          throw new Error("Could not calculate bearing for given points. Check your bearing function");
        }
        switch (Math.round(bearing / 22.5)) {
          case 1:
            return "NNE";
          case 2:
            return "NE";
          case 3:
            return "ENE";
          case 4:
            return "E";
          case 5:
            return "ESE";
          case 6:
            return "SE";
          case 7:
            return "SSE";
          case 8:
            return "S";
          case 9:
            return "SSW";
          case 10:
            return "SW";
          case 11:
            return "WSW";
          case 12:
            return "W";
          case 13:
            return "WNW";
          case 14:
            return "NW";
          case 15:
            return "NNW";
          default:
            return "N";
        }
      };
      var _default = getCompassDirection;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getDistanceFromLine.js
  var require_getDistanceFromLine = __commonJS({
    "../node_modules/geolib/es/getDistanceFromLine.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistance = _interopRequireDefault(require_getDistance());
      var _robustAcos = _interopRequireDefault(require_robustAcos());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getDistanceFromLine = function getDistanceFromLine2(point, lineStart, lineEnd) {
        var accuracy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
        var d1 = (0, _getDistance.default)(lineStart, point, accuracy);
        var d2 = (0, _getDistance.default)(point, lineEnd, accuracy);
        var d3 = (0, _getDistance.default)(lineStart, lineEnd, accuracy);
        var alpha = Math.acos((0, _robustAcos.default)((d1 * d1 + d3 * d3 - d2 * d2) / (2 * d1 * d3)));
        var beta = Math.acos((0, _robustAcos.default)((d2 * d2 + d3 * d3 - d1 * d1) / (2 * d2 * d3)));
        if (alpha > Math.PI / 2) {
          return d1;
        }
        if (beta > Math.PI / 2) {
          return d2;
        }
        return Math.sin(alpha) * d1;
      };
      var _default = getDistanceFromLine;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getGreatCircleBearing.js
  var require_getGreatCircleBearing = __commonJS({
    "../node_modules/geolib/es/getGreatCircleBearing.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _toDeg = _interopRequireDefault(require_toDeg());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getGreatCircleBearing = function getGreatCircleBearing2(origin, dest) {
        var destLat = (0, _getLatitude.default)(dest);
        var detLon = (0, _getLongitude.default)(dest);
        var originLat = (0, _getLatitude.default)(origin);
        var originLon = (0, _getLongitude.default)(origin);
        var bearing = ((0, _toDeg.default)(Math.atan2(Math.sin((0, _toRad.default)(detLon) - (0, _toRad.default)(originLon)) * Math.cos((0, _toRad.default)(destLat)), Math.cos((0, _toRad.default)(originLat)) * Math.sin((0, _toRad.default)(destLat)) - Math.sin((0, _toRad.default)(originLat)) * Math.cos((0, _toRad.default)(destLat)) * Math.cos((0, _toRad.default)(detLon) - (0, _toRad.default)(originLon)))) + 360) % 360;
        return bearing;
      };
      var _default = getGreatCircleBearing;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getPathLength.js
  var require_getPathLength = __commonJS({
    "../node_modules/geolib/es/getPathLength.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistance = _interopRequireDefault(require_getDistance());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      var getPathLength = function getPathLength2(points) {
        var distanceFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _getDistance.default;
        return points.reduce(function(acc, point) {
          if (_typeof(acc) === "object" && acc.last !== null) {
            acc.distance += distanceFn(point, acc.last);
          }
          acc.last = point;
          return acc;
        }, { last: null, distance: 0 }).distance;
      };
      var _default = getPathLength;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getPreciseDistance.js
  var require_getPreciseDistance = __commonJS({
    "../node_modules/geolib/es/getPreciseDistance.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _toRad = _interopRequireDefault(require_toRad());
      var _constants = require_constants();
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getDistance = function getDistance2(start, end) {
        var accuracy = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        accuracy = typeof accuracy !== "undefined" && !isNaN(accuracy) ? accuracy : 1;
        var startLat = (0, _getLatitude.default)(start);
        var startLon = (0, _getLongitude.default)(start);
        var endLat = (0, _getLatitude.default)(end);
        var endLon = (0, _getLongitude.default)(end);
        var b = 6356752314245e-6;
        var ellipsoidParams = 1 / 298.257223563;
        var L = (0, _toRad.default)(endLon - startLon);
        var cosSigma;
        var sigma;
        var sinAlpha;
        var cosSqAlpha;
        var cos2SigmaM;
        var sinSigma;
        var U1 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(startLat))));
        var U2 = Math.atan((1 - ellipsoidParams) * Math.tan((0, _toRad.default)(parseFloat(endLat))));
        var sinU1 = Math.sin(U1);
        var cosU1 = Math.cos(U1);
        var sinU2 = Math.sin(U2);
        var cosU2 = Math.cos(U2);
        var lambda = L;
        var lambdaP;
        var iterLimit = 100;
        do {
          var sinLambda = Math.sin(lambda);
          var cosLambda = Math.cos(lambda);
          sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
          if (sinSigma === 0) {
            return 0;
          }
          cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
          sigma = Math.atan2(sinSigma, cosSigma);
          sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
          cosSqAlpha = 1 - sinAlpha * sinAlpha;
          cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
          if (isNaN(cos2SigmaM)) {
            cos2SigmaM = 0;
          }
          var C = ellipsoidParams / 16 * cosSqAlpha * (4 + ellipsoidParams * (4 - 3 * cosSqAlpha));
          lambdaP = lambda;
          lambda = L + (1 - C) * ellipsoidParams * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
        if (iterLimit === 0) {
          return NaN;
        }
        var uSq = cosSqAlpha * (_constants.earthRadius * _constants.earthRadius - b * b) / (b * b);
        var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
        var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        var distance = b * A * (sigma - deltaSigma);
        return Math.round(distance / accuracy) * accuracy;
      };
      var _default = getDistance;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getRoughCompassDirection.js
  var require_getRoughCompassDirection = __commonJS({
    "../node_modules/geolib/es/getRoughCompassDirection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var getRoughCompassDirection = function getRoughCompassDirection2(exact) {
        if (/^NNE|NE|NNW|N$/.test(exact)) {
          return "N";
        }
        if (/^ENE|E|ESE|SE$/.test(exact)) {
          return "E";
        }
        if (/^SSE|S|SSW|SW$/.test(exact)) {
          return "S";
        }
        if (/^WSW|W|WNW|NW$/.test(exact)) {
          return "W";
        }
      };
      var _default = getRoughCompassDirection;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/getSpeed.js
  var require_getSpeed = __commonJS({
    "../node_modules/geolib/es/getSpeed.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistance = _interopRequireDefault(require_getDistance());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var getSpeed = function getSpeed2(start, end) {
        var distanceFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _getDistance.default;
        var distance = distanceFn(start, end);
        var time = Number(end.time) - Number(start.time);
        var metersPerSecond = distance / time * 1e3;
        return metersPerSecond;
      };
      var _default = getSpeed;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isPointInLine.js
  var require_isPointInLine = __commonJS({
    "../node_modules/geolib/es/isPointInLine.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistance = _interopRequireDefault(require_getDistance());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isPointInLine = function isPointInLine2(point, lineStart, lineEnd) {
        return (0, _getDistance.default)(lineStart, point) + (0, _getDistance.default)(point, lineEnd) === (0, _getDistance.default)(lineStart, lineEnd);
      };
      var _default = isPointInLine;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isPointInPolygon.js
  var require_isPointInPolygon = __commonJS({
    "../node_modules/geolib/es/isPointInPolygon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isPointInPolygon = function isPointInPolygon2(point, polygon) {
        var isInside = false;
        var totalPolys = polygon.length;
        for (var i = -1, j = totalPolys - 1; ++i < totalPolys; j = i) {
          if (((0, _getLongitude.default)(polygon[i]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[j]) || (0, _getLongitude.default)(polygon[j]) <= (0, _getLongitude.default)(point) && (0, _getLongitude.default)(point) < (0, _getLongitude.default)(polygon[i])) && (0, _getLatitude.default)(point) < ((0, _getLatitude.default)(polygon[j]) - (0, _getLatitude.default)(polygon[i])) * ((0, _getLongitude.default)(point) - (0, _getLongitude.default)(polygon[i])) / ((0, _getLongitude.default)(polygon[j]) - (0, _getLongitude.default)(polygon[i])) + (0, _getLatitude.default)(polygon[i])) {
            isInside = !isInside;
          }
        }
        return isInside;
      };
      var _default = isPointInPolygon;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isPointNearLine.js
  var require_isPointNearLine = __commonJS({
    "../node_modules/geolib/es/isPointNearLine.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistanceFromLine = _interopRequireDefault(require_getDistanceFromLine());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isPointNearLine = function isPointNearLine2(point, start, end, distance) {
        return (0, _getDistanceFromLine.default)(point, start, end) < distance;
      };
      var _default = isPointNearLine;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/isPointWithinRadius.js
  var require_isPointWithinRadius = __commonJS({
    "../node_modules/geolib/es/isPointWithinRadius.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var _getDistance = _interopRequireDefault(require_getDistance());
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var isPointWithinRadius = function isPointWithinRadius2(point, center, radius) {
        return (0, _getDistance.default)(point, center) < radius;
      };
      var _default = isPointWithinRadius;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/wktToPolygon.js
  var require_wktToPolygon = __commonJS({
    "../node_modules/geolib/es/wktToPolygon.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      function _slicedToArray(arr, i) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      var wktToPolygon = function wktToPolygon2(wkt) {
        if (!wkt.startsWith("POLYGON")) {
          throw new Error("Invalid wkt.");
        }
        var coordsText = wkt.slice(wkt.indexOf("(") + 2, wkt.indexOf(")")).split(", ");
        var polygon = coordsText.map(function(coordText) {
          var _coordText$split = coordText.split(" "), _coordText$split2 = _slicedToArray(_coordText$split, 2), longitude = _coordText$split2[0], latitude = _coordText$split2[1];
          return { longitude: parseFloat(longitude), latitude: parseFloat(latitude) };
        });
        return polygon;
      };
      var _default = wktToPolygon;
      exports.default = _default;
    }
  });

  // ../node_modules/geolib/es/index.js
  var require_es = __commonJS({
    "../node_modules/geolib/es/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var _exportNames = { computeDestinationPoint: true, convertArea: true, convertDistance: true, convertSpeed: true, decimalToSexagesimal: true, findNearest: true, getAreaOfPolygon: true, getBounds: true, getBoundsOfDistance: true, getCenter: true, getCenterOfBounds: true, getCompassDirection: true, getCoordinateKey: true, getCoordinateKeys: true, getDistance: true, getDistanceFromLine: true, getGreatCircleBearing: true, getLatitude: true, getLongitude: true, getPathLength: true, getPreciseDistance: true, getRhumbLineBearing: true, getRoughCompassDirection: true, getSpeed: true, isDecimal: true, isPointInLine: true, isPointInPolygon: true, isPointNearLine: true, isPointWithinRadius: true, isSexagesimal: true, isValidCoordinate: true, isValidLatitude: true, isValidLongitude: true, orderByDistance: true, sexagesimalToDecimal: true, toDecimal: true, toRad: true, toDeg: true, wktToPolygon: true };
      Object.defineProperty(exports, "computeDestinationPoint", { enumerable: true, get: function get() {
        return _computeDestinationPoint.default;
      } });
      Object.defineProperty(exports, "convertArea", { enumerable: true, get: function get() {
        return _convertArea.default;
      } });
      Object.defineProperty(exports, "convertDistance", { enumerable: true, get: function get() {
        return _convertDistance.default;
      } });
      Object.defineProperty(exports, "convertSpeed", { enumerable: true, get: function get() {
        return _convertSpeed.default;
      } });
      Object.defineProperty(exports, "decimalToSexagesimal", { enumerable: true, get: function get() {
        return _decimalToSexagesimal.default;
      } });
      Object.defineProperty(exports, "findNearest", { enumerable: true, get: function get() {
        return _findNearest.default;
      } });
      Object.defineProperty(exports, "getAreaOfPolygon", { enumerable: true, get: function get() {
        return _getAreaOfPolygon.default;
      } });
      Object.defineProperty(exports, "getBounds", { enumerable: true, get: function get() {
        return _getBounds.default;
      } });
      Object.defineProperty(exports, "getBoundsOfDistance", { enumerable: true, get: function get() {
        return _getBoundsOfDistance.default;
      } });
      Object.defineProperty(exports, "getCenter", { enumerable: true, get: function get() {
        return _getCenter.default;
      } });
      Object.defineProperty(exports, "getCenterOfBounds", { enumerable: true, get: function get() {
        return _getCenterOfBounds.default;
      } });
      Object.defineProperty(exports, "getCompassDirection", { enumerable: true, get: function get() {
        return _getCompassDirection.default;
      } });
      Object.defineProperty(exports, "getCoordinateKey", { enumerable: true, get: function get() {
        return _getCoordinateKey.default;
      } });
      Object.defineProperty(exports, "getCoordinateKeys", { enumerable: true, get: function get() {
        return _getCoordinateKeys.default;
      } });
      Object.defineProperty(exports, "getDistance", { enumerable: true, get: function get() {
        return _getDistance.default;
      } });
      Object.defineProperty(exports, "getDistanceFromLine", { enumerable: true, get: function get() {
        return _getDistanceFromLine.default;
      } });
      Object.defineProperty(exports, "getGreatCircleBearing", { enumerable: true, get: function get() {
        return _getGreatCircleBearing.default;
      } });
      Object.defineProperty(exports, "getLatitude", { enumerable: true, get: function get() {
        return _getLatitude.default;
      } });
      Object.defineProperty(exports, "getLongitude", { enumerable: true, get: function get() {
        return _getLongitude.default;
      } });
      Object.defineProperty(exports, "getPathLength", { enumerable: true, get: function get() {
        return _getPathLength.default;
      } });
      Object.defineProperty(exports, "getPreciseDistance", { enumerable: true, get: function get() {
        return _getPreciseDistance.default;
      } });
      Object.defineProperty(exports, "getRhumbLineBearing", { enumerable: true, get: function get() {
        return _getRhumbLineBearing.default;
      } });
      Object.defineProperty(exports, "getRoughCompassDirection", { enumerable: true, get: function get() {
        return _getRoughCompassDirection.default;
      } });
      Object.defineProperty(exports, "getSpeed", { enumerable: true, get: function get() {
        return _getSpeed.default;
      } });
      Object.defineProperty(exports, "isDecimal", { enumerable: true, get: function get() {
        return _isDecimal.default;
      } });
      Object.defineProperty(exports, "isPointInLine", { enumerable: true, get: function get() {
        return _isPointInLine.default;
      } });
      Object.defineProperty(exports, "isPointInPolygon", { enumerable: true, get: function get() {
        return _isPointInPolygon.default;
      } });
      Object.defineProperty(exports, "isPointNearLine", { enumerable: true, get: function get() {
        return _isPointNearLine.default;
      } });
      Object.defineProperty(exports, "isPointWithinRadius", { enumerable: true, get: function get() {
        return _isPointWithinRadius.default;
      } });
      Object.defineProperty(exports, "isSexagesimal", { enumerable: true, get: function get() {
        return _isSexagesimal.default;
      } });
      Object.defineProperty(exports, "isValidCoordinate", { enumerable: true, get: function get() {
        return _isValidCoordinate.default;
      } });
      Object.defineProperty(exports, "isValidLatitude", { enumerable: true, get: function get() {
        return _isValidLatitude.default;
      } });
      Object.defineProperty(exports, "isValidLongitude", { enumerable: true, get: function get() {
        return _isValidLongitude.default;
      } });
      Object.defineProperty(exports, "orderByDistance", { enumerable: true, get: function get() {
        return _orderByDistance.default;
      } });
      Object.defineProperty(exports, "sexagesimalToDecimal", { enumerable: true, get: function get() {
        return _sexagesimalToDecimal.default;
      } });
      Object.defineProperty(exports, "toDecimal", { enumerable: true, get: function get() {
        return _toDecimal.default;
      } });
      Object.defineProperty(exports, "toRad", { enumerable: true, get: function get() {
        return _toRad.default;
      } });
      Object.defineProperty(exports, "toDeg", { enumerable: true, get: function get() {
        return _toDeg.default;
      } });
      Object.defineProperty(exports, "wktToPolygon", { enumerable: true, get: function get() {
        return _wktToPolygon.default;
      } });
      var _computeDestinationPoint = _interopRequireDefault(require_computeDestinationPoint());
      var _convertArea = _interopRequireDefault(require_convertArea());
      var _convertDistance = _interopRequireDefault(require_convertDistance());
      var _convertSpeed = _interopRequireDefault(require_convertSpeed());
      var _decimalToSexagesimal = _interopRequireDefault(require_decimalToSexagesimal());
      var _findNearest = _interopRequireDefault(require_findNearest());
      var _getAreaOfPolygon = _interopRequireDefault(require_getAreaOfPolygon());
      var _getBounds = _interopRequireDefault(require_getBounds());
      var _getBoundsOfDistance = _interopRequireDefault(require_getBoundsOfDistance());
      var _getCenter = _interopRequireDefault(require_getCenter());
      var _getCenterOfBounds = _interopRequireDefault(require_getCenterOfBounds());
      var _getCompassDirection = _interopRequireDefault(require_getCompassDirection());
      var _getCoordinateKey = _interopRequireDefault(require_getCoordinateKey());
      var _getCoordinateKeys = _interopRequireDefault(require_getCoordinateKeys());
      var _getDistance = _interopRequireDefault(require_getDistance());
      var _getDistanceFromLine = _interopRequireDefault(require_getDistanceFromLine());
      var _getGreatCircleBearing = _interopRequireDefault(require_getGreatCircleBearing());
      var _getLatitude = _interopRequireDefault(require_getLatitude());
      var _getLongitude = _interopRequireDefault(require_getLongitude());
      var _getPathLength = _interopRequireDefault(require_getPathLength());
      var _getPreciseDistance = _interopRequireDefault(require_getPreciseDistance());
      var _getRhumbLineBearing = _interopRequireDefault(require_getRhumbLineBearing());
      var _getRoughCompassDirection = _interopRequireDefault(require_getRoughCompassDirection());
      var _getSpeed = _interopRequireDefault(require_getSpeed());
      var _isDecimal = _interopRequireDefault(require_isDecimal());
      var _isPointInLine = _interopRequireDefault(require_isPointInLine());
      var _isPointInPolygon = _interopRequireDefault(require_isPointInPolygon());
      var _isPointNearLine = _interopRequireDefault(require_isPointNearLine());
      var _isPointWithinRadius = _interopRequireDefault(require_isPointWithinRadius());
      var _isSexagesimal = _interopRequireDefault(require_isSexagesimal());
      var _isValidCoordinate = _interopRequireDefault(require_isValidCoordinate());
      var _isValidLatitude = _interopRequireDefault(require_isValidLatitude());
      var _isValidLongitude = _interopRequireDefault(require_isValidLongitude());
      var _orderByDistance = _interopRequireDefault(require_orderByDistance());
      var _sexagesimalToDecimal = _interopRequireDefault(require_sexagesimalToDecimal());
      var _toDecimal = _interopRequireDefault(require_toDecimal());
      var _toRad = _interopRequireDefault(require_toRad());
      var _toDeg = _interopRequireDefault(require_toDeg());
      var _wktToPolygon = _interopRequireDefault(require_wktToPolygon());
      var _constants = require_constants();
      Object.keys(_constants).forEach(function(key) {
        if (key === "default" || key === "__esModule")
          return;
        if (Object.prototype.hasOwnProperty.call(_exportNames, key))
          return;
        Object.defineProperty(exports, key, { enumerable: true, get: function get() {
          return _constants[key];
        } });
      });
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }
  });

  // ../node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "../node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      var f;
      var g;
      var h;
      var k;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l = performance;
        exports.unstable_now = function() {
          return l.now();
        };
      } else {
        p = Date, q = p.now();
        exports.unstable_now = function() {
          return p.now() - q;
        };
      }
      var l;
      var p;
      var q;
      if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
        t = null, u = null, w = function() {
          if (null !== t)
            try {
              var a = exports.unstable_now();
              t(true, a);
              t = null;
            } catch (b) {
              throw setTimeout(w, 0), b;
            }
        };
        f = function(a) {
          null !== t ? setTimeout(f, 0, a) : (t = a, setTimeout(w, 0));
        };
        g = function(a, b) {
          u = setTimeout(a, b);
        };
        h = function() {
          clearTimeout(u);
        };
        exports.unstable_shouldYield = function() {
          return false;
        };
        k = exports.unstable_forceFrameRate = function() {
        };
      } else {
        x = window.setTimeout, y = window.clearTimeout;
        if ("undefined" !== typeof console) {
          z = window.cancelAnimationFrame;
          "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        A = false, B = null, C = -1, D = 5, E = 0;
        exports.unstable_shouldYield = function() {
          return exports.unstable_now() >= E;
        };
        k = function() {
        };
        exports.unstable_forceFrameRate = function(a) {
          0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1e3 / a) : 5;
        };
        F = new MessageChannel(), G = F.port2;
        F.port1.onmessage = function() {
          if (null !== B) {
            var a = exports.unstable_now();
            E = a + D;
            try {
              B(true, a) ? G.postMessage(null) : (A = false, B = null);
            } catch (b) {
              throw G.postMessage(null), b;
            }
          } else
            A = false;
        };
        f = function(a) {
          B = a;
          A || (A = true, G.postMessage(null));
        };
        g = function(a, b) {
          C = x(function() {
            a(exports.unstable_now());
          }, b);
        };
        h = function() {
          y(C);
          C = -1;
        };
      }
      var t;
      var u;
      var w;
      var x;
      var y;
      var z;
      var A;
      var B;
      var C;
      var D;
      var E;
      var F;
      var G;
      function H(a, b) {
        var c = a.length;
        a.push(b);
        a:
          for (; ; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (void 0 !== e && 0 < I(e, b))
              a[d] = b, a[c] = e, c = d;
            else
              break a;
          }
      }
      function J(a) {
        a = a[0];
        return void 0 === a ? null : a;
      }
      function K(a) {
        var b = a[0];
        if (void 0 !== b) {
          var c = a.pop();
          if (c !== b) {
            a[0] = c;
            a:
              for (var d = 0, e = a.length; d < e; ) {
                var m = 2 * (d + 1) - 1, n = a[m], v = m + 1, r = a[v];
                if (void 0 !== n && 0 > I(n, c))
                  void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);
                else if (void 0 !== r && 0 > I(r, c))
                  a[d] = r, a[v] = c, d = v;
                else
                  break a;
              }
          }
          return b;
        }
        return null;
      }
      function I(a, b) {
        var c = a.sortIndex - b.sortIndex;
        return 0 !== c ? c : a.id - b.id;
      }
      var L = [];
      var M = [];
      var N = 1;
      var O = null;
      var P2 = 3;
      var Q = false;
      var R = false;
      var S = false;
      function T(a) {
        for (var b = J(M); null !== b; ) {
          if (null === b.callback)
            K(M);
          else if (b.startTime <= a)
            K(M), b.sortIndex = b.expirationTime, H(L, b);
          else
            break;
          b = J(M);
        }
      }
      function U(a) {
        S = false;
        T(a);
        if (!R)
          if (null !== J(L))
            R = true, f(V);
          else {
            var b = J(M);
            null !== b && g(U, b.startTime - a);
          }
      }
      function V(a, b) {
        R = false;
        S && (S = false, h());
        Q = true;
        var c = P2;
        try {
          T(b);
          for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
            var d = O.callback;
            if ("function" === typeof d) {
              O.callback = null;
              P2 = O.priorityLevel;
              var e = d(O.expirationTime <= b);
              b = exports.unstable_now();
              "function" === typeof e ? O.callback = e : O === J(L) && K(L);
              T(b);
            } else
              K(L);
            O = J(L);
          }
          if (null !== O)
            var m = true;
          else {
            var n = J(M);
            null !== n && g(U, n.startTime - b);
            m = false;
          }
          return m;
        } finally {
          O = null, P2 = c, Q = false;
        }
      }
      var W = k;
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a) {
        a.callback = null;
      };
      exports.unstable_continueExecution = function() {
        R || Q || (R = true, f(V));
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return P2;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return J(L);
      };
      exports.unstable_next = function(a) {
        switch (P2) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = P2;
        }
        var c = P2;
        P2 = b;
        try {
          return a();
        } finally {
          P2 = c;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = W;
      exports.unstable_runWithPriority = function(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a = 3;
        }
        var c = P2;
        P2 = a;
        try {
          return b();
        } finally {
          P2 = c;
        }
      };
      exports.unstable_scheduleCallback = function(a, b, c) {
        var d = exports.unstable_now();
        "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
        switch (a) {
          case 1:
            var e = -1;
            break;
          case 2:
            e = 250;
            break;
          case 5:
            e = 1073741823;
            break;
          case 4:
            e = 1e4;
            break;
          default:
            e = 5e3;
        }
        e = c + e;
        a = { id: N++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
        c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = true, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = true, f(V)));
        return a;
      };
      exports.unstable_wrapCallback = function(a) {
        var b = P2;
        return function() {
          var c = P2;
          P2 = b;
          try {
            return a.apply(this, arguments);
          } finally {
            P2 = c;
          }
        };
      };
    }
  });

  // ../node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../node_modules/scheduler/index.js"(exports, module2) {
      "use strict";
      if (true) {
        module2.exports = require_scheduler_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // ../node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "../node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      var aa = require_react();
      var m = require_object_assign();
      var r = require_scheduler();
      function y(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
          b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      if (!aa)
        throw Error(y(227));
      var ba = /* @__PURE__ */ new Set();
      var ca = {};
      function da(a, b) {
        ea(a, b);
        ea(a + "Capture", b);
      }
      function ea(a, b) {
        ca[a] = b;
        for (a = 0; a < b.length; a++)
          ba.add(b[a]);
      }
      var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var ia = Object.prototype.hasOwnProperty;
      var ja = {};
      var ka = {};
      function la(a) {
        if (ia.call(ka, a))
          return true;
        if (ia.call(ja, a))
          return false;
        if (ha.test(a))
          return ka[a] = true;
        ja[a] = true;
        return false;
      }
      function ma(a, b, c, d) {
        if (null !== c && 0 === c.type)
          return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d)
              return false;
            if (null !== c)
              return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function na(a, b, c, d) {
        if (null === b || "undefined" === typeof b || ma(a, b, c, d))
          return true;
        if (d)
          return false;
        if (null !== c)
          switch (c.type) {
            case 3:
              return !b;
            case 4:
              return false === b;
            case 5:
              return isNaN(b);
            case 6:
              return isNaN(b) || 1 > b;
          }
        return false;
      }
      function B(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var D = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        D[a] = new B(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        D[b] = new B(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        D[a] = new B(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        D[a] = new B(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        D[a] = new B(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        D[a] = new B(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var oa = /[\-:]([a-z])/g;
      function pa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          oa,
          pa
        );
        D[b] = new B(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(oa, pa);
        D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(oa, pa);
        D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
      });
      D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function qa(a, b, c, d) {
        var e = D.hasOwnProperty(b) ? D[b] : null;
        var f = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
        f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
      }
      var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var sa = 60103;
      var ta = 60106;
      var ua = 60107;
      var wa = 60108;
      var xa = 60114;
      var ya = 60109;
      var za = 60110;
      var Aa = 60112;
      var Ba = 60113;
      var Ca = 60120;
      var Da = 60115;
      var Ea = 60116;
      var Fa = 60121;
      var Ga = 60128;
      var Ha = 60129;
      var Ia = 60130;
      var Ja = 60131;
      if ("function" === typeof Symbol && Symbol.for) {
        E = Symbol.for;
        sa = E("react.element");
        ta = E("react.portal");
        ua = E("react.fragment");
        wa = E("react.strict_mode");
        xa = E("react.profiler");
        ya = E("react.provider");
        za = E("react.context");
        Aa = E("react.forward_ref");
        Ba = E("react.suspense");
        Ca = E("react.suspense_list");
        Da = E("react.memo");
        Ea = E("react.lazy");
        Fa = E("react.block");
        E("react.scope");
        Ga = E("react.opaque.id");
        Ha = E("react.debug_trace_mode");
        Ia = E("react.offscreen");
        Ja = E("react.legacy_hidden");
      }
      var E;
      var Ka = "function" === typeof Symbol && Symbol.iterator;
      function La(a) {
        if (null === a || "object" !== typeof a)
          return null;
        a = Ka && a[Ka] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var Ma;
      function Na(a) {
        if (void 0 === Ma)
          try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            Ma = b && b[1] || "";
          }
        return "\n" + Ma + a;
      }
      var Oa = false;
      function Pa(a, b) {
        if (!a || Oa)
          return "";
        Oa = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b)
            if (b = function() {
              throw Error();
            }, Object.defineProperty(b.prototype, "props", { set: function() {
              throw Error();
            } }), "object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(b, []);
              } catch (k) {
                var d = k;
              }
              Reflect.construct(a, [], b);
            } else {
              try {
                b.call();
              } catch (k) {
                d = k;
              }
              a.call(b.prototype);
            }
          else {
            try {
              throw Error();
            } catch (k) {
              d = k;
            }
            a();
          }
        } catch (k) {
          if (k && d && "string" === typeof k.stack) {
            for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
              h--;
            for (; 1 <= g && 0 <= h; g--, h--)
              if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h) {
                  do
                    if (g--, h--, 0 > h || e[g] !== f[h])
                      return "\n" + e[g].replace(" at new ", " at ");
                  while (1 <= g && 0 <= h);
                }
                break;
              }
          }
        } finally {
          Oa = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
      }
      function Qa(a) {
        switch (a.tag) {
          case 5:
            return Na(a.type);
          case 16:
            return Na("Lazy");
          case 13:
            return Na("Suspense");
          case 19:
            return Na("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Pa(a.type, false), a;
          case 11:
            return a = Pa(a.type.render, false), a;
          case 22:
            return a = Pa(a.type._render, false), a;
          case 1:
            return a = Pa(a.type, true), a;
          default:
            return "";
        }
      }
      function Ra(a) {
        if (null == a)
          return null;
        if ("function" === typeof a)
          return a.displayName || a.name || null;
        if ("string" === typeof a)
          return a;
        switch (a) {
          case ua:
            return "Fragment";
          case ta:
            return "Portal";
          case xa:
            return "Profiler";
          case wa:
            return "StrictMode";
          case Ba:
            return "Suspense";
          case Ca:
            return "SuspenseList";
        }
        if ("object" === typeof a)
          switch (a.$$typeof) {
            case za:
              return (a.displayName || "Context") + ".Consumer";
            case ya:
              return (a._context.displayName || "Context") + ".Provider";
            case Aa:
              var b = a.render;
              b = b.displayName || b.name || "";
              return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
            case Da:
              return Ra(a.type);
            case Fa:
              return Ra(a._render);
            case Ea:
              b = a._payload;
              a = a._init;
              try {
                return Ra(a(b));
              } catch (c) {
              }
          }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "object":
          case "string":
          case "undefined":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a)
          return false;
        var b = a._valueTracker;
        if (!b)
          return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a)
          return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function $a(a, b) {
        b = b.checked;
        null != b && qa(a, "checked", b, false);
      }
      function ab(a, b) {
        $a(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c)
          if ("number" === d) {
            if (0 === c && "" === a.value || a.value != c)
              a.value = "" + c;
          } else
            a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function cb(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
            return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function bb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a)
          null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      function db(a) {
        var b = "";
        aa.Children.forEach(a, function(a2) {
          null != a2 && (b += a2);
        });
        return b;
      }
      function eb(a, b) {
        a = m({ children: void 0 }, b);
        if (b = db(b.children))
          a.children = b;
        return a;
      }
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++)
            b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++)
            e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML)
          throw Error(y(91));
        return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b)
              throw Error(y(92));
            if (Array.isArray(c)) {
              if (!(1 >= c.length))
                throw Error(y(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
      function lb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function mb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var nb;
      var ob = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if (a.namespaceURI !== kb.svg || "innerHTML" in a)
          a.innerHTML = b;
        else {
          nb = nb || document.createElement("div");
          nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = nb.firstChild; a.firstChild; )
            a.removeChild(a.firstChild);
          for (; b.firstChild; )
            a.appendChild(b.firstChild);
        }
      });
      function pb(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var qb = {
        animationIterationCount: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var rb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(qb).forEach(function(a) {
        rb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          qb[b] = qb[a];
        });
      });
      function sb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
      }
      function tb(a, b) {
        a = a.style;
        for (var c in b)
          if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--"), e = sb(c, b[c], d);
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : a[c] = e;
          }
      }
      var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function vb(a, b) {
        if (b) {
          if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
            throw Error(y(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children)
              throw Error(y(60));
            if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML))
              throw Error(y(61));
          }
          if (null != b.style && "object" !== typeof b.style)
            throw Error(y(62));
        }
      }
      function wb(a, b) {
        if (-1 === a.indexOf("-"))
          return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb)
            throw Error(y(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b)
            for (a = 0; a < b.length; a++)
              Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb(a, b, c, d, e) {
        return a(b, c, d, e);
      }
      function Ib() {
      }
      var Jb = Gb;
      var Kb = false;
      var Lb = false;
      function Mb() {
        if (null !== zb || null !== Ab)
          Ib(), Fb();
      }
      function Nb(a, b, c) {
        if (Lb)
          return a(b, c);
        Lb = true;
        try {
          return Jb(a, b, c);
        } finally {
          Lb = false, Mb();
        }
      }
      function Ob(a, b) {
        var c = a.stateNode;
        if (null === c)
          return null;
        var d = Db(c);
        if (null === d)
          return null;
        c = d[b];
        a:
          switch (b) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
              a = !d;
              break a;
            default:
              a = false;
          }
        if (a)
          return null;
        if (c && "function" !== typeof c)
          throw Error(y(231, b, typeof c));
        return c;
      }
      var Pb = false;
      if (fa)
        try {
          Qb = {};
          Object.defineProperty(Qb, "passive", { get: function() {
            Pb = true;
          } });
          window.addEventListener("test", Qb, Qb);
          window.removeEventListener("test", Qb, Qb);
        } catch (a) {
          Pb = false;
        }
      var Qb;
      function Rb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (n) {
          this.onError(n);
        }
      }
      var Sb = false;
      var Tb = null;
      var Ub = false;
      var Vb = null;
      var Wb = { onError: function(a) {
        Sb = true;
        Tb = a;
      } };
      function Xb(a, b, c, d, e, f, g, h, k) {
        Sb = false;
        Tb = null;
        Rb.apply(Wb, arguments);
      }
      function Yb(a, b, c, d, e, f, g, h, k) {
        Xb.apply(this, arguments);
        if (Sb) {
          if (Sb) {
            var l = Tb;
            Sb = false;
            Tb = null;
          } else
            throw Error(y(198));
          Ub || (Ub = true, Vb = l);
        }
      }
      function Zb(a) {
        var b = a, c = a;
        if (a.alternate)
          for (; b.return; )
            b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function $b(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b)
            return b.dehydrated;
        }
        return null;
      }
      function ac(a) {
        if (Zb(a) !== a)
          throw Error(y(188));
      }
      function bc(a) {
        var b = a.alternate;
        if (!b) {
          b = Zb(a);
          if (null === b)
            throw Error(y(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e)
            break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c)
                return ac(e), a;
              if (f === d)
                return ac(e), b;
              f = f.sibling;
            }
            throw Error(y(188));
          }
          if (c.return !== d.return)
            c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g)
                throw Error(y(189));
            }
          }
          if (c.alternate !== d)
            throw Error(y(190));
        }
        if (3 !== c.tag)
          throw Error(y(188));
        return c.stateNode.current === c ? a : b;
      }
      function cc(a) {
        a = bc(a);
        if (!a)
          return null;
        for (var b = a; ; ) {
          if (5 === b.tag || 6 === b.tag)
            return b;
          if (b.child)
            b.child.return = b, b = b.child;
          else {
            if (b === a)
              break;
            for (; !b.sibling; ) {
              if (!b.return || b.return === a)
                return null;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return null;
      }
      function dc(a, b) {
        for (var c = a.alternate; null !== b; ) {
          if (b === a || b === c)
            return true;
          b = b.return;
        }
        return false;
      }
      var ec;
      var fc;
      var gc;
      var hc;
      var ic = false;
      var jc = [];
      var kc = null;
      var lc = null;
      var mc = null;
      var nc = /* @__PURE__ */ new Map();
      var oc = /* @__PURE__ */ new Map();
      var pc = [];
      var qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function rc(a, b, c, d, e) {
        return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
      }
      function sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            kc = null;
            break;
          case "dragenter":
          case "dragleave":
            lc = null;
            break;
          case "mouseover":
          case "mouseout":
            mc = null;
            break;
          case "pointerover":
          case "pointerout":
            nc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            oc.delete(b.pointerId);
        }
      }
      function tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f)
          return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return kc = tc(kc, a, b, c, d, e), true;
          case "dragenter":
            return lc = tc(lc, a, b, c, d, e), true;
          case "mouseover":
            return mc = tc(mc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function vc(a) {
        var b = wc(a.target);
        if (null !== b) {
          var c = Zb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = $b(c), null !== b) {
                a.blockedOn = b;
                hc(a.lanePriority, function() {
                  r.unstable_runWithPriority(a.priority, function() {
                    gc(c);
                  });
                });
                return;
              }
            } else if (3 === b && c.stateNode.hydrate) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function xc(a) {
        if (null !== a.blockedOn)
          return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null !== c)
            return b = Cb(c), null !== b && fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function zc(a, b, c) {
        xc(a) && c.delete(b);
      }
      function Ac() {
        for (ic = false; 0 < jc.length; ) {
          var a = jc[0];
          if (null !== a.blockedOn) {
            a = Cb(a.blockedOn);
            null !== a && ec(a);
            break;
          }
          for (var b = a.targetContainers; 0 < b.length; ) {
            var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
            if (null !== c) {
              a.blockedOn = c;
              break;
            }
            b.shift();
          }
          null === a.blockedOn && jc.shift();
        }
        null !== kc && xc(kc) && (kc = null);
        null !== lc && xc(lc) && (lc = null);
        null !== mc && xc(mc) && (mc = null);
        nc.forEach(zc);
        oc.forEach(zc);
      }
      function Bc(a, b) {
        a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
      }
      function Cc(a) {
        function b(b2) {
          return Bc(b2, a);
        }
        if (0 < jc.length) {
          Bc(jc[0], a);
          for (var c = 1; c < jc.length; c++) {
            var d = jc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== kc && Bc(kc, a);
        null !== lc && Bc(lc, a);
        null !== mc && Bc(mc, a);
        nc.forEach(b);
        oc.forEach(b);
        for (c = 0; c < pc.length; c++)
          d = pc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); )
          vc(c), null === c.blockedOn && pc.shift();
      }
      function Dc(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") };
      var Fc = {};
      var Gc = {};
      fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
      function Hc(a) {
        if (Fc[a])
          return Fc[a];
        if (!Ec[a])
          return a;
        var b = Ec[a], c;
        for (c in b)
          if (b.hasOwnProperty(c) && c in Gc)
            return Fc[a] = b[c];
        return a;
      }
      var Ic = Hc("animationend");
      var Jc = Hc("animationiteration");
      var Kc = Hc("animationstart");
      var Lc = Hc("transitionend");
      var Mc = /* @__PURE__ */ new Map();
      var Nc = /* @__PURE__ */ new Map();
      var Oc = [
        "abort",
        "abort",
        Ic,
        "animationEnd",
        Jc,
        "animationIteration",
        Kc,
        "animationStart",
        "canplay",
        "canPlay",
        "canplaythrough",
        "canPlayThrough",
        "durationchange",
        "durationChange",
        "emptied",
        "emptied",
        "encrypted",
        "encrypted",
        "ended",
        "ended",
        "error",
        "error",
        "gotpointercapture",
        "gotPointerCapture",
        "load",
        "load",
        "loadeddata",
        "loadedData",
        "loadedmetadata",
        "loadedMetadata",
        "loadstart",
        "loadStart",
        "lostpointercapture",
        "lostPointerCapture",
        "playing",
        "playing",
        "progress",
        "progress",
        "seeking",
        "seeking",
        "stalled",
        "stalled",
        "suspend",
        "suspend",
        "timeupdate",
        "timeUpdate",
        Lc,
        "transitionEnd",
        "waiting",
        "waiting"
      ];
      function Pc(a, b) {
        for (var c = 0; c < a.length; c += 2) {
          var d = a[c], e = a[c + 1];
          e = "on" + (e[0].toUpperCase() + e.slice(1));
          Nc.set(d, b);
          Mc.set(d, e);
          da(e, [d]);
        }
      }
      var Qc = r.unstable_now;
      Qc();
      var F = 8;
      function Rc(a) {
        if (0 !== (1 & a))
          return F = 15, 1;
        if (0 !== (2 & a))
          return F = 14, 2;
        if (0 !== (4 & a))
          return F = 13, 4;
        var b = 24 & a;
        if (0 !== b)
          return F = 12, b;
        if (0 !== (a & 32))
          return F = 11, 32;
        b = 192 & a;
        if (0 !== b)
          return F = 10, b;
        if (0 !== (a & 256))
          return F = 9, 256;
        b = 3584 & a;
        if (0 !== b)
          return F = 8, b;
        if (0 !== (a & 4096))
          return F = 7, 4096;
        b = 4186112 & a;
        if (0 !== b)
          return F = 6, b;
        b = 62914560 & a;
        if (0 !== b)
          return F = 5, b;
        if (a & 67108864)
          return F = 4, 67108864;
        if (0 !== (a & 134217728))
          return F = 3, 134217728;
        b = 805306368 & a;
        if (0 !== b)
          return F = 2, b;
        if (0 !== (1073741824 & a))
          return F = 1, 1073741824;
        F = 8;
        return a;
      }
      function Sc(a) {
        switch (a) {
          case 99:
            return 15;
          case 98:
            return 10;
          case 97:
          case 96:
            return 8;
          case 95:
            return 2;
          default:
            return 0;
        }
      }
      function Tc(a) {
        switch (a) {
          case 15:
          case 14:
            return 99;
          case 13:
          case 12:
          case 11:
          case 10:
            return 98;
          case 9:
          case 8:
          case 7:
          case 6:
          case 4:
          case 5:
            return 97;
          case 3:
          case 2:
          case 1:
            return 95;
          case 0:
            return 90;
          default:
            throw Error(y(358, a));
        }
      }
      function Uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c)
          return F = 0;
        var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
        if (0 !== f)
          d = f, e = F = 15;
        else if (f = c & 134217727, 0 !== f) {
          var k = f & ~g;
          0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
        } else
          f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);
        if (0 === d)
          return 0;
        d = 31 - Vc(d);
        d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
        if (0 !== b && b !== d && 0 === (b & g)) {
          Rc(b);
          if (e <= F)
            return b;
          F = e;
        }
        b = a.entangledLanes;
        if (0 !== b)
          for (a = a.entanglements, b &= d; 0 < b; )
            c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function Wc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function Xc(a, b) {
        switch (a) {
          case 15:
            return 1;
          case 14:
            return 2;
          case 12:
            return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;
          case 10:
            return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;
          case 8:
            return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;
          case 2:
            return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
        }
        throw Error(y(358, a));
      }
      function Yc(a) {
        return a & -a;
      }
      function Zc(a) {
        for (var b = [], c = 0; 31 > c; c++)
          b.push(a);
        return b;
      }
      function $c(a, b, c) {
        a.pendingLanes |= b;
        var d = b - 1;
        a.suspendedLanes &= d;
        a.pingedLanes &= d;
        a = a.eventTimes;
        b = 31 - Vc(b);
        a[b] = c;
      }
      var Vc = Math.clz32 ? Math.clz32 : ad;
      var bd = Math.log;
      var cd = Math.LN2;
      function ad(a) {
        return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
      }
      var dd = r.unstable_UserBlockingPriority;
      var ed = r.unstable_runWithPriority;
      var fd = true;
      function gd(a, b, c, d) {
        Kb || Ib();
        var e = hd, f = Kb;
        Kb = true;
        try {
          Hb(e, a, b, c, d);
        } finally {
          (Kb = f) || Mb();
        }
      }
      function id(a, b, c, d) {
        ed(dd, hd.bind(null, a, b, c, d));
      }
      function hd(a, b, c, d) {
        if (fd) {
          var e;
          if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a))
            a = rc(null, a, b, c, d), jc.push(a);
          else {
            var f = yc(a, b, c, d);
            if (null === f)
              e && sc(a, d);
            else {
              if (e) {
                if (-1 < qc.indexOf(a)) {
                  a = rc(f, a, b, c, d);
                  jc.push(a);
                  return;
                }
                if (uc(f, a, b, c, d))
                  return;
                sc(a, d);
              }
              jd(a, b, d, null, c);
            }
          }
        }
      }
      function yc(a, b, c, d) {
        var e = xb(d);
        e = wc(e);
        if (null !== e) {
          var f = Zb(e);
          if (null === f)
            e = null;
          else {
            var g = f.tag;
            if (13 === g) {
              e = $b(f);
              if (null !== e)
                return e;
              e = null;
            } else if (3 === g) {
              if (f.stateNode.hydrate)
                return 3 === f.tag ? f.stateNode.containerInfo : null;
              e = null;
            } else
              f !== e && (e = null);
          }
        }
        jd(a, b, d, e, c);
        return null;
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md)
          return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++)
          ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
          ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a)
            a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        m(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = m({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a)
          return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = m({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = m({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = m({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = m({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = m({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b)
            return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = m({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = fa && "CompositionEvent" in window;
      var be = null;
      fa && "documentMode" in document && (be = document.documentMode);
      var ce = fa && "TextEvent" in window && !be;
      var de = fa && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which)
              return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie)
          return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length)
                return b.char;
              if (b.which)
                return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null;
      var qe = null;
      function re2(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b))
          return a;
      }
      function ve(a, b) {
        if ("change" === a)
          return b;
      }
      var we = false;
      if (fa) {
        if (fa) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else
          xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          a = re2;
          if (Kb)
            a(b);
          else {
            Kb = true;
            try {
              Gb(a, b);
            } finally {
              Kb = false, Mb();
            }
          }
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a)
          return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a)
          return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a)
          return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      var Ie = Object.prototype.hasOwnProperty;
      function Je(a, b) {
        if (He(a, b))
          return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
          return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length)
          return false;
        for (d = 0; d < c.length; d++)
          if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
            return false;
        return true;
      }
      function Ke(a) {
        for (; a && a.firstChild; )
          a = a.firstChild;
        return a;
      }
      function Le(a, b) {
        var c = Ke(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b)
              return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Ke(c);
        }
      }
      function Me(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Ne() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c)
            a = b.contentWindow;
          else
            break;
          b = Xa(a.document);
        }
        return b;
      }
      function Oe(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      var Pe = fa && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      Pc(
        "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
        0
      );
      Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
      Pc(Oc, 2);
      for (Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
        Nc.set(Ve[We], 0);
      var Ve;
      var We;
      ea("onMouseEnter", ["mouseout", "mouseover"]);
      ea("onMouseLeave", ["mouseout", "mouseover"]);
      ea("onPointerEnter", ["pointerout", "pointerover"]);
      ea("onPointerLeave", ["pointerout", "pointerover"]);
      da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
      function Ze(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Yb(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b)
              for (var g = d.length - 1; 0 <= g; g--) {
                var h = d[g], k = h.instance, l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped())
                  break a;
                Ze(e, h, l);
                f = k;
              }
            else
              for (g = 0; g < d.length; g++) {
                h = d[g];
                k = h.instance;
                l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped())
                  break a;
                Ze(e, h, l);
                f = k;
              }
          }
        }
        if (Ub)
          throw a = Vb, Ub = false, Vb = null, a;
      }
      function G(a, b) {
        var c = $e(b), d = a + "__bubble";
        c.has(d) || (af(b, a, 2, false), c.add(d));
      }
      var bf = "_reactListening" + Math.random().toString(36).slice(2);
      function cf(a) {
        a[bf] || (a[bf] = true, ba.forEach(function(b) {
          Ye.has(b) || df(b, false, a, null);
          df(b, true, a, null);
        }));
      }
      function df(a, b, c, d) {
        var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f = c;
        "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);
        if (null !== d && !b && Ye.has(a)) {
          if ("scroll" !== a)
            return;
          e |= 2;
          f = d;
        }
        var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
        g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
      }
      function af(a, b, c, d) {
        var e = Nc.get(b);
        switch (void 0 === e ? 2 : e) {
          case 0:
            e = gd;
            break;
          case 1:
            e = id;
            break;
          default:
            e = hd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function jd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d)
          a:
            for (; ; ) {
              if (null === d)
                return;
              var g = d.tag;
              if (3 === g || 4 === g) {
                var h = d.stateNode.containerInfo;
                if (h === e || 8 === h.nodeType && h.parentNode === e)
                  break;
                if (4 === g)
                  for (g = d.return; null !== g; ) {
                    var k = g.tag;
                    if (3 === k || 4 === k) {
                      if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e)
                        return;
                    }
                    g = g.return;
                  }
                for (; null !== h; ) {
                  g = wc(h);
                  if (null === g)
                    return;
                  k = g.tag;
                  if (5 === k || 6 === k) {
                    d = f = g;
                    continue a;
                  }
                  h = h.parentNode;
                }
              }
              d = d.return;
            }
        Nb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = Mc.get(a);
            if (void 0 !== h2) {
              var k2 = td, x = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c))
                    break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  x = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  x = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button)
                    break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case Ic:
                case Jc:
                case Kc:
                  k2 = Hd;
                  break;
                case Lc:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var w = 0 !== (b & 4), z = !w && "scroll" === a, u = w ? null !== h2 ? h2 + "Capture" : null : h2;
              w = [];
              for (var t = d2, q; null !== t; ) {
                q = t;
                var v = q.stateNode;
                5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));
                if (z)
                  break;
                t = t.return;
              }
              0 < w.length && (h2 = new k2(h2, x, null, c, e2), g2.push({ event: h2, listeners: w }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff]))
                break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (x = c.relatedTarget || c.toElement, k2 = d2, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag))
                    x = null;
                } else
                  k2 = null, x = d2;
                if (k2 !== x) {
                  w = Bd;
                  v = "onMouseLeave";
                  u = "onMouseEnter";
                  t = "mouse";
                  if ("pointerout" === a || "pointerover" === a)
                    w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
                  z = null == k2 ? h2 : ue(k2);
                  q = null == x ? h2 : ue(x);
                  h2 = new w(v, t + "leave", k2, c, e2);
                  h2.target = z;
                  h2.relatedTarget = q;
                  v = null;
                  wc(e2) === d2 && (w = new w(u, t + "enter", x, c, e2), w.target = q, w.relatedTarget = z, v = w);
                  z = v;
                  if (k2 && x)
                    b: {
                      w = k2;
                      u = x;
                      t = 0;
                      for (q = w; q; q = gf(q))
                        t++;
                      q = 0;
                      for (v = u; v; v = gf(v))
                        q++;
                      for (; 0 < t - q; )
                        w = gf(w), t--;
                      for (; 0 < q - t; )
                        u = gf(u), q--;
                      for (; t--; ) {
                        if (w === u || null !== u && w === u.alternate)
                          break b;
                        w = gf(w);
                        u = gf(u);
                      }
                      w = null;
                    }
                  else
                    w = null;
                  null !== k2 && hf(g2, h2, k2, w, false);
                  null !== x && null !== z && hf(g2, z, x, w, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type)
                var J = ve;
              else if (me(h2))
                if (we)
                  J = Fe;
                else {
                  J = De;
                  var K = Ce;
                }
              else
                (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (J = Ee);
              if (J && (J = J(a, d2))) {
                ne(g2, J, c, e2);
                break a;
              }
              K && K(a, h2, d2);
              "focusout" === a && (K = h2._wrapperState) && K.controlled && "number" === h2.type && bb(h2, "number", h2.value);
            }
            K = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(K) || "true" === K.contentEditable)
                  Qe = K, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe)
                  break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var Q;
            if (ae)
              b: {
                switch (a) {
                  case "compositionstart":
                    var L = "onCompositionStart";
                    break b;
                  case "compositionend":
                    L = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    L = "onCompositionUpdate";
                    break b;
                }
                L = void 0;
              }
            else
              ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");
            L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K = oe(d2, L), 0 < K.length && (L = new Ld(L, a, null, c, e2), g2.push({ event: L, listeners: K }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));
            if (Q = ce ? je(a, c) : ke(a, c))
              d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld(
                "onBeforeInput",
                "beforeinput",
                null,
                c,
                e2
              ), g2.push({ event: e2, listeners: d2 }), e2.data = Q);
          }
          se(g2, b);
        });
      }
      function ef(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function gf(a) {
        if (null === a)
          return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function hf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d)
            break;
          5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      function jf() {
      }
      var kf = null;
      var lf = null;
      function mf(a, b) {
        switch (a) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!b.autoFocus;
        }
        return false;
      }
      function nf(a, b) {
        return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var of = "function" === typeof setTimeout ? setTimeout : void 0;
      var pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      function qf(a) {
        1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
      }
      function rf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b)
            break;
        }
        return a;
      }
      function sf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b)
                return a;
              b--;
            } else
              "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var tf = 0;
      function uf(a) {
        return { $$typeof: Ga, toString: a, valueOf: a };
      }
      var vf = Math.random().toString(36).slice(2);
      var wf = "__reactFiber$" + vf;
      var xf = "__reactProps$" + vf;
      var ff = "__reactContainer$" + vf;
      var yf = "__reactEvents$" + vf;
      function wc(a) {
        var b = a[wf];
        if (b)
          return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[ff] || c[wf]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child)
              for (a = sf(a); null !== a; ) {
                if (c = a[wf])
                  return c;
                a = sf(a);
              }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[wf] || a[ff];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag)
          return a.stateNode;
        throw Error(y(33));
      }
      function Db(a) {
        return a[xf] || null;
      }
      function $e(a) {
        var b = a[yf];
        void 0 === b && (b = a[yf] = /* @__PURE__ */ new Set());
        return b;
      }
      var zf = [];
      var Af = -1;
      function Bf(a) {
        return { current: a };
      }
      function H(a) {
        0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
      }
      function I(a, b) {
        Af++;
        zf[Af] = a.current;
        a.current = b;
      }
      var Cf = {};
      var M = Bf(Cf);
      var N = Bf(false);
      var Df = Cf;
      function Ef(a, b) {
        var c = a.type.contextTypes;
        if (!c)
          return Cf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
          return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c)
          e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Ff(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function Gf() {
        H(N);
        H(M);
      }
      function Hf(a, b, c) {
        if (M.current !== Cf)
          throw Error(y(168));
        I(M, b);
        I(N, c);
      }
      function If(a, b, c) {
        var d = a.stateNode;
        a = b.childContextTypes;
        if ("function" !== typeof d.getChildContext)
          return c;
        d = d.getChildContext();
        for (var e in d)
          if (!(e in a))
            throw Error(y(108, Ra(b) || "Unknown", e));
        return m({}, c, d);
      }
      function Jf(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
        Df = M.current;
        I(M, a);
        I(N, N.current);
        return true;
      }
      function Kf(a, b, c) {
        var d = a.stateNode;
        if (!d)
          throw Error(y(169));
        c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
        I(N, c);
      }
      var Lf = null;
      var Mf = null;
      var Nf = r.unstable_runWithPriority;
      var Of = r.unstable_scheduleCallback;
      var Pf = r.unstable_cancelCallback;
      var Qf = r.unstable_shouldYield;
      var Rf = r.unstable_requestPaint;
      var Sf = r.unstable_now;
      var Tf = r.unstable_getCurrentPriorityLevel;
      var Uf = r.unstable_ImmediatePriority;
      var Vf = r.unstable_UserBlockingPriority;
      var Wf = r.unstable_NormalPriority;
      var Xf = r.unstable_LowPriority;
      var Yf = r.unstable_IdlePriority;
      var Zf = {};
      var $f = void 0 !== Rf ? Rf : function() {
      };
      var ag = null;
      var bg = null;
      var cg = false;
      var dg = Sf();
      var O = 1e4 > dg ? Sf : function() {
        return Sf() - dg;
      };
      function eg() {
        switch (Tf()) {
          case Uf:
            return 99;
          case Vf:
            return 98;
          case Wf:
            return 97;
          case Xf:
            return 96;
          case Yf:
            return 95;
          default:
            throw Error(y(332));
        }
      }
      function fg(a) {
        switch (a) {
          case 99:
            return Uf;
          case 98:
            return Vf;
          case 97:
            return Wf;
          case 96:
            return Xf;
          case 95:
            return Yf;
          default:
            throw Error(y(332));
        }
      }
      function gg(a, b) {
        a = fg(a);
        return Nf(a, b);
      }
      function hg(a, b, c) {
        a = fg(a);
        return Of(a, b, c);
      }
      function ig() {
        if (null !== bg) {
          var a = bg;
          bg = null;
          Pf(a);
        }
        jg();
      }
      function jg() {
        if (!cg && null !== ag) {
          cg = true;
          var a = 0;
          try {
            var b = ag;
            gg(99, function() {
              for (; a < b.length; a++) {
                var c = b[a];
                do
                  c = c(true);
                while (null !== c);
              }
            });
            ag = null;
          } catch (c) {
            throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
          } finally {
            cg = false;
          }
        }
      }
      var kg = ra.ReactCurrentBatchConfig;
      function lg(a, b) {
        if (a && a.defaultProps) {
          b = m({}, b);
          a = a.defaultProps;
          for (var c in a)
            void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      var mg = Bf(null);
      var ng = null;
      var og = null;
      var pg = null;
      function qg() {
        pg = og = ng = null;
      }
      function rg(a) {
        var b = mg.current;
        H(mg);
        a.type._context._currentValue = b;
      }
      function sg(a, b) {
        for (; null !== a; ) {
          var c = a.alternate;
          if ((a.childLanes & b) === b)
            if (null === c || (c.childLanes & b) === b)
              break;
            else
              c.childLanes |= b;
          else
            a.childLanes |= b, null !== c && (c.childLanes |= b);
          a = a.return;
        }
      }
      function tg(a, b) {
        ng = a;
        pg = og = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = true), a.firstContext = null);
      }
      function vg(a, b) {
        if (pg !== a && false !== b && 0 !== b) {
          if ("number" !== typeof b || 1073741823 === b)
            pg = a, b = 1073741823;
          b = { context: a, observedBits: b, next: null };
          if (null === og) {
            if (null === ng)
              throw Error(y(308));
            og = b;
            ng.dependencies = { lanes: 0, firstContext: b, responders: null };
          } else
            og = og.next = b;
        }
        return a._currentValue;
      }
      var wg = false;
      function xg(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
      }
      function yg(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function zg(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function Ag(a, b) {
        a = a.updateQueue;
        if (null !== a) {
          a = a.shared;
          var c = a.pending;
          null === c ? b.next = b : (b.next = c.next, c.next = b);
          a.pending = b;
        }
      }
      function Bg(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else
            e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function Cg(a, b, c, d) {
        var e = a.updateQueue;
        wg = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var n = a.alternate;
          if (null !== n) {
            n = n.updateQueue;
            var A = n.lastBaseUpdate;
            A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
          }
        }
        if (null !== f) {
          A = e.baseState;
          g = 0;
          n = l = k = null;
          do {
            h = f.lane;
            var p = f.eventTime;
            if ((d & h) === h) {
              null !== n && (n = n.next = {
                eventTime: p,
                lane: 0,
                tag: f.tag,
                payload: f.payload,
                callback: f.callback,
                next: null
              });
              a: {
                var C = a, x = f;
                h = b;
                p = c;
                switch (x.tag) {
                  case 1:
                    C = x.payload;
                    if ("function" === typeof C) {
                      A = C.call(p, A, h);
                      break a;
                    }
                    A = C;
                    break a;
                  case 3:
                    C.flags = C.flags & -4097 | 64;
                  case 0:
                    C = x.payload;
                    h = "function" === typeof C ? C.call(p, A, h) : C;
                    if (null === h || void 0 === h)
                      break a;
                    A = m({}, A, h);
                    break a;
                  case 2:
                    wg = true;
                }
              }
              null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
            } else
              p = { eventTime: p, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;
            f = f.next;
            if (null === f)
              if (h = e.shared.pending, null === h)
                break;
              else
                f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
          } while (1);
          null === n && (k = A);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = n;
          Dg |= g;
          a.lanes = g;
          a.memoizedState = A;
        }
      }
      function Eg(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a)
          for (b = 0; b < a.length; b++) {
            var d = a[b], e = d.callback;
            if (null !== e) {
              d.callback = null;
              d = c;
              if ("function" !== typeof e)
                throw Error(y(191, e));
              e.call(d);
            }
          }
      }
      var Fg = new aa.Component().refs;
      function Gg(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : m({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Kg = { isMounted: function(a) {
        return (a = a._reactInternals) ? Zb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = Hg(), e = Ig(a), f = zg(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        Ag(a, f);
        Jg(a, e, d);
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = Hg(), e = Ig(a), f = zg(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        Ag(a, f);
        Jg(a, e, d);
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = Hg(), d = Ig(a), e = zg(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        Ag(a, e);
        Jg(a, d, c);
      } };
      function Lg(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
      }
      function Mg(a, b, c) {
        var d = false, e = Cf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Kg;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Ng(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
      }
      function Og(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = Fg;
        xg(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
        Cg(a, c, e, d);
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4);
      }
      var Pg = Array.isArray;
      function Qg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag)
                throw Error(y(309));
              var d = c.stateNode;
            }
            if (!d)
              throw Error(y(147, a));
            var e = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
              return b.ref;
            b = function(a2) {
              var b2 = d.refs;
              b2 === Fg && (b2 = d.refs = {});
              null === a2 ? delete b2[e] : b2[e] = a2;
            };
            b._stringRef = e;
            return b;
          }
          if ("string" !== typeof a)
            throw Error(y(284));
          if (!c._owner)
            throw Error(y(290, a));
        }
        return a;
      }
      function Rg(a, b) {
        if ("textarea" !== a.type)
          throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
      }
      function Sg(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.lastEffect;
            null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
            c2.nextEffect = null;
            c2.flags = 8;
          }
        }
        function c(c2, d2) {
          if (!a)
            return null;
          for (; null !== d2; )
            b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
            null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Tg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a)
            return c2;
          d2 = b2.alternate;
          if (null !== d2)
            return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
          b2.flags = 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags = 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag)
            return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          if (null !== b2 && b2.elementType === c2.type)
            return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
          d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Qg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
            return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function n(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag)
            return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function A(a2, b2, c2) {
          if ("string" === typeof b2 || "number" === typeof b2)
            return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case sa:
                return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
              case ta:
                return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
            }
            if (Pg(b2) || La(b2))
              return b2 = Xg(
                b2,
                a2.mode,
                c2,
                null
              ), b2.return = a2, b2;
            Rg(a2, b2);
          }
          return null;
        }
        function p(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 || "number" === typeof c2)
            return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case sa:
                return c2.key === e2 ? c2.type === ua ? n(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
              case ta:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
            }
            if (Pg(c2) || La(c2))
              return null !== e2 ? null : n(a2, b2, c2, d2, null);
            Rg(a2, c2);
          }
          return null;
        }
        function C(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 || "number" === typeof d2)
            return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case sa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
              case ta:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
            }
            if (Pg(d2) || La(d2))
              return a2 = a2.get(c2) || null, n(b2, a2, d2, e2, null);
            Rg(b2, d2);
          }
          return null;
        }
        function x(e2, g2, h2, k2) {
          for (var l2 = null, t = null, u = g2, z = g2 = 0, q = null; null !== u && z < h2.length; z++) {
            u.index > z ? (q = u, u = null) : q = u.sibling;
            var n3 = p(e2, u, h2[z], k2);
            if (null === n3) {
              null === u && (u = q);
              break;
            }
            a && u && null === n3.alternate && b(e2, u);
            g2 = f(n3, g2, z);
            null === t ? l2 = n3 : t.sibling = n3;
            t = n3;
            u = q;
          }
          if (z === h2.length)
            return c(e2, u), l2;
          if (null === u) {
            for (; z < h2.length; z++)
              u = A(e2, h2[z], k2), null !== u && (g2 = f(u, g2, z), null === t ? l2 = u : t.sibling = u, t = u);
            return l2;
          }
          for (u = d(e2, u); z < h2.length; z++)
            q = C(u, e2, z, h2[z], k2), null !== q && (a && null !== q.alternate && u.delete(null === q.key ? z : q.key), g2 = f(q, g2, z), null === t ? l2 = q : t.sibling = q, t = q);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          return l2;
        }
        function w(e2, g2, h2, k2) {
          var l2 = La(h2);
          if ("function" !== typeof l2)
            throw Error(y(150));
          h2 = l2.call(h2);
          if (null == h2)
            throw Error(y(151));
          for (var t = l2 = null, u = g2, z = g2 = 0, q = null, n3 = h2.next(); null !== u && !n3.done; z++, n3 = h2.next()) {
            u.index > z ? (q = u, u = null) : q = u.sibling;
            var w2 = p(e2, u, n3.value, k2);
            if (null === w2) {
              null === u && (u = q);
              break;
            }
            a && u && null === w2.alternate && b(e2, u);
            g2 = f(w2, g2, z);
            null === t ? l2 = w2 : t.sibling = w2;
            t = w2;
            u = q;
          }
          if (n3.done)
            return c(e2, u), l2;
          if (null === u) {
            for (; !n3.done; z++, n3 = h2.next())
              n3 = A(e2, n3.value, k2), null !== n3 && (g2 = f(n3, g2, z), null === t ? l2 = n3 : t.sibling = n3, t = n3);
            return l2;
          }
          for (u = d(e2, u); !n3.done; z++, n3 = h2.next())
            n3 = C(u, e2, z, n3.value, k2), null !== n3 && (a && null !== n3.alternate && u.delete(null === n3.key ? z : n3.key), g2 = f(n3, g2, z), null === t ? l2 = n3 : t.sibling = n3, t = n3);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          return l2;
        }
        return function(a2, d2, f2, h2) {
          var k2 = "object" === typeof f2 && null !== f2 && f2.type === ua && null === f2.key;
          k2 && (f2 = f2.props.children);
          var l2 = "object" === typeof f2 && null !== f2;
          if (l2)
            switch (f2.$$typeof) {
              case sa:
                a: {
                  l2 = f2.key;
                  for (k2 = d2; null !== k2; ) {
                    if (k2.key === l2) {
                      switch (k2.tag) {
                        case 7:
                          if (f2.type === ua) {
                            c(a2, k2.sibling);
                            d2 = e(k2, f2.props.children);
                            d2.return = a2;
                            a2 = d2;
                            break a;
                          }
                          break;
                        default:
                          if (k2.elementType === f2.type) {
                            c(a2, k2.sibling);
                            d2 = e(k2, f2.props);
                            d2.ref = Qg(a2, k2, f2);
                            d2.return = a2;
                            a2 = d2;
                            break a;
                          }
                      }
                      c(a2, k2);
                      break;
                    } else
                      b(a2, k2);
                    k2 = k2.sibling;
                  }
                  f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case ta:
                a: {
                  for (k2 = f2.key; null !== d2; ) {
                    if (d2.key === k2)
                      if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                        c(a2, d2.sibling);
                        d2 = e(d2, f2.children || []);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      } else {
                        c(a2, d2);
                        break;
                      }
                    else
                      b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Wg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
            }
          if ("string" === typeof f2 || "number" === typeof f2)
            return f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
          if (Pg(f2))
            return x(a2, d2, f2, h2);
          if (La(f2))
            return w(a2, d2, f2, h2);
          l2 && Rg(a2, f2);
          if ("undefined" === typeof f2 && !k2)
            switch (a2.tag) {
              case 1:
              case 22:
              case 0:
              case 11:
              case 15:
                throw Error(y(152, Ra(a2.type) || "Component"));
            }
          return c(a2, d2);
        };
      }
      var Yg = Sg(true);
      var Zg = Sg(false);
      var $g = {};
      var ah = Bf($g);
      var bh = Bf($g);
      var ch = Bf($g);
      function dh(a) {
        if (a === $g)
          throw Error(y(174));
        return a;
      }
      function eh(a, b) {
        I(ch, b);
        I(bh, a);
        I(ah, $g);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
        }
        H(ah);
        I(ah, b);
      }
      function fh() {
        H(ah);
        H(bh);
        H(ch);
      }
      function gh(a) {
        dh(ch.current);
        var b = dh(ah.current);
        var c = mb(b, a.type);
        b !== c && (I(bh, a), I(ah, c));
      }
      function hh(a) {
        bh.current === a && (H(ah), H(bh));
      }
      var P2 = Bf(0);
      function ih(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
              return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 64))
              return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a)
            break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var jh = null;
      var kh = null;
      var lh = false;
      function mh(a, b) {
        var c = nh(5, null, null, 0);
        c.elementType = "DELETED";
        c.type = "DELETED";
        c.stateNode = b;
        c.return = a;
        c.flags = 8;
        null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
      }
      function oh(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
          case 13:
            return false;
          default:
            return false;
        }
      }
      function ph(a) {
        if (lh) {
          var b = kh;
          if (b) {
            var c = b;
            if (!oh(a, b)) {
              b = rf(c.nextSibling);
              if (!b || !oh(a, b)) {
                a.flags = a.flags & -1025 | 2;
                lh = false;
                jh = a;
                return;
              }
              mh(jh, c);
            }
            jh = a;
            kh = rf(b.firstChild);
          } else
            a.flags = a.flags & -1025 | 2, lh = false, jh = a;
        }
      }
      function qh(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
          a = a.return;
        jh = a;
      }
      function rh(a) {
        if (a !== jh)
          return false;
        if (!lh)
          return qh(a), lh = true, false;
        var b = a.type;
        if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps))
          for (b = kh; b; )
            mh(a, b), b = rf(b.nextSibling);
        qh(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a)
            throw Error(y(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    kh = rf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else
                  "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            kh = null;
          }
        } else
          kh = jh ? rf(a.stateNode.nextSibling) : null;
        return true;
      }
      function sh() {
        kh = jh = null;
        lh = false;
      }
      var th = [];
      function uh() {
        for (var a = 0; a < th.length; a++)
          th[a]._workInProgressVersionPrimary = null;
        th.length = 0;
      }
      var vh = ra.ReactCurrentDispatcher;
      var wh = ra.ReactCurrentBatchConfig;
      var xh = 0;
      var R = null;
      var S = null;
      var T = null;
      var yh = false;
      var zh = false;
      function Ah() {
        throw Error(y(321));
      }
      function Bh(a, b) {
        if (null === b)
          return false;
        for (var c = 0; c < b.length && c < a.length; c++)
          if (!He(a[c], b[c]))
            return false;
        return true;
      }
      function Ch(a, b, c, d, e, f) {
        xh = f;
        R = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        vh.current = null === a || null === a.memoizedState ? Dh : Eh;
        a = c(d, e);
        if (zh) {
          f = 0;
          do {
            zh = false;
            if (!(25 > f))
              throw Error(y(301));
            f += 1;
            T = S = null;
            b.updateQueue = null;
            vh.current = Fh;
            a = c(d, e);
          } while (zh);
        }
        vh.current = Gh;
        b = null !== S && null !== S.next;
        xh = 0;
        T = S = R = null;
        yh = false;
        if (b)
          throw Error(y(300));
        return a;
      }
      function Hh() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === T ? R.memoizedState = T = a : T = T.next = a;
        return T;
      }
      function Ih() {
        if (null === S) {
          var a = R.alternate;
          a = null !== a ? a.memoizedState : null;
        } else
          a = S.next;
        var b = null === T ? R.memoizedState : T.next;
        if (null !== b)
          T = b, S = a;
        else {
          if (null === a)
            throw Error(y(310));
          S = a;
          a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
          null === T ? R.memoizedState = T = a : T = T.next = a;
        }
        return T;
      }
      function Jh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Kh(a) {
        var b = Ih(), c = b.queue;
        if (null === c)
          throw Error(y(311));
        c.lastRenderedReducer = a;
        var d = S, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          e = e.next;
          d = d.baseState;
          var h = g = f = null, k = e;
          do {
            var l = k.lane;
            if ((xh & l) === l)
              null !== h && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
            else {
              var n = {
                lane: l,
                action: k.action,
                eagerReducer: k.eagerReducer,
                eagerState: k.eagerState,
                next: null
              };
              null === h ? (g = h = n, f = d) : h = h.next = n;
              R.lanes |= l;
              Dg |= l;
            }
            k = k.next;
          } while (null !== k && k !== e);
          null === h ? f = d : h.next = g;
          He(d, b.memoizedState) || (ug = true);
          b.memoizedState = d;
          b.baseState = f;
          b.baseQueue = h;
          c.lastRenderedState = d;
        }
        return [b.memoizedState, c.dispatch];
      }
      function Lh(a) {
        var b = Ih(), c = b.queue;
        if (null === c)
          throw Error(y(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (ug = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Mh(a, b, c) {
        var d = b._getVersion;
        d = d(b._source);
        var e = b._workInProgressVersionPrimary;
        if (null !== e)
          a = e === d;
        else if (a = a.mutableReadLanes, a = (xh & a) === a)
          b._workInProgressVersionPrimary = d, th.push(b);
        if (a)
          return c(b._source);
        th.push(b);
        throw Error(y(350));
      }
      function Nh(a, b, c, d) {
        var e = U;
        if (null === e)
          throw Error(y(349));
        var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
          return Mh(e, b, c);
        }), l = k[1], n = k[0];
        k = T;
        var A = a.memoizedState, p = A.refs, C = p.getSnapshot, x = A.source;
        A = A.subscribe;
        var w = R;
        a.memoizedState = { refs: p, source: b, subscribe: d };
        h.useEffect(function() {
          p.getSnapshot = c;
          p.setSnapshot = l;
          var a2 = f(b._source);
          if (!He(g, a2)) {
            a2 = c(b._source);
            He(n, a2) || (l(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
            a2 = e.mutableReadLanes;
            e.entangledLanes |= a2;
            for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
              var k2 = 31 - Vc(h2), v = 1 << k2;
              d2[k2] |= a2;
              h2 &= ~v;
            }
          }
        }, [c, b, d]);
        h.useEffect(function() {
          return d(b._source, function() {
            var a2 = p.getSnapshot, c2 = p.setSnapshot;
            try {
              c2(a2(b._source));
              var d2 = Ig(w);
              e.mutableReadLanes |= d2 & e.pendingLanes;
            } catch (q) {
              c2(function() {
                throw q;
              });
            }
          });
        }, [b, d]);
        He(C, c) && He(x, b) && He(A, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n }, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
        return n;
      }
      function Ph(a, b, c) {
        var d = Ih();
        return Nh(d, a, b, c);
      }
      function Qh(a) {
        var b = Hh();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
        a = a.dispatch = Oh.bind(null, R, a);
        return [b.memoizedState, a];
      }
      function Rh(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = R.updateQueue;
        null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function Sh(a) {
        var b = Hh();
        a = { current: a };
        return b.memoizedState = a;
      }
      function Th() {
        return Ih().memoizedState;
      }
      function Uh(a, b, c, d) {
        var e = Hh();
        R.flags |= a;
        e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function Vh(a, b, c, d) {
        var e = Ih();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== S) {
          var g = S.memoizedState;
          f = g.destroy;
          if (null !== d && Bh(d, g.deps)) {
            Rh(b, c, f, d);
            return;
          }
        }
        R.flags |= a;
        e.memoizedState = Rh(1 | b, c, f, d);
      }
      function Wh(a, b) {
        return Uh(516, 4, a, b);
      }
      function Xh(a, b) {
        return Vh(516, 4, a, b);
      }
      function Yh(a, b) {
        return Vh(4, 2, a, b);
      }
      function Zh(a, b) {
        if ("function" === typeof b)
          return a = a(), b(a), function() {
            b(null);
          };
        if (null !== b && void 0 !== b)
          return a = a(), b.current = a, function() {
            b.current = null;
          };
      }
      function $h(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return Vh(4, 2, Zh.bind(null, b, a), c);
      }
      function ai() {
      }
      function bi(a, b) {
        var c = Ih();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Bh(b, d[1]))
          return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ci(a, b) {
        var c = Ih();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Bh(b, d[1]))
          return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function di(a, b) {
        var c = eg();
        gg(98 > c ? 98 : c, function() {
          a(true);
        });
        gg(97 < c ? 97 : c, function() {
          var c2 = wh.transition;
          wh.transition = 1;
          try {
            a(false), b();
          } finally {
            wh.transition = c2;
          }
        });
      }
      function Oh(a, b, c) {
        var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
        null === g ? f.next = f : (f.next = g.next, g.next = f);
        b.pending = f;
        g = a.alternate;
        if (a === R || null !== g && g === R)
          zh = yh = true;
        else {
          if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g))
            try {
              var h = b.lastRenderedState, k = g(h, c);
              f.eagerReducer = g;
              f.eagerState = k;
              if (He(k, h))
                return;
            } catch (l) {
            } finally {
            }
          Jg(a, e, d);
        }
      }
      var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false };
      var Dh = { readContext: vg, useCallback: function(a, b) {
        Hh().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return Uh(4, 2, Zh.bind(
          null,
          b,
          a
        ), c);
      }, useLayoutEffect: function(a, b) {
        return Uh(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Hh();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Hh();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        a = a.dispatch = Oh.bind(null, R, a);
        return [d.memoizedState, a];
      }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
        var b = Qh(a), c = b[0], d = b[1];
        Wh(function() {
          var b2 = wh.transition;
          wh.transition = 1;
          try {
            d(a);
          } finally {
            wh.transition = b2;
          }
        }, [a]);
        return c;
      }, useTransition: function() {
        var a = Qh(false), b = a[0];
        a = di.bind(null, a[1]);
        Sh(a);
        return [a, b];
      }, useMutableSource: function(a, b, c) {
        var d = Hh();
        d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
        return Nh(d, a, b, c);
      }, useOpaqueIdentifier: function() {
        if (lh) {
          var a = false, b = uf(function() {
            a || (a = true, c("r:" + (tf++).toString(36)));
            throw Error(y(355));
          }), c = Qh(b)[1];
          0 === (R.mode & 2) && (R.flags |= 516, Rh(
            5,
            function() {
              c("r:" + (tf++).toString(36));
            },
            void 0,
            null
          ));
          return b;
        }
        b = "r:" + (tf++).toString(36);
        Qh(b);
        return b;
      }, unstable_isNewReconciler: false };
      var Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
        return Kh(Jh);
      }, useDebugValue: ai, useDeferredValue: function(a) {
        var b = Kh(Jh), c = b[0], d = b[1];
        Xh(function() {
          var b2 = wh.transition;
          wh.transition = 1;
          try {
            d(a);
          } finally {
            wh.transition = b2;
          }
        }, [a]);
        return c;
      }, useTransition: function() {
        var a = Kh(Jh)[0];
        return [
          Th().current,
          a
        ];
      }, useMutableSource: Ph, useOpaqueIdentifier: function() {
        return Kh(Jh)[0];
      }, unstable_isNewReconciler: false };
      var Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
        return Lh(Jh);
      }, useDebugValue: ai, useDeferredValue: function(a) {
        var b = Lh(Jh), c = b[0], d = b[1];
        Xh(function() {
          var b2 = wh.transition;
          wh.transition = 1;
          try {
            d(a);
          } finally {
            wh.transition = b2;
          }
        }, [a]);
        return c;
      }, useTransition: function() {
        var a = Lh(Jh)[0];
        return [
          Th().current,
          a
        ];
      }, useMutableSource: Ph, useOpaqueIdentifier: function() {
        return Lh(Jh)[0];
      }, unstable_isNewReconciler: false };
      var ei = ra.ReactCurrentOwner;
      var ug = false;
      function fi(a, b, c, d) {
        b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
      }
      function gi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        tg(b, e);
        d = Ch(a, b, c, d, f, e);
        if (null !== a && !ug)
          return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
        b.flags |= 1;
        fi(a, b, d, e);
        return b.child;
      }
      function ii(a, b, c, d, e, f) {
        if (null === a) {
          var g = c.type;
          if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps)
            return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
          a = Vg(c.type, null, d, b, b.mode, f);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        g = a.child;
        if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref))
          return hi(a, b, f);
        b.flags |= 1;
        a = Tg(g, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function ki(a, b, c, d, e, f) {
        if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref)
          if (ug = false, 0 !== (f & e))
            0 !== (a.flags & 16384) && (ug = true);
          else
            return b.lanes = a.lanes, hi(a, b, f);
        return li(a, b, c, d, f);
      }
      function mi(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode)
          if (0 === (b.mode & 4))
            b.memoizedState = { baseLanes: 0 }, ni(b, c);
          else if (0 !== (c & 1073741824))
            b.memoizedState = { baseLanes: 0 }, ni(b, null !== f ? f.baseLanes : c);
          else
            return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
        else
          null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
        fi(a, b, e, c);
        return b.child;
      }
      function oi(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c)
          b.flags |= 128;
      }
      function li(a, b, c, d, e) {
        var f = Ff(c) ? Df : M.current;
        f = Ef(b, f);
        tg(b, e);
        c = Ch(a, b, c, d, f, e);
        if (null !== a && !ug)
          return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
        b.flags |= 1;
        fi(a, b, c, e);
        return b.child;
      }
      function pi(a, b, c, d, e) {
        if (Ff(c)) {
          var f = true;
          Jf(b);
        } else
          f = false;
        tg(b, e);
        if (null === b.stateNode)
          null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));
          var n = c.getDerivedStateFromProps, A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;
          A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);
          wg = false;
          var p = b.memoizedState;
          g.state = p;
          Cg(b, d, g, e);
          k = b.memoizedState;
          h !== d || p !== k || N.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = false);
        } else {
          g = b.stateNode;
          yg(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : lg(b.type, h);
          g.props = l;
          A = b.pendingProps;
          p = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
          var C = c.getDerivedStateFromProps;
          (n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);
          wg = false;
          p = b.memoizedState;
          g.state = p;
          Cg(b, d, g, e);
          var x = b.memoizedState;
          h !== A || p !== x || N.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(
            d,
            x,
            k
          ), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = false);
        }
        return qi(a, b, c, d, f, e);
      }
      function qi(a, b, c, d, e, f) {
        oi(a, b);
        var g = 0 !== (b.flags & 64);
        if (!d && !g)
          return e && Kf(b, c, false), hi(a, b, f);
        d = b.stateNode;
        ei.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
        b.memoizedState = d.state;
        e && Kf(b, c, true);
        return b.child;
      }
      function ri(a) {
        var b = a.stateNode;
        b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
        eh(a, b.containerInfo);
      }
      var si = { dehydrated: null, retryLane: 0 };
      function ti(a, b, c) {
        var d = b.pendingProps, e = P2.current, f = false, g;
        (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        g ? (f = true, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e |= 1);
        I(P2, e & 1);
        if (null === a) {
          void 0 !== d.fallback && ph(b);
          a = d.children;
          e = d.fallback;
          if (f)
            return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
          if ("number" === typeof d.unstable_expectedLoadTime)
            return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
          c = vi({ mode: "visible", children: a }, b.mode, c, null);
          c.return = b;
          return b.child = c;
        }
        if (null !== a.memoizedState) {
          if (f)
            return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
          c = xi(a, b, d.children, c);
          b.memoizedState = null;
          return c;
        }
        if (f)
          return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
        c = xi(a, b, d.children, c);
        b.memoizedState = null;
        return c;
      }
      function ui(a, b, c, d) {
        var e = a.mode, f = a.child;
        b = { mode: "hidden", children: b };
        0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
        c = Xg(c, e, d, null);
        f.return = a;
        c.return = a;
        f.sibling = c;
        a.child = f;
        return c;
      }
      function xi(a, b, c, d) {
        var e = a.child;
        a = e.sibling;
        c = Tg(e, { mode: "visible", children: c });
        0 === (b.mode & 2) && (c.lanes = d);
        c.return = b;
        c.sibling = null;
        null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
        return b.child = c;
      }
      function wi(a, b, c, d, e) {
        var f = b.mode, g = a.child;
        a = g.sibling;
        var h = { mode: "hidden", children: c };
        0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
        null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
        d.return = b;
        c.return = b;
        c.sibling = d;
        b.child = c;
        return d;
      }
      function yi(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        sg(a.return, b);
      }
      function zi(a, b, c, d, e, f) {
        var g = a.memoizedState;
        null === g ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
      }
      function Ai(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        fi(a, b, d.children, c);
        d = P2.current;
        if (0 !== (d & 2))
          d = d & 1 | 2, b.flags |= 64;
        else {
          if (null !== a && 0 !== (a.flags & 64))
            a:
              for (a = b.child; null !== a; ) {
                if (13 === a.tag)
                  null !== a.memoizedState && yi(a, c);
                else if (19 === a.tag)
                  yi(a, c);
                else if (null !== a.child) {
                  a.child.return = a;
                  a = a.child;
                  continue;
                }
                if (a === b)
                  break a;
                for (; null === a.sibling; ) {
                  if (null === a.return || a.return === b)
                    break a;
                  a = a.return;
                }
                a.sibling.return = a.return;
                a = a.sibling;
              }
          d &= 1;
        }
        I(P2, d);
        if (0 === (b.mode & 2))
          b.memoizedState = null;
        else
          switch (e) {
            case "forwards":
              c = b.child;
              for (e = null; null !== c; )
                a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
              c = e;
              null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
              zi(b, false, e, c, f, b.lastEffect);
              break;
            case "backwards":
              c = null;
              e = b.child;
              for (b.child = null; null !== e; ) {
                a = e.alternate;
                if (null !== a && null === ih(a)) {
                  b.child = e;
                  break;
                }
                a = e.sibling;
                e.sibling = c;
                c = e;
                e = a;
              }
              zi(b, true, c, null, f, b.lastEffect);
              break;
            case "together":
              zi(b, false, null, null, void 0, b.lastEffect);
              break;
            default:
              b.memoizedState = null;
          }
        return b.child;
      }
      function hi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        Dg |= b.lanes;
        if (0 !== (c & b.childLanes)) {
          if (null !== a && b.child !== a.child)
            throw Error(y(153));
          if (null !== b.child) {
            a = b.child;
            c = Tg(a, a.pendingProps);
            b.child = c;
            for (c.return = b; null !== a.sibling; )
              a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
            c.sibling = null;
          }
          return b.child;
        }
        return null;
      }
      var Bi;
      var Ci;
      var Di;
      var Ei;
      Bi = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag)
            a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b)
            break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Ci = function() {
      };
      Di = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          dh(ah.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "option":
              e = eb(a, e);
              d = eb(a, d);
              f = [];
              break;
            case "select":
              e = m({}, e, { value: void 0 });
              d = m({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
          }
          vb(c, d);
          var g;
          c = null;
          for (l in e)
            if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
              if ("style" === l) {
                var h = e[l];
                for (g in h)
                  h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
              } else
                "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h))
              if ("style" === l)
                if (h) {
                  for (g in h)
                    !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                  for (g in k)
                    k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                } else
                  c || (f || (f = []), f.push(l, c)), c = k;
              else
                "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
          }
          c && (f = f || []).push(
            "style",
            c
          );
          var l = f;
          if (b.updateQueue = l)
            b.flags |= 4;
        }
      };
      Ei = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Fi(a, b) {
        if (!lh)
          switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b; )
                null !== b.alternate && (c = b), b = b.sibling;
              null === c ? a.tail = null : c.sibling = null;
              break;
            case "collapsed":
              c = a.tail;
              for (var d = null; null !== c; )
                null !== c.alternate && (d = c), c = c.sibling;
              null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
          }
      }
      function Gi(a, b, c) {
        var d = b.pendingProps;
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return null;
          case 1:
            return Ff(b.type) && Gf(), null;
          case 3:
            fh();
            H(N);
            H(M);
            uh();
            d = b.stateNode;
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child)
              rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
            Ci(b);
            return null;
          case 5:
            hh(b);
            var e = dh(ch.current);
            c = b.type;
            if (null !== a && null != b.stateNode)
              Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
            else {
              if (!d) {
                if (null === b.stateNode)
                  throw Error(y(166));
                return null;
              }
              a = dh(ah.current);
              if (rh(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[wf] = b;
                d[xf] = f;
                switch (c) {
                  case "dialog":
                    G("cancel", d);
                    G("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    G("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (a = 0; a < Xe.length; a++)
                      G(Xe[a], d);
                    break;
                  case "source":
                    G("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    G("error", d);
                    G("load", d);
                    break;
                  case "details":
                    G("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    G("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    G("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), G("invalid", d);
                }
                vb(c, f);
                a = null;
                for (var g in f)
                  f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));
                switch (c) {
                  case "input":
                    Va(d);
                    cb(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = jf);
                }
                d = a;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                a === kb.html && (a = lb(c));
                a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[wf] = b;
                a[xf] = d;
                Bi(a, b, false, false);
                b.stateNode = a;
                g = wb(c, d);
                switch (c) {
                  case "dialog":
                    G("cancel", a);
                    G("close", a);
                    e = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    G("load", a);
                    e = d;
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < Xe.length; e++)
                      G(Xe[e], a);
                    e = d;
                    break;
                  case "source":
                    G("error", a);
                    e = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    G("error", a);
                    G("load", a);
                    e = d;
                    break;
                  case "details":
                    G("toggle", a);
                    e = d;
                    break;
                  case "input":
                    Za(a, d);
                    e = Ya(a, d);
                    G("invalid", a);
                    break;
                  case "option":
                    e = eb(a, d);
                    break;
                  case "select":
                    a._wrapperState = { wasMultiple: !!d.multiple };
                    e = m({}, d, { value: void 0 });
                    G("invalid", a);
                    break;
                  case "textarea":
                    hb(a, d);
                    e = gb(a, d);
                    G("invalid", a);
                    break;
                  default:
                    e = d;
                }
                vb(c, e);
                var h = e;
                for (f in h)
                  if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
                  }
                switch (c) {
                  case "input":
                    Va(a);
                    cb(a, d, false);
                    break;
                  case "textarea":
                    Va(a);
                    jb(a);
                    break;
                  case "option":
                    null != d.value && a.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a.multiple = !!d.multiple;
                    f = d.value;
                    null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                    break;
                  default:
                    "function" === typeof e.onClick && (a.onclick = jf);
                }
                mf(c, d) && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 128);
            }
            return null;
          case 6:
            if (a && null != b.stateNode)
              Ei(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode)
                throw Error(y(166));
              c = dh(ch.current);
              dh(ah.current);
              rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
            }
            return null;
          case 13:
            H(P2);
            d = b.memoizedState;
            if (0 !== (b.flags & 64))
              return b.lanes = c, b;
            d = null !== d;
            c = false;
            null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
            if (d && !c && 0 !== (b.mode & 2))
              if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P2.current & 1))
                0 === V && (V = 3);
              else {
                if (0 === V || 3 === V)
                  V = 4;
                null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
              }
            if (d || c)
              b.flags |= 4;
            return null;
          case 4:
            return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;
          case 10:
            return rg(b), null;
          case 17:
            return Ff(b.type) && Gf(), null;
          case 19:
            H(P2);
            d = b.memoizedState;
            if (null === d)
              return null;
            f = 0 !== (b.flags & 64);
            g = d.rendering;
            if (null === g)
              if (f)
                Fi(d, false);
              else {
                if (0 !== V || null !== a && 0 !== (a.flags & 64))
                  for (a = b.child; null !== a; ) {
                    g = ih(a);
                    if (null !== g) {
                      b.flags |= 64;
                      Fi(d, false);
                      f = g.updateQueue;
                      null !== f && (b.updateQueue = f, b.flags |= 4);
                      null === d.lastEffect && (b.firstEffect = null);
                      b.lastEffect = d.lastEffect;
                      d = c;
                      for (c = b.child; null !== c; )
                        f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                      I(P2, P2.current & 1 | 2);
                      return b.child;
                    }
                    a = a.sibling;
                  }
                null !== d.tail && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
              }
            else {
              if (!f)
                if (a = ih(g), null !== a) {
                  if (b.flags |= 64, f = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh)
                    return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
                } else
                  2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
              d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
            }
            return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P2.current, I(P2, f ? b & 1 | 2 : b & 1), c) : null;
          case 23:
          case 24:
            return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
        }
        throw Error(y(156, b.tag));
      }
      function Li(a) {
        switch (a.tag) {
          case 1:
            Ff(a.type) && Gf();
            var b = a.flags;
            return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
          case 3:
            fh();
            H(N);
            H(M);
            uh();
            b = a.flags;
            if (0 !== (b & 64))
              throw Error(y(285));
            a.flags = b & -4097 | 64;
            return a;
          case 5:
            return hh(a), null;
          case 13:
            return H(P2), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
          case 19:
            return H(P2), null;
          case 4:
            return fh(), null;
          case 10:
            return rg(a), null;
          case 23:
          case 24:
            return Ki(), null;
          default:
            return null;
        }
      }
      function Mi(a, b) {
        try {
          var c = "", d = b;
          do
            c += Qa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e };
      }
      function Ni(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Oi = "function" === typeof WeakMap ? WeakMap : Map;
      function Pi(a, b, c) {
        c = zg(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Qi || (Qi = true, Ri = d);
          Ni(a, b);
        };
        return c;
      }
      function Si(a, b, c) {
        c = zg(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            Ni(a, b);
            return d(e);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      var Ui = "function" === typeof WeakSet ? WeakSet : Set;
      function Vi(a) {
        var b = a.ref;
        if (null !== b)
          if ("function" === typeof b)
            try {
              b(null);
            } catch (c) {
              Wi(a, c);
            }
          else
            b.current = null;
      }
      function Xi(a, b) {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
          case 22:
            return;
          case 1:
            if (b.flags & 256 && null !== a) {
              var c = a.memoizedProps, d = a.memoizedState;
              a = b.stateNode;
              b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
              a.__reactInternalSnapshotBeforeUpdate = b;
            }
            return;
          case 3:
            b.flags & 256 && qf(b.stateNode.containerInfo);
            return;
          case 5:
          case 6:
          case 4:
          case 17:
            return;
        }
        throw Error(y(163));
      }
      function Yi(a, b, c) {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
          case 22:
            b = c.updateQueue;
            b = null !== b ? b.lastEffect : null;
            if (null !== b) {
              a = b = b.next;
              do {
                if (3 === (a.tag & 3)) {
                  var d = a.create;
                  a.destroy = d();
                }
                a = a.next;
              } while (a !== b);
            }
            b = c.updateQueue;
            b = null !== b ? b.lastEffect : null;
            if (null !== b) {
              a = b = b.next;
              do {
                var e = a;
                d = e.next;
                e = e.tag;
                0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
                a = d;
              } while (a !== b);
            }
            return;
          case 1:
            a = c.stateNode;
            c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(
              d,
              b.memoizedState,
              a.__reactInternalSnapshotBeforeUpdate
            )));
            b = c.updateQueue;
            null !== b && Eg(c, b, a);
            return;
          case 3:
            b = c.updateQueue;
            if (null !== b) {
              a = null;
              if (null !== c.child)
                switch (c.child.tag) {
                  case 5:
                    a = c.child.stateNode;
                    break;
                  case 1:
                    a = c.child.stateNode;
                }
              Eg(c, b, a);
            }
            return;
          case 5:
            a = c.stateNode;
            null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
            return;
          case 6:
            return;
          case 4:
            return;
          case 12:
            return;
          case 13:
            null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
            return;
          case 19:
          case 17:
          case 20:
          case 21:
          case 23:
          case 24:
            return;
        }
        throw Error(y(163));
      }
      function aj(a, b) {
        for (var c = a; ; ) {
          if (5 === c.tag) {
            var d = c.stateNode;
            if (b)
              d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
            else {
              d = c.stateNode;
              var e = c.memoizedProps.style;
              e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
              d.style.display = sb("display", e);
            }
          } else if (6 === c.tag)
            c.stateNode.nodeValue = b ? "" : c.memoizedProps;
          else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === a)
            break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === a)
              return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      }
      function bj(a, b) {
        if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
          try {
            Mf.onCommitFiberUnmount(Lf, b);
          } catch (f) {
          }
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
          case 22:
            a = b.updateQueue;
            if (null !== a && (a = a.lastEffect, null !== a)) {
              var c = a = a.next;
              do {
                var d = c, e = d.destroy;
                d = d.tag;
                if (void 0 !== e)
                  if (0 !== (d & 4))
                    Zi(b, c);
                  else {
                    d = b;
                    try {
                      e();
                    } catch (f) {
                      Wi(d, f);
                    }
                  }
                c = c.next;
              } while (c !== a);
            }
            break;
          case 1:
            Vi(b);
            a = b.stateNode;
            if ("function" === typeof a.componentWillUnmount)
              try {
                a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
              } catch (f) {
                Wi(
                  b,
                  f
                );
              }
            break;
          case 5:
            Vi(b);
            break;
          case 4:
            cj(a, b);
        }
      }
      function dj(a) {
        a.alternate = null;
        a.child = null;
        a.dependencies = null;
        a.firstEffect = null;
        a.lastEffect = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.return = null;
        a.updateQueue = null;
      }
      function ej(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function fj(a) {
        a: {
          for (var b = a.return; null !== b; ) {
            if (ej(b))
              break a;
            b = b.return;
          }
          throw Error(y(160));
        }
        var c = b;
        b = c.stateNode;
        switch (c.tag) {
          case 5:
            var d = false;
            break;
          case 3:
            b = b.containerInfo;
            d = true;
            break;
          case 4:
            b = b.containerInfo;
            d = true;
            break;
          default:
            throw Error(y(161));
        }
        c.flags & 16 && (pb(b, ""), c.flags &= -17);
        a:
          b:
            for (c = a; ; ) {
              for (; null === c.sibling; ) {
                if (null === c.return || ej(c.return)) {
                  c = null;
                  break a;
                }
                c = c.return;
              }
              c.sibling.return = c.return;
              for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
                if (c.flags & 2)
                  continue b;
                if (null === c.child || 4 === c.tag)
                  continue b;
                else
                  c.child.return = c, c = c.child;
              }
              if (!(c.flags & 2)) {
                c = c.stateNode;
                break a;
              }
            }
        d ? gj(a, c, b) : hj(a, c, b);
      }
      function gj(a, b, c) {
        var d = a.tag, e = 5 === d || 6 === d;
        if (e)
          a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
        else if (4 !== d && (a = a.child, null !== a))
          for (gj(a, b, c), a = a.sibling; null !== a; )
            gj(a, b, c), a = a.sibling;
      }
      function hj(a, b, c) {
        var d = a.tag, e = 5 === d || 6 === d;
        if (e)
          a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a))
          for (hj(a, b, c), a = a.sibling; null !== a; )
            hj(a, b, c), a = a.sibling;
      }
      function cj(a, b) {
        for (var c = b, d = false, e, f; ; ) {
          if (!d) {
            d = c.return;
            a:
              for (; ; ) {
                if (null === d)
                  throw Error(y(160));
                e = d.stateNode;
                switch (d.tag) {
                  case 5:
                    f = false;
                    break a;
                  case 3:
                    e = e.containerInfo;
                    f = true;
                    break a;
                  case 4:
                    e = e.containerInfo;
                    f = true;
                    break a;
                }
                d = d.return;
              }
            d = true;
          }
          if (5 === c.tag || 6 === c.tag) {
            a:
              for (var g = a, h = c, k = h; ; )
                if (bj(g, k), null !== k.child && 4 !== k.tag)
                  k.child.return = k, k = k.child;
                else {
                  if (k === h)
                    break a;
                  for (; null === k.sibling; ) {
                    if (null === k.return || k.return === h)
                      break a;
                    k = k.return;
                  }
                  k.sibling.return = k.return;
                  k = k.sibling;
                }
            f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
          } else if (4 === c.tag) {
            if (null !== c.child) {
              e = c.stateNode.containerInfo;
              f = true;
              c.child.return = c;
              c = c.child;
              continue;
            }
          } else if (bj(a, c), null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b)
            break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b)
              return;
            c = c.return;
            4 === c.tag && (d = false);
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      }
      function ij(a, b) {
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
          case 22:
            var c = b.updateQueue;
            c = null !== c ? c.lastEffect : null;
            if (null !== c) {
              var d = c = c.next;
              do
                3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
              while (d !== c);
            }
            return;
          case 1:
            return;
          case 5:
            c = b.stateNode;
            if (null != c) {
              d = b.memoizedProps;
              var e = null !== a ? a.memoizedProps : d;
              a = b.type;
              var f = b.updateQueue;
              b.updateQueue = null;
              if (null !== f) {
                c[xf] = d;
                "input" === a && "radio" === d.type && null != d.name && $a(c, d);
                wb(a, e);
                b = wb(a, d);
                for (e = 0; e < f.length; e += 2) {
                  var g = f[e], h = f[e + 1];
                  "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
                }
                switch (a) {
                  case "input":
                    ab(c, d);
                    break;
                  case "textarea":
                    ib(c, d);
                    break;
                  case "select":
                    a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
                }
              }
            }
            return;
          case 6:
            if (null === b.stateNode)
              throw Error(y(162));
            b.stateNode.nodeValue = b.memoizedProps;
            return;
          case 3:
            c = b.stateNode;
            c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
            return;
          case 12:
            return;
          case 13:
            null !== b.memoizedState && (jj = O(), aj(b.child, true));
            kj(b);
            return;
          case 19:
            kj(b);
            return;
          case 17:
            return;
          case 23:
          case 24:
            aj(b, null !== b.memoizedState);
            return;
        }
        throw Error(y(163));
      }
      function kj(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Ui());
          b.forEach(function(b2) {
            var d = lj.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function mj(a, b) {
        return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
      }
      var nj = Math.ceil;
      var oj = ra.ReactCurrentDispatcher;
      var pj = ra.ReactCurrentOwner;
      var X = 0;
      var U = null;
      var Y = null;
      var W = 0;
      var qj = 0;
      var rj = Bf(0);
      var V = 0;
      var sj = null;
      var tj = 0;
      var Dg = 0;
      var Hi = 0;
      var uj = 0;
      var vj = null;
      var jj = 0;
      var Ji = Infinity;
      function wj() {
        Ji = O() + 500;
      }
      var Z = null;
      var Qi = false;
      var Ri = null;
      var Ti = null;
      var xj = false;
      var yj = null;
      var zj = 90;
      var Aj = [];
      var Bj = [];
      var Cj = null;
      var Dj = 0;
      var Ej = null;
      var Fj = -1;
      var Gj = 0;
      var Hj = 0;
      var Ij = null;
      var Jj = false;
      function Hg() {
        return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
      }
      function Ig(a) {
        a = a.mode;
        if (0 === (a & 2))
          return 1;
        if (0 === (a & 4))
          return 99 === eg() ? 1 : 2;
        0 === Gj && (Gj = tj);
        if (0 !== kg.transition) {
          0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
          a = Gj;
          var b = 4186112 & ~Hj;
          b &= -b;
          0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
          return b;
        }
        a = eg();
        0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
        return a;
      }
      function Jg(a, b, c) {
        if (50 < Dj)
          throw Dj = 0, Ej = null, Error(y(185));
        a = Kj(a, b);
        if (null === a)
          return null;
        $c(a, b, c);
        a === U && (Hi |= b, 4 === V && Ii(a, W));
        var d = eg();
        1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
        vj = a;
      }
      function Kj(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; )
          a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      function Mj(a, b) {
        for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
          var h = 31 - Vc(g), k = 1 << h, l = f[h];
          if (-1 === l) {
            if (0 === (k & d) || 0 !== (k & e)) {
              l = b;
              Rc(k);
              var n = F;
              f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5e3 : -1;
            }
          } else
            l <= b && (a.expiredLanes |= k);
          g &= ~k;
        }
        d = Uc(a, a === U ? W : 0);
        b = F;
        if (0 === d)
          null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
        else {
          if (null !== c) {
            if (a.callbackPriority === b)
              return;
            c !== Zf && Pf(c);
          }
          15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Nj(a) {
        Fj = -1;
        Hj = Gj = 0;
        if (0 !== (X & 48))
          throw Error(y(327));
        var b = a.callbackNode;
        if (Oj() && a.callbackNode !== b)
          return null;
        var c = Uc(a, a === U ? W : 0);
        if (0 === c)
          return null;
        var d = c;
        var e = X;
        X |= 16;
        var f = Pj();
        if (U !== a || W !== d)
          wj(), Qj(a, d);
        do
          try {
            Rj();
            break;
          } catch (h) {
            Sj(a, h);
          }
        while (1);
        qg();
        oj.current = f;
        X = e;
        null !== Y ? d = 0 : (U = null, W = 0, d = V);
        if (0 !== (tj & Hi))
          Qj(a, 0);
        else if (0 !== d) {
          2 === d && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
          if (1 === d)
            throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
          a.finishedWork = a.current.alternate;
          a.finishedLanes = c;
          switch (d) {
            case 0:
            case 1:
              throw Error(y(345));
            case 2:
              Uj(a);
              break;
            case 3:
              Ii(a, c);
              if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
                if (0 !== Uc(a, 0))
                  break;
                e = a.suspendedLanes;
                if ((e & c) !== c) {
                  Hg();
                  a.pingedLanes |= a.suspendedLanes & e;
                  break;
                }
                a.timeoutHandle = of(Uj.bind(null, a), d);
                break;
              }
              Uj(a);
              break;
            case 4:
              Ii(a, c);
              if ((c & 4186112) === c)
                break;
              d = a.eventTimes;
              for (e = -1; 0 < c; ) {
                var g = 31 - Vc(c);
                f = 1 << g;
                g = d[g];
                g > e && (e = g);
                c &= ~f;
              }
              c = e;
              c = O() - c;
              c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
              if (10 < c) {
                a.timeoutHandle = of(Uj.bind(null, a), c);
                break;
              }
              Uj(a);
              break;
            case 5:
              Uj(a);
              break;
            default:
              throw Error(y(329));
          }
        }
        Mj(a, O());
        return a.callbackNode === b ? Nj.bind(null, a) : null;
      }
      function Ii(a, b) {
        b &= ~uj;
        b &= ~Hi;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - Vc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Lj(a) {
        if (0 !== (X & 48))
          throw Error(y(327));
        Oj();
        if (a === U && 0 !== (a.expiredLanes & W)) {
          var b = W;
          var c = Tj(a, b);
          0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
        } else
          b = Uc(a, 0), c = Tj(a, b);
        0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
        if (1 === c)
          throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Uj(a);
        Mj(a, O());
        return null;
      }
      function Vj() {
        if (null !== Cj) {
          var a = Cj;
          Cj = null;
          a.forEach(function(a2) {
            a2.expiredLanes |= 24 & a2.pendingLanes;
            Mj(a2, O());
          });
        }
        ig();
      }
      function Wj(a, b) {
        var c = X;
        X |= 1;
        try {
          return a(b);
        } finally {
          X = c, 0 === X && (wj(), ig());
        }
      }
      function Xj(a, b) {
        var c = X;
        X &= -2;
        X |= 8;
        try {
          return a(b);
        } finally {
          X = c, 0 === X && (wj(), ig());
        }
      }
      function ni(a, b) {
        I(rj, qj);
        qj |= b;
        tj |= b;
      }
      function Ki() {
        qj = rj.current;
        H(rj);
      }
      function Qj(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, pf(c));
        if (null !== Y)
          for (c = Y.return; null !== c; ) {
            var d = c;
            switch (d.tag) {
              case 1:
                d = d.type.childContextTypes;
                null !== d && void 0 !== d && Gf();
                break;
              case 3:
                fh();
                H(N);
                H(M);
                uh();
                break;
              case 5:
                hh(d);
                break;
              case 4:
                fh();
                break;
              case 13:
                H(P2);
                break;
              case 19:
                H(P2);
                break;
              case 10:
                rg(d);
                break;
              case 23:
              case 24:
                Ki();
            }
            c = c.return;
          }
        U = a;
        Y = Tg(a.current, null);
        W = qj = tj = b;
        V = 0;
        sj = null;
        uj = Hi = Dg = 0;
      }
      function Sj(a, b) {
        do {
          var c = Y;
          try {
            qg();
            vh.current = Gh;
            if (yh) {
              for (var d = R.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              yh = false;
            }
            xh = 0;
            T = S = R = null;
            zh = false;
            pj.current = null;
            if (null === c || null === c.return) {
              V = 1;
              sj = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = W;
              h.flags |= 2048;
              h.firstEffect = h.lastEffect = null;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k;
                if (0 === (h.mode & 2)) {
                  var n = h.alternate;
                  n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
                }
                var A = 0 !== (P2.current & 1), p = g;
                do {
                  var C;
                  if (C = 13 === p.tag) {
                    var x = p.memoizedState;
                    if (null !== x)
                      C = null !== x.dehydrated ? true : false;
                    else {
                      var w = p.memoizedProps;
                      C = void 0 === w.fallback ? false : true !== w.unstable_avoidThisFallback ? true : A ? false : true;
                    }
                  }
                  if (C) {
                    var z = p.updateQueue;
                    if (null === z) {
                      var u = /* @__PURE__ */ new Set();
                      u.add(l);
                      p.updateQueue = u;
                    } else
                      z.add(l);
                    if (0 === (p.mode & 2)) {
                      p.flags |= 64;
                      h.flags |= 16384;
                      h.flags &= -2981;
                      if (1 === h.tag)
                        if (null === h.alternate)
                          h.tag = 17;
                        else {
                          var t = zg(-1, 1);
                          t.tag = 2;
                          Ag(h, t);
                        }
                      h.lanes |= 1;
                      break a;
                    }
                    k = void 0;
                    h = b;
                    var q = f.pingCache;
                    null === q ? (q = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = /* @__PURE__ */ new Set(), q.set(l, k)));
                    if (!k.has(h)) {
                      k.add(h);
                      var v = Yj.bind(null, f, l, h);
                      l.then(v, v);
                    }
                    p.flags |= 4096;
                    p.lanes = b;
                    break a;
                  }
                  p = p.return;
                } while (null !== p);
                k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
              }
              5 !== V && (V = 2);
              k = Mi(k, h);
              p = g;
              do {
                switch (p.tag) {
                  case 3:
                    f = k;
                    p.flags |= 4096;
                    b &= -b;
                    p.lanes |= b;
                    var J = Pi(p, f, b);
                    Bg(p, J);
                    break a;
                  case 1:
                    f = k;
                    var K = p.type, Q = p.stateNode;
                    if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
                      p.flags |= 4096;
                      b &= -b;
                      p.lanes |= b;
                      var L = Si(p, f, b);
                      Bg(p, L);
                      break a;
                    }
                }
                p = p.return;
              } while (null !== p);
            }
            Zj(c);
          } catch (va) {
            b = va;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Pj() {
        var a = oj.current;
        oj.current = Gh;
        return null === a ? Gh : a;
      }
      function Tj(a, b) {
        var c = X;
        X |= 16;
        var d = Pj();
        U === a && W === b || Qj(a, b);
        do
          try {
            ak();
            break;
          } catch (e) {
            Sj(a, e);
          }
        while (1);
        qg();
        X = c;
        oj.current = d;
        if (null !== Y)
          throw Error(y(261));
        U = null;
        W = 0;
        return V;
      }
      function ak() {
        for (; null !== Y; )
          bk(Y);
      }
      function Rj() {
        for (; null !== Y && !Qf(); )
          bk(Y);
      }
      function bk(a) {
        var b = ck(a.alternate, a, qj);
        a.memoizedProps = a.pendingProps;
        null === b ? Zj(a) : Y = b;
        pj.current = null;
      }
      function Zj(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 2048)) {
            c = Gi(c, b, qj);
            if (null !== c) {
              Y = c;
              return;
            }
            c = b;
            if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
              for (var d = 0, e = c.child; null !== e; )
                d |= e.lanes | e.childLanes, e = e.sibling;
              c.childLanes = d;
            }
            null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
          } else {
            c = Li(b);
            if (null !== c) {
              c.flags &= 2047;
              Y = c;
              return;
            }
            null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === V && (V = 5);
      }
      function Uj(a) {
        var b = eg();
        gg(99, dk.bind(null, a, b));
        return null;
      }
      function dk(a, b) {
        do
          Oj();
        while (null !== yj);
        if (0 !== (X & 48))
          throw Error(y(327));
        var c = a.finishedWork;
        if (null === c)
          return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current)
          throw Error(y(177));
        a.callbackNode = null;
        var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
        a.pendingLanes = e;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= e;
        a.mutableReadLanes &= e;
        a.entangledLanes &= e;
        e = a.entanglements;
        for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
          var k = 31 - Vc(f), l = 1 << k;
          e[k] = 0;
          g[k] = -1;
          h[k] = -1;
          f &= ~l;
        }
        null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
        a === U && (Y = U = null, W = 0);
        1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
        if (null !== d) {
          e = X;
          X |= 32;
          pj.current = null;
          kf = fd;
          g = Ne();
          if (Oe(g)) {
            if ("selectionStart" in g)
              h = { start: g.selectionStart, end: g.selectionEnd };
            else
              a:
                if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
                  h = l.anchorNode;
                  f = l.anchorOffset;
                  k = l.focusNode;
                  l = l.focusOffset;
                  try {
                    h.nodeType, k.nodeType;
                  } catch (va) {
                    h = null;
                    break a;
                  }
                  var n = 0, A = -1, p = -1, C = 0, x = 0, w = g, z = null;
                  b:
                    for (; ; ) {
                      for (var u; ; ) {
                        w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);
                        w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);
                        3 === w.nodeType && (n += w.nodeValue.length);
                        if (null === (u = w.firstChild))
                          break;
                        z = w;
                        w = u;
                      }
                      for (; ; ) {
                        if (w === g)
                          break b;
                        z === h && ++C === f && (A = n);
                        z === k && ++x === l && (p = n);
                        if (null !== (u = w.nextSibling))
                          break;
                        w = z;
                        z = w.parentNode;
                      }
                      w = u;
                    }
                  h = -1 === A || -1 === p ? null : { start: A, end: p };
                } else
                  h = null;
            h = h || { start: 0, end: 0 };
          } else
            h = null;
          lf = { focusedElem: g, selectionRange: h };
          fd = false;
          Ij = null;
          Jj = false;
          Z = d;
          do
            try {
              ek();
            } catch (va) {
              if (null === Z)
                throw Error(y(330));
              Wi(Z, va);
              Z = Z.nextEffect;
            }
          while (null !== Z);
          Ij = null;
          Z = d;
          do
            try {
              for (g = a; null !== Z; ) {
                var t = Z.flags;
                t & 16 && pb(Z.stateNode, "");
                if (t & 128) {
                  var q = Z.alternate;
                  if (null !== q) {
                    var v = q.ref;
                    null !== v && ("function" === typeof v ? v(null) : v.current = null);
                  }
                }
                switch (t & 1038) {
                  case 2:
                    fj(Z);
                    Z.flags &= -3;
                    break;
                  case 6:
                    fj(Z);
                    Z.flags &= -3;
                    ij(Z.alternate, Z);
                    break;
                  case 1024:
                    Z.flags &= -1025;
                    break;
                  case 1028:
                    Z.flags &= -1025;
                    ij(Z.alternate, Z);
                    break;
                  case 4:
                    ij(Z.alternate, Z);
                    break;
                  case 8:
                    h = Z;
                    cj(g, h);
                    var J = h.alternate;
                    dj(h);
                    null !== J && dj(J);
                }
                Z = Z.nextEffect;
              }
            } catch (va) {
              if (null === Z)
                throw Error(y(330));
              Wi(Z, va);
              Z = Z.nextEffect;
            }
          while (null !== Z);
          v = lf;
          q = Ne();
          t = v.focusedElem;
          g = v.selectionRange;
          if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
            null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
            q = [];
            for (v = t; v = v.parentNode; )
              1 === v.nodeType && q.push({ element: v, left: v.scrollLeft, top: v.scrollTop });
            "function" === typeof t.focus && t.focus();
            for (t = 0; t < q.length; t++)
              v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
          }
          fd = !!kf;
          lf = kf = null;
          a.current = c;
          Z = d;
          do
            try {
              for (t = a; null !== Z; ) {
                var K = Z.flags;
                K & 36 && Yi(t, Z.alternate, Z);
                if (K & 128) {
                  q = void 0;
                  var Q = Z.ref;
                  if (null !== Q) {
                    var L = Z.stateNode;
                    switch (Z.tag) {
                      case 5:
                        q = L;
                        break;
                      default:
                        q = L;
                    }
                    "function" === typeof Q ? Q(q) : Q.current = q;
                  }
                }
                Z = Z.nextEffect;
              }
            } catch (va) {
              if (null === Z)
                throw Error(y(330));
              Wi(Z, va);
              Z = Z.nextEffect;
            }
          while (null !== Z);
          Z = null;
          $f();
          X = e;
        } else
          a.current = c;
        if (xj)
          xj = false, yj = a, zj = b;
        else
          for (Z = d; null !== Z; )
            b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
        d = a.pendingLanes;
        0 === d && (Ti = null);
        1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
        c = c.stateNode;
        if (Mf && "function" === typeof Mf.onCommitFiberRoot)
          try {
            Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
          } catch (va) {
          }
        Mj(a, O());
        if (Qi)
          throw Qi = false, a = Ri, Ri = null, a;
        if (0 !== (X & 8))
          return null;
        ig();
        return null;
      }
      function ek() {
        for (; null !== Z; ) {
          var a = Z.alternate;
          Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = true));
          var b = Z.flags;
          0 !== (b & 256) && Xi(a, Z);
          0 === (b & 512) || xj || (xj = true, hg(97, function() {
            Oj();
            return null;
          }));
          Z = Z.nextEffect;
        }
      }
      function Oj() {
        if (90 !== zj) {
          var a = 97 < zj ? 97 : zj;
          zj = 90;
          return gg(a, fk);
        }
        return false;
      }
      function $i(a, b) {
        Aj.push(b, a);
        xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
      }
      function Zi(a, b) {
        Bj.push(b, a);
        xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
      }
      function fk() {
        if (null === yj)
          return false;
        var a = yj;
        yj = null;
        if (0 !== (X & 48))
          throw Error(y(331));
        var b = X;
        X |= 32;
        var c = Bj;
        Bj = [];
        for (var d = 0; d < c.length; d += 2) {
          var e = c[d], f = c[d + 1], g = e.destroy;
          e.destroy = void 0;
          if ("function" === typeof g)
            try {
              g();
            } catch (k) {
              if (null === f)
                throw Error(y(330));
              Wi(f, k);
            }
        }
        c = Aj;
        Aj = [];
        for (d = 0; d < c.length; d += 2) {
          e = c[d];
          f = c[d + 1];
          try {
            var h = e.create;
            e.destroy = h();
          } catch (k) {
            if (null === f)
              throw Error(y(330));
            Wi(f, k);
          }
        }
        for (h = a.current.firstEffect; null !== h; )
          a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
        X = b;
        ig();
        return true;
      }
      function gk(a, b, c) {
        b = Mi(c, b);
        b = Pi(a, b, 1);
        Ag(a, b);
        b = Hg();
        a = Kj(a, 1);
        null !== a && ($c(a, 1, b), Mj(a, b));
      }
      function Wi(a, b) {
        if (3 === a.tag)
          gk(a, a, b);
        else
          for (var c = a.return; null !== c; ) {
            if (3 === c.tag) {
              gk(c, a, b);
              break;
            } else if (1 === c.tag) {
              var d = c.stateNode;
              if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
                a = Mi(b, a);
                var e = Si(c, a, 1);
                Ag(c, e);
                e = Hg();
                c = Kj(c, 1);
                if (null !== c)
                  $c(c, 1, e), Mj(c, e);
                else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d)))
                  try {
                    d.componentDidCatch(b, a);
                  } catch (f) {
                  }
                break;
              }
            }
            c = c.return;
          }
      }
      function Yj(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = Hg();
        a.pingedLanes |= a.suspendedLanes & c;
        U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
        Mj(a, b);
      }
      function lj(a, b) {
        var c = a.stateNode;
        null !== c && c.delete(b);
        b = 0;
        0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
        c = Hg();
        a = Kj(a, b);
        null !== a && ($c(a, b, c), Mj(a, c));
      }
      var ck;
      ck = function(a, b, c) {
        var d = b.lanes;
        if (null !== a)
          if (a.memoizedProps !== b.pendingProps || N.current)
            ug = true;
          else if (0 !== (c & d))
            ug = 0 !== (a.flags & 16384) ? true : false;
          else {
            ug = false;
            switch (b.tag) {
              case 3:
                ri(b);
                sh();
                break;
              case 5:
                gh(b);
                break;
              case 1:
                Ff(b.type) && Jf(b);
                break;
              case 4:
                eh(b, b.stateNode.containerInfo);
                break;
              case 10:
                d = b.memoizedProps.value;
                var e = b.type._context;
                I(mg, e._currentValue);
                e._currentValue = d;
                break;
              case 13:
                if (null !== b.memoizedState) {
                  if (0 !== (c & b.child.childLanes))
                    return ti(a, b, c);
                  I(P2, P2.current & 1);
                  b = hi(a, b, c);
                  return null !== b ? b.sibling : null;
                }
                I(P2, P2.current & 1);
                break;
              case 19:
                d = 0 !== (c & b.childLanes);
                if (0 !== (a.flags & 64)) {
                  if (d)
                    return Ai(a, b, c);
                  b.flags |= 64;
                }
                e = b.memoizedState;
                null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
                I(P2, P2.current);
                if (d)
                  break;
                else
                  return null;
              case 23:
              case 24:
                return b.lanes = 0, mi(a, b, c);
            }
            return hi(a, b, c);
          }
        else
          ug = false;
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            d = b.type;
            null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
            a = b.pendingProps;
            e = Ef(b, M.current);
            tg(b, c);
            e = Ch(null, b, d, a, e, c);
            b.flags |= 1;
            if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
              b.tag = 1;
              b.memoizedState = null;
              b.updateQueue = null;
              if (Ff(d)) {
                var f = true;
                Jf(b);
              } else
                f = false;
              b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
              xg(b);
              var g = d.getDerivedStateFromProps;
              "function" === typeof g && Gg(b, d, g, a);
              e.updater = Kg;
              b.stateNode = e;
              e._reactInternals = b;
              Og(b, d, a, c);
              b = qi(null, b, d, true, f, c);
            } else
              b.tag = 0, fi(null, b, e, c), b = b.child;
            return b;
          case 16:
            e = b.elementType;
            a: {
              null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
              a = b.pendingProps;
              f = e._init;
              e = f(e._payload);
              b.type = e;
              f = b.tag = hk(e);
              a = lg(e, a);
              switch (f) {
                case 0:
                  b = li(null, b, e, a, c);
                  break a;
                case 1:
                  b = pi(null, b, e, a, c);
                  break a;
                case 11:
                  b = gi(null, b, e, a, c);
                  break a;
                case 14:
                  b = ii(null, b, e, lg(e.type, a), d, c);
                  break a;
              }
              throw Error(y(306, e, ""));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
          case 3:
            ri(b);
            d = b.updateQueue;
            if (null === a || null === d)
              throw Error(y(282));
            d = b.pendingProps;
            e = b.memoizedState;
            e = null !== e ? e.element : null;
            yg(a, b);
            Cg(b, d, null, c);
            d = b.memoizedState.element;
            if (d === e)
              sh(), b = hi(a, b, c);
            else {
              e = b.stateNode;
              if (f = e.hydrate)
                kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
              if (f) {
                a = e.mutableSourceEagerHydrationData;
                if (null != a)
                  for (e = 0; e < a.length; e += 2)
                    f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
                c = Zg(b, null, d, c);
                for (b.child = c; c; )
                  c.flags = c.flags & -3 | 1024, c = c.sibling;
              } else
                fi(a, b, d, c), sh();
              b = b.child;
            }
            return b;
          case 5:
            return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
          case 6:
            return null === a && ph(b), null;
          case 13:
            return ti(a, b, c);
          case 4:
            return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
          case 7:
            return fi(a, b, b.pendingProps, c), b.child;
          case 8:
            return fi(
              a,
              b,
              b.pendingProps.children,
              c
            ), b.child;
          case 12:
            return fi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              g = b.memoizedProps;
              f = e.value;
              var h = b.type._context;
              I(mg, h._currentValue);
              h._currentValue = f;
              if (null !== g)
                if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
                  if (g.children === e.children && !N.current) {
                    b = hi(a, b, c);
                    break a;
                  }
                } else
                  for (h = b.child, null !== h && (h.return = b); null !== h; ) {
                    var k = h.dependencies;
                    if (null !== k) {
                      g = h.child;
                      for (var l = k.firstContext; null !== l; ) {
                        if (l.context === d && 0 !== (l.observedBits & f)) {
                          1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
                          h.lanes |= c;
                          l = h.alternate;
                          null !== l && (l.lanes |= c);
                          sg(h.return, c);
                          k.lanes |= c;
                          break;
                        }
                        l = l.next;
                      }
                    } else
                      g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;
                    if (null !== g)
                      g.return = h;
                    else
                      for (g = h; null !== g; ) {
                        if (g === b) {
                          g = null;
                          break;
                        }
                        h = g.sibling;
                        if (null !== h) {
                          h.return = g.return;
                          g = h;
                          break;
                        }
                        g = g.return;
                      }
                    h = g;
                  }
              fi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(
              e,
              f.unstable_observedBits
            ), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
          case 14:
            return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
          case 15:
            return ki(a, b, b.type, b.pendingProps, d, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
          case 19:
            return Ai(a, b, c);
          case 23:
            return mi(a, b, c);
          case 24:
            return mi(a, b, c);
        }
        throw Error(y(156, b.tag));
      };
      function ik(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.flags = 0;
        this.lastEffect = this.firstEffect = this.nextEffect = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function nh(a, b, c, d) {
        return new ik(a, b, c, d);
      }
      function ji(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function hk(a) {
        if ("function" === typeof a)
          return ji(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Aa)
            return 11;
          if (a === Da)
            return 14;
        }
        return 2;
      }
      function Tg(a, b) {
        var c = a.alternate;
        null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Vg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a)
          ji(a) && (g = 1);
        else if ("string" === typeof a)
          g = 5;
        else
          a:
            switch (a) {
              case ua:
                return Xg(c.children, e, f, b);
              case Ha:
                g = 8;
                e |= 16;
                break;
              case wa:
                g = 8;
                e |= 1;
                break;
              case xa:
                return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
              case Ba:
                return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
              case Ca:
                return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
              case Ia:
                return vi(c, e, f, b);
              case Ja:
                return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
              default:
                if ("object" === typeof a && null !== a)
                  switch (a.$$typeof) {
                    case ya:
                      g = 10;
                      break a;
                    case za:
                      g = 9;
                      break a;
                    case Aa:
                      g = 11;
                      break a;
                    case Da:
                      g = 14;
                      break a;
                    case Ea:
                      g = 16;
                      d = null;
                      break a;
                    case Fa:
                      g = 22;
                      break a;
                  }
                throw Error(y(130, null == a ? a : typeof a, ""));
            }
        b = nh(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Xg(a, b, c, d) {
        a = nh(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function vi(a, b, c, d) {
        a = nh(23, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        return a;
      }
      function Ug(a, b, c) {
        a = nh(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Wg(a, b, c) {
        b = nh(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function jk(a, b, c) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.pendingContext = this.context = null;
        this.hydrate = c;
        this.callbackNode = null;
        this.callbackPriority = 0;
        this.eventTimes = Zc(0);
        this.expirationTimes = Zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = Zc(0);
        this.mutableSourceEagerHydrationData = null;
      }
      function kk(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function lk(a, b, c, d) {
        var e = b.current, f = Hg(), g = Ig(e);
        a:
          if (c) {
            c = c._reactInternals;
            b: {
              if (Zb(c) !== c || 1 !== c.tag)
                throw Error(y(170));
              var h = c;
              do {
                switch (h.tag) {
                  case 3:
                    h = h.stateNode.context;
                    break b;
                  case 1:
                    if (Ff(h.type)) {
                      h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                      break b;
                    }
                }
                h = h.return;
              } while (null !== h);
              throw Error(y(171));
            }
            if (1 === c.tag) {
              var k = c.type;
              if (Ff(k)) {
                c = If(c, k, h);
                break a;
              }
            }
            c = h;
          } else
            c = Cf;
        null === b.context ? b.context = c : b.pendingContext = c;
        b = zg(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        Ag(e, b);
        Jg(e, g, f);
        return g;
      }
      function mk(a) {
        a = a.current;
        if (!a.child)
          return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function nk(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function ok(a, b) {
        nk(a, b);
        (a = a.alternate) && nk(a, b);
      }
      function pk() {
        return null;
      }
      function qk(a, b, c) {
        var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
        c = new jk(a, b, null != c && true === c.hydrate);
        b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
        c.current = b;
        b.stateNode = c;
        xg(b);
        a[ff] = c.current;
        cf(8 === a.nodeType ? a.parentNode : a);
        if (d)
          for (a = 0; a < d.length; a++) {
            b = d[a];
            var e = b._getVersion;
            e = e(b._source);
            null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
          }
        this._internalRoot = c;
      }
      qk.prototype.render = function(a) {
        lk(a, this._internalRoot, null, null);
      };
      qk.prototype.unmount = function() {
        var a = this._internalRoot, b = a.containerInfo;
        lk(null, a, null, function() {
          b[ff] = null;
        });
      };
      function rk(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function sk(a, b) {
        b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
        if (!b)
          for (var c; c = a.lastChild; )
            a.removeChild(c);
        return new qk(a, 0, b ? { hydrate: true } : void 0);
      }
      function tk(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f._internalRoot;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = mk(g);
              h.call(a2);
            };
          }
          lk(b, g, a, e);
        } else {
          f = c._reactRootContainer = sk(c, d);
          g = f._internalRoot;
          if ("function" === typeof e) {
            var k = e;
            e = function() {
              var a2 = mk(g);
              k.call(a2);
            };
          }
          Xj(function() {
            lk(b, g, a, e);
          });
        }
        return mk(g);
      }
      ec = function(a) {
        if (13 === a.tag) {
          var b = Hg();
          Jg(a, 4, b);
          ok(a, 4);
        }
      };
      fc = function(a) {
        if (13 === a.tag) {
          var b = Hg();
          Jg(a, 67108864, b);
          ok(a, 67108864);
        }
      };
      gc = function(a) {
        if (13 === a.tag) {
          var b = Hg(), c = Ig(a);
          Jg(a, c, b);
          ok(a, c);
        }
      };
      hc = function(a, b) {
        return b();
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            ab(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; )
                c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e)
                    throw Error(y(90));
                  Wa(d);
                  ab(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Wj;
      Hb = function(a, b, c, d, e) {
        var f = X;
        X |= 4;
        try {
          return gg(98, a.bind(null, b, c, d, e));
        } finally {
          X = f, 0 === X && (wj(), ig());
        }
      };
      Ib = function() {
        0 === (X & 49) && (Vj(), Oj());
      };
      Jb = function(a, b) {
        var c = X;
        X |= 2;
        try {
          return a(b);
        } finally {
          X = c, 0 === X && (wj(), ig());
        }
      };
      function uk(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!rk(b))
          throw Error(y(200));
        return kk(a, b, null, c);
      }
      var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] };
      var wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
      var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = cc(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!yk.isDisabled && yk.supportsFiber)
          try {
            Lf = yk.inject(xk), Mf = yk;
          } catch (a) {
          }
      }
      var yk;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
      exports.createPortal = uk;
      exports.findDOMNode = function(a) {
        if (null == a)
          return null;
        if (1 === a.nodeType)
          return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render)
            throw Error(y(188));
          throw Error(y(268, Object.keys(a)));
        }
        a = cc(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      exports.flushSync = function(a, b) {
        var c = X;
        if (0 !== (c & 48))
          return a(b);
        X |= 1;
        try {
          if (a)
            return gg(99, a.bind(null, b));
        } finally {
          X = c, ig();
        }
      };
      exports.hydrate = function(a, b, c) {
        if (!rk(b))
          throw Error(y(200));
        return tk(null, a, b, true, c);
      };
      exports.render = function(a, b, c) {
        if (!rk(b))
          throw Error(y(200));
        return tk(null, a, b, false, c);
      };
      exports.unmountComponentAtNode = function(a) {
        if (!rk(a))
          throw Error(y(40));
        return a._reactRootContainer ? (Xj(function() {
          tk(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[ff] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Wj;
      exports.unstable_createPortal = function(a, b) {
        return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
      };
      exports.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!rk(c))
          throw Error(y(200));
        if (null == a || void 0 === a._reactInternals)
          throw Error(y(38));
        return tk(a, b, c, false, d);
      };
      exports.version = "17.0.2";
    }
  });

  // ../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../node_modules/react-dom/index.js"(exports, module2) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module2.exports = require_react_dom_production_min();
      } else {
        module2.exports = null;
      }
    }
  });

  // ../node_modules/@sentry/browser/node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "../node_modules/@sentry/browser/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter8;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory2) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory2(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory2(createExporter(root, createExporter(module2.exports)));
        } else {
          factory2(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter8 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod4) {
          if (mod4 && mod4.__esModule)
            return mod4;
          var result = {};
          if (mod4 != null) {
            for (var k in mod4)
              if (Object.hasOwnProperty.call(mod4, k))
                result[k] = mod4[k];
          }
          result["default"] = mod4;
          return result;
        };
        __importDefault7 = function(mod4) {
          return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter8);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/minimal/node_modules/tslib/tslib.js
  var require_tslib2 = __commonJS({
    "../node_modules/@sentry/minimal/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter8;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory2) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory2(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory2(createExporter(root, createExporter(module2.exports)));
        } else {
          factory2(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter8 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod4) {
          if (mod4 && mod4.__esModule)
            return mod4;
          var result = {};
          if (mod4 != null) {
            for (var k in mod4)
              if (Object.hasOwnProperty.call(mod4, k))
                result[k] = mod4[k];
          }
          result["default"] = mod4;
          return result;
        };
        __importDefault7 = function(mod4) {
          return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter8);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/hub/node_modules/tslib/tslib.js
  var require_tslib3 = __commonJS({
    "../node_modules/@sentry/hub/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter8;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory2) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory2(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory2(createExporter(root, createExporter(module2.exports)));
        } else {
          factory2(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter8 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod4) {
          if (mod4 && mod4.__esModule)
            return mod4;
          var result = {};
          if (mod4 != null) {
            for (var k in mod4)
              if (Object.hasOwnProperty.call(mod4, k))
                result[k] = mod4[k];
          }
          result["default"] = mod4;
          return result;
        };
        __importDefault7 = function(mod4) {
          return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter8);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/utils/node_modules/tslib/tslib.js
  var require_tslib4 = __commonJS({
    "../node_modules/@sentry/utils/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter8;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory2) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory2(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory2(createExporter(root, createExporter(module2.exports)));
        } else {
          factory2(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter8 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod4) {
          if (mod4 && mod4.__esModule)
            return mod4;
          var result = {};
          if (mod4 != null) {
            for (var k in mod4)
              if (Object.hasOwnProperty.call(mod4, k))
                result[k] = mod4[k];
          }
          result["default"] = mod4;
          return result;
        };
        __importDefault7 = function(mod4) {
          return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter8);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/core/node_modules/tslib/tslib.js
  var require_tslib5 = __commonJS({
    "../node_modules/@sentry/core/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter8;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory2) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory2(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory2(createExporter(root, createExporter(module2.exports)));
        } else {
          factory2(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter8 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod4) {
          if (mod4 && mod4.__esModule)
            return mod4;
          var result = {};
          if (mod4 != null) {
            for (var k in mod4)
              if (Object.hasOwnProperty.call(mod4, k))
                result[k] = mod4[k];
          }
          result["default"] = mod4;
          return result;
        };
        __importDefault7 = function(mod4) {
          return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter8);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // ../node_modules/@sentry/tracing/node_modules/tslib/tslib.js
  var require_tslib6 = __commonJS({
    "../node_modules/@sentry/tracing/node_modules/tslib/tslib.js"(exports, module2) {
      var __extends7;
      var __assign7;
      var __rest7;
      var __decorate7;
      var __param7;
      var __metadata7;
      var __awaiter8;
      var __generator7;
      var __exportStar7;
      var __values7;
      var __read7;
      var __spread7;
      var __spreadArrays7;
      var __await7;
      var __asyncGenerator7;
      var __asyncDelegator7;
      var __asyncValues7;
      var __makeTemplateObject7;
      var __importStar7;
      var __importDefault7;
      var __classPrivateFieldGet7;
      var __classPrivateFieldSet7;
      var __createBinding7;
      (function(factory2) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory2(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory2(createExporter(root, createExporter(module2.exports)));
        } else {
          factory2(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (b.hasOwnProperty(p))
              d[p] = b[p];
        };
        __extends7 = function(d, b) {
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign7 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest7 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate7 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param7 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata7 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter8 = function(thisArg, _arguments, P2, generator) {
          function adopt(value) {
            return value instanceof P2 ? value : new P2(function(resolve) {
              resolve(value);
            });
          }
          return new (P2 || (P2 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator7 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __createBinding7 = function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __exportStar7 = function(m, exports2) {
          for (var p in m)
            if (p !== "default" && !exports2.hasOwnProperty(p))
              exports2[p] = m[p];
        };
        __values7 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read7 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread7 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read7(arguments[i]));
          return ar;
        };
        __spreadArrays7 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __await7 = function(v) {
          return this instanceof __await7 ? (this.v = v, this) : new __await7(v);
        };
        __asyncGenerator7 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await7 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator7 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await7(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues7 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values7 === "function" ? __values7(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject7 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        __importStar7 = function(mod4) {
          if (mod4 && mod4.__esModule)
            return mod4;
          var result = {};
          if (mod4 != null) {
            for (var k in mod4)
              if (Object.hasOwnProperty.call(mod4, k))
                result[k] = mod4[k];
          }
          result["default"] = mod4;
          return result;
        };
        __importDefault7 = function(mod4) {
          return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
        };
        __classPrivateFieldGet7 = function(receiver, privateMap) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
          }
          return privateMap.get(receiver);
        };
        __classPrivateFieldSet7 = function(receiver, privateMap, value) {
          if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
          }
          privateMap.set(receiver, value);
          return value;
        };
        exporter("__extends", __extends7);
        exporter("__assign", __assign7);
        exporter("__rest", __rest7);
        exporter("__decorate", __decorate7);
        exporter("__param", __param7);
        exporter("__metadata", __metadata7);
        exporter("__awaiter", __awaiter8);
        exporter("__generator", __generator7);
        exporter("__exportStar", __exportStar7);
        exporter("__createBinding", __createBinding7);
        exporter("__values", __values7);
        exporter("__read", __read7);
        exporter("__spread", __spread7);
        exporter("__spreadArrays", __spreadArrays7);
        exporter("__await", __await7);
        exporter("__asyncGenerator", __asyncGenerator7);
        exporter("__asyncDelegator", __asyncDelegator7);
        exporter("__asyncValues", __asyncValues7);
        exporter("__makeTemplateObject", __makeTemplateObject7);
        exporter("__importStar", __importStar7);
        exporter("__importDefault", __importDefault7);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet7);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet7);
      });
    }
  });

  // src/systems/instruments/src/ND/index.tsx
  var import_react27 = __toESM(require_react());

  // src/systems/instruments/src/Common/displayUnit.tsx
  var import_react4 = __toESM(require_react());

  // src/systems/shared/src/persistence.ts
  var _NXDataStore = class {
    static get listener() {
      if (this.mListener === void 0) {
        this.mListener = RegisterViewListener("JS_LISTENER_SIMVARS", null, true);
      }
      return this.mListener;
    }
    static get(key, defaultVal) {
      const val = GetStoredData(`A32NX_${key}`);
      if (val === null || val.length === 0) {
        return defaultVal;
      }
      return val;
    }
    static set(key, val) {
      SetStoredData(`A32NX_${key}`, val);
      this.listener.triggerToAllSubscribers("A32NX_NXDATASTORE_UPDATE", key, val);
    }
    static subscribe(key, callback) {
      return Coherent.on("A32NX_NXDATASTORE_UPDATE", (updatedKey, value) => {
        if (key === "*" || key === updatedKey) {
          callback(updatedKey, value);
        }
      }).clear;
    }
    static getAndSubscribe(key, callback, defaultVal) {
      callback(key, _NXDataStore.get(key, defaultVal));
      return _NXDataStore.subscribe(key, callback);
    }
  };
  var NXDataStore = _NXDataStore;
  __publicField(NXDataStore, "mListener");

  // src/systems/instruments/src/Common/utils.tsx
  var import_react = __toESM(require_react());
  var Layer = ({ x = 0, y = 0, id, className, children, visibility = "visible" }) => /* @__PURE__ */ import_react.default.createElement("g", { transform: `translate(${x}, ${y})`, id, visibility, className }, children);
  var getSmallestAngle = (angle1, angle2) => {
    let smallestAngle = angle1 - angle2;
    if (smallestAngle > 180) {
      smallestAngle -= 360;
    } else if (smallestAngle < -180) {
      smallestAngle += 360;
    }
    return smallestAngle;
  };
  var isCaptainSide = (displayIndex) => displayIndex === 1;
  var getSupplier = (displayIndex, knobValue) => {
    const adirs3ToCaptain = 0;
    const adirs3ToFO = 2;
    if (isCaptainSide(displayIndex)) {
      return knobValue === adirs3ToCaptain ? 3 : 1;
    }
    return knobValue === adirs3ToFO ? 3 : 2;
  };

  // src/systems/instruments/src/Common/simVars.tsx
  var import_react3 = __toESM(require_react());

  // src/systems/instruments/src/Common/hooks.tsx
  var import_react2 = __toESM(require_react());

  // src/systems/shared/src/GenericDataListenerSync.ts
  var _GenericDataListenerSync = class {
    constructor(recvEventCb, topic) {
      __publicField(this, "dataPackageQueue");
      __publicField(this, "topic");
      __publicField(this, "isRunning");
      __publicField(this, "listener");
      __publicField(this, "lastEventSynced", -1);
      __publicField(this, "recvEventCb");
      this.topic = topic;
      this.dataPackageQueue = [];
      this.isRunning = true;
      this.recvEventCb = recvEventCb;
      this.listener = RegisterGenericDataListener(() => {
        this.listener.onDataReceived(_GenericDataListenerSync.EB_LISTENER_KEY, (data) => {
          this.processEventsReceived(data);
        });
      });
      const sendFn = () => {
        if (this.dataPackageQueue.length > 0) {
          const syncDataPackage = { packagedId: Math.floor(Math.random() * 1e9), data: this.dataPackageQueue };
          this.listener.send(_GenericDataListenerSync.EB_LISTENER_KEY, syncDataPackage);
          this.dataPackageQueue.length = 0;
        }
        if (this.isRunning) {
          requestAnimationFrame(sendFn);
        }
      };
      requestAnimationFrame(sendFn);
    }
    stop() {
      this.isRunning = false;
    }
    processEventsReceived(syncPackage) {
      const syncDataPackage = syncPackage;
      if (syncDataPackage.packagedId !== this.lastEventSynced) {
        this.lastEventSynced = syncDataPackage.packagedId;
        syncDataPackage.data.forEach((data) => {
          if (data.topic === this.topic) {
            try {
              this.recvEventCb(data.topic, data.data !== void 0 ? data.data : void 0);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          }
        });
      }
    }
    sendEvent(topic, data) {
      const dataObj = data;
      const dataPackage = {
        topic,
        data: dataObj
      };
      this.dataPackageQueue.push(dataPackage);
    }
    receiveEvent() {
    }
  };
  var GenericDataListenerSync = _GenericDataListenerSync;
  __publicField(GenericDataListenerSync, "EB_LISTENER_KEY", "EB_EVENTS");

  // src/systems/instruments/src/Common/defaults.ts
  var reactMount = document.getElementById("MSFS_REACT_MOUNT");
  var getRenderTarget = () => reactMount;
  var getRootElement = () => {
    if (reactMount == null ? void 0 : reactMount.parentElement) {
      return reactMount.parentElement;
    }
    throw new Error("Could not find rootElement");
  };

  // src/systems/instruments/src/Common/hooks.tsx
  var useUpdate = (handler) => {
    const savedHandler = import_react2.default.useRef(handler);
    import_react2.default.useEffect(() => {
      savedHandler.current = handler;
    }, [handler]);
    import_react2.default.useEffect(() => {
      const wrappedHandler = (event) => {
        savedHandler.current(event.detail);
      };
      getRootElement().addEventListener("update", wrappedHandler);
      return () => {
        getRootElement().removeEventListener("update", wrappedHandler);
      };
    }, []);
  };
  var useInteractionEvent = (event, handler) => {
    const savedHandler = import_react2.default.useRef(handler);
    import_react2.default.useEffect(() => {
      savedHandler.current = handler;
    }, [handler]);
    import_react2.default.useEffect(() => {
      const wrappedHandler = (e) => {
        if (event === "*") {
          savedHandler.current(e.detail);
        } else {
          savedHandler.current();
        }
      };
      getRootElement().addEventListener(event, wrappedHandler);
      return () => {
        getRootElement().removeEventListener(event, wrappedHandler);
      };
    }, [event]);
  };
  var useCoherentEvent = (event, handler) => {
    const savedHandler = import_react2.default.useRef(handler);
    import_react2.default.useEffect(() => {
      savedHandler.current = handler;
    }, [handler]);
    import_react2.default.useEffect(() => {
      console.log("hooking coherent event", event);
      const coherentHandler = Coherent.on(event, savedHandler.current);
      console.log(coherentHandler);
      return () => {
        coherentHandler.clear();
      };
    }, [event]);
  };
  var useFlowSyncEvent = (event, handler) => {
    const savedHandler = import_react2.default.useRef(handler);
    import_react2.default.useEffect(() => {
      savedHandler.current = handler;
    }, [handler]);
    import_react2.default.useEffect(() => {
      const genericEventHandler = new GenericDataListenerSync(savedHandler.current, event);
      return () => {
        genericEventHandler.stop();
      };
    }, [event]);
  };

  // src/systems/instruments/src/Common/simVars.tsx
  var useSimVar = (name69, unit, refreshInterval = 0) => {
    const lastUpdate = (0, import_react3.useRef)(Date.now() - refreshInterval - 1);
    const [stateValue, setStateValue] = (0, import_react3.useState)(() => SimVar.GetSimVarValue(name69, unit));
    const updateCallback = (0, import_react3.useCallback)(() => {
      const delta = Date.now() - lastUpdate.current;
      if (delta >= refreshInterval) {
        lastUpdate.current = Date.now();
        const newValue = SimVar.GetSimVarValue(name69, unit);
        setStateValue(newValue);
      }
    }, [name69, unit, refreshInterval]);
    useUpdate(updateCallback);
    const setter = (0, import_react3.useCallback)((valueOrSetter) => {
      const executedValue = typeof valueOrSetter === "function" ? valueOrSetter(stateValue) : valueOrSetter;
      SimVar.SetSimVarValue(name69, unit, executedValue);
      setStateValue(executedValue);
      return stateValue;
    }, [name69, unit, stateValue]);
    return [stateValue, setter];
  };

  // src/systems/instruments/src/Common/displayUnit.tsx
  var DisplayUnit = (props) => {
    const [coldDark] = useSimVar("L:A32NX_COLD_AND_DARK_SPAWN", "Bool", 200);
    const [state, setState] = (0, import_react4.useState)(coldDark ? 1 /* Off */ : 3 /* Standby */);
    const timer = (0, import_react4.useRef)(null);
    const [dmcSwitching] = useSimVar("L:A32NX_EIS_DMC_SWITCHING_KNOB", "enum", 200);
    const supplyingDmc = getSupplier(props.normDmc, dmcSwitching);
    const [potentiometer] = useSimVar(`LIGHT POTENTIOMETER:${props.potentiometerIndex}`, "percent over 100", 200);
    const [electricityState] = useSimVar(props.electricitySimvar, "bool", 200);
    useUpdate((deltaTime) => {
      if (timer.current !== null) {
        if (timer.current > 0) {
          timer.current -= deltaTime / 1e3;
        } else if (state === 3 /* Standby */) {
          setState(1 /* Off */);
          timer.current = null;
        } else if (state === 2 /* Selftest */) {
          setState(0 /* On */);
          timer.current = null;
        }
      }
      if (!document.documentElement.classList.contains("animationsEnabled")) {
        document.documentElement.classList.add("animationsEnabled");
      }
    });
    (0, import_react4.useEffect)(() => {
      if (state !== 1 /* Off */ && props.failed) {
        setState(1 /* Off */);
      } else if (state === 0 /* On */ && (potentiometer === 0 || electricityState === 0)) {
        setState(3 /* Standby */);
        timer.current = 10;
      } else if (state === 3 /* Standby */ && (potentiometer !== 0 && electricityState !== 0)) {
        setState(0 /* On */);
        timer.current = null;
      } else if (state === 1 /* Off */ && (potentiometer !== 0 && electricityState !== 0 && !props.failed)) {
        setState(2 /* Selftest */);
        timer.current = parseInt(NXDataStore.get("CONFIG_SELF_TEST_TIME", "15"));
      } else if (state === 2 /* Selftest */ && (potentiometer === 0 || electricityState === 0)) {
        setState(1 /* Off */);
        timer.current = null;
      }
    }, [timer.current, state, potentiometer, electricityState]);
    if (state === 2 /* Selftest */) {
      return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, /* @__PURE__ */ import_react4.default.createElement("svg", { className: "SelfTest", viewBox: "0 0 600 600" }, /* @__PURE__ */ import_react4.default.createElement("rect", { className: "SelfTestBackground", x: "0", y: "0", width: "100%", height: "100%" }), /* @__PURE__ */ import_react4.default.createElement(
        "text",
        {
          className: "SelfTestText",
          x: "50%",
          y: "50%"
        },
        "SELF TEST IN PROGRESS"
      ), /* @__PURE__ */ import_react4.default.createElement(
        "text",
        {
          className: "SelfTestText",
          x: "50%",
          y: "56%"
        },
        "(MAX 40 SECONDS)"
      )));
    }
    if (state === 4 /* MaintenanceMode */) {
      return /* @__PURE__ */ import_react4.default.createElement("svg", { className: "MaintenanceMode", viewBox: "0 0 600 600" }, /* @__PURE__ */ import_react4.default.createElement(
        "text",
        {
          className: "SelfTestText",
          x: "50%",
          y: "50%"
        },
        "MAINTENANCE MODE"
      ));
    }
    if (state === 5 /* EngineeringTest */) {
      return /* @__PURE__ */ import_react4.default.createElement("svg", { className: "EngineeringTestMode", viewBox: "0 0 600 600" }, /* @__PURE__ */ import_react4.default.createElement("text", { x: 9, y: 250 }, "P/N : C19755BA01"), /* @__PURE__ */ import_react4.default.createElement("text", { x: 10, y: 270 }, `S/N : C197551733${supplyingDmc}`), /* @__PURE__ */ import_react4.default.createElement("text", { x: 10, y: 344 }, "EIS SW"), /* @__PURE__ */ import_react4.default.createElement("text", { x: 10, y: 366 }, "P/N : C1975517332"), /* @__PURE__ */ import_react4.default.createElement("text", { textAnchor: "end", x: "90%", y: 250 }, "THALES AVIONICS"), /* @__PURE__ */ import_react4.default.createElement("text", { textAnchor: "end", x: "98%", y: 366 }, "LCDU 725"));
    }
    if (state === 1 /* Off */) {
      return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null);
    }
    return /* @__PURE__ */ import_react4.default.createElement(import_react4.default.Fragment, null, /* @__PURE__ */ import_react4.default.createElement("div", { style: { display: state === 0 /* On */ ? "block" : "none" } }, props.children));
  };

  // src/systems/instruments/src/Common/flightplan.tsx
  var import_react5 = __toESM(require_react());

  // src/systems/fmgc/src/types/fstypes/FSEnums.ts
  var TurnDirection = /* @__PURE__ */ ((TurnDirection3) => {
    TurnDirection3[TurnDirection3["Unknown"] = 0] = "Unknown";
    TurnDirection3[TurnDirection3["Left"] = 1] = "Left";
    TurnDirection3[TurnDirection3["Right"] = 2] = "Right";
    TurnDirection3[TurnDirection3["Either"] = 3] = "Either";
    return TurnDirection3;
  })(TurnDirection || {});

  // src/systems/shared/src/RunwayUtils.ts
  var RunwayUtils = class {
    static runwayString(runwayNumber, runwayDesignator) {
      if (runwayNumber > 0) {
        return `${runwayNumber.toFixed(0).padStart(2, "0")}${RunwayUtils.designatorString(runwayDesignator)}`;
      }
      return "";
    }
    static designatorString(runwayDesignator) {
      switch (runwayDesignator) {
        case 5 /* A */:
          return "A";
        case 6 /* B */:
          return "B";
        case 3 /* C */:
          return "C";
        case 1 /* L */:
          return "L";
        case 2 /* R */:
          return "R";
        case 4 /* W */:
          return "W";
        default:
          return "";
      }
    }
  };

  // src/systems/shared/src/ApproachUtils.ts
  var _ApproachUtils = class {
    static parseApproachName(name69) {
      var _a, _b, _c;
      const match = name69.trim().match(/^(ILS|LOC|RNAV|NDB|VOR|GPS)? ?(RW)?([0-9]{1,2}[LCRT]?)?([\s-]*([A-Z0-9]))?$/);
      if (!match) {
        return void 0;
      }
      return {
        type: (_a = match[1]) != null ? _a : "",
        runway: (_b = match[3]) != null ? _b : "",
        designator: (_c = match[5]) != null ? _c : ""
      };
    }
    static parseApproach(approach) {
      const type = _ApproachUtils.approachTypeString(approach.approachType);
      const runway = RunwayUtils.runwayString(approach.runwayNumber, approach.runwayDesignator);
      const designator = approach.approachSuffix;
      return {
        type,
        runway,
        designator
      };
    }
    static formatShortApproachName(arg0) {
      let appr;
      if (typeof arg0 === "string") {
        appr = _ApproachUtils.parseApproachName(arg0);
      } else if ("finalLegs" in arg0) {
        appr = _ApproachUtils.parseApproach(arg0);
      } else {
        appr = arg0;
      }
      if (!appr) {
        return typeof arg0 === "string" ? arg0 : "";
      }
      const runway = Avionics.Utils.formatRunway(appr.runway);
      const suffix = appr.designator ? `${runway.length > 2 ? "" : "-"}${appr.designator}` : "";
      return `${appr.type.replace("RNAV", "RNV")}${runway}${suffix}`;
    }
    static formatLongApproachName(arg0) {
      let appr;
      if (typeof arg0 === "string") {
        appr = _ApproachUtils.parseApproachName(arg0);
      } else if ("finalLegs" in arg0) {
        appr = _ApproachUtils.parseApproach(arg0);
      } else {
        appr = arg0;
      }
      const runway = Avionics.Utils.formatRunway(appr.runway);
      const suffix = appr.designator ? `-${appr.designator}` : "";
      return `${appr.type}${runway}${suffix}`;
    }
    static approachTypeString(type) {
      switch (type) {
        case ApproachType.APPROACH_TYPE_GPS:
          return "GPS";
        case ApproachType.APPROACH_TYPE_ILS:
          return "ILS";
        case ApproachType.APPROACH_TYPE_LDA:
          return "LDA";
        case ApproachType.APPROACH_TYPE_LOCALIZER:
        case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
          return "LOC";
        case ApproachType.APPROACH_TYPE_NDB:
        case ApproachType.APPROACH_TYPE_NDBDME:
          return "NDB";
        case ApproachType.APPROACH_TYPE_RNAV:
          return "RNAV";
        case ApproachType.APPROACH_TYPE_SDF:
          return "SDF";
        case ApproachType.APPROACH_TYPE_VOR:
        case ApproachType.APPROACH_TYPE_VORDME:
          return "VOR";
        default:
          return "";
      }
    }
  };
  var ApproachUtils = _ApproachUtils;
  __publicField(ApproachUtils, "shortApproachName", _ApproachUtils.formatShortApproachName);
  __publicField(ApproachUtils, "longApproachName", _ApproachUtils.formatLongApproachName);

  // src/systems/fmgc/src/guidance/LnavConfig.ts
  var LnavConfig = {
    DEFAULT_MIN_PREDICTED_TAS: 160,
    TURN_RADIUS_FACTOR: 1,
    NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE: -1,
    DEBUG_GEOMETRY: false,
    DEBUG_USE_SPEED_LVARS: false,
    DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS: false,
    DEBUG_GUIDANCE: false,
    DEBUG_GUIDABLE_RECOMPUTATION: false,
    DEBUG_PREDICTED_PATH: false,
    DEBUG_PATH_DRAWING: false,
    DEBUG_PERF: false,
    DEBUG_SAVE_FPLN_LOCAL_STORAGE: false
  };

  // src/systems/fmgc/src/flightplanning/DirectTo.ts
  var DirectTo = class {
    constructor() {
      __publicField(this, "waypointIsInFlightPlan", false);
      __publicField(this, "isActive", false);
      __publicField(this, "waypoint");
      __publicField(this, "planWaypointIndex", 0);
      __publicField(this, "interceptPoints");
      __publicField(this, "currentWaypointIndex", 0);
      __publicField(this, "segments");
    }
  };

  // src/systems/fmgc/src/flightplanning/FlightPlanSegment.ts
  var _FlightPlanSegment = class {
    constructor(type, offset, waypoints) {
      this.type = type;
      this.offset = offset;
      this.waypoints = waypoints;
      this.type = type;
      this.offset = offset;
      this.waypoints = waypoints;
    }
  };
  var FlightPlanSegment = _FlightPlanSegment;
  __publicField(FlightPlanSegment, "Empty", new _FlightPlanSegment(-1, -1, []));
  var SegmentType = /* @__PURE__ */ ((SegmentType2) => {
    SegmentType2[SegmentType2["Origin"] = 0] = "Origin";
    SegmentType2[SegmentType2["Departure"] = 1] = "Departure";
    SegmentType2[SegmentType2["Enroute"] = 2] = "Enroute";
    SegmentType2[SegmentType2["Arrival"] = 3] = "Arrival";
    SegmentType2[SegmentType2["Approach"] = 4] = "Approach";
    SegmentType2[SegmentType2["Missed"] = 5] = "Missed";
    SegmentType2[SegmentType2["Destination"] = 6] = "Destination";
    return SegmentType2;
  })(SegmentType || {});

  // src/systems/fmgc/src/flightplanning/GPS.ts
  var GPS = class {
    static async clearPlan() {
      const totalGpsWaypoints = SimVar.GetSimVarValue("C:fs9gps:FlightPlanWaypointsNumber", "number");
      for (let i = 0; i < totalGpsWaypoints; i++) {
        GPS.deleteWaypoint(0).catch(console.error);
      }
    }
    static async addIcaoWaypoint(icao, index) {
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanNewWaypointICAO", "string", icao).catch(console.error);
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanAddWaypoint", "number", index).catch(console.error);
    }
    static async addUserWaypoint(lat, lon, index, ident) {
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanNewWaypointLatitude", "degrees", lat).catch(console.error);
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanNewWaypointLongitude", "degrees", lon).catch(console.error);
      if (ident) {
        await SimVar.SetSimVarValue("C:fs9gps:FlightPlanNewWaypointIdent", "string", ident).catch(console.error);
      }
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanAddWaypoint", "number", index).catch(console.error);
    }
    static async deleteWaypoint(index) {
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanDeleteWaypoint", "number", index).catch(console.error);
    }
    static async setActiveWaypoint(index) {
      await SimVar.SetSimVarValue("C:fs9gps:FlightPlanActiveWaypoint", "number", index).catch(console.error);
    }
    static getActiveWaypoint() {
      return SimVar.GetSimVarValue("C:fs9gps:FlightPlanActiveWaypoint", "number");
    }
    static async logCurrentPlan() {
      const waypointIdents = [];
      const totalGpsWaypoints = SimVar.GetSimVarValue("C:fs9gps:FlightPlanWaypointsNumber", "number");
      for (let i = 0; i < totalGpsWaypoints; i++) {
        SimVar.SetSimVarValue("C:fs9gps:FlightPlanWaypointIndex", "number", i);
        waypointIdents.push(SimVar.GetSimVarValue("C:fs9gps:FlightPlanWaypointIdent", "string"));
      }
      console.log(`GPS Plan: ${waypointIdents.join(" ")}`);
    }
  };

  // ../node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // ../node_modules/mathjs/lib/esm/core/config.js
  var DEFAULT_CONFIG = {
    epsilon: 1e-12,
    matrix: "Matrix",
    number: "number",
    precision: 64,
    predictable: false,
    randomSeed: null
  };

  // ../node_modules/mathjs/lib/esm/utils/is.js
  function isNumber(x) {
    return typeof x === "number";
  }
  function isBigNumber(x) {
    if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
      return false;
    }
    if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
      return true;
    }
    if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
      return true;
    }
    return false;
  }
  function isComplex(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === "string";
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === void 0;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = typeof x;
    if (t === "object") {
      if (x === null)
        return "null";
      if (Array.isArray(x))
        return "Array";
      if (x instanceof Date)
        return "Date";
      if (x instanceof RegExp)
        return "RegExp";
      if (isBigNumber(x))
        return "BigNumber";
      if (isComplex(x))
        return "Complex";
      if (isFraction(x))
        return "Fraction";
      if (isMatrix(x))
        return "Matrix";
      if (isUnit(x))
        return "Unit";
      if (isIndex(x))
        return "Index";
      if (isRange(x))
        return "Range";
      if (isResultSet(x))
        return "ResultSet";
      if (isNode(x))
        return x.type;
      if (isChain(x))
        return "Chain";
      if (isHelp(x))
        return "Help";
      return "Object";
    }
    if (t === "function")
      return "Function";
    return t;
  }

  // ../node_modules/mathjs/lib/esm/utils/object.js
  function clone(x) {
    var type = typeof x;
    if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
      return x;
    }
    if (typeof x.clone === "function") {
      return x.clone();
    }
    if (Array.isArray(x)) {
      return x.map(function(value) {
        return clone(value);
      });
    }
    if (x instanceof Date)
      return new Date(x.valueOf());
    if (isBigNumber(x))
      return x;
    if (x instanceof RegExp)
      throw new TypeError("Cannot clone " + x);
    return mapObject(x, clone);
  }
  function mapObject(object, callback) {
    var clone3 = {};
    for (var key in object) {
      if (hasOwnProperty(object, key)) {
        clone3[key] = callback(object[key]);
      }
    }
    return clone3;
  }
  function extend(a, b) {
    for (var prop in b) {
      if (hasOwnProperty(b, prop)) {
        a[prop] = b[prop];
      }
    }
    return a;
  }
  function deepStrictEqual(a, b) {
    var prop, i, len;
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (i = 0, len = a.length; i < len; i++) {
        if (!deepStrictEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    } else if (typeof a === "function") {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }
      for (prop in a) {
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      for (prop in b) {
        if (!(prop in a)) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  }
  function hasOwnProperty(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  function pickShallow(object, properties) {
    var copy = {};
    for (var i = 0; i < properties.length; i++) {
      var key = properties[i];
      var value = object[key];
      if (value !== void 0) {
        copy[key] = value;
      }
    }
    return copy;
  }

  // ../node_modules/mathjs/lib/esm/core/function/config.js
  var MATRIX_OPTIONS = ["Matrix", "Array"];
  var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];

  // ../node_modules/mathjs/lib/esm/entry/configReadonly.js
  var config = function config2(options) {
    if (options) {
      throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
    }
    return Object.freeze(DEFAULT_CONFIG);
  };
  _extends(config, DEFAULT_CONFIG, {
    MATRIX_OPTIONS,
    NUMBER_OPTIONS
  });

  // ../node_modules/mathjs/lib/esm/core/function/typed.js
  var import_typed_function = __toESM(require_typed_function(), 1);

  // ../node_modules/mathjs/lib/esm/utils/number.js
  function isInteger(value) {
    if (typeof value === "boolean") {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  var sign = Math.sign || function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  var log2 = Math.log2 || function log22(x) {
    return Math.log(x) / Math.LN2;
  };
  var log10 = Math.log10 || function log102(x) {
    return Math.log(x) / Math.LN10;
  };
  var log1p = Math.log1p || function(x) {
    return Math.log(x + 1);
  };
  var cbrt = Math.cbrt || function cbrt2(x) {
    if (x === 0) {
      return x;
    }
    var negate = x < 0;
    var result;
    if (negate) {
      x = -x;
    }
    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3);
      result = (x / (result * result) + 2 * result) / 3;
    } else {
      result = x;
    }
    return negate ? -result : result;
  };
  var expm1 = Math.expm1 || function expm12(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
  };
  function formatNumberToBase(n, base, size2) {
    var prefixes = {
      2: "0b",
      8: "0o",
      16: "0x"
    };
    var prefix = prefixes[base];
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!isInteger(n)) {
        throw new Error("Value must be an integer");
      }
      if (n < 0) {
        n = n + 2 ** size2;
      }
      suffix = "i".concat(size2);
    }
    var sign4 = "";
    if (n < 0) {
      n = -n;
      sign4 = "-";
    }
    return "".concat(sign4).concat(prefix).concat(n.toString(base)).concat(suffix);
  }
  function format(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    } else if (isNaN(value)) {
      return "NaN";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options) {
      if (options.notation) {
        notation = options.notation;
      }
      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed(value, precision);
      case "exponential":
        return toExponential(value, precision);
      case "engineering":
        return toEngineering(value, precision);
      case "bin":
        return formatNumberToBase(value, 2, wordSize);
      case "oct":
        return formatNumberToBase(value, 8, wordSize);
      case "hex":
        return formatNumberToBase(value, 16, wordSize);
      case "auto":
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e = arguments[4];
          return digits2 !== "." ? digits2 + e : e;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function splitNumber(value) {
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError("Invalid number " + value);
    }
    var sign4 = match[1];
    var digits2 = match[2];
    var exponent = parseFloat(match[4] || "0");
    var dot2 = digits2.indexOf(".");
    exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
    var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros3) {
      exponent -= zeros3.length;
      return "";
    }).replace(/0*$/, "").split("").map(function(d) {
      return parseInt(d);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign: sign4,
      coefficients,
      exponent
    };
  }
  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e = rounded.exponent;
    var c = rounded.coefficients;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    if (isNumber(precision)) {
      while (precision > c.length || e - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      var missingZeros = Math.abs(e - newExp) - (c.length - 1);
      for (var i = 0; i < missingZeros; i++) {
        c.push(0);
      }
    }
    var expDiff = Math.abs(e - newExp);
    var decimalIdx = 1;
    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    }
    var decimals = c.slice(decimalIdx).join("");
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
    var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e >= 0 ? "+" : "") + newExp.toString();
    return rounded.sign + str;
  }
  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1;
    var pp = p + (precision || 0);
    if (c.length < pp) {
      c = c.concat(zeros(pp - c.length));
    }
    if (p < 0) {
      c = zeros(-p + 1).concat(c);
      p = 1;
    }
    if (p < c.length) {
      c.splice(p, 0, p === 0 ? "0." : ".");
    }
    return rounded.sign + c.join("");
  }
  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e >= 0 ? "+" : "") + e;
  }
  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      return toExponential(value, precision);
    } else {
      var c = rounded.coefficients;
      var e = rounded.exponent;
      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      }
      c = c.concat(zeros(e - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
      c = zeros(-e).concat(c);
      var dot2 = e > 0 ? e : 0;
      if (dot2 < c.length - 1) {
        c.splice(dot2 + 1, 0, ".");
      }
      return rounded.sign + c.join("");
    }
  }
  function roundDigits(split, precision) {
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients;
    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        var i = precision - 1;
        c[i]++;
        while (c[i] === 10) {
          c.pop();
          if (i === 0) {
            c.unshift(0);
            rounded.exponent++;
            i++;
          }
          i--;
          c[i]++;
        }
      }
    }
    return rounded;
  }
  function zeros(length) {
    var arr = [];
    for (var i = 0; i < length; i++) {
      arr.push(0);
    }
    return arr;
  }
  function digits(value) {
    return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
  }
  var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
  function nearlyEqual(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x === y;
    }
    if (x === y) {
      return true;
    }
    if (isNaN(x) || isNaN(y)) {
      return false;
    }
    if (isFinite(x) && isFinite(y)) {
      var diff = Math.abs(x - y);
      if (diff < DBL_EPSILON) {
        return true;
      } else {
        return diff <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
      }
    }
    return false;
  }

  // ../node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
  function formatBigNumberToBase(n, base, size2) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!n.isInteger()) {
        throw new Error("Value must be an integer");
      }
      if (n.lessThan(0)) {
        n = n.add(big2.pow(size2));
      }
      suffix = "i".concat(size2);
    }
    switch (base) {
      case 2:
        return "".concat(n.toBinary()).concat(suffix);
      case 8:
        return "".concat(n.toOctal()).concat(suffix);
      case 16:
        return "".concat(n.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  function format2(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (!value.isFinite()) {
      return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options !== void 0) {
      if (options.notation) {
        notation = options.notation;
      }
      if (typeof options === "number") {
        precision = options;
      } else if (options.precision) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed2(value, precision);
      case "exponential":
        return toExponential2(value, precision);
      case "engineering":
        return toEngineering2(value, precision);
      case "bin":
        return formatBigNumberToBase(value, 2, wordSize);
      case "oct":
        return formatBigNumberToBase(value, 8, wordSize);
      case "hex":
        return formatBigNumberToBase(value, 16, wordSize);
      case "auto": {
        var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
        var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
        if (value.isZero())
          return "0";
        var str;
        var rounded = value.toSignificantDigits(precision);
        var exp2 = rounded.e;
        if (exp2 >= lowerExp && exp2 < upperExp) {
          str = rounded.toFixed();
        } else {
          str = toExponential2(value, precision);
        }
        return str.replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e = arguments[4];
          return digits2 !== "." ? digits2 + e : e;
        });
      }
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function toEngineering2(value, precision) {
    var e = value.e;
    var newExp = e % 3 === 0 ? e : e < 0 ? e - 3 - e % 3 : e - e % 3;
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.indexOf("e") !== -1) {
      valueStr = valueWithoutExp.toString();
    }
    return valueStr + "e" + (e >= 0 ? "+" : "") + newExp.toString();
  }
  function toExponential2(value, precision) {
    if (precision !== void 0) {
      return value.toExponential(precision - 1);
    } else {
      return value.toExponential();
    }
  }
  function toFixed2(value, precision) {
    return value.toFixed(precision);
  }

  // ../node_modules/mathjs/lib/esm/utils/string.js
  function format3(value, options) {
    var result = _format(value, options);
    if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
      return result.substring(0, options.truncate - 3) + "...";
    }
    return result;
  }
  function _format(value, options) {
    if (typeof value === "number") {
      return format(value, options);
    }
    if (isBigNumber(value)) {
      return format2(value, options);
    }
    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== "decimal") {
        return value.s * value.n + "/" + value.d;
      } else {
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return '"' + value + '"';
    }
    if (typeof value === "function") {
      return value.syntax ? String(value.syntax) : "function";
    }
    if (value && typeof value === "object") {
      if (typeof value.format === "function") {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map((key) => {
          return '"' + key + '": ' + format3(value[key], options);
        });
        return "{" + entries.join(", ") + "}";
      }
    }
    return String(value);
  }
  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = "[";
      var len = array.length;
      for (var i = 0; i < len; i++) {
        if (i !== 0) {
          str += ", ";
        }
        str += formatArray(array[i], options);
      }
      str += "]";
      return str;
    } else {
      return format3(array, options);
    }
  }
  function looksLikeFraction(value) {
    return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
  }

  // ../node_modules/mathjs/lib/esm/error/DimensionError.js
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = "DimensionError";
  DimensionError.prototype.isDimensionError = true;

  // ../node_modules/mathjs/lib/esm/error/IndexError.js
  function IndexError(index, min2, max2) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.index = index;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min2;
    } else {
      this.min = min2;
      this.max = max2;
    }
    if (this.min !== void 0 && this.index < this.min) {
      this.message = "Index out of range (" + this.index + " < " + this.min + ")";
    } else if (this.max !== void 0 && this.index >= this.max) {
      this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
    } else {
      this.message = "Index out of range (" + this.index + ")";
    }
    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = "IndexError";
  IndexError.prototype.isIndexError = true;

  // ../node_modules/mathjs/lib/esm/utils/array.js
  function arraySize(x) {
    var s = [];
    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }
    return s;
  }
  function _validate(array, size2, dim) {
    var i;
    var len = array.length;
    if (len !== size2[dim]) {
      throw new DimensionError(len, size2[dim]);
    }
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < len; i++) {
        var child = array[i];
        if (!Array.isArray(child)) {
          throw new DimensionError(size2.length - 1, size2.length, "<");
        }
        _validate(array[i], size2, dimNext);
      }
    } else {
      for (i = 0; i < len; i++) {
        if (Array.isArray(array[i])) {
          throw new DimensionError(size2.length + 1, size2.length, ">");
        }
      }
    }
  }
  function validate(array, size2) {
    var isScalar = size2.length === 0;
    if (isScalar) {
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      _validate(array, size2, 0);
    }
  }
  function validateIndex(index, length) {
    if (!isNumber(index) || !isInteger(index)) {
      throw new TypeError("Index must be an integer (value: " + index + ")");
    }
    if (index < 0 || typeof length === "number" && index >= length) {
      throw new IndexError(index, length);
    }
  }
  function resize(array, size2, defaultValue) {
    if (!Array.isArray(array) || !Array.isArray(size2)) {
      throw new TypeError("Array expected");
    }
    if (size2.length === 0) {
      throw new Error("Resizing to scalar is not supported");
    }
    size2.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
      }
    });
    var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
    _resize(array, size2, 0, _defaultValue);
    return array;
  }
  function _resize(array, size2, dim, defaultValue) {
    var i;
    var elem;
    var oldLen = array.length;
    var newLen = size2[dim];
    var minLen = Math.min(oldLen, newLen);
    array.length = newLen;
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i = 0; i < minLen; i++) {
        elem = array[i];
        if (!Array.isArray(elem)) {
          elem = [elem];
          array[i] = elem;
        }
        _resize(elem, size2, dimNext, defaultValue);
      }
      for (i = minLen; i < newLen; i++) {
        elem = [];
        array[i] = elem;
        _resize(elem, size2, dimNext, defaultValue);
      }
    } else {
      for (i = 0; i < minLen; i++) {
        while (Array.isArray(array[i])) {
          array[i] = array[i][0];
        }
      }
      for (i = minLen; i < newLen; i++) {
        array[i] = defaultValue;
      }
    }
  }
  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, "!=");
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e) {
      if (e instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, "!=");
      }
      throw e;
    }
  }
  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error("More than one wildcard in sizes");
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
      }
    }
    return processedSizes;
  }
  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  function _reshape(array, sizes) {
    var tmpArray = array;
    var tmpArray2;
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size2 = sizes[sizeIndex];
      tmpArray2 = [];
      var length = tmpArray.length / size2;
      for (var i = 0; i < length; i++) {
        tmpArray2.push(tmpArray.slice(i * size2, (i + 1) * size2));
      }
      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  function squeeze(array, size2) {
    var s = size2 || arraySize(array);
    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s.shift();
    }
    var dims = s.length;
    while (s[dims - 1] === 1) {
      dims--;
    }
    if (dims < s.length) {
      array = _squeeze(array, dims, 0);
      s.length = dims;
    }
    return array;
  }
  function _squeeze(array, dims, dim) {
    var i, ii;
    if (dim < dims) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _squeeze(array[i], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }
    return array;
  }
  function unsqueeze(array, dims, outer, size2) {
    var s = size2 || arraySize(array);
    if (outer) {
      for (var i = 0; i < outer; i++) {
        array = [array];
        s.unshift(1);
      }
    }
    array = _unsqueeze(array, dims, 0);
    while (s.length < dims) {
      s.push(1);
    }
    return array;
  }
  function _unsqueeze(array, dims, dim) {
    var i, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i = 0, ii = array.length; i < ii; i++) {
        array[i] = _unsqueeze(array[i], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }
    return array;
  }
  function flatten(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback);
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  function getArrayDataType(array, typeOf2) {
    var type;
    var length = 0;
    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      var isArray2 = Array.isArray(item);
      if (i === 0 && isArray2) {
        length = item.length;
      }
      if (isArray2 && item.length !== length) {
        return void 0;
      }
      var itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
      if (type === void 0) {
        type = itemType;
      } else if (type !== itemType) {
        return "mixed";
      } else {
      }
    }
    return type;
  }

  // ../node_modules/mathjs/lib/esm/utils/factory.js
  function factory(name69, dependencies70, create, meta) {
    function assertAndCreate(scope) {
      var deps = pickShallow(scope, dependencies70.map(stripOptionalNotation));
      assertDependencies(name69, dependencies70, scope);
      return create(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name69;
    assertAndCreate.dependencies = dependencies70.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  function assertDependencies(name69, dependencies70, scope) {
    var allDefined = dependencies70.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
    if (!allDefined) {
      var missingDependencies = dependencies70.filter((dependency) => scope[dependency] === void 0);
      throw new Error('Cannot create function "'.concat(name69, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === "?";
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
  }

  // ../node_modules/mathjs/lib/esm/utils/customs.js
  function getSafeProperty(object, prop) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function setSafeProperty(object, prop, value) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function hasSafeProperty(object, prop) {
    return prop in object;
  }
  function isSafeProperty(object, prop) {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (hasOwnProperty(safeNativeProperties, prop)) {
      return true;
    }
    if (prop in Object.prototype) {
      return false;
    }
    if (prop in Function.prototype) {
      return false;
    }
    return true;
  }
  function isSafeMethod(object, method) {
    if (object === null || object === void 0 || typeof object[method] !== "function") {
      return false;
    }
    if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    }
    if (hasOwnProperty(safeNativeMethods, method)) {
      return true;
    }
    if (method in Object.prototype) {
      return false;
    }
    if (method in Function.prototype) {
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === "object" && object && object.constructor === Object;
  }
  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  // ../node_modules/mathjs/lib/esm/utils/map.js
  var ObjectWrappingMap = class {
    constructor(object) {
      this.wrappedObject = object;
    }
    keys() {
      return Object.keys(this.wrappedObject);
    }
    get(key) {
      return getSafeProperty(this.wrappedObject, key);
    }
    set(key, value) {
      setSafeProperty(this.wrappedObject, key, value);
      return this;
    }
    has(key) {
      return hasSafeProperty(this.wrappedObject, key);
    }
  };
  function isMap(object) {
    if (!object) {
      return false;
    }
    return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
  }

  // ../node_modules/mathjs/lib/esm/core/function/typed.js
  var _createTyped2 = function _createTyped() {
    _createTyped2 = import_typed_function.default.create;
    return import_typed_function.default;
  };
  var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
  var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
    var {
      BigNumber: BigNumber2,
      Complex: Complex3,
      DenseMatrix: DenseMatrix2,
      Fraction: Fraction3
    } = _ref;
    var typed2 = _createTyped2();
    typed2.types = [
      {
        name: "number",
        test: isNumber
      },
      {
        name: "Complex",
        test: isComplex
      },
      {
        name: "BigNumber",
        test: isBigNumber
      },
      {
        name: "Fraction",
        test: isFraction
      },
      {
        name: "Unit",
        test: isUnit
      },
      {
        name: "string",
        test: isString
      },
      {
        name: "Chain",
        test: isChain
      },
      {
        name: "Array",
        test: isArray
      },
      {
        name: "Matrix",
        test: isMatrix
      },
      {
        name: "DenseMatrix",
        test: isDenseMatrix
      },
      {
        name: "SparseMatrix",
        test: isSparseMatrix
      },
      {
        name: "Range",
        test: isRange
      },
      {
        name: "Index",
        test: isIndex
      },
      {
        name: "boolean",
        test: isBoolean
      },
      {
        name: "ResultSet",
        test: isResultSet
      },
      {
        name: "Help",
        test: isHelp
      },
      {
        name: "function",
        test: isFunction
      },
      {
        name: "Date",
        test: isDate
      },
      {
        name: "RegExp",
        test: isRegExp
      },
      {
        name: "null",
        test: isNull
      },
      {
        name: "undefined",
        test: isUndefined
      },
      {
        name: "AccessorNode",
        test: isAccessorNode
      },
      {
        name: "ArrayNode",
        test: isArrayNode
      },
      {
        name: "AssignmentNode",
        test: isAssignmentNode
      },
      {
        name: "BlockNode",
        test: isBlockNode
      },
      {
        name: "ConditionalNode",
        test: isConditionalNode
      },
      {
        name: "ConstantNode",
        test: isConstantNode
      },
      {
        name: "FunctionNode",
        test: isFunctionNode
      },
      {
        name: "FunctionAssignmentNode",
        test: isFunctionAssignmentNode
      },
      {
        name: "IndexNode",
        test: isIndexNode
      },
      {
        name: "Node",
        test: isNode
      },
      {
        name: "ObjectNode",
        test: isObjectNode
      },
      {
        name: "OperatorNode",
        test: isOperatorNode
      },
      {
        name: "ParenthesisNode",
        test: isParenthesisNode
      },
      {
        name: "RangeNode",
        test: isRangeNode
      },
      {
        name: "SymbolNode",
        test: isSymbolNode
      },
      {
        name: "Map",
        test: isMap
      },
      {
        name: "Object",
        test: isObject
      }
    ];
    typed2.conversions = [{
      from: "number",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        if (digits(x) > 15) {
          throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
        }
        return new BigNumber2(x);
      }
    }, {
      from: "number",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x, 0);
      }
    }, {
      from: "number",
      to: "string",
      convert: function convert(x) {
        return x + "";
      }
    }, {
      from: "BigNumber",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x.toNumber(), 0);
      }
    }, {
      from: "Fraction",
      to: "BigNumber",
      convert: function convert(x) {
        throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
      }
    }, {
      from: "Fraction",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x.valueOf(), 0);
      }
    }, {
      from: "number",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        var f = new Fraction3(x);
        if (f.valueOf() !== x) {
          throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
        }
        return f;
      }
    }, {
      from: "string",
      to: "number",
      convert: function convert(x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: "string",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        try {
          return new BigNumber2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: "string",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        try {
          return new Fraction3(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: "string",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        try {
          return new Complex3(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: "boolean",
      to: "number",
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: "boolean",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        return new BigNumber2(+x);
      }
    }, {
      from: "boolean",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        return new Fraction3(+x);
      }
    }, {
      from: "boolean",
      to: "string",
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: "Array",
      to: "Matrix",
      convert: function convert(array) {
        if (!DenseMatrix2) {
          throwNoMatrix();
        }
        return new DenseMatrix2(array);
      }
    }, {
      from: "Matrix",
      to: "Array",
      convert: function convert(matrix2) {
        return matrix2.valueOf();
      }
    }];
    return typed2;
  });
  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
  }
  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  // ../node_modules/decimal.js/decimal.mjs
  var EXP_LIMIT = 9e15;
  var MAX_DIGITS = 1e9;
  var NUMERALS = "0123456789abcdef";
  var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var DEFAULTS = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -EXP_LIMIT,
    maxE: EXP_LIMIT,
    crypto: false
  };
  var inexact;
  var quadrant;
  var external = true;
  var decimalError = "[DecimalError] ";
  var invalidArgument = decimalError + "Invalid argument: ";
  var precisionLimitExceeded = decimalError + "Precision limit exceeded";
  var cryptoUnavailable = decimalError + "crypto unavailable";
  var tag = "[object Decimal]";
  var mathfloor = Math.floor;
  var mathpow = Math.pow;
  var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var BASE = 1e7;
  var LOG_BASE = 7;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var LN10_PRECISION = LN10.length - 1;
  var PI_PRECISION = PI.length - 1;
  var P = { toStringTag: tag };
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s < 0)
      x.s = 1;
    return finalise(x);
  };
  P.ceil = function() {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };
  P.clampedTo = P.clamp = function(min2, max2) {
    var k, x = this, Ctor = x.constructor;
    min2 = new Ctor(min2);
    max2 = new Ctor(max2);
    if (!min2.s || !max2.s)
      return new Ctor(NaN);
    if (min2.gt(max2))
      throw Error(invalidArgument + max2);
    k = x.cmp(min2);
    return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
  };
  P.comparedTo = P.cmp = function(y) {
    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }
    if (!xd[0] || !yd[0])
      return xd[0] ? xs : yd[0] ? -ys : 0;
    if (xs !== ys)
      return xs;
    if (x.e !== y.e)
      return x.e > y.e ^ xs < 0 ? 1 : -1;
    xdL = xd.length;
    ydL = yd.length;
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i])
        return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };
  P.cosine = P.cos = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.d)
      return new Ctor(NaN);
    if (!x.d[0])
      return new Ctor(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };
  P.cubeRoot = P.cbrt = function() {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    external = false;
    s = x.s * mathpow(x.s * x, 1 / 3);
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;
      if (s = (e - n.length + 1) % 3)
        n += s == 1 || s == -2 ? "0" : "00";
      s = mathpow(n, 1 / 3);
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e + 1, 0);
            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  P.decimalPlaces = P.dp = function() {
    var w, d = this.d, n = NaN;
    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
      w = d[w];
      if (w)
        for (; w % 10 == 0; w /= 10)
          n--;
      if (n < 0)
        n = 0;
    }
    return n;
  };
  P.dividedBy = P.div = function(y) {
    return divide(this, new this.constructor(y));
  };
  P.dividedToIntegerBy = P.divToInt = function(y) {
    var x = this, Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };
  P.equals = P.eq = function(y) {
    return this.cmp(y) === 0;
  };
  P.floor = function() {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };
  P.greaterThan = P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };
  P.hyperbolicCosine = P.cosh = function() {
    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
    if (!x.isFinite())
      return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero())
      return one;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = "2.3283064365386962890625e-10";
    }
    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
    var cosh2_x, i = k, d8 = new Ctor(8);
    for (; i--; ) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }
    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.hyperbolicSine = P.sinh = function() {
    var k, pr, rm, len, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);
      var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(x, pr, rm, true);
  };
  P.hyperbolicTangent = P.tanh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(x.s);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;
    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };
  P.inverseCosine = P.acos = function() {
    var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
    if (k !== -1) {
      return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
    }
    if (x.isZero())
      return getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return halfPi.minus(x);
  };
  P.inverseHyperbolicCosine = P.acosh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (x.lte(1))
      return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).minus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicSine = P.asinh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).plus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicTangent = P.atanh = function() {
    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.e >= 0)
      return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();
    if (Math.max(xsd, pr) < 2 * -x.e - 1)
      return finalise(new Ctor(x), pr, rm, true);
    Ctor.precision = wpr = xsd - x.e;
    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
    Ctor.precision = pr + 4;
    Ctor.rounding = 1;
    x = x.ln();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(0.5);
  };
  P.inverseSine = P.asin = function() {
    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
    if (x.isZero())
      return new Ctor(x);
    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (k !== -1) {
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }
      return new Ctor(NaN);
    }
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseTangent = P.atan = function() {
    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
    if (!x.isFinite()) {
      if (!x.s)
        return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }
    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;
    k = Math.min(28, wpr / LOG_BASE + 2 | 0);
    for (i = k; i; --i)
      x = x.div(x.times(x).plus(1).sqrt().plus(1));
    external = false;
    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;
    for (; i !== -1; ) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));
      px = px.times(x2);
      r = t.plus(px.div(n += 2));
      if (r.d[j] !== void 0)
        for (i = j; r.d[i] === t.d[i] && i--; )
          ;
    }
    if (k)
      r = r.times(2 << k - 1);
    external = true;
    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.isFinite = function() {
    return !!this.d;
  };
  P.isInteger = P.isInt = function() {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = P.isNeg = function() {
    return this.s < 0;
  };
  P.isPositive = P.isPos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  P.lessThan = P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.logarithm = P.log = function(base) {
    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;
      if (base.s < 0 || !d || !d[0] || base.eq(1))
        return new Ctor(NaN);
      isBase10 = base.eq(10);
    }
    d = arg.d;
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0; )
          k /= 10;
        inf = k !== 1;
      }
    }
    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
    r = divide(num, denominator, sd, 1);
    if (checkRoundingDigits(r.d, k = pr, rm)) {
      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (!inf) {
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }
    external = true;
    return finalise(r, pr, rm);
  };
  P.minus = P.sub = function(y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s)
        y = new Ctor(NaN);
      else if (x.d)
        y.s = -y.s;
      else
        y = new Ctor(y.d || x.s !== y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (yd[0])
        y.s = -y.s;
      else if (xd[0])
        y = new Ctor(x);
      else
        return new Ctor(rm === 3 ? -0 : 0);
      return external ? finalise(y, pr, rm) : y;
    }
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);
    xd = xd.slice();
    k = xe - e;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
      if (k > i) {
        k = i;
        d.length = 1;
      }
      d.reverse();
      for (i = k; i--; )
        d.push(0);
      d.reverse();
    } else {
      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy)
        len = i;
      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }
    len = xd.length;
    for (i = yd.length - len; i > 0; --i)
      xd[len++] = 0;
    for (i = yd.length; i > k; ) {
      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0; )
          xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }
      xd[i] -= yd[i];
    }
    for (; xd[--len] === 0; )
      xd.pop();
    for (; xd[0] === 0; xd.shift())
      --e;
    if (!xd[0])
      return new Ctor(rm === 3 ? -0 : 0);
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  P.modulo = P.mod = function(y) {
    var q, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.s || y.d && !y.d[0])
      return new Ctor(NaN);
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }
    external = false;
    if (Ctor.modulo == 9) {
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }
    q = q.times(y);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return naturalExponential(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return naturalLogarithm(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };
  P.plus = P.add = function(y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
    y = new Ctor(y);
    if (!x.d || !y.d) {
      if (!x.s || !y.s)
        y = new Ctor(NaN);
      else if (!x.d)
        y = new Ctor(y.d || x.s === y.s ? x : NaN);
      return y;
    }
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }
    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (!yd[0])
        y = new Ctor(x);
      return external ? finalise(y, pr, rm) : y;
    }
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);
    xd = xd.slice();
    i = k - e;
    if (i) {
      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i > len) {
        i = len;
        d.length = 1;
      }
      d.reverse();
      for (; i--; )
        d.push(0);
      d.reverse();
    }
    len = xd.length;
    i = yd.length;
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }
    for (carry = 0; i; ) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }
    if (carry) {
      xd.unshift(carry);
      ++e;
    }
    for (len = xd.length; xd[--len] == 0; )
      xd.pop();
    y.d = xd;
    y.e = getBase10Exponent(xd, e);
    return external ? finalise(y, pr, rm) : y;
  };
  P.precision = P.sd = function(z) {
    var k, x = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
      throw Error(invalidArgument + z);
    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k)
        k = x.e + 1;
    } else {
      k = NaN;
    }
    return k;
  };
  P.round = function() {
    var x = this, Ctor = x.constructor;
    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };
  P.sine = P.sin = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = sine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e + 1, 0);
            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e, Ctor.rounding, m);
  };
  P.tangent = P.tan = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;
    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };
  P.times = P.mul = function(y) {
    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
    y.s *= x.s;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
    }
    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--; )
      r.push(0);
    for (i = ydL; --i >= 0; ) {
      carry = 0;
      for (k = xdL + i; k > i; ) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; )
      r.pop();
    if (carry)
      ++e;
    else
      r.shift();
    y.d = r;
    y.e = getBase10Exponent(r, e);
    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };
  P.toBinary = function(sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };
  P.toDecimalPlaces = P.toDP = function(dp, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp === void 0)
      return x;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    return finalise(x, dp + x.e + 1, rm);
  };
  P.toExponential = function(dp, rm) {
    var str, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFixed = function(dp, rm) {
    var str, y, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFraction = function(maxD) {
    var d, d0, d1, d2, e, k, n, n0, n13, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
    if (!xd)
      return new Ctor(x);
    n13 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);
    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
    if (maxD == null) {
      maxD = e > 0 ? d : n13;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n13))
        throw Error(invalidArgument + n);
      maxD = n.gt(d) ? e > 0 ? d : n13 : n;
    }
    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;
    for (; ; ) {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1)
        break;
      d0 = d1;
      d1 = d2;
      d2 = n13;
      n13 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }
    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n13));
    d0 = d0.plus(d2.times(d1));
    n0.s = n13.s = x.s;
    r = divide(n13, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n13, d1] : [n0, d0];
    Ctor.precision = pr;
    external = true;
    return r;
  };
  P.toHexadecimal = P.toHex = function(sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };
  P.toNearest = function(y, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (y == null) {
      if (!x.d)
        return x;
      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }
      if (!x.d)
        return y.s ? x : y;
      if (!y.d) {
        if (y.s)
          y.s = x.s;
        return y;
      }
    }
    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);
    } else {
      y.s = x.s;
      x = y;
    }
    return x;
  };
  P.toNumber = function() {
    return +this;
  };
  P.toOctal = function(sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };
  P.toPower = P.pow = function(y) {
    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
    if (!x.d || !y.d || !x.d[0] || !y.d[0])
      return new Ctor(mathpow(+x, yn));
    x = new Ctor(x);
    if (x.eq(1))
      return x;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (y.eq(1))
      return finalise(x, pr, rm);
    e = mathfloor(y.e / LOG_BASE);
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }
    s = x.s;
    if (s < 0) {
      if (e < y.d.length - 1)
        return new Ctor(NaN);
      if ((y.d[e] & 1) == 0)
        s = 1;
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1)
      return new Ctor(e > 0 ? s / 0 : 0);
    external = false;
    Ctor.rounding = x.s = 1;
    k = Math.min(12, (e + "").length);
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
    if (r.d) {
      r = finalise(r, pr + 5, 1);
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }
    r.s = s;
    external = true;
    Ctor.rounding = rm;
    return finalise(r, pr, rm);
  };
  P.toPrecision = function(sd, rm) {
    var str, x = this, Ctor = x.constructor;
    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toSignificantDigits = P.toSD = function(sd, rm) {
    var x = this, Ctor = x.constructor;
    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    }
    return finalise(new Ctor(x), sd, rm);
  };
  P.toString = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.truncated = P.trunc = function() {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };
  P.valueOf = P.toJSON = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() ? "-" + str : str;
  };
  function digitsToString(d) {
    var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
        str += ws;
      }
      w = d[i];
      ws = w + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
    } else if (w === 0) {
      return "0";
    }
    for (; w % 10 === 0; )
      w /= 10;
    return str + w;
  }
  function checkInt32(i, min2, max2) {
    if (i !== ~~i || i < min2 || i > max2) {
      throw Error(invalidArgument + i);
    }
  }
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;
    for (k = d[0]; k >= 10; k /= 10)
      --i;
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;
    if (repeating == null) {
      if (i < 3) {
        if (i == 0)
          rd = rd / 100 | 0;
        else if (i == 1)
          rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0)
          rd = rd / 1e3 | 0;
        else if (i == 1)
          rd = rd / 100 | 0;
        else if (i == 2)
          rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
      }
    }
    return r;
  }
  function convertBase(str, baseIn, baseOut) {
    var j, arr = [0], arrL, i = 0, strL = str.length;
    for (; i < strL; ) {
      for (arrL = arr.length; arrL--; )
        arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0)
            arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }
    return arr.reverse();
  }
  function cosine(Ctor, x) {
    var k, len, y;
    if (x.isZero())
      return x;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = "2.3283064365386962890625e-10";
    }
    Ctor.precision += k;
    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
    for (var i = k; i--; ) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }
    Ctor.precision -= k;
    return x;
  }
  var divide = function() {
    function multiplyInteger(x, k, base) {
      var temp, carry = 0, i = x.length;
      for (x = x.slice(); i--; ) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }
      if (carry)
        x.unshift(carry);
      return x;
    }
    function compare(a, b, aL, bL) {
      var i, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract2(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; )
        a.shift();
    }
    return function(x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign4 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
        );
      }
      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign4);
      qd = q.d = [];
      for (i = 0; yd[i] == (xd[i] || 0); i++)
        ;
      if (yd[i] > (xd[i] || 0))
        e--;
      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }
      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {
        sd = sd / logBase + 2 | 0;
        i = 0;
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }
          more = k || i < xL;
        } else {
          k = base / (yd[0] + 1) | 0;
          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }
          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; )
            rem[remL++] = 0;
          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= base / 2)
            ++yd0;
          do {
            k = 0;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              k = rem0 / yd0 | 0;
              if (k > 1) {
                if (k >= base)
                  k = base - 1;
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;
                cmp = compare(prod, rem, prodL, remL);
                if (cmp == 1) {
                  k--;
                  subtract2(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {
                if (k == 0)
                  cmp = k = 1;
                prod = yd.slice();
              }
              prodL = prod.length;
              if (prodL < remL)
                prod.unshift(0);
              subtract2(rem, prod, remL, base);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 1) {
                  k++;
                  subtract2(rem, yL < remL ? yz : yd, remL, base);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }
            qd[i++] = k;
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          more = rem[0] !== void 0;
        }
        if (!qd[0])
          qd.shift();
      }
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {
        for (i = 1, k = qd[0]; k >= 10; k /= 10)
          i++;
        q.e = i + e * logBase - 1;
        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }
      return q;
    };
  }();
  function finalise(x, sd, rm, isTruncated) {
    var digits2, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
    out:
      if (sd != null) {
        xd = x.d;
        if (!xd)
          return x;
        for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
          digits2++;
        i = sd - digits2;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];
          rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {
              for (; k++ <= xdi; )
                xd.push(0);
              w = rd = 0;
              digits2 = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];
            for (digits2 = 1; k >= 10; k /= 10)
              digits2++;
            i %= LOG_BASE;
            j = i - LOG_BASE + digits2;
            rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
          }
        }
        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {
            sd -= x.e + 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {
            xd[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);
          xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
        }
        if (roundUp) {
          for (; ; ) {
            if (xdi == 0) {
              for (i = 1, j = xd[0]; j >= 10; j /= 10)
                i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10)
                k++;
              if (i != k) {
                x.e++;
                if (xd[0] == BASE)
                  xd[0] = 1;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE)
                break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i = xd.length; xd[--i] === 0; )
          xd.pop();
      }
    if (external) {
      if (x.e > Ctor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < Ctor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
    return x;
  }
  function finiteToString(x, isExp, sd) {
    if (!x.isFinite())
      return nonFiniteToString(x);
    var k, e = x.e, str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (x.e < 0 ? "e" : "e+") + x.e;
    } else if (e < 0) {
      str = "0." + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0)
        str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0)
        str = str + "." + getZeroString(k);
    } else {
      if ((k = e + 1) < len)
        str = str.slice(0, k) + "." + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len)
          str += ".";
        str += getZeroString(k);
      }
    }
    return str;
  }
  function getBase10Exponent(digits2, e) {
    var w = digits2[0];
    for (e *= LOG_BASE; w >= 10; w /= 10)
      e++;
    return e;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      external = true;
      if (pr)
        Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }
  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION)
      throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }
  function getPrecision(digits2) {
    var w = digits2.length - 1, len = w * LOG_BASE + 1;
    w = digits2[w];
    if (w) {
      for (; w % 10 == 0; w /= 10)
        len--;
      for (w = digits2[0]; w >= 10; w /= 10)
        len++;
    }
    return len;
  }
  function getZeroString(k) {
    var zs = "";
    for (; k--; )
      zs += "0";
    return zs;
  }
  function intPow(Ctor, x, n, pr) {
    var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k))
          isTruncated = true;
      }
      n = mathfloor(n / 2);
      if (n === 0) {
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0)
          ++r.d[n];
        break;
      }
      x = x.times(x);
      truncate(x.d, k);
    }
    external = true;
    return r;
  }
  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }
  function maxOrMin(Ctor, args, ltgt) {
    var y, x = new Ctor(args[0]), i = 0;
    for (; ++i < args.length; ) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }
    return x;
  }
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow3, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (!x.d || !x.d[0] || x.e > 17) {
      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t = new Ctor(0.03125);
    while (x.e > -2) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow3 = sum2 = new Ctor(1);
    Ctor.precision = wpr;
    for (; ; ) {
      pow3 = finalise(pow3.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum2.plus(divide(pow3, denominator, wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        j = k;
        while (j--)
          sum2 = finalise(sum2.times(sum2), wpr, 1);
        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow3 = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
    }
  }
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    if (Math.abs(e = x.e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }
      e = x.e;
      if (c0 > 1) {
        x = new Ctor("0." + c);
        e++;
      } else {
        x = new Ctor(c0 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr).times(e + "");
      x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }
    x1 = x;
    sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;
    for (; ; ) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
        sum2 = sum2.times(2);
        if (e !== 0)
          sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
        sum2 = divide(sum2, new Ctor(n), wpr, 1);
        if (sd == null) {
          if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum2, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum2;
        }
      }
      sum2 = t;
      denominator += 2;
    }
  }
  function nonFiniteToString(x) {
    return String(x.s * x.s / 0);
  }
  function parseDecimal(x, str) {
    var e, i, len;
    if ((e = str.indexOf(".")) > -1)
      str = str.replace(".", "");
    if ((i = str.search(/e/i)) > 0) {
      if (e < 0)
        e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {
      e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
      ;
    str = str.slice(i, len);
    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];
      i = (e + 1) % LOG_BASE;
      if (e < 0)
        i += LOG_BASE;
      if (i < len) {
        if (i)
          x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len; )
          x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }
      for (; i--; )
        str += "0";
      x.d.push(+str);
      if (external) {
        if (x.e > x.constructor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < x.constructor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
    } else {
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
    if (str.indexOf("_") > -1) {
      str = str.replace(/(\d)_(?=\d)/g, "$1");
      if (isDecimal.test(str))
        return parseDecimal(x, str);
    } else if (str === "Infinity" || str === "NaN") {
      if (!+str)
        x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }
    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }
    i = str.search(/p/i);
    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }
    i = str.indexOf(".");
    isFloat = i >= 0;
    Ctor = x.constructor;
    if (isFloat) {
      str = str.replace(".", "");
      len = str.length;
      i = len - i;
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }
    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;
    for (i = xe; xd[i] === 0; --i)
      xd.pop();
    if (i < 0)
      return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;
    if (isFloat)
      x = divide(x, divisor, len * 4);
    if (p)
      x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;
    return x;
  }
  function sine(Ctor, x) {
    var k, len = x.d.length;
    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);
    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }
    return x;
  }
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
    external = false;
    x2 = x.times(x);
    u = new Ctor(y);
    for (; ; ) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);
      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--; )
          ;
        if (j == -1)
          break;
      }
      j = u;
      u = y;
      y = t;
      t = j;
      i++;
    }
    external = true;
    t.d.length = k + 1;
    return t;
  }
  function tinyPow(b, e) {
    var n = b;
    while (--e)
      n *= b;
    return n;
  }
  function toLessThanHalfPi(Ctor, x) {
    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
    x = x.abs();
    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }
    t = x.divToInt(pi);
    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x;
      }
      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }
    return x.minus(pi).abs();
  }
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }
    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf(".");
      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }
      if (i >= 0) {
        str = str.replace(".", "");
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }
      xd = convertBase(str, 10, base);
      e = len = xd.length;
      for (; xd[--len] == 0; )
        xd.pop();
      if (!xd[0]) {
        str = isExp ? "0p+0" : "0";
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
        xd.length = sd;
        if (roundUp) {
          for (; ++xd[--sd] > base - 1; ) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }
        for (len = xd.length; !xd[len - 1]; --len)
          ;
        for (i = 0, str = ""; i < len; i++)
          str += NUMERALS.charAt(xd[i]);
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++)
                str += "0";
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len)
                ;
              for (i = 1, str = "1."; i < len; i++)
                str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + "." + str.slice(1);
            }
          }
          str = str + (e < 0 ? "p" : "p+") + e;
        } else if (e < 0) {
          for (; ++e; )
            str = "0" + str;
          str = "0." + str;
        } else {
          if (++e > len)
            for (e -= len; e--; )
              str += "0";
          else if (e < len)
            str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function abs(x) {
    return new this(x).abs();
  }
  function acos(x) {
    return new this(x).acos();
  }
  function acosh(x) {
    return new this(x).acosh();
  }
  function add(x, y) {
    return new this(x).plus(y);
  }
  function asin(x) {
    return new this(x).asin();
  }
  function asinh(x) {
    return new this(x).asinh();
  }
  function atan(x) {
    return new this(x).atan();
  }
  function atanh(x) {
    return new this(x).atanh();
  }
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
    if (!y.s || !x.s) {
      r = new this(NaN);
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }
    return r;
  }
  function cbrt3(x) {
    return new this(x).cbrt();
  }
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }
  function clamp(x, min2, max2) {
    return new this(x).clamp(min2, max2);
  }
  function config3(obj) {
    if (!obj || typeof obj !== "object")
      throw Error(decimalError + "Object expected");
    var i, p, v, useDefaults = obj.defaults === true, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -EXP_LIMIT,
      0,
      "toExpPos",
      0,
      EXP_LIMIT,
      "maxE",
      0,
      EXP_LIMIT,
      "minE",
      -EXP_LIMIT,
      0,
      "modulo",
      0,
      9
    ];
    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
          this[p] = v;
        else
          throw Error(invalidArgument + p + ": " + v);
      }
    }
    if (p = "crypto", useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ": " + v);
      }
    }
    return this;
  }
  function cos(x) {
    return new this(x).cos();
  }
  function cosh(x) {
    return new this(x).cosh();
  }
  function clone2(obj) {
    var i, p, ps;
    function Decimal2(v) {
      var e, i2, t, x = this;
      if (!(x instanceof Decimal2))
        return new Decimal2(v);
      x.constructor = Decimal2;
      if (isDecimalInstance(v)) {
        x.s = v.s;
        if (external) {
          if (!v.d || v.e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }
        return;
      }
      t = typeof v;
      if (t === "number") {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        if (v === ~~v && v < 1e7) {
          for (e = 0, i2 = v; i2 >= 10; i2 /= 10)
            e++;
          if (external) {
            if (e > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }
          return;
        } else if (v * 0 !== 0) {
          if (!v)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }
        return parseDecimal(x, v.toString());
      } else if (t !== "string") {
        throw Error(invalidArgument + v);
      }
      if ((i2 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i2 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.EUCLID = 9;
    Decimal2.config = Decimal2.set = config3;
    Decimal2.clone = clone2;
    Decimal2.isDecimal = isDecimalInstance;
    Decimal2.abs = abs;
    Decimal2.acos = acos;
    Decimal2.acosh = acosh;
    Decimal2.add = add;
    Decimal2.asin = asin;
    Decimal2.asinh = asinh;
    Decimal2.atan = atan;
    Decimal2.atanh = atanh;
    Decimal2.atan2 = atan2;
    Decimal2.cbrt = cbrt3;
    Decimal2.ceil = ceil;
    Decimal2.clamp = clamp;
    Decimal2.cos = cos;
    Decimal2.cosh = cosh;
    Decimal2.div = div;
    Decimal2.exp = exp;
    Decimal2.floor = floor;
    Decimal2.hypot = hypot;
    Decimal2.ln = ln;
    Decimal2.log = log;
    Decimal2.log10 = log103;
    Decimal2.log2 = log23;
    Decimal2.max = max;
    Decimal2.min = min;
    Decimal2.mod = mod;
    Decimal2.mul = mul;
    Decimal2.pow = pow;
    Decimal2.random = random;
    Decimal2.round = round;
    Decimal2.sign = sign2;
    Decimal2.sin = sin;
    Decimal2.sinh = sinh;
    Decimal2.sqrt = sqrt;
    Decimal2.sub = sub;
    Decimal2.sum = sum;
    Decimal2.tan = tan;
    Decimal2.tanh = tanh;
    Decimal2.trunc = trunc;
    if (obj === void 0)
      obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
        for (i = 0; i < ps.length; )
          if (!obj.hasOwnProperty(p = ps[i++]))
            obj[p] = this[p];
      }
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function div(x, y) {
    return new this(x).div(y);
  }
  function exp(x) {
    return new this(x).exp();
  }
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }
  function hypot() {
    var i, n, t = new this(0);
    external = false;
    for (i = 0; i < arguments.length; ) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }
    external = true;
    return t.sqrt();
  }
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  function ln(x) {
    return new this(x).ln();
  }
  function log(x, y) {
    return new this(x).log(y);
  }
  function log23(x) {
    return new this(x).log(2);
  }
  function log103(x) {
    return new this(x).log(10);
  }
  function max() {
    return maxOrMin(this, arguments, "lt");
  }
  function min() {
    return maxOrMin(this, arguments, "gt");
  }
  function mod(x, y) {
    return new this(x).mod(y);
  }
  function mul(x, y) {
    return new this(x).mul(y);
  }
  function pow(x, y) {
    return new this(x).pow(y);
  }
  function random(sd) {
    var d, e, k, n, i = 0, r = new this(1), rd = [];
    if (sd === void 0)
      sd = this.precision;
    else
      checkInt32(sd, 1, MAX_DIGITS);
    k = Math.ceil(sd / LOG_BASE);
    if (!this.crypto) {
      for (; i < k; )
        rd[i++] = Math.random() * 1e7 | 0;
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));
      for (; i < k; ) {
        n = d[i];
        if (n >= 429e7) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          rd[i++] = n % 1e7;
        }
      }
    } else if (crypto.randomBytes) {
      d = crypto.randomBytes(k *= 4);
      for (; i < k; ) {
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
        if (n >= 214e7) {
          crypto.randomBytes(4).copy(d, i);
        } else {
          rd.push(n % 1e7);
          i += 4;
        }
      }
      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }
    k = rd[--i];
    sd %= LOG_BASE;
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }
    for (; rd[i] === 0; i--)
      rd.pop();
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;
      for (; rd[0] === 0; e -= LOG_BASE)
        rd.shift();
      for (k = 1, n = rd[0]; n >= 10; n /= 10)
        k++;
      if (k < LOG_BASE)
        e -= LOG_BASE - k;
    }
    r.e = e;
    r.d = rd;
    return r;
  }
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }
  function sign2(x) {
    x = new this(x);
    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
  }
  function sin(x) {
    return new this(x).sin();
  }
  function sinh(x) {
    return new this(x).sinh();
  }
  function sqrt(x) {
    return new this(x).sqrt();
  }
  function sub(x, y) {
    return new this(x).sub(y);
  }
  function sum() {
    var i = 0, args = arguments, x = new this(args[i]);
    external = false;
    for (; x.s && ++i < args.length; )
      x = x.plus(args[i]);
    external = true;
    return finalise(x, this.precision, this.rounding);
  }
  function tan(x) {
    return new this(x).tan();
  }
  function tanh(x) {
    return new this(x).tanh();
  }
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
  P[Symbol.toStringTag] = "Decimal";
  var Decimal = P.constructor = clone2(DEFAULTS);
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);
  var decimal_default = Decimal;

  // ../node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
  var name = "BigNumber";
  var dependencies2 = ["?on", "config"];
  var createBigNumberClass = /* @__PURE__ */ factory(name, dependencies2, (_ref) => {
    var {
      on,
      config: config4
    } = _ref;
    var BigNumber2 = decimal_default.clone({
      precision: config4.precision,
      modulo: decimal_default.EUCLID
    });
    BigNumber2.prototype = Object.create(BigNumber2.prototype);
    BigNumber2.prototype.type = "BigNumber";
    BigNumber2.prototype.isBigNumber = true;
    BigNumber2.prototype.toJSON = function() {
      return {
        mathjs: "BigNumber",
        value: this.toString()
      };
    };
    BigNumber2.fromJSON = function(json) {
      return new BigNumber2(json.value);
    };
    if (on) {
      on("config", function(curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber2.config({
            precision: curr.precision
          });
        }
      });
    }
    return BigNumber2;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/type/complex/Complex.js
  var import_complex = __toESM(require_complex(), 1);
  var name2 = "Complex";
  var dependencies3 = [];
  var createComplexClass = /* @__PURE__ */ factory(name2, dependencies3, () => {
    import_complex.default.prototype.type = "Complex";
    import_complex.default.prototype.isComplex = true;
    import_complex.default.prototype.toJSON = function() {
      return {
        mathjs: "Complex",
        re: this.re,
        im: this.im
      };
    };
    import_complex.default.prototype.toPolar = function() {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    import_complex.default.prototype.format = function(options) {
      var str = "";
      var im2 = this.im;
      var re2 = this.re;
      var strRe = format(this.re, options);
      var strIm = format(this.im, options);
      var precision = isNumber(options) ? options : options ? options.precision : null;
      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);
        if (Math.abs(re2 / im2) < epsilon) {
          re2 = 0;
        }
        if (Math.abs(im2 / re2) < epsilon) {
          im2 = 0;
        }
      }
      if (im2 === 0) {
        str = strRe;
      } else if (re2 === 0) {
        if (im2 === 1) {
          str = "i";
        } else if (im2 === -1) {
          str = "-i";
        } else {
          str = strIm + "i";
        }
      } else {
        if (im2 < 0) {
          if (im2 === -1) {
            str = strRe + " - i";
          } else {
            str = strRe + " - " + strIm.substring(1) + "i";
          }
        } else {
          if (im2 === 1) {
            str = strRe + " + i";
          } else {
            str = strRe + " + " + strIm + "i";
          }
        }
      }
      return str;
    };
    import_complex.default.fromPolar = function(args) {
      switch (arguments.length) {
        case 1: {
          var arg = arguments[0];
          if (typeof arg === "object") {
            return (0, import_complex.default)(arg);
          } else {
            throw new TypeError("Input has to be an object with r and phi keys.");
          }
        }
        case 2: {
          var r = arguments[0];
          var phi = arguments[1];
          if (isNumber(r)) {
            if (isUnit(phi) && phi.hasBase("ANGLE")) {
              phi = phi.toNumber("rad");
            }
            if (isNumber(phi)) {
              return new import_complex.default({
                r,
                phi
              });
            }
            throw new TypeError("Phi is not a number nor an angle unit.");
          } else {
            throw new TypeError("Radius r is not a number.");
          }
        }
        default:
          throw new SyntaxError("Wrong number of arguments in function fromPolar");
      }
    };
    import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
    import_complex.default.fromJSON = function(json) {
      return new import_complex.default(json);
    };
    import_complex.default.compare = function(a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return import_complex.default;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/type/fraction/Fraction.js
  var import_fraction = __toESM(require_fraction(), 1);
  var name3 = "Fraction";
  var dependencies4 = [];
  var createFractionClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
    import_fraction.default.prototype.type = "Fraction";
    import_fraction.default.prototype.isFraction = true;
    import_fraction.default.prototype.toJSON = function() {
      return {
        mathjs: "Fraction",
        n: this.s * this.n,
        d: this.d
      };
    };
    import_fraction.default.fromJSON = function(json) {
      return new import_fraction.default(json);
    };
    return import_fraction.default;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/Matrix.js
  var name4 = "Matrix";
  var dependencies5 = [];
  var createMatrixClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
    function Matrix2() {
      if (!(this instanceof Matrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
    }
    Matrix2.prototype.type = "Matrix";
    Matrix2.prototype.isMatrix = true;
    Matrix2.prototype.storage = function() {
      throw new Error("Cannot invoke storage on a Matrix interface");
    };
    Matrix2.prototype.datatype = function() {
      throw new Error("Cannot invoke datatype on a Matrix interface");
    };
    Matrix2.prototype.create = function(data, datatype) {
      throw new Error("Cannot invoke create on a Matrix interface");
    };
    Matrix2.prototype.subset = function(index, replacement, defaultValue) {
      throw new Error("Cannot invoke subset on a Matrix interface");
    };
    Matrix2.prototype.get = function(index) {
      throw new Error("Cannot invoke get on a Matrix interface");
    };
    Matrix2.prototype.set = function(index, value, defaultValue) {
      throw new Error("Cannot invoke set on a Matrix interface");
    };
    Matrix2.prototype.resize = function(size2, defaultValue) {
      throw new Error("Cannot invoke resize on a Matrix interface");
    };
    Matrix2.prototype.reshape = function(size2, defaultValue) {
      throw new Error("Cannot invoke reshape on a Matrix interface");
    };
    Matrix2.prototype.clone = function() {
      throw new Error("Cannot invoke clone on a Matrix interface");
    };
    Matrix2.prototype.size = function() {
      throw new Error("Cannot invoke size on a Matrix interface");
    };
    Matrix2.prototype.map = function(callback, skipZeros) {
      throw new Error("Cannot invoke map on a Matrix interface");
    };
    Matrix2.prototype.forEach = function(callback) {
      throw new Error("Cannot invoke forEach on a Matrix interface");
    };
    Matrix2.prototype[Symbol.iterator] = function() {
      throw new Error("Cannot iterate a Matrix interface");
    };
    Matrix2.prototype.toArray = function() {
      throw new Error("Cannot invoke toArray on a Matrix interface");
    };
    Matrix2.prototype.valueOf = function() {
      throw new Error("Cannot invoke valueOf on a Matrix interface");
    };
    Matrix2.prototype.format = function(options) {
      throw new Error("Cannot invoke format on a Matrix interface");
    };
    Matrix2.prototype.toString = function() {
      throw new Error("Cannot invoke toString on a Matrix interface");
    };
    return Matrix2;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
  var name5 = "DenseMatrix";
  var dependencies6 = ["Matrix"];
  var createDenseMatrixClass = /* @__PURE__ */ factory(name5, dependencies6, (_ref) => {
    var {
      Matrix: Matrix2
    } = _ref;
    function DenseMatrix2(data, datatype) {
      if (!(this instanceof DenseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        if (data.type === "DenseMatrix") {
          this._data = clone(data._data);
          this._size = clone(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        this._data = preprocess(data);
        this._size = arraySize(this._data);
        validate(this._data, this._size);
        this._datatype = datatype;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }
    DenseMatrix2.prototype = new Matrix2();
    DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.type = "DenseMatrix";
    DenseMatrix2.prototype.isDenseMatrix = true;
    DenseMatrix2.prototype.getDataType = function() {
      return getArrayDataType(this._data, typeOf);
    };
    DenseMatrix2.prototype.storage = function() {
      return "dense";
    };
    DenseMatrix2.prototype.datatype = function() {
      return this._datatype;
    };
    DenseMatrix2.prototype.create = function(data, datatype) {
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index);
        case 2:
        case 3:
          return _set(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    DenseMatrix2.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      for (var x = 0; x < index.length; x++) {
        validateIndex(index[x], this._size[x]);
      }
      var data = this._data;
      for (var i = 0, ii = index.length; i < ii; i++) {
        var indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      return data;
    };
    DenseMatrix2.prototype.set = function(index, value, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length < this._size.length) {
        throw new DimensionError(index.length, this._size.length, "<");
      }
      var i, ii, indexI;
      var size2 = index.map(function(i2) {
        return i2 + 1;
      });
      _fit(this, size2, defaultValue);
      var data = this._data;
      for (i = 0, ii = index.length - 1; i < ii; i++) {
        indexI = index[i];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      indexI = index[index.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    function _get(matrix2, index) {
      if (!isIndex(index)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = index.isScalar();
      if (isScalar) {
        return matrix2.get(index.min());
      } else {
        var size2 = index.size();
        if (size2.length !== matrix2._size.length) {
          throw new DimensionError(size2.length, matrix2._size.length);
        }
        var min2 = index.min();
        var max2 = index.max();
        for (var i = 0, ii = matrix2._size.length; i < ii; i++) {
          validateIndex(min2[i], matrix2._size[i]);
          validateIndex(max2[i], matrix2._size[i]);
        }
        return new DenseMatrix2(_getSubmatrix(matrix2._data, index, size2.length, 0), matrix2._datatype);
      }
    }
    function _getSubmatrix(data, index, dims, dim) {
      var last = dim === dims - 1;
      var range2 = index.dimension(dim);
      if (last) {
        return range2.map(function(i) {
          validateIndex(i, data.length);
          return data[i];
        }).valueOf();
      } else {
        return range2.map(function(i) {
          validateIndex(i, data.length);
          var child = data[i];
          return _getSubmatrix(child, index, dims, dim + 1);
        }).valueOf();
      }
    }
    function _set(matrix2, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix2.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length < matrix2._size.length) {
          throw new DimensionError(iSize.length, matrix2._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        var size2 = index.max().map(function(i2) {
          return i2 + 1;
        });
        _fit(matrix2, size2, defaultValue);
        var dims = iSize.length;
        var dim = 0;
        _setSubmatrix(matrix2._data, index, submatrix, dims, dim);
      }
      return matrix2;
    }
    function _setSubmatrix(data, index, submatrix, dims, dim) {
      var last = dim === dims - 1;
      var range2 = index.dimension(dim);
      if (last) {
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          _setSubmatrix(data[dataIndex], index, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
      if (!isCollection(size2)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size2.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray, defaultValue);
    };
    function _resize2(matrix2, size2, defaultValue) {
      if (size2.length === 0) {
        var v = matrix2._data;
        while (isArray(v)) {
          v = v[0];
        }
        return v;
      }
      matrix2._size = size2.slice(0);
      matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
      return matrix2;
    }
    DenseMatrix2.prototype.reshape = function(size2, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size2);
      var currentLength = m._size.reduce((length, size3) => length * size3);
      m._size = processSizesWildcard(size2, currentLength);
      return m;
    };
    function _fit(matrix2, size2, defaultValue) {
      var newSize = matrix2._size.slice(0);
      var changed = false;
      while (newSize.length < size2.length) {
        newSize.push(0);
        changed = true;
      }
      for (var i = 0, ii = size2.length; i < ii; i++) {
        if (size2[i] > newSize[i]) {
          newSize[i] = size2[i];
          changed = true;
        }
      }
      if (changed) {
        _resize2(matrix2, newSize, defaultValue);
      }
    }
    DenseMatrix2.prototype.clone = function() {
      var m = new DenseMatrix2({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    DenseMatrix2.prototype.size = function() {
      return this._size.slice(0);
    };
    DenseMatrix2.prototype.map = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          return value.map(function(child, i) {
            return recurse2(child, index.concat(i));
          });
        } else {
          return callback(value, index, me);
        }
      };
      var data = recurse(this._data, []);
      var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.forEach = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index) {
        if (isArray(value)) {
          value.forEach(function(child, i) {
            recurse2(child, index.concat(i));
          });
        } else {
          callback(value, index, me);
        }
      };
      recurse(this._data, []);
    };
    DenseMatrix2.prototype[Symbol.iterator] = function* () {
      var recurse = function* recurse2(value, index) {
        if (isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            yield* recurse2(value[i], index.concat(i));
          }
        } else {
          yield {
            value,
            index
          };
        }
      };
      yield* recurse(this._data, []);
    };
    DenseMatrix2.prototype.rows = function() {
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      for (var row of data) {
        result.push(new DenseMatrix2([row], this._datatype));
      }
      return result;
    };
    DenseMatrix2.prototype.columns = function() {
      var _this = this;
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      var _loop = function _loop2(i2) {
        var col = data.map((row) => [row[i2]]);
        result.push(new DenseMatrix2(col, _this._datatype));
      };
      for (var i = 0; i < s[1]; i++) {
        _loop(i);
      }
      return result;
    };
    DenseMatrix2.prototype.toArray = function() {
      return clone(this._data);
    };
    DenseMatrix2.prototype.valueOf = function() {
      return this._data;
    };
    DenseMatrix2.prototype.format = function(options) {
      return format3(this._data, options);
    };
    DenseMatrix2.prototype.toString = function() {
      return format3(this._data);
    };
    DenseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "DenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    DenseMatrix2.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var data = [];
      for (var i = 0; i < n; i++) {
        data[i] = this._data[i + kSub][i + kSuper];
      }
      return new DenseMatrix2({
        data,
        size: [n],
        datatype: this._datatype
      });
    };
    DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
      if (!isArray(size2)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size2.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size2 = size2.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size2[0];
      var columns = size2[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i) {
          return value[i];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i) {
          return value.get([i]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      if (!defaultValue) {
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
      }
      var data = [];
      if (size2.length > 0) {
        data = resize(data, size2, defaultValue);
        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      }
      return new DenseMatrix2({
        data,
        size: [rows, columns]
      });
    };
    DenseMatrix2.fromJSON = function(json) {
      return new DenseMatrix2(json);
    };
    DenseMatrix2.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      DenseMatrix2._swapRows(i, j, this._data);
      return this;
    };
    DenseMatrix2._swapRows = function(i, j, data) {
      var vi = data[i];
      data[i] = data[j];
      data[j] = vi;
    };
    function preprocess(data) {
      for (var i = 0, ii = data.length; i < ii; i++) {
        var elem = data[i];
        if (isArray(elem)) {
          data[i] = preprocess(elem);
        } else if (elem && elem.isMatrix === true) {
          data[i] = preprocess(elem.valueOf());
        }
      }
      return data;
    }
    return DenseMatrix2;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/utils/collection.js
  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === "function") {
      return array.map(function(x) {
        return deepMap(x, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }

  // ../node_modules/mathjs/lib/esm/plain/number/arithmetic.js
  var n1 = "number";
  var n2 = "number, number";
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function subtractNumber(a, b) {
    return a - b;
  }
  subtractNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function divideNumber(a, b) {
    return a / b;
  }
  divideNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1;
  function unaryPlusNumber(x) {
    return x;
  }
  unaryPlusNumber.signature = n1;
  function cbrtNumber(x) {
    return cbrt(x);
  }
  cbrtNumber.signature = n1;
  function cubeNumber(x) {
    return x * x * x;
  }
  cubeNumber.signature = n1;
  function expNumber(x) {
    return Math.exp(x);
  }
  expNumber.signature = n1;
  function expm1Number(x) {
    return expm1(x);
  }
  expm1Number.signature = n1;
  function gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = a % b;
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  gcdNumber.signature = n2;
  function lcmNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a === 0 || b === 0) {
      return 0;
    }
    var t;
    var prod = a * b;
    while (b !== 0) {
      t = b;
      b = a % t;
      a = t;
    }
    return Math.abs(prod / a);
  }
  lcmNumber.signature = n2;
  function log10Number(x) {
    return log10(x);
  }
  log10Number.signature = n1;
  function log2Number(x) {
    return log2(x);
  }
  log2Number.signature = n1;
  function log1pNumber(x) {
    return log1p(x);
  }
  log1pNumber.signature = n1;
  function modNumber(x, y) {
    if (y > 0) {
      return x - y * Math.floor(x / y);
    } else if (y === 0) {
      return x;
    } else {
      throw new Error("Cannot calculate mod for a negative divisor");
    }
  }
  modNumber.signature = n2;
  function signNumber(x) {
    return sign(x);
  }
  signNumber.signature = n1;
  function sqrtNumber(x) {
    return Math.sqrt(x);
  }
  sqrtNumber.signature = n1;
  function squareNumber(x) {
    return x * x;
  }
  squareNumber.signature = n1;
  function xgcdNumber(a, b) {
    var t;
    var q;
    var r;
    var x = 0;
    var lastx = 1;
    var y = 1;
    var lasty = 0;
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (b) {
      q = Math.floor(a / b);
      r = a - q * b;
      t = x;
      x = lastx - q * x;
      lastx = t;
      t = y;
      y = lasty - q * y;
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    } else {
      res = [a, a ? lastx : 0, lasty];
    }
    return res;
  }
  xgcdNumber.signature = n2;
  function powNumber(x, y) {
    if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
      return 0;
    }
    return Math.pow(x, y);
  }
  powNumber.signature = n2;
  function normNumber(x) {
    return Math.abs(x);
  }
  normNumber.signature = n1;

  // ../node_modules/mathjs/lib/esm/plain/number/utils.js
  var n12 = "number";
  function isIntegerNumber(x) {
    return isInteger(x);
  }
  isIntegerNumber.signature = n12;
  function isNegativeNumber(x) {
    return x < 0;
  }
  isNegativeNumber.signature = n12;
  function isPositiveNumber(x) {
    return x > 0;
  }
  isPositiveNumber.signature = n12;
  function isZeroNumber(x) {
    return x === 0;
  }
  isZeroNumber.signature = n12;
  function isNaNNumber(x) {
    return Number.isNaN(x);
  }
  isNaNNumber.signature = n12;

  // ../node_modules/mathjs/lib/esm/function/utils/isZero.js
  var name6 = "isZero";
  var dependencies7 = ["typed"];
  var createIsZero = /* @__PURE__ */ factory(name6, dependencies7, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name6, {
      number: isZeroNumber,
      BigNumber: function BigNumber2(x) {
        return x.isZero();
      },
      Complex: function Complex3(x) {
        return x.re === 0 && x.im === 0;
      },
      Fraction: function Fraction3(x) {
        return x.d === 1 && x.n === 0;
      },
      Unit: function Unit(x) {
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
  function nearlyEqual2(x, y, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x.eq(y);
    }
    if (x.eq(y)) {
      return true;
    }
    if (x.isNaN() || y.isNaN()) {
      return false;
    }
    if (x.isFinite() && y.isFinite()) {
      var diff = x.minus(y).abs();
      if (diff.isZero()) {
        return true;
      } else {
        var max2 = x.constructor.max(x.abs(), y.abs());
        return diff.lte(max2.times(epsilon));
      }
    }
    return false;
  }

  // ../node_modules/mathjs/lib/esm/utils/complex.js
  function complexEquals(x, y, epsilon) {
    return nearlyEqual(x.re, y.re, epsilon) && nearlyEqual(x.im, y.im, epsilon);
  }

  // ../node_modules/mathjs/lib/esm/function/relational/equalScalar.js
  var name7 = "equalScalar";
  var dependencies8 = ["typed", "config"];
  var createEqualScalar = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
    var {
      typed: typed2,
      config: config4
    } = _ref;
    return typed2(name7, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x === y;
      },
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.eq(y) || nearlyEqual2(x, y, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.equals(y);
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return complexEquals(x, y, config4.epsilon);
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      }
    });
  });
  var createEqualScalarNumber = factory(name7, ["typed", "config"], (_ref2) => {
    var {
      typed: typed2,
      config: config4
    } = _ref2;
    return typed2(name7, {
      "number, number": function numberNumber(x, y) {
        return nearlyEqual(x, y, config4.epsilon);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
  var name8 = "SparseMatrix";
  var dependencies9 = ["typed", "equalScalar", "Matrix"];
  var createSparseMatrixClass = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2,
      Matrix: Matrix2
    } = _ref;
    function SparseMatrix2(data, datatype) {
      if (!(this instanceof SparseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        _createFromArray(this, data, datatype);
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }
    function _createFromMatrix(matrix2, source, datatype) {
      if (source.type === "SparseMatrix") {
        matrix2._values = source._values ? clone(source._values) : void 0;
        matrix2._index = clone(source._index);
        matrix2._ptr = clone(source._ptr);
        matrix2._size = clone(source._size);
        matrix2._datatype = datatype || source._datatype;
      } else {
        _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix2, data, datatype) {
      matrix2._values = [];
      matrix2._index = [];
      matrix2._ptr = [];
      matrix2._datatype = datatype;
      var rows = data.length;
      var columns = 0;
      var eq = equalScalar2;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
        zero = typed2.convert(0, datatype);
      }
      if (rows > 0) {
        var j = 0;
        do {
          matrix2._ptr.push(matrix2._index.length);
          for (var i = 0; i < rows; i++) {
            var row = data[i];
            if (isArray(row)) {
              if (j === 0 && columns < row.length) {
                columns = row.length;
              }
              if (j < row.length) {
                var v = row[j];
                if (!eq(v, zero)) {
                  matrix2._values.push(v);
                  matrix2._index.push(i);
                }
              }
            } else {
              if (j === 0 && columns < 1) {
                columns = 1;
              }
              if (!eq(row, zero)) {
                matrix2._values.push(row);
                matrix2._index.push(i);
              }
            }
          }
          j++;
        } while (j < columns);
      }
      matrix2._ptr.push(matrix2._index.length);
      matrix2._size = [rows, columns];
    }
    SparseMatrix2.prototype = new Matrix2();
    SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
      return new SparseMatrix2(data, datatype);
    };
    SparseMatrix2.prototype.type = "SparseMatrix";
    SparseMatrix2.prototype.isSparseMatrix = true;
    SparseMatrix2.prototype.getDataType = function() {
      return getArrayDataType(this._values, typeOf);
    };
    SparseMatrix2.prototype.storage = function() {
      return "sparse";
    };
    SparseMatrix2.prototype.datatype = function() {
      return this._datatype;
    };
    SparseMatrix2.prototype.create = function(data, datatype) {
      return new SparseMatrix2(data, datatype);
    };
    SparseMatrix2.prototype.density = function() {
      var rows = this._size[0];
      var columns = this._size[1];
      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    SparseMatrix2.prototype.subset = function(index, replacement, defaultValue) {
      if (!this._values) {
        throw new Error("Cannot invoke subset on a Pattern only matrix");
      }
      switch (arguments.length) {
        case 1:
          return _getsubset(this, index);
        case 2:
        case 3:
          return _setsubset(this, index, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    function _getsubset(matrix2, idx) {
      if (!isIndex(idx)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = idx.isScalar();
      if (isScalar) {
        return matrix2.get(idx.min());
      }
      var size2 = idx.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var i, ii, k, kk;
      var min2 = idx.min();
      var max2 = idx.max();
      for (i = 0, ii = matrix2._size.length; i < ii; i++) {
        validateIndex(min2[i], matrix2._size[i]);
        validateIndex(max2[i], matrix2._size[i]);
      }
      var mvalues = matrix2._values;
      var mindex = matrix2._index;
      var mptr = matrix2._ptr;
      var rows = idx.dimension(0);
      var columns = idx.dimension(1);
      var w = [];
      var pv = [];
      rows.forEach(function(i2, r) {
        pv[i2] = r[0];
        w[i2] = true;
      });
      var values = mvalues ? [] : void 0;
      var index = [];
      var ptr = [];
      columns.forEach(function(j) {
        ptr.push(index.length);
        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          i = mindex[k];
          if (w[i] === true) {
            index.push(pv[i]);
            if (values) {
              values.push(mvalues[k]);
            }
          }
        }
      });
      ptr.push(index.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: size2,
        datatype: matrix2._datatype
      });
    }
    function _setsubset(matrix2, index, submatrix, defaultValue) {
      if (!index || index.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index.size();
      var isScalar = index.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.toArray();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix2.set(index.min(), submatrix, defaultValue);
      } else {
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix2._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i = 0;
          var outer = 0;
          while (iSize[i] === 1 && sSize[i] === 1) {
            i++;
          }
          while (iSize[i] === 1) {
            outer++;
            i++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        if (iSize.length === 1) {
          var range2 = index.dimension(0);
          range2.forEach(function(dataIndex, subIndex) {
            validateIndex(dataIndex);
            matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
          });
        } else {
          var firstDimensionRange = index.dimension(0);
          var secondDimensionRange = index.dimension(1);
          firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
            validateIndex(firstDataIndex);
            secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
              validateIndex(secondDataIndex);
              matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
            });
          });
        }
      }
      return matrix2;
    }
    SparseMatrix2.prototype.get = function(index) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke get on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[1]);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        return this._values[k];
      }
      return 0;
    };
    SparseMatrix2.prototype.set = function(index, v, defaultValue) {
      if (!isArray(index)) {
        throw new TypeError("Array expected");
      }
      if (index.length !== this._size.length) {
        throw new DimensionError(index.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke set on a Pattern only matrix");
      }
      var i = index[0];
      var j = index[1];
      var rows = this._size[0];
      var columns = this._size[1];
      var eq = equalScalar2;
      var zero = 0;
      if (isString(this._datatype)) {
        eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
        zero = typed2.convert(0, this._datatype);
      }
      if (i > rows - 1 || j > columns - 1) {
        _resize2(this, Math.max(i + 1, rows), Math.max(j + 1, columns), defaultValue);
        rows = this._size[0];
        columns = this._size[1];
      }
      validateIndex(i, rows);
      validateIndex(j, columns);
      var k = _getValueIndex(i, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i) {
        if (!eq(v, zero)) {
          this._values[k] = v;
        } else {
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        _insert(k, i, j, v, this._values, this._index, this._ptr);
      }
      return this;
    };
    function _getValueIndex(i, top, bottom, index) {
      if (bottom - top === 0) {
        return bottom;
      }
      for (var r = top; r < bottom; r++) {
        if (index[r] === i) {
          return r;
        }
      }
      return top;
    }
    function _remove(k, j, values, index, ptr) {
      values.splice(k, 1);
      index.splice(k, 1);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i, j, v, values, index, ptr) {
      values.splice(k, 0, v);
      index.splice(k, 0, i);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
      if (!isCollection(size2)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size2.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      if (sizeArray.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      sizeArray.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
        }
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize2(matrix2, rows, columns, defaultValue) {
      var value = defaultValue || 0;
      var eq = equalScalar2;
      var zero = 0;
      if (isString(matrix2._datatype)) {
        eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
        zero = typed2.convert(0, matrix2._datatype);
        value = typed2.convert(value, matrix2._datatype);
      }
      var ins = !eq(value, zero);
      var r = matrix2._size[0];
      var c = matrix2._size[1];
      var i, j, k;
      if (columns > c) {
        for (j = c; j < columns; j++) {
          matrix2._ptr[j] = matrix2._values.length;
          if (ins) {
            for (i = 0; i < r; i++) {
              matrix2._values.push(value);
              matrix2._index.push(i);
            }
          }
        }
        matrix2._ptr[columns] = matrix2._values.length;
      } else if (columns < c) {
        matrix2._ptr.splice(columns + 1, c - columns);
        matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
        matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
      }
      c = columns;
      if (rows > r) {
        if (ins) {
          var n = 0;
          for (j = 0; j < c; j++) {
            matrix2._ptr[j] = matrix2._ptr[j] + n;
            k = matrix2._ptr[j + 1] + n;
            var p = 0;
            for (i = r; i < rows; i++, p++) {
              matrix2._values.splice(k + p, 0, value);
              matrix2._index.splice(k + p, 0, i);
              n++;
            }
          }
          matrix2._ptr[c] = matrix2._values.length;
        }
      } else if (rows < r) {
        var d = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] - d;
          var k0 = matrix2._ptr[j];
          var k1 = matrix2._ptr[j + 1] - d;
          for (k = k0; k < k1; k++) {
            i = matrix2._index[k];
            if (i > rows - 1) {
              matrix2._values.splice(k, 1);
              matrix2._index.splice(k, 1);
              d++;
            }
          }
        }
        matrix2._ptr[j] = matrix2._values.length;
      }
      matrix2._size[0] = rows;
      matrix2._size[1] = columns;
      return matrix2;
    }
    SparseMatrix2.prototype.reshape = function(sizes, copy) {
      if (!isArray(sizes)) {
        throw new TypeError("Array expected");
      }
      if (sizes.length !== 2) {
        throw new Error("Sparse matrices can only be reshaped in two dimensions");
      }
      sizes.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
          throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
        }
      });
      var currentLength = this._size[0] * this._size[1];
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = sizes[0] * sizes[1];
      if (currentLength !== newLength) {
        throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
      }
      var m = copy ? this.clone() : this;
      if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
        return m;
      }
      var colIndex = [];
      for (var i = 0; i < m._ptr.length; i++) {
        for (var j = 0; j < m._ptr[i + 1] - m._ptr[i]; j++) {
          colIndex.push(i);
        }
      }
      var values = m._values.slice();
      var rowIndex = m._index.slice();
      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % sizes[1];
        rowIndex[_i] = Math.floor(flat / sizes[1]);
      }
      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = sizes[1] + 1;
      m._size = sizes.slice();
      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      }
      for (var h = 0; h < values.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values[h];
        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      }
      return m;
    };
    SparseMatrix2.prototype.clone = function() {
      var m = new SparseMatrix2({
        values: this._values ? clone(this._values) : void 0,
        index: clone(this._index),
        ptr: clone(this._ptr),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    SparseMatrix2.prototype.size = function() {
      return this._size.slice(0);
    };
    SparseMatrix2.prototype.map = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke map on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      var invoke = function invoke2(v, i, j) {
        return callback(v, [i, j], me);
      };
      return _map(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    function _map(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      var values = [];
      var index = [];
      var ptr = [];
      var eq = equalScalar2;
      var zero = 0;
      if (isString(matrix2._datatype)) {
        eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
        zero = typed2.convert(0, matrix2._datatype);
      }
      var invoke = function invoke2(v, x, y) {
        v = callback(v, x, y);
        if (!eq(v, zero)) {
          values.push(v);
          index.push(x);
        }
      };
      for (var j = minColumn; j <= maxColumn; j++) {
        ptr.push(values.length);
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = matrix2._index[k];
            if (i >= minRow && i <= maxRow) {
              invoke(matrix2._values[k], i - minRow, j - minColumn);
            }
          }
        } else {
          var _values = {};
          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix2._index[_k];
            _values[_i4] = matrix2._values[_k];
          }
          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke forEach on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i = this._index[k];
            callback(this._values[k], [i, j], me);
          }
        } else {
          var values = {};
          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values[_i6] = this._values[_k2];
          }
          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values ? values[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    SparseMatrix2.prototype[Symbol.iterator] = function* () {
      if (!this._values) {
        throw new Error("Cannot iterate a Pattern only matrix");
      }
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          yield {
            value: this._values[k],
            index: [i, j]
          };
        }
      }
    };
    SparseMatrix2.prototype.toArray = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    SparseMatrix2.prototype.valueOf = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values, index, ptr, size2, copy) {
      var rows = size2[0];
      var columns = size2[1];
      var a = [];
      var i, j;
      for (i = 0; i < rows; i++) {
        a[i] = [];
        for (j = 0; j < columns; j++) {
          a[i][j] = 0;
        }
      }
      for (j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          i = index[k];
          a[i][j] = values ? copy ? clone(values[k]) : values[k] : 1;
        }
      }
      return a;
    }
    SparseMatrix2.prototype.format = function(options) {
      var rows = this._size[0];
      var columns = this._size[1];
      var density = this.density();
      var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i = this._index[k];
          str += "\n    (" + format3(i, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
        }
      }
      return str;
    };
    SparseMatrix2.prototype.toString = function() {
      return format3(this.toArray());
    };
    SparseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "SparseMatrix",
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    SparseMatrix2.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var values = [];
      var index = [];
      var ptr = [];
      ptr[0] = 0;
      for (var j = kSuper; j < columns && values.length < n; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var x = k0; x < k1; x++) {
          var i = this._index[x];
          if (i === j - kSuper + kSub) {
            values.push(this._values[x]);
            index[values.length - 1] = i - kSub;
            break;
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: [n, 1]
      });
    };
    SparseMatrix2.fromJSON = function(json) {
      return new SparseMatrix2(json);
    };
    SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
      if (!isArray(size2)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size2.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size2 = size2.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var eq = equalScalar2;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
        zero = typed2.convert(0, datatype);
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size2[0];
      var columns = size2[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i2) {
          return value[i2];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i2) {
          return value.get([i2]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      var values = [];
      var index = [];
      var ptr = [];
      for (var j = 0; j < columns; j++) {
        ptr.push(values.length);
        var i = j - kSuper;
        if (i >= 0 && i < n) {
          var v = _value(i);
          if (!eq(v, zero)) {
            index.push(i + kSub);
            values.push(v);
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index,
        ptr,
        size: [rows, columns]
      });
    };
    SparseMatrix2.prototype.swapRows = function(i, j) {
      if (!isNumber(i) || !isInteger(i) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i, this._size[0]);
      validateIndex(j, this._size[0]);
      SparseMatrix2._swapRows(i, j, this._size[1], this._values, this._index, this._ptr);
      return this;
    };
    SparseMatrix2._forEachRow = function(j, values, index, ptr, callback) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        callback(index[k], values[k]);
      }
    };
    SparseMatrix2._swapRows = function(x, y, columns, values, index, ptr) {
      for (var j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        var kx = _getValueIndex(x, k0, k1, index);
        var ky = _getValueIndex(y, k0, k1, index);
        if (kx < k1 && ky < k1 && index[kx] === x && index[ky] === y) {
          if (values) {
            var v = values[kx];
            values[kx] = values[ky];
            values[ky] = v;
          }
          continue;
        }
        if (kx < k1 && index[kx] === x && (ky >= k1 || index[ky] !== y)) {
          var vx = values ? values[kx] : void 0;
          index.splice(ky, 0, y);
          if (values) {
            values.splice(ky, 0, vx);
          }
          index.splice(ky <= kx ? kx + 1 : kx, 1);
          if (values) {
            values.splice(ky <= kx ? kx + 1 : kx, 1);
          }
          continue;
        }
        if (ky < k1 && index[ky] === y && (kx >= k1 || index[kx] !== x)) {
          var vy = values ? values[ky] : void 0;
          index.splice(kx, 0, x);
          if (values) {
            values.splice(kx, 0, vy);
          }
          index.splice(kx <= ky ? ky + 1 : ky, 1);
          if (values) {
            values.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };
    return SparseMatrix2;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/type/number.js
  var name9 = "number";
  var dependencies10 = ["typed"];
  function getNonDecimalNumberParts(input) {
    var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
      var radix = {
        "0b": 2,
        "0o": 8,
        "0x": 16
      }[nonDecimalWithRadixMatch[1]];
      var integerPart = nonDecimalWithRadixMatch[2];
      var fractionalPart = nonDecimalWithRadixMatch[3];
      return {
        input,
        radix,
        integerPart,
        fractionalPart
      };
    } else {
      return null;
    }
  }
  function makeNumberFromNonDecimalParts(parts) {
    var n = parseInt(parts.integerPart, parts.radix);
    var f = 0;
    for (var i = 0; i < parts.fractionalPart.length; i++) {
      var digitValue = parseInt(parts.fractionalPart[i], parts.radix);
      f += digitValue / Math.pow(parts.radix, i + 1);
    }
    var result = n + f;
    if (isNaN(result)) {
      throw new SyntaxError('String "' + parts.input + '" is no valid number');
    }
    return result;
  }
  var createNumber = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    var number2 = typed2("number", {
      "": function _() {
        return 0;
      },
      number: function number3(x) {
        return x;
      },
      string: function string(x) {
        if (x === "NaN")
          return NaN;
        var nonDecimalNumberParts = getNonDecimalNumberParts(x);
        if (nonDecimalNumberParts) {
          return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
        }
        var size2 = 0;
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          size2 = Number(wordSizeSuffixMatch[2]);
          x = wordSizeSuffixMatch[1];
        }
        var num = Number(x);
        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is no valid number');
        }
        if (wordSizeSuffixMatch) {
          if (num > 2 ** size2 - 1) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          if (num >= 2 ** (size2 - 1)) {
            num = num - 2 ** size2;
          }
        }
        return num;
      },
      BigNumber: function BigNumber2(x) {
        return x.toNumber();
      },
      Fraction: function Fraction3(x) {
        return x.valueOf();
      },
      Unit: function Unit(x) {
        throw new Error("Second argument with valueless unit expected");
      },
      null: function _null(x) {
        return 0;
      },
      "Unit, string | Unit": function UnitStringUnit(unit, valuelessUnit) {
        return unit.toNumber(valuelessUnit);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
    number2.fromJSON = function(json) {
      return parseFloat(json.value);
    };
    return number2;
  });

  // ../node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
  var name10 = "bignumber";
  var dependencies11 = ["typed", "BigNumber"];
  var createBignumber = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
    var {
      typed: typed2,
      BigNumber: BigNumber2
    } = _ref;
    return typed2("bignumber", {
      "": function _() {
        return new BigNumber2(0);
      },
      number: function number2(x) {
        return new BigNumber2(x + "");
      },
      string: function string(x) {
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          var size2 = wordSizeSuffixMatch[2];
          var n = BigNumber2(wordSizeSuffixMatch[1]);
          var twoPowSize = new BigNumber2(2).pow(Number(size2));
          if (n.gt(twoPowSize.sub(1))) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
          if (n.gte(twoPowSizeSubOne)) {
            return n.sub(twoPowSize);
          } else {
            return n;
          }
        }
        return new BigNumber2(x);
      },
      BigNumber: function BigNumber3(x) {
        return x;
      },
      Fraction: function Fraction3(x) {
        return new BigNumber2(x.n).div(x.d).times(x.s);
      },
      null: function _null(x) {
        return new BigNumber2(0);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/type/complex/function/complex.js
  var name11 = "complex";
  var dependencies12 = ["typed", "Complex"];
  var createComplex = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
    var {
      typed: typed2,
      Complex: Complex3
    } = _ref;
    return typed2("complex", {
      "": function _() {
        return Complex3.ZERO;
      },
      number: function number2(x) {
        return new Complex3(x, 0);
      },
      "number, number": function numberNumber(re2, im2) {
        return new Complex3(re2, im2);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
        return new Complex3(re2.toNumber(), im2.toNumber());
      },
      Fraction: function Fraction3(x) {
        return new Complex3(x.valueOf(), 0);
      },
      Complex: function Complex4(x) {
        return x.clone();
      },
      string: function string(x) {
        return Complex3(x);
      },
      null: function _null(x) {
        return Complex3(0);
      },
      Object: function Object2(x) {
        if ("re" in x && "im" in x) {
          return new Complex3(x.re, x.im);
        }
        if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
          return new Complex3(x);
        }
        throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
  var name12 = "fraction";
  var dependencies13 = ["typed", "Fraction"];
  var createFraction = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
    var {
      typed: typed2,
      Fraction: Fraction3
    } = _ref;
    return typed2("fraction", {
      number: function number2(x) {
        if (!isFinite(x) || isNaN(x)) {
          throw new Error(x + " cannot be represented as a fraction");
        }
        return new Fraction3(x);
      },
      string: function string(x) {
        return new Fraction3(x);
      },
      "number, number": function numberNumber(numerator, denominator) {
        return new Fraction3(numerator, denominator);
      },
      null: function _null(x) {
        return new Fraction3(0);
      },
      BigNumber: function BigNumber2(x) {
        return new Fraction3(x.toString());
      },
      Fraction: function Fraction4(x) {
        return x;
      },
      Object: function Object2(x) {
        return new Fraction3(x);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
  var name13 = "matrix";
  var dependencies14 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
  var createMatrix = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
    var {
      typed: typed2,
      Matrix: Matrix2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed2(name13, {
      "": function _() {
        return _create([]);
      },
      string: function string(format4) {
        return _create([], format4);
      },
      "string, string": function stringString(format4, datatype) {
        return _create([], format4, datatype);
      },
      Array: function Array2(data) {
        return _create(data);
      },
      Matrix: function Matrix3(data) {
        return _create(data, data.storage());
      },
      "Array | Matrix, string": _create,
      "Array | Matrix, string, string": _create
    });
    function _create(data, format4, datatype) {
      if (format4 === "dense" || format4 === "default" || format4 === void 0) {
        return new DenseMatrix2(data, datatype);
      }
      if (format4 === "sparse") {
        return new SparseMatrix2(data, datatype);
      }
      throw new TypeError("Unknown matrix type " + JSON.stringify(format4) + ".");
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
  var name14 = "matrixFromColumns";
  var dependencies15 = ["typed", "matrix", "flatten", "size"];
  var createMatrixFromColumns = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      flatten: flatten3,
      size: size2
    } = _ref;
    return typed2(name14, {
      "...Array": function Array2(arr) {
        return _createArray(arr);
      },
      "...Matrix": function Matrix2(arr) {
        return matrix2(_createArray(arr.map((m) => m.toArray())));
      }
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError("At least one column is needed to construct a matrix.");
      var N = checkVectorTypeAndReturnLength(arr[0]);
      var result = [];
      for (var i = 0; i < N; i++) {
        result[i] = [];
      }
      for (var col of arr) {
        var colLength = checkVectorTypeAndReturnLength(col);
        if (colLength !== N) {
          throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
        }
        var f = flatten3(col);
        for (var _i = 0; _i < N; _i++) {
          result[_i].push(f[_i]);
        }
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      var s = size2(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError("Only one- or two-dimensional vectors are supported.");
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
  var name15 = "unaryMinus";
  var dependencies16 = ["typed"];
  var createUnaryMinus = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name15, {
      number: unaryMinusNumber,
      Complex: function Complex3(x) {
        return x.neg();
      },
      BigNumber: function BigNumber2(x) {
        return x.neg();
      },
      Fraction: function Fraction3(x) {
        return x.neg();
      },
      Unit: function Unit(x) {
        var res = x.clone();
        res.value = this(x.value);
        return res;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/abs.js
  var name16 = "abs";
  var dependencies17 = ["typed"];
  var createAbs = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name16, {
      number: absNumber,
      Complex: function Complex3(x) {
        return x.abs();
      },
      BigNumber: function BigNumber2(x) {
        return x.abs();
      },
      Fraction: function Fraction3(x) {
        return x.abs();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.abs();
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
  var name17 = "addScalar";
  var dependencies18 = ["typed"];
  var createAddScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name17, {
      "number, number": addNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.add(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.plus(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.add(y);
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (x.value === null || x.value === void 0)
          throw new Error("Parameter x contains a unit with undefined value");
        if (y.value === null || y.value === void 0)
          throw new Error("Parameter y contains a unit with undefined value");
        if (!x.equalBase(y))
          throw new Error("Units do not match");
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm11.js
  var name18 = "algorithm11";
  var dependencies19 = ["typed", "equalScalar"];
  var createAlgorithm11 = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2
    } = _ref;
    return function algorithm11(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var i = aindex[k];
          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
          if (!eq(v, zero)) {
            cindex.push(i);
            cvalues.push(v);
          }
        }
      }
      cptr[columns] = cindex.length;
      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm12.js
  var name19 = "algorithm12";
  var dependencies20 = ["typed", "DenseMatrix"];
  var createAlgorithm12 = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
    var {
      typed: typed2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function algorithm12(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (var i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      }
      return new DenseMatrix2({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm14.js
  var name20 = "algorithm14";
  var dependencies21 = ["typed"];
  var createAlgorithm14 = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return function algorithm14(a, b, callback, inverse) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv, inverse) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = inverse ? f(bv, av[i]) : f(av[i], bv);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm01.js
  var name21 = "algorithm01";
  var dependencies22 = ["typed"];
  var createAlgorithm01 = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
      var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
      var i, j;
      var cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      var x = [];
      var w = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (i = 0; i < rows; i++) {
          if (w[i] === mark) {
            cdata[i][j] = x[i];
          } else {
            cdata[i][j] = adata[i][j];
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm04.js
  var name22 = "algorithm04";
  var dependencies23 = ["typed", "equalScalar"];
  var createAlgorithm04 = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2
    } = _ref;
    return function algorithm04(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = avalues && bvalues ? [] : void 0;
      var xb = avalues && bvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa) {
            xa[i] = avalues[k];
          }
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i = bindex[k];
          if (wa[i] === mark) {
            if (xa) {
              var v = cf(xa[i], bvalues[k]);
              if (!eq(v, zero)) {
                xa[i] = v;
              } else {
                wa[i] = null;
              }
            }
          } else {
            cindex.push(i);
            wb[i] = mark;
            if (xb) {
              xb[i] = bvalues[k];
            }
          }
        }
        if (xa && xb) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            if (wa[i] === mark) {
              cvalues[k] = xa[i];
              k++;
            } else if (wb[i] === mark) {
              cvalues[k] = xb[i];
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm10.js
  var name23 = "algorithm10";
  var dependencies24 = ["typed", "DenseMatrix"];
  var createAlgorithm10 = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
    var {
      typed: typed2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function algorithm10(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed2.convert(b, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w[r] = mark;
        }
        for (var i = 0; i < rows; i++) {
          if (j === 0) {
            cdata[i] = [];
          }
          if (w[i] === mark) {
            cdata[i][j] = inverse ? cf(b, x[i]) : cf(x[i], b);
          } else {
            cdata[i][j] = b;
          }
        }
      }
      return new DenseMatrix2({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm13.js
  var name24 = "algorithm13";
  var dependencies25 = ["typed"];
  var createAlgorithm13 = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return function algorithm13(a, b, callback) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var csize = [];
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      for (var s = 0; s < asize.length; s++) {
        if (asize[s] !== bsize[s]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        csize[s] = asize[s];
      }
      var dt;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        cf = typed2.find(callback, [dt, dt]);
      }
      var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i = 0; i < n; i++) {
          cv[i] = f(av[i], bv[i]);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }
      return cv;
    }
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm03.js
  var name25 = "algorithm03";
  var dependencies26 = ["typed"];
  var createAlgorithm03 = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return function algorithm03(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cdata = [];
      for (var z = 0; z < rows; z++) {
        cdata[z] = [];
      }
      var x = [];
      var w = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i = bindex[k];
          x[i] = inverse ? cf(bvalues[k], adata[i][j]) : cf(adata[i][j], bvalues[k]);
          w[i] = mark;
        }
        for (var y = 0; y < rows; y++) {
          if (w[y] === mark) {
            cdata[y][j] = x[y];
          } else {
            cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm05.js
  var name26 = "algorithm05";
  var dependencies27 = ["typed", "equalScalar"];
  var createAlgorithm05 = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2
    } = _ref;
    return function algorithm05(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = cvalues ? [] : void 0;
      var xb = cvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i, j, k, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          i = aindex[k];
          cindex.push(i);
          wa[i] = mark;
          if (xa) {
            xa[i] = avalues[k];
          }
        }
        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          i = bindex[k];
          if (wa[i] !== mark) {
            cindex.push(i);
          }
          wb[i] = mark;
          if (xb) {
            xb[i] = bvalues[k];
          }
        }
        if (cvalues) {
          k = cptr[j];
          while (k < cindex.length) {
            i = cindex[k];
            var wai = wa[i];
            var wbi = wb[i];
            if (wai === mark || wbi === mark) {
              var va = wai === mark ? xa[i] : zero;
              var vb = wbi === mark ? xb[i] : zero;
              var vc = cf(va, vb);
              if (!eq(vc, zero)) {
                cvalues.push(vc);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
  var name27 = "multiplyScalar";
  var dependencies28 = ["typed"];
  var createMultiplyScalar = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2("multiplyScalar", {
      "number, number": multiplyNumber,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.mul(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.times(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.mul(y);
      },
      "number | Fraction | BigNumber | Complex, Unit": function numberFractionBigNumberComplexUnit(x, y) {
        var res = y.clone();
        res.value = res.value === null ? res._normalize(x) : this(res.value, x);
        return res;
      },
      "Unit, number | Fraction | BigNumber | Complex": function UnitNumberFractionBigNumberComplex(x, y) {
        var res = x.clone();
        res.value = res.value === null ? res._normalize(y) : this(res.value, y);
        return res;
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return x.multiply(y);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
  var name28 = "multiply";
  var dependencies29 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
  var createMultiply = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      equalScalar: equalScalar2,
      dot: dot2
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed: typed2,
      equalScalar: equalScalar2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    function _validateMatrixDimensions(size1, size2) {
      switch (size1.length) {
        case 1:
          switch (size2.length) {
            case 1:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
              }
              break;
            case 2:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        case 2:
          switch (size2.length) {
            case 1:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
              }
              break;
            case 2:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        default:
          throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
      }
    }
    function _multiplyVectorVector(a, b, n) {
      if (n === 0) {
        throw new Error("Cannot multiply two empty vectors");
      }
      return dot2(a, b);
    }
    function _multiplyVectorMatrix(a, b) {
      if (b.storage() !== "dense") {
        throw new Error("Support for SparseMatrix not implemented");
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    function _multiplyVectorDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var alength = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(adata[0], bdata[0][j]);
        for (var i = 1; i < alength; i++) {
          sum2 = af(sum2, mf(adata[i], bdata[i][j]));
        }
        c[j] = sum2;
      }
      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: dt
      });
    }
    var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
      "DenseMatrix, any": _multiplyDenseMatrixVector,
      "SparseMatrix, any": _multiplySparseMatrixVector
    });
    var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
      "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
      "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
      "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
      "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
    });
    function _multiplyDenseMatrixVector(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        var sum2 = mf(row[0], bdata[0]);
        for (var j = 1; j < acolumns; j++) {
          sum2 = af(sum2, mf(row[j], bdata[j]));
        }
        c[i] = sum2;
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var i = 0; i < arows; i++) {
        var row = adata[i];
        c[i] = [];
        for (var j = 0; j < bcolumns; j++) {
          var sum2 = mf(row[0], bdata[0][j]);
          for (var x = 1; x < acolumns; x++) {
            sum2 = af(sum2, mf(row[x], bdata[x][j]));
          }
          c[i][j] = sum2;
        }
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixSparseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (!bvalues) {
        throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
      }
      var arows = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1];
        if (kb1 > kb0) {
          var last = 0;
          for (var i = 0; i < arows; i++) {
            var mark = i + 1;
            var cij = void 0;
            for (var kb = kb0; kb < kb1; kb++) {
              var ib = bindex[kb];
              if (last !== mark) {
                cij = mf(adata[i][ib], bvalues[kb]);
                last = mark;
              } else {
                cij = af(cij, mf(adata[i][ib], bvalues[kb]));
              }
            }
            if (last === mark && !eq(cij, zero)) {
              cindex.push(i);
              cvalues.push(cij);
            }
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixVector(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      var x = [];
      var w = [];
      cptr[0] = 0;
      for (var ib = 0; ib < brows; ib++) {
        var vbi = bdata[ib];
        if (!eq(vbi, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (!w[ia]) {
              w[ia] = true;
              cindex.push(ia);
              x[ia] = mf(vbi, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      }
      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
      cptr[1] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: dt
      });
    }
    function _multiplySparseMatrixDenseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
        eq = typed2.find(equalScalar2, [dt, dt]);
        zero = typed2.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = [];
      var w = [];
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (var ib = 0; ib < brows; ib++) {
          var vbij = bdata[ib][jb];
          if (!eq(vbij, zero)) {
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              var ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(vbij, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        }
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixSparseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype;
      var arows = a._size[0];
      var bcolumns = b._size[1];
      var values = avalues && bvalues;
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed2.find(addScalar2, [dt, dt]);
        mf = typed2.find(multiplyScalar2, [dt, dt]);
      }
      var cvalues = values ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = values ? [] : void 0;
      var w = [];
      var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          ib = bindex[kb];
          if (values) {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w[ia] !== mark) {
                w[ia] = mark;
                cindex.push(ia);
              }
            }
          }
        }
        if (values) {
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    return typed2(name28, extend({
      "Array, Array": function ArrayArray(x, y) {
        _validateMatrixDimensions(arraySize(x), arraySize(y));
        var m = this(matrix2(x), matrix2(y));
        return isMatrix(m) ? m.valueOf() : m;
      },
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        var xsize = x.size();
        var ysize = y.size();
        _validateMatrixDimensions(xsize, ysize);
        if (xsize.length === 1) {
          if (ysize.length === 1) {
            return _multiplyVectorVector(x, y, xsize[0]);
          }
          return _multiplyVectorMatrix(x, y);
        }
        if (ysize.length === 1) {
          return _multiplyMatrixVector(x, y);
        }
        return _multiplyMatrixMatrix(x, y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x, y.storage()), y);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, multiplyScalar2, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, multiplyScalar2, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm11(y, x, multiplyScalar2, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, multiplyScalar2, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, multiplyScalar2, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, multiplyScalar2, true).valueOf();
      },
      "any, any": multiplyScalar2,
      "any, any, ...any": function anyAnyAny(x, y, rest) {
        var result = this(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }
        return result;
      }
    }, multiplyScalar2.signatures));
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/sign.js
  var name29 = "sign";
  var dependencies30 = ["typed", "BigNumber", "Fraction", "complex"];
  var createSign = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
    var {
      typed: typed2,
      BigNumber: _BigNumber,
      complex: complex2,
      Fraction: _Fraction
    } = _ref;
    return typed2(name29, {
      number: signNumber,
      Complex: function Complex3(x) {
        return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(x.cmp(0));
      },
      Fraction: function Fraction3(x) {
        return new _Fraction(x.s, 1);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        if (!x._isDerived() && x.units[0].unit.offset !== 0) {
          throw new TypeError("sign is ambiguous for units with offset");
        }
        return this(x.value);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
  var name30 = "sqrt";
  var dependencies31 = ["config", "typed", "Complex"];
  var createSqrt = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
    var {
      config: config4,
      typed: typed2,
      Complex: Complex3
    } = _ref;
    return typed2("sqrt", {
      number: _sqrtNumber,
      Complex: function Complex4(x) {
        return x.sqrt();
      },
      BigNumber: function BigNumber2(x) {
        if (!x.isNegative() || config4.predictable) {
          return x.sqrt();
        } else {
          return _sqrtNumber(x.toNumber());
        }
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      },
      Unit: function Unit(x) {
        return x.pow(0.5);
      }
    });
    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config4.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex3(x, 0).sqrt();
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
  var name31 = "subtract";
  var dependencies32 = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
  var createSubtract = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      equalScalar: equalScalar2,
      addScalar: addScalar2,
      unaryMinus: unaryMinus2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed: typed2
    });
    var algorithm03 = createAlgorithm03({
      typed: typed2
    });
    var algorithm05 = createAlgorithm05({
      typed: typed2,
      equalScalar: equalScalar2
    });
    var algorithm10 = createAlgorithm10({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name31, {
      "number, number": function numberNumber(x, y) {
        return x - y;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.sub(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.minus(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.sub(y);
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (x.value === null) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y.value === null) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y)) {
          throw new Error("Units do not match");
        }
        var res = x.clone();
        res.value = this(res.value, y.value);
        res.fixPrefix = false;
        return res;
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm05(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm01(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        checkEqualDimensions(x, y);
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm10(x, unaryMinus2(y), addScalar2);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm10(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, this, true).valueOf();
      }
    });
  });
  function checkEqualDimensions(x, y) {
    var xsize = x.size();
    var ysize = y.size();
    if (xsize.length !== ysize.length) {
      throw new DimensionError(xsize.length, ysize.length);
    }
  }

  // ../node_modules/mathjs/lib/esm/type/matrix/utils/algorithm07.js
  var name32 = "algorithm07";
  var dependencies33 = ["typed", "DenseMatrix"];
  var createAlgorithm07 = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
    var {
      typed: typed2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function algorithm07(a, b, callback) {
      var asize = a._size;
      var adt = a._datatype;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed2.convert(0, dt);
        cf = typed2.find(callback, [dt, dt]);
      }
      var i, j;
      var cdata = [];
      for (i = 0; i < rows; i++) {
        cdata[i] = [];
      }
      var xa = [];
      var xb = [];
      var wa = [];
      var wb = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        _scatter(a, j, wa, xa, mark);
        _scatter(b, j, wb, xb, mark);
        for (i = 0; i < rows; i++) {
          var va = wa[i] === mark ? xa[i] : zero;
          var vb = wb[i] === mark ? xb[i] : zero;
          cdata[i][j] = cf(va, vb);
        }
      }
      return new DenseMatrix2({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
    function _scatter(m, j, w, x, mark) {
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        var i = index[k];
        w[i] = mark;
        x[i] = values[k];
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/complex/conj.js
  var name33 = "conj";
  var dependencies34 = ["typed"];
  var createConj = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name33, {
      number: function number2(x) {
        return x;
      },
      BigNumber: function BigNumber2(x) {
        return x;
      },
      Complex: function Complex3(x) {
        return x.conjugate();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/complex/im.js
  var name34 = "im";
  var dependencies35 = ["typed"];
  var createIm = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name34, {
      number: function number2(x) {
        return 0;
      },
      BigNumber: function BigNumber2(x) {
        return x.mul(0);
      },
      Fraction: function Fraction3(x) {
        return x.mul(0);
      },
      Complex: function Complex3(x) {
        return x.im;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/complex/re.js
  var name35 = "re";
  var dependencies36 = ["typed"];
  var createRe = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name35, {
      number: function number2(x) {
        return x;
      },
      BigNumber: function BigNumber2(x) {
        return x;
      },
      Fraction: function Fraction3(x) {
        return x;
      },
      Complex: function Complex3(x) {
        return x.re;
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/column.js
  var name36 = "column";
  var dependencies37 = ["typed", "Index", "matrix", "range"];
  var createColumn = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
    var {
      typed: typed2,
      Index: Index2,
      matrix: matrix2,
      range: range2
    } = _ref;
    return typed2(name36, {
      "Matrix, number": _column,
      "Array, number": function ArrayNumber(value, column2) {
        return _column(matrix2(clone(value)), column2).valueOf();
      }
    });
    function _column(value, column2) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(column2, value.size()[1]);
      var rowRange = range2(0, value.size()[0]);
      var index = new Index2(rowRange, column2);
      return value.subset(index);
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/cross.js
  var name37 = "cross";
  var dependencies38 = ["typed", "matrix", "subtract", "multiply"];
  var createCross = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      subtract: subtract2,
      multiply: multiply2
    } = _ref;
    return typed2(name37, {
      "Matrix, Matrix": function MatrixMatrix(x, y) {
        return matrix2(_cross(x.toArray(), y.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return matrix2(_cross(x.toArray(), y));
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return matrix2(_cross(x, y.toArray()));
      },
      "Array, Array": _cross
    });
    function _cross(x, y) {
      var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
      x = squeeze(x);
      y = squeeze(y);
      var xSize = arraySize(x);
      var ySize = arraySize(y);
      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
      }
      var product2 = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
      if (highestDimension > 1) {
        return [product2];
      } else {
        return product2;
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/diag.js
  var name38 = "diag";
  var dependencies39 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
  var createDiag = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed2(name38, {
      Array: function Array2(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      "Array, number": function ArrayNumber(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      "Array, BigNumber": function ArrayBigNumber(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      "Array, string": function ArrayString(x, format4) {
        return _diag(x, 0, arraySize(x), format4);
      },
      "Array, number, string": function ArrayNumberString(x, k, format4) {
        return _diag(x, k, arraySize(x), format4);
      },
      "Array, BigNumber, string": function ArrayBigNumberString(x, k, format4) {
        return _diag(x, k.toNumber(), arraySize(x), format4);
      },
      Matrix: function Matrix2(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      "Matrix, number": function MatrixNumber(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      "Matrix, BigNumber": function MatrixBigNumber(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      "Matrix, string": function MatrixString(x, format4) {
        return _diag(x, 0, x.size(), format4);
      },
      "Matrix, number, string": function MatrixNumberString(x, k, format4) {
        return _diag(x, k, x.size(), format4);
      },
      "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format4) {
        return _diag(x, k.toNumber(), x.size(), format4);
      }
    });
    function _diag(x, k, size2, format4) {
      if (!isInteger(k)) {
        throw new TypeError("Second parameter in function diag must be an integer");
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      switch (size2.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format4, size2[0], kSub, kSuper);
        case 2:
          return _getDiagonal(x, k, format4, size2, kSub, kSuper);
      }
      throw new RangeError("Matrix for function diag must be 2 dimensional");
    }
    function _createDiagonalMatrix(x, k, format4, l, kSub, kSuper) {
      var ms = [l + kSub, l + kSuper];
      if (format4 && format4 !== "sparse" && format4 !== "dense") {
        throw new TypeError("Unknown matrix type ".concat(format4, '"'));
      }
      var m = format4 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
      return format4 !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format4, s, kSub, kSuper) {
      if (isMatrix(x)) {
        var dm = x.diagonal(k);
        if (format4 !== null) {
          if (format4 !== dm.storage()) {
            return matrix2(dm, format4);
          }
          return dm;
        }
        return dm.valueOf();
      }
      var n = Math.min(s[0] - kSub, s[1] - kSuper);
      var vector = [];
      for (var i = 0; i < n; i++) {
        vector[i] = x[i + kSub][i + kSuper];
      }
      return format4 !== null ? matrix2(vector) : vector;
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/flatten.js
  var name39 = "flatten";
  var dependencies40 = ["typed", "matrix"];
  var createFlatten = /* @__PURE__ */ factory(name39, dependencies40, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2
    } = _ref;
    return typed2(name39, {
      Array: function Array2(x) {
        return flatten(clone(x));
      },
      Matrix: function Matrix2(x) {
        var flat = flatten(clone(x.toArray()));
        return matrix2(flat);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/identity.js
  var name40 = "identity";
  var dependencies41 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
  var createIdentity = /* @__PURE__ */ factory(name40, dependencies41, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      BigNumber: BigNumber2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed2(name40, {
      "": function _() {
        return config4.matrix === "Matrix" ? matrix2([]) : [];
      },
      string: function string(format4) {
        return matrix2(format4);
      },
      "number | BigNumber": function numberBigNumber(rows) {
        return _identity(rows, rows, config4.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, string": function numberBigNumberString(rows, format4) {
        return _identity(rows, rows, format4);
      },
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
        return _identity(rows, cols, config4.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format4) {
        return _identity(rows, cols, format4);
      },
      Array: function Array2(size2) {
        return _identityVector(size2);
      },
      "Array, string": function ArrayString(size2, format4) {
        return _identityVector(size2, format4);
      },
      Matrix: function Matrix2(size2) {
        return _identityVector(size2.valueOf(), size2.storage());
      },
      "Matrix, string": function MatrixString(size2, format4) {
        return _identityVector(size2.valueOf(), format4);
      }
    });
    function _identityVector(size2, format4) {
      switch (size2.length) {
        case 0:
          return format4 ? matrix2(format4) : [];
        case 1:
          return _identity(size2[0], size2[0], format4);
        case 2:
          return _identity(size2[0], size2[1], format4);
        default:
          throw new Error("Vector containing two values expected");
      }
    }
    function _identity(rows, cols, format4) {
      var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
      if (isBigNumber(rows))
        rows = rows.toNumber();
      if (isBigNumber(cols))
        cols = cols.toNumber();
      if (!isInteger(rows) || rows < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      if (!isInteger(cols) || cols < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      var one = Big ? new BigNumber2(1) : 1;
      var defaultValue = Big ? new Big(0) : 0;
      var size2 = [rows, cols];
      if (format4) {
        if (format4 === "sparse") {
          return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
        }
        if (format4 === "dense") {
          return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
        }
        throw new TypeError('Unknown matrix type "'.concat(format4, '"'));
      }
      var res = resize([], size2, defaultValue);
      var minimum = rows < cols ? rows : cols;
      for (var d = 0; d < minimum; d++) {
        res[d][d] = one;
      }
      return res;
    }
  });

  // ../node_modules/mathjs/lib/esm/utils/noop.js
  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  // ../node_modules/mathjs/lib/esm/function/matrix/range.js
  var name41 = "range";
  var dependencies42 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
  var createRange = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      bignumber: bignumber2,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2,
      largerEq: largerEq2
    } = _ref;
    return typed2(name41, {
      string: _strRange,
      "string, boolean": _strRange,
      "number, number": function numberNumber(start, end) {
        return _out(_rangeEx(start, end, 1));
      },
      "number, number, number": function numberNumberNumber(start, end, step) {
        return _out(_rangeEx(start, end, step));
      },
      "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, 1)) : _out(_rangeEx(start, end, 1));
      },
      "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_rangeInc(start, end, step)) : _out(_rangeEx(start, end, step));
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
        var BigNumber2 = start.constructor;
        return _out(_bigRangeEx(start, end, new BigNumber2(1)));
      },
      "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
        return _out(_bigRangeEx(start, end, step));
      },
      "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
        var BigNumber2 = start.constructor;
        return includeEnd ? _out(_bigRangeInc(start, end, new BigNumber2(1))) : _out(_bigRangeEx(start, end, new BigNumber2(1)));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
        return includeEnd ? _out(_bigRangeInc(start, end, step)) : _out(_bigRangeEx(start, end, step));
      }
    });
    function _out(arr) {
      if (config4.matrix === "Matrix") {
        return matrix2 ? matrix2(arr) : noMatrix();
      }
      return arr;
    }
    function _strRange(str, includeEnd) {
      var r = _parse(str);
      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }
      var fn;
      if (config4.number === "BigNumber") {
        if (bignumber2 === void 0) {
          noBignumber();
        }
        fn = includeEnd ? _bigRangeInc : _bigRangeEx;
        return _out(fn(bignumber2(r.start), bignumber2(r.end), bignumber2(r.step)));
      } else {
        fn = includeEnd ? _rangeInc : _rangeEx;
        return _out(fn(r.start, r.end, r.step));
      }
    }
    function _rangeEx(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smaller2(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (larger2(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    function _rangeInc(start, end, step) {
      var array = [];
      var x = start;
      if (step > 0) {
        while (smallerEq2(x, end)) {
          array.push(x);
          x += step;
        }
      } else if (step < 0) {
        while (largerEq2(x, end)) {
          array.push(x);
          x += step;
        }
      }
      return array;
    }
    function _bigRangeEx(start, end, step) {
      var zero = bignumber2(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smaller2(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (larger2(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    function _bigRangeInc(start, end, step) {
      var zero = bignumber2(0);
      var array = [];
      var x = start;
      if (step.gt(zero)) {
        while (smallerEq2(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      } else if (step.lt(zero)) {
        while (largerEq2(x, end)) {
          array.push(x);
          x = x.plus(step);
        }
      }
      return array;
    }
    function _parse(str) {
      var args = str.split(":");
      var nums = args.map(function(arg) {
        return Number(arg);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };
        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };
        default:
          return null;
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/size.js
  var name42 = "size";
  var dependencies43 = ["typed", "config", "?matrix"];
  var createSize = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2
    } = _ref;
    return typed2(name42, {
      Matrix: function Matrix2(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string(x) {
        return config4.matrix === "Array" ? [x.length] : matrix2([x.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
        return config4.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/transpose.js
  var name43 = "transpose";
  var dependencies44 = ["typed", "matrix"];
  var createTranspose = /* @__PURE__ */ factory(name43, dependencies44, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2
    } = _ref;
    return typed2("transpose", {
      Array: function Array2(x) {
        return this(matrix2(x)).valueOf();
      },
      Matrix: function Matrix2(x) {
        var size2 = x.size();
        var c;
        switch (size2.length) {
          case 1:
            c = x.clone();
            break;
          case 2:
            {
              var rows = size2[0];
              var columns = size2[1];
              if (columns === 0) {
                throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size2) + ")");
              }
              switch (x.storage()) {
                case "dense":
                  c = _denseTranspose(x, rows, columns);
                  break;
                case "sparse":
                  c = _sparseTranspose(x, rows, columns);
                  break;
              }
            }
            break;
          default:
            throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(this._size) + ")");
        }
        return c;
      },
      any: function any(x) {
        return clone(x);
      }
    });
    function _denseTranspose(m, rows, columns) {
      var data = m._data;
      var transposed = [];
      var transposedRow;
      for (var j = 0; j < columns; j++) {
        transposedRow = transposed[j] = [];
        for (var i = 0; i < rows; i++) {
          transposedRow[i] = clone(data[i][j]);
        }
      }
      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
    function _sparseTranspose(m, rows, columns) {
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var cvalues = values ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var w = [];
      for (var x = 0; x < rows; x++) {
        w[x] = 0;
      }
      var p, l, j;
      for (p = 0, l = index.length; p < l; p++) {
        w[index[p]]++;
      }
      var sum2 = 0;
      for (var i = 0; i < rows; i++) {
        cptr.push(sum2);
        sum2 += w[i];
        w[i] = cptr[i];
      }
      cptr.push(sum2);
      for (j = 0; j < columns; j++) {
        for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          var q = w[index[k]]++;
          cindex[q] = j;
          if (values) {
            cvalues[q] = clone(values[k]);
          }
        }
      }
      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
  var name44 = "ctranspose";
  var dependencies45 = ["typed", "transpose", "conj"];
  var createCtranspose = /* @__PURE__ */ factory(name44, dependencies45, (_ref) => {
    var {
      typed: typed2,
      transpose: transpose2,
      conj: conj2
    } = _ref;
    return typed2(name44, {
      any: function any(x) {
        return conj2(transpose2(x));
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/zeros.js
  var name45 = "zeros";
  var dependencies46 = ["typed", "config", "matrix", "BigNumber"];
  var createZeros = /* @__PURE__ */ factory(name45, dependencies46, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      BigNumber: BigNumber2
    } = _ref;
    return typed2(name45, {
      "": function _() {
        return config4.matrix === "Array" ? _zeros([]) : _zeros([], "default");
      },
      "...number | BigNumber | string": function numberBigNumberString(size2) {
        var last = size2[size2.length - 1];
        if (typeof last === "string") {
          var format4 = size2.pop();
          return _zeros(size2, format4);
        } else if (config4.matrix === "Array") {
          return _zeros(size2);
        } else {
          return _zeros(size2, "default");
        }
      },
      Array: _zeros,
      Matrix: function Matrix2(size2) {
        var format4 = size2.storage();
        return _zeros(size2.valueOf(), format4);
      },
      "Array | Matrix, string": function ArrayMatrixString(size2, format4) {
        return _zeros(size2.valueOf(), format4);
      }
    });
    function _zeros(size2, format4) {
      var hasBigNumbers = _normalize(size2);
      var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
      _validate2(size2);
      if (format4) {
        var m = matrix2(format4);
        if (size2.length > 0) {
          return m.resize(size2, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size2.length > 0) {
          return resize(arr, size2, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size2) {
      var hasBigNumbers = false;
      size2.forEach(function(value, index, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size2) {
      size2.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function zeros must be positive integers");
        }
      });
    }
  });

  // ../node_modules/mathjs/lib/esm/function/utils/numeric.js
  var name46 = "numeric";
  var dependencies47 = ["number", "?bignumber", "?fraction"];
  var createNumeric = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
    var {
      number: _number,
      bignumber: bignumber2,
      fraction: fraction2
    } = _ref;
    var validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    };
    var validOutputTypes = {
      number: (x) => _number(x),
      BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
      Fraction: fraction2 ? (x) => fraction2(x) : noFraction
    };
    return function numeric2(value, outputType) {
      var inputType = typeOf(value);
      if (!(inputType in validInputTypes)) {
        throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
      }
      if (!(outputType in validOutputTypes)) {
        throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
      }
      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
  var name47 = "divideScalar";
  var dependencies48 = ["typed", "numeric"];
  var createDivideScalar = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
    var {
      typed: typed2,
      numeric: numeric2
    } = _ref;
    return typed2(name47, {
      "number, number": function numberNumber(x, y) {
        return x / y;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.div(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.div(y);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.div(y);
      },
      "Unit, number | Fraction | BigNumber": function UnitNumberFractionBigNumber(x, y) {
        var res = x.clone();
        var one = numeric2(1, typeOf(y));
        res.value = this(res.value === null ? res._normalize(one) : res.value, y);
        return res;
      },
      "number | Fraction | BigNumber, Unit": function numberFractionBigNumberUnit(x, y) {
        var res = y.clone();
        res = res.pow(-1);
        var one = numeric2(1, typeOf(x));
        res.value = this(x, y.value === null ? y._normalize(one) : y.value);
        return res;
      },
      "Unit, Unit": function UnitUnit(x, y) {
        return x.divide(y);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/pow.js
  var name48 = "pow";
  var dependencies49 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
  var createPow = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      identity: identity2,
      multiply: multiply2,
      matrix: matrix2,
      inv: inv2,
      number: number2,
      fraction: fraction2,
      Complex: Complex3
    } = _ref;
    return typed2(name48, {
      "number, number": _pow,
      "Complex, Complex": function ComplexComplex(x, y) {
        return x.pow(y);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        if (y.isInteger() || x >= 0 || config4.predictable) {
          return x.pow(y);
        } else {
          return new Complex3(x.toNumber(), 0).pow(y.toNumber(), 0);
        }
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        var result = x.pow(y);
        if (result != null) {
          return result;
        }
        if (config4.predictable) {
          throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
        } else {
          return _pow(x.valueOf(), y.valueOf());
        }
      },
      "Array, number": _powArray,
      "Array, BigNumber": function ArrayBigNumber(x, y) {
        return _powArray(x, y.toNumber());
      },
      "Matrix, number": _powMatrix,
      "Matrix, BigNumber": function MatrixBigNumber(x, y) {
        return _powMatrix(x, y.toNumber());
      },
      "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
        return x.pow(y);
      }
    });
    function _pow(x, y) {
      if (config4.predictable && !isInteger(y) && x < 0) {
        try {
          var yFrac = fraction2(y);
          var yNum = number2(yFrac);
          if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
            if (yFrac.d % 2 === 1) {
              return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
            }
          }
        } catch (ex) {
        }
      }
      if (config4.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
        return NaN;
      }
      if (isInteger(y) || x >= 0 || config4.predictable) {
        return powNumber(x, y);
      } else {
        if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
          return 0;
        }
        return new Complex3(x, 0).pow(y, 0);
      }
    }
    function _powArray(x, y) {
      if (!isInteger(y)) {
        throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
      }
      var s = arraySize(x);
      if (s.length !== 2) {
        throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
      }
      if (s[0] !== s[1]) {
        throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
      }
      if (y < 0) {
        try {
          return _powArray(inv2(x), -y);
        } catch (error) {
          if (error.message === "Cannot calculate inverse, determinant is zero") {
            throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
          }
          throw error;
        }
      }
      var res = identity2(s[0]).valueOf();
      var px = x;
      while (y >= 1) {
        if ((y & 1) === 1) {
          res = multiply2(px, res);
        }
        y >>= 1;
        px = multiply2(px, px);
      }
      return res;
    }
    function _powMatrix(x, y) {
      return matrix2(_powArray(x.valueOf(), y));
    }
  });

  // ../node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
  function createSolveValidation(_ref) {
    var {
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function solveValidation(m, b, copy) {
      var mSize = m.size();
      if (mSize.length !== 2) {
        throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
      }
      var rows = mSize[0];
      var columns = mSize[1];
      if (rows !== columns) {
        throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
      }
      var data = [];
      if (isMatrix(b)) {
        var bSize = b.size();
        var bdata = b._data;
        if (bSize.length === 1) {
          if (bSize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var i = 0; i < rows; i++) {
            data[i] = [bdata[i]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
        if (bSize.length === 2) {
          if (bSize[0] !== rows || bSize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          if (isDenseMatrix(b)) {
            if (copy) {
              data = [];
              for (var _i = 0; _i < rows; _i++) {
                data[_i] = [bdata[_i][0]];
              }
              return new DenseMatrix2({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
            return b;
          }
          if (isSparseMatrix(b)) {
            for (var _i2 = 0; _i2 < rows; _i2++) {
              data[_i2] = [0];
            }
            var values = b._values;
            var index = b._index;
            var ptr = b._ptr;
            for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
              var _i3 = index[k];
              data[_i3][0] = values[k];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
      if (isArray(b)) {
        var bsize = arraySize(b);
        if (bsize.length === 1) {
          if (bsize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i4 = 0; _i4 < rows; _i4++) {
            data[_i4] = [b[_i4]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1]
          });
        }
        if (bsize.length === 2) {
          if (bsize[0] !== rows || bsize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i5 = 0; _i5 < rows; _i5++) {
            data[_i5] = [b[_i5][0]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1]
          });
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
    };
  }

  // ../node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
  var name49 = "usolve";
  var dependencies50 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createUsolve = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtract: subtract2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed2(name49, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix2(a);
        var r = _denseBackwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar2(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar2(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar2(bj, vjj);
          for (var i = j - 1; i >= 0; i--) {
            bdata[i] = [subtract2(bdata[i][0] || 0, multiplyScalar2(xj, mdata[i][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix2({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar2(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = lastIndex - 1; k >= firstIndex; k--) {
            var i = index[k];
            if (i === j) {
              vjj = values[k];
            } else if (i < j) {
              jValues.push(values[k]);
              jIndices.push(i);
            }
          }
          if (equalScalar2(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar2(bj, vjj);
          for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtract2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix2({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // ../node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
  var name50 = "usolveAll";
  var dependencies51 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
  var createUsolveAll = /* @__PURE__ */ factory(name50, dependencies51, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtract: subtract2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed2(name50, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix2(a);
        var R = _denseBackwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseBackwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e) => e[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          if (!equalScalar2(M[i][i], 0)) {
            b[i] = divideScalar2(b[i], M[i][i]);
            for (var j = i - 1; j >= 0; j--) {
              b[j] = subtract2(b[j], multiplyScalar2(b[i], M[j][i]));
            }
          } else if (!equalScalar2(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j = i - 1; _j >= 0; _j--) {
              bNew[_j] = subtract2(bNew[_j], M[_j][i]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix2({
        data: x.map((e) => [e]),
        size: [rows, 1]
      }));
    }
    function _sparseBackwardSubstitution(m, b_) {
      var B = [solveValidation(m, b_, true)._data.map((e) => e[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index = m._index;
      var ptr = m._ptr;
      for (var i = columns - 1; i >= 0; i--) {
        var L = B.length;
        for (var k = 0; k < L; k++) {
          var b = B[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i];
          var lastIndex = ptr[i + 1];
          var Mii = 0;
          for (var j = lastIndex - 1; j >= firstIndex; j--) {
            var J = index[j];
            if (J === i) {
              Mii = values[j];
            } else if (J < i) {
              iValues.push(values[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar2(Mii, 0)) {
            b[i] = divideScalar2(b[i], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtract2(b[_J], multiplyScalar2(b[i], iValues[_j2]));
            }
          } else if (!equalScalar2(b[i], 0)) {
            if (k === 0) {
              return [];
            } else {
              B.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
            }
            B.push(bNew);
          }
        }
      }
      return B.map((x) => new DenseMatrix2({
        data: x.map((e) => [e]),
        size: [rows, 1]
      }));
    }
  });

  // ../node_modules/mathjs/lib/esm/function/relational/equal.js
  var name51 = "equal";
  var dependencies52 = ["typed", "matrix", "equalScalar", "DenseMatrix"];
  var createEqual = /* @__PURE__ */ factory(name51, dependencies52, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed: typed2
    });
    var algorithm07 = createAlgorithm07({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm12 = createAlgorithm12({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name51, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === void 0) {
          return y === void 0;
        }
        if (y === void 0) {
          return x === void 0;
        }
        return equalScalar2(x, y);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, equalScalar2);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, equalScalar2, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, equalScalar2, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, equalScalar2);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, equalScalar2, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, equalScalar2, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, equalScalar2, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, equalScalar2, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, equalScalar2, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, equalScalar2, true).valueOf();
      }
    });
  });
  var createEqualNumber = factory(name51, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed: typed2,
      equalScalar: equalScalar2
    } = _ref2;
    return typed2(name51, {
      "any, any": function anyAny(x, y) {
        if (x === null) {
          return y === null;
        }
        if (y === null) {
          return x === null;
        }
        if (x === void 0) {
          return y === void 0;
        }
        if (y === void 0) {
          return x === void 0;
        }
        return equalScalar2(x, y);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/relational/smaller.js
  var name52 = "smaller";
  var dependencies53 = ["typed", "config", "matrix", "DenseMatrix"];
  var createSmaller = /* @__PURE__ */ factory(name52, dependencies53, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed: typed2
    });
    var algorithm07 = createAlgorithm07({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm12 = createAlgorithm12({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name52, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x < y;
      },
      "number, number": function numberNumber(x, y) {
        return x < y && !nearlyEqual(x, y, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.lt(y) && !nearlyEqual2(x, y, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) === -1;
      },
      "Complex, Complex": function ComplexComplex(x, y) {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, this, true).valueOf();
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/relational/smallerEq.js
  var name53 = "smallerEq";
  var dependencies54 = ["typed", "config", "matrix", "DenseMatrix"];
  var createSmallerEq = /* @__PURE__ */ factory(name53, dependencies54, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed: typed2
    });
    var algorithm07 = createAlgorithm07({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm12 = createAlgorithm12({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name53, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x <= y;
      },
      "number, number": function numberNumber(x, y) {
        return x <= y || nearlyEqual(x, y, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.lte(y) || nearlyEqual2(x, y, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) !== 1;
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, this, true).valueOf();
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/relational/larger.js
  var name54 = "larger";
  var dependencies55 = ["typed", "config", "matrix", "DenseMatrix"];
  var createLarger = /* @__PURE__ */ factory(name54, dependencies55, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed: typed2
    });
    var algorithm07 = createAlgorithm07({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm12 = createAlgorithm12({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name54, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x > y;
      },
      "number, number": function numberNumber(x, y) {
        return x > y && !nearlyEqual(x, y, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.gt(y) && !nearlyEqual2(x, y, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) === 1;
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, this, true).valueOf();
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/relational/largerEq.js
  var name55 = "largerEq";
  var dependencies56 = ["typed", "config", "matrix", "DenseMatrix"];
  var createLargerEq = /* @__PURE__ */ factory(name55, dependencies56, (_ref) => {
    var {
      typed: typed2,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var algorithm03 = createAlgorithm03({
      typed: typed2
    });
    var algorithm07 = createAlgorithm07({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm12 = createAlgorithm12({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name55, {
      "boolean, boolean": function booleanBoolean(x, y) {
        return x >= y;
      },
      "number, number": function numberNumber(x, y) {
        return x >= y || nearlyEqual(x, y, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
        return x.gte(y) || nearlyEqual2(x, y, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y) {
        return x.compare(y) !== -1;
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      },
      "Unit, Unit": function UnitUnit(x, y) {
        if (!x.equalBase(y)) {
          throw new Error("Cannot compare units with different base");
        }
        return this(x.value, y.value);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm07(x, y, this);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm03(y, x, this, true);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm03(x, y, this, false);
      },
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, this);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm12(x, y, this, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, this, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm12(y, x, this, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, this, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, this, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, this, true).valueOf();
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
  var name56 = "ImmutableDenseMatrix";
  var dependencies57 = ["smaller", "DenseMatrix"];
  var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name56, dependencies57, (_ref) => {
    var {
      smaller: smaller2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    function ImmutableDenseMatrix2(data, datatype) {
      if (!(this instanceof ImmutableDenseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data) || isArray(data)) {
        var matrix2 = new DenseMatrix2(data, datatype);
        this._data = matrix2._data;
        this._size = matrix2._size;
        this._datatype = matrix2._datatype;
        this._min = null;
        this._max = null;
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        this._datatype = data.datatype;
        this._min = typeof data.min !== "undefined" ? data.min : null;
        this._max = typeof data.max !== "undefined" ? data.max : null;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
        this._min = null;
        this._max = null;
      }
    }
    ImmutableDenseMatrix2.prototype = new DenseMatrix2();
    ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
    ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
    ImmutableDenseMatrix2.prototype.subset = function(index) {
      switch (arguments.length) {
        case 1: {
          var m = DenseMatrix2.prototype.subset.call(this, index);
          if (isMatrix(m)) {
            return new ImmutableDenseMatrix2({
              data: m._data,
              size: m._size,
              datatype: m._datatype
            });
          }
          return m;
        }
        case 2:
        case 3:
          throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    ImmutableDenseMatrix2.prototype.set = function() {
      throw new Error("Cannot invoke set on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.resize = function() {
      throw new Error("Cannot invoke resize on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.reshape = function() {
      throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.clone = function() {
      return new ImmutableDenseMatrix2({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
    };
    ImmutableDenseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "ImmutableDenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    ImmutableDenseMatrix2.fromJSON = function(json) {
      return new ImmutableDenseMatrix2(json);
    };
    ImmutableDenseMatrix2.prototype.swapRows = function() {
      throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.min = function() {
      if (this._min === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller2(v, m)) {
            m = v;
          }
        });
        this._min = m !== null ? m : void 0;
      }
      return this._min;
    };
    ImmutableDenseMatrix2.prototype.max = function() {
      if (this._max === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller2(m, v)) {
            m = v;
          }
        });
        this._max = m !== null ? m : void 0;
      }
      return this._max;
    };
    return ImmutableDenseMatrix2;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
  var name57 = "Index";
  var dependencies58 = ["ImmutableDenseMatrix"];
  var createIndexClass = /* @__PURE__ */ factory(name57, dependencies58, (_ref) => {
    var {
      ImmutableDenseMatrix: ImmutableDenseMatrix2
    } = _ref;
    function Index2(ranges) {
      if (!(this instanceof Index2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._dimensions = [];
      this._isScalar = true;
      for (var i = 0, ii = arguments.length; i < ii; i++) {
        var arg = arguments[i];
        if (isRange(arg)) {
          this._dimensions.push(arg);
          this._isScalar = false;
        } else if (Array.isArray(arg) || isMatrix(arg)) {
          var m = _createImmutableMatrix(arg.valueOf());
          this._dimensions.push(m);
          var size2 = m.size();
          if (size2.length !== 1 || size2[0] !== 1) {
            this._isScalar = false;
          }
        } else if (typeof arg === "number") {
          this._dimensions.push(_createImmutableMatrix([arg]));
        } else if (typeof arg === "string") {
          this._dimensions.push(arg);
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
      }
    }
    Index2.prototype.type = "Index";
    Index2.prototype.isIndex = true;
    function _createImmutableMatrix(arg) {
      for (var i = 0, l = arg.length; i < l; i++) {
        if (typeof arg[i] !== "number" || !isInteger(arg[i])) {
          throw new TypeError("Index parameters must be positive integer numbers");
        }
      }
      return new ImmutableDenseMatrix2(arg);
    }
    Index2.prototype.clone = function() {
      var index = new Index2();
      index._dimensions = clone(this._dimensions);
      index._isScalar = this._isScalar;
      return index;
    };
    Index2.create = function(ranges) {
      var index = new Index2();
      Index2.apply(index, ranges);
      return index;
    };
    Index2.prototype.size = function() {
      var size2 = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var d = this._dimensions[i];
        size2[i] = typeof d === "string" ? 1 : d.size()[0];
      }
      return size2;
    };
    Index2.prototype.max = function() {
      var values = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range2 = this._dimensions[i];
        values[i] = typeof range2 === "string" ? range2 : range2.max();
      }
      return values;
    };
    Index2.prototype.min = function() {
      var values = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var range2 = this._dimensions[i];
        values[i] = typeof range2 === "string" ? range2 : range2.min();
      }
      return values;
    };
    Index2.prototype.forEach = function(callback) {
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        callback(this._dimensions[i], i, this);
      }
    };
    Index2.prototype.dimension = function(dim) {
      return this._dimensions[dim] || null;
    };
    Index2.prototype.isObjectProperty = function() {
      return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
    };
    Index2.prototype.getObjectProperty = function() {
      return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    Index2.prototype.isScalar = function() {
      return this._isScalar;
    };
    Index2.prototype.toArray = function() {
      var array = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        array.push(typeof dimension === "string" ? dimension : dimension.toArray());
      }
      return array;
    };
    Index2.prototype.valueOf = Index2.prototype.toArray;
    Index2.prototype.toString = function() {
      var strings = [];
      for (var i = 0, ii = this._dimensions.length; i < ii; i++) {
        var dimension = this._dimensions[i];
        if (typeof dimension === "string") {
          strings.push(JSON.stringify(dimension));
        } else {
          strings.push(dimension.toString());
        }
      }
      return "[" + strings.join(", ") + "]";
    };
    Index2.prototype.toJSON = function() {
      return {
        mathjs: "Index",
        dimensions: this._dimensions
      };
    };
    Index2.fromJSON = function(json) {
      return Index2.create(json.dimensions);
    };
    return Index2;
  }, {
    isClass: true
  });

  // ../node_modules/mathjs/lib/esm/function/trigonometry/atan.js
  var name58 = "atan";
  var dependencies59 = ["typed"];
  var createAtan = /* @__PURE__ */ factory(name58, dependencies59, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2("atan", {
      number: function number2(x) {
        return Math.atan(x);
      },
      Complex: function Complex3(x) {
        return x.atan();
      },
      BigNumber: function BigNumber2(x) {
        return x.atan();
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/trigonometry/cos.js
  var name59 = "cos";
  var dependencies60 = ["typed"];
  var createCos = /* @__PURE__ */ factory(name59, dependencies60, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name59, {
      number: Math.cos,
      Complex: function Complex3(x) {
        return x.cos();
      },
      BigNumber: function BigNumber2(x) {
        return x.cos();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function cos is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/trigonometry/sin.js
  var name60 = "sin";
  var dependencies61 = ["typed"];
  var createSin = /* @__PURE__ */ factory(name60, dependencies61, (_ref) => {
    var {
      typed: typed2
    } = _ref;
    return typed2(name60, {
      number: Math.sin,
      Complex: function Complex3(x) {
        return x.sin();
      },
      BigNumber: function BigNumber2(x) {
        return x.sin();
      },
      Unit: function Unit(x) {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function sin is no angle");
        }
        return this(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, this, true);
      }
    });
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/add.js
  var name61 = "add";
  var dependencies62 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix"];
  var createAdd = /* @__PURE__ */ factory(name61, dependencies62, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      addScalar: addScalar2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    var algorithm01 = createAlgorithm01({
      typed: typed2
    });
    var algorithm04 = createAlgorithm04({
      typed: typed2,
      equalScalar: equalScalar2
    });
    var algorithm10 = createAlgorithm10({
      typed: typed2,
      DenseMatrix: DenseMatrix2
    });
    var algorithm13 = createAlgorithm13({
      typed: typed2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2(name61, extend({
      "DenseMatrix, DenseMatrix": function DenseMatrixDenseMatrix(x, y) {
        return algorithm13(x, y, addScalar2);
      },
      "DenseMatrix, SparseMatrix": function DenseMatrixSparseMatrix(x, y) {
        return algorithm01(x, y, addScalar2, false);
      },
      "SparseMatrix, DenseMatrix": function SparseMatrixDenseMatrix(x, y) {
        return algorithm01(y, x, addScalar2, true);
      },
      "SparseMatrix, SparseMatrix": function SparseMatrixSparseMatrix(x, y) {
        return algorithm04(x, y, addScalar2);
      },
      "Array, Array": function ArrayArray(x, y) {
        return this(matrix2(x), matrix2(y)).valueOf();
      },
      "Array, Matrix": function ArrayMatrix(x, y) {
        return this(matrix2(x), y);
      },
      "Matrix, Array": function MatrixArray(x, y) {
        return this(x, matrix2(y));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, addScalar2, false);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm10(x, y, addScalar2, false);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y) {
        return algorithm14(y, x, addScalar2, true);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y) {
        return algorithm10(y, x, addScalar2, true);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, addScalar2, false).valueOf();
      },
      "any, Array": function anyArray(x, y) {
        return algorithm14(matrix2(y), x, addScalar2, true).valueOf();
      },
      "any, any": addScalar2,
      "any, any, ...any": function anyAnyAny(x, y, rest) {
        var result = this(x, y);
        for (var i = 0; i < rest.length; i++) {
          result = this(result, rest[i]);
        }
        return result;
      }
    }, addScalar2.signatures));
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/norm.js
  var name62 = "norm";
  var dependencies63 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
  var createNorm = /* @__PURE__ */ factory(name62, dependencies63, (_ref) => {
    var {
      typed: typed2,
      abs: abs3,
      add: add3,
      pow: pow3,
      conj: conj2,
      sqrt: sqrt3,
      multiply: multiply2,
      equalScalar: equalScalar2,
      larger: larger2,
      smaller: smaller2,
      matrix: matrix2,
      ctranspose: ctranspose2,
      eigs: eigs2
    } = _ref;
    return typed2(name62, {
      number: Math.abs,
      Complex: function Complex3(x) {
        return x.abs();
      },
      BigNumber: function BigNumber2(x) {
        return x.abs();
      },
      boolean: function boolean(x) {
        return Math.abs(x);
      },
      Array: function Array2(x) {
        return _norm(matrix2(x), 2);
      },
      Matrix: function Matrix2(x) {
        return _norm(x, 2);
      },
      "number | Complex | BigNumber | boolean, number | BigNumber | string": function numberComplexBigNumberBooleanNumberBigNumberString(x) {
        return this(x);
      },
      "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
        return _norm(matrix2(x), p);
      },
      "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
        return _norm(x, p);
      }
    });
    function _vectorNormPlusInfinity(x) {
      var pinf = 0;
      x.forEach(function(value) {
        var v = abs3(value);
        if (larger2(v, pinf)) {
          pinf = v;
        }
      }, true);
      return pinf;
    }
    function _vectorNormMinusInfinity(x) {
      var ninf;
      x.forEach(function(value) {
        var v = abs3(value);
        if (!ninf || smaller2(v, ninf)) {
          ninf = v;
        }
      }, true);
      return ninf || 0;
    }
    function _vectorNorm(x, p) {
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _vectorNormPlusInfinity(x);
      }
      if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
        return _vectorNormMinusInfinity(x);
      }
      if (p === "fro") {
        return _norm(x, 2);
      }
      if (typeof p === "number" && !isNaN(p)) {
        if (!equalScalar2(p, 0)) {
          var n = 0;
          x.forEach(function(value) {
            n = add3(pow3(abs3(value), p), n);
          }, true);
          return pow3(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      throw new Error("Unsupported parameter value");
    }
    function _matrixNormFrobenius(x) {
      var fro = 0;
      x.forEach(function(value, index) {
        fro = add3(fro, multiply2(value, conj2(value)));
      });
      return abs3(sqrt3(fro));
    }
    function _matrixNormOne(x) {
      var c = [];
      var maxc = 0;
      x.forEach(function(value, index) {
        var j = index[1];
        var cj = add3(c[j] || 0, abs3(value));
        if (larger2(cj, maxc)) {
          maxc = cj;
        }
        c[j] = cj;
      }, true);
      return maxc;
    }
    function _matrixNormTwo(x) {
      var sizeX = x.size();
      if (sizeX[0] !== sizeX[1]) {
        throw new RangeError("Invalid matrix dimensions");
      }
      var tx = ctranspose2(x);
      var squaredX = multiply2(tx, x);
      var eigenVals = eigs2(squaredX).values.toArray();
      var rho = eigenVals[eigenVals.length - 1];
      return abs3(sqrt3(rho));
    }
    function _matrixNormInfinity(x) {
      var r = [];
      var maxr = 0;
      x.forEach(function(value, index) {
        var i = index[0];
        var ri = add3(r[i] || 0, abs3(value));
        if (larger2(ri, maxr)) {
          maxr = ri;
        }
        r[i] = ri;
      }, true);
      return maxr;
    }
    function _matrixNorm(x, p) {
      if (p === 1) {
        return _matrixNormOne(x);
      }
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _matrixNormInfinity(x);
      }
      if (p === "fro") {
        return _matrixNormFrobenius(x);
      }
      if (p === 2) {
        return _matrixNormTwo(x);
      }
      throw new Error("Unsupported parameter value " + p);
    }
    function _norm(x, p) {
      var sizeX = x.size();
      if (sizeX.length === 1) {
        return _vectorNorm(x, p);
      }
      if (sizeX.length === 2) {
        if (sizeX[0] && sizeX[1]) {
          return _matrixNorm(x, p);
        } else {
          throw new RangeError("Invalid matrix dimensions");
        }
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/dot.js
  var name63 = "dot";
  var dependencies64 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
  var createDot = /* @__PURE__ */ factory(name63, dependencies64, (_ref) => {
    var {
      typed: typed2,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      conj: conj2,
      size: size2
    } = _ref;
    return typed2(name63, {
      "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
      "SparseMatrix, SparseMatrix": _sparseDot
    });
    function _validateDim(x, y) {
      var xSize = _size(x);
      var ySize = _size(y);
      var xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
      }
      if (xLen !== yLen)
        throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
      if (xLen === 0)
        throw new RangeError("Cannot calculate the dot product of empty vectors");
      return xLen;
    }
    function _denseDot(a, b) {
      var N = _validateDim(a, b);
      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype : void 0;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype : void 0;
      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add3 = addScalar2;
      var mul2 = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        var dt = adt;
        add3 = typed2.find(addScalar2, [dt, dt]);
        mul2 = typed2.find(multiplyScalar2, [dt, dt]);
      }
      if (!aIsColumn && !bIsColumn) {
        var c = mul2(conj2(adata[0]), bdata[0]);
        for (var i = 1; i < N; i++) {
          c = add3(c, mul2(conj2(adata[i]), bdata[i]));
        }
        return c;
      }
      if (!aIsColumn && bIsColumn) {
        var _c = mul2(conj2(adata[0]), bdata[0][0]);
        for (var _i = 1; _i < N; _i++) {
          _c = add3(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
        }
        return _c;
      }
      if (aIsColumn && !bIsColumn) {
        var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add3(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
        }
        return _c2;
      }
      if (aIsColumn && bIsColumn) {
        var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add3(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
        }
        return _c3;
      }
    }
    function _sparseDot(x, y) {
      _validateDim(x, y);
      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y._index;
      var yvalues = y._values;
      var c = 0;
      var add3 = addScalar2;
      var mul2 = multiplyScalar2;
      var i = 0;
      var j = 0;
      while (i < xindex.length && j < yindex.length) {
        var I = xindex[i];
        var J = yindex[j];
        if (I < J) {
          i++;
          continue;
        }
        if (I > J) {
          j++;
          continue;
        }
        if (I === J) {
          c = add3(c, mul2(xvalues[i], yvalues[j]));
          i++;
          j++;
        }
      }
      return c;
    }
    function _size(x) {
      return isMatrix(x) ? x.size() : size2(x);
    }
  });

  // ../node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
  var name64 = "qr";
  var dependencies65 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
  var createQr = /* @__PURE__ */ factory(name64, dependencies65, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      zeros: zeros3,
      identity: identity2,
      isZero: isZero2,
      equal: equal2,
      sign: sign4,
      sqrt: sqrt3,
      conj: conj2,
      unaryMinus: unaryMinus2,
      addScalar: addScalar2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtract: subtract2,
      complex: complex2
    } = _ref;
    return _extends(typed2(name64, {
      DenseMatrix: function DenseMatrix2(m) {
        return _denseQR(m);
      },
      SparseMatrix: function SparseMatrix2(m) {
        return _sparseQR(m);
      },
      Array: function Array2(a) {
        var m = matrix2(a);
        var r = _denseQR(m);
        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    }), {
      _denseQRimpl
    });
    function _denseQRimpl(m) {
      var rows = m._size[0];
      var cols = m._size[1];
      var Q = identity2([rows], "dense");
      var Qdata = Q._data;
      var R = m.clone();
      var Rdata = R._data;
      var i, j, k;
      var w = zeros3([rows], "");
      for (k = 0; k < Math.min(cols, rows); ++k) {
        var pivot = Rdata[k][k];
        var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign4(pivot));
        var conjSgn = conj2(sgn);
        var alphaSquared = 0;
        for (i = k; i < rows; i++) {
          alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i][k], conj2(Rdata[i][k])));
        }
        var alpha = multiplyScalar2(sgn, sqrt3(alphaSquared));
        if (!isZero2(alpha)) {
          var u1 = subtract2(pivot, alpha);
          w[k] = 1;
          for (i = k + 1; i < rows; i++) {
            w[i] = divideScalar2(Rdata[i][k], u1);
          }
          var tau = unaryMinus2(conj2(divideScalar2(u1, alpha)));
          var s = void 0;
          for (j = k; j < cols; j++) {
            s = 0;
            for (i = k; i < rows; i++) {
              s = addScalar2(s, multiplyScalar2(conj2(w[i]), Rdata[i][j]));
            }
            s = multiplyScalar2(s, tau);
            for (i = k; i < rows; i++) {
              Rdata[i][j] = multiplyScalar2(subtract2(Rdata[i][j], multiplyScalar2(w[i], s)), conjSgn);
            }
          }
          for (i = 0; i < rows; i++) {
            s = 0;
            for (j = k; j < rows; j++) {
              s = addScalar2(s, multiplyScalar2(Qdata[i][j], w[j]));
            }
            s = multiplyScalar2(s, tau);
            for (j = k; j < rows; ++j) {
              Qdata[i][j] = divideScalar2(subtract2(Qdata[i][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
            }
          }
        }
      }
      return {
        Q,
        R,
        toString: function toString() {
          return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
        }
      };
    }
    function _denseQR(m) {
      var ret = _denseQRimpl(m);
      var Rdata = ret.R._data;
      if (m._data.length > 0) {
        var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
        for (var i = 0; i < Rdata.length; ++i) {
          for (var j = 0; j < i && j < (Rdata[0] || []).length; ++j) {
            Rdata[i][j] = zero;
          }
        }
      }
      return ret;
    }
    function _sparseQR(m) {
      throw new Error("qr not implemented for sparse matrices yet");
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/det.js
  var name65 = "det";
  var dependencies66 = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
  var createDet = /* @__PURE__ */ factory(name65, dependencies66, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      subtract: subtract2,
      multiply: multiply2,
      divideScalar: divideScalar2,
      isZero: isZero2,
      unaryMinus: unaryMinus2
    } = _ref;
    return typed2(name65, {
      any: function any(x) {
        return clone(x);
      },
      "Array | Matrix": function det2(x) {
        var size2;
        if (isMatrix(x)) {
          size2 = x.size();
        } else if (Array.isArray(x)) {
          x = matrix2(x);
          size2 = x.size();
        } else {
          size2 = [];
        }
        switch (size2.length) {
          case 0:
            return clone(x);
          case 1:
            if (size2[0] === 1) {
              return clone(x.valueOf()[0]);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              return _det(x.clone().valueOf(), rows, cols);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
        }
      }
    });
    function _det(matrix3, rows, cols) {
      if (rows === 1) {
        return clone(matrix3[0][0]);
      } else if (rows === 2) {
        return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
      } else {
        var negated = false;
        var rowIndices = new Array(rows).fill(0).map((_, i2) => i2);
        for (var k = 0; k < rows; k++) {
          var k_ = rowIndices[k];
          if (isZero2(matrix3[k_][k])) {
            var _k = void 0;
            for (_k = k + 1; _k < rows; _k++) {
              if (!isZero2(matrix3[rowIndices[_k]][k])) {
                k_ = rowIndices[_k];
                rowIndices[_k] = rowIndices[k];
                rowIndices[k] = k_;
                negated = !negated;
                break;
              }
            }
            if (_k === rows)
              return matrix3[k_][k];
          }
          var piv = matrix3[k_][k];
          var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
          for (var i = k + 1; i < rows; i++) {
            var i_ = rowIndices[i];
            for (var j = k + 1; j < rows; j++) {
              matrix3[i_][j] = divideScalar2(subtract2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
            }
          }
        }
        var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
        return negated ? unaryMinus2(det2) : det2;
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/inv.js
  var name66 = "inv";
  var dependencies67 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
  var createInv = /* @__PURE__ */ factory(name66, dependencies67, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      divideScalar: divideScalar2,
      addScalar: addScalar2,
      multiply: multiply2,
      unaryMinus: unaryMinus2,
      det: det2,
      identity: identity2,
      abs: abs3
    } = _ref;
    return typed2(name66, {
      "Array | Matrix": function ArrayMatrix(x) {
        var size2 = isMatrix(x) ? x.size() : arraySize(x);
        switch (size2.length) {
          case 1:
            if (size2[0] === 1) {
              if (isMatrix(x)) {
                return matrix2([divideScalar2(1, x.valueOf()[0])]);
              } else {
                return [divideScalar2(1, x[0])];
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              if (isMatrix(x)) {
                return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
              } else {
                return _inv(x, rows, cols);
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
        }
      },
      any: function any(x) {
        return divideScalar2(1, x);
      }
    });
    function _inv(mat, rows, cols) {
      var r, s, f, value, temp;
      if (rows === 1) {
        value = mat[0][0];
        if (value === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar2(1, value)]];
      } else if (rows === 2) {
        var d = det2(mat);
        if (d === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
      } else {
        var A = mat.concat();
        for (r = 0; r < rows; r++) {
          A[r] = A[r].concat();
        }
        var B = identity2(rows).valueOf();
        for (var c = 0; c < cols; c++) {
          var ABig = abs3(A[c][c]);
          var rBig = c;
          r = c + 1;
          while (r < rows) {
            if (abs3(A[r][c]) > ABig) {
              ABig = abs3(A[r][c]);
              rBig = r;
            }
            r++;
          }
          if (ABig === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          r = rBig;
          if (r !== c) {
            temp = A[c];
            A[c] = A[r];
            A[r] = temp;
            temp = B[c];
            B[c] = B[r];
            B[r] = temp;
          }
          var Ac = A[c];
          var Bc = B[c];
          for (r = 0; r < rows; r++) {
            var Ar = A[r];
            var Br = B[r];
            if (r !== c) {
              if (Ar[c] !== 0) {
                f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
                }
              }
            } else {
              f = Ac[c];
              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar2(Ar[s], f);
              }
              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar2(Br[s], f);
              }
            }
          }
        }
        return B;
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
  function createComplexEigs(_ref) {
    var {
      addScalar: addScalar2,
      subtract: subtract2,
      flatten: flatten3,
      multiply: multiply2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      sqrt: sqrt3,
      abs: abs3,
      bignumber: bignumber2,
      diag: diag2,
      inv: inv2,
      qr: qr2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      equal: equal2,
      complex: complex2,
      larger: larger2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    } = _ref;
    function complexEigs(arr, N, prec, type, findVectors) {
      if (findVectors === void 0) {
        findVectors = true;
      }
      var R = balance(arr, N, prec, type, findVectors);
      reduceToHessenberg(arr, N, prec, type, findVectors, R);
      var {
        values,
        C
      } = iterateUntilTriangular(arr, N, prec, type, findVectors);
      var vectors;
      if (findVectors) {
        vectors = findEigenvectors(arr, N, C, R, values, prec, type);
        vectors = matrixFromColumns2(...vectors);
      }
      return {
        values,
        vectors
      };
    }
    function balance(arr, N, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var realzero = big ? bignumber2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      var realone = big ? bignumber2(1) : 1;
      var radix = big ? bignumber2(10) : 2;
      var radixSq = multiplyScalar2(radix, radix);
      var Rdiag;
      if (findVectors) {
        Rdiag = Array(N).fill(one);
      }
      var last = false;
      while (!last) {
        last = true;
        for (var i = 0; i < N; i++) {
          var colNorm = realzero;
          var rowNorm = realzero;
          for (var j = 0; j < N; j++) {
            if (i === j)
              continue;
            var c = abs3(arr[i][j]);
            colNorm = addScalar2(colNorm, c);
            rowNorm = addScalar2(rowNorm, c);
          }
          if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
            var f = realone;
            var _c = colNorm;
            var rowDivRadix = divideScalar2(rowNorm, radix);
            var rowMulRadix = multiplyScalar2(rowNorm, radix);
            while (smaller2(_c, rowDivRadix)) {
              _c = multiplyScalar2(_c, radixSq);
              f = multiplyScalar2(f, radix);
            }
            while (larger2(_c, rowMulRadix)) {
              _c = divideScalar2(_c, radixSq);
              f = divideScalar2(f, radix);
            }
            var condition = smaller2(divideScalar2(addScalar2(_c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
            if (condition) {
              last = false;
              var g = divideScalar2(1, f);
              for (var _j = 0; _j < N; _j++) {
                if (i === _j) {
                  continue;
                }
                arr[i][_j] = multiplyScalar2(arr[i][_j], f);
                arr[_j][i] = multiplyScalar2(arr[_j][i], g);
              }
              if (findVectors) {
                Rdiag[i] = multiplyScalar2(Rdiag[i], f);
              }
            }
          }
        }
      }
      return diag2(Rdiag);
    }
    function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      if (big) {
        prec = bignumber2(prec);
      }
      for (var i = 0; i < N - 2; i++) {
        var maxIndex = 0;
        var max2 = zero;
        for (var j = i + 1; j < N; j++) {
          var el = arr[j][i];
          if (smaller2(abs3(max2), abs3(el))) {
            max2 = el;
            maxIndex = j;
          }
        }
        if (smaller2(abs3(max2), prec)) {
          continue;
        }
        if (maxIndex !== i + 1) {
          var tmp1 = arr[maxIndex];
          arr[maxIndex] = arr[i + 1];
          arr[i + 1] = tmp1;
          for (var _j2 = 0; _j2 < N; _j2++) {
            var tmp2 = arr[_j2][maxIndex];
            arr[_j2][maxIndex] = arr[_j2][i + 1];
            arr[_j2][i + 1] = tmp2;
          }
          if (findVectors) {
            var tmp3 = R[maxIndex];
            R[maxIndex] = R[i + 1];
            R[i + 1] = tmp3;
          }
        }
        for (var _j3 = i + 2; _j3 < N; _j3++) {
          var n = divideScalar2(arr[_j3][i], max2);
          if (n === 0) {
            continue;
          }
          for (var k = 0; k < N; k++) {
            arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i + 1][k]));
          }
          for (var _k = 0; _k < N; _k++) {
            arr[_k][i + 1] = addScalar2(arr[_k][i + 1], multiplyScalar2(n, arr[_k][_j3]));
          }
          if (findVectors) {
            for (var _k2 = 0; _k2 < N; _k2++) {
              R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i + 1][_k2]));
            }
          }
        }
      }
      return R;
    }
    function iterateUntilTriangular(A, N, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      if (big) {
        prec = bignumber2(prec);
      }
      var arr = clone(A);
      var lambdas = [];
      var n = N;
      var Sdiag = [];
      var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
      var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
      var lastConvergenceBefore = 0;
      while (lastConvergenceBefore <= 100) {
        lastConvergenceBefore += 1;
        var k = 0;
        for (var i = 0; i < n; i++) {
          arr[i][i] = subtract2(arr[i][i], k);
        }
        var {
          Q,
          R
        } = qr2(arr);
        arr = multiply2(R, Q);
        for (var _i = 0; _i < n; _i++) {
          arr[_i][_i] = addScalar2(arr[_i][_i], k);
        }
        if (findVectors) {
          Qpartial = multiply2(Qpartial, Q);
        }
        if (n === 1 || smaller2(abs3(arr[n - 1][n - 2]), prec)) {
          lastConvergenceBefore = 0;
          lambdas.push(arr[n - 1][n - 1]);
          if (findVectors) {
            Sdiag.unshift([[1]]);
            inflateMatrix(Qpartial, N);
            Qtotal = multiply2(Qtotal, Qpartial);
            if (n > 1) {
              Qpartial = diag2(Array(n - 1).fill(one));
            }
          }
          n -= 1;
          arr.pop();
          for (var _i2 = 0; _i2 < n; _i2++) {
            arr[_i2].pop();
          }
        } else if (n === 2 || smaller2(abs3(arr[n - 2][n - 3]), prec)) {
          lastConvergenceBefore = 0;
          var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
          lambdas.push(...ll);
          if (findVectors) {
            Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
            inflateMatrix(Qpartial, N);
            Qtotal = multiply2(Qtotal, Qpartial);
            if (n > 2) {
              Qpartial = diag2(Array(n - 2).fill(one));
            }
          }
          n -= 2;
          arr.pop();
          arr.pop();
          for (var _i3 = 0; _i3 < n; _i3++) {
            arr[_i3].pop();
            arr[_i3].pop();
          }
        }
        if (n === 0) {
          break;
        }
      }
      lambdas.sort((a, b) => +subtract2(abs3(a), abs3(b)));
      if (lastConvergenceBefore > 100) {
        var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
        err.values = lambdas;
        err.vectors = [];
        throw err;
      }
      var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
      return {
        values: lambdas,
        C
      };
    }
    function findEigenvectors(A, N, C, R, values, prec, type) {
      var Cinv = inv2(C);
      var U = multiply2(Cinv, A, C);
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      var uniqueValues = [];
      var multiplicities = [];
      for (var \u03BB of values) {
        var i = indexOf(uniqueValues, \u03BB, equal2);
        if (i === -1) {
          uniqueValues.push(\u03BB);
          multiplicities.push(1);
        } else {
          multiplicities[i] += 1;
        }
      }
      var vectors = [];
      var len = uniqueValues.length;
      var b = Array(N).fill(zero);
      var E = diag2(Array(N).fill(one));
      var failedLambdas = [];
      var _loop = function _loop2(_i42) {
        var \u03BB2 = uniqueValues[_i42];
        var S = subtract2(U, multiply2(\u03BB2, E));
        var solutions = usolveAll2(S, b);
        solutions.shift();
        while (solutions.length < multiplicities[_i42]) {
          var approxVec = inverseIterate(S, N, solutions, prec, type);
          if (approxVec == null) {
            failedLambdas.push(\u03BB2);
            break;
          }
          solutions.push(approxVec);
        }
        var correction = multiply2(inv2(R), C);
        solutions = solutions.map((v) => multiply2(correction, v));
        vectors.push(...solutions.map((v) => flatten3(v)));
      };
      for (var _i4 = 0; _i4 < len; _i4++) {
        _loop(_i4);
      }
      if (failedLambdas.length !== 0) {
        var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
        err.values = values;
        err.vectors = vectors;
        throw err;
      }
      return vectors;
    }
    function eigenvalues2x2(a, b, c, d) {
      var trA = addScalar2(a, d);
      var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
      var x = multiplyScalar2(trA, 0.5);
      var y = multiplyScalar2(sqrt3(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
      return [addScalar2(x, y), subtract2(x, y)];
    }
    function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      if (smaller2(abs3(c), prec)) {
        return [[one, zero], [zero, one]];
      }
      if (larger2(abs3(subtract2(l1, l2)), prec)) {
        return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
      }
      var na = subtract2(a, l1);
      var nb = subtract2(b, l1);
      var nc = subtract2(c, l1);
      var nd = subtract2(d, l1);
      if (smaller2(abs3(nb), prec)) {
        return [[na, one], [nc, zero]];
      } else {
        return [[nb, zero], [nd, one]];
      }
    }
    function inflateMatrix(arr, N) {
      for (var i = 0; i < arr.length; i++) {
        arr[i].push(...Array(N - arr[i].length).fill(0));
      }
      for (var _i5 = arr.length; _i5 < N; _i5++) {
        arr.push(Array(N).fill(0));
        arr[_i5][_i5] = 1;
      }
      return arr;
    }
    function blockDiag(arr, N) {
      var M = [];
      for (var i = 0; i < N; i++) {
        M[i] = Array(N).fill(0);
      }
      var I = 0;
      for (var sub2 of arr) {
        var n = sub2.length;
        for (var _i6 = 0; _i6 < n; _i6++) {
          for (var j = 0; j < n; j++) {
            M[I + _i6][I + j] = sub2[_i6][j];
          }
        }
        I += n;
      }
      return M;
    }
    function indexOf(arr, el, fn) {
      for (var i = 0; i < arr.length; i++) {
        if (fn(arr[i], el)) {
          return i;
        }
      }
      return -1;
    }
    function inverseIterate(A, N, orthog, prec, type) {
      var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
      var b;
      var i = 0;
      while (true) {
        b = randomOrthogonalVector(N, orthog, type);
        b = usolve2(A, b);
        if (larger2(norm2(b), largeNum)) {
          break;
        }
        if (++i >= 5) {
          return null;
        }
      }
      i = 0;
      while (true) {
        var c = usolve2(A, b);
        if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
          break;
        }
        if (++i >= 10) {
          return null;
        }
        b = normalize2(c);
      }
      return b;
    }
    function randomOrthogonalVector(N, orthog, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
      if (big) {
        v = v.map((n) => bignumber2(n));
      }
      if (cplx) {
        v = v.map((n) => complex2(n));
      }
      v = orthogonalComplement(v, orthog);
      return normalize2(v, type);
    }
    function orthogonalComplement(v, orthog) {
      for (var w of orthog) {
        v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
      }
      return v;
    }
    function norm2(v) {
      return abs3(sqrt3(dot2(v, v)));
    }
    function normalize2(v, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      return multiply2(divideScalar2(one, norm2(v)), v);
    }
    return complexEigs;
  }

  // ../node_modules/mathjs/lib/esm/function/matrix/eigs/realSymetric.js
  function createRealSymmetric(_ref) {
    var {
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      abs: abs3,
      atan: atan4,
      cos: cos5,
      sin: sin5,
      multiplyScalar: multiplyScalar2,
      inv: inv2,
      bignumber: bignumber2,
      multiply: multiply2,
      add: add3
    } = _ref;
    function main(arr, N) {
      var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config4.epsilon;
      var type = arguments.length > 3 ? arguments[3] : void 0;
      if (type === "number") {
        return diag2(arr, prec);
      }
      if (type === "BigNumber") {
        return diagBig(arr, prec);
      }
      throw TypeError("Unsupported data type: " + type);
    }
    function diag2(x, precision) {
      var N = x.length;
      var e0 = Math.abs(precision / N);
      var psi;
      var Sij = new Array(N);
      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1;
      }
      var Vab = getAij(x);
      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j = Vab[0][1];
        psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
        x = x1(x, psi, _i, j);
        Sij = Sij1(Sij, psi, _i, j);
        Vab = getAij(x);
      }
      var Ei = createArray(N, 0);
      for (var _i2 = 0; _i2 < N; _i2++) {
        Ei[_i2] = x[_i2][_i2];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function diagBig(x, precision) {
      var N = x.length;
      var e0 = abs3(precision / N);
      var psi;
      var Sij = new Array(N);
      for (var i = 0; i < N; i++) {
        Sij[i] = createArray(N, 0);
        Sij[i][i] = 1;
      }
      var Vab = getAijBig(x);
      while (abs3(Vab[1]) >= abs3(e0)) {
        var _i3 = Vab[0][0];
        var j = Vab[0][1];
        psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
        x = x1Big(x, psi, _i3, j);
        Sij = Sij1Big(Sij, psi, _i3, j);
        Vab = getAijBig(x);
      }
      var Ei = createArray(N, 0);
      for (var _i4 = 0; _i4 < N; _i4++) {
        Ei[_i4] = x[_i4][_i4];
      }
      return sorting(clone(Ei), clone(Sij));
    }
    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;
      if (Math.abs(denom) <= config4.epsilon) {
        return Math.PI / 4;
      } else {
        return 0.5 * Math.atan(2 * aij / (ajj - aii));
      }
    }
    function getThetaBig(aii, ajj, aij) {
      var denom = subtract2(ajj, aii);
      if (abs3(denom) <= config4.epsilon) {
        return bignumber2(-1).acos().div(4);
      } else {
        return multiplyScalar2(0.5, atan4(multiply2(2, aij, inv2(denom))));
      }
    }
    function Sij1(Sij, theta, i, j) {
      var N = Sij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var Ski = createArray(N, 0);
      var Skj = createArray(N, 0);
      for (var k = 0; k < N; k++) {
        Ski[k] = c * Sij[k][i] - s * Sij[k][j];
        Skj[k] = s * Sij[k][i] + c * Sij[k][j];
      }
      for (var _k = 0; _k < N; _k++) {
        Sij[_k][i] = Ski[_k];
        Sij[_k][j] = Skj[_k];
      }
      return Sij;
    }
    function Sij1Big(Sij, theta, i, j) {
      var N = Sij.length;
      var c = cos5(theta);
      var s = sin5(theta);
      var Ski = createArray(N, bignumber2(0));
      var Skj = createArray(N, bignumber2(0));
      for (var k = 0; k < N; k++) {
        Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i]), multiplyScalar2(s, Sij[k][j]));
        Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i]), multiplyScalar2(c, Sij[k][j]));
      }
      for (var _k2 = 0; _k2 < N; _k2++) {
        Sij[_k2][i] = Ski[_k2];
        Sij[_k2][j] = Skj[_k2];
      }
      return Sij;
    }
    function x1Big(Hij, theta, i, j) {
      var N = Hij.length;
      var c = bignumber2(cos5(theta));
      var s = bignumber2(sin5(theta));
      var c2 = multiplyScalar2(c, c);
      var s2 = multiplyScalar2(s, s);
      var Aki = createArray(N, bignumber2(0));
      var Akj = createArray(N, bignumber2(0));
      var csHij = multiply2(bignumber2(2), c, s, Hij[i][j]);
      var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i][i]), csHij), multiplyScalar2(s2, Hij[j][j]));
      var Ajj = add3(multiplyScalar2(s2, Hij[i][i]), csHij, multiplyScalar2(c2, Hij[j][j]));
      for (var k = 0; k < N; k++) {
        Aki[k] = subtract2(multiplyScalar2(c, Hij[i][k]), multiplyScalar2(s, Hij[j][k]));
        Akj[k] = addScalar2(multiplyScalar2(s, Hij[i][k]), multiplyScalar2(c, Hij[j][k]));
      }
      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = bignumber2(0);
      Hij[j][i] = bignumber2(0);
      for (var _k3 = 0; _k3 < N; _k3++) {
        if (_k3 !== i && _k3 !== j) {
          Hij[i][_k3] = Aki[_k3];
          Hij[_k3][i] = Aki[_k3];
          Hij[j][_k3] = Akj[_k3];
          Hij[_k3][j] = Akj[_k3];
        }
      }
      return Hij;
    }
    function x1(Hij, theta, i, j) {
      var N = Hij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var c2 = c * c;
      var s2 = s * s;
      var Aki = createArray(N, 0);
      var Akj = createArray(N, 0);
      var Aii = c2 * Hij[i][i] - 2 * c * s * Hij[i][j] + s2 * Hij[j][j];
      var Ajj = s2 * Hij[i][i] + 2 * c * s * Hij[i][j] + c2 * Hij[j][j];
      for (var k = 0; k < N; k++) {
        Aki[k] = c * Hij[i][k] - s * Hij[j][k];
        Akj[k] = s * Hij[i][k] + c * Hij[j][k];
      }
      Hij[i][i] = Aii;
      Hij[j][j] = Ajj;
      Hij[i][j] = 0;
      Hij[j][i] = 0;
      for (var _k4 = 0; _k4 < N; _k4++) {
        if (_k4 !== i && _k4 !== j) {
          Hij[i][_k4] = Aki[_k4];
          Hij[_k4][i] = Aki[_k4];
          Hij[j][_k4] = Akj[_k4];
          Hij[_k4][j] = Akj[_k4];
        }
      }
      return Hij;
    }
    function getAij(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i][j])) {
            maxMij = Math.abs(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function getAijBig(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i = 0; i < N; i++) {
        for (var j = i + 1; j < N; j++) {
          if (abs3(maxMij) < abs3(Mij[i][j])) {
            maxMij = abs3(Mij[i][j]);
            maxIJ = [i, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function sorting(E, S) {
      var N = E.length;
      var values = Array(N);
      var vectors = Array(N);
      for (var k = 0; k < N; k++) {
        vectors[k] = Array(N);
      }
      for (var i = 0; i < N; i++) {
        var minID = 0;
        var minE = E[0];
        for (var j = 0; j < E.length; j++) {
          if (abs3(E[j]) < abs3(minE)) {
            minID = j;
            minE = E[minID];
          }
        }
        values[i] = E.splice(minID, 1)[0];
        for (var _k5 = 0; _k5 < N; _k5++) {
          vectors[_k5][i] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
      return {
        values,
        vectors
      };
    }
    function createArray(size2, value) {
      var array = new Array(size2);
      for (var i = 0; i < size2; i++) {
        array[i] = value;
      }
      return array;
    }
    return main;
  }

  // ../node_modules/mathjs/lib/esm/function/matrix/eigs.js
  var name67 = "eigs";
  var dependencies68 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
  var createEigs = /* @__PURE__ */ factory(name67, dependencies68, (_ref) => {
    var {
      config: config4,
      typed: typed2,
      matrix: matrix2,
      addScalar: addScalar2,
      subtract: subtract2,
      equal: equal2,
      abs: abs3,
      atan: atan4,
      cos: cos5,
      sin: sin5,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      inv: inv2,
      bignumber: bignumber2,
      multiply: multiply2,
      add: add3,
      larger: larger2,
      column: column2,
      flatten: flatten3,
      number: number2,
      complex: complex2,
      sqrt: sqrt3,
      diag: diag2,
      qr: qr2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      im: im2,
      re: re2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    } = _ref;
    var doRealSymetric = createRealSymmetric({
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      column: column2,
      flatten: flatten3,
      equal: equal2,
      abs: abs3,
      atan: atan4,
      cos: cos5,
      sin: sin5,
      multiplyScalar: multiplyScalar2,
      inv: inv2,
      bignumber: bignumber2,
      complex: complex2,
      multiply: multiply2,
      add: add3
    });
    var doComplexEigs = createComplexEigs({
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      multiply: multiply2,
      multiplyScalar: multiplyScalar2,
      flatten: flatten3,
      divideScalar: divideScalar2,
      sqrt: sqrt3,
      abs: abs3,
      bignumber: bignumber2,
      diag: diag2,
      qr: qr2,
      inv: inv2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      equal: equal2,
      complex: complex2,
      larger: larger2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    });
    return typed2("eigs", {
      Array: function Array2(x) {
        var mat = matrix2(x);
        return computeValuesAndVectors(mat);
      },
      "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
        var mat = matrix2(x);
        return computeValuesAndVectors(mat, prec);
      },
      Matrix: function Matrix2(mat) {
        var {
          values,
          vectors
        } = computeValuesAndVectors(mat);
        return {
          values: matrix2(values),
          vectors: matrix2(vectors)
        };
      },
      "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
        var {
          values,
          vectors
        } = computeValuesAndVectors(mat, prec);
        return {
          values: matrix2(values),
          vectors: matrix2(vectors)
        };
      }
    });
    function computeValuesAndVectors(mat, prec) {
      if (prec === void 0) {
        prec = config4.epsilon;
      }
      var size2 = mat.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
      }
      var arr = mat.toArray();
      var N = size2[0];
      if (isReal(arr, N, prec)) {
        coerceReal(arr, N);
        if (isSymmetric(arr, N, prec)) {
          var _type = coerceTypes(mat, arr, N);
          return doRealSymetric(arr, N, prec, _type);
        }
      }
      var type = coerceTypes(mat, arr, N);
      return doComplexEigs(arr, N, prec, type);
    }
    function isSymmetric(arr, N, prec) {
      for (var i = 0; i < N; i++) {
        for (var j = i; j < N; j++) {
          if (larger2(bignumber2(abs3(subtract2(arr[i][j], arr[j][i]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function isReal(arr, N, prec) {
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          if (larger2(bignumber2(abs3(im2(arr[i][j]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function coerceReal(arr, N) {
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          arr[i][j] = re2(arr[i][j]);
        }
      }
    }
    function coerceTypes(mat, arr, N) {
      var type = mat.datatype();
      if (type === "number" || type === "BigNumber" || type === "Complex") {
        return type;
      }
      var hasNumber = false;
      var hasBig = false;
      var hasComplex = false;
      for (var i = 0; i < N; i++) {
        for (var j = 0; j < N; j++) {
          var el = arr[i][j];
          if (isNumber(el) || isFraction(el)) {
            hasNumber = true;
          } else if (isBigNumber(el)) {
            hasBig = true;
          } else if (isComplex(el)) {
            hasComplex = true;
          } else {
            throw TypeError("Unsupported type in Matrix: " + typeOf(el));
          }
        }
      }
      if (hasBig && hasComplex) {
        console.warn("Complex BigNumbers not supported, this operation will lose precission.");
      }
      if (hasComplex) {
        for (var _i = 0; _i < N; _i++) {
          for (var _j = 0; _j < N; _j++) {
            arr[_i][_j] = complex2(arr[_i][_j]);
          }
        }
        return "Complex";
      }
      if (hasBig) {
        for (var _i2 = 0; _i2 < N; _i2++) {
          for (var _j2 = 0; _j2 < N; _j2++) {
            arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
          }
        }
        return "BigNumber";
      }
      if (hasNumber) {
        for (var _i3 = 0; _i3 < N; _i3++) {
          for (var _j3 = 0; _j3 < N; _j3++) {
            arr[_i3][_j3] = number2(arr[_i3][_j3]);
          }
        }
        return "number";
      } else {
        throw TypeError("Matrix contains unsupported types only.");
      }
    }
  });

  // ../node_modules/mathjs/lib/esm/function/arithmetic/divide.js
  var name68 = "divide";
  var dependencies69 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
  var createDivide = /* @__PURE__ */ factory(name68, dependencies69, (_ref) => {
    var {
      typed: typed2,
      matrix: matrix2,
      multiply: multiply2,
      equalScalar: equalScalar2,
      divideScalar: divideScalar2,
      inv: inv2
    } = _ref;
    var algorithm11 = createAlgorithm11({
      typed: typed2,
      equalScalar: equalScalar2
    });
    var algorithm14 = createAlgorithm14({
      typed: typed2
    });
    return typed2("divide", extend({
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
        return multiply2(x, inv2(y));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y) {
        return algorithm14(x, y, divideScalar2, false);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y) {
        return algorithm11(x, y, divideScalar2, false);
      },
      "Array, any": function ArrayAny(x, y) {
        return algorithm14(matrix2(x), y, divideScalar2, false).valueOf();
      },
      "any, Array | Matrix": function anyArrayMatrix(x, y) {
        return multiply2(x, inv2(y));
      }
    }, divideScalar2.signatures));
  });

  // ../node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
  var BigNumber = /* @__PURE__ */ createBigNumberClass({
    config
  });
  var Complex2 = /* @__PURE__ */ createComplexClass({});
  var Fraction2 = /* @__PURE__ */ createFractionClass({});
  var Matrix = /* @__PURE__ */ createMatrixClass({});
  var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
    Matrix
  });
  var typed = /* @__PURE__ */ createTyped({
    BigNumber,
    Complex: Complex2,
    DenseMatrix,
    Fraction: Fraction2
  });
  var abs2 = /* @__PURE__ */ createAbs({
    typed
  });
  var addScalar = /* @__PURE__ */ createAddScalar({
    typed
  });
  var atan3 = /* @__PURE__ */ createAtan({
    typed
  });
  var bignumber = /* @__PURE__ */ createBignumber({
    BigNumber,
    typed
  });
  var complex = /* @__PURE__ */ createComplex({
    Complex: Complex2,
    typed
  });
  var conj = /* @__PURE__ */ createConj({
    typed
  });
  var equalScalar = /* @__PURE__ */ createEqualScalar({
    config,
    typed
  });
  var im = /* @__PURE__ */ createIm({
    typed
  });
  var isZero = /* @__PURE__ */ createIsZero({
    typed
  });
  var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
    typed
  });
  var number = /* @__PURE__ */ createNumber({
    typed
  });
  var re = /* @__PURE__ */ createRe({
    typed
  });
  var sign3 = /* @__PURE__ */ createSign({
    BigNumber,
    Fraction: Fraction2,
    complex,
    typed
  });
  var sin2 = /* @__PURE__ */ createSin({
    typed
  });
  var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
    Matrix,
    equalScalar,
    typed
  });
  var cos2 = /* @__PURE__ */ createCos({
    typed
  });
  var sqrt2 = /* @__PURE__ */ createSqrt({
    Complex: Complex2,
    config,
    typed
  });
  var unaryMinus = /* @__PURE__ */ createUnaryMinus({
    typed
  });
  var fraction = /* @__PURE__ */ createFraction({
    Fraction: Fraction2,
    typed
  });
  var matrix = /* @__PURE__ */ createMatrix({
    DenseMatrix,
    Matrix,
    SparseMatrix,
    typed
  });
  var numeric = /* @__PURE__ */ createNumeric({
    bignumber,
    fraction,
    number
  });
  var size = /* @__PURE__ */ createSize({
    matrix,
    config,
    typed
  });
  var smaller = /* @__PURE__ */ createSmaller({
    DenseMatrix,
    config,
    matrix,
    typed
  });
  var subtract = /* @__PURE__ */ createSubtract({
    DenseMatrix,
    addScalar,
    equalScalar,
    matrix,
    typed,
    unaryMinus
  });
  var transpose = /* @__PURE__ */ createTranspose({
    matrix,
    typed
  });
  var zeros2 = /* @__PURE__ */ createZeros({
    BigNumber,
    config,
    matrix,
    typed
  });
  var ctranspose = /* @__PURE__ */ createCtranspose({
    conj,
    transpose,
    typed
  });
  var diag = /* @__PURE__ */ createDiag({
    DenseMatrix,
    SparseMatrix,
    matrix,
    typed
  });
  var divideScalar = /* @__PURE__ */ createDivideScalar({
    numeric,
    typed
  });
  var equal = /* @__PURE__ */ createEqual({
    DenseMatrix,
    equalScalar,
    matrix,
    typed
  });
  var flatten2 = /* @__PURE__ */ createFlatten({
    matrix,
    typed
  });
  var largerEq = /* @__PURE__ */ createLargerEq({
    DenseMatrix,
    config,
    matrix,
    typed
  });
  var matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
    flatten: flatten2,
    matrix,
    size,
    typed
  });
  var smallerEq = /* @__PURE__ */ createSmallerEq({
    DenseMatrix,
    config,
    matrix,
    typed
  });
  var usolve = /* @__PURE__ */ createUsolve({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtract,
    typed
  });
  var add2 = /* @__PURE__ */ createAdd({
    DenseMatrix,
    SparseMatrix,
    addScalar,
    equalScalar,
    matrix,
    typed
  });
  var dot = /* @__PURE__ */ createDot({
    addScalar,
    conj,
    multiplyScalar,
    size,
    typed
  });
  var identity = /* @__PURE__ */ createIdentity({
    BigNumber,
    DenseMatrix,
    SparseMatrix,
    config,
    matrix,
    typed
  });
  var larger = /* @__PURE__ */ createLarger({
    DenseMatrix,
    config,
    matrix,
    typed
  });
  var multiply = /* @__PURE__ */ createMultiply({
    addScalar,
    dot,
    equalScalar,
    matrix,
    multiplyScalar,
    typed
  });
  var qr = /* @__PURE__ */ createQr({
    addScalar,
    complex,
    conj,
    divideScalar,
    equal,
    identity,
    isZero,
    matrix,
    multiplyScalar,
    sign: sign3,
    sqrt: sqrt2,
    subtract,
    typed,
    unaryMinus,
    zeros: zeros2
  });
  var range = /* @__PURE__ */ createRange({
    bignumber,
    matrix,
    config,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  });
  var usolveAll = /* @__PURE__ */ createUsolveAll({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtract,
    typed
  });
  var cross = /* @__PURE__ */ createCross({
    matrix,
    multiply,
    subtract,
    typed
  });
  var det = /* @__PURE__ */ createDet({
    divideScalar,
    isZero,
    matrix,
    multiply,
    subtract,
    typed,
    unaryMinus
  });
  var ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
    DenseMatrix,
    smaller
  });
  var Index = /* @__PURE__ */ createIndexClass({
    ImmutableDenseMatrix
  });
  var column = /* @__PURE__ */ createColumn({
    Index,
    matrix,
    range,
    typed
  });
  var inv = /* @__PURE__ */ createInv({
    abs: abs2,
    addScalar,
    det,
    divideScalar,
    identity,
    matrix,
    multiply,
    typed,
    unaryMinus
  });
  var pow2 = /* @__PURE__ */ createPow({
    Complex: Complex2,
    config,
    fraction,
    identity,
    inv,
    matrix,
    multiply,
    number,
    typed
  });
  var divide2 = /* @__PURE__ */ createDivide({
    divideScalar,
    equalScalar,
    inv,
    matrix,
    multiply,
    typed
  });
  var eigs = /* @__PURE__ */ createEigs({
    abs: abs2,
    add: add2,
    addScalar,
    atan: atan3,
    bignumber,
    column,
    complex,
    config,
    cos: cos2,
    diag,
    divideScalar,
    dot,
    equal,
    flatten: flatten2,
    im,
    inv,
    larger,
    matrix,
    matrixFromColumns,
    multiply,
    multiplyScalar,
    number,
    qr,
    re,
    sin: sin2,
    smaller,
    sqrt: sqrt2,
    subtract,
    typed,
    usolve,
    usolveAll
  });
  var norm = /* @__PURE__ */ createNorm({
    abs: abs2,
    add: add2,
    conj,
    ctranspose,
    eigs,
    equalScalar,
    larger,
    matrix,
    multiply,
    pow: pow2,
    smaller,
    sqrt: sqrt2,
    typed
  });

  // ../node_modules/msfs-geo/dist/index.mjs
  function DegToRad(value) {
    return value * (Math.PI / 180);
  }
  function RadToDeg(value) {
    return value * (180 / Math.PI);
  }
  var MIN_LON = -180;
  var MAX_LON = 180;
  var EARTH_RADIUS = 3443.91846652;
  var sin3 = (angle) => Math.sin(DegToRad(angle));
  var cos3 = (angle) => Math.cos(DegToRad(angle));
  function asin2(angle) {
    return RadToDeg(Math.asin(angle));
  }
  function atan22(y, x) {
    return RadToDeg(Math.atan2(y, x));
  }
  function bearingTo(from, to) {
    return (atan22(sin3(to.long - from.long) * cos3(to.lat), cos3(from.lat) * sin3(to.lat) - sin3(from.lat) * cos3(to.lat) * cos3(to.long - from.long)) + 360) % 360;
  }
  var robustAcos = (value) => {
    if (value > 1) {
      return 1;
    }
    if (value < -1) {
      return -1;
    }
    return value;
  };
  function clampAngle(a) {
    while (a >= 360) {
      a -= 360;
    }
    while (a < 0) {
      a += 360;
    }
    return a;
  }
  function diffAngle(a, b) {
    let diff = b - a;
    while (diff > 180) {
      diff -= 360;
    }
    while (diff <= -180) {
      diff += 360;
    }
    return diff;
  }
  function coordinatesToSpherical(location) {
    return [
      cos3(location.lat) * cos3(location.long),
      cos3(location.lat) * sin3(location.long),
      sin3(location.lat)
    ];
  }
  function sphericalToCoordinates(spherical) {
    return {
      lat: asin2(spherical[2]),
      long: atan22(spherical[1], spherical[0])
    };
  }
  function distanceTo(from, to) {
    return Math.acos(robustAcos(sin3(to.lat) * sin3(from.lat) + cos3(to.lat) * cos3(from.lat) * cos3(from.long - to.long))) * EARTH_RADIUS;
  }
  function placeBearingDistance(place, bearing, distance) {
    const delta = distance / EARTH_RADIUS;
    const lat = asin2(sin3(place.lat) * Math.cos(delta) + cos3(place.lat) * Math.sin(delta) * cos3(bearing));
    let long = place.long + atan22(sin3(bearing) * Math.sin(delta) * cos3(place.lat), Math.cos(delta) - sin3(place.lat) * sin3(lat));
    if (long < MIN_LON || long > MAX_LON) {
      long = (long + 540) % 360 - 180;
    }
    return {
      lat,
      long
    };
  }
  function placeBearingIntersection(point1, bearing1, point2, bearing2) {
    const Pa11 = coordinatesToSpherical(point1);
    const point12 = placeBearingDistance(point1, clampAngle(bearing1), 500);
    const Pa12 = coordinatesToSpherical(point12);
    const Pa21 = coordinatesToSpherical(point2);
    const point22 = placeBearingDistance(point2, clampAngle(bearing2), 500);
    const Pa22 = coordinatesToSpherical(point22);
    const N1 = cross(Pa11, Pa12);
    const N2 = cross(Pa21, Pa22);
    const L = cross(N1, N2);
    const l = norm(L);
    const I1 = divide2(L, l);
    const I2 = multiply(I1, -1);
    const s1 = sphericalToCoordinates(I1);
    const s2 = sphericalToCoordinates(I2);
    const brgTos1 = bearingTo(point1, s1);
    const brgTos2 = bearingTo(point1, s2);
    const delta1 = Math.abs(clampAngle(bearing1) - brgTos1);
    const delta2 = Math.abs(clampAngle(bearing1) - brgTos2);
    return [delta1 < delta2 ? s1 : s2, delta1 < delta2 ? s2 : s1];
  }
  function xyzToCoordinates(x, y, z) {
    const theta = Math.atan2(Math.sqrt(x ** 2 + y ** 2), z);
    let phi = NaN;
    if (x > 0)
      phi = Math.atan(y / x);
    else if (x < 0 && y >= 0)
      phi = Math.atan(y / x) + Math.PI;
    else if (x < 0 && y < 0)
      phi = Math.atan(y / x) - Math.PI;
    else if (x === 0 && y > 0)
      phi = Math.PI;
    else if (x === 0 && y < 0)
      phi = -Math.PI;
    return {
      lat: thetaToLat(theta),
      long: phiToLong(phi)
    };
  }
  function thetaToLat(theta) {
    return 90 - theta * 180 / Math.PI;
  }
  function phiToLong(phi) {
    if (phi > Math.PI)
      return 180 - phi * 180 / Math.PI;
    return phi * 180 / Math.PI;
  }
  function latToTheta(lat) {
    return (90 - lat) * Math.PI / 180;
  }
  function longToPhi(long) {
    if (long < 0)
      return (long + 360) * Math.PI / 180;
    return long * Math.PI / 180;
  }
  function coordinatesToXyz(coordinates, radius) {
    const theta = latToTheta(coordinates.lat);
    const phi = longToPhi(coordinates.long);
    return [
      radius * Math.sin(theta) * Math.cos(phi),
      radius * Math.sin(theta) * Math.sin(phi),
      radius * Math.cos(theta)
    ];
  }
  function crossProduct(x1, y1, z1, x2, y2, z2) {
    return [y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2];
  }
  function thetaUnitVector(theta, phi) {
    return [Math.cos(theta) * Math.cos(phi), Math.cos(theta) * Math.sin(phi), -Math.sin(theta)];
  }
  function phiUnitVector(theta, phi) {
    return [-Math.sin(phi), Math.cos(phi), 0];
  }
  function calculateV(course, theta, phi) {
    const [thetaUnitX, thetaUnitY, thetaUnitZ] = thetaUnitVector(theta, phi);
    const [phiUnitX, phiUnitY, phiUnitZ] = phiUnitVector(theta, phi);
    return [
      -Math.cos(course) * thetaUnitX + Math.sin(course) * phiUnitX,
      -Math.cos(course) * thetaUnitY + Math.sin(course) * phiUnitY,
      -Math.cos(course) * thetaUnitZ + Math.sin(course) * phiUnitZ
    ];
  }
  function solveWithPermutations(smallCircleCoordinates, ns, smallCircleRadius, permutations) {
    let permutation = permutations[0];
    let denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
    for (let i = 1; Math.abs(denominator) < 1e-4 && i < 3; i++) {
      permutation = permutations[i];
      denominator = ns[permutation[2]] * smallCircleCoordinates[permutation[1]] - ns[permutation[1]] * smallCircleCoordinates[permutation[2]];
    }
    const A = -ns[permutation[2]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2) / 2 / denominator;
    const B = -(ns[permutation[2]] * smallCircleCoordinates[permutation[0]] - ns[permutation[0]] * smallCircleCoordinates[permutation[2]]) / denominator;
    const C = ns[permutation[1]] * (smallCircleRadius ** 2 - 2 * EARTH_RADIUS ** 2) / 2 / denominator;
    const D = -(-ns[permutation[1]] * smallCircleCoordinates[permutation[0]] + ns[permutation[0]] * smallCircleCoordinates[permutation[1]]) / denominator;
    const discriminant = -(C ** 2) * (1 + B ** 2) + 2 * A * B * C * D - A ** 2 * (1 + D ** 2) + (1 + B ** 2 + D ** 2) * EARTH_RADIUS ** 2;
    if (discriminant < 0) {
      return null;
    }
    const result1 = [0, 0, 0];
    const result2 = [0, 0, 0];
    result1[permutation[0]] = (-A * B - C * D - Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
    result2[permutation[0]] = (-A * B - C * D + Math.sqrt(discriminant)) / (1 + B ** 2 + D ** 2);
    result1[permutation[1]] = A + B * result1[permutation[0]];
    result2[permutation[1]] = A + B * result2[permutation[0]];
    result1[permutation[2]] = C + D * result1[permutation[0]];
    result2[permutation[2]] = C + D * result2[permutation[0]];
    return [xyzToCoordinates(result1[0], result1[1], result1[2]), xyzToCoordinates(result2[0], result2[1], result2[2])];
  }
  function smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
    const smallCircleCoords = coordinatesToXyz(smallCircleCentre, EARTH_RADIUS);
    const [greatCircleX, greatCircleY, greatCircleZ] = coordinatesToXyz(greatCircleReference, EARTH_RADIUS);
    const [vx, vy, vz] = calculateV(greatCircleBearing * Math.PI / 180, latToTheta(greatCircleReference.lat), longToPhi(greatCircleReference.long));
    const normalVector = crossProduct(greatCircleX, greatCircleY, greatCircleZ, vx, vy, vz);
    return solveWithPermutations(smallCircleCoords, normalVector, smallCircleRadius, [[0, 1, 2], [2, 0, 1], [1, 2, 0]]);
  }
  function firstSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
    const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
    if (!intercepts)
      return null;
    if (distanceTo(greatCircleReference, smallCircleCentre) <= smallCircleRadius) {
      if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, intercepts[0]))) <= 90) {
        return intercepts[0];
      }
      return intercepts[1];
    }
    if (Math.abs(diffAngle(greatCircleBearing, bearingTo(greatCircleReference, smallCircleCentre))) <= 90) {
      if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
        return intercepts[0];
      }
      return intercepts[1];
    }
    if (distanceTo(greatCircleReference, intercepts[0]) > distanceTo(greatCircleReference, intercepts[1])) {
      return intercepts[0];
    }
    return intercepts[1];
  }
  function closestSmallCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing) {
    const intercepts = smallCircleGreatCircleIntersection(smallCircleCentre, smallCircleRadius, greatCircleReference, greatCircleBearing);
    if (!intercepts)
      return null;
    if (distanceTo(greatCircleReference, intercepts[0]) < distanceTo(greatCircleReference, intercepts[1])) {
      return intercepts[0];
    }
    return intercepts[1];
  }

  // src/systems/fmgc/src/flightplanning/FixNamingScheme.ts
  var FixNamingScheme = class {
    static vector() {
      return "MANUAL";
    }
    static headingUntilAltitude(altitudeFeet) {
      return Math.round(altitudeFeet).toString();
    }
    static courseToDistance(course, distance) {
      const roundedDistance = Math.round(distance);
      const distanceAlpha = distance > 26 ? "Z" : this.alphabet[roundedDistance];
      return `D${course.toFixed(0).padStart(3, "0")}${distanceAlpha}`;
    }
    static courseToIntercept(course) {
      return "INTCPT";
    }
  };
  __publicField(FixNamingScheme, "alphabet", [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  ]);

  // src/systems/fmgc/src/flightplanning/WorldMagneticModel.ts
  function WorldMagneticModel() {
    this.coff = [
      "  1,  0,  -29404.5  ,     0.0    ,    6.7  ,      0.0",
      "  1,  1,   -1450.7  ,  4652.9    ,    7.7  ,    -25.1",
      "  2,  0,   -2500.0  ,     0.0    ,  -11.5  ,      0.0",
      "  2,  1,    2982.0  , -2991.6    ,   -7.1  ,    -30.2",
      "  2,  2,    1676.8  ,  -734.8    ,   -2.2  ,    -23.9",
      "  3,  0,    1363.9  ,     0.0    ,    2.8  ,      0.0",
      "  3,  1,   -2381.0  ,   -82.2    ,   -6.2  ,      5.7",
      "  3,  2,    1236.2  ,   241.8    ,    3.4  ,     -1.0",
      "  3,  3,     525.7  ,  -542.9    ,  -12.2  ,      1.1",
      "  4,  0,     903.1  ,     0.0    ,   -1.1  ,      0.0",
      "  4,  1,     809.4  ,   282.0    ,   -1.6  ,      0.2",
      "  4,  2,      86.2  ,  -158.4    ,   -6.0  ,      6.9",
      "  4,  3,    -309.4  ,   199.8    ,    5.4  ,      3.7",
      "  4,  4,      47.9  ,  -350.1    ,   -5.5  ,     -5.6",
      "  5,  0,    -234.4  ,     0.0    ,   -0.3  ,      0.0",
      "  5,  1,     363.1  ,    47.7    ,    0.6  ,      0.1",
      "  5,  2,     187.8  ,   208.4    ,   -0.7  ,      2.5",
      "  5,  3,    -140.7  ,  -121.3    ,    0.1  ,     -0.9",
      "  5,  4,    -151.2  ,    32.2    ,    1.2  ,      3.0",
      "  5,  5,      13.7  ,    99.1    ,    1.0  ,      0.5",
      "  6,  0,      65.9  ,     0.0    ,   -0.6  ,      0.0",
      "  6,  1,      65.6  ,   -19.1    ,   -0.4  ,      0.1",
      "  6,  2,      73.0  ,    25.0    ,    0.5  ,     -1.8",
      "  6,  3,    -121.5  ,    52.7    ,    1.4  ,     -1.4",
      "  6,  4,     -36.2  ,   -64.4    ,   -1.4  ,      0.9",
      "  6,  5,      13.5  ,     9.0    ,   -0.0  ,      0.1",
      "  6,  6,     -64.7  ,    68.1    ,    0.8  ,      1.0",
      "  7,  0,      80.6  ,     0.0    ,   -0.1  ,      0.0",
      "  7,  1,     -76.8  ,   -51.4    ,   -0.3  ,      0.5",
      "  7,  2,      -8.3  ,   -16.8    ,   -0.1  ,      0.6",
      "  7,  3,      56.5  ,     2.3    ,    0.7  ,     -0.7",
      "  7,  4,      15.8  ,    23.5    ,    0.2  ,     -0.2",
      "  7,  5,       6.4  ,    -2.2    ,   -0.5  ,     -1.2",
      "  7,  6,      -7.2  ,   -27.2    ,   -0.8  ,      0.2",
      "  7,  7,       9.8  ,    -1.9    ,    1.0  ,      0.3",
      "  8,  0,      23.6  ,     0.0    ,   -0.1  ,      0.0",
      "  8,  1,       9.8  ,     8.4    ,    0.1  ,     -0.3",
      "  8,  2,     -17.5  ,   -15.3    ,   -0.1  ,      0.7",
      "  8,  3,      -0.4  ,    12.8    ,    0.5  ,     -0.2",
      "  8,  4,     -21.1  ,   -11.8    ,   -0.1  ,      0.5",
      "  8,  5,      15.3  ,    14.9    ,    0.4  ,     -0.3",
      "  8,  6,      13.7  ,     3.6    ,    0.5  ,     -0.5",
      "  8,  7,     -16.5  ,    -6.9    ,    0.0  ,      0.4",
      "  8,  8,      -0.3  ,     2.8    ,    0.4  ,      0.1",
      "  9,  0,       5.0  ,     0.0    ,   -0.1  ,      0.0",
      "  9,  1,       8.2  ,   -23.3    ,   -0.2  ,     -0.3",
      "  9,  2,       2.9  ,    11.1    ,   -0.0  ,      0.2",
      "  9,  3,      -1.4  ,     9.8    ,    0.4  ,     -0.4",
      "  9,  4,      -1.1  ,    -5.1    ,   -0.3  ,      0.4",
      "  9,  5,     -13.3  ,    -6.2    ,   -0.0  ,      0.1",
      "  9,  6,       1.1  ,     7.8    ,    0.3  ,     -0.0",
      "  9,  7,       8.9  ,     0.4    ,   -0.0  ,     -0.2",
      "  9,  8,      -9.3  ,    -1.5    ,   -0.0  ,      0.5",
      "  9,  9,     -11.9  ,     9.7    ,   -0.4  ,      0.2",
      " 10,  0,      -1.9  ,     0.0    ,    0.0  ,      0.0",
      " 10,  1,      -6.2  ,     3.4    ,   -0.0  ,     -0.0",
      " 10,  2,      -0.1  ,    -0.2    ,   -0.0  ,      0.1",
      " 10,  3,       1.7  ,     3.5    ,    0.2  ,     -0.3",
      " 10,  4,      -0.9  ,     4.8    ,   -0.1  ,      0.1",
      " 10,  5,       0.6  ,    -8.6    ,   -0.2  ,     -0.2",
      " 10,  6,      -0.9  ,    -0.1    ,   -0.0  ,      0.1",
      " 10,  7,       1.9  ,    -4.2    ,   -0.1  ,     -0.0",
      " 10,  8,       1.4  ,    -3.4    ,   -0.2  ,     -0.1",
      " 10,  9,      -2.4  ,    -0.1    ,   -0.1  ,      0.2",
      " 10, 10,      -3.9  ,    -8.8    ,   -0.0  ,     -0.0",
      " 11,  0,       3.0  ,     0.0    ,   -0.0  ,      0.0",
      " 11,  1,      -1.4  ,    -0.0    ,   -0.1  ,     -0.0",
      " 11,  2,      -2.5  ,     2.6    ,   -0.0  ,      0.1",
      " 11,  3,       2.4  ,    -0.5    ,    0.0  ,      0.0",
      " 11,  4,      -0.9  ,    -0.4    ,   -0.0  ,      0.2",
      " 11,  5,       0.3  ,     0.6    ,   -0.1  ,     -0.0",
      " 11,  6,      -0.7  ,    -0.2    ,    0.0  ,      0.0",
      " 11,  7,      -0.1  ,    -1.7    ,   -0.0  ,      0.1",
      " 11,  8,       1.4  ,    -1.6    ,   -0.1  ,     -0.0",
      " 11,  9,      -0.6  ,    -3.0    ,   -0.1  ,     -0.1",
      " 11, 10,       0.2  ,    -2.0    ,   -0.1  ,      0.0",
      " 11, 11,       3.1  ,    -2.6    ,   -0.1  ,     -0.0",
      " 12,  0,      -2.0  ,     0.0    ,    0.0  ,      0.0",
      " 12,  1,      -0.1  ,    -1.2    ,   -0.0  ,     -0.0",
      " 12,  2,       0.5  ,     0.5    ,   -0.0  ,      0.0",
      " 12,  3,       1.3  ,     1.3    ,    0.0  ,     -0.1",
      " 12,  4,      -1.2  ,    -1.8    ,   -0.0  ,      0.1",
      " 12,  5,       0.7  ,     0.1    ,   -0.0  ,     -0.0",
      " 12,  6,       0.3  ,     0.7    ,    0.0  ,      0.0",
      " 12,  7,       0.5  ,    -0.1    ,   -0.0  ,     -0.0",
      " 12,  8,      -0.2  ,     0.6    ,    0.0  ,      0.1",
      " 12,  9,      -0.5  ,     0.2    ,   -0.0  ,     -0.0",
      " 12, 10,       0.1  ,    -0.9    ,   -0.0  ,     -0.0",
      " 12, 11,      -1.1  ,    -0.0    ,   -0.0  ,      0.0",
      " 12, 12,      -0.3  ,     0.5    ,   -0.1  ,     -0.1"
    ];
    this.c = new Array(13);
    this.cd = new Array(13);
    this.tc = new Array(13);
    this.dp = new Array(13);
    this.k = new Array(13);
    for (var i = 0; i < 13; i++) {
      this.c[i] = new Array(13);
      this.cd[i] = new Array(13);
      this.tc[i] = new Array(13);
      this.dp[i] = new Array(13);
      this.k[i] = new Array(13);
    }
    this.snorm = new Array(169);
    this.sp = new Array(13);
    this.cp = new Array(13);
    this.fn = new Array(13);
    this.fm = new Array(13);
    this.pp = new Array(13);
    const maxdeg = 12;
    let maxord;
    var i;
    let j;
    let D1;
    let D2;
    let n;
    let m;
    let a;
    let b;
    let a2;
    let b2;
    let c2;
    let a4;
    let b4;
    let c4;
    let re2;
    let gnm;
    let hnm;
    let dgnm;
    let dhnm;
    let flnmj;
    let c_str;
    let c_flds;
    maxord = maxdeg;
    this.sp[0] = 0;
    this.cp[0] = this.snorm[0] = this.pp[0] = 1;
    this.dp[0][0] = 0;
    a = 6378.137;
    b = 6356.7523142;
    re2 = 6371.2;
    a2 = a * a;
    b2 = b * b;
    c2 = a2 - b2;
    a4 = a2 * a2;
    b4 = b2 * b2;
    c4 = a4 - b4;
    this.c[0][0] = 0;
    this.cd[0][0] = 0;
    for (i = 0; i < this.coff.length; i++) {
      c_str = this.coff[i];
      c_flds = c_str.split(",");
      n = parseInt(c_flds[0], 10);
      m = parseInt(c_flds[1], 10);
      gnm = parseFloat(c_flds[2]);
      hnm = parseFloat(c_flds[3]);
      dgnm = parseFloat(c_flds[4]);
      dhnm = parseFloat(c_flds[5]);
      if (m <= n) {
        this.c[m][n] = gnm;
        this.cd[m][n] = dgnm;
        if (m != 0) {
          this.c[n][m - 1] = hnm;
          this.cd[n][m - 1] = dhnm;
        }
      }
    }
    this.snorm[0] = 1;
    for (n = 1; n <= maxord; n++) {
      this.snorm[n] = this.snorm[n - 1] * (2 * n - 1) / n;
      j = 2;
      for (m = 0, D1 = 1, D2 = (n - m + D1) / D1; D2 > 0; D2--, m += D1) {
        this.k[m][n] = ((n - 1) * (n - 1) - m * m) / ((2 * n - 1) * (2 * n - 3));
        if (m > 0) {
          flnmj = (n - m + 1) * j / (n + m);
          this.snorm[n + m * 13] = this.snorm[n + (m - 1) * 13] * Math.sqrt(flnmj);
          j = 1;
          this.c[n][m - 1] = this.snorm[n + m * 13] * this.c[n][m - 1];
          this.cd[n][m - 1] = this.snorm[n + m * 13] * this.cd[n][m - 1];
        }
        this.c[m][n] = this.snorm[n + m * 13] * this.c[m][n];
        this.cd[m][n] = this.snorm[n + m * 13] * this.cd[m][n];
      }
      this.fn[n] = n + 1;
      this.fm[n] = n;
    }
    this.k[1][1] = 0;
    this.fm[0] = 0;
  }
  WorldMagneticModel.prototype.declination = function(altitudeKm, latitudeDegrees, longitudeDegrees, yearFloat) {
    const a = 6378.137;
    const b = 6356.7523142;
    const re2 = 6371.2;
    const a2 = a * a;
    const b2 = b * b;
    const c2 = a2 - b2;
    const a4 = a2 * a2;
    const b4 = b2 * b2;
    const c4 = a4 - b4;
    let D3;
    let D4;
    let dip;
    let ti;
    let gv;
    let dec;
    let n;
    let m;
    let pi;
    let dt;
    let rlon;
    let rlat;
    let srlon;
    let srlat;
    let crlon;
    let crlat;
    let srlat2;
    let crlat2;
    let q;
    let q1;
    let q2;
    let ct;
    let d;
    let aor;
    let ar;
    let br;
    let r;
    let r2;
    let bpp;
    let par;
    let temp1;
    let parp;
    let temp2;
    let bx;
    let by;
    let bz;
    let bh;
    let dtr;
    let bp;
    let bt;
    let st;
    let ca;
    let sa;
    const maxord = 12;
    const alt = altitudeKm;
    const glon = longitudeDegrees;
    const glat = latitudeDegrees;
    dt = yearFloat - 2020;
    if (dt < 0 || dt > 5)
      return -999;
    pi = 3.14159265359;
    dtr = pi / 180;
    rlon = glon * dtr;
    rlat = glat * dtr;
    srlon = Math.sin(rlon);
    srlat = Math.sin(rlat);
    crlon = Math.cos(rlon);
    crlat = Math.cos(rlat);
    srlat2 = srlat * srlat;
    crlat2 = crlat * crlat;
    this.sp[1] = srlon;
    this.cp[1] = crlon;
    q = Math.sqrt(a2 - c2 * srlat2);
    q1 = alt * q;
    q2 = (q1 + a2) / (q1 + b2) * ((q1 + a2) / (q1 + b2));
    ct = srlat / Math.sqrt(q2 * crlat2 + srlat2);
    st = Math.sqrt(1 - ct * ct);
    r2 = alt * alt + 2 * q1 + (a4 - c4 * srlat2) / (q * q);
    r = Math.sqrt(r2);
    d = Math.sqrt(a2 * crlat2 + b2 * srlat2);
    ca = (alt + d) / r;
    sa = c2 * crlat * srlat / (r * d);
    for (m = 2; m <= maxord; m++) {
      this.sp[m] = this.sp[1] * this.cp[m - 1] + this.cp[1] * this.sp[m - 1];
      this.cp[m] = this.cp[1] * this.cp[m - 1] - this.sp[1] * this.sp[m - 1];
    }
    aor = re2 / r;
    ar = aor * aor;
    br = bt = bp = bpp = 0;
    for (n = 1; n <= maxord; n++) {
      ar *= aor;
      for (m = 0, D3 = 1, D4 = (n + m + D3) / D3; D4 > 0; D4--, m += D3) {
        if (n == m) {
          this.snorm[n + m * 13] = st * this.snorm[n - 1 + (m - 1) * 13];
          this.dp[m][n] = st * this.dp[m - 1][n - 1] + ct * this.snorm[n - 1 + (m - 1) * 13];
        } else if (n == 1 && m == 0) {
          this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13];
          this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13];
        } else if (n > 1 && n != m) {
          if (m > n - 2)
            this.snorm[n - 2 + m * 13] = 0;
          if (m > n - 2)
            this.dp[m][n - 2] = 0;
          this.snorm[n + m * 13] = ct * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.snorm[n - 2 + m * 13];
          this.dp[m][n] = ct * this.dp[m][n - 1] - st * this.snorm[n - 1 + m * 13] - this.k[m][n] * this.dp[m][n - 2];
        }
        this.tc[m][n] = this.c[m][n] + dt * this.cd[m][n];
        if (m != 0)
          this.tc[n][m - 1] = this.c[n][m - 1] + dt * this.cd[n][m - 1];
        par = ar * this.snorm[n + m * 13];
        if (m == 0) {
          temp1 = this.tc[m][n] * this.cp[m];
          temp2 = this.tc[m][n] * this.sp[m];
        } else {
          temp1 = this.tc[m][n] * this.cp[m] + this.tc[n][m - 1] * this.sp[m];
          temp2 = this.tc[m][n] * this.sp[m] - this.tc[n][m - 1] * this.cp[m];
        }
        bt -= ar * temp1 * this.dp[m][n];
        bp += this.fm[m] * temp2 * par;
        br += this.fn[n] * temp1 * par;
        if (st == 0 && m == 1) {
          if (n == 1)
            this.pp[n] = this.pp[n - 1];
          else
            this.pp[n] = this.ct * this.pp[n - 1] - this.k[m][n] * this.pp[n - 2];
          parp = ar * this.pp[n];
          bpp += this.fm[m] * temp2 * parp;
        }
      }
    }
    if (st == 0)
      bp = bpp;
    else
      bp /= st;
    bx = -bt * ca - br * sa;
    by = bp;
    bz = bt * sa - br * ca;
    bh = Math.sqrt(bx * bx + by * by);
    ti = Math.sqrt(bh * bh + bz * bz);
    dec = Math.atan2(by, bx) / dtr;
    dip = Math.atan2(bz, bh) / dtr;
    gv = -999;
    if (Math.abs(glat) >= 55) {
      if (glat > 0 && glon >= 0)
        gv = dec - glon;
      if (glat > 0 && glon < 0)
        gv = dec + Math.abs(glon);
      if (glat < 0 && glon >= 0)
        gv = dec + glon;
      if (glat < 0 && glon < 0)
        gv = dec - Math.abs(glon);
      if (gv > 180)
        gv -= 360;
      if (gv < -180)
        gv += 360;
    }
    return dec;
  };
  WorldMagneticModel.prototype.knownAnswerTest = function() {
    const kat2010 = [
      "80.00	,0.00	 ,-6.13	    ",
      "0.00	,120.00	 ,0.97	    ",
      "-80.00	,240.00	 ,70.21	    "
    ];
    const kat2012p5 = [
      "80.00	,0.00	 ,-5.21	    ",
      "0.00	,120.00	 ,0.88	    ",
      "-80.00	,240.00	 ,70.04	    "
    ];
    let maxErr = 0;
    for (var i = 0; i < kat2010.length; i++) {
      var c_str = kat2010[i];
      var c_flds = c_str.split(",");
      var lat = parseFloat(c_flds[0]);
      var lon = parseFloat(c_flds[1]);
      var exp2 = parseFloat(c_flds[2]);
      var maxExp;
      var dec = this.declination(0, lat, lon, 2010);
      if (Math.abs(dec - exp2) > maxErr) {
        maxErr = Math.abs(dec - exp2);
        maxExp = exp2;
      }
    }
    for (var i = 0; i < kat2012p5.length; i++) {
      var c_str = kat2012p5[i];
      var c_flds = c_str.split(",");
      var lat = parseFloat(c_flds[0]);
      var lon = parseFloat(c_flds[1]);
      var exp2 = parseFloat(c_flds[2]);
      var maxExp;
      var dec = this.declination(0, lat, lon, 2012.5);
      if (Math.abs(dec - exp2) > maxErr) {
        maxErr = Math.abs(dec - exp2);
        maxExp = exp2;
      }
    }
    return maxErr * 100 / maxExp;
  };

  // src/systems/fmgc/src/flightplanning/GeoMath.ts
  var _GeoMath = class {
    static relativeBearingDistanceToCoords(course, distanceInNM, referenceCoordinates) {
      const courseRadians = course * Avionics.Utils.DEG2RAD;
      const distanceRadians = Math.PI / (180 * 60) * distanceInNM;
      const refLat = referenceCoordinates.lat * Avionics.Utils.DEG2RAD;
      const refLon = -(referenceCoordinates.long * Avionics.Utils.DEG2RAD);
      const lat = Math.asin(Math.sin(refLat) * Math.cos(distanceRadians) + Math.cos(refLat) * Math.sin(distanceRadians) * Math.cos(courseRadians));
      const dlon = Math.atan2(Math.sin(courseRadians) * Math.sin(distanceRadians) * Math.cos(refLat), Math.cos(distanceRadians) - Math.sin(refLat) * Math.sin(lat));
      const lon = Avionics.Utils.fmod(refLon - dlon + Math.PI, 2 * Math.PI) - Math.PI;
      return new LatLongAlt(lat * Avionics.Utils.RAD2DEG, -(lon * Avionics.Utils.RAD2DEG));
    }
    static correctMagvar(trueCourse, magneticVariation) {
      return trueCourse - _GeoMath.normalizeMagVar(magneticVariation);
    }
    static removeMagvar(headingMagnetic, magneticVariation) {
      return headingMagnetic + _GeoMath.normalizeMagVar(magneticVariation);
    }
    static normalizeMagVar(magneticVariation) {
      let normalizedMagVar;
      if (magneticVariation <= 180) {
        normalizedMagVar = magneticVariation;
      } else {
        normalizedMagVar = magneticVariation - 360;
      }
      return normalizedMagVar;
    }
    static getMagvar(lat, lon) {
      return _GeoMath.magneticModel.declination(0, lat, lon, 2020);
    }
    static directedDistanceToGo(from, to, acDirectedLineBearing) {
      const absDtg = Avionics.Utils.computeGreatCircleDistance(from, to);
      if (acDirectedLineBearing >= 90 && acDirectedLineBearing <= 270) {
        return absDtg;
      }
      return -absDtg;
    }
  };
  var GeoMath = _GeoMath;
  __publicField(GeoMath, "magneticModel", new WorldMagneticModel());

  // src/systems/fmgc/src/flightplanning/RawDataMapper.ts
  var RawDataMapper = class {
    static toWaypoint(facility, instrument2) {
      const waypoint = new WayPoint(instrument2);
      waypoint.ident = WayPoint.formatIdentFromIcao(facility.icao);
      waypoint.icao = facility.icao;
      waypoint.type = facility.icao[0];
      let alt = 0;
      switch (waypoint.type) {
        case "A":
          {
            const info = new AirportInfo(instrument2);
            info.CopyBaseInfosFrom(waypoint);
            info.UpdateNamedFrequencies();
            alt = 3.28084 * facility.runways.reduce((sum2, r) => sum2 + r.elevation, 0) / facility.runways.length;
            info.elevation = alt;
            info.approaches = facility.approaches;
            info.approaches.forEach((approach) => {
              approach.name = ApproachUtils.shortApproachName(approach);
              approach.longName = ApproachUtils.longApproachName(approach);
            });
            info.approaches.forEach((approach) => {
              approach.transitions.forEach((trans) => {
                if (trans.name.trim().length === 0) {
                  trans.name = WayPoint.formatIdentFromIcao(trans.legs[0].fixIcao);
                }
                for (let i = 1; i < trans.legs.length; i++) {
                  const leg = trans.legs[i];
                  if ((leg.fixTypeFlags & 1 /* IAF */) > 0 && (leg.type === 18 /* TF */ || leg.type === 15 /* IF */)) {
                    const iafIdent = WayPoint.formatIdentFromIcao(leg.fixIcao);
                    if (approach.transitions.find((t) => t.name === iafIdent) !== void 0) {
                      continue;
                    }
                    RawDataMapper.addApproachTransition(approach, iafIdent, trans.legs.slice(i));
                  }
                }
              });
              const isRnpAr = approach.runwayNumber !== 0 && approach.rnavTypeFlags === 0;
              if (isRnpAr) {
                RawDataMapper.addRnpIfRfPresent(approach.finalLegs, true);
                approach.transitions.forEach((t) => RawDataMapper.addRnpIfRfPresent(t.legs));
              }
            });
            info.approaches.forEach((approach) => approach.runway = approach.runway.trim());
            info.departures = facility.departures;
            info.departures.forEach((departure) => {
              departure.runwayTransitions.forEach((trans) => trans.name = RawDataMapper.generateRunwayTransitionName(trans));
              departure.enRouteTransitions.forEach(
                (trans) => trans.name.trim().length === 0 && (trans.name = RawDataMapper.generateDepartureEnRouteTransitionName(trans))
              );
              RawDataMapper.addRnpIfRfPresent(departure.commonLegs);
              departure.enRouteTransitions.forEach((t) => RawDataMapper.addRnpIfRfPresent(t.legs));
              departure.runwayTransitions.forEach((t) => RawDataMapper.addRnpIfRfPresent(t.legs));
            });
            info.arrivals = facility.arrivals;
            info.arrivals.forEach((arrival) => arrival.runwayTransitions.forEach((trans) => trans.name = RawDataMapper.generateRunwayTransitionName(trans)));
            info.arrivals.forEach(
              (arrival) => arrival.enRouteTransitions.forEach(
                (trans) => trans.name.trim().length === 0 && (trans.name = RawDataMapper.generateArrivalTransitionName(trans))
              )
            );
            info.runways = facility.runways;
            info.oneWayRunways = [];
            facility.runways.forEach((runway) => info.oneWayRunways.push(...Object.assign(new Runway(), runway).splitIfTwoWays()));
            info.oneWayRunways.sort(RawDataMapper.sortRunways);
            waypoint.infos = info;
          }
          break;
        case "V":
          const vorInfo = new VORInfo(instrument2);
          waypoint.infos = vorInfo;
          vorInfo.frequencyMHz = facility.freqMHz;
          vorInfo.frequencyBcd16 = facility.freqBCD16;
          vorInfo.magneticVariation = facility.magneticVariation;
          vorInfo.type = facility.type;
          vorInfo.vorClass = facility.vorClass;
          break;
        case "N":
          const ndbInfo = new NDBInfo(instrument2);
          waypoint.infos = ndbInfo;
          ndbInfo.type = facility.type;
          ndbInfo.frequencyMHz = facility.freqMHz;
          break;
        case "W":
          waypoint.infos = new IntersectionInfo(instrument2);
          break;
        case "R":
        default:
          waypoint.infos = new WayPointInfo(instrument2);
          break;
      }
      if (waypoint.type !== "A") {
        waypoint.infos.CopyBaseInfosFrom(waypoint);
        waypoint.infos.routes = facility.routes;
      }
      waypoint.infos.coordinates = new LatLongAlt(facility.lat, facility.lon, alt);
      waypoint.additionalData = { facility };
      return waypoint;
    }
    static sortRunways(r1, r2) {
      if (parseInt(r1.designation) === parseInt(r2.designation)) {
        let v1 = 0;
        if (r1.designation.indexOf("L") !== -1) {
          v1 = 1;
        } else if (r1.designation.indexOf("C") !== -1) {
          v1 = 2;
        } else if (r1.designation.indexOf("R") !== -1) {
          v1 = 3;
        }
        let v2 = 0;
        if (r2.designation.indexOf("L") !== -1) {
          v2 = 1;
        } else if (r2.designation.indexOf("C") !== -1) {
          v2 = 2;
        } else if (r2.designation.indexOf("R") !== -1) {
          v2 = 3;
        }
        return v1 - v2;
      }
      return parseInt(r1.designation) - parseInt(r2.designation);
    }
    static generateRunwayTransitionName(runwayTransition) {
      let name69 = `RW${runwayTransition.runwayNumber}`;
      switch (runwayTransition.runwayDesignation) {
        case 1:
          name69 += "L";
          break;
        case 2:
          name69 += "R";
          break;
        case 3:
          name69 += "C";
          break;
        default:
          break;
      }
      return name69;
    }
    static generateArrivalTransitionName(enrouteTransition) {
      return WayPoint.formatIdentFromIcao(enrouteTransition.legs[0].fixIcao);
    }
    static generateDepartureEnRouteTransitionName(enrouteTransition) {
      return WayPoint.formatIdentFromIcao(enrouteTransition.legs[enrouteTransition.legs.length - 1].fixIcao);
    }
    static addApproachTransition(approach, name69, legs) {
      legs[0] = __spreadValues({}, legs[0]);
      legs[0].type = 15 /* IF */;
      approach.transitions.push({
        name: name69,
        legs,
        __Type: "JS_ApproachTransition"
      });
    }
    static addRnpIfRfPresent(legs, force = false) {
      const hasAr = legs.findIndex((l) => l.type === 17 /* RF */) >= 0;
      if (hasAr || force) {
        legs.forEach((l) => l.rnp = 0.3);
      }
    }
  };

  // src/systems/fmgc/src/flightplanning/LegsProcedure.ts
  var _LegsProcedure = class {
    constructor(_legs, _previousFix, _instrument, airportMagVar, approachType, legAnnotations) {
      this._legs = _legs;
      this._previousFix = _previousFix;
      this._instrument = _instrument;
      this.airportMagVar = airportMagVar;
      this.approachType = approachType;
      this.legAnnotations = legAnnotations;
      __publicField(this, "_currentIndex", 0);
      __publicField(this, "_isDiscontinuityPending", false);
      __publicField(this, "_facilities", /* @__PURE__ */ new Map());
      __publicField(this, "_facilitiesLoaded", false);
      __publicField(this, "_facilitiesToLoad", /* @__PURE__ */ new Map());
      __publicField(this, "_addedProcedureStart", false);
      __publicField(this, "legFilteringRules", [
        (icao) => icao.trim() !== "",
        (icao) => icao[0] !== "R",
        (icao) => icao[0] !== "A",
        (icao) => !this._facilitiesToLoad.has(icao)
      ]);
      for (const leg of this._legs) {
        if (this.isIcaoValid(leg.fixIcao)) {
          this._facilitiesToLoad.set(leg.fixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.fixIcao, 2e3, true));
        }
        if (this.isIcaoValid(leg.originIcao)) {
          this._facilitiesToLoad.set(leg.originIcao, this._instrument.facilityLoader.getFacilityRaw(leg.originIcao, 2e3, true));
        }
        if (this.isIcaoValid(leg.arcCenterFixIcao)) {
          this._facilitiesToLoad.set(leg.arcCenterFixIcao, this._instrument.facilityLoader.getFacilityRaw(leg.arcCenterFixIcao, 2e3, true));
        }
      }
    }
    hasNext() {
      return this._currentIndex < this._legs.length || this._isDiscontinuityPending;
    }
    async ensureFacilitiesLoaded() {
      if (!this._facilitiesLoaded) {
        const facilityResults = await Promise.all(this._facilitiesToLoad.values());
        for (const facility of facilityResults.filter((f) => f !== void 0)) {
          this._facilities.set(facility.icao, facility);
        }
        this._facilitiesLoaded = true;
      }
    }
    async getNext() {
      let isLegMappable = false;
      let mappedLeg;
      await this.ensureFacilitiesLoaded();
      while (!isLegMappable && this._currentIndex < this._legs.length) {
        const currentLeg = this._legs[this._currentIndex];
        const currentAnnotation = this.legAnnotations[this._currentIndex];
        isLegMappable = true;
        if (this._currentIndex === 0 && currentLeg.type === 10 && !this._addedProcedureStart) {
          mappedLeg = this.mapExactFix(currentLeg);
          this._addedProcedureStart = true;
        } else {
          try {
            switch (currentLeg.type) {
              case 1 /* AF */:
              case 16 /* PI */:
                mappedLeg = this.mapExactFix(currentLeg);
                break;
              case 3 /* CD */:
              case 20 /* VD */:
                mappedLeg = this.mapHeadingUntilDistanceFromOrigin(currentLeg, this._previousFix);
                break;
              case 4 /* CF */:
                if (currentLeg.fixIcao === "" || currentLeg.fixIcao[0] !== "R") {
                  mappedLeg = this.mapOriginRadialForDistance(currentLeg, this._previousFix);
                } else {
                  isLegMappable = false;
                }
                break;
              case 5 /* CI */:
              case 21 /* VI */:
                mappedLeg = this.mapHeadingToInterceptNextLeg(currentLeg, this._previousFix, this._legs[this._currentIndex + 1]);
                break;
              case 6 /* CR */:
              case 23 /* VR */:
                mappedLeg = this.mapHeadingUntilRadialCrossing(currentLeg, this._previousFix);
                break;
              case 9 /* FC */:
              case 10 /* FD */:
                mappedLeg = this.mapBearingAndDistanceFromOrigin(currentLeg);
                break;
              case 11 /* FM */:
              case 22 /* VM */:
                mappedLeg = this.mapVectors(currentLeg, this._previousFix);
                break;
              case 15 /* IF */:
                if (currentLeg.fixIcao[0] !== "A" && currentLeg.fixIcao[0] !== "R") {
                  const leg = this.mapExactFix(currentLeg);
                  const prevLeg = this._previousFix;
                  if (leg.icao === prevLeg.icao && leg.infos.coordinates.lat === prevLeg.infos.coordinates.lat && leg.infos.coordinates.long === prevLeg.infos.coordinates.long) {
                    isLegMappable = false;
                  } else {
                    mappedLeg = leg;
                  }
                } else {
                  isLegMappable = false;
                }
                break;
              case 7 /* DF */:
              case 18 /* TF */:
                if (currentLeg.fixIcao === "" || currentLeg.fixIcao[0] !== "R") {
                  mappedLeg = this.mapExactFix(currentLeg);
                } else {
                  isLegMappable = false;
                }
                break;
              case 17 /* RF */:
                mappedLeg = this.mapRadiusToFix(currentLeg);
                break;
              case 2 /* CA */:
              case 19 /* VA */:
                mappedLeg = this.mapHeadingUntilAltitude(currentLeg, this._previousFix);
                break;
              case 12 /* HA */:
              case 13 /* HF */:
              case 14 /* HM */:
                mappedLeg = this.mapHold(currentLeg);
                break;
              default:
                isLegMappable = false;
                break;
            }
          } catch (err) {
            console.log(`LegsProcedure: Unexpected unmappable leg: ${err}`);
          }
          if (mappedLeg !== void 0) {
            const magCorrection = this.getMagCorrection(currentLeg);
            if (this.approachType === ApproachType.APPROACH_TYPE_ILS && (currentLeg.fixTypeFlags & 8 /* FAF */) > 0) {
              if (currentLeg.altDesc === 1 /* At */) {
                mappedLeg.legAltitudeDescription = 6 /* G */;
              } else {
                mappedLeg.legAltitudeDescription = 7 /* H */;
              }
            } else {
              mappedLeg.legAltitudeDescription = currentLeg.altDesc;
            }
            mappedLeg.legAltitude1 = currentLeg.altitude1 * 3.28084;
            mappedLeg.legAltitude2 = currentLeg.altitude2 * 3.28084;
            mappedLeg.speedConstraint = currentLeg.speedRestriction;
            mappedLeg.turnDirection = currentLeg.turnDirection;
            const recNavaid = this._facilities.get(currentLeg.originIcao);
            mappedLeg.additionalData.legType = currentLeg.type;
            mappedLeg.additionalData.overfly = currentLeg.flyOver;
            mappedLeg.additionalData.fixTypeFlags = currentLeg.fixTypeFlags;
            mappedLeg.additionalData.distance = currentLeg.distanceMinutes ? void 0 : currentLeg.distance / 1852;
            mappedLeg.additionalData.distanceInMinutes = currentLeg.distanceMinutes ? currentLeg.distance : void 0;
            mappedLeg.additionalData.course = currentLeg.trueDegrees ? currentLeg.course : A32NX_Util.magneticToTrue(currentLeg.course, magCorrection);
            mappedLeg.additionalData.recommendedIcao = currentLeg.originIcao.trim().length > 0 ? currentLeg.originIcao : void 0;
            mappedLeg.additionalData.recommendedFrequency = recNavaid ? recNavaid.freqMHz : void 0;
            mappedLeg.additionalData.recommendedLocation = recNavaid ? { lat: recNavaid.lat, long: recNavaid.lon } : void 0;
            mappedLeg.additionalData.recommendedFacility = recNavaid != null ? recNavaid : null;
            mappedLeg.additionalData.rho = currentLeg.rho / 1852;
            mappedLeg.additionalData.theta = currentLeg.theta;
            mappedLeg.additionalData.thetaTrue = A32NX_Util.magneticToTrue(currentLeg.theta, magCorrection);
            mappedLeg.additionalData.annotation = currentAnnotation;
            mappedLeg.additionalData.verticalAngle = currentLeg.verticalAngle ? currentLeg.verticalAngle - 360 : void 0;
            mappedLeg.additionalData.rnp = currentLeg.rnp;
          }
          this._currentIndex++;
        }
      }
      if (mappedLeg !== void 0) {
        this._previousFix = mappedLeg;
        return mappedLeg;
      }
      return void 0;
    }
    getMagCorrection(currentLeg) {
      if (currentLeg.fixIcao.charAt(0) === "V") {
        const vor = this.getLoadedFacility(currentLeg.fixIcao);
        if (!vor || vor.magneticVariation === void 0) {
          console.warn("Leg coded incorrectly (missing vor fix or station declination)", currentLeg, vor);
          return this.airportMagVar;
        }
        return 360 - vor.magneticVariation;
      }
      if (this.approachType === ApproachType.APPROACH_TYPE_VORDME) {
        for (let i = this._legs.length - 1; i >= 0; i--) {
          if (this._legs[i].originIcao.trim().length > 0) {
            const recNavaid = this.getLoadedFacility(this._legs[i].originIcao);
            if (recNavaid && recNavaid.magneticVariation !== void 0) {
              return 360 - recNavaid.magneticVariation;
            }
          }
        }
        console.warn("VOR/DME approach coded incorrectly (missing recommended navaid or station declination)", currentLeg);
        return this.airportMagVar;
      }
      let useStationDeclination = currentLeg.type === 4 /* CF */ || currentLeg.type === 8 /* FA */ || currentLeg.type === 11 /* FM */;
      if (this.approachType === ApproachType.APPROACH_TYPE_ILS || this.approachType === ApproachType.APPROACH_TYPE_LOCALIZER) {
        useStationDeclination = useStationDeclination && this._legs.indexOf(currentLeg) < this.getFacfIndex();
      }
      if (useStationDeclination) {
        const recNavaid = this.getLoadedFacility(currentLeg.originIcao);
        if (!recNavaid || recNavaid.magneticVariation === void 0) {
          console.warn("Leg coded incorrectly (missing recommended navaid or station declination)", currentLeg, recNavaid);
          return this.airportMagVar;
        }
        return 360 - recNavaid.magneticVariation;
      }
      return this.airportMagVar;
    }
    getLoadedFacility(icao) {
      const facility = this._facilities.get(icao);
      if (!facility) {
        throw new Error(`Failed to load facility: ${icao}`);
      }
      return facility;
    }
    getFacfIndex() {
      if (this.approachType !== void 0) {
        for (let i = this._legs.length - 1; i >= 0; i--) {
          if (this._legs[i].fixTypeFlags & 2 /* IF */) {
            return i;
          }
        }
      }
      return void 0;
    }
    mapHeadingUntilDistanceFromOrigin(leg, prevLeg) {
      const origin = this.getLoadedFacility(leg.originIcao);
      const originIdent = origin.icao.substring(7, 12).trim();
      const bearingToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
      const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon)) / _LegsProcedure.distanceNormalFactorNM;
      const deltaAngle = this.deltaAngleRadians(bearingToOrigin, leg.course);
      const targetDistance = leg.distance / 1852 / _LegsProcedure.distanceNormalFactorNM;
      const distanceAngle = Math.asin(Math.sin(distanceToOrigin) * Math.sin(deltaAngle) / Math.sin(targetDistance));
      const inverseDistanceAngle = Math.PI - distanceAngle;
      const legDistance1 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + distanceAngle)) / Math.sin(0.5 * (deltaAngle - distanceAngle))));
      const legDistance2 = 2 * Math.atan(Math.tan(0.5 * (targetDistance - distanceToOrigin)) * (Math.sin(0.5 * (deltaAngle + inverseDistanceAngle)) / Math.sin(0.5 * (deltaAngle - inverseDistanceAngle))));
      const legDistance = targetDistance > distanceToOrigin ? legDistance1 : Math.min(legDistance1, legDistance2);
      const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(
        course,
        legDistance * _LegsProcedure.distanceNormalFactorNM,
        prevLeg.infos.coordinates.lat,
        prevLeg.infos.coordinates.long
      );
      const waypoint = this.buildWaypoint(`${originIdent.substring(0, 3)}/${Math.round(leg.distance / 1852).toString().padStart(2, "0")}`, coordinates);
      return waypoint;
    }
    mapBearingAndDistanceFromOrigin(leg) {
      const origin = this.getLoadedFacility(leg.fixIcao);
      const originIdent = origin.icao.substring(7, 12).trim();
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, Facilities.getMagVar(origin.lat, origin.lon));
      const refDistance = leg.distance / 1852;
      let termPoint;
      let legLength;
      if (leg.type === 10 /* FD */) {
        const recNavaid = this.getLoadedFacility(leg.originIcao);
        termPoint = firstSmallCircleIntersection(
          { lat: recNavaid.lat, long: recNavaid.lon },
          refDistance,
          { lat: origin.lat, long: origin.lon },
          course
        );
        legLength = Avionics.Utils.computeGreatCircleDistance(
          { lat: origin.lat, long: origin.lon },
          termPoint
        );
      } else {
        termPoint = Avionics.Utils.bearingDistanceToCoordinates(
          course,
          refDistance,
          origin.lat,
          origin.lon
        );
        legLength = refDistance;
      }
      return this.buildWaypoint(`${originIdent.substring(0, 3)}/${Math.round(legLength).toString().padStart(2, "0")}`, termPoint);
    }
    mapOriginRadialForDistance(leg, prevLeg) {
      if (leg.fixIcao.trim() !== "") {
        return this.mapExactFix(leg);
      }
      const origin = this.getLoadedFacility(leg.originIcao);
      const originIdent = origin.icao.substring(7, 12).trim();
      const course = leg.course + GeoMath.getMagvar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(course, leg.distance / 1852, prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const distanceFromOrigin = Avionics.Utils.computeGreatCircleDistance(new LatLongAlt(origin.lat, origin.lon), coordinates);
      return this.buildWaypoint(`${originIdent}${Math.trunc(distanceFromOrigin / 1852)}`, coordinates);
    }
    mapHeadingToInterceptNextLeg(leg, prevLeg, nextLeg) {
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
      const waypoint = this.buildWaypoint(FixNamingScheme.courseToIntercept(course), coordinates, prevLeg.infos.magneticVariation);
      return waypoint;
    }
    mapHeadingUntilRadialCrossing(leg, prevLeg) {
      const origin = this.getLoadedFacility(leg.originIcao);
      const originCoordinates = new LatLongAlt(origin.lat, origin.lon);
      const originToCoordinates = Avionics.Utils.computeGreatCircleHeading(originCoordinates, prevLeg.infos.coordinates);
      const coordinatesToOrigin = Avionics.Utils.computeGreatCircleHeading(prevLeg.infos.coordinates, new LatLongAlt(origin.lat, origin.lon));
      const distanceToOrigin = Avionics.Utils.computeGreatCircleDistance(prevLeg.infos.coordinates, originCoordinates) / _LegsProcedure.distanceNormalFactorNM;
      const alpha = this.deltaAngleRadians(coordinatesToOrigin, leg.course);
      const beta = this.deltaAngleRadians(originToCoordinates, leg.theta);
      const gamma = Math.acos(Math.sin(alpha) * Math.sin(beta) * Math.cos(distanceToOrigin) - Math.cos(alpha) * Math.cos(beta));
      const legDistance = Math.acos((Math.cos(beta) + Math.cos(alpha) * Math.cos(gamma)) / (Math.sin(alpha) * Math.sin(gamma)));
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(
        course,
        legDistance * _LegsProcedure.distanceNormalFactorNM,
        prevLeg.infos.coordinates.lat,
        prevLeg.infos.coordinates.long
      );
      const waypoint = this.buildWaypoint(`${this.getIdent(origin.icao)}${leg.theta}`, coordinates);
      return waypoint;
    }
    mapHeadingUntilAltitude(leg, prevLeg) {
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      const altitudeFeet = leg.altitude1 * 3.2808399;
      const distanceInNM = altitudeFeet / 500;
      const coordinates = GeoMath.relativeBearingDistanceToCoords(course, distanceInNM, prevLeg.infos.coordinates);
      const waypoint = this.buildWaypoint(FixNamingScheme.headingUntilAltitude(altitudeFeet), coordinates, prevLeg.infos.magneticVariation);
      waypoint.additionalData.vectorsAltitude = altitudeFeet;
      return waypoint;
    }
    mapVectors(leg, prevLeg) {
      const magVar = Facilities.getMagVar(prevLeg.infos.coordinates.lat, prevLeg.infos.coordinates.long);
      const course = leg.trueDegrees ? leg.course : A32NX_Util.magneticToTrue(leg.course, magVar);
      const coordinates = GeoMath.relativeBearingDistanceToCoords(course, 1, prevLeg.infos.coordinates);
      const waypoint = this.buildWaypoint(FixNamingScheme.vector(), coordinates);
      waypoint.isVectors = true;
      waypoint.endsInDiscontinuity = true;
      waypoint.discontinuityCanBeCleared = false;
      return waypoint;
    }
    mapExactFix(leg) {
      const facility = this.getLoadedFacility(leg.fixIcao);
      return RawDataMapper.toWaypoint(facility, this._instrument);
    }
    mapArcToFix(leg, prevLeg) {
      const toFix = this.getLoadedFacility(leg.fixIcao);
      const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
      return waypoint;
    }
    mapRadiusToFix(leg) {
      const arcCentreFix = this.getLoadedFacility(leg.arcCenterFixIcao);
      const arcCenterCoordinates = new LatLongAlt(arcCentreFix.lat, arcCentreFix.lon, 0);
      const toFix = this.getLoadedFacility(leg.fixIcao);
      const toCoordinates = new LatLongAlt(toFix.lat, toFix.lon, 0);
      const radius = Avionics.Utils.computeGreatCircleDistance(arcCenterCoordinates, toCoordinates);
      const waypoint = RawDataMapper.toWaypoint(toFix, this._instrument);
      waypoint.additionalData.radius = radius;
      waypoint.additionalData.center = arcCenterCoordinates;
      return waypoint;
    }
    mapHold(leg) {
      const facility = this.getLoadedFacility(leg.fixIcao);
      const waypoint = RawDataMapper.toWaypoint(facility, this._instrument);
      const magVar = Facilities.getMagVar(facility.lat, facility.lon);
      waypoint.additionalData.defaultHold = {
        inboundMagneticCourse: leg.trueDegrees ? A32NX_Util.trueToMagnetic(leg.course, magVar) : leg.course,
        turnDirection: leg.turnDirection,
        distance: leg.distanceMinutes ? void 0 : leg.distance / 1852,
        time: leg.distanceMinutes ? leg.distance : void 0,
        type: 1 /* Database */
      };
      waypoint.additionalData.modifiedHold = {};
      return waypoint;
    }
    deltaAngleRadians(a, b) {
      return Math.abs((Avionics.Utils.fmod(a - b + 180, 360) - 180) * Avionics.Utils.DEG2RAD);
    }
    getIdent(icao) {
      return icao.substring(7, 12).trim();
    }
    isIcaoValid(icao) {
      for (const rule of this.legFilteringRules) {
        if (!rule(icao)) {
          return false;
        }
      }
      return true;
    }
    buildWaypoint(ident, coordinates, magneticVariation) {
      const waypoint = new WayPoint(this._instrument);
      waypoint.type = "W";
      waypoint.infos = new IntersectionInfo(this._instrument);
      waypoint.infos.coordinates = coordinates;
      waypoint.infos.magneticVariation = magneticVariation;
      waypoint.ident = ident;
      waypoint.infos.ident = ident;
      waypoint.additionalData = {};
      return waypoint;
    }
  };
  var LegsProcedure = _LegsProcedure;
  __publicField(LegsProcedure, "distanceNormalFactorNM", 21639 / 2 * Math.PI);

  // src/systems/fmgc/src/flightplanning/ProcedureDetails.ts
  var ProcedureDetails = class {
    constructor() {
      __publicField(this, "originRunwayIndex", -1);
      __publicField(this, "departureIndex", -1);
      __publicField(this, "departureTransitionIndex", -1);
      __publicField(this, "departureRunwayIndex", -1);
      __publicField(this, "arrivalIndex", -1);
      __publicField(this, "arrivalTransitionIndex", -1);
      __publicField(this, "arrivalRunwayIndex", -1);
      __publicField(this, "approachIndex", -1);
      __publicField(this, "approachTransitionIndex", -1);
      __publicField(this, "destinationRunwayIndex", -1);
      __publicField(this, "destinationRunwayExtension", -1);
      __publicField(this, "approachType");
    }
  };

  // src/systems/fmgc/src/flightplanning/WaypointBuilder.ts
  var WaypointBuilder = class {
    static fromCoordinates(ident, coordinates, instrument2, additionalData, icao) {
      const waypoint = new WayPoint(instrument2);
      waypoint.type = "W";
      waypoint.infos = new IntersectionInfo(instrument2);
      waypoint.infos.coordinates = coordinates;
      waypoint.ident = ident;
      waypoint.infos.ident = ident;
      waypoint.icao = icao != null ? icao : `W      ${ident}`;
      waypoint.infos.icao = waypoint.icao;
      waypoint.additionalData = additionalData != null ? additionalData : {};
      return waypoint;
    }
    static fromPlaceBearingDistance(ident, placeCoordinates, bearing, distance, instrument2) {
      let magneticBearing = bearing + GeoMath.getMagvar(placeCoordinates.lat, placeCoordinates.long);
      magneticBearing = magneticBearing < 0 ? 360 + magneticBearing : magneticBearing;
      const coordinates = Avionics.Utils.bearingDistanceToCoordinates(magneticBearing, distance, placeCoordinates.lat, placeCoordinates.long);
      return WaypointBuilder.fromCoordinates(ident, coordinates, instrument2);
    }
    static fromPlaceAlongFlightPlan(ident, placeIndex, distance, instrument2, fpm) {
      console.log("running fromPlaceAlongFlightPlan");
      console.log(`destination? ${fpm.getDestination()}` ? "True" : "False");
      const destinationDistanceInFlightplan = fpm.getDestination().cumulativeDistanceInFP;
      console.log(`destinationDistanceInFlightplan ${destinationDistanceInFlightplan}`);
      const placeDistanceFromDestination = fpm.getWaypoint(placeIndex, 0, true).cumulativeDistanceInFP;
      console.log(`placeDistanceFromDestination ${placeDistanceFromDestination}`);
      const distanceFromDestination = destinationDistanceInFlightplan - placeDistanceFromDestination - distance;
      console.log(`distanceFromDestination ${distanceFromDestination}`);
      const coordinates = fpm.getCoordinatesAtNMFromDestinationAlongFlightPlan(distanceFromDestination);
      return WaypointBuilder.fromCoordinates(ident, coordinates, instrument2);
    }
    static fromWaypointManualHold(waypoint, holdDirection, inboundCourse, holdLength, holdTime, instrument2) {
      const newWaypoint = WaypointBuilder.fromCoordinates(waypoint.ident, waypoint.infos.coordinates, instrument2);
      newWaypoint.icao = waypoint.icao;
      newWaypoint.infos = waypoint.infos;
      newWaypoint.additionalData.legType = 14 /* HM */;
      newWaypoint.turnDirection = holdDirection;
      newWaypoint.additionalData.course = inboundCourse;
      newWaypoint.additionalData.distance = holdLength;
      newWaypoint.additionalData.distanceInMinutes = holdTime;
      newWaypoint.speedConstraint = waypoint.speedConstraint;
      newWaypoint.legAltitudeDescription = waypoint.legAltitudeDescription;
      newWaypoint.legAltitude1 = waypoint.legAltitude1;
      newWaypoint.legAltitude2 = waypoint.legAltitude2;
      newWaypoint.additionalData.constraintType = waypoint.additionalData.constraintType;
      return newWaypoint;
    }
  };

  // src/systems/fmgc/src/flightplanning/ManagedFlightPlan.ts
  var ManagedFlightPlan = class {
    constructor() {
      __publicField(this, "originAirfield");
      __publicField(this, "persistentOriginAirfield");
      __publicField(this, "originTransitionAltitudeDb");
      __publicField(this, "originTransitionAltitudePilot");
      __publicField(this, "destinationAirfield");
      __publicField(this, "destinationTransitionLevelDb");
      __publicField(this, "destinationTransitionLevelPilot");
      __publicField(this, "thrustReductionAltitudeDefault");
      __publicField(this, "thrustReductionAltitudePilot");
      __publicField(this, "accelerationAltitudeDefault");
      __publicField(this, "accelerationAltitudePilot");
      __publicField(this, "engineOutAccelerationAltitudeDefault");
      __publicField(this, "engineOutAccelerationAltitudePilot");
      __publicField(this, "missedThrustReductionAltitudeDefault");
      __publicField(this, "missedThrustReductionAltitudePilot");
      __publicField(this, "missedAccelerationAltitudeDefault");
      __publicField(this, "missedAccelerationAltitudePilot");
      __publicField(this, "missedEngineOutAccelerationAltitudeDefault");
      __publicField(this, "missedEngineOutAccelerationAltitudePilot");
      __publicField(this, "cruiseAltitude", 0);
      __publicField(this, "activeWaypointIndex", 0);
      __publicField(this, "procedureDetails", new ProcedureDetails());
      __publicField(this, "directTo", new DirectTo());
      __publicField(this, "turningPointIndex", 0);
      __publicField(this, "_parentInstrument");
      __publicField(this, "_segments", [new FlightPlanSegment(2 /* Enroute */, 0, [])]);
    }
    get departure() {
      return this.getSegment(1 /* Departure */);
    }
    get enroute() {
      return this.getSegment(2 /* Enroute */);
    }
    get arrival() {
      return this.getSegment(3 /* Arrival */);
    }
    get approach() {
      return this.getSegment(4 /* Approach */);
    }
    get missed() {
      return this.getSegment(5 /* Missed */);
    }
    get hasOrigin() {
      return this.originAirfield;
    }
    get hasPersistentOrigin() {
      return this.persistentOriginAirfield;
    }
    get hasDestination() {
      return this.destinationAirfield;
    }
    get activeWaypoint() {
      return this.waypoints[this.activeWaypointIndex];
    }
    computeWaypointStatistics(ppos) {
      const stats = /* @__PURE__ */ new Map();
      const firstData = this.computeActiveWaypointStatistics(ppos);
      stats.set(this.activeWaypointIndex, firstData);
      this.waypoints.slice(0).forEach((waypoint, index) => {
        var _a, _b, _c;
        const firstDistFromPpos = (_a = firstData == null ? void 0 : firstData.distanceFromPpos) != null ? _a : 0;
        const activeWpCumulativeDist = (_c = (_b = this.activeWaypoint) == null ? void 0 : _b.cumulativeDistanceInFP) != null ? _c : 0;
        const distPpos = waypoint.isVectors ? 1 : waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos;
        const data = {
          ident: waypoint.ident,
          bearingInFp: waypoint.bearingInFP,
          distanceInFP: waypoint.distanceInFP,
          magneticVariation: waypoint.infos.magneticVariation,
          distanceFromPpos: distPpos,
          timeFromPpos: this.computeWaypointTime(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos),
          etaFromPpos: this.computeWaypointEta(waypoint.cumulativeDistanceInFP - activeWpCumulativeDist + firstDistFromPpos)
        };
        stats.set(index, data);
      });
      return stats;
    }
    computeActiveWaypointStatistics(ppos) {
      if (!this.activeWaypoint) {
        return void 0;
      }
      const bearingInFp = Avionics.Utils.computeGreatCircleHeading(ppos, this.activeWaypoint.infos.coordinates);
      let distanceFromPpos;
      if (Number.isNaN(ppos.lat) || Number.isNaN(ppos.long)) {
        distanceFromPpos = this.activeWaypoint.distanceInFP;
      } else if (this.activeWaypoint.isVectors) {
        distanceFromPpos = 1;
      } else {
        distanceFromPpos = Avionics.Utils.computeGreatCircleDistance(ppos, this.activeWaypoint.infos.coordinates);
      }
      const timeFromPpos = this.computeWaypointTime(distanceFromPpos);
      const etaFromPpos = this.computeWaypointEta(distanceFromPpos, timeFromPpos);
      return {
        ident: this.activeWaypoint.ident,
        bearingInFp,
        distanceInFP: this.activeWaypoint.distanceInFP,
        distanceFromPpos,
        timeFromPpos,
        etaFromPpos,
        magneticVariation: GeoMath.getMagvar(this.activeWaypoint.infos.coordinates.lat, this.activeWaypoint.infos.coordinates.long)
      };
    }
    computeWaypointTime(distance) {
      const groundSpeed = Simplane.getGroundSpeed();
      if (groundSpeed < 100) {
        return distance / 400 * 3600;
      }
      return distance / groundSpeed * 3600;
    }
    computeWaypointEta(distance, preComputedTime) {
      const eta = preComputedTime != null ? preComputedTime : this.computeWaypointTime(distance);
      const utcTime = SimVar.GetGlobalVarValue("ZULU TIME", "seconds");
      return eta + utcTime;
    }
    get waypoints() {
      const waypoints = [];
      if (this.originAirfield) {
        waypoints.push(this.originAirfield);
      }
      for (const segment of this._segments) {
        waypoints.push(...segment.waypoints);
      }
      if (this.destinationAirfield) {
        waypoints.push(this.destinationAirfield);
      }
      return waypoints;
    }
    get visibleWaypoints() {
      const allWaypoints = this.waypoints;
      if (this.directTo.isActive) {
        const directToWaypointIndex = this.directTo.planWaypointIndex;
        return allWaypoints.slice(Math.max(this.activeWaypointIndex - 1, directToWaypointIndex), allWaypoints.length - 1);
      }
      return allWaypoints.slice(this.activeWaypointIndex - 1, allWaypoints.length);
    }
    get activeVisibleWaypointIndex() {
      if (this.directTo.isActive) {
        const directToWaypointIndex = this.directTo.planWaypointIndex;
        return this.activeWaypointIndex - 1 > directToWaypointIndex ? 1 : 0;
      }
      return 1;
    }
    get segments() {
      return this._segments;
    }
    get length() {
      const lastSeg = this._segments[this._segments.length - 1];
      return lastSeg.offset + lastSeg.waypoints.length + (this.hasDestination ? 1 : 0);
    }
    get checksum() {
      let checksum = 0;
      const { waypoints } = this;
      for (let i = 0; i < waypoints.length; i++)
        checksum += waypoints[i].infos.coordinates.lat;
      return checksum;
    }
    get nonApproachWaypoints() {
      const waypoints = [];
      if (this.originAirfield) {
        waypoints.push(this.originAirfield);
      }
      for (const segment of this._segments.filter((s) => s.type < 4 /* Approach */)) {
        waypoints.push(...segment.waypoints);
      }
      if (this.destinationAirfield) {
        waypoints.push(this.destinationAirfield);
      }
      return waypoints;
    }
    get cruiseStepWaypoints() {
      return this.waypoints.reduce((waypoints, wp, index) => {
        if (wp.additionalData.cruiseStep) {
          wp.additionalData.cruiseStep.waypointIndex = index;
          waypoints.push(wp);
        }
        return waypoints;
      }, []);
    }
    setParentInstrument(instrument2) {
      this._parentInstrument = instrument2;
    }
    async clearPlan() {
      this.originAirfield = void 0;
      this.originTransitionAltitudeDb = void 0;
      this.originTransitionAltitudePilot = void 0;
      this.persistentOriginAirfield = void 0;
      this.destinationAirfield = void 0;
      this.destinationTransitionLevelDb = void 0;
      this.destinationTransitionLevelPilot = void 0;
      this.thrustReductionAltitudeDefault = void 0;
      this.thrustReductionAltitudePilot = void 0;
      this.accelerationAltitudeDefault = void 0;
      this.accelerationAltitudePilot = void 0;
      this.engineOutAccelerationAltitudeDefault = void 0;
      this.engineOutAccelerationAltitudePilot = void 0;
      this.missedThrustReductionAltitudeDefault = void 0;
      this.missedThrustReductionAltitudePilot = void 0;
      this.missedAccelerationAltitudeDefault = void 0;
      this.missedAccelerationAltitudePilot = void 0;
      this.missedEngineOutAccelerationAltitudeDefault = void 0;
      this.missedEngineOutAccelerationAltitudePilot = void 0;
      this.cruiseAltitude = 0;
      this.activeWaypointIndex = 0;
      this.procedureDetails = new ProcedureDetails();
      this.directTo = new DirectTo();
      await GPS.clearPlan().catch(console.error);
      this._segments = [new FlightPlanSegment(2 /* Enroute */, 0, [])];
    }
    async syncToGPS() {
      await GPS.clearPlan().catch(console.error);
      for (let i = 0; i < this.waypoints.length; i++) {
        const waypoint = this.waypoints[i];
        if (waypoint.icao && waypoint.icao.trim() !== "") {
          GPS.addIcaoWaypoint(waypoint.icao, i).catch(console.error);
        } else {
          GPS.addUserWaypoint(waypoint.infos.coordinates.lat, waypoint.infos.coordinates.long, i, waypoint.ident).catch(console.error);
        }
        if (waypoint.endsInDiscontinuity) {
          break;
        }
      }
      await GPS.setActiveWaypoint(this.activeWaypointIndex).catch(console.error);
      await GPS.logCurrentPlan().catch(console.error);
    }
    addWaypoint(waypoint, index, segmentType) {
      console.log(`addWaypoint ${waypoint.icao}, ${index}, ${SegmentType[segmentType]}`, waypoint);
      const mappedWaypoint = waypoint instanceof WayPoint ? waypoint : RawDataMapper.toWaypoint(waypoint, this._parentInstrument);
      if (mappedWaypoint.type === "A" && index === 0) {
        mappedWaypoint.endsInDiscontinuity = true;
        mappedWaypoint.discontinuityCanBeCleared = true;
        this.originAirfield = mappedWaypoint;
        this.persistentOriginAirfield = mappedWaypoint;
        this.setOriginDefaults(mappedWaypoint);
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunwayIndex = -1;
        this.reflowSegments();
        this.reflowDistances();
      } else if (mappedWaypoint.type === "A" && index === void 0) {
        this.destinationAirfield = mappedWaypoint;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayIndex = -1;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.setDestinationDefaults(mappedWaypoint);
        const previousWp = this.waypoints[this.waypoints.length - 2];
        if (previousWp) {
          previousWp.endsInDiscontinuity = true;
          previousWp.discontinuityCanBeCleared = true;
        }
        this.reflowSegments();
        this.reflowDistances();
      } else {
        let segment;
        if (segmentType !== void 0) {
          segment = this.getSegment(segmentType);
          if (segment === FlightPlanSegment.Empty) {
            segment = this.addSegment(segmentType);
          }
        } else {
          segment = this.findSegmentByWaypointIndex(index);
          if (segment === FlightPlanSegment.Empty) {
            throw new Error("ManagedFlightPlan::addWaypoint: no segment found!");
          }
        }
        if (segment.type > 2 /* Enroute */ && index === segment.offset) {
          const segIdx = this._segments.findIndex((seg) => seg.type === segment.type);
          const prevSeg = this._segments[segIdx - 1];
          if (prevSeg.type === 2 /* Enroute */) {
            segment = prevSeg;
          }
        }
        if (segment) {
          if (index > this.length) {
            index = void 0;
          }
          if (mappedWaypoint.additionalData.legType === void 0) {
            if (segment.waypoints.length < 1) {
              mappedWaypoint.additionalData.legType = 15 /* IF */;
            } else {
              mappedWaypoint.additionalData.legType = 18 /* TF */;
            }
          }
          if (index !== void 0) {
            const segmentIndex = index - segment.offset;
            if (segmentIndex < segment.waypoints.length) {
              segment.waypoints.splice(segmentIndex, 0, mappedWaypoint);
            } else {
              segment.waypoints.push(mappedWaypoint);
            }
          } else {
            segment.waypoints.push(mappedWaypoint);
          }
          this.reflowSegments();
          this.reflowDistances();
          const finalIndex = this.waypoints.indexOf(mappedWaypoint);
          const previousWp = finalIndex > 0 ? this.waypoints[finalIndex - 1] : void 0;
          if (previousWp && previousWp.endsInDiscontinuity && !mappedWaypoint.isTurningPoint) {
            if (previousWp.discontinuityCanBeCleared === void 0 || previousWp.discontinuityCanBeCleared) {
              previousWp.endsInDiscontinuity = false;
              previousWp.discontinuityCanBeCleared = void 0;
              mappedWaypoint.endsInDiscontinuity = true;
              if (!mappedWaypoint.isVectors) {
                mappedWaypoint.discontinuityCanBeCleared = true;
              }
            }
          }
          if (this.activeWaypointIndex === 0 && this.length > 1) {
            this.activeWaypointIndex = 1;
          } else if (this.activeWaypointIndex === 1 && waypoint.isRunway && segment.type === 1 /* Departure */) {
            this.activeWaypointIndex = 2;
          }
          return finalIndex;
        }
      }
      return -1;
    }
    removeWaypoint(index, noDiscontinuity = false) {
      if (this.originAirfield && index === 0) {
        this.originAirfield = void 0;
        this.reflowSegments();
        this.reflowDistances();
      } else if (this.destinationAirfield && index === this.length - 1) {
        this.destinationAirfield = void 0;
      } else {
        const segment = this.findSegmentByWaypointIndex(index);
        if (segment) {
          const spliced = segment.waypoints.splice(index - segment.offset, 1);
          console.log(`removing waypoint ${spliced[0].icao} from segment ${segment.type}`);
          if (segment.waypoints.length === 0 && segment.type !== 2 /* Enroute */) {
            console.log(`removing segment ${segment.type} as length is 0`);
            this.removeSegment(segment.type);
          }
          this.reflowSegments();
          this.reflowDistances();
        }
      }
      const beforeRemoved = this.waypoints[index - 1];
      if (!noDiscontinuity && beforeRemoved && !beforeRemoved.endsInDiscontinuity) {
        beforeRemoved.endsInDiscontinuity = true;
        beforeRemoved.discontinuityCanBeCleared = true;
      }
      if (index < this.activeWaypointIndex || this.activeWaypointIndex === this.waypoints.length) {
        this.activeWaypointIndex--;
      }
    }
    getWaypoint(index) {
      if (this.originAirfield && index === 0) {
        return this.originAirfield;
      }
      if (this.destinationAirfield && index === this.length - 1) {
        return this.destinationAirfield;
      }
      const segment = this.findSegmentByWaypointIndex(index);
      if (segment) {
        return segment.waypoints[index - segment.offset];
      }
      return null;
    }
    setWaypointOverfly(index, value) {
      if (this.originAirfield && index === 0) {
        return;
      }
      if (this.destinationAirfield && index === this.length - 1) {
        return;
      }
      const segment = this.findSegmentByWaypointIndex(index);
      if (segment) {
        segment.waypoints[index - segment.offset].additionalData.overfly = value;
      }
    }
    addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
      const atWaypoint = this.getWaypoint(index);
      if (!atWaypoint) {
        return 0;
      }
      const magVar = Facilities.getMagVar(atWaypoint.infos.coordinates.lat, atWaypoint.infos.coordinates.long);
      const trueCourse = A32NX_Util.magneticToTrue(desiredHold.inboundMagneticCourse, magVar);
      if (atWaypoint.additionalData.legType === 12 /* HA */ || atWaypoint.additionalData.legType === 13 /* HF */ || atWaypoint.additionalData.legType === 14 /* HM */) {
        atWaypoint.additionalData.legType = 14 /* HM */;
        atWaypoint.turnDirection = desiredHold.turnDirection;
        atWaypoint.additionalData.course = trueCourse;
        atWaypoint.additionalData.distance = desiredHold.distance;
        atWaypoint.additionalData.distanceInMinutes = desiredHold.time;
        atWaypoint.additionalData.modifiedHold = modifiedHold;
        if (atWaypoint.additionalData.defaultHold === void 0) {
          atWaypoint.additionalData.defaultHold = defaultHold;
        }
        return index;
      }
      const manualHoldWaypoint = WaypointBuilder.fromWaypointManualHold(atWaypoint, desiredHold.turnDirection, trueCourse, desiredHold.distance, desiredHold.time, this._parentInstrument);
      manualHoldWaypoint.additionalData.modifiedHold = modifiedHold;
      manualHoldWaypoint.additionalData.defaultHold = defaultHold;
      this.addWaypoint(manualHoldWaypoint, index + 1);
      return index + 1;
    }
    addSegment(type) {
      const segment = new FlightPlanSegment(type, 0, []);
      this._segments.push(segment);
      this._segments.sort((a, b) => a.type - b.type);
      this.reflowSegments();
      return segment;
    }
    removeSegment(type) {
      const segmentIndex = this._segments.findIndex((s) => s.type === type);
      if (segmentIndex > -1) {
        this._segments.splice(segmentIndex, 1);
      }
    }
    reflowSegments() {
      let index = 0;
      if (this.originAirfield) {
        index = 1;
      }
      for (const segment of this._segments) {
        segment.offset = index;
        index += segment.waypoints.length;
      }
    }
    getSegment(type) {
      const segment = this._segments.find((s) => s.type === type);
      return segment !== void 0 ? segment : FlightPlanSegment.Empty;
    }
    findSegmentByWaypointIndex(index) {
      for (let i = 0; i < this._segments.length; i++) {
        const segMaxIdx = this._segments[i].offset + this._segments[i].waypoints.length;
        if (segMaxIdx > index) {
          return this._segments[i];
        }
      }
      return this._segments[this._segments.length - 1];
    }
    isLastWaypointInSegment(fpIndex) {
      const segment = this.findSegmentByWaypointIndex(fpIndex);
      if (fpIndex >= this.waypoints.length) {
        return false;
      }
      if (fpIndex === segment.offset + segment.waypoints.length - 1) {
        return true;
      }
      return false;
    }
    reflowDistances() {
      let cumulativeDistance = 0;
      const { waypoints } = this;
      for (let i = 0; i < waypoints.length; i++) {
        if (i > 0) {
          const referenceWaypoint = waypoints[i];
          const prevWaypoint = waypoints[i - 1];
          const trueCourseToWaypoint = Avionics.Utils.computeGreatCircleHeading(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
          referenceWaypoint.bearingInFP = trueCourseToWaypoint - GeoMath.getMagvar(prevWaypoint.infos.coordinates.lat, prevWaypoint.infos.coordinates.long);
          referenceWaypoint.bearingInFP = referenceWaypoint.bearingInFP < 0 ? 360 + referenceWaypoint.bearingInFP : referenceWaypoint.bearingInFP;
          if (prevWaypoint.endsInDiscontinuity && !prevWaypoint.discontinuityCanBeCleared) {
            referenceWaypoint.distanceInFP = 0;
          } else if (referenceWaypoint.additionalData) {
            switch (referenceWaypoint.additionalData.legType) {
              case 11:
              case 22:
                referenceWaypoint.distanceInFP = 1;
                break;
              default:
                referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
                break;
            }
          } else {
            referenceWaypoint.distanceInFP = Avionics.Utils.computeGreatCircleDistance(prevWaypoint.infos.coordinates, referenceWaypoint.infos.coordinates);
          }
          cumulativeDistance += referenceWaypoint.distanceInFP;
          referenceWaypoint.cumulativeDistanceInFP = cumulativeDistance;
        }
      }
    }
    serialize() {
      var _a;
      const planCopy = new ManagedFlightPlan();
      const copyWaypoint = (waypoint) => ({
        icao: waypoint.icao,
        ident: waypoint.ident,
        type: waypoint.type,
        legAltitudeDescription: waypoint.legAltitudeDescription,
        legAltitude1: waypoint.legAltitude1,
        legAltitude2: waypoint.legAltitude2,
        speedConstraint: waypoint.speedConstraint,
        turnDirection: waypoint.turnDirection,
        isVectors: waypoint.isVectors,
        endsInDiscontinuity: waypoint.endsInDiscontinuity,
        discontinuityCanBeCleared: waypoint.discontinuityCanBeCleared,
        distanceInFP: waypoint.distanceInFP,
        cumulativeDistanceInFP: waypoint.cumulativeDistanceInFP,
        isRunway: waypoint.isRunway,
        additionalData: waypoint.additionalData,
        infos: {
          icao: waypoint.infos.icao,
          ident: waypoint.infos.ident,
          airwayIn: waypoint.infos.airwayIn,
          airwayOut: waypoint.infos.airwayOut,
          routes: waypoint.infos.routes,
          coordinates: {
            lat: waypoint.infos.coordinates.lat,
            long: waypoint.infos.coordinates.long,
            alt: waypoint.infos.coordinates.alt
          }
        }
      });
      const copyAirfield = (airfield) => {
        const copy = Object.assign(new WayPoint(void 0), airfield);
        copy.infos = Object.assign(new AirportInfo(void 0), copy.infos);
        delete copy.instrument;
        delete copy.infos.instrument;
        delete copy._svgElements;
        delete copy.infos._svgElements;
        return copy;
      };
      planCopy.activeWaypointIndex = this.activeWaypointIndex;
      planCopy.destinationAirfield = this.destinationAirfield && copyAirfield(this.destinationAirfield);
      planCopy.originAirfield = this.originAirfield && copyAirfield(this.originAirfield);
      planCopy.persistentOriginAirfield = this.persistentOriginAirfield && copyAirfield(this.persistentOriginAirfield);
      planCopy.procedureDetails = __spreadValues({}, this.procedureDetails);
      planCopy.directTo = __spreadValues({}, this.directTo);
      planCopy.directTo.interceptPoints = (_a = planCopy.directTo.interceptPoints) == null ? void 0 : _a.map((w) => copyWaypoint(w));
      const copySegments = [];
      for (const segment of this._segments) {
        const copySegment = new FlightPlanSegment(segment.type, segment.offset, []);
        for (const waypoint of segment.waypoints) {
          copySegment.waypoints.push(copyWaypoint(waypoint));
        }
        copySegments.push(copySegment);
      }
      planCopy._segments = copySegments;
      return planCopy;
    }
    copy() {
      const newFlightPlan = Object.assign(new ManagedFlightPlan(), this);
      newFlightPlan.setParentInstrument(this._parentInstrument);
      newFlightPlan._segments = [];
      for (let i = 0; i < this._segments.length; i++) {
        const seg = this._segments[i];
        newFlightPlan._segments[i] = Object.assign(new FlightPlanSegment(seg.type, seg.offset, []), seg);
        newFlightPlan._segments[i].waypoints = [...seg.waypoints.map((wp) => {
          const clone3 = new wp.constructor();
          Object.assign(clone3, wp);
          clone3.additionalData = __spreadValues({}, wp.additionalData);
          return clone3;
        })];
      }
      newFlightPlan.procedureDetails = Object.assign(new ProcedureDetails(), this.procedureDetails);
      newFlightPlan.directTo = Object.assign(new DirectTo(), this.directTo);
      newFlightPlan.directTo.interceptPoints = this.directTo.interceptPoints !== void 0 ? [...this.directTo.interceptPoints] : void 0;
      return newFlightPlan;
    }
    reverse() {
    }
    async addDirectTo(waypoint) {
      const lat = SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude");
      const long = SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude");
      const trueTrack = SimVar.GetSimVarValue("GPS GROUND TRUE TRACK", "degree");
      const oldToWp = this.waypoints[this.activeWaypointIndex];
      const turningPoint = WaypointBuilder.fromCoordinates(
        "T-P",
        new LatLongAlt(lat, long),
        this._parentInstrument,
        { legType: 4 /* CF */, course: trueTrack, dynamicPpos: true },
        this.getTurningPointIcao()
      );
      turningPoint.isTurningPoint = true;
      const waypointIndex = this.waypoints.findIndex((w, idx) => idx >= this.activeWaypointIndex && w.icao === waypoint.icao);
      if (waypointIndex === -1) {
        waypoint.endsInDiscontinuity = true;
        waypoint.discontinuityCanBeCleared = true;
        waypoint.additionalData.legType = 7 /* DF */;
        this.addWaypoint(waypoint, this.activeWaypointIndex);
        this.activeWaypointIndex = this.addWaypoint(turningPoint, this.activeWaypointIndex) + 1;
        if (ManagedFlightPlan.isXfLeg(oldToWp)) {
          oldToWp.additionalData.legType = 15 /* IF */;
        }
      } else {
        const toWp = this.waypoints[waypointIndex];
        toWp.additionalData.legType = 7 /* DF */;
        toWp.turnDirection = 0;
        this.addWaypoint(turningPoint, waypointIndex);
        this.activeWaypointIndex = waypointIndex + 1;
      }
    }
    updateTurningPoint(force = false) {
      var _a;
      const wp = this.getWaypoint(this.activeWaypointIndex - 1);
      if (((_a = wp == null ? void 0 : wp.additionalData) == null ? void 0 : _a.dynamicPpos) || force && (wp == null ? void 0 : wp.isTurningPoint)) {
        wp.infos.coordinates.lat = SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude");
        wp.infos.coordinates.long = SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude");
        wp.additionalData.course = SimVar.GetSimVarValue("GPS GROUND TRUE TRACK", "degree");
        wp.icao = this.getTurningPointIcao();
        wp.infos.icao = wp.icao;
        console.log("updated T-P:", force, wp.additionalData, wp.infos.coordinates);
        return true;
      }
      return false;
    }
    getTurningPointIcao() {
      this.turningPointIndex = (this.turningPointIndex + 1) % 1e3;
      return `WXX    TP${this.turningPointIndex.toFixed(0).padStart(3, "0")}`;
    }
    async buildDeparture() {
      const legs = [];
      const legAnnotations = [];
      const origin = this.originAirfield;
      const { departureIndex } = this.procedureDetails;
      const runwayIndex = this.procedureDetails.departureRunwayIndex;
      const transitionIndex = this.procedureDetails.departureTransitionIndex;
      const selectedOriginRunwayIndex = this.procedureDetails.originRunwayIndex;
      const airportInfo = origin.infos;
      const airportMagVar = Facilities.getMagVar(airportInfo.coordinates.lat, airportInfo.coordinates.long);
      if (origin) {
        origin.additionalData.legType = 15 /* IF */;
        origin.endsInDiscontinuity = true;
        origin.discontinuityCanBeCleared = true;
        const departure = airportInfo.departures[departureIndex];
        if (departure) {
          origin.additionalData.annotation = departure.name;
        } else {
          origin.additionalData.annotation = "";
        }
      }
      if (origin && selectedOriginRunwayIndex >= 0) {
        origin.infos.coordinates = airportInfo.oneWayRunways[selectedOriginRunwayIndex].beginningCoordinates;
        origin.additionalData.runwayElevation = airportInfo.oneWayRunways[selectedOriginRunwayIndex].elevation * 3.2808399;
        origin.additionalData.runwayLength = airportInfo.oneWayRunways[selectedOriginRunwayIndex].length;
      }
      if (departureIndex >= 0 && runwayIndex >= 0) {
        const runwayTransition = airportInfo.departures[departureIndex].runwayTransitions[runwayIndex];
        const departure = airportInfo.departures[departureIndex];
        if (runwayTransition) {
          legs.push(...runwayTransition.legs);
          legAnnotations.push(...runwayTransition.legs.map((_) => departure.name));
          origin.endsInDiscontinuity = false;
          origin.discontinuityCanBeCleared = void 0;
        }
      }
      if (departureIndex >= 0) {
        const departure = airportInfo.departures[departureIndex];
        legs.push(...departure.commonLegs);
        legAnnotations.push(...departure.commonLegs.map((_) => departure.name));
      }
      if (transitionIndex >= 0 && departureIndex >= 0) {
        if (airportInfo.departures[departureIndex].enRouteTransitions.length > 0) {
          const transition = airportInfo.departures[departureIndex].enRouteTransitions[transitionIndex];
          legs.push(...transition.legs);
          legAnnotations.push(...transition.legs.map((_) => transition.name));
        }
      }
      let segment = this.departure;
      if (segment !== FlightPlanSegment.Empty) {
        for (let i = 0; i < segment.waypoints.length; i++) {
          this.removeWaypoint(segment.offset);
        }
        this.removeSegment(segment.type);
      }
      if (legs.length > 0 || selectedOriginRunwayIndex >= 0 || departureIndex >= 0 && runwayIndex >= 0) {
        segment = this.addSegment(1 /* Departure */);
        const procedure = new LegsProcedure(legs, origin, this._parentInstrument, airportMagVar, void 0, legAnnotations);
        const runway = this.getOriginRunway();
        if (runway) {
          if (departureIndex < 0 && transitionIndex < 0) {
            const TEMPORARY_VERTICAL_SPEED = 2e3;
            const TEMPORARY_GROUND_SPEED = 160;
            const altitudeFeet = runway.elevation * 3.2808399 + 1500;
            const distanceInNM = altitudeFeet / TEMPORARY_VERTICAL_SPEED * (TEMPORARY_GROUND_SPEED / 60);
            const coordinates = GeoMath.relativeBearingDistanceToCoords(runway.direction, distanceInNM, runway.endCoordinates);
            const faLeg = procedure.buildWaypoint(`${Math.round(altitudeFeet)}`, coordinates);
            faLeg.endsInDiscontinuity = true;
            faLeg.discontinuityCanBeCleared = true;
            this.addWaypoint(faLeg, void 0, segment.type);
          }
        }
        let waypointIndex = segment.offset;
        while (procedure.hasNext()) {
          const waypoint = await procedure.getNext();
          if (waypoint !== void 0) {
            waypoint.additionalData.constraintType = WaypointConstraintType.CLB;
            this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
          }
        }
      }
      this.restringSegmentBoundaries(1 /* Departure */, 2 /* Enroute */);
    }
    async rebuildArrivalApproach() {
      this.truncateSegment(3 /* Arrival */);
      this.truncateSegment(4 /* Approach */);
      this.truncateSegment(5 /* Missed */);
      await this.buildArrival().catch(console.error);
      await this.buildApproach().catch(console.error);
    }
    async buildArrival() {
      const legs = [];
      const legAnnotations = [];
      const destination = this.destinationAirfield;
      const { arrivalIndex } = this.procedureDetails;
      const { arrivalRunwayIndex } = this.procedureDetails;
      const { arrivalTransitionIndex } = this.procedureDetails;
      const destinationInfo = destination.infos;
      const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
      if (arrivalIndex >= 0 && arrivalTransitionIndex >= 0) {
        const transition = destinationInfo.arrivals[arrivalIndex].enRouteTransitions[arrivalTransitionIndex];
        if (transition !== void 0) {
          legs.push(...transition.legs);
          legAnnotations.push(...transition.legs.map((_) => transition.name));
        }
      }
      if (arrivalIndex >= 0) {
        const arrival = destinationInfo.arrivals[arrivalIndex];
        legs.push(...arrival.commonLegs);
        legAnnotations.push(...arrival.commonLegs.map((_) => arrival.name));
        const starHasOneRunwayTrans = arrival.commonLegs.length === 0 && arrival.runwayTransitions.length === 1;
        const approachIsRunwaySpecific = this.procedureDetails.destinationRunwayIndex >= 0;
        const runwayTransIndex = arrivalRunwayIndex < 0 && starHasOneRunwayTrans && !approachIsRunwaySpecific ? 0 : arrivalRunwayIndex;
        const runwayTransition = arrival.runwayTransitions[runwayTransIndex];
        if (runwayTransition) {
          legs.push(...runwayTransition.legs);
          legAnnotations.push(...runwayTransition.legs.map((_) => arrival.name));
        }
      }
      let { _startIndex, segment } = this.truncateSegment(3 /* Arrival */);
      if (legs.length > 0) {
        if (segment === FlightPlanSegment.Empty) {
          segment = this.addSegment(3 /* Arrival */);
          _startIndex = segment.offset;
        }
        const procedure = new LegsProcedure(legs, this.getWaypoint(segment.offset - 1), this._parentInstrument, airportMagVar, void 0, legAnnotations);
        let waypointIndex = segment.offset;
        while (procedure.hasNext()) {
          const waypoint = await procedure.getNext();
          if (waypoint) {
            waypoint.additionalData.constraintType = WaypointConstraintType.DES;
            this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
          }
        }
      }
      this.restringSegmentBoundaries(2 /* Enroute */, 3 /* Arrival */);
      this.restringSegmentBoundaries(3 /* Arrival */, 4 /* Approach */);
    }
    async buildApproach() {
      var _a, _b, _c;
      const legs = [];
      const legAnnotations = [];
      const missedLegs = [];
      const destination = this.destinationAirfield;
      this.procedureDetails.approachType = void 0;
      const { approachIndex } = this.procedureDetails;
      const { approachTransitionIndex } = this.procedureDetails;
      const { destinationRunwayIndex } = this.procedureDetails;
      const destinationInfo = destination.infos;
      const airportMagVar = Facilities.getMagVar(destinationInfo.coordinates.lat, destinationInfo.coordinates.long);
      const approach = destinationInfo.approaches[approachIndex];
      const approachName = approach && approach.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN ? approach.name : "";
      if (approachIndex >= 0 && approachTransitionIndex >= 0) {
        const transition = destinationInfo.approaches[approachIndex].transitions[approachTransitionIndex];
        legs.push(...transition.legs);
        legAnnotations.push(...transition.legs.map((_) => transition.name));
      }
      if (approachIndex >= 0) {
        const finalLegs = [...approach.finalLegs];
        const viaLastLegType = (_a = legs[legs.length - 1]) == null ? void 0 : _a.type;
        if (viaLastLegType === 16 /* PI */ && ((_b = finalLegs[0]) == null ? void 0 : _b.type) === 15 /* IF */) {
          finalLegs.splice(0, 1);
          if (((_c = finalLegs[0]) == null ? void 0 : _c.type) !== 4 /* CF */) {
            console.error("PI must be followed by CF!");
          }
        }
        this.procedureDetails.approachType = approach.approachType;
        legs.push(...finalLegs);
        legAnnotations.push(...finalLegs.map((_) => approachName));
        missedLegs.push(...approach.missedLegs);
      }
      let { _startIndex, segment } = this.truncateSegment(4 /* Approach */);
      if (legs.length > 0 || approachIndex >= 0 || destinationRunwayIndex >= 0) {
        if (segment === FlightPlanSegment.Empty) {
          segment = this.addSegment(4 /* Approach */);
          _startIndex = segment.offset;
          const prevWaypointIndex = segment.offset - 1;
          if (prevWaypointIndex > 0) {
            const prevWaypoint = this.getWaypoint(segment.offset - 1);
            if (!prevWaypoint.endsInDiscontinuity) {
              prevWaypoint.endsInDiscontinuity = true;
              prevWaypoint.discontinuityCanBeCleared = true;
            }
          }
        }
        const runway = this.getDestinationRunway();
        const procedure = new LegsProcedure(legs, this.getWaypoint(_startIndex - 1), this._parentInstrument, airportMagVar, this.procedureDetails.approachType, legAnnotations);
        let waypointIndex = _startIndex;
        while (procedure.hasNext()) {
          const waypoint = await procedure.getNext();
          if (waypoint !== void 0) {
            waypoint.additionalData.constraintType = WaypointConstraintType.DES;
            this.addWaypointAvoidingDuplicates(waypoint, ++waypointIndex, segment);
          }
        }
        if (runway) {
          this.destinationAirfield.infos.coordinates = runway.beginningCoordinates;
          this.destinationAirfield.legAltitudeDescription = 1;
          this.destinationAirfield.legAltitude1 = Math.round((runway.elevation * 3.28084 + 50) / 10) * 10;
          this.destinationAirfield.isRunway = true;
          if (approachIndex >= 0) {
            const lastLeg = approach.finalLegs[approach.finalLegs.length - 1];
            if (lastLeg.type === 4 /* CF */) {
              const magCourse = lastLeg.trueDegrees ? A32NX_Util.trueToMagnetic(lastLeg.course, Facilities.getMagVar(runway.beginningCoordinates.lat, runway.beginningCoordinates.long)) : lastLeg.course;
              this.destinationAirfield.additionalData.annotation = `C${magCourse.toFixed(0).padStart(3, "0")}\xB0`;
            } else {
              this.destinationAirfield.additionalData.annotation = approachName;
            }
            this.destinationAirfield.additionalData.verticalAngle = lastLeg.verticalAngle ? lastLeg.verticalAngle - 360 : void 0;
          }
          const wpBeforeDestIdx = this.waypoints.indexOf(this.destinationAirfield) - 1;
          if (wpBeforeDestIdx >= 0) {
            const wpBeforeDest = this.getWaypoint(wpBeforeDestIdx);
            if (wpBeforeDest.endsInDiscontinuity && wpBeforeDest.discontinuityCanBeCleared) {
              wpBeforeDest.endsInDiscontinuity = false;
            }
          }
        }
      }
      this.restringSegmentBoundaries(3 /* Arrival */, 4 /* Approach */);
    }
    static isXfLeg(leg) {
      var _a;
      switch ((_a = leg == null ? void 0 : leg.additionalData) == null ? void 0 : _a.legType) {
        case 4 /* CF */:
        case 7 /* DF */:
        case 15 /* IF */:
        case 17 /* RF */:
        case 18 /* TF */:
          return true;
        default:
          return false;
      }
    }
    static isFxLeg(leg) {
      var _a;
      switch ((_a = leg == null ? void 0 : leg.additionalData) == null ? void 0 : _a.legType) {
        case 8 /* FA */:
        case 9 /* FC */:
        case 10 /* FD */:
        case 11 /* FM */:
          return true;
        default:
          return false;
      }
    }
    static legsStartOrEndAtSameFix(legA, legB) {
      return legA.icao === legB.icao && (ManagedFlightPlan.isXfLeg(legA) && ManagedFlightPlan.isXfLeg(legB) || ManagedFlightPlan.isFxLeg(legA) && ManagedFlightPlan.isFxLeg(legB));
    }
    static climbConstraint(leg) {
      switch (leg.legAltitudeDescription) {
        case 1 /* At */:
        case 3 /* AtOrBelow */:
          return leg.legAltitude1;
        case 4 /* Between */:
          return Math.max(leg.legAltitude1, leg.legAltitude2);
        default:
          break;
      }
      return Infinity;
    }
    static descentConstraint(leg) {
      switch (leg.legAltitudeDescription) {
        case 1 /* At */:
        case 2 /* AtOrAbove */:
          return leg.legAltitude1;
        case 4 /* Between */:
          return Math.min(leg.legAltitude1, leg.legAltitude2);
        default:
          break;
      }
      return -Infinity;
    }
    static mergeConstraints(legA, legB) {
      let legAltitudeDescription = 0 /* Empty */;
      let legAltitude1 = 0;
      let legAltitude2 = 0;
      if (legA.legAltitudeDescription === 1 /* At */) {
        legAltitudeDescription = 1 /* At */;
        if (legB.legAltitudeDescription === 1 /* At */) {
          legAltitude1 = Math.min(legA.legAltitude1, legB.legAltitude1);
        } else {
          legAltitude1 = legA.legAltitude1;
        }
      } else if (legB.legAltitudeDescription === 1 /* At */) {
        legAltitudeDescription = 1 /* At */;
        legAltitude1 = legB.legAltitude1;
      } else if (legA.legAltitudeDescription > 0 || legB.legAltitudeDescription > 0) {
        const maxAlt = Math.min(ManagedFlightPlan.climbConstraint(legA), ManagedFlightPlan.climbConstraint(legB));
        const minAlt = Math.max(ManagedFlightPlan.descentConstraint(legA), ManagedFlightPlan.descentConstraint(legB));
        if (Number.isFinite(maxAlt)) {
          if (Number.isFinite(minAlt)) {
            if (Math.abs(minAlt - maxAlt) < 1) {
              legAltitudeDescription = 1 /* At */;
              legAltitude1 = minAlt;
            } else {
              legAltitudeDescription = 4 /* Between */;
              legAltitude1 = minAlt;
              legAltitude2 = maxAlt;
            }
          } else {
            legAltitudeDescription = 3 /* AtOrBelow */;
            legAltitude1 = maxAlt;
          }
        } else if (Number.isFinite(minAlt)) {
          legAltitudeDescription = 2 /* AtOrAbove */;
          legAltitude1 = minAlt;
        }
      }
      const speed = Math.min(legA.speedConstraint > 0 ? legA.speedConstraint : Infinity, legB.speedConstraint > 0 ? legB.speedConstraint : Infinity);
      return {
        legAltitudeDescription,
        legAltitude1,
        legAltitude2,
        speedConstraint: Number.isFinite(speed) ? speed : 0
      };
    }
    restringSegmentBoundaries(segmentTypeA, segmentTypeB) {
      if (segmentTypeB < segmentTypeA) {
        throw new Error("restringSegmentBoundaries: segmentTypeA must be before segmentTypeB");
      }
      const segmentA = this.getSegment(segmentTypeA);
      const segmentB = this.getSegment(segmentTypeB);
      if ((segmentA == null ? void 0 : segmentA.waypoints.length) < 1 || (segmentB == null ? void 0 : segmentB.waypoints.length) < 1) {
        return;
      }
      const lastLegIndexA = segmentA.offset + segmentA.waypoints.length - 1;
      const lastLegA = segmentA.waypoints[segmentA.waypoints.length - 1];
      const firstLegIndexB = segmentB.offset;
      const firstLegB = segmentB.waypoints[0];
      if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, firstLegB)) {
        const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
        if (segmentA.type === 1 /* Departure */) {
          this.removeWaypoint(firstLegIndexB, true);
          Object.assign(lastLegA, constraints);
          lastLegA.endsInDiscontinuity = false;
          lastLegA.discontinuityCanBeCleared = void 0;
        } else {
          this.removeWaypoint(lastLegIndexA, true);
          Object.assign(firstLegB, constraints);
          firstLegB.endsInDiscontinuity = false;
          firstLegB.discontinuityCanBeCleared = void 0;
        }
      } else if (segmentTypeA === 3 /* Arrival */ && segmentTypeB === 4 /* Approach */) {
        let toDeleteFromB = 0;
        for (let i = 0; i < segmentB.waypoints.length; i++) {
          if (ManagedFlightPlan.legsStartOrEndAtSameFix(lastLegA, segmentB.waypoints[i])) {
            const constraints = ManagedFlightPlan.mergeConstraints(lastLegA, firstLegB);
            Object.assign(lastLegA, constraints);
            toDeleteFromB = i + 1;
            break;
          }
        }
        for (let i = 0; i < toDeleteFromB; i++) {
          this.removeWaypoint(segmentB.offset, true);
        }
        if (toDeleteFromB === 0 && firstLegB.additionalData.legType === 15 /* IF */) {
          lastLegA.endsInDiscontinuity = true;
          lastLegA.discontinuityCanBeCleared = true;
        }
      }
    }
    truncateSegment(type) {
      let segment = this.getSegment(type);
      const startIndex = segment.offset;
      if (segment !== FlightPlanSegment.Empty) {
        const finalIndex = segment.offset + segment.waypoints.length;
        if (startIndex < finalIndex) {
          for (let i = startIndex; i < finalIndex; i++) {
            this.removeWaypoint(startIndex);
          }
        }
      }
      if (segment.waypoints.length === 0) {
        this.removeSegment(segment.type);
        segment = FlightPlanSegment.Empty;
      } else {
        const waypoint = segment.waypoints[Math.max(startIndex - 1 - segment.offset, 0)];
        waypoint.endsInDiscontinuity = true;
        waypoint.discontinuityCanBeCleared = true;
      }
      return { _startIndex: startIndex, segment };
    }
    static fromObject(flightPlanObject, parentInstrument) {
      const plan = Object.assign(new ManagedFlightPlan(), flightPlanObject);
      plan.setParentInstrument(parentInstrument);
      plan.directTo = Object.assign(new DirectTo(), plan.directTo);
      const mapObject2 = (obj, parentType) => {
        if (obj && obj.infos) {
          obj = Object.assign(new WayPoint(parentInstrument), obj);
        }
        if (obj && obj.coordinates) {
          switch (parentType) {
            case "A":
              obj = Object.assign(new AirportInfo(parentInstrument), obj);
              break;
            case "W":
              obj = Object.assign(new IntersectionInfo(parentInstrument), obj);
              break;
            case "V":
              obj = Object.assign(new VORInfo(parentInstrument), obj);
              break;
            case "N":
              obj = Object.assign(new NDBInfo(parentInstrument), obj);
              break;
            default:
              obj = Object.assign(new WayPointInfo(parentInstrument), obj);
          }
          obj.coordinates = Object.assign(new LatLongAlt(), obj.coordinates);
        }
        return obj;
      };
      const visitObject = (obj) => {
        for (const key in obj) {
          if (typeof obj[key] === "object" && obj[key] && obj[key].scroll === void 0) {
            if (Array.isArray(obj[key])) {
              visitArray(obj[key]);
            } else {
              visitObject(obj[key]);
            }
            obj[key] = mapObject2(obj[key], obj.type);
          }
        }
      };
      const visitArray = (array) => {
        array.forEach((item, index) => {
          if (Array.isArray(item)) {
            visitArray(item);
          } else if (typeof item === "object") {
            visitObject(item);
          }
          array[index] = mapObject2(item);
        });
      };
      visitObject(plan);
      return plan;
    }
    legDataMatches(a, b, fields) {
      return fields.every((field) => a.additionalData[field] === b.additionalData[field]);
    }
    isLegDuplicate(a, b) {
      if (a.additionalData.legType === b.additionalData.legType) {
        switch (a.additionalData.legType) {
          case 1 /* AF */:
          case 6 /* CR */:
          case 23 /* VR */:
            return this.legDataMatches(a, b, ["course", "theta", "recommendedIcao"]);
          case 2 /* CA */:
          case 19 /* VA */:
            return this.legDataMatches(a, b, ["course"]) && a.legAltitude1 === b.legAltitude1;
          case 3 /* CD */:
          case 20 /* VD */:
            return this.legDataMatches(a, b, ["course", "distance", "recommendedIcao"]);
          case 4 /* CF */:
            return this.legDataMatches(a, b, ["course"]) && a.icao === b.icao;
          case 5 /* CI */:
          case 21 /* VI */:
          case 22 /* VM */:
            return this.legDataMatches(a, b, ["course"]);
          case 7 /* DF */:
          case 15 /* IF */:
          case 18 /* TF */:
            return a.icao === b.icao;
          case 8 /* FA */:
            return a.icao === b.icao && a.legAltitude1 === b.legAltitude1;
          case 9 /* FC */:
            return this.legDataMatches(a, b, ["course", "distance"]) && a.icao === b.icao;
          case 10 /* FD */:
            return this.legDataMatches(a, b, ["course", "distance", "recommendedIcao"]) && a.icao === b.icao;
          case 11 /* FM */:
            return this.legDataMatches(a, b, ["course"]) && a.icao === b.icao;
          case 12 /* HA */:
            return this.legDataMatches(a, b, ["course", "distance", "distanceInMinutes"]) && a.icao === b.icao && a.legAltitude1 === b.legAltitude1;
          case 13 /* HF */:
          case 14 /* HM */:
          case 16 /* PI */:
            return this.legDataMatches(a, b, ["course", "distance", "distanceInMinutes"]) && a.icao === b.icao;
          case 17 /* RF */:
            return this.legDataMatches(a, b, ["center", "radius"]) && a.icao === b.icao;
          default:
        }
      } else if (ManagedFlightPlan.isXfLeg(a) && ManagedFlightPlan.isXfLeg(b) || ManagedFlightPlan.isFxLeg(a) && ManagedFlightPlan.isFxLeg(b)) {
        return a.icao === b.icao;
      }
      return false;
    }
    addWaypointAvoidingDuplicates(waypoint, waypointIndex, segment) {
      const index = this.waypoints.findIndex((wp) => this.isLegDuplicate(waypoint, wp));
      const wptDist = Math.abs(index - waypointIndex);
      if (index !== -1 && wptDist <= 2) {
        const removedWp = this.getWaypoint(index);
        if (waypoint.legAltitudeDescription === 0 /* Empty */ && removedWp.legAltitudeDescription !== 0 /* Empty */) {
          waypoint.legAltitudeDescription = removedWp.legAltitudeDescription;
          waypoint.legAltitude1 = removedWp.legAltitude1;
          waypoint.legAltitude2 = removedWp.legAltitude2;
        }
        if (waypoint.speedConstraint <= 0 && removedWp.speedConstraint > 0) {
          waypoint.speedConstraint = removedWp.speedConstraint;
        }
        this.removeWaypoint(index);
      }
      this.addWaypoint(waypoint, waypointIndex, segment.type);
    }
    getOriginRunway() {
      if (this.originAirfield) {
        if (this.procedureDetails.originRunwayIndex >= 0) {
          return this.originAirfield.infos.oneWayRunways[this.procedureDetails.originRunwayIndex];
        }
      }
      return null;
    }
    getDestinationRunway() {
      if (this.destinationAirfield) {
        if (this.procedureDetails.destinationRunwayIndex >= 0) {
          return this.destinationAirfield.infos.oneWayRunways[this.procedureDetails.destinationRunwayIndex];
        }
      }
      return null;
    }
    get manualHoldActive() {
      var _a, _b;
      return ((_b = (_a = this.waypoints[this.activeWaypointIndex]) == null ? void 0 : _a.additionalData) == null ? void 0 : _b.legType) === 14 /* HM */;
    }
    get glideslopeIntercept() {
      const appr = this.getSegment(4 /* Approach */);
      for (const wp of appr.waypoints) {
        if (wp.additionalData.fixTypeFlags & 8 /* FAF */ && (wp.legAltitudeDescription === 6 /* G */ || wp.legAltitudeDescription === 7 /* H */)) {
          return wp.legAltitude1;
        }
      }
      return void 0;
    }
    get destinationIndex() {
      const appr = this.getSegment(4 /* Approach */);
      const index = appr.offset + appr.waypoints.length;
      if (this.destinationAirfield) {
        return index + 1;
      }
      return -1;
    }
    get finalApproachActive() {
      const appr = this.getSegment(4 /* Approach */);
      if (appr === FlightPlanSegment.Empty) {
        return false;
      }
      const offset = this.activeWaypointIndex - appr.offset;
      if (offset >= 0 && offset < appr.waypoints.length) {
        for (const [index, wp] of appr.waypoints.entries()) {
          if (wp.additionalData.fixTypeFlags & 8 /* FAF */) {
            return offset >= index;
          }
        }
      }
      return false;
    }
    static round(n, r = 1) {
      if (n === void 0 || n === null) {
        return n;
      }
      return Math.round(n / r) * r;
    }
    setOriginDefaults(airport) {
      const referenceAltitude = airport.infos.elevation;
      if (referenceAltitude !== void 0) {
        this.thrustReductionAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_THR_RED_ALT", "1500"));
        this.accelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ACCEL_ALT", "1500"));
        this.engineOutAccelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ENG_OUT_ACCEL_ALT", "1500"));
      } else {
        this.thrustReductionAltitudeDefault = void 0;
        this.accelerationAltitudeDefault = void 0;
        this.engineOutAccelerationAltitudeDefault = void 0;
      }
      this.thrustReductionAltitudePilot = void 0;
      this.accelerationAltitudePilot = void 0;
      this.engineOutAccelerationAltitudePilot = void 0;
    }
    setDestinationDefaults(airport) {
      const referenceAltitude = airport.infos.elevation;
      if (referenceAltitude !== void 0) {
        this.missedThrustReductionAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_THR_RED_ALT", "1500"));
        this.missedAccelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ACCEL_ALT", "1500"));
        this.missedEngineOutAccelerationAltitudeDefault = referenceAltitude + parseInt(NXDataStore.get("CONFIG_ENG_OUT_ACCEL_ALT", "1500"));
      } else {
        this.missedThrustReductionAltitudeDefault = void 0;
        this.missedAccelerationAltitudeDefault = void 0;
        this.missedEngineOutAccelerationAltitudeDefault = void 0;
      }
      this.missedThrustReductionAltitudePilot = void 0;
      this.missedAccelerationAltitudePilot = void 0;
      this.missedEngineOutAccelerationAltitudePilot = void 0;
    }
    get thrustReductionAltitude() {
      var _a;
      return ManagedFlightPlan.round((_a = this.thrustReductionAltitudePilot) != null ? _a : this.thrustReductionAltitudeDefault, 10);
    }
    get isThrustReductionAltitudePilotEntered() {
      return this.thrustReductionAltitudePilot !== void 0;
    }
    get hasThrustReductionAltitudeDefault() {
      return this.thrustReductionAltitudeDefault !== void 0;
    }
    get accelerationAltitude() {
      var _a;
      return ManagedFlightPlan.round((_a = this.accelerationAltitudePilot) != null ? _a : this.accelerationAltitudeDefault, 10);
    }
    get isAccelerationAltitudePilotEntered() {
      return this.accelerationAltitudePilot !== void 0;
    }
    get hasAccelerationAltitudeDefault() {
      return this.accelerationAltitudeDefault !== void 0;
    }
    get engineOutAccelerationAltitude() {
      var _a;
      return ManagedFlightPlan.round((_a = this.engineOutAccelerationAltitudePilot) != null ? _a : this.engineOutAccelerationAltitudeDefault, 10);
    }
    get isEngineOutAccelerationAltitudePilotEntered() {
      return this.engineOutAccelerationAltitudePilot !== void 0;
    }
    get hasEngineOutAccelerationAltitudeDefault() {
      return this.engineOutAccelerationAltitudeDefault !== void 0;
    }
    get missedThrustReductionAltitude() {
      var _a;
      return ManagedFlightPlan.round((_a = this.missedThrustReductionAltitudePilot) != null ? _a : this.missedThrustReductionAltitudeDefault, 10);
    }
    get isMissedThrustReductionAltitudePilotEntered() {
      return this.missedThrustReductionAltitudePilot !== void 0;
    }
    get hasMissedThrustReductionAltitudeDefault() {
      return this.missedThrustReductionAltitudeDefault !== void 0;
    }
    get missedAccelerationAltitude() {
      var _a;
      return ManagedFlightPlan.round((_a = this.missedAccelerationAltitudePilot) != null ? _a : this.missedAccelerationAltitudeDefault, 10);
    }
    get isMissedAccelerationAltitudePilotEntered() {
      return this.missedAccelerationAltitudePilot !== void 0;
    }
    get hasMissedAccelerationAltitudeDefault() {
      return this.missedAccelerationAltitudeDefault !== void 0;
    }
    get missedEngineOutAccelerationAltitude() {
      var _a;
      return ManagedFlightPlan.round((_a = this.missedEngineOutAccelerationAltitudePilot) != null ? _a : this.missedEngineOutAccelerationAltitudeDefault, 10);
    }
    get isMissedEngineOutAccelerationAltitudePilotEntered() {
      return this.missedEngineOutAccelerationAltitudePilot !== void 0;
    }
    get hasMissedEngineOutAccelerationAltitudeDefault() {
      return this.missedEngineOutAccelerationAltitudeDefault !== void 0;
    }
    lowestClimbConstraint() {
      let lowestClimbConstraint = Infinity;
      for (const wp of this.waypoints) {
        const climbConstraint = wp.additionalData.constraintType === WaypointConstraintType.CLB ? ManagedFlightPlan.climbConstraint(wp) : Infinity;
        if (climbConstraint < lowestClimbConstraint) {
          lowestClimbConstraint = climbConstraint;
        }
      }
      return lowestClimbConstraint;
    }
    reconcileThrustReductionWithConstraints() {
      const lowestClimbConstraint = this.lowestClimbConstraint();
      if (isFinite(lowestClimbConstraint) && this.thrustReductionAltitude > lowestClimbConstraint) {
        this.thrustReductionAltitudeDefault = this.thrustReductionAltitudeDefault !== void 0 ? Math.min(this.thrustReductionAltitudeDefault, lowestClimbConstraint) : void 0;
        this.thrustReductionAltitudePilot = this.thrustReductionAltitudePilot !== void 0 ? Math.min(this.thrustReductionAltitudePilot, lowestClimbConstraint) : void 0;
        return true;
      }
      return false;
    }
    reconcileAccelerationWithConstraints() {
      const lowestClimbConstraint = this.lowestClimbConstraint();
      if (isFinite(lowestClimbConstraint) && this.accelerationAltitude > lowestClimbConstraint) {
        this.accelerationAltitudeDefault = this.accelerationAltitudeDefault !== void 0 ? Math.min(this.accelerationAltitudeDefault, lowestClimbConstraint) : void 0;
        this.accelerationAltitudePilot = this.accelerationAltitudePilot !== void 0 ? Math.min(this.accelerationAltitudePilot, lowestClimbConstraint) : void 0;
        return true;
      }
      return false;
    }
    addOrUpdateCruiseStep(waypoint, toAltitude, waypointIndex) {
      if (!waypointIndex) {
        waypointIndex = this.findWaypointIndexByIdent(waypoint.ident);
      }
      const step = {
        distanceBeforeTermination: 0,
        toAltitude,
        waypointIndex,
        isIgnored: false
      };
      waypoint.additionalData.cruiseStep = step;
    }
    removeCruiseStep(waypoint) {
      waypoint.additionalData.cruiseStep = void 0;
    }
    findWaypointIndexByIdent(ident) {
      return this.waypoints.findIndex((waypoint) => waypoint.ident === ident);
    }
    unignoreAllCruiseSteps() {
      this.cruiseStepWaypoints.forEach((step) => step.additionalData.cruiseStep.isIgnored = false);
    }
  };

  // src/systems/fmgc/src/flightplanning/FlightPlanAsoboSync.ts
  var _FlightPlanAsoboSync = class {
    static init() {
      if (!this.fpListenerInitialized) {
        RegisterViewListener("JS_LISTENER_FLIGHTPLAN");
        this.fpListenerInitialized = true;
      }
    }
    static async LoadFromGame(fpln) {
      return new Promise((resolve) => {
        this.init();
        setTimeout(() => {
          Coherent.call("LOAD_CURRENT_GAME_FLIGHT").catch(console.error);
          Coherent.call("LOAD_CURRENT_ATC_FLIGHTPLAN").catch(console.error);
          setTimeout(() => {
            Coherent.call("GET_FLIGHTPLAN").then(async (data) => {
              console.log("COHERENT GET_FLIGHTPLAN received:");
              console.log("Data from MSFS flight plan:", data);
              const { isDirectTo } = data;
              if (isDirectTo) {
                return;
              }
              if (data.waypoints.length === 0 || data.waypoints[0].icao[0] !== "A") {
                fpln.resumeSync();
                resolve();
                return;
              }
              await fpln._parentInstrument.facilityLoader.getFacilityRaw(data.waypoints[0].icao, 1e4).catch((e) => {
                console.error("[FP LOAD] Error getting first wp data");
                console.error(e);
              });
              await fpln.setOrigin(data.waypoints[0].icao).catch((e) => {
                console.error("[FP LOAD] Error setting origin");
                console.error(e);
              });
              await fpln.setDestination(data.waypoints[data.waypoints.length - 1].icao).catch((e) => {
                console.error("[FP LOAD] Error setting Destination");
                console.error(e);
              });
              const enrouteStart = data.departureWaypointsSize === -1 ? 1 : data.departureWaypointsSize;
              const enrouteEnd = data.waypoints.length - (data.arrivalWaypointsSize === -1 ? 0 : data.arrivalWaypointsSize) - 1;
              const enroute = data.waypoints.slice(enrouteStart, enrouteEnd);
              for (let i = 0; i < enroute.length; i++) {
                const wpt = enroute[i];
                if (wpt.icao.trim() !== "") {
                  await fpln.addWaypoint(
                    wpt.icao,
                    Infinity,
                    () => {
                    }
                  ).catch(console.error);
                }
              }
              await fpln.setDepartureRunwayIndex(data.departureRunwayIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Departure Runway ${data.departureRunwayIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setDepartureProcIndex(data.departureProcIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Departure Procedure ${data.departureProcIndex} ... FAILED`);
                console.error(e);
              });
              if (data.originRunwayIndex !== -1) {
                await fpln.setOriginRunwayIndex(data.originRunwayIndex).catch((e) => {
                  console.error(`[FP LOAD] Setting Origin ${data.originRunwayIndex} ... FAILED`);
                  console.error(e);
                });
              } else if (data.departureRunwayIndex !== -1 && data.departureProcIndex !== -1) {
                await fpln.setOriginRunwayIndexFromDeparture().catch((e) => {
                  console.error(`[FP LOAD] Setting Origin using ${data.departureProcIndex}/${data.departureRunwayIndex} ... FAILED`);
                  console.error(e);
                });
              }
              await fpln.setDepartureEnRouteTransitionIndex(data.departureEnRouteTransitionIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Departure En Route Transition ${data.departureEnRouteTransitionIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setArrivalRunwayIndex(data.arrivalRunwayIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Arrival Runway ${data.arrivalRunwayIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setApproachIndex(data.approachIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Approach ${data.approachIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setApproachTransitionIndex(data.approachTransitionIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Approach Transition ${data.approachTransitionIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setArrivalProcIndex(data.arrivalProcIndex).catch((e) => {
                console.error(`[FP LOAD] Setting Arrival Procedure ${data.arrivalProcIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setArrivalEnRouteTransitionIndex(data.arrivalEnRouteTransitionIndex).catch((e) => {
                console.error(`[FP LOAD] Setting En Route Transition ${data.arrivalEnRouteTransitionIndex} ... FAILED`);
                console.error(e);
              });
              await fpln.setDestinationRunwayIndexFromApproach().catch((e) => {
                console.error(`[FP LOAD] Setting Destination Runway using ${data.approachIndex} ... FAILED`);
                console.error(e);
              });
              fpln.resumeSync();
              this.fpChecksum = fpln.getCurrentFlightPlan().checksum;
              Coherent.call("SET_ACTIVE_WAYPOINT_INDEX", 0).catch((e) => console.error("[FP LOAD] Error when setting Active WP", e));
              Coherent.call("RECOMPUTE_ACTIVE_WAYPOINT_INDEX").catch((e) => console.error("[FP LOAD] Error when recomputing Active WP", e));
              resolve();
              console.log("Resulting aircraft flight plan: ", fpln);
            }).catch(console.error);
          }, 500);
        }, 200);
      });
    }
    static async SaveToGame(fpln) {
      return __awaiter(this, 0, 0, function* () {
        return new Promise(() => __awaiter(this, 0, 0, function* () {
          _FlightPlanAsoboSync.init();
          const plan = fpln.getCurrentFlightPlan();
          if (plan.checksum !== this.fpChecksum) {
            yield Coherent.call("SET_CURRENT_FLIGHTPLAN_INDEX", 0, false).catch(console.error);
            yield Coherent.call("CLEAR_CURRENT_FLIGHT_PLAN").catch(console.error);
            if (plan.hasPersistentOrigin && plan.hasDestination) {
              yield Coherent.call("SET_ORIGIN", plan.persistentOriginAirfield.icao, false).catch(console.error);
              yield Coherent.call("SET_DESTINATION", plan.destinationAirfield.icao, false).catch(console.error);
              let coIndex = 1;
              for (let i = 0; i < plan.enroute.waypoints.length; i++) {
                const wpt = plan.enroute.waypoints[i];
                if (wpt.icao.trim() !== "") {
                  yield Coherent.call("ADD_WAYPOINT", wpt.icao, coIndex, false).catch(console.error);
                  coIndex++;
                }
              }
              yield Coherent.call("SET_ORIGIN_RUNWAY_INDEX", plan.procedureDetails.originRunwayIndex).catch((e) => {
                console.error(`[FP SAVE] Setting Origin Runway ${plan.procedureDetails.originRunwayIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_DEPARTURE_RUNWAY_INDEX", plan.procedureDetails.departureRunwayIndex).catch((e) => {
                console.error(`[FP SAVE] Setting Departure Runway ${plan.procedureDetails.departureRunwayIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_DEPARTURE_PROC_INDEX", plan.procedureDetails.departureIndex).catch((e) => {
                console.error(`[FP SAVE] Setting Departure Procedure ${plan.procedureDetails.departureIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_DEPARTURE_ENROUTE_TRANSITION_INDEX", plan.procedureDetails.departureTransitionIndex).catch((e) => {
                console.error(`[FP SAVE] Setting Departure Transition ${plan.procedureDetails.departureTransitionIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_ARRIVAL_RUNWAY_INDEX", plan.procedureDetails.arrivalRunwayIndex).catch((e) => {
                console.error(`[FP SAVE] Setting  Arrival Runway ${plan.procedureDetails.arrivalRunwayIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_ARRIVAL_PROC_INDEX", plan.procedureDetails.arrivalIndex).catch((e) => {
                console.error(`[FP SAVE] Setting Arrival Procedure ${plan.procedureDetails.arrivalIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_ARRIVAL_ENROUTE_TRANSITION_INDEX", plan.procedureDetails.arrivalTransitionIndex).catch((e) => {
                console.error(`[FP SAVE] Setting Arrival En Route Transition ${plan.procedureDetails.arrivalTransitionIndex} ... FAILED`);
                console.error(e);
              });
              yield Coherent.call("SET_APPROACH_INDEX", plan.procedureDetails.approachIndex).then(() => {
                Coherent.call("SET_APPROACH_TRANSITION_INDEX", plan.procedureDetails.approachTransitionIndex).catch((e) => {
                  console.error(`[FP SAVE] Setting Approach Transition ${plan.procedureDetails.approachTransitionIndex} ... FAILED`);
                  console.error(e);
                });
              }).catch((e) => {
                console.error(`[FP SAVE] Setting Approach ${plan.procedureDetails.approachIndex} ... FAILED`);
                console.error(e);
              });
            }
            this.fpChecksum = plan.checksum;
          }
          Coherent.call("RECOMPUTE_ACTIVE_WAYPOINT_INDEX").catch((e) => console.log("[FP SAVE] Setting Active Waypoint... FAILED: ", e));
        }));
      });
    }
  };
  var FlightPlanAsoboSync = _FlightPlanAsoboSync;
  __publicField(FlightPlanAsoboSync, "fpChecksum", 0);
  __publicField(FlightPlanAsoboSync, "fpListenerInitialized", false);
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2((resolve) => {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))((resolve, reject) => {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  // src/systems/fmgc/src/flightplanning/FixInfo.ts
  var FixInfo = class {
    constructor(flightPlanManager) {
      __publicField(this, "flightPlanManager");
      __publicField(this, "refFix");
      __publicField(this, "radials", []);
      __publicField(this, "radius");
      __publicField(this, "abeam", false);
      this.flightPlanManager = flightPlanManager;
    }
    setRefFix(fix) {
      this.radials.length = 0;
      this.radius = void 0;
      this.abeam = false;
      this.refFix = fix;
      this.flightPlanManager.updateFlightPlanVersion();
    }
    getRefFix() {
      return this.refFix;
    }
    getRefFixIdent() {
      var _a;
      return (_a = this.refFix) == null ? void 0 : _a.ident;
    }
    setRadial(index, magneticBearing) {
      if (magneticBearing !== void 0) {
        const trueBearing = Avionics.Utils.clampAngle(magneticBearing + Facilities.getMagVar(this.refFix.infos.coordinates.lat, this.refFix.infos.coordinates.long));
        this.radials[index] = { magneticBearing, trueBearing };
      } else {
        this.radials.splice(index, 1);
      }
      this.flightPlanManager.updateFlightPlanVersion();
    }
    getRadial(index) {
      return this.radials[index];
    }
    getRadialTrueBearings() {
      return this.radials.map((r) => r.trueBearing);
    }
    setRadius(radius) {
      if (radius !== void 0) {
        this.radius = { radius };
      } else {
        this.radius = void 0;
      }
      this.flightPlanManager.updateFlightPlanVersion();
    }
    getRadius() {
      return this.radius;
    }
    getRadiusValue() {
      var _a;
      return (_a = this.radius) == null ? void 0 : _a.radius;
    }
  };

  // src/systems/fmgc/src/flightplanning/FlightPlanManager.ts
  var _FlightPlanManager = class {
    constructor(_parentInstrument) {
      this._parentInstrument = _parentInstrument;
      __publicField(this, "_isRegistered", false);
      __publicField(this, "_isMaster", false);
      __publicField(this, "_isSyncPaused", false);
      __publicField(this, "_currentFlightPlanVersion", 0);
      __publicField(this, "__currentFlightPlanIndex", 0);
      __publicField(this, "activeArea", 0 /* Terminal */);
      __publicField(this, "_flightPlans", []);
      __publicField(this, "_fixInfos", []);
      __publicField(this, "updateThrottler", new A32NX_Util.UpdateThrottler(2e3));
      this._currentFlightPlanVersion = SimVar.GetSimVarValue(_FlightPlanManager.FlightPlanVersionKey, "number");
      this._loadFlightPlans();
      if (_parentInstrument.instrumentIdentifier === "A320_Neo_CDU") {
        this._isMaster = true;
        _parentInstrument.addEventListener("FlightStart", async () => {
          const plan = new ManagedFlightPlan();
          plan.setParentInstrument(_parentInstrument);
          this._flightPlans = [];
          this._flightPlans.push(plan);
          if (NXDataStore.get("FP_SYNC", "LOAD") !== "NONE") {
            this.pauseSync();
            await FlightPlanAsoboSync.LoadFromGame(this).catch(console.error);
          }
          this.resumeSync();
        });
        for (let i = 0; i < 4; i++) {
          this._fixInfos.push(new FixInfo(this));
        }
      }
      _FlightPlanManager.DEBUG_INSTANCE = this;
    }
    get _currentFlightPlanIndex() {
      return this.__currentFlightPlanIndex;
    }
    set _currentFlightPlanIndex(value) {
      this.__currentFlightPlanIndex = value;
    }
    update(deltaTime) {
      if (this.updateThrottler.canUpdate(deltaTime) !== -1) {
        const tmpy = this._flightPlans[1 /* Temporary */];
        if (tmpy && this.__currentFlightPlanIndex === 1 /* Temporary */) {
          if (tmpy.updateTurningPoint()) {
            this.updateFlightPlanVersion();
          }
        }
      }
      this.updateActiveArea();
    }
    onCurrentGameFlightLoaded(_callback) {
      _callback();
    }
    registerListener() {
    }
    addHardCodedConstraints(wp) {
    }
    _loadWaypoints(data, currentWaypoints, callback) {
    }
    async updateWaypointIndex() {
    }
    updateFlightPlan(callback = () => {
    }, log3 = false, force = false) {
      const flightPlanVersion = SimVar.GetSimVarValue(_FlightPlanManager.FlightPlanVersionKey, "number");
      if (flightPlanVersion !== this._currentFlightPlanVersion || force) {
        this._loadFlightPlans();
        this._currentFlightPlanVersion = flightPlanVersion;
      }
      callback();
    }
    _loadFlightPlans() {
      this._getFlightPlan();
      if (this._flightPlans.length === 0) {
        const newFpln = new ManagedFlightPlan();
        newFpln.setParentInstrument(this._parentInstrument);
        this._flightPlans.push(new ManagedFlightPlan());
      } else {
        this._flightPlans = this._flightPlans.map((fp) => ManagedFlightPlan.fromObject(fp, this._parentInstrument));
      }
    }
    updateCurrentApproach(callback = () => {
    }, log3 = false) {
      callback();
    }
    get cruisingAltitude() {
      return 0;
    }
    isCurrentFlightPlanTemporary() {
      return this.getCurrentFlightPlanIndex() === 1;
    }
    getCurrentFlightPlanIndex() {
      return this._currentFlightPlanIndex;
    }
    setCurrentFlightPlanIndex(index, callback = EmptyCallback.Boolean) {
      if (index >= 0 && index < this._flightPlans.length) {
        this._currentFlightPlanIndex = index;
        callback(true);
      } else {
        callback(false);
      }
    }
    createNewFlightPlan(callback = EmptyCallback.Void) {
      const newFlightPlan = new ManagedFlightPlan();
      newFlightPlan.setParentInstrument(this._parentInstrument);
      this._flightPlans.push(newFlightPlan);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async copyCurrentFlightPlanInto(index, callback = EmptyCallback.Void) {
      const copiedFlightPlan = this._flightPlans[this._currentFlightPlanIndex].copy();
      const { activeWaypointIndex } = copiedFlightPlan;
      if (this._currentFlightPlanIndex === 1 /* Temporary */ && index === 0 /* Active */) {
        copiedFlightPlan.waypoints.forEach((wp) => delete wp.additionalData.dynamicPpos);
      }
      this._flightPlans[index] = copiedFlightPlan;
      if (index === 0) {
        await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async copyFlightPlanIntoCurrent(index, callback = EmptyCallback.Void) {
      const copiedFlightPlan = this._flightPlans[index].copy();
      const { activeWaypointIndex } = copiedFlightPlan;
      this._flightPlans[this._currentFlightPlanIndex] = copiedFlightPlan;
      if (this._currentFlightPlanIndex === 0) {
        await GPS.setActiveWaypoint(activeWaypointIndex).catch(console.error);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async clearFlightPlan(callback = EmptyCallback.Void) {
      await this._flightPlans[this._currentFlightPlanIndex].clearPlan().catch(console.error);
      for (const fixInfo of this._fixInfos) {
        fixInfo.setRefFix();
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async deleteFlightPlan(flightPlanIndex) {
      if (this._flightPlans[flightPlanIndex]) {
        delete this._flightPlans[flightPlanIndex];
      }
    }
    getOrigin(flightPlanIndex = this._currentFlightPlanIndex) {
      return this._flightPlans[flightPlanIndex].originAirfield;
    }
    getPersistentOrigin(flightPlanIndex = this._currentFlightPlanIndex) {
      return this._flightPlans[flightPlanIndex].persistentOriginAirfield;
    }
    async setOrigin(icao, callback = () => {
    }) {
      var _a;
      const sameAirport = ((_a = this.getOrigin()) == null ? void 0 : _a.ident) === icao;
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const airport = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch(console.error);
      if (airport) {
        airport.additionalData = {};
        airport.additionalData.legType = 15 /* IF */;
        await currentFlightPlan.clearPlan().catch(console.error);
        await currentFlightPlan.addWaypoint(airport, 0);
        this.setOriginTransitionAltitude(void 0, false);
        if (!sameAirport) {
          this.setOriginTransitionAltitude(void 0, true);
        }
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    getActiveWaypointIndex(forceSimVarCall = false, useCorrection = false, flightPlanIndex = NaN) {
      var _a, _b;
      if (Number.isNaN(flightPlanIndex)) {
        return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
      }
      return (_b = (_a = this._flightPlans[flightPlanIndex]) == null ? void 0 : _a.activeWaypointIndex) != null ? _b : -1;
    }
    isActiveWaypointAtEnd(forceSimVarCall = false, useCorrection = false, flightPlanIndex = NaN) {
      if (Number.isNaN(flightPlanIndex)) {
        return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex + 1 === this.getWaypointsCount(this._currentFlightPlanIndex) - 1;
      }
      return this._flightPlans[flightPlanIndex].activeWaypointIndex === this.getWaypointsCount(flightPlanIndex) - 1;
    }
    setActiveWaypointIndex(index, callback = EmptyCallback.Void, fplnIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[fplnIndex];
      if (index >= 0 && index <= currentFlightPlan.length) {
        currentFlightPlan.activeWaypointIndex = index;
        Coherent.call("SET_ACTIVE_WAYPOINT_INDEX", index + 1).catch(console.error);
        if (currentFlightPlan.directTo.isActive && currentFlightPlan.directTo.waypointIsInFlightPlan && currentFlightPlan.activeWaypointIndex > currentFlightPlan.directTo.planWaypointIndex) {
          currentFlightPlan.directTo.isActive = false;
        }
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    recomputeActiveWaypointIndex(callback = EmptyCallback.Void) {
      callback();
    }
    getPreviousActiveWaypoint(forceSimVarCall = false) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const previousWaypointIndex = currentFlightPlan.activeWaypointIndex - 1;
      return currentFlightPlan.getWaypoint(previousWaypointIndex);
    }
    getActiveWaypointIdent(forceSimVarCall = false) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.activeWaypoint) {
        return currentFlightPlan.activeWaypoint.ident;
      }
      return "";
    }
    getGPSActiveWaypointIndex(forceSimVarCall = false) {
      return this.getActiveWaypointIndex();
    }
    getActiveWaypoint(forceSimVarCall = false, useCorrection = false, flightPlanIndex = NaN) {
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return this._flightPlans[flightPlanIndex].activeWaypoint;
    }
    getNextActiveWaypoint(forceSimVarCall = false, flightPlanIndex = NaN) {
      if (isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      const nextWaypointIndex = currentFlightPlan.activeWaypointIndex + 1;
      return currentFlightPlan.getWaypoint(nextWaypointIndex);
    }
    getDistanceToActiveWaypoint() {
      const lat = SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude");
      const long = SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude");
      const ll = new LatLongAlt(lat, long);
      const waypoint = this.getActiveWaypoint();
      if (waypoint && waypoint.infos) {
        return Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
      }
      return 0;
    }
    getDistanceToDestination(fplnIndex = -1) {
      var _a, _b;
      if (fplnIndex < 0) {
        fplnIndex = this._currentFlightPlanIndex;
      }
      const destIndex = this.getDestinationIndex();
      if (destIndex < 0) {
        return -1;
      }
      const fmPos = {
        lat: SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude"),
        long: SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude")
      };
      const fpln = this._flightPlans[fplnIndex];
      const stats = fpln.computeWaypointStatistics(fmPos);
      return (_b = (_a = stats.get(destIndex)) == null ? void 0 : _a.distanceFromPpos) != null ? _b : -1;
    }
    getApproachStats() {
      var _a;
      const name69 = (_a = this.getApproach(0 /* Active */)) == null ? void 0 : _a.name;
      if (!name69) {
        return void 0;
      }
      const distanceFromPpos = this.getDistanceToDestination(0 /* Active */);
      return {
        name: name69,
        distanceFromPpos
      };
    }
    getBearingToActiveWaypoint() {
      const lat = SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude");
      const long = SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude");
      const ll = new LatLongAlt(lat, long);
      const waypoint = this.getActiveWaypoint();
      if (waypoint && waypoint.infos) {
        return Avionics.Utils.computeGreatCircleHeading(ll, waypoint.infos.coordinates);
      }
      return 0;
    }
    getETEToActiveWaypoint() {
      const lat = SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude");
      const long = SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude");
      const ll = new LatLongAlt(lat, long);
      const waypoint = this.getActiveWaypoint();
      if (waypoint && waypoint.infos) {
        const dist = Avionics.Utils.computeDistance(ll, waypoint.infos.coordinates);
        let groundSpeed = SimVar.GetSimVarValue("GPS GROUND SPEED", "knots");
        if (groundSpeed < 50) {
          groundSpeed = 50;
        }
        if (groundSpeed > 0.1) {
          return dist / groundSpeed * 3600;
        }
      }
      return 0;
    }
    getDestination(flightPlanIndex = this._currentFlightPlanIndex) {
      return this._flightPlans[flightPlanIndex].destinationAirfield;
    }
    getDestinationIndex() {
      if (this.getDestination()) {
        return this.getWaypointsCount() - 1;
      }
      return -1;
    }
    getDeparture(flightPlanIndex = NaN) {
      const origin = this.getOrigin();
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (origin) {
        const originInfos = origin.infos;
        if (originInfos.departures !== void 0 && currentFlightPlan.procedureDetails.departureIndex >= 0) {
          return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex];
        }
      }
      return void 0;
    }
    getDepartureName() {
      const origin = this.getPersistentOrigin();
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (origin) {
        const originInfos = origin.infos;
        if (originInfos.departures !== void 0 && currentFlightPlan.procedureDetails.departureIndex >= 0) {
          return originInfos.departures[currentFlightPlan.procedureDetails.departureIndex].name;
        }
      }
      return void 0;
    }
    getArrival() {
      const destination = this.getDestination();
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (destination) {
        const originInfos = destination.infos;
        if (originInfos.arrivals !== void 0 && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
          return originInfos.arrivals[currentFlightPlan.procedureDetails.arrivalIndex];
        }
      }
      return void 0;
    }
    getAirportApproach() {
      const destination = this.getDestination();
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (destination) {
        const originInfos = destination.infos;
        if (originInfos.approaches !== void 0 && currentFlightPlan.procedureDetails.approachIndex >= 0) {
          return originInfos.approaches[currentFlightPlan.procedureDetails.approachIndex];
        }
      }
      return void 0;
    }
    getDepartureWaypoints() {
      return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
    }
    getDepartureWaypointsMap() {
      return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints;
    }
    getEnRouteWaypoints(outFPIndex) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const enrouteSegment = currentFlightPlan.enroute;
      if (enrouteSegment !== FlightPlanSegment.Empty) {
        for (let i = 0; i < enrouteSegment.waypoints.length; i++) {
          outFPIndex.push(enrouteSegment.offset + i);
        }
      }
      return enrouteSegment.waypoints;
    }
    getEnRouteWaypointsFirstIndex(flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      const enrouteSegment = currentFlightPlan == null ? void 0 : currentFlightPlan.enroute;
      return enrouteSegment == null ? void 0 : enrouteSegment.offset;
    }
    getEnRouteWaypointsLastIndex(flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      const enrouteSegment = currentFlightPlan == null ? void 0 : currentFlightPlan.enroute;
      return enrouteSegment ? enrouteSegment.offset + (enrouteSegment.waypoints.length - 1) : null;
    }
    getArrivalWaypoints() {
      return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
    }
    getArrivalWaypointsMap() {
      return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints;
    }
    getWaypointsWithAltitudeConstraints() {
      return this._flightPlans[this._currentFlightPlanIndex].waypoints;
    }
    getSegmentFromWaypoint(waypoint, flightPlanIndex = NaN) {
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const index = waypoint === void 0 ? this.getActiveWaypointIndex() : this.indexOfWaypoint(waypoint);
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.findSegmentByWaypointIndex(index);
    }
    async setDestination(icao, callback = () => {
    }) {
      var _a;
      const sameAirport = ((_a = this.getDestination()) == null ? void 0 : _a.ident) === icao;
      const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao);
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const destinationIndex = currentFlightPlan.length - 1;
      if (currentFlightPlan.hasDestination) {
        currentFlightPlan.removeWaypoint(destinationIndex);
      }
      currentFlightPlan.addWaypoint(waypoint);
      this.setDestinationTransitionLevel(void 0, false);
      if (!sameAirport) {
        this.setDestinationTransitionLevel(void 0, true);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async addWaypoint(icao, index = Infinity, callback = () => {
    }, setActive = true) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = await this._parentInstrument.facilityLoader.getFacilityRaw(icao).catch((e) => {
        console.log(`addWaypoint: [${icao}] Error`);
        console.error(e);
      });
      if (waypoint) {
        currentFlightPlan.addWaypoint(waypoint, index);
        if (setActive) {
        }
        this.updateFlightPlanVersion().catch(console.error);
        callback();
      }
    }
    async addUserWaypoint(waypoint, index = Infinity, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      currentFlightPlan.addWaypoint(waypoint, index);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    setLegAltitudeDescription(waypoint, code, callback = () => {
    }) {
      if (waypoint) {
        waypoint.legAltitudeDescription = code;
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    setWaypointAltitude(altitude, index, callback = () => {
    }, isDescentConstraint) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        waypoint.legAltitude1 = altitude;
        if (isDescentConstraint !== void 0 && !waypoint.additionalData.constraintType) {
          if (isDescentConstraint) {
            this.setFirstDesConstraintWaypoint(index);
          } else {
            this.setLastClbConstraintWaypoint(index);
          }
        }
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    setWaypointSpeed(speed, index, callback = () => {
    }, isDescentConstraint) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        waypoint.speedConstraint = speed;
        if (isDescentConstraint) {
          this.setFirstDesConstraintWaypoint(index);
        } else {
          this.setLastClbConstraintWaypoint(index);
        }
        this.updateFlightPlanVersion();
      }
      callback();
    }
    setLastClbConstraintWaypoint(index) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      for (let i = index; i >= 0; i--) {
        const waypoint = currentFlightPlan.getWaypoint(i);
        if (waypoint) {
          waypoint.additionalData.constraintType = 1 /* CLB */;
        }
      }
    }
    setFirstDesConstraintWaypoint(index) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      for (let i = index; i < this.getWaypointsCount(); i++) {
        const waypoint = currentFlightPlan.getWaypoint(i);
        if (waypoint) {
          waypoint.additionalData.constraintType = 2 /* DES */;
        }
      }
    }
    setWaypointAdditionalData(index, key, value, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        waypoint.additionalData[key] = value;
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    getWaypointAdditionalData(index, key, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      if (waypoint) {
        callback(waypoint.additionalData[key]);
      } else {
        callback(void 0);
      }
    }
    invertActiveFlightPlan(callback = () => {
    }) {
      this._flightPlans[this._currentFlightPlanIndex].reverse();
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    getApproachIfIcao(callback = () => {
    }) {
      callback(this.getApproach());
    }
    addFlightPlanUpdateCallback(_callback) {
    }
    addWaypointByIdent(ident, index, callback = EmptyCallback.Void) {
      this.addWaypoint(ident, index, callback).catch(console.error);
    }
    removeWaypoint(index, noDiscontinuity = false, callback = () => {
    }) {
      this._flightPlans[this._currentFlightPlanIndex].removeWaypoint(index, noDiscontinuity);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    addWaypointOverfly(index, thenSetActive = false, callback = () => {
    }) {
      this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, true);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    removeWaypointOverfly(index, thenSetActive = false, callback = () => {
    }) {
      this._flightPlans[this._currentFlightPlanIndex].setWaypointOverfly(index, false);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    addOrEditManualHold(index, desiredHold, modifiedHold, defaultHold) {
      const holdIndex = this._flightPlans[this._currentFlightPlanIndex].addOrEditManualHold(
        index,
        desiredHold,
        modifiedHold,
        defaultHold
      );
      this.updateFlightPlanVersion().catch(console.error);
      return holdIndex;
    }
    truncateWaypoints(index, thenSetActive = false, callback = () => {
    }) {
      const fp = this._flightPlans[this._currentFlightPlanIndex];
      for (let i = fp.length; i > index; i--) {
        fp.removeWaypoint(index);
      }
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    indexOfWaypoint(waypoint) {
      return this._flightPlans[this._currentFlightPlanIndex].waypoints.indexOf(waypoint);
    }
    getWaypointsCount(flightPlanIndex = NaN) {
      var _a, _b, _c, _d;
      if (Number.isNaN(flightPlanIndex)) {
        return (_b = (_a = this._flightPlans[this._currentFlightPlanIndex]) == null ? void 0 : _a.length) != null ? _b : 0;
      }
      return (_d = (_c = this._flightPlans[flightPlanIndex]) == null ? void 0 : _c.length) != null ? _d : 0;
    }
    getDepartureWaypointsCount() {
      return this._flightPlans[this._currentFlightPlanIndex].departure.waypoints.length;
    }
    getArrivalWaypointsCount() {
      return this._flightPlans[this._currentFlightPlanIndex].arrival.waypoints.length;
    }
    getWaypoint(index, flightPlanIndex = NaN, considerApproachWaypoints = false) {
      var _a;
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return (_a = this._flightPlans[flightPlanIndex]) == null ? void 0 : _a.getWaypoint(index);
    }
    getWaypoints(flightPlanIndex = NaN) {
      var _a, _b;
      if (Number.isNaN(flightPlanIndex)) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return (_b = (_a = this._flightPlans[flightPlanIndex]) == null ? void 0 : _a.nonApproachWaypoints) != null ? _b : [];
    }
    getAllWaypoints(flightPlanIndex) {
      if (flightPlanIndex === void 0) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      return this._flightPlans[flightPlanIndex].waypoints;
    }
    getDepartureRunwayIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasOrigin) {
        return currentFlightPlan.procedureDetails.departureRunwayIndex;
      }
      return -1;
    }
    getOriginRunwayIndex(flightPlanIndex = void 0) {
      if (flightPlanIndex === void 0) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (currentFlightPlan.procedureDetails.originRunwayIndex >= 0 && currentFlightPlan.originAirfield) {
        return currentFlightPlan.procedureDetails.originRunwayIndex;
      }
      return -1;
    }
    getOriginRunway(flightPlanIndex = void 0) {
      var _a, _b;
      if (flightPlanIndex === void 0) {
        flightPlanIndex = this._currentFlightPlanIndex;
      }
      const runwayIndex = this.getOriginRunwayIndex(flightPlanIndex);
      if (runwayIndex >= 0) {
        return (_b = (_a = this.getOrigin()) == null ? void 0 : _a.infos) == null ? void 0 : _b.oneWayRunways[runwayIndex];
      }
      return void 0;
    }
    getDetectedCurrentRunway() {
      const origin = this.getOrigin();
      if (origin && origin.infos instanceof AirportInfo) {
        const runways = origin.infos.oneWayRunways;
        if (runways && runways.length > 0) {
          const direction = Simplane.getHeadingMagnetic();
          let bestRunway = runways[0];
          let bestDeltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, bestRunway.direction));
          for (let i = 1; i < runways.length; i++) {
            const deltaAngle = Math.abs(Avionics.Utils.diffAngle(direction, runways[i].direction));
            if (deltaAngle < bestDeltaAngle) {
              bestDeltaAngle = deltaAngle;
              bestRunway = runways[i];
            }
          }
          return bestRunway;
        }
      }
      return void 0;
    }
    getDepartureProcIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.departureIndex;
    }
    async setDepartureProcIndex(index, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.departureIndex !== index) {
        currentFlightPlan.procedureDetails.departureIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setDepartureRunwayIndex(index, callback = EmptyCallback.Void) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.departureRunwayIndex !== index) {
        currentFlightPlan.procedureDetails.departureRunwayIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setOriginRunwayIndex(index, callback = EmptyCallback.Void) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.originRunwayIndex !== index) {
        currentFlightPlan.procedureDetails.originRunwayIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setOriginRunwayIndexFromDeparture() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasOrigin && currentFlightPlan.procedureDetails.departureRunwayIndex >= 0 && currentFlightPlan.procedureDetails.departureIndex >= 0 && currentFlightPlan.originAirfield) {
        const transition = currentFlightPlan.originAirfield.infos.departures[currentFlightPlan.procedureDetails.departureIndex].runwayTransitions[currentFlightPlan.procedureDetails.departureRunwayIndex];
        const runways = currentFlightPlan.originAirfield.infos.oneWayRunways;
        await this.setOriginRunwayIndex(runways.findIndex((r) => r.number === transition.runwayNumber && r.designator === transition.runwayDesignation));
      }
    }
    getDepartureEnRouteTransitionIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.departureTransitionIndex;
    }
    async setDepartureEnRouteTransitionIndex(index, callback = EmptyCallback.Void) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.departureTransitionIndex !== index) {
        currentFlightPlan.procedureDetails.departureTransitionIndex = index;
        await currentFlightPlan.buildDeparture().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    getDepartureDiscontinuity() {
    }
    clearDepartureDiscontinuity(callback = EmptyCallback.Void) {
      callback();
    }
    async removeDeparture(callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      currentFlightPlan.procedureDetails.departureIndex = -1;
      await currentFlightPlan.buildDeparture().catch(console.error);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    getArrivalProcIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.arrivalIndex >= 0) {
        return currentFlightPlan.procedureDetails.arrivalIndex;
      }
      return -1;
    }
    getArrivalTransitionIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.arrivalTransitionIndex;
    }
    async setArrivalProcIndex(index, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.arrivalIndex !== index) {
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
        currentFlightPlan.procedureDetails.arrivalIndex = index;
        currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    getArrivalDiscontinuity() {
    }
    clearArrivalDiscontinuity(callback = EmptyCallback.Void) {
      callback();
    }
    clearDiscontinuity(index) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      const waypoint = currentFlightPlan.getWaypoint(index);
      const nextWaypoint = currentFlightPlan.getWaypoint(index + 1);
      if (waypoint !== void 0 && nextWaypoint !== void 0 && waypoint.discontinuityCanBeCleared) {
        waypoint.endsInDiscontinuity = false;
        switch (nextWaypoint.additionalData.legType) {
          case 8 /* FA */:
          case 9 /* FC */:
          case 10 /* FD */:
          case 11 /* FM */:
          case 12 /* HA */:
          case 13 /* HF */:
          case 14 /* HM */:
          case 16 /* PI */:
            this.addWaypointByIdent(nextWaypoint.icao, index + 1, () => this.updateFlightPlanVersion().catch(console.error));
            break;
          default:
            this.updateFlightPlanVersion().catch(console.error);
        }
        return true;
      }
      this.updateFlightPlanVersion().catch(console.error);
      return false;
    }
    async setArrivalEnRouteTransitionIndex(index, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.arrivalTransitionIndex !== index) {
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = index;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setArrivalRunwayIndex(index, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.arrivalRunwayIndex !== index) {
        currentFlightPlan.procedureDetails.arrivalRunwayIndex = index;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setDestinationRunwayIndex(index, runwayExtension = -1, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.destinationRunwayIndex !== index || currentFlightPlan.procedureDetails.destinationRunwayExtension !== runwayExtension) {
        currentFlightPlan.procedureDetails.destinationRunwayIndex = index;
        currentFlightPlan.procedureDetails.destinationRunwayExtension = runwayExtension;
        await currentFlightPlan.buildApproach().catch(console.error);
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async setDestinationRunwayIndexFromApproach() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
        const approach = currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
        const destRunways = currentFlightPlan.destinationAirfield.infos.oneWayRunways;
        await this.setDestinationRunwayIndex(destRunways.findIndex((r) => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator));
      }
    }
    getApproachIndex() {
      return this._flightPlans[this._currentFlightPlanIndex].procedureDetails.approachIndex;
    }
    async setApproachIndex(index, callback = () => {
    }, transition = -1) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.approachIndex !== index) {
        currentFlightPlan.procedureDetails.approachIndex = index;
        currentFlightPlan.procedureDetails.approachTransitionIndex = -1;
        currentFlightPlan.procedureDetails.arrivalIndex = -1;
        currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    isLoadedApproach(forceSimVarCall = false) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.approachIndex >= 0;
    }
    isActiveApproach(flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.approach.waypoints.length > 0 && currentFlightPlan.activeWaypointIndex >= currentFlightPlan.approach.offset;
    }
    async activateApproach(callback = EmptyCallback.Void) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (!this.isActiveApproach() && currentFlightPlan.approach.offset >= 0) {
        await GPS.setActiveWaypoint(currentFlightPlan.approach.offset).catch(console.error);
      }
      callback();
    }
    deactivateApproach() {
    }
    tryAutoActivateApproach() {
    }
    getApproachActiveWaypointIndex() {
      return this._flightPlans[this._currentFlightPlanIndex].activeWaypointIndex;
    }
    getApproach(flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (currentFlightPlan.hasDestination && currentFlightPlan.procedureDetails.approachIndex >= 0) {
        return currentFlightPlan.destinationAirfield.infos.approaches[currentFlightPlan.procedureDetails.approachIndex];
      }
      return void 0;
    }
    getApproachTransitionIndex() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      return currentFlightPlan.procedureDetails.approachTransitionIndex;
    }
    getLastIndexBeforeApproach() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.approach !== FlightPlanSegment.Empty) {
        return currentFlightPlan.approach.offset - 1;
      }
      return this.getWaypointsCount();
    }
    getDestinationRunway(flightPlanIndex = this._currentFlightPlanIndex) {
      const flightPlan = this._flightPlans[flightPlanIndex];
      const runwayIndex = this.getDestinationRunwayIndex(flightPlanIndex);
      if (runwayIndex >= 0) {
        return flightPlan.destinationAirfield.infos.oneWayRunways[runwayIndex];
      }
      return void 0;
    }
    getDestinationRunwayIndex(flightPlanIndex = this._currentFlightPlanIndex) {
      const flightPlan = this._flightPlans[flightPlanIndex];
      if (flightPlan.procedureDetails.destinationRunwayIndex >= 0 && flightPlan.destinationAirfield) {
        return flightPlan.procedureDetails.destinationRunwayIndex;
      }
      if (flightPlan.hasDestination && flightPlan.procedureDetails.approachIndex >= 0) {
        console.error("Destination runway index is -1 with valid STAR");
        const approach = flightPlan.destinationAirfield.infos.approaches[flightPlan.procedureDetails.approachIndex];
        const runways = flightPlan.destinationAirfield.infos.oneWayRunways;
        return runways.findIndex((r) => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
      }
      return -1;
    }
    getApproachWaypoints(flightPlanIndex = this._currentFlightPlanIndex) {
      return this._flightPlans[flightPlanIndex].approach.waypoints;
    }
    async setApproachTransitionIndex(index, callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.procedureDetails.approachTransitionIndex !== index) {
        currentFlightPlan.procedureDetails.approachTransitionIndex = index;
        await currentFlightPlan.rebuildArrivalApproach();
        this.updateFlightPlanVersion().catch(console.error);
      }
      callback();
    }
    async removeArrival(callback = () => {
    }) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      currentFlightPlan.procedureDetails.arrivalIndex = -1;
      currentFlightPlan.procedureDetails.arrivalRunwayIndex = -1;
      currentFlightPlan.procedureDetails.arrivalTransitionIndex = -1;
      await currentFlightPlan.buildArrival().catch(console.error);
      this.updateFlightPlanVersion().catch(console.error);
      callback();
    }
    async insertDirectTo(waypoint) {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      await currentFlightPlan.addDirectTo(waypoint);
      this.updateFlightPlanVersion().catch(console.error);
    }
    cancelDirectTo(callback = EmptyCallback.Void) {
      callback();
    }
    getIsDirectTo() {
      return this._flightPlans[this._currentFlightPlanIndex].directTo.isActive;
    }
    getDirectToTarget() {
      const currentFlightPlan = this._flightPlans[this._currentFlightPlanIndex];
      if (currentFlightPlan.directTo.waypointIsInFlightPlan) {
        return currentFlightPlan.waypoints[currentFlightPlan.directTo.planWaypointIndex];
      }
      return currentFlightPlan.directTo.waypoint;
    }
    getDirecToOrigin() {
      return this._flightPlans[this._currentFlightPlanIndex].directTo.interceptPoints[0];
    }
    getCoordinatesHeadingAtDistanceAlongFlightPlan(_distance) {
    }
    getCoordinatesAtNMFromDestinationAlongFlightPlan(distance) {
      const allWaypoints = this.getAllWaypoints();
      const destination = this.getDestination();
      if (destination) {
        const fromStartDistance = destination.cumulativeDistanceInFP - distance;
        let prev;
        let next;
        for (let i = 0; i < allWaypoints.length - 1; i++) {
          prev = allWaypoints[i];
          next = allWaypoints[i + 1];
          if (prev.cumulativeDistanceInFP < fromStartDistance && next.cumulativeDistanceInFP > fromStartDistance) {
            break;
          }
        }
        const prevCD = prev.cumulativeDistanceInFP;
        const nextCD = next.cumulativeDistanceInFP;
        const d = (fromStartDistance - prevCD) / (nextCD - prevCD);
        const output = new LatLongAlt();
        output.lat = Avionics.Utils.lerpAngle(prev.infos.coordinates.lat, next.infos.coordinates.lat, d);
        output.long = Avionics.Utils.lerpAngle(prev.infos.coordinates.long, next.infos.coordinates.long, d);
        return output;
      }
      return null;
    }
    _getFlightPlan() {
      if (!LnavConfig.DEBUG_SAVE_FPLN_LOCAL_STORAGE) {
        return;
      }
      const fpln = window.localStorage.getItem(_FlightPlanManager.FlightPlanKey);
      if (fpln === null || fpln === "") {
        this._flightPlans = [];
        const initFpln = new ManagedFlightPlan();
        initFpln.setParentInstrument(this._parentInstrument);
        this._flightPlans.push(initFpln);
      } else if (window.localStorage.getItem(_FlightPlanManager.FlightPlanCompressedKey) === "1") {
        this._flightPlans = JSON.parse(LZUTF8.decompress(fpln, { inputEncoding: "StorageBinaryString" }));
      } else {
        try {
          this._flightPlans = JSON.parse(fpln);
        } catch (e) {
          this._flightPlans = JSON.parse(LZUTF8.decompress(fpln, { inputEncoding: "StorageBinaryString" }));
        }
      }
    }
    getCurrentFlightPlan() {
      return this._flightPlans[this._currentFlightPlanIndex];
    }
    getFlightPlan(index) {
      return this._flightPlans[index];
    }
    async updateFlightPlanVersion() {
      if (this._isSyncPaused) {
        return;
      }
      if (LnavConfig.DEBUG_SAVE_FPLN_LOCAL_STORAGE) {
        let fpJson = JSON.stringify(this._flightPlans.map((fp) => fp.serialize()));
        if (fpJson.length > 25e5) {
          fpJson = LZUTF8.compress(fpJson, { outputEncoding: "StorageBinaryString" });
          window.localStorage.setItem(_FlightPlanManager.FlightPlanCompressedKey, "1");
        } else {
          window.localStorage.setItem(_FlightPlanManager.FlightPlanCompressedKey, "0");
        }
        window.localStorage.setItem(_FlightPlanManager.FlightPlanKey, fpJson);
      }
      SimVar.SetSimVarValue(_FlightPlanManager.FlightPlanVersionKey, "number", ++this._currentFlightPlanVersion);
      if (NXDataStore.get("FP_SYNC", "LOAD") === "SAVE") {
        FlightPlanAsoboSync.SaveToGame(this).catch(console.error);
      }
    }
    pauseSync() {
      this._isSyncPaused = true;
      console.log("FlightPlan Sync Paused");
    }
    resumeSync() {
      this._isSyncPaused = false;
      this.updateFlightPlanVersion().catch(console.error);
      console.log("FlightPlan Sync Resume");
    }
    get currentFlightPlanVersion() {
      return this._currentFlightPlanVersion;
    }
    getOriginTransitionAltitude(flightPlanIndex = this._currentFlightPlanIndex) {
      var _a;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return (_a = currentFlightPlan.originTransitionAltitudePilot) != null ? _a : currentFlightPlan.originTransitionAltitudeDb;
    }
    get originTransitionAltitude() {
      return this.getOriginTransitionAltitude(0);
    }
    getOriginTransitionAltitudeIsFromDb(flightPlanIndex = 0) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.originTransitionAltitudePilot === void 0;
    }
    get originTransitionAltitudeIsFromDb() {
      return this.getOriginTransitionAltitudeIsFromDb(0);
    }
    setOriginTransitionAltitude(altitude, database = false, flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (database) {
        currentFlightPlan.originTransitionAltitudeDb = altitude;
      } else {
        currentFlightPlan.originTransitionAltitudePilot = altitude;
      }
      this.updateFlightPlanVersion();
    }
    getDestinationTransitionLevel(flightPlanIndex = this._currentFlightPlanIndex) {
      var _a;
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return (_a = currentFlightPlan.destinationTransitionLevelPilot) != null ? _a : currentFlightPlan.destinationTransitionLevelDb;
    }
    get destinationTransitionLevel() {
      return this.getDestinationTransitionLevel(0);
    }
    getDestinationTransitionLevelIsFromDb(flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      return currentFlightPlan.destinationTransitionLevelPilot === void 0;
    }
    get destinationTransitionLevelIsFromDb() {
      return this.getDestinationTransitionLevelIsFromDb(0);
    }
    setDestinationTransitionLevel(flightLevel, database = false, flightPlanIndex = this._currentFlightPlanIndex) {
      const currentFlightPlan = this._flightPlans[flightPlanIndex];
      if (database) {
        currentFlightPlan.destinationTransitionLevelDb = flightLevel;
      } else {
        currentFlightPlan.destinationTransitionLevelPilot = flightLevel;
      }
      this.updateFlightPlanVersion();
    }
    getFixInfo(index) {
      return this._fixInfos[index];
    }
    isWaypointInUse(icao) {
      var _a, _b;
      for (const fp of this._flightPlans) {
        for (let i = 0; i < (fp == null ? void 0 : fp.waypoints.length); i++) {
          if (((_a = fp == null ? void 0 : fp.getWaypoint(i)) == null ? void 0 : _a.icao) === icao) {
            return true;
          }
        }
      }
      for (const fixInfo of this._fixInfos) {
        if (((_b = fixInfo == null ? void 0 : fixInfo.getRefFix()) == null ? void 0 : _b.infos.icao) === icao) {
          return true;
        }
      }
      return false;
    }
    get activeFlightPlan() {
      return this._flightPlans[0 /* Active */];
    }
    getApproachType(flightPlanIndex = this._currentFlightPlanIndex) {
      var _a;
      const fp = this._flightPlans[flightPlanIndex];
      return (_a = fp == null ? void 0 : fp.procedureDetails.approachType) != null ? _a : void 0;
    }
    getGlideslopeIntercept(flightPlanIndex = this._currentFlightPlanIndex) {
      var _a;
      const fp = this._flightPlans[flightPlanIndex];
      return (_a = fp == null ? void 0 : fp.glideslopeIntercept) != null ? _a : void 0;
    }
    updateActiveArea() {
      const activeFp = this._flightPlans[0 /* Active */];
      if (!activeFp) {
        this.activeArea = 0 /* Terminal */;
        return;
      }
      this.activeArea = this.calculateActiveArea(activeFp);
    }
    calculateActiveArea(activeFp) {
      const activeIndex = activeFp.activeWaypointIndex;
      const appr = activeFp.getSegment(4 /* Approach */);
      const arrival = activeFp.getSegment(3 /* Arrival */);
      const departure = activeFp.getSegment(1 /* Departure */);
      if (departure !== FlightPlanSegment.Empty && activeIndex < departure.offset + departure.waypoints.length) {
        return 0 /* Terminal */;
      }
      if (arrival !== FlightPlanSegment.Empty && activeIndex >= arrival.offset && activeIndex < arrival.offset + arrival.waypoints.length) {
        return 0 /* Terminal */;
      }
      if (appr !== FlightPlanSegment.Empty && activeIndex >= appr.offset && activeIndex < appr.offset + appr.waypoints.length && activeFp.finalApproachActive) {
        const apprType = activeFp.procedureDetails.approachType;
        switch (apprType) {
          case ApproachType.APPROACH_TYPE_ILS:
            return 6 /* PrecisionApproach */;
          case ApproachType.APPROACH_TYPE_GPS:
          case ApproachType.APPROACH_TYPE_RNAV:
            return 5 /* GpsApproach */;
          case ApproachType.APPROACH_TYPE_VOR:
          case ApproachType.APPROACH_TYPE_VORDME:
            return 4 /* VorApproach */;
          default:
            return 7 /* NonPrecisionApproach */;
        }
      }
      return 2 /* Enroute */;
    }
    addOrUpdateCruiseStep(waypoint, toAltitude, waypointIndex) {
      this._flightPlans[this._currentFlightPlanIndex].addOrUpdateCruiseStep(waypoint, toAltitude, waypointIndex);
      this.unignoreAllCruiseSteps();
      this.updateFlightPlanVersion().catch(console.error);
    }
    removeCruiseStep(waypoint) {
      this._flightPlans[this._currentFlightPlanIndex].removeCruiseStep(waypoint);
      this.unignoreAllCruiseSteps();
      this.updateFlightPlanVersion().catch(console.error);
    }
    findWaypointIndexByIdent(ident) {
      return this._flightPlans[this._currentFlightPlanIndex].findWaypointIndexByIdent(ident);
    }
    unignoreAllCruiseSteps() {
      this._flightPlans[this._currentFlightPlanIndex].unignoreAllCruiseSteps();
      this.updateFlightPlanVersion().catch(console.error);
    }
  };
  var FlightPlanManager = _FlightPlanManager;
  __publicField(FlightPlanManager, "DEBUG_INSTANCE");
  __publicField(FlightPlanManager, "FlightPlanKey", "A32NX.FlightPlan");
  __publicField(FlightPlanManager, "FlightPlanCompressedKey", "A32NX.FlightPlan.Compressed");
  __publicField(FlightPlanManager, "FlightPlanVersionKey", "L:A32NX.FlightPlan.Version");

  // src/systems/shared/src/arinc429.ts
  var _Arinc429Word = class {
    constructor(word) {
      __publicField(this, "ssm");
      __publicField(this, "value");
      _Arinc429Word.u32View[0] = (word & 4294967295) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 3;
      this.value = _Arinc429Word.f32View[0];
    }
    static empty() {
      return new _Arinc429Word(0);
    }
    static fromSimVarValue(name69) {
      return new _Arinc429Word(SimVar.GetSimVarValue(name69, "number"));
    }
    static async toSimVarValue(name69, value, ssm) {
      _Arinc429Word.f32View[0] = value;
      const simVal = _Arinc429Word.u32View[0] + Math.trunc(ssm) * 2 ** 32;
      return SimVar.SetSimVarValue(name69, "string", simVal.toString());
    }
    isFailureWarning() {
      return this.ssm === 0 /* FailureWarning */;
    }
    isNoComputedData() {
      return this.ssm === 1 /* NoComputedData */;
    }
    isFunctionalTest() {
      return this.ssm === 2 /* FunctionalTest */;
    }
    isNormalOperation() {
      return this.ssm === 3 /* NormalOperation */;
    }
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    getBitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    getBitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
    setBitValue(bit, value) {
      if (value) {
        this.value |= 1 << bit - 1;
      } else {
        this.value &= ~(1 << bit - 1);
      }
    }
  };
  var Arinc429Word = _Arinc429Word;
  __publicField(Arinc429Word, "u32View", new Uint32Array(1));
  __publicField(Arinc429Word, "f32View", new Float32Array(_Arinc429Word.u32View.buffer));
  var Arinc429Register = class {
    constructor() {
      __publicField(this, "u32View", new Uint32Array(1));
      __publicField(this, "f32View", new Float32Array(this.u32View.buffer));
      __publicField(this, "ssm");
      __publicField(this, "value");
      this.set(0);
    }
    static empty() {
      return new Arinc429Register();
    }
    set(word) {
      this.u32View[0] = (word & 4294967295) >>> 0;
      this.ssm = Math.trunc(word / 2 ** 32) & 3;
      this.value = this.f32View[0];
    }
    setFromSimVar(name69) {
      this.set(SimVar.GetSimVarValue(name69, "number"));
    }
    isFailureWarning() {
      return this.ssm === 0 /* FailureWarning */;
    }
    isNoComputedData() {
      return this.ssm === 1 /* NoComputedData */;
    }
    isFunctionalTest() {
      return this.ssm === 2 /* FunctionalTest */;
    }
    isNormalOperation() {
      return this.ssm === 3 /* NormalOperation */;
    }
    valueOr(defaultValue) {
      return this.isNormalOperation() ? this.value : defaultValue;
    }
    bitValue(bit) {
      return (this.value >> bit - 1 & 1) !== 0;
    }
    bitValueOr(bit, defaultValue) {
      return this.isNormalOperation() ? (this.value >> bit - 1 & 1) !== 0 : defaultValue;
    }
  };

  // src/systems/shared/src/autopilot.ts
  function isArmed(bitmask, armedBit) {
    return (bitmask >> armedBit & 1) === 1;
  }

  // src/systems/shared/src/flightphase.ts
  function isReady() {
    return SimVar.GetSimVarValue("L:A32NX_IS_READY", "number") === 1;
  }
  function isSlewActive() {
    return SimVar.GetSimVarValue("IS SLEW ACTIVE", "bool");
  }
  function isOnGround() {
    return SimVar.GetSimVarValue("L:A32NX_LGCIU_1_NOSE_GEAR_COMPRESSED", "bool") || SimVar.GetSimVarValue("L:A32NX_LGCIU_2_NOSE_GEAR_COMPRESSED", "bool");
  }
  function isEngineOn(index) {
    return SimVar.GetSimVarValue(`L:A32NX_ENGINE_N2:${index}`, "number") > 20;
  }
  function isEngineOnTakeOffThrust(index) {
    return SimVar.GetSimVarValue(`L:A32NX_ENGINE_N1:${index}`, "number") >= 70;
  }
  function isAnEngineOn() {
    return isEngineOn(1) || isEngineOn(2);
  }
  function isAllEngineOn() {
    return isEngineOn(1) && isEngineOn(2);
  }
  function getAutopilotVerticalMode() {
    return SimVar.GetSimVarValue("L:A32NX_FMA_VERTICAL_MODE", "Enum");
  }
  function conditionTakeOff() {
    return getAutopilotVerticalMode() === 40 /* SRS */ && isEngineOnTakeOffThrust(1) && isEngineOnTakeOffThrust(2) || Math.abs(Simplane.getGroundSpeed()) > 90;
  }

  // src/systems/shared/src/logic.ts
  var ConfirmationNode = class {
    constructor(triggerTime) {
      this.triggerTime = triggerTime;
      __publicField(this, "lastInput", false);
      __publicField(this, "input", false);
      __publicField(this, "output", false);
      __publicField(this, "timer", 0);
    }
    update(deltaTime) {
      if (this.lastInput !== this.input) {
        this.lastInput = this.input;
        this.output = false;
        this.timer = 0;
        return;
      }
      this.lastInput = this.input;
      if (this.input) {
        this.timer += deltaTime;
      }
      if (this.timer > this.triggerTime) {
        this.output = true;
      }
    }
  };
  var Trigger = class {
    constructor(risingEdge) {
      this.risingEdge = risingEdge;
      __publicField(this, "lastInput", false);
      __publicField(this, "input", false);
      __publicField(this, "output", false);
    }
    update(_) {
      if (this.lastInput !== this.input) {
        if (this.risingEdge && this.input) {
          this.output = true;
        } else if (!this.risingEdge && this.input) {
          this.output = false;
        }
      } else {
        this.output = false;
      }
      this.lastInput = this.input;
    }
  };

  // src/systems/fmgc/src/flightphase/Phase.ts
  var Phase = class {
    constructor() {
      __publicField(this, "nextPhase");
    }
    init() {
    }
  };
  var PreFlightPhase = class extends Phase {
    constructor() {
      super(...arguments);
      __publicField(this, "takeoffConfirmation", new ConfirmationNode(0.2 * 1e3));
    }
    init() {
      this.nextPhase = 1 /* Takeoff */;
    }
    shouldActivateNextPhase(_deltaTime) {
      this.takeoffConfirmation.input = conditionTakeOff();
      this.takeoffConfirmation.update(_deltaTime);
      return this.takeoffConfirmation.output;
    }
  };
  var TakeOffPhase = class extends Phase {
    constructor() {
      super(...arguments);
      __publicField(this, "accelerationAltitudeMsl");
      __publicField(this, "accelerationAltitudeMslEo");
    }
    init() {
      this.nextPhase = 2 /* Climb */;
      SimVar.SetSimVarValue("L:A32NX_COLD_AND_DARK_SPAWN", "Bool", false);
      const accAlt = Arinc429Word.fromSimVarValue("L:A32NX_FM1_ACC_ALT");
      this.accelerationAltitudeMsl = accAlt.valueOr(SimVar.GetSimVarValue("INDICATED ALTITUDE", "feet") + parseInt(NXDataStore.get("CONFIG_ACCEL_ALT", "1500")));
      const eoAccAlt = Arinc429Word.fromSimVarValue("L:A32NX_FM1_EO_ACC_ALT");
      this.accelerationAltitudeMslEo = eoAccAlt.valueOr(SimVar.GetSimVarValue("INDICATED ALTITUDE", "feet") + parseInt(NXDataStore.get("CONFIG_ACCEL_ALT", "1500")));
    }
    shouldActivateNextPhase(_deltaTime) {
      return Simplane.getAltitude() > (isAllEngineOn() ? this.accelerationAltitudeMsl : this.accelerationAltitudeMslEo);
    }
  };
  var ClimbPhase = class extends Phase {
    init() {
      this.nextPhase = 3 /* Cruise */;
    }
    shouldActivateNextPhase(_deltaTime) {
      const cruiseFl = SimVar.GetSimVarValue("L:AIRLINER_CRUISE_ALTITUDE", "number") / 100;
      const fl = Math.round(SimVar.GetSimVarValue("INDICATED ALTITUDE:3", "feet") / 100);
      return fl >= cruiseFl;
    }
  };
  var CruisePhase = class extends Phase {
    init() {
      this.nextPhase = 3 /* Cruise */;
    }
    shouldActivateNextPhase(_deltaTime) {
      return false;
    }
  };
  var DescentPhase = class extends Phase {
    init() {
      this.nextPhase = 5 /* Approach */;
    }
    shouldActivateNextPhase(_deltaTime) {
      const fl = Math.round(SimVar.GetSimVarValue("INDICATED ALTITUDE:3", "feet") / 100);
      const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue("feet") / 100;
      const cruiseFl = SimVar.GetSimVarValue("L:AIRLINER_CRUISE_ALTITUDE", "number") / 100;
      if (fl === cruiseFl && fcuSelFl === fl) {
        this.nextPhase = 3 /* Cruise */;
        return true;
      }
      return !!SimVar.GetSimVarValue("L:A32NX_FM_ENABLE_APPROACH_PHASE", "Bool");
    }
  };
  var ApproachPhase = class extends Phase {
    constructor() {
      super(...arguments);
      __publicField(this, "landingConfirmation", new ConfirmationNode(30 * 1e3));
    }
    init() {
      SimVar.SetSimVarValue("L:A32NX_TO_FLEX_TEMP", "Number", 0);
      this.nextPhase = 7 /* Done */;
    }
    shouldActivateNextPhase(_deltaTime) {
      if (getAutopilotVerticalMode() === 41 /* SRS_GA */) {
        this.nextPhase = 6 /* GoAround */;
        return true;
      }
      this.landingConfirmation.input = isOnGround();
      this.landingConfirmation.update(_deltaTime);
      return this.landingConfirmation.output || !isAnEngineOn();
    }
  };
  var GoAroundPhase = class extends Phase {
    init() {
      SimVar.SetSimVarValue("L:A32NX_TO_FLEX_TEMP", "Number", 0);
      this.nextPhase = 6 /* GoAround */;
    }
    shouldActivateNextPhase(_deltaTime) {
      return false;
    }
  };
  var DonePhase = class extends Phase {
    init() {
      SimVar.SetSimVarValue("L:A32NX_TO_FLEX_TEMP", "Number", 0);
      this.nextPhase = 7 /* Done */;
    }
    shouldActivateNextPhase(_deltaTime) {
      return false;
    }
  };

  // src/systems/fmgc/src/flightphase/FlightPhaseManager.ts
  function canInitiateDes(distanceToDestination) {
    const fl = Math.round(Simplane.getAltitude() / 100);
    const fcuSelFl = Simplane.getAutoPilotDisplayedAltitudeLockValue("feet") / 100;
    const cruiseFl = SimVar.GetSimVarValue("L:AIRLINER_CRUISE_ALTITUDE", "number") / 100;
    return (distanceToDestination < 200 || fl < 200) && fcuSelFl < cruiseFl && fcuSelFl < fl || distanceToDestination >= 200 && fl > 200 && fcuSelFl <= 200;
  }
  var FlightPhaseManager = class {
    constructor() {
      __publicField(this, "onGroundConfirmationNode", new ConfirmationNode(30 * 1e3));
      __publicField(this, "activePhase", this.initialPhase || 0 /* Preflight */);
      __publicField(this, "phases", {
        [0 /* Preflight */]: new PreFlightPhase(),
        [1 /* Takeoff */]: new TakeOffPhase(),
        [2 /* Climb */]: new ClimbPhase(),
        [3 /* Cruise */]: new CruisePhase(),
        [4 /* Descent */]: new DescentPhase(),
        [5 /* Approach */]: new ApproachPhase(),
        [6 /* GoAround */]: new GoAroundPhase(),
        [7 /* Done */]: new DonePhase()
      });
      __publicField(this, "phaseChangeListeners", []);
    }
    get phase() {
      return this.activePhase;
    }
    get initialPhase() {
      return SimVar.GetSimVarValue("L:A32NX_INITIAL_FLIGHT_PHASE", "number");
    }
    init() {
      console.log(`FMGC Flight Phase: ${this.phase}`);
      this.phases[this.phase].init();
      this.changePhase(this.activePhase);
    }
    shouldActivateNextPhase(_deltaTime) {
      if (isReady() && !isSlewActive()) {
        if (this.shouldActivateDonePhase(_deltaTime)) {
          this.changePhase(7 /* Done */);
        } else if (this.phases[this.phase].shouldActivateNextPhase(_deltaTime)) {
          this.changePhase(this.phases[this.phase].nextPhase);
        }
      } else if (isReady() && isSlewActive()) {
        this.handleSlewSituation(_deltaTime);
      } else if (this.activePhase !== this.initialPhase) {
        this.activePhase = this.initialPhase;
        this.changePhase(this.initialPhase);
      }
    }
    addOnPhaseChanged(cb) {
      this.phaseChangeListeners.push(cb);
    }
    handleFcuAltKnobPushPull(distanceToDestination) {
      switch (this.phase) {
        case 1 /* Takeoff */:
          this.changePhase(2 /* Climb */);
          break;
        case 2 /* Climb */:
        case 3 /* Cruise */:
          if (canInitiateDes(distanceToDestination)) {
            this.changePhase(4 /* Descent */);
          }
          break;
        default:
      }
    }
    handleFcuAltKnobTurn(distanceToDestination) {
      if (this.phase === 3 /* Cruise */) {
        const activeVerticalMode = SimVar.GetSimVarValue("L:A32NX_FMA_VERTICAL_MODE", "Enum");
        const VS = SimVar.GetSimVarValue("L:A32NX_AUTOPILOT_VS_SELECTED", "feet per minute");
        const FPA = SimVar.GetSimVarValue("L:A32NX_AUTOPILOT_FPA_SELECTED", "Degrees");
        if ((activeVerticalMode === 13 /* OP_DES */ || activeVerticalMode === 14 /* VS */ && VS < 0 || activeVerticalMode === 15 /* FPA */ && FPA < 0 || activeVerticalMode === 23 /* DES */) && canInitiateDes(distanceToDestination)) {
          this.changePhase(4 /* Descent */);
        }
      }
    }
    handleFcuVSKnob(distanceToDestination, onStepClimbDescent) {
      if (this.phase === 2 /* Climb */ || this.phase === 3 /* Cruise */) {
        setTimeout(() => {
          const activeVerticalMode = SimVar.GetSimVarValue("L:A32NX_FMA_VERTICAL_MODE", "Enum");
          const VS = SimVar.GetSimVarValue("L:A32NX_AUTOPILOT_VS_SELECTED", "feet per minute");
          const FPA = SimVar.GetSimVarValue("L:A32NX_AUTOPILOT_FPA_SELECTED", "Degrees");
          if (activeVerticalMode === 14 /* VS */ && VS < 0 || activeVerticalMode === 15 /* FPA */ && FPA < 0) {
            if (canInitiateDes(distanceToDestination)) {
              this.changePhase(4 /* Descent */);
            } else {
              onStepClimbDescent();
            }
          }
        }, 100);
      }
    }
    handleNewCruiseAltitudeEntered(newCruiseFlightLevel) {
      const currentFlightLevel = Math.round(SimVar.GetSimVarValue("INDICATED ALTITUDE:3", "feet") / 100);
      if (this.activePhase === 5 /* Approach */) {
        this.changePhase(2 /* Climb */);
      } else if (currentFlightLevel < newCruiseFlightLevel && this.activePhase === 4 /* Descent */) {
        this.changePhase(2 /* Climb */);
      } else if (currentFlightLevel > newCruiseFlightLevel && (this.activePhase === 2 /* Climb */ || this.activePhase === 4 /* Descent */)) {
        this.changePhase(3 /* Cruise */);
      }
    }
    handleNewDestinationAirportEntered() {
      if (this.activePhase === 6 /* GoAround */) {
        const accAlt = isAllEngineOn() ? Arinc429Word.fromSimVarValue("L:A32NX_FM1_MISSED_ACC_ALT") : Arinc429Word.fromSimVarValue("L:A32NX_FM1_MISSED_EO_ACC_ALT");
        if (Simplane.getAltitude() > accAlt.valueOr(0)) {
          this.changePhase(2 /* Climb */);
        }
      }
    }
    changePhase(newPhase) {
      const prevPhase = this.phase;
      console.log(`FMGC Flight Phase: ${prevPhase} => ${newPhase}`);
      this.activePhase = newPhase;
      SimVar.SetSimVarValue("L:A32NX_FMGC_FLIGHT_PHASE", "number", newPhase);
      SimVar.SetSimVarValue("L:AIRLINER_FLIGHT_PHASE", "number", newPhase < 1 /* Takeoff */ ? 0 /* Preflight */ : newPhase + 1);
      this.phases[this.phase].init();
      for (const pcl of this.phaseChangeListeners) {
        pcl(prevPhase, newPhase);
      }
      this.shouldActivateNextPhase(0);
    }
    tryGoInApproachPhase() {
      if (this.phase === 0 /* Preflight */ || this.phase === 1 /* Takeoff */ || this.phase === 7 /* Done */) {
        return false;
      }
      if (this.phase !== 5 /* Approach */) {
        this.changePhase(5 /* Approach */);
      }
      return true;
    }
    shouldActivateDonePhase(_deltaTime) {
      this.onGroundConfirmationNode.input = isOnGround();
      this.onGroundConfirmationNode.update(_deltaTime);
      return this.onGroundConfirmationNode.output && !isAnEngineOn() && this.phase !== 7 /* Done */ && this.phase !== 0 /* Preflight */;
    }
    handleSlewSituation(_deltaTime) {
      switch (this.phase) {
        case 0 /* Preflight */:
        case 1 /* Takeoff */:
        case 7 /* Done */:
          if (Simplane.getAltitudeAboveGround() >= 1500) {
            this.changePhase(2 /* Climb */);
          }
          break;
        default:
      }
    }
  };

  // src/systems/fmgc/src/flightphase/index.ts
  var flightPhaseManager = new FlightPhaseManager();
  function getFlightPhaseManager() {
    return flightPhaseManager;
  }

  // src/systems/shared/src/MathUtils.ts
  var _MathUtils = class {
    static fastToFixed(val, fraction2) {
      if (fraction2 <= 0) {
        return Math.round(val).toString();
      }
      let coefficient = _MathUtils.optiPow10[fraction2];
      if (!coefficient || Number.isNaN(coefficient)) {
        coefficient = 10 ** fraction2;
        _MathUtils.optiPow10[fraction2] = coefficient;
      }
      return (Math.round(val * coefficient) / coefficient).toString();
    }
    static fastToFixedNum(val, fraction2) {
      if (fraction2 <= 0) {
        return Math.round(val);
      }
      let coefficient = _MathUtils.optiPow10[fraction2];
      if (!coefficient || Number.isNaN(coefficient)) {
        coefficient = 10 ** fraction2;
        _MathUtils.optiPow10[fraction2] = coefficient;
      }
      return Math.round(val * coefficient) / coefficient;
    }
    static angleAdd(a, b) {
      let r = a + b;
      while (r > 360) {
        r -= 360;
      }
      while (r < 0) {
        r += 360;
      }
      return r;
    }
    static diffAngle(a, b, direction) {
      let diff = b - a;
      while (diff > 180) {
        diff -= 360;
      }
      while (diff <= -180) {
        diff += 360;
      }
      if (diff < 0 && direction === 2 /* Right */) {
        diff += 360;
      }
      if (diff > 0 && direction === 1 /* Left */) {
        diff -= 360;
      }
      return diff;
    }
    static adjustAngleForTurnDirection(angle, turnDirection) {
      let ret = angle;
      if (angle < 0 && turnDirection === 2 /* Right */) {
        ret += 360;
      }
      if (angle > 0 && turnDirection === 1 /* Left */) {
        ret -= 360;
      }
      return ret;
    }
    static smallCrossingAngle(xyAngle, zyAngle) {
      let correctedXyBearing = xyAngle - zyAngle;
      if (correctedXyBearing < 0) {
        correctedXyBearing = 360 + correctedXyBearing;
      }
      let xyzAngle = 180 - correctedXyBearing;
      if (xyzAngle < 0) {
        xyzAngle = 360 + xyzAngle;
      }
      return xyzAngle;
    }
    static mod(x, n) {
      return x - Math.floor(x / n) * n;
    }
    static highestPower2(n) {
      let res = 0;
      for (let i = n; i >= 1; i--) {
        if ((i & i - 1) === 0) {
          res = i;
          break;
        }
      }
      return res;
    }
    static unpackPowers(n) {
      const res = [];
      let x = n;
      while (x > 0) {
        const pow3 = _MathUtils.highestPower2(x);
        res.push(pow3);
        x -= pow3;
      }
      return res;
    }
    static packPowers(ns) {
      if (ns.some((it) => it === 0 || (it & it - 1) !== 0)) {
        throw new Error("Cannot pack number which is not a power of 2 or is equal to zero.");
      }
      return ns.reduce((acc, v) => acc + v);
    }
    static convertCtoK(celsius) {
      return celsius + 273.15;
    }
    static convertMachToKTas(mach, oat) {
      return mach * 661.4786 * Math.sqrt(oat / 288.15);
    }
    static convertKTASToMach(tas, oat) {
      return tas / 661.4786 / Math.sqrt(oat / 288.15);
    }
    static convertTasToKCas(tas, oat, pressure) {
      return 1479.1 * Math.sqrt((pressure / 1013 * ((1 + 1 / (oat / 288.15) * (tas / 1479.1) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1);
    }
    static convertKCasToKTAS(kcas, oat, pressure) {
      return 1479.1 * Math.sqrt(oat / 288.15 * ((1 / (pressure / 1013) * ((1 + 0.2 * (kcas / 661.4786) ** 2) ** 3.5 - 1) + 1) ** (1 / 3.5) - 1));
    }
    static convertMachToKCas(mach, oat, pressure) {
      return _MathUtils.convertTasToKCas(_MathUtils.convertMachToKTas(mach, oat), oat, pressure);
    }
    static computeGreatCircleDistance(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
      const lat0 = pos0Lat * _MathUtils.DEGREES_TO_RADIANS;
      const lon0 = pos0Lon * _MathUtils.DEGREES_TO_RADIANS;
      const lat1 = pos1Lat * _MathUtils.DEGREES_TO_RADIANS;
      const lon1 = pos1Lon * _MathUtils.DEGREES_TO_RADIANS;
      const dlon = lon1 - lon0;
      const cosLat0 = Math.cos(lat0);
      const cosLat1 = Math.cos(lat1);
      const a1 = Math.sin((lat1 - lat0) / 2);
      const a2 = Math.sin(dlon / 2);
      return Math.asin(Math.sqrt(a1 * a1 + cosLat0 * cosLat1 * a2 * a2)) * 6880.126;
    }
    static computeGreatCircleHeading(pos0Lat, pos0Lon, pos1Lat, pos1Lon) {
      const lat0 = pos0Lat * _MathUtils.DEGREES_TO_RADIANS;
      const lon0 = pos0Lon * _MathUtils.DEGREES_TO_RADIANS;
      const lat1 = pos1Lat * _MathUtils.DEGREES_TO_RADIANS;
      const lon1 = pos1Lon * _MathUtils.DEGREES_TO_RADIANS;
      const dlon = lon1 - lon0;
      const cosLat1 = Math.cos(lat1);
      let x = Math.sin(lat1 - lat0);
      const sinLon2 = Math.sin(dlon / 2);
      x += sinLon2 * sinLon2 * 2 * Math.sin(lat0) * cosLat1;
      let heading = Math.atan2(cosLat1 * Math.sin(dlon), x);
      if (heading < 0) {
        heading += 2 * Math.PI;
      }
      return heading * _MathUtils.RADIANS_TO_DEGREES;
    }
    static computeDistance3D(pos0Lat, pos0Lon, pos0alt, pos1Lat, pos1Lon, pos1alt) {
      const earthRadius = 3440.065;
      const deg2rad = Math.PI / 180;
      const radius1 = pos0alt / 6076 + earthRadius;
      const radius2 = pos1alt / 6076 + earthRadius;
      const x1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.cos(deg2rad * (pos0Lon + 180));
      const y1 = radius1 * Math.sin(deg2rad * (pos0Lat + 90)) * Math.sin(deg2rad * (pos0Lon + 180));
      const z1 = radius1 * Math.cos(deg2rad * (pos0Lat + 90));
      const x2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.cos(deg2rad * (pos1Lon + 180));
      const y2 = radius2 * Math.sin(deg2rad * (pos1Lat + 90)) * Math.sin(deg2rad * (pos1Lon + 180));
      const z2 = radius2 * Math.cos(deg2rad * (pos1Lat + 90));
      return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
    }
    static pointInEllipse(xPos, yPos, xLimPos, yLimPos, xLimNeg = xLimPos, yLimNeg = yLimPos) {
      return xPos ** 2 / (xPos >= 0 ? xLimPos : xLimNeg) ** 2 + yPos ** 2 / (yPos >= 0 ? yLimPos : yLimNeg) ** 2 <= 1;
    }
    static pointInPolygon(xPos, yPos, polygon) {
      let odd = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; i++) {
        if (polygon[i][1] > yPos !== polygon[j][1] > yPos && xPos < (polygon[j][0] - polygon[i][0]) * (yPos - polygon[i][1]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0]) {
          odd = !odd;
        }
        j = i;
      }
      return odd;
    }
    static intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      if (x1 === x2 && y1 === y2 || x3 === x4 && y3 === y4) {
        return null;
      }
      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      if (denominator === 0) {
        return null;
      }
      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
      const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;
      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
        return null;
      }
      const x = x1 + ua * (x2 - x1);
      const y = y1 + ua * (y2 - y1);
      return [x, y];
    }
    static intersectWithPolygon(x1, y1, x2, y2, polygon) {
      let ret = null;
      polygon.forEach((xy, index, polygon2) => {
        if (ret)
          return;
        if (index + 1 >= polygon2.length) {
          return;
        }
        const x3 = xy[0];
        const y3 = xy[1];
        const x4 = polygon2[index + 1][0];
        const y4 = polygon2[index + 1][1];
        ret = _MathUtils.intersect(x1, y1, x2, y2, x3, y3, x4, y4);
      });
      return ret;
    }
    static clamp(value, lower, upper) {
      return Math.min(Math.max(value, lower), upper);
    }
    static round(value, decimalPrecision) {
      const shift = 10 ** decimalPrecision;
      return Math.round((value + Number.EPSILON) * shift) / shift;
    }
  };
  var MathUtils = _MathUtils;
  __publicField(MathUtils, "DEGREES_TO_RADIANS", Math.PI / 180);
  __publicField(MathUtils, "RADIANS_TO_DEGREES", 180 / Math.PI);
  __publicField(MathUtils, "optiPow10", []);

  // src/systems/fmgc/src/guidance/lnav/CommonGeometry.ts
  function arcDistanceToGo(ppos, itp, centreFix, sweepAngle) {
    const itpBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, itp);
    const pposBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ppos);
    const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
    const refFrameOffset = Avionics.Utils.diffAngle(0, itpBearing);
    const pposAngle = sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - pposBearing) : Avionics.Utils.clampAngle(pposBearing - refFrameOffset);
    if (pposAngle >= 340) {
      return radius * Math.PI * Math.abs(sweepAngle) / 180;
    }
    if (pposAngle >= Math.abs(sweepAngle)) {
      return 0;
    }
    return radius * Math.PI * (Math.abs(sweepAngle) - pposAngle) / 180;
  }
  function arcGuidance(ppos, trueTrack, itp, centreFix, sweepAngle) {
    const bearingPpos = Avionics.Utils.computeGreatCircleHeading(
      centreFix,
      ppos
    );
    const desiredTrack = sweepAngle > 0 ? Avionics.Utils.clampAngle(bearingPpos + 90) : Avionics.Utils.clampAngle(bearingPpos - 90);
    const trackAngleError = Avionics.Utils.diffAngle(trueTrack, desiredTrack);
    const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, itp);
    const distanceFromCenter = Avionics.Utils.computeGreatCircleDistance(centreFix, ppos);
    const crossTrackError = sweepAngle > 0 ? distanceFromCenter - radius : radius - distanceFromCenter;
    const groundSpeed = SimVar.GetSimVarValue("GPS GROUND SPEED", "meters per second");
    const radiusInMetre = radius * 1852;
    const phiCommand = (sweepAngle > 0 ? 1 : -1) * Math.atan(groundSpeed * groundSpeed / (radiusInMetre * 9.81)) * (180 / Math.PI);
    return {
      law: 3 /* LATERAL_PATH */,
      trackAngleError,
      crossTrackError,
      phiCommand
    };
  }
  function pointOnCourseToFix(distanceFromEnd, course, fix) {
    return Avionics.Utils.bearingDistanceToCoordinates(
      Avionics.Utils.clampAngle(course + 180),
      distanceFromEnd,
      fix.lat,
      fix.long
    );
  }
  function pointOnArc(distanceFromFtp, ftp, centreFix, sweepAngle) {
    const radius = Avionics.Utils.computeGreatCircleDistance(centreFix, ftp);
    const distanceRatio = distanceFromFtp / arcLength(radius, sweepAngle);
    const angleFromFtp = -distanceRatio * sweepAngle;
    const centerToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(centreFix, ftp);
    return Avionics.Utils.bearingDistanceToCoordinates(
      Avionics.Utils.clampAngle(centerToTerminationBearing + angleFromFtp),
      radius,
      centreFix.lat,
      centreFix.long
    );
  }
  function minBank(segment) {
    return segment === 2 /* Enroute */ ? 5 : 10;
  }
  function maxBank(tas, pathCapture) {
    if (pathCapture) {
      if (tas < 100) {
        return 15 + tas / 10;
      }
      if (tas > 350) {
        return 19 + Math.max(0, (450 - tas) * 6 / 100);
      }
      return 25;
    }
    if (tas < 150) {
      return 15 + tas / 10;
    }
    if (tas > 300) {
      return 19 + Math.max(0, (450 - tas) * 11 / 150);
    }
    return 30;
  }
  function maxTad(tas) {
    if (tas === void 0) {
      return 10;
    }
    if (tas <= 100) {
      return 4;
    }
    if (tas >= 100 && tas <= 400) {
      return tas / 100 * 4;
    }
    return 16;
  }
  function courseToFixDistanceToGo(ppos, course, fix) {
    const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
    const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
    const pposToFixAngle = Avionics.Utils.diffAngle(pposToFixBearing, course);
    return Math.max(0, pposToFixDist * Math.cos(pposToFixAngle * Math.PI / 180));
  }
  function courseToFixGuidance(ppos, trueTrack, course, fix) {
    const pposToFixBearing = Avionics.Utils.computeGreatCircleHeading(ppos, fix);
    const pposToFixDist = Avionics.Utils.computeGreatCircleDistance(ppos, fix);
    const pposToFixAngle = Avionics.Utils.diffAngle(course, pposToFixBearing);
    const crossTrackError = pposToFixDist * Math.sin(pposToFixAngle * Math.PI / 180);
    const trackAngleError = Avionics.Utils.diffAngle(trueTrack, course);
    return {
      law: 3 /* LATERAL_PATH */,
      trackAngleError,
      crossTrackError,
      phiCommand: 0
    };
  }
  function sideOfPointOnCourseToFix(fix, course, point) {
    const bearingFixPoint = bearingTo(fix, point);
    const onOtherSide = Math.abs(MathUtils.diffAngle(bearingFixPoint, course)) < 3;
    if (onOtherSide) {
      return 1 /* After */;
    }
    return 0 /* Before */;
  }
  function getAlongTrackDistanceTo(start, end, ppos) {
    const R = 3440.1 /* EARTH_RADIUS_NM */;
    const d13 = Avionics.Utils.computeGreatCircleDistance(start, ppos) / R;
    const Theta13 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, ppos);
    const Theta12 = Avionics.Utils.DEG2RAD * Avionics.Utils.computeGreatCircleHeading(start, end);
    const deltaXt = Math.asin(Math.sin(d13) * Math.sin(Theta13 - Theta12));
    const deltaAt = Math.acos(Math.cos(d13) / Math.abs(Math.cos(deltaXt)));
    return deltaAt * Math.sign(Math.cos(Theta12 - Theta13)) * R;
  }
  function getIntermediatePoint(start, end, fraction2) {
    const Phi1 = start.lat * Avionics.Utils.DEG2RAD;
    const Gamma1 = start.long * Avionics.Utils.DEG2RAD;
    const Phi2 = end.lat * Avionics.Utils.DEG2RAD;
    const Gamma2 = end.long * Avionics.Utils.DEG2RAD;
    const deltaPhi = Phi2 - Phi1;
    const deltaGamma = Gamma2 - Gamma1;
    const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(Phi1) * Math.cos(Phi2) * Math.sin(deltaGamma / 2) * Math.sin(deltaGamma / 2);
    const delta = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const A = Math.sin((1 - fraction2) * delta) / Math.sin(delta);
    const B = Math.sin(fraction2 * delta) / Math.sin(delta);
    const x = A * Math.cos(Phi1) * Math.cos(Gamma1) + B * Math.cos(Phi2) * Math.cos(Gamma2);
    const y = A * Math.cos(Phi1) * Math.sin(Gamma1) + B * Math.cos(Phi2) * Math.sin(Gamma2);
    const z = A * Math.sin(Phi1) + B * Math.sin(Phi2);
    const Phi3 = Math.atan2(z, Math.sqrt(x * x + y * y));
    const Gamma3 = Math.atan2(y, x);
    return {
      lat: Phi3 * Avionics.Utils.RAD2DEG,
      long: Gamma3 * Avionics.Utils.RAD2DEG
    };
  }
  function fixToFixGuidance(ppos, trueTrack, from, to) {
    const totalTrackDistance = Avionics.Utils.computeGreatCircleDistance(from, to);
    const alongTrackDistance = getAlongTrackDistanceTo(from, to, ppos);
    const intermediatePoint = getIntermediatePoint(from, to, Math.min(Math.max(alongTrackDistance / totalTrackDistance, 0.05), 0.95));
    const desiredTrack = Avionics.Utils.computeGreatCircleHeading(intermediatePoint, to);
    const trackAngleError = MathUtils.mod(desiredTrack - trueTrack + 180, 360) - 180;
    const bearingAC = Avionics.Utils.computeGreatCircleHeading(from, ppos);
    const bearingAB = Avionics.Utils.computeGreatCircleHeading(from, to);
    const distanceAC = Avionics.Utils.computeDistance(from, ppos);
    const desiredOffset = 0;
    const actualOffset = Math.asin(
      Math.sin(Avionics.Utils.DEG2RAD * (distanceAC / 3440.1 /* EARTH_RADIUS_NM */)) * Math.sin(Avionics.Utils.DEG2RAD * (bearingAC - bearingAB))
    ) * Avionics.Utils.RAD2DEG * 3440.1 /* EARTH_RADIUS_NM */;
    const crossTrackError = desiredOffset - actualOffset;
    return {
      law: 3 /* LATERAL_PATH */,
      trackAngleError,
      crossTrackError,
      phiCommand: 0
    };
  }
  function arcLength(radius, sweepAngle) {
    const circumference = 2 * Math.PI * radius;
    return circumference / 360 * Math.abs(sweepAngle);
  }
  function reciprocal(course) {
    return Avionics.Utils.clampAngle(course + 180);
  }

  // src/systems/fmgc/src/guidance/lnav/PathVector.ts
  var DebugPointColour = /* @__PURE__ */ ((DebugPointColour2) => {
    DebugPointColour2[DebugPointColour2["White"] = 0] = "White";
    DebugPointColour2[DebugPointColour2["Green"] = 1] = "Green";
    DebugPointColour2[DebugPointColour2["Yellow"] = 2] = "Yellow";
    DebugPointColour2[DebugPointColour2["Cyan"] = 3] = "Cyan";
    DebugPointColour2[DebugPointColour2["Magenta"] = 4] = "Magenta";
    return DebugPointColour2;
  })(DebugPointColour || {});
  function pathVectorLength(vector) {
    if (vector.type === 0 /* Line */) {
      return Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.endPoint);
    }
    if (vector.type === 1 /* Arc */) {
      const radius = Avionics.Utils.computeGreatCircleDistance(vector.startPoint, vector.centrePoint);
      return arcLength(radius, vector.sweepAngle);
    }
    return 0;
  }
  function pathVectorPoint(vector, distanceFromEnd) {
    if (vector.type === 0 /* Line */) {
      return pointOnCourseToFix(distanceFromEnd, Avionics.Utils.computeGreatCircleHeading(vector.startPoint, vector.endPoint), vector.endPoint);
    }
    if (vector.type === 1 /* Arc */) {
      return pointOnArc(distanceFromEnd, vector.endPoint, vector.centrePoint, vector.sweepAngle);
    }
    return void 0;
  }

  // src/systems/fmgc/src/guidance/Guidable.ts
  var Guidable = class {
    constructor() {
      __publicField(this, "isNull", false);
      __publicField(this, "inboundGuidable");
      __publicField(this, "outboundGuidable");
      __publicField(this, "isComputed", false);
    }
    setNeighboringGuidables(inbound, outbound) {
      this.inboundGuidable = inbound;
      this.outboundGuidable = outbound;
    }
    getPathEndPoint() {
      if (this.isNull) {
        return this.inboundGuidable.getPathEndPoint();
      }
      if (this.predictedPath) {
        for (let i = this.predictedPath.length - 1; i >= 0; i--) {
          const vector = this.predictedPath[i];
          if (vector.type === 2 /* DebugPoint */) {
            continue;
          }
          if (vector.endPoint) {
            return vector.endPoint;
          }
        }
      }
      return void 0;
    }
    getPseudoWaypointLocation(distanceBeforeTerminator) {
      let accumulator = 0;
      for (const vector of [...this.predictedPath].reverse()) {
        const length = pathVectorLength(vector);
        if (accumulator + length > distanceBeforeTerminator) {
          return pathVectorPoint(vector, distanceBeforeTerminator - accumulator);
        }
        accumulator += length;
      }
      return void 0;
    }
    get startsInCircularArc() {
      return false;
    }
    get endsInCircularArc() {
      return false;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/Transition.ts
  var Transition = class extends Guidable {
    constructor(previousLeg, nextLeg) {
      super();
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "isFrozen", false);
      this.inboundGuidable = previousLeg;
      this.outboundGuidable = nextLeg;
    }
    freeze() {
      this.isFrozen = true;
    }
    setNeighboringLegs(previous, next) {
      this.previousLeg = previous;
      this.nextLeg = next;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
    }
  };

  // src/systems/fmgc/src/utils/Geo.ts
  var import_geolib = __toESM(require_es());

  // src/systems/fmgc/src/guidance/lnav/legs/Leg.ts
  var Leg = class extends Guidable {
    constructor() {
      super(...arguments);
      __publicField(this, "segment");
      __publicField(this, "constrainedTurnDirection");
      __publicField(this, "isNull", false);
      __publicField(this, "displayedOnMap", true);
      __publicField(this, "predictedTas");
      __publicField(this, "predictedGs");
    }
    get disableAutomaticSequencing() {
      return false;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
    }
    get distance() {
      try {
        return distanceTo(this.getPathStartPoint(), this.getPathEndPoint());
      } catch (e) {
        return 0;
      }
    }
    get overflyTermFix() {
      return false;
    }
    get initialLegTermPoint() {
      return this.getPathEndPoint();
    }
  };

  // src/systems/fmgc/src/guidance/lnav/transitions/DmeArcTransition.ts
  var tan2 = (input) => Math.tan(input * (Math.PI / 180));
  var DmeArcTransition = class extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "predictedPath", []);
      __publicField(this, "radius");
      __publicField(this, "itp");
      __publicField(this, "centre");
      __publicField(this, "ftp");
      __publicField(this, "sweepAngle");
      __publicField(this, "clockwise");
    }
    getPathStartPoint() {
      return this.itp;
    }
    getPathEndPoint() {
      return this.ftp;
    }
    recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
      if (this.isFrozen) {
        return;
      }
      this.radius = gs ** 2 / (9.81 * tan2(maxBank(tas, true))) / 6080.2;
      if (this.previousLeg instanceof AFLeg) {
        const turnDirection = Math.sign(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
        const nextLegReference = this.nextLeg.getPathStartPoint();
        const reference = placeBearingDistance(nextLegReference, this.nextLeg.inboundCourse + 90 * turnDirection, this.radius);
        const dme = this.previousLeg.centre;
        const turnCentre = closestSmallCircleIntersection(
          dme,
          this.previousLeg.radius + this.radius * turnDirection * -this.previousLeg.turnDirectionSign,
          reference,
          this.nextLeg.inboundCourse - 180
        );
        if (!turnCentre) {
          throw new Error("AFLeg did not intersect with previous leg offset reference");
        }
        this.centre = turnCentre;
        this.itp = placeBearingDistance(
          turnCentre,
          turnDirection * -this.previousLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre),
          this.radius
        );
        this.ftp = placeBearingDistance(
          turnCentre,
          this.nextLeg.inboundCourse - 90 * turnDirection,
          this.radius
        );
        this.sweepAngle = MathUtils.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
        this.clockwise = this.sweepAngle > 0;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: 1 /* Arc */,
          startPoint: this.itp,
          centrePoint: turnCentre,
          endPoint: this.ftp,
          sweepAngle: this.sweepAngle
        });
        this.isComputed = true;
        if (LnavConfig.DEBUG_PREDICTED_PATH) {
          this.addDebugPoints();
        }
      } else if (this.nextLeg instanceof AFLeg) {
        const turnDirection = Math.sign(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse));
        const reference = placeBearingDistance(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse + 90 * turnDirection, this.radius);
        const dme = this.nextLeg.centre;
        let turnCentre;
        if (this.previousLeg instanceof XFLeg && !(this.previousLeg instanceof AFLeg)) {
          const intersection = closestSmallCircleIntersection(
            dme,
            this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign,
            reference,
            this.previousLeg.outboundCourse
          );
          if (intersection) {
            turnCentre = intersection;
            this.itp = placeBearingDistance(
              turnCentre,
              this.previousLeg.outboundCourse - 90 * turnDirection,
              this.radius
            );
            this.ftp = placeBearingDistance(
              turnCentre,
              turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre),
              this.radius
            );
          } else {
            this.ftp = placeBearingDistance(
              dme,
              this.nextLeg.boundaryRadial,
              this.nextLeg.radius
            );
            const turnSign = turnDirection > 0 ? 1 : -1;
            turnCentre = placeBearingDistance(
              this.ftp,
              Avionics.Utils.clampAngle(this.nextLeg.boundaryRadial + (turnSign > 0 ? 180 : 0)),
              this.radius
            );
            this.itp = placeBearingDistance(
              turnCentre,
              Avionics.Utils.clampAngle(this.previousLeg.outboundCourse - turnSign * 90),
              this.radius
            );
          }
        } else {
          turnCentre = closestSmallCircleIntersection(
            dme,
            this.nextLeg.radius + this.radius * turnDirection * -this.nextLeg.turnDirectionSign,
            reference,
            this.previousLeg.outboundCourse
          );
          if (!turnCentre) {
            throw new Error("AFLeg did not intersect with previous leg offset reference");
          }
          this.itp = placeBearingDistance(
            turnCentre,
            this.previousLeg.outboundCourse - 90 * turnDirection,
            this.radius
          );
          this.ftp = placeBearingDistance(
            turnCentre,
            turnDirection * -this.nextLeg.turnDirectionSign === 1 ? bearingTo(turnCentre, dme) : bearingTo(dme, turnCentre),
            this.radius
          );
        }
        this.centre = turnCentre;
        this.sweepAngle = MathUtils.diffAngle(bearingTo(turnCentre, this.itp), bearingTo(turnCentre, this.ftp));
        this.clockwise = this.sweepAngle > 0;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: 1 /* Arc */,
          startPoint: this.itp,
          centrePoint: turnCentre,
          endPoint: this.ftp,
          sweepAngle: this.sweepAngle
        });
        this.isComputed = true;
        if (LnavConfig.DEBUG_PREDICTED_PATH) {
          this.predictedPath.push({
            type: 2 /* DebugPoint */,
            startPoint: reference,
            annotation: "DME TRANS REF"
          });
          this.addDebugPoints();
        }
      }
    }
    addDebugPoints() {
      if (this.itp && this.centre && this.ftp) {
        this.predictedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.itp,
            annotation: "DME TRANS ITP"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.centre,
            annotation: "DME TRANS C"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.ftp,
            annotation: "DME TRANS FTP"
          }
        );
      }
    }
    getTurningPoints() {
      return [this.itp, this.ftp];
    }
    get distance() {
      return pathVectorLength(this.predictedPath[0]);
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    getGuidanceParameters(ppos, trueTrack) {
      return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    getDistanceToGo(ppos) {
      return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    isAbeam(ppos) {
      const turningPoints = this.getTurningPoints();
      if (!turningPoints) {
        return false;
      }
      const [inbound, outbound] = turningPoints;
      const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
      const inHeadingAc = Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
      const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
      const outHeadingAc = Math.abs(MathUtils.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
      return inHeadingAc <= 90 && outHeadingAc >= 90;
    }
    get repr() {
      return `DME(${this.previousLeg.repr}, ${this.nextLeg.repr})`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/XF.ts
  var XFLeg = class extends Leg {
    constructor(fix) {
      super();
      this.fix = fix;
    }
    getPathEndPoint() {
      if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.fix.infos.coordinates;
    }
    get terminationWaypoint() {
      return this.fix;
    }
    get ident() {
      return this.fix.ident;
    }
    get overflyTermFix() {
      return this.metadata.isOverfly;
    }
    get overshot() {
      const side = sideOfPointOnCourseToFix(this.fix.infos.coordinates, this.outboundCourse, this.getPathStartPoint());
      return side === 1 /* After */;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      if (this.overshot) {
        return 0;
      }
      return distanceTo(startPoint, this.fix.infos.coordinates);
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/AF.ts
  var AFLeg = class extends XFLeg {
    constructor(fix, navaid, rho, theta, boundaryRadial, metadata, segment) {
      super(fix);
      this.navaid = navaid;
      this.rho = rho;
      this.theta = theta;
      this.boundaryRadial = boundaryRadial;
      this.metadata = metadata;
      __publicField(this, "predictedPath", []);
      __publicField(this, "centre");
      __publicField(this, "terminationRadial");
      __publicField(this, "bearing");
      __publicField(this, "arcStartPoint");
      __publicField(this, "arcEndPoint");
      __publicField(this, "radius");
      __publicField(this, "sweepAngle");
      __publicField(this, "clockwise");
      __publicField(this, "inboundCourse");
      __publicField(this, "outboundCourse");
      this.segment = segment;
      this.centre = navaid;
      this.radius = distanceTo(navaid, this.fix.infos.coordinates);
      this.terminationRadial = this.theta;
      this.bearing = Avionics.Utils.clampAngle(bearingTo(this.centre, this.fix.infos.coordinates) + 90 * this.turnDirectionSign);
      this.arcStartPoint = placeBearingDistance(this.centre, this.boundaryRadial, this.radius);
      this.arcEndPoint = placeBearingDistance(this.centre, this.terminationRadial, this.radius);
      this.inboundCourse = this.boundaryRadial + 90 * this.turnDirectionSign;
      this.outboundCourse = this.terminationRadial + 90 * this.turnDirectionSign;
    }
    getPathStartPoint() {
      return this.inboundGuidable instanceof DmeArcTransition ? this.inboundGuidable.getPathEndPoint() : this.arcStartPoint;
    }
    getPathEndPoint() {
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.arcEndPoint;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.sweepAngle = MathUtils.diffAngle(bearingTo(this.centre, this.getPathStartPoint()), bearingTo(this.centre, this.getPathEndPoint()));
      this.clockwise = this.sweepAngle > 0;
      const startPoint = this.inboundGuidable instanceof PathCaptureTransition ? this.inboundGuidable.getPathEndPoint() : this.getPathStartPoint();
      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: 1 /* Arc */,
        startPoint,
        centrePoint: this.centre,
        endPoint: this.getPathEndPoint(),
        sweepAngle: this.sweepAngle
      });
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.predictedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.getPathStartPoint(),
            annotation: "AF ITP"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.getPathEndPoint(),
            annotation: "AF FTP"
          }
        );
      }
    }
    get turnDirectionSign() {
      if (this.fix.turnDirection !== 2 /* Right */ && this.fix.turnDirection !== 1 /* Left */) {
        throw new Error("AFLeg found without specific turnDirection");
      }
      return this.fix.turnDirection === 1 /* Left */ ? -1 : 1;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    getGuidanceParameters(ppos, trueTrack) {
      return arcGuidance(ppos, trueTrack, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    getDistanceToGo(ppos) {
      return arcDistanceToGo(ppos, this.getPathStartPoint(), this.centre, this.sweepAngle);
    }
    isAbeam(ppos) {
      const bearingPpos = Avionics.Utils.computeGreatCircleHeading(
        this.centre,
        ppos
      );
      const bearingFrom = Avionics.Utils.computeGreatCircleHeading(
        this.centre,
        this.getPathStartPoint()
      );
      const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
      return trackAngleError >= 0;
    }
    get repr() {
      return `AF(${this.radius.toFixed(1)}NM) TO ${this.fix.ident}`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/TF.ts
  var TFLeg = class extends XFLeg {
    constructor(from, to, metadata, segment) {
      super(to);
      this.metadata = metadata;
      __publicField(this, "from");
      __publicField(this, "to");
      __publicField(this, "constraintType");
      __publicField(this, "course");
      __publicField(this, "computedPath", []);
      this.from = from;
      this.to = to;
      this.segment = segment;
      this.constraintType = to.constraintType;
      this.course = Avionics.Utils.computeGreatCircleHeading(
        this.from.infos.coordinates,
        this.to.infos.coordinates
      );
    }
    get inboundCourse() {
      return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
    }
    get outboundCourse() {
      return bearingTo(this.from.infos.coordinates, this.to.infos.coordinates);
    }
    get predictedPath() {
      return this.computedPath;
    }
    getPathStartPoint() {
      var _a;
      return ((_a = this.inboundGuidable) == null ? void 0 : _a.isComputed) ? this.inboundGuidable.getPathEndPoint() : this.from.infos.coordinates;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      const startPoint = this.getPathStartPoint();
      const endPoint = this.getPathEndPoint();
      this.computedPath.length = 0;
      if (this.overshot) {
        this.computedPath.push({
          type: 0 /* Line */,
          startPoint: endPoint,
          endPoint
        });
      } else {
        this.computedPath.push({
          type: 0 /* Line */,
          startPoint,
          endPoint
        });
      }
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.computedPath.push({
          type: 2 /* DebugPoint */,
          startPoint: endPoint,
          annotation: "TF END"
        });
      }
      this.isComputed = true;
    }
    getPseudoWaypointLocation(distanceBeforeTerminator) {
      return getIntermediatePoint(
        this.getPathStartPoint(),
        this.getPathEndPoint(),
        (this.distance - distanceBeforeTerminator) / this.distance
      );
    }
    getGuidanceParameters(ppos, trueTrack) {
      return fixToFixGuidance(ppos, trueTrack, this.from.infos.coordinates, this.to.infos.coordinates);
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getAircraftToLegBearing(ppos) {
      const aircraftToTerminationBearing = Avionics.Utils.computeGreatCircleHeading(ppos, this.to.infos.coordinates);
      const aircraftLegBearing = MathUtils.smallCrossingAngle(this.outboundCourse, aircraftToTerminationBearing);
      return aircraftLegBearing;
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    isAbeam(ppos) {
      const bearingAC = Avionics.Utils.computeGreatCircleHeading(this.from.infos.coordinates, ppos);
      const headingAC = Math.abs(MathUtils.diffAngle(this.inboundCourse, bearingAC));
      if (headingAC > 90) {
        return false;
      }
      const distanceAC = Avionics.Utils.computeDistance(this.from.infos.coordinates, ppos);
      const distanceAX = Math.cos(headingAC * Avionics.Utils.DEG2RAD) * distanceAC;
      return distanceAX <= this.distance;
    }
    get repr() {
      return `TF FROM ${this.from.ident} TO ${this.to.ident}`;
    }
  };

  // src/systems/fmgc/src/utils/Geo.ts
  var sin4 = (input) => Math.sin(input * (Math.PI / 180));
  var asin3 = (input) => Math.asin(input) * (180 / Math.PI);
  var Geo = class {
    static computeDestinationPoint(start, distance, bearing, radius = 6371e3) {
      const a = (0, import_geolib.computeDestinationPoint)(__spreadProps(__spreadValues({}, start), { lon: start.long }), distance * 1852, bearing, radius);
      return {
        lat: a.latitude,
        long: a.longitude
      };
    }
    static distanceToLeg(from, leg) {
      const intersections1 = placeBearingIntersection(
        from,
        Avionics.Utils.clampAngle(leg.outboundCourse - 90),
        leg.initialLegTermPoint,
        Avionics.Utils.clampAngle(leg.outboundCourse - 180)
      );
      const d1 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[0]);
      const d2 = Avionics.Utils.computeGreatCircleDistance(from, intersections1[1]);
      let legStartReference;
      if (leg instanceof TFLeg) {
        legStartReference = leg.from.infos.coordinates;
      } else {
        legStartReference = leg.getPathStartPoint();
      }
      if (!legStartReference) {
        return Math.min(d1, d2);
      }
      const intersections2 = placeBearingIntersection(
        from,
        Avionics.Utils.clampAngle(leg.outboundCourse - 90),
        legStartReference,
        Avionics.Utils.clampAngle(leg.outboundCourse - 180)
      );
      const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
      const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
      return Math.min(d1, d2, d3, d4);
    }
    static legIntercept(from, bearing, leg) {
      if (leg instanceof AFLeg) {
        const intersections = smallCircleGreatCircleIntersection(
          leg.centre,
          leg.radius,
          from,
          bearing
        );
        const d12 = Avionics.Utils.computeGreatCircleDistance(from, intersections[0]);
        const d22 = Avionics.Utils.computeGreatCircleDistance(from, intersections[1]);
        return d12 > d22 ? intersections[1] : intersections[0];
      }
      if (leg.getPathEndPoint() === void 0 || leg.outboundCourse === void 0) {
        throw new Error("[FMS/LNAV] Cannot compute leg intercept if leg end point or outbound course are undefined");
      }
      const intersections1 = placeBearingIntersection(
        from,
        Avionics.Utils.clampAngle(bearing),
        "fix" in leg ? leg.fix.infos.coordinates : leg.getPathEndPoint(),
        Avionics.Utils.clampAngle(leg.outboundCourse - 180)
      );
      const d1 = distanceTo(from, intersections1[0]);
      const d2 = distanceTo(from, intersections1[1]);
      if (!leg.getPathStartPoint()) {
        return d1 > d2 ? intersections1[1] : intersections1[0];
      }
      const intersections2 = placeBearingIntersection(
        from,
        Avionics.Utils.clampAngle(bearing),
        leg.getPathStartPoint(),
        Avionics.Utils.clampAngle(leg.outboundCourse - 180)
      );
      const d3 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[0]);
      const d4 = Avionics.Utils.computeGreatCircleDistance(from, intersections2[1]);
      const smallest = Math.min(d1, d2, d3, d4);
      if (smallest === d1) {
        return intersections1[0];
      }
      if (smallest === d2) {
        return intersections1[1];
      }
      if (smallest === d3) {
        return intersections2[0];
      }
      return intersections2[1];
    }
    static placeBearingPlaceDistanceIntercept(bearingPoint, distancePoint, bearing, distance) {
      const relativeBearing = bearingTo(bearingPoint, distancePoint);
      const distanceBetween = distanceTo(bearingPoint, distancePoint);
      const angleA = Math.abs(MathUtils.diffAngle(relativeBearing, bearing));
      const angleC = angleA > 90 ? asin3(distanceBetween * (sin4(angleA) / distance)) : 180 - asin3(distanceBetween * (sin4(angleA) / distance));
      const angleB = 180 - angleA - angleC;
      return placeBearingDistance(bearingPoint, bearing, Math.abs(sin4(angleB) * (distance / sin4(angleA))));
    }
    static doublePlaceBearingIntercept(pointA, pointB, bearingA, bearingB) {
      return A32NX_Util.greatCircleIntersection(pointA, bearingA, pointB, bearingB);
    }
  };

  // src/systems/fmgc/src/guidance/lnav/transitions/utilss/CourseChange.ts
  var CourseChange = class {
    static normal(turnDirection, turnCenterDistance, trackChange, radius) {
      if (turnDirection > 0) {
        if (turnCenterDistance >= radius) {
          return trackChange - 45;
        }
        return trackChange + 45;
      }
      if (-turnCenterDistance >= radius) {
        return trackChange + 45;
      }
      return trackChange - 45;
    }
    static reverse(turnDirection, turnCenterDistance, trackChange, radius) {
      if (trackChange > 0) {
        if (turnCenterDistance > 0) {
          if (turnCenterDistance > radius) {
            return trackChange - 45;
          }
          return trackChange + 45;
        }
        return trackChange + 45;
      }
      if (turnCenterDistance > 0) {
        return trackChange - 45;
      }
      if (-turnCenterDistance > radius) {
        return trackChange + 45;
      }
      return trackChange - 45;
    }
    static acuteFar(turnDirection, turnCenterDistance, trackChange) {
      return turnDirection * (45 - Math.abs(trackChange));
    }
    static acuteNear(turnDirection, turnCenterDistance, trackChange) {
      return trackChange + (turnDirection > 0 ? 45 : -45);
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/IF.ts
  var IFLeg = class extends XFLeg {
    constructor(fix, metadata, segment) {
      super(fix);
      this.metadata = metadata;
      this.segment = segment;
    }
    get predictedPath() {
      return [];
    }
    getPathStartPoint() {
      return this.fix.infos.coordinates;
    }
    getPathEndPoint() {
      return this.fix.infos.coordinates;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.isComputed = true;
    }
    setNeighboringGuidables(inbound, outbound) {
      if (outbound && !(outbound instanceof Leg) && outbound !== this.outboundGuidable) {
        console.error(`IF outboundGuidable must be a leg (is ${outbound == null ? void 0 : outbound.constructor})`);
      }
      super.setNeighboringGuidables(inbound, outbound);
    }
    get inboundCourse() {
      return void 0;
    }
    get outboundCourse() {
      return void 0;
    }
    get distance() {
      return 0;
    }
    getDistanceToGo(_ppos) {
      return void 0;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      var _a, _b;
      return (_b = (_a = this.outboundGuidable) == null ? void 0 : _a.getGuidanceParameters(ppos, trueTrack, tas, gs)) != null ? _b : void 0;
    }
    getNominalRollAngle(_gs) {
      return void 0;
    }
    getPseudoWaypointLocation(_distanceBeforeTerminator) {
      return void 0;
    }
    isAbeam(_ppos) {
      return false;
    }
    get repr() {
      return `IF AT ${this.fix.ident}`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/CF.ts
  var CFLeg = class extends XFLeg {
    constructor(fix, course, metadata, segment) {
      super(fix);
      this.course = course;
      this.metadata = metadata;
      __publicField(this, "computedPath", []);
      this.segment = segment;
    }
    getPathStartPoint() {
      if (this.inboundGuidable instanceof IFLeg) {
        return this.inboundGuidable.fix.infos.coordinates;
      }
      if (this.inboundGuidable instanceof Transition && this.inboundGuidable.isComputed) {
        return this.inboundGuidable.getPathEndPoint();
      }
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.estimateStartWithoutInboundTransition();
    }
    estimateStartWithoutInboundTransition() {
      const inverseCourse = Avionics.Utils.clampAngle(this.course + 180);
      if (this.inboundGuidable && this.inboundGuidable.isComputed) {
        const prevLegTerm = this.inboundGuidable.getPathEndPoint();
        return Geo.doublePlaceBearingIntercept(
          this.getPathEndPoint(),
          prevLegTerm,
          inverseCourse,
          Avionics.Utils.clampAngle(inverseCourse + 90)
        );
      }
      let distance = 1;
      if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
        distance = this.outboundGuidable.tad + 0.1;
      }
      return Avionics.Utils.bearingDistanceToCoordinates(
        inverseCourse,
        distance,
        this.fix.infos.coordinates.lat,
        this.fix.infos.coordinates.long
      );
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      if (this.overshot) {
        this.computedPath = [{
          type: 0 /* Line */,
          startPoint: this.getPathEndPoint(),
          endPoint: this.getPathEndPoint()
        }];
      } else {
        this.computedPath = [{
          type: 0 /* Line */,
          startPoint: this.getPathStartPoint(),
          endPoint: this.getPathEndPoint()
        }];
      }
      this.isComputed = true;
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.computedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.getPathStartPoint(),
            annotation: "CF START"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.getPathEndPoint(),
            annotation: "CF END"
          }
        );
      }
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    isAbeam(ppos) {
      const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      return dtg >= 0 && dtg <= this.distance;
    }
    get repr() {
      return `CF(${this.course.toFixed(1)}T) TO ${this.fix.ident}`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/PI.ts
  var PILeg = class extends Leg {
    constructor(fix, nextLeg, metadata, segment) {
      super();
      this.fix = fix;
      this.nextLeg = nextLeg;
      this.metadata = metadata;
      this.segment = segment;
      __publicField(this, "radius", 1);
      __publicField(this, "straight", {});
      __publicField(this, "turn1", {});
      __publicField(this, "outbound", {});
      __publicField(this, "turn2", {});
      __publicField(this, "intercept", {});
      __publicField(this, "state", 0 /* Straight */);
      __publicField(this, "debugPoints", []);
      this.recomputeWithParameters(false, 220, 220, { lat: 0, long: 0 }, 0);
    }
    recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
      if (isActive) {
        return;
      }
      if (this.nextLeg && !(this.nextLeg instanceof CFLeg)) {
        throw new Error("PI must be followed by CF!");
      } else if (!this.nextLeg) {
        return;
      }
      this.debugPoints.length = 0;
      const turn1Sign = this.fix.turnDirection === 1 /* Left */ ? 1 : -1;
      const turn2Sign = -1 * turn1Sign;
      const gsMs = gs / 1.94384;
      this.radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(tas, true) * Math.PI / 180)) / 1852;
      const minStraightDist = this.radius * 2;
      const brgToCf = Avionics.Utils.computeGreatCircleHeading(
        this.fix.infos.coordinates,
        this.nextLeg.fix.infos.coordinates
      );
      const distToCf = Avionics.Utils.computeGreatCircleDistance(
        this.fix.infos.coordinates,
        this.nextLeg.fix.infos.coordinates
      );
      const cfInverseCrs = (this.nextLeg.course + 180) % 360;
      this.outbound.course = this.fix.additionalData.course;
      this.straight.itp = this.fix.infos.coordinates;
      this.straight.course = cfInverseCrs;
      let tp;
      if (Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, brgToCf)) < 90 && distToCf > minStraightDist) {
        tp = this.nextLeg.fix.infos.coordinates;
      } else {
        [tp] = smallCircleGreatCircleIntersection(
          this.fix.infos.coordinates,
          minStraightDist,
          this.nextLeg.fix.infos.coordinates,
          cfInverseCrs
        ).filter((p) => Math.abs(Avionics.Utils.diffAngle(cfInverseCrs, bearingTo(this.nextLeg.fix.infos.coordinates, p))) < 90);
        this.straight.course = Avionics.Utils.computeGreatCircleHeading(
          this.fix.infos.coordinates,
          tp
        );
      }
      this.turn1.sweepAngle = turn1Sign * Math.abs(Avionics.Utils.diffAngle(this.straight.course, this.outbound.course));
      const tpT1FtpDist = this.radius * Math.tan(Math.abs(this.turn1.sweepAngle) * Math.PI / 360);
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(
        this.outbound.course,
        tpT1FtpDist,
        tp.lat,
        tp.long
      );
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        (360 + this.outbound.course + turn1Sign * 90) % 360,
        this.radius,
        this.turn1.ftp.lat,
        this.turn1.ftp.long
      );
      this.turn1.itp = Avionics.Utils.bearingDistanceToCoordinates(
        (this.straight.course + 180) % 360,
        this.radius * (1 - Math.cos(this.turn1.sweepAngle * Math.PI / 180)),
        tp.lat,
        tp.long
      );
      this.turn1.length = Math.abs(this.turn1.sweepAngle / 180 * this.radius);
      this.straight.ftp = this.turn1.itp;
      this.straight.length = Avionics.Utils.computeGreatCircleDistance(
        this.fix.infos.coordinates,
        this.turn1.itp
      );
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: tp,
          annotation: "TP",
          colour: 2 /* Yellow */
        });
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn1.itp,
          annotation: "ITP1",
          colour: 4 /* Magenta */
        });
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn1.arcCentre,
          annotation: "AC1",
          colour: 4 /* Magenta */
        });
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn1.ftp,
          annotation: "FTP1",
          colour: 4 /* Magenta */
        });
      }
      const theta = Math.abs(Avionics.Utils.diffAngle(this.outbound.course, (this.nextLeg.course + 180) % 360)) * Math.PI / 180;
      this.outbound.length = this.radius * (1 / Math.tan(theta / 2));
      this.outbound.itp = this.turn1.ftp;
      this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(
        this.outbound.course,
        this.outbound.length + tpT1FtpDist,
        tp.lat,
        tp.long
      );
      this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        (360 + this.outbound.course + turn2Sign * 90) % 360,
        this.radius,
        this.turn2.itp.lat,
        this.turn2.itp.long
      );
      this.turn2.sweepAngle = turn2Sign * 180;
      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(
        (360 + this.outbound.course + turn2Sign * 90) % 360,
        this.radius,
        this.turn2.arcCentre.lat,
        this.turn2.arcCentre.long
      );
      this.turn2.length = Math.abs(this.turn2.sweepAngle / 180 * this.radius);
      this.outbound.ftp = this.turn2.itp;
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn2.itp,
          annotation: "ITP2",
          colour: 3 /* Cyan */
        });
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn2.arcCentre,
          annotation: "AC2",
          colour: 3 /* Cyan */
        });
        this.debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn2.ftp,
          annotation: "FTP2",
          colour: 3 /* Cyan */
        });
      }
      this.intercept.itp = this.turn2.ftp;
      this.intercept.ftp = A32NX_Util.greatCircleIntersection(
        this.turn2.ftp,
        (this.outbound.course + 180) % 360,
        tp,
        cfInverseCrs
      );
      this.intercept.length = Avionics.Utils.computeGreatCircleDistance(
        this.intercept.itp,
        this.intercept.ftp
      );
      this.intercept.course = Avionics.Utils.computeGreatCircleHeading(
        this.intercept.itp,
        this.intercept.ftp
      );
      this.isComputed = true;
    }
    get initialLegTermPoint() {
      return this.turn1.itp;
    }
    get distanceToTermination() {
      return this.straight.length;
    }
    get distance() {
      return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + this.straight.length;
    }
    get turnAreaExceeded() {
      if (!this.turn2) {
        return false;
      }
      const maxExcursion = distanceTo(
        this.fix.infos.coordinates,
        this.turn2.arcCentre
      ) + this.radius;
      return maxExcursion > this.fix.additionalData.distance;
    }
    getDistanceToGo(ppos) {
      switch (this.state) {
        case 4 /* Intercept */:
          return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);
        case 3 /* Turn2 */:
          return this.intercept.length + arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
        case 2 /* Outbound */:
          return this.intercept.length + this.turn2.length + courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);
        case 1 /* Turn1 */:
          return this.intercept.length + this.turn2.length + this.outbound.length + arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
        case 0 /* Straight */:
          return this.intercept.length + this.turn2.length + this.outbound.length + this.turn1.length + courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);
        default:
          return 1;
      }
    }
    dtgCurrentSegment(ppos) {
      switch (this.state) {
        case 4 /* Intercept */:
          return courseToFixDistanceToGo(ppos, this.intercept.course, this.intercept.ftp);
        case 3 /* Turn2 */:
          return arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
        case 2 /* Outbound */:
          return courseToFixDistanceToGo(ppos, this.outbound.course, this.outbound.ftp);
        case 1 /* Turn1 */:
          return arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
        case 0 /* Straight */:
          return courseToFixDistanceToGo(ppos, this.straight.course, this.straight.ftp);
        default:
          return 0;
      }
    }
    radCurrentSegment(tas, gs) {
      const turn1Sign = this.fix.turnDirection === 1 /* Left */ ? 1 : -1;
      const turn2Sign = -1 * turn1Sign;
      let currentBank;
      let nextBank;
      switch (this.state) {
        case 1 /* Turn1 */:
          currentBank = turn1Sign * maxBank(tas, true);
          nextBank = 0;
          break;
        case 3 /* Turn2 */:
          currentBank = turn2Sign * maxBank(tas, true);
          nextBank = 0;
          break;
        case 0 /* Straight */:
          currentBank = 0;
          nextBank = turn1Sign * maxBank(tas, true);
          break;
        case 2 /* Outbound */:
          currentBank = 0;
          nextBank = turn2Sign * maxBank(tas, true);
          break;
        default:
          return [0, 0];
      }
      return [Geometry.getRollAnticipationDistance(gs, currentBank, nextBank), nextBank];
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      var _a;
      let dtg = this.dtgCurrentSegment(ppos);
      if (dtg <= 0 && this.state < 4 /* Intercept */) {
        this.state++;
        dtg = this.dtgCurrentSegment(ppos);
      }
      let params;
      switch (this.state) {
        case 4 /* Intercept */:
          return (_a = this.nextLeg) == null ? void 0 : _a.getGuidanceParameters(ppos, trueTrack, tas);
        case 3 /* Turn2 */:
          return arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
        case 2 /* Outbound */:
          params = courseToFixGuidance(ppos, trueTrack, this.outbound.course, this.outbound.ftp);
          break;
        case 1 /* Turn1 */:
          params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          break;
        case 0 /* Straight */:
          params = courseToFixGuidance(ppos, trueTrack, this.straight.course, this.straight.ftp);
          break;
        default:
      }
      const [rad, nextBank] = this.radCurrentSegment(tas, gs);
      if (params && rad > 0 && dtg <= rad) {
        params.phiCommand = nextBank;
      }
      return params;
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getPathStartPoint() {
      var _a;
      return ((_a = this.inboundGuidable) == null ? void 0 : _a.isComputed) ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates;
    }
    getPathEndPoint() {
      return this.intercept.ftp;
    }
    get terminationWaypoint() {
      return this.intercept.ftp;
    }
    get inboundCourse() {
      var _a;
      return (_a = this.straight.course) != null ? _a : 0;
    }
    get outboundCourse() {
      var _a, _b;
      return (_b = (_a = this.nextLeg) == null ? void 0 : _a.course) != null ? _b : 0;
    }
    isAbeam(_ppos) {
      return true;
    }
    get predictedPath() {
      var _a;
      return [
        {
          type: 0 /* Line */,
          startPoint: ((_a = this.inboundGuidable) == null ? void 0 : _a.isComputed) ? this.inboundGuidable.getPathEndPoint() : this.fix.infos.coordinates,
          endPoint: this.turn1.itp
        },
        {
          type: 1 /* Arc */,
          startPoint: this.turn1.itp,
          centrePoint: this.turn1.arcCentre,
          endPoint: this.turn1.ftp,
          sweepAngle: this.turn1.sweepAngle
        },
        {
          type: 0 /* Line */,
          startPoint: this.turn1.ftp,
          endPoint: this.turn2.itp
        },
        {
          type: 1 /* Arc */,
          startPoint: this.turn2.itp,
          centrePoint: this.turn2.arcCentre,
          endPoint: this.turn2.ftp,
          sweepAngle: this.turn2.sweepAngle
        },
        {
          type: 0 /* Line */,
          startPoint: this.turn2.ftp,
          endPoint: this.intercept.ftp
        },
        ...this.debugPoints
      ];
    }
    get ident() {
      return "INTCPT";
    }
    get repr() {
      return `PI ${this.ident}`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/index.ts
  function isHold(leg) {
    return leg instanceof HALeg || leg instanceof HFLeg || leg instanceof HMLeg;
  }
  function isCourseReversalLeg(leg) {
    return isHold(leg) || leg instanceof PILeg;
  }

  // src/systems/fmgc/src/guidance/lnav/transitions/PathCaptureTransition.ts
  var cos4 = (input) => Math.cos(input * (Math.PI / 180));
  var tan3 = (input) => Math.tan(input * MathUtils.DEGREES_TO_RADIANS);
  var compareTurnDirections = (sign4, data) => {
    if ((data === 1 /* Left */ || data === 2 /* Right */) && (sign4 === -1 || sign4 === 1)) {
      return data === 1 /* Left */ && sign4 === -1 || data === 2 /* Right */ && sign4 === 1;
    }
    return true;
  };
  var PathCaptureTransition = class extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "startWithTad", false);
      __publicField(this, "predictedPath", []);
      __publicField(this, "itp");
      __publicField(this, "ftp");
      __publicField(this, "tad");
      __publicField(this, "forcedTurnComplete", false);
      __publicField(this, "computedTurnDirection", 3 /* Either */);
      __publicField(this, "computedTargetTrack", 0);
      __publicField(this, "distance", 0);
    }
    getPathStartPoint() {
      return this.itp;
    }
    get turnDirection() {
      return this.nextLeg.metadata.turnDirection;
    }
    get deltaTrack() {
      return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
    }
    recomputeWithParameters(_isActive, tas, gs, _ppos, _trueTrack) {
      if (this.isFrozen) {
        return;
      }
      if (!(this.inboundGuidable instanceof Leg)) {
        throw new Error("[FMS/Geometry/PathCapture] previousGuidable must be a leg");
      }
      const targetTrack = this.inboundGuidable.outboundCourse;
      const naturalTurnDirectionSign = Math.sign(MathUtils.diffAngle(targetTrack, this.nextLeg.inboundCourse));
      this.computedTurnDirection = 3 /* Either */;
      this.computedTargetTrack = this.nextLeg.inboundCourse;
      let prevLegTermFix;
      if (this.previousLeg instanceof AFLeg) {
        prevLegTermFix = this.previousLeg.arcEndPoint;
      } else {
        prevLegTermFix = this.previousLeg.terminationWaypoint instanceof WayPoint ? this.previousLeg.terminationWaypoint.infos.coordinates : this.previousLeg.terminationWaypoint;
      }
      let initialTurningPoint;
      if (this.startWithTad) {
        const prevLegDistanceToTerm = this.previousLeg.distanceToTermination;
        this.tad = Math.min(maxTad(tas), prevLegDistanceToTerm - 0.05);
        if ("from" in this.previousLeg) {
          const start = this.previousLeg.from.infos.coordinates;
          const end = this.previousLeg.to.infos.coordinates;
          const length = distanceTo(start, end);
          const ratio = (length - this.tad) / length;
          initialTurningPoint = getIntermediatePoint(start, end, ratio);
        } else {
          initialTurningPoint = placeBearingDistance(
            prevLegTermFix,
            reciprocal(this.previousLeg.outboundCourse),
            this.tad
          );
        }
      } else {
        this.tad = 0;
        initialTurningPoint = prevLegTermFix;
      }
      const distanceFromItp = Geo.distanceToLeg(initialTurningPoint, this.nextLeg);
      const desiredDirection = isCourseReversalLeg(this.nextLeg) ? 3 /* Either */ : this.nextLeg.metadata.turnDirection;
      const deltaTrack = MathUtils.diffAngle(targetTrack, this.nextLeg.inboundCourse, desiredDirection);
      this.predictedPath.length = 0;
      if (Math.abs(deltaTrack) < 3 && distanceFromItp < 0.1) {
        this.itp = this.previousLeg.getPathEndPoint();
        this.ftp = this.previousLeg.getPathEndPoint();
        this.predictedPath.push({
          type: 0 /* Line */,
          startPoint: this.previousLeg.getPathEndPoint(),
          endPoint: this.previousLeg.getPathEndPoint()
        });
        this.isNull = true;
        this.distance = 0;
        this.isComputed = true;
        return;
      }
      this.isNull = false;
      if (Math.abs(deltaTrack) > 42 && Math.abs(deltaTrack) < 48 && distanceFromItp > 0.01) {
        this.computeDirectIntercept();
        this.isComputed = true;
        return;
      }
      let turnDirection = Math.sign(deltaTrack);
      const radius = gs ** 2 / (9.81 /* G */ * tan3(maxBank(tas, true)) * 6997.84) * LnavConfig.TURN_RADIUS_FACTOR;
      const distanceLimit = radius * cos4(48);
      let turnCenter = placeBearingDistance(initialTurningPoint, targetTrack + turnDirection * 90, radius);
      let turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
      let courseChange;
      if (Math.abs(deltaTrack) < 45) {
        if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
          turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
          turnDirection = -turnDirection;
          turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
          courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
        } else {
          courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
        }
      } else if (Math.abs(deltaTrack) >= 45 && !compareTurnDirections(turnDirection, this.nextLeg.metadata.turnDirection)) {
        turnCenter = placeBearingDistance(initialTurningPoint, targetTrack - turnDirection * 90, radius);
        turnDirection = -turnDirection;
        turnCenterDistance = Math.sign(MathUtils.diffAngle(bearingTo(turnCenter, this.nextLeg.getPathEndPoint()), this.nextLeg.outboundCourse)) * Geo.distanceToLeg(turnCenter, this.nextLeg);
      }
      if (distanceLimit <= Math.abs(turnCenterDistance) && Math.abs(turnCenterDistance) < radius) {
        const radiusToLeg = radius - Math.abs(turnCenterDistance);
        let intercept2;
        if ("from" in this.nextLeg) {
          const intersects = smallCircleGreatCircleIntersection(turnCenter, radius, this.nextLeg.from.infos.coordinates, this.nextLeg.outboundCourse);
          if (intersects) {
            const [one, two] = intersects;
            if (distanceTo(initialTurningPoint, one) > distanceTo(initialTurningPoint, two)) {
              intercept2 = one;
            } else {
              intercept2 = two;
            }
          }
        } else {
          intercept2 = firstSmallCircleIntersection(turnCenter, radius, this.nextLeg.getPathEndPoint(), reciprocal(this.nextLeg.outboundCourse));
        }
        if (!intercept2 && radiusToLeg < 0.1) {
          this.computeDirectIntercept();
          this.isComputed = true;
          return;
        }
        if (intercept2 && !Number.isNaN(intercept2.lat)) {
          const bearingTcFtp = bearingTo(turnCenter, intercept2);
          const angleToLeg = MathUtils.diffAngle(
            Avionics.Utils.clampAngle(bearingTcFtp - (turnDirection > 0 ? -90 : 90)),
            this.nextLeg.outboundCourse
          );
          if (Math.abs(angleToLeg) <= 48) {
            this.itp = initialTurningPoint;
            this.ftp = intercept2;
            this.predictedPath.push({
              type: 1 /* Arc */,
              startPoint: initialTurningPoint,
              endPoint: intercept2,
              centrePoint: turnCenter,
              sweepAngle: Math.abs(deltaTrack) * turnDirection
            });
            this.distance = arcLength(radius, Math.abs(deltaTrack) * turnDirection);
            if (LnavConfig.DEBUG_PREDICTED_PATH) {
              this.predictedPath.push(
                {
                  type: 2 /* DebugPoint */,
                  startPoint: initialTurningPoint,
                  annotation: "PATH CAPTURE ARC START"
                },
                {
                  type: 2 /* DebugPoint */,
                  startPoint: turnCenter,
                  annotation: "PATH CAPTURE CENTRE"
                },
                {
                  type: 2 /* DebugPoint */,
                  startPoint: intercept2,
                  annotation: "PATH CAPTURE INTCPT"
                }
              );
            }
            this.isComputed = true;
            return;
          }
        }
      }
      if (Math.abs(deltaTrack) < 45) {
        if (deltaTrack > 0 && turnCenterDistance >= radius || deltaTrack < 0 && turnCenterDistance <= -radius) {
          courseChange = CourseChange.acuteFar(turnDirection, turnCenterDistance, deltaTrack);
        } else {
          courseChange = CourseChange.acuteNear(turnDirection, turnCenterDistance, deltaTrack);
        }
      } else {
        const isReverse = !compareTurnDirections(naturalTurnDirectionSign, this.nextLeg.metadata.turnDirection);
        if (isReverse) {
          courseChange = CourseChange.reverse(turnDirection, turnCenterDistance, deltaTrack, radius);
          this.computedTurnDirection = this.nextLeg.metadata.turnDirection;
        } else {
          courseChange = CourseChange.normal(turnDirection, turnCenterDistance, deltaTrack, radius);
          this.computedTurnDirection = turnDirection < 0 ? 1 /* Left */ : 2 /* Right */;
        }
      }
      this.computedTargetTrack = (360 + this.previousLeg.outboundCourse + courseChange) % 360;
      const finalTurningPoint = placeBearingDistance(turnCenter, targetTrack + courseChange - 90 * turnDirection, radius);
      let intercept;
      if ("from" in this.nextLeg) {
        const intersections = placeBearingIntersection(
          finalTurningPoint,
          Avionics.Utils.clampAngle(targetTrack + courseChange),
          this.nextLeg.from.infos.coordinates,
          this.nextLeg.outboundCourse
        );
        if (intersections) {
          const [one, two] = intersections;
          if (distanceTo(finalTurningPoint, one) < distanceTo(finalTurningPoint, two)) {
            intercept = one;
          } else {
            intercept = two;
          }
        }
      } else {
        intercept = Geo.legIntercept(finalTurningPoint, targetTrack + courseChange, this.nextLeg);
      }
      const overshot = sideOfPointOnCourseToFix(finalTurningPoint, targetTrack + courseChange, intercept) === 0 /* Before */;
      this.itp = initialTurningPoint;
      this.ftp = finalTurningPoint;
      this.isComputed = true;
      this.predictedPath.push(
        {
          type: 1 /* Arc */,
          startPoint: initialTurningPoint,
          endPoint: finalTurningPoint,
          centrePoint: turnCenter,
          sweepAngle: courseChange
        }
      );
      if (!overshot) {
        this.predictedPath.push({
          type: 0 /* Line */,
          startPoint: finalTurningPoint,
          endPoint: intercept
        });
      }
      this.distance = arcLength(radius, courseChange) + (overshot ? 0 : distanceTo(finalTurningPoint, intercept));
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.predictedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: initialTurningPoint,
            annotation: "PATH CAPTURE ARC START"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: turnCenter,
            annotation: "PATH CAPTURE CENTRE"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: finalTurningPoint,
            annotation: "PATH CAPTURE ARC EMD"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: intercept,
            annotation: "PATH CAPTURE INTCPT"
          }
        );
      }
    }
    computeDirectIntercept() {
      const intercept = Geo.legIntercept(this.previousLeg.getPathEndPoint(), this.previousLeg.outboundCourse, this.nextLeg);
      this.itp = this.previousLeg.getPathEndPoint();
      this.ftp = intercept;
      this.predictedPath.push({
        type: 0 /* Line */,
        startPoint: this.previousLeg.getPathEndPoint(),
        endPoint: intercept
      });
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.predictedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.previousLeg.getPathEndPoint(),
            annotation: "PATH CAPTURE START"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: intercept,
            annotation: "PATH CAPTURE INTCPT"
          }
        );
      }
      this.distance = distanceTo(this.previousLeg.getPathEndPoint(), intercept);
    }
    get startsInCircularArc() {
      return false;
    }
    get endsInCircularArc() {
      return false;
    }
    isAbeam(ppos) {
      return !this.isNull && this.computedTurnDirection !== 3 /* Either */ && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
    }
    getTurningPoints() {
      return [this.itp, this.ftp];
    }
    getDistanceToGo(_ppos) {
      return 1;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (this.computedTurnDirection !== 3 /* Either */) {
        const turnSign = this.computedTurnDirection === 1 /* Left */ ? -1 : 1;
        let trackAngleError = this.computedTargetTrack - trueTrack;
        if (turnSign !== Math.sign(trackAngleError)) {
          trackAngleError += turnSign * 360;
        }
        if (Math.abs(trackAngleError) > 130) {
          const phiCommand = turnSign * maxBank(tas, true);
          return {
            law: 3 /* LATERAL_PATH */,
            trackAngleError: 0,
            phiCommand,
            crossTrackError: 0
          };
        }
        this.forcedTurnComplete = true;
      }
      return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    get repr() {
      return `PATH CAPTURE(${this.previousLeg.repr} TO ${this.nextLeg.repr})`;
    }
    getActualDistanceToGo(ppos, trueTrack) {
      let dtg = 0;
      for (const path of this.predictedPath) {
        if (path.type === 1 /* Arc */) {
          const turnSign = this.computedTurnDirection === 1 /* Left */ ? -1 : 1;
          let trackAngleError = this.computedTargetTrack - trueTrack;
          if (turnSign !== Math.sign(trackAngleError)) {
            trackAngleError += turnSign * 360;
          }
          dtg += pathVectorLength(path) * trackAngleError / path.sweepAngle;
        } else if (path.type === 0 /* Line */) {
          dtg += Math.min(pathVectorLength(path), distanceTo(path.endPoint, ppos));
        }
      }
      return dtg;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/CI.ts
  var CILeg = class extends Leg {
    constructor(course, nextLeg, metadata, segment) {
      super();
      this.course = course;
      this.nextLeg = nextLeg;
      this.metadata = metadata;
      __publicField(this, "computedPath", []);
      __publicField(this, "intercept");
      this.segment = segment;
    }
    get terminationWaypoint() {
      return this.intercept;
    }
    get distanceToTermFix() {
      return Avionics.Utils.computeGreatCircleDistance(this.getPathStartPoint(), this.intercept);
    }
    get ident() {
      return "INTCPT";
    }
    getPathStartPoint() {
      if (this.inboundGuidable instanceof IFLeg) {
        return this.inboundGuidable.fix.infos.coordinates;
      }
      if (this.inboundGuidable && this.inboundGuidable.isComputed) {
        return this.inboundGuidable.getPathEndPoint();
      }
      throw new Error("[CILeg] No computed inbound guidable.");
    }
    getPathEndPoint() {
      if (this.outboundGuidable instanceof FixedRadiusTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      if (this.outboundGuidable instanceof DmeArcTransition && this.outboundGuidable.isComputed) {
        return this.outboundGuidable.getPathStartPoint();
      }
      return this.intercept;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.intercept = Geo.legIntercept(
        this.getPathStartPoint(),
        this.course,
        this.nextLeg
      );
      const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
      const overshot = side === 1 /* After */;
      if (this.intercept && !Number.isNaN(this.intercept.lat) && !overshot) {
        this.isNull = false;
        this.computedPath = [{
          type: 0 /* Line */,
          startPoint: this.getPathStartPoint(),
          endPoint: this.getPathEndPoint()
        }];
        this.isComputed = true;
        if (LnavConfig.DEBUG_PREDICTED_PATH) {
          this.computedPath.push(
            {
              type: 2 /* DebugPoint */,
              startPoint: this.getPathStartPoint(),
              annotation: "CI START"
            },
            {
              type: 2 /* DebugPoint */,
              startPoint: this.getPathEndPoint(),
              annotation: "CI END"
            }
          );
        }
      } else {
        this.computedPath.length = 0;
        this.isNull = true;
        this.isComputed = true;
      }
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      return distanceTo(startPoint, this.intercept);
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    getGuidanceParameters(_ppos, _trueTrack) {
      return {
        law: 2 /* TRACK */,
        course: this.course
      };
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    isAbeam(ppos) {
      const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      return dtg >= 0 && dtg <= this.distance;
    }
    get repr() {
      return `CI(${Math.trunc(this.course)}T)`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/transitions/FixedRadiusTransition.ts
  var mod2 = (x, n) => x - Math.floor(x / n) * n;
  var FixedRadiusTransition = class extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "radius");
      __publicField(this, "tad");
      __publicField(this, "clockwise");
      __publicField(this, "isFrozen", false);
      __publicField(this, "computedPath", []);
      __publicField(this, "sweepAngle");
      __publicField(this, "centre");
      __publicField(this, "revertTo");
      __publicField(this, "turningPoints");
    }
    get isReverted() {
      return this.revertTo !== void 0;
    }
    getPathStartPoint() {
      if (this.revertTo) {
        return this.revertTo.getPathStartPoint();
      }
      if (this.isComputed) {
        return this.turningPoints[0];
      }
      throw Error("?");
    }
    getPathEndPoint() {
      if (this.revertTo) {
        return this.revertTo.getPathEndPoint();
      }
      if (this.isComputed) {
        return this.turningPoints[1];
      }
      throw Error("?");
    }
    recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
      if (this.isFrozen) {
        if (DEBUG) {
          console.log("[FMS/Geometry] Not recomputing Type I transition as it is frozen.");
        }
        return;
      }
      this.sweepAngle = MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse);
      const bankAngle = Math.abs(this.sweepAngle) / 2;
      const finalBankAngle = Math.max(Math.min(bankAngle, maxBank(tas, true)), minBank(this.nextLeg.segment));
      this.radius = tas ** 2 / (9.81 * Math.tan(finalBankAngle * Avionics.Utils.DEG2RAD)) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
      this.tad = this.radius * Math.tan(Math.abs(this.sweepAngle / 2) * MathUtils.DEGREES_TO_RADIANS);
      const prevLegTermDistanceToNextLeg = Geo.distanceToLeg(
        this.previousLeg instanceof XFLeg ? this.previousLeg.fix.infos.coordinates : this.previousLeg.intercept,
        this.nextLeg
      );
      const defaultTurnDirection = this.sweepAngle >= 0 ? 2 /* Right */ : 1 /* Left */;
      const forcedTurn = (this.nextLeg.metadata.turnDirection === 1 /* Left */ || this.nextLeg.metadata.turnDirection === 2 /* Right */) && defaultTurnDirection !== this.nextLeg.metadata.turnDirection;
      const tooBigForPrevious = this.previousLeg.distanceToTermination < this.tad + 0.1;
      const tooBigForNext = "from" in this.nextLeg ? distanceTo(this.nextLeg.from.infos.coordinates, this.nextLeg.to.infos.coordinates) < this.tad + 0.1 : false;
      const notLinedUp = Math.abs(prevLegTermDistanceToNextLeg) >= 0.25;
      const shouldRevert = Math.abs(this.sweepAngle) <= 3 || Math.abs(this.sweepAngle) > 175 || this.previousLeg.overflyTermFix || forcedTurn || tooBigForPrevious || tooBigForNext || notLinedUp;
      const previousLegOvershot = "overshot" in this.previousLeg && this.previousLeg.overshot;
      if (shouldRevert && !previousLegOvershot) {
        const shouldHaveTad = !this.previousLeg.overflyTermFix && !notLinedUp && (tooBigForPrevious || tooBigForNext);
        if (!this.revertTo) {
          const reverted = new PathCaptureTransition(this.previousLeg, this.nextLeg);
          reverted.startWithTad = shouldHaveTad;
          reverted.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
          const reversionTad = reverted.tad;
          const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.tad;
          if (fixDtg > reversionTad) {
            this.revertTo = reverted;
            this.isComputed = this.revertTo.isComputed;
            return;
          }
        } else {
          this.revertTo.startWithTad = shouldHaveTad;
          this.revertTo.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
          this.isComputed = this.revertTo.isComputed;
          return;
        }
      }
      if (this.revertTo) {
        const fixDtg = this.previousLeg.getDistanceToGo(ppos) + this.revertTo.tad;
        if (fixDtg > this.tad + 0.05 || !isActive) {
          this.revertTo = void 0;
        }
      }
      this.clockwise = this.sweepAngle >= 0;
      this.turningPoints = this.computeTurningPoints();
      this.computedPath.length = 0;
      this.computedPath.push(
        {
          type: 1 /* Arc */,
          startPoint: this.getTurningPoints()[0],
          centrePoint: this.centre,
          endPoint: this.getTurningPoints()[1],
          sweepAngle: this.sweepAngle
        }
      );
      this.isComputed = true;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    isAbeam(ppos) {
      if (this.revertTo !== void 0) {
        return this.revertTo.isAbeam(ppos);
      }
      const turningPoints = this.getTurningPoints();
      if (!turningPoints) {
        return false;
      }
      const [inbound, outbound] = turningPoints;
      const inBearingAc = Avionics.Utils.computeGreatCircleHeading(inbound, ppos);
      const inHeadingAc = Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, inBearingAc));
      const outBearingAc = Avionics.Utils.computeGreatCircleHeading(outbound, ppos);
      const outHeadingAc = Math.abs(MathUtils.diffAngle(this.nextLeg.inboundCourse, outBearingAc));
      return inHeadingAc <= 90 && outHeadingAc >= 90;
    }
    get distance() {
      if (this.revertTo) {
        return this.revertTo.distance;
      }
      return arcLength(this.radius, this.sweepAngle);
    }
    get unflownDistance() {
      if (this.revertTo) {
        return 0;
      }
      if (!this.getTurningPoints()) {
        return 0;
      }
      return Avionics.Utils.computeGreatCircleDistance(
        this.previousLeg.getPathEndPoint(),
        this.getTurningPoints()[0]
      );
    }
    computeTurningPoints() {
      const { lat, long } = this.previousLeg instanceof CILeg ? this.previousLeg.intercept : this.previousLeg.fix.infos.coordinates;
      const inbound = Avionics.Utils.bearingDistanceToCoordinates(
        mod2(this.previousLeg.outboundCourse + 180, 360),
        this.tad,
        lat,
        long
      );
      const outbound = Avionics.Utils.bearingDistanceToCoordinates(
        this.nextLeg.inboundCourse,
        this.tad,
        lat,
        long
      );
      this.centre = Avionics.Utils.bearingDistanceToCoordinates(
        Avionics.Utils.clampAngle(this.previousLeg.outboundCourse + (this.clockwise ? 90 : -90)),
        this.radius,
        inbound.lat,
        inbound.long
      );
      return [inbound, outbound];
    }
    getTurningPoints() {
      if (this.revertTo) {
        return this.revertTo.getTurningPoints();
      }
      return this.turningPoints;
    }
    get predictedPath() {
      if (this.revertTo) {
        return this.revertTo.predictedPath;
      }
      return this.computedPath;
    }
    getDistanceToGo(ppos) {
      if (this.revertTo) {
        return this.revertTo.getDistanceToGo(ppos);
      }
      const [itp] = this.getTurningPoints();
      return arcDistanceToGo(ppos, itp, this.centre, this.sweepAngle);
    }
    getGuidanceParameters(ppos, trueTrack, tas) {
      if (this.revertTo) {
        return this.revertTo.getGuidanceParameters(ppos, trueTrack, tas);
      }
      const [itp] = this.getTurningPoints();
      return arcGuidance(ppos, trueTrack, itp, this.centre, this.sweepAngle);
    }
    getNominalRollAngle(gs) {
      if (this.revertTo) {
        return this.revertTo.getNominalRollAngle(gs);
      }
      return (this.clockwise ? 1 : -1) * Math.atan((gs * 463 / 900) ** 2 / (this.radius * 1852 * 9.81 /* G */)) * (180 / Math.PI);
    }
    get repr() {
      return `TYPE1(${this.previousLeg.repr} TO ${this.nextLeg.repr})`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/transitions/CourseCaptureTransition.ts
  var tan4 = (input) => Math.tan(input * (Math.PI / 180));
  var CourseCaptureTransition = class extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "terminator");
      __publicField(this, "isArc");
      __publicField(this, "startPoint");
      __publicField(this, "endPoint");
      __publicField(this, "center");
      __publicField(this, "sweepAngle");
      __publicField(this, "radius");
      __publicField(this, "clockwise");
      __publicField(this, "predictedPath", []);
      __publicField(this, "forcedTurnComplete", false);
      __publicField(this, "computedTurnDirection", 3 /* Either */);
    }
    getPathStartPoint() {
      return this.previousLeg.getPathEndPoint();
    }
    getPathEndPoint() {
      return this.terminator;
    }
    get turnDirection() {
      return Math.sign(this.courseVariation) === -1 ? 1 /* Left */ : 2 /* Right */;
    }
    get deltaTrack() {
      return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
    }
    get courseVariation() {
      return MathUtils.adjustAngleForTurnDirection(this.deltaTrack, this.nextLeg.metadata.turnDirection);
    }
    recomputeWithParameters(_isActive, tas, gs, ppos, _trueTrack) {
      const termFix = this.previousLeg.getPathEndPoint();
      this.computedTurnDirection = 3 /* Either */;
      let courseChange;
      let initialTurningPoint;
      if (!this.inboundGuidable) {
        if (this.courseVariation <= 90) {
          courseChange = this.deltaTrack;
        } else if (Math.sign(this.courseVariation) === Math.sign(this.deltaTrack)) {
          courseChange = this.deltaTrack;
        } else {
          courseChange = Math.sign(this.courseVariation) * 360 + this.deltaTrack;
        }
        initialTurningPoint = ppos;
      } else {
        courseChange = this.courseVariation;
        initialTurningPoint = termFix;
      }
      const radius = gs ** 2 / (9.81 /* G */ * tan4(Math.abs(maxBank(tas, false)))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
      const turnCenter = Geo.computeDestinationPoint(initialTurningPoint, radius, this.previousLeg.outboundCourse + 90 * Math.sign(courseChange));
      const finalTurningPoint = Geo.computeDestinationPoint(turnCenter, radius, this.previousLeg.outboundCourse - 90 * Math.sign(courseChange) + courseChange);
      this.radius = radius;
      this.clockwise = courseChange >= 0;
      if (courseChange === 0) {
        this.isArc = false;
        this.startPoint = this.previousLeg.getPathEndPoint();
        this.endPoint = this.previousLeg.getPathEndPoint();
        this.terminator = this.endPoint;
        this.isComputed = true;
        this.predictedPath.length = 0;
        this.predictedPath.push({
          type: 0 /* Line */,
          startPoint: this.startPoint,
          endPoint: this.endPoint
        });
        this.isNull = true;
        return;
      }
      this.computedTurnDirection = this.clockwise ? 2 /* Right */ : 1 /* Left */;
      this.isNull = false;
      this.isArc = true;
      this.startPoint = initialTurningPoint;
      this.center = turnCenter;
      this.endPoint = finalTurningPoint;
      this.sweepAngle = courseChange;
      this.terminator = this.endPoint;
      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: 1 /* Arc */,
        startPoint: this.startPoint,
        centrePoint: this.center,
        endPoint: this.endPoint,
        sweepAngle: this.sweepAngle
      });
      this.isComputed = true;
    }
    get startsInCircularArc() {
      return this.isArc;
    }
    get endsInCircularArc() {
      return this.isArc;
    }
    get angle() {
      return this.sweepAngle;
    }
    isAbeam(ppos) {
      return !this.isNull && this.computedTurnDirection !== 3 /* Either */ && !this.forcedTurnComplete && this.previousLeg.getDistanceToGo(ppos) <= 0;
    }
    get distance() {
      if (this.isNull) {
        return 0;
      }
      return arcLength(this.radius, this.angle);
    }
    getTurningPoints() {
      return [this.startPoint, this.endPoint];
    }
    getDistanceToGo(ppos) {
      const [itp] = this.getTurningPoints();
      return arcDistanceToGo(ppos, itp, this.center, this.clockwise ? this.angle : -this.angle);
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (this.computedTurnDirection !== 3 /* Either */) {
        const turnSign = this.computedTurnDirection === 1 /* Left */ ? -1 : 1;
        let trackAngleError = this.nextLeg.inboundCourse - trueTrack;
        if (turnSign !== Math.sign(trackAngleError)) {
          trackAngleError += turnSign * 360;
        }
        if (Math.abs(trackAngleError) > 130) {
          const phiCommand = turnSign * maxBank(tas, false);
          return {
            law: 3 /* LATERAL_PATH */,
            trackAngleError: 0,
            phiCommand,
            crossTrackError: 0
          };
        }
        this.forcedTurnComplete = true;
      }
      return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    get repr() {
      return `COURSE CAPTURE(${this.previousLeg.repr} TO ${this.nextLeg.repr})`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/transitions/DirectToFixTransition.ts
  var tan5 = (input) => Math.tan(input * (Math.PI / 180));
  var acos2 = (input) => Math.acos(input) * (180 / Math.PI);
  var DirectToFixTransitionGuidanceState = /* @__PURE__ */ ((DirectToFixTransitionGuidanceState2) => {
    DirectToFixTransitionGuidanceState2[DirectToFixTransitionGuidanceState2["Straight"] = 0] = "Straight";
    DirectToFixTransitionGuidanceState2[DirectToFixTransitionGuidanceState2["Turn"] = 1] = "Turn";
    return DirectToFixTransitionGuidanceState2;
  })(DirectToFixTransitionGuidanceState || {});
  var DirectToFixTransition = class extends Transition {
    constructor(previousLeg, nextLeg) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "state", 0 /* Straight */);
      __publicField(this, "straightCourse");
      __publicField(this, "terminator");
      __publicField(this, "hasArc");
      __publicField(this, "center");
      __publicField(this, "radius");
      __publicField(this, "clockwise");
      __publicField(this, "lineStartPoint");
      __publicField(this, "lineEndPoint");
      __publicField(this, "arcStartPoint");
      __publicField(this, "arcCentrePoint");
      __publicField(this, "arcEndPoint");
      __publicField(this, "arcSweepAngle");
      __publicField(this, "computedPath", []);
    }
    getPathStartPoint() {
      return this.previousLeg.getPathEndPoint();
    }
    get turnDirection() {
      return Math.sign(this.deltaTrack);
    }
    get deltaTrack() {
      return MathUtils.fastToFixedNum(MathUtils.diffAngle(this.previousLeg.outboundCourse, this.nextLeg.inboundCourse), 1);
    }
    get courseVariation() {
      return this.deltaTrack;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(isActive, tas, gs, _ppos, _trueTrack) {
      if (this.isFrozen) {
        return;
      }
      const termFix = this.previousLeg.getPathEndPoint();
      const nextFix = this.nextLeg.fix.infos.coordinates;
      this.radius = gs ** 2 / (9.81 /* G */ * tan5(maxBank(tas, true))) / 6997.84 * LnavConfig.TURN_RADIUS_FACTOR;
      let trackChange = MathUtils.diffAngle(this.previousLeg.outboundCourse, bearingTo(this.previousLeg.getPathEndPoint(), nextFix), this.nextLeg.metadata.turnDirection);
      if (Math.abs(trackChange) < 3 || !Number.isFinite(trackChange)) {
        this.isNull = true;
        this.isComputed = true;
        return;
      }
      const turnDirectionSign = trackChange > 0 ? 1 : -1;
      const turnDirection = turnDirectionSign > 0 ? 2 /* Right */ : 1 /* Left */;
      const currentRollAngle = isActive ? -SimVar.GetSimVarValue("PLANE BANK DEGREES", "degrees") : 0;
      const rollAngleChange = Math.abs(turnDirectionSign * maxBank(tas, true) - currentRollAngle);
      const rollAnticipationDistance = Geometry.getRollAnticipationDistance(gs, 0, rollAngleChange);
      let itp = rollAnticipationDistance >= 0.05 ? placeBearingDistance(termFix, this.previousLeg.outboundCourse, rollAnticipationDistance) : termFix;
      let turnCentre = placeBearingDistance(itp, this.previousLeg.outboundCourse + turnDirectionSign * 90, this.radius);
      let distanceToFix = distanceTo(turnCentre, nextFix);
      if (distanceToFix < this.radius) {
        if (Math.abs(MathUtils.diffAngle(this.previousLeg.outboundCourse, bearingTo(termFix, nextFix), this.nextLeg.metadata.turnDirection)) < 60) {
          this.hasArc = false;
          this.lineStartPoint = termFix;
          this.lineEndPoint = termFix;
          this.terminator = this.lineEndPoint;
          this.predictedPath.length = 0;
          this.predictedPath.push({
            type: 0 /* Line */,
            startPoint: this.lineStartPoint,
            endPoint: this.lineEndPoint
          });
          if (LnavConfig.DEBUG_PREDICTED_PATH) {
            this.predictedPath.push(...this.getPathDebugPoints());
          }
          this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
          this.isNull = true;
          this.isComputed = true;
          return;
        }
        const tcFixBearing = bearingTo(turnCentre, nextFix);
        const extendDist = Math.sqrt(this.radius ** 2 - distanceToFix ** 2 * Math.sin((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) ** 2) + distanceToFix * Math.cos((tcFixBearing - this.previousLeg.outboundCourse) * Math.PI / 180) + 0.3;
        itp = placeBearingDistance(itp, this.previousLeg.outboundCourse, extendDist);
        turnCentre = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse, extendDist);
        distanceToFix = distanceTo(turnCentre, nextFix);
      }
      const bearingTcItp = bearingTo(turnCentre, itp);
      const bearingTcFix = bearingTo(turnCentre, nextFix);
      const angleFtpFix = acos2(this.radius / distanceToFix);
      trackChange = MathUtils.diffAngle(bearingTcItp, MathUtils.diffAngle(turnDirectionSign * angleFtpFix, bearingTcFix), turnDirection);
      const ftp = placeBearingDistance(turnCentre, this.previousLeg.outboundCourse + trackChange - 90 * turnDirectionSign, this.radius);
      this.lineStartPoint = this.previousLeg.getPathEndPoint();
      this.lineEndPoint = itp;
      this.hasArc = true;
      this.arcStartPoint = itp;
      this.arcCentrePoint = turnCentre;
      this.arcEndPoint = ftp;
      this.arcSweepAngle = trackChange;
      this.terminator = this.arcEndPoint;
      this.predictedPath.length = 0;
      this.predictedPath.push({
        type: 0 /* Line */,
        startPoint: this.lineStartPoint,
        endPoint: this.lineEndPoint
      });
      this.predictedPath.push({
        type: 1 /* Arc */,
        startPoint: this.arcStartPoint,
        centrePoint: this.arcCentrePoint,
        endPoint: this.arcEndPoint,
        sweepAngle: this.arcSweepAngle
      });
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.predictedPath.push(...this.getPathDebugPoints());
      }
      this.straightCourse = bearingTo(this.lineStartPoint, this.lineEndPoint);
      this.isNull = false;
      this.isComputed = true;
    }
    getPathDebugPoints() {
      const points = [];
      points.push(
        {
          type: 2 /* DebugPoint */,
          startPoint: this.lineStartPoint,
          annotation: "T4 RAD START"
        },
        {
          type: 2 /* DebugPoint */,
          startPoint: this.lineEndPoint,
          annotation: "T4 RAD END"
        }
      );
      if (this.hasArc) {
        points.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.arcStartPoint,
            annotation: "T4 ARC START"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.arcCentrePoint
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.arcEndPoint,
            annotation: "T4 ARC END"
          }
        );
      }
      return points;
    }
    get endsInCircularArc() {
      return this.hasArc;
    }
    isAbeam(ppos) {
      if (this.isNull) {
        return false;
      }
      let dtg = 0;
      if (this.state === 0 /* Straight */) {
        const straightDist = distanceTo(this.lineStartPoint, this.lineEndPoint);
        const straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
        dtg += straightDtg;
        if (dtg >= straightDist) {
          return false;
        }
      }
      if (this.hasArc) {
        if (this.state === 1 /* Turn */) {
          const arcDtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
          dtg += arcDtg;
        } else {
          dtg += arcLength(this.radius, this.arcSweepAngle);
        }
      }
      return dtg > 0;
    }
    get distance() {
      if (this.isNull) {
        return 0;
      }
      const straightDistance = distanceTo(this.lineStartPoint, this.lineEndPoint);
      if (this.hasArc) {
        return straightDistance + arcLength(this.radius, this.arcSweepAngle);
      }
      return straightDistance;
    }
    getTurningPoints() {
      return [this.arcStartPoint, this.arcEndPoint];
    }
    getDistanceToGo(ppos) {
      let straightDtg = 0;
      if (this.state === 0 /* Straight */) {
        straightDtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
      }
      if (!this.hasArc) {
        return straightDtg;
      }
      return straightDtg + arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
    }
    getGuidanceParameters(ppos, trueTrack, tas) {
      let dtg;
      let params;
      switch (this.state) {
        case 0 /* Straight */:
          dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.lineEndPoint);
          if (dtg <= 0 && this.hasArc) {
            this.state = 1 /* Turn */;
          }
          break;
        case 1 /* Turn */:
          dtg = arcDistanceToGo(ppos, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
          break;
        default:
      }
      switch (this.state) {
        case 0 /* Straight */:
          params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.lineEndPoint);
          let bankNext = 0;
          if (this.hasArc) {
            bankNext = this.arcSweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, false);
          }
          const rad = Geometry.getRollAnticipationDistance(tas, 0, bankNext);
          if (dtg <= rad) {
            params.phiCommand = bankNext;
          }
          break;
        case 1 /* Turn */:
          params = arcGuidance(ppos, trueTrack, this.arcStartPoint, this.arcCentrePoint, this.arcSweepAngle);
          break;
        default:
      }
      return params;
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    get repr() {
      return `DIRECT TO FIX(${this.previousLeg.repr} TO ${this.nextLeg.repr})`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/CA.ts
  var CALeg = class extends Leg {
    constructor(course, altitude, metadata, segment, extraLength) {
      super();
      this.course = course;
      this.altitude = altitude;
      this.metadata = metadata;
      this.extraLength = extraLength;
      __publicField(this, "estimatedTermination");
      __publicField(this, "computedPath", []);
      __publicField(this, "start");
      __publicField(this, "wasMovedByPpos", false);
      this.segment = segment;
    }
    get terminationWaypoint() {
      return this.estimatedTermination;
    }
    get ident() {
      return Math.round(this.altitude).toString();
    }
    getPathStartPoint() {
      var _a;
      return (_a = this.inboundGuidable) == null ? void 0 : _a.getPathEndPoint();
    }
    getPathEndPoint() {
      return this.estimatedTermination;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(isActive, _tas, _gs, ppos, _trueTrack) {
      var _a;
      const afterRunway = this.inboundGuidable instanceof IFLeg && (this.inboundGuidable.fix.isRunway || this.inboundGuidable.fix.icao.startsWith("A"));
      if (isActive && !afterRunway) {
        this.wasMovedByPpos = true;
        if (!this.start) {
          this.start = __spreadValues({}, ppos);
        } else {
          this.start.lat = ppos.lat;
          this.start.long = ppos.long;
        }
        if (!this.estimatedTermination) {
          this.recomputeEstimatedTermination();
        }
      } else if (!this.wasMovedByPpos) {
        const newPreviousGuidableStart = (_a = this.inboundGuidable) == null ? void 0 : _a.getPathEndPoint();
        if (newPreviousGuidableStart) {
          if (!this.start) {
            this.start = __spreadValues({}, newPreviousGuidableStart);
          } else {
            this.start.lat = newPreviousGuidableStart.lat;
            this.start.long = newPreviousGuidableStart.long;
          }
        }
        this.recomputeEstimatedTermination();
      }
      this.computedPath = [{
        type: 0 /* Line */,
        startPoint: this.start,
        endPoint: this.getPathEndPoint()
      }];
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.computedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.start,
            annotation: "CA START"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.getPathEndPoint(),
            annotation: "CA END"
          }
        );
      }
      this.isComputed = true;
    }
    recomputeEstimatedTermination() {
      const ESTIMATED_VS = 2e3;
      const ESTIMATED_KTS = 175;
      let originAltitude = 0;
      if (this.inboundGuidable instanceof IFLeg && this.inboundGuidable.fix.icao.startsWith("A")) {
        originAltitude = this.inboundGuidable.fix.infos.oneWayRunways[0].elevation * 3.28084;
      }
      const minutesToAltitude = (this.altitude - Math.max(0, originAltitude)) / ESTIMATED_VS;
      let distanceToTermination = minutesToAltitude / 60 * ESTIMATED_KTS;
      if (!this.wasMovedByPpos && this.extraLength > 0) {
        distanceToTermination += this.extraLength;
      }
      this.estimatedTermination = Avionics.Utils.bearingDistanceToCoordinates(
        this.course,
        distanceToTermination,
        this.start.lat,
        this.start.long
      );
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.estimatedTermination);
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return courseToFixGuidance(ppos, trueTrack, this.course, this.estimatedTermination);
    }
    getNominalRollAngle(_gs) {
      return void 0;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      return distanceTo(startPoint, this.estimatedTermination);
    }
    isAbeam(_ppos) {
      return false;
    }
    get repr() {
      return `CA(${this.course.toFixed(1)}T) TO ${Math.round(this.altitude)} FT`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/CR.ts
  var CRLeg = class extends Leg {
    constructor(course, origin, radial, metadata, segment) {
      super();
      this.course = course;
      this.origin = origin;
      this.radial = radial;
      this.metadata = metadata;
      __publicField(this, "computedPath", []);
      __publicField(this, "intercept");
      this.segment = segment;
    }
    get terminationWaypoint() {
      return this.intercept;
    }
    get ident() {
      return this.origin.ident.substring(0, 3) + this.origin.theta.toFixed(0);
    }
    getPathStartPoint() {
      if (this.inboundGuidable && this.inboundGuidable.isComputed) {
        return this.inboundGuidable.getPathEndPoint();
      }
      throw new Error("[CRLeg] No computed inbound guidable.");
    }
    getPathEndPoint() {
      return this.intercept;
    }
    get predictedPath() {
      return this.computedPath;
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.intercept = Geo.doublePlaceBearingIntercept(
        this.getPathStartPoint(),
        this.origin.coordinates,
        this.course,
        this.radial
      );
      const overshot = distanceTo(this.getPathStartPoint(), this.intercept) >= 5e3;
      if (this.intercept && !overshot) {
        this.computedPath = [{
          type: 0 /* Line */,
          startPoint: this.getPathStartPoint(),
          endPoint: this.intercept
        }];
        this.isNull = false;
        this.isComputed = true;
        if (LnavConfig.DEBUG_PREDICTED_PATH) {
          this.computedPath.push(
            {
              type: 2 /* DebugPoint */,
              startPoint: this.getPathStartPoint(),
              annotation: "CR START"
            },
            {
              type: 2 /* DebugPoint */,
              startPoint: this.getPathEndPoint(),
              annotation: "CR END"
            }
          );
        }
      } else {
        this.predictedPath.length = 0;
        this.isNull = true;
        this.isComputed = true;
      }
    }
    get overshot() {
      const side = sideOfPointOnCourseToFix(this.intercept, this.outboundCourse, this.getPathStartPoint());
      return side === 1 /* After */;
    }
    get inboundCourse() {
      return this.course;
    }
    get outboundCourse() {
      return this.course;
    }
    get distanceToTermination() {
      const startPoint = this.getPathStartPoint();
      return distanceTo(startPoint, this.intercept);
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return courseToFixGuidance(ppos, trueTrack, this.course, this.getPathEndPoint());
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getPseudoWaypointLocation(_distanceBeforeTerminator) {
      return void 0;
    }
    isAbeam(ppos) {
      const dtg = courseToFixDistanceToGo(ppos, this.course, this.getPathEndPoint());
      return dtg >= 0 && dtg <= this.distance;
    }
    get repr() {
      return `CR ${this.course}T to ${this.origin.ident}${this.origin.theta}`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/VM.ts
  var VM_LEG_SIZE = 321;
  var VMLeg = class extends Leg {
    constructor(heading, metadata, segment) {
      super();
      this.heading = heading;
      this.metadata = metadata;
      __publicField(this, "predictedPath", []);
      __publicField(this, "displayedOnMap", false);
      this.segment = segment;
    }
    get terminationWaypoint() {
      return void 0;
    }
    get ident() {
      return "MANUAL";
    }
    getPathStartPoint() {
      var _a;
      return (_a = this.inboundGuidable) == null ? void 0 : _a.getPathEndPoint();
    }
    getPathEndPoint() {
      return Avionics.Utils.bearingDistanceToCoordinates(
        this.heading,
        VM_LEG_SIZE,
        this.getPathStartPoint().lat,
        this.getPathStartPoint().long
      );
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      this.predictedPath.length = 0;
      this.predictedPath.push(
        {
          type: 0 /* Line */,
          startPoint: this.getPathStartPoint(),
          endPoint: this.getPathEndPoint()
        }
      );
      this.isComputed = true;
    }
    get inboundCourse() {
      return this.heading;
    }
    get outboundCourse() {
      return this.heading;
    }
    get distance() {
      return 0;
    }
    get distanceToTermination() {
      return 1;
    }
    getPseudoWaypointLocation(_distanceBeforeTerminator) {
      return void 0;
    }
    getGuidanceParameters(_ppos, _trueTrack) {
      return {
        law: 1 /* HEADING */,
        heading: this.heading
      };
    }
    getNominalRollAngle(_gs) {
      return 0;
    }
    getDistanceToGo(_ppos) {
      return void 0;
    }
    isAbeam(_ppos) {
      return true;
    }
    get disableAutomaticSequencing() {
      return true;
    }
    get repr() {
      return `VM(${this.heading.toFixed(1)}T)`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/DF.ts
  var DFLeg = class extends XFLeg {
    constructor(fix, metadata, segment) {
      super(fix);
      this.metadata = metadata;
      __publicField(this, "computedPath", []);
      __publicField(this, "start");
      this.segment = segment;
    }
    getPathStartPoint() {
      var _a, _b;
      return (_b = (_a = this.inboundGuidable) == null ? void 0 : _a.getPathEndPoint()) != null ? _b : this.estimateStartPoint();
    }
    get predictedPath() {
      return this.computedPath;
    }
    estimateStartPoint() {
      let bearing = 0;
      if (this.outboundGuidable instanceof Transition) {
        bearing = this.outboundGuidable.nextLeg.inboundCourse + 180;
      } else if (this.outboundGuidable instanceof Leg) {
        bearing = this.outboundGuidable.inboundCourse + 180;
      }
      bearing = Avionics.Utils.clampAngle(bearing);
      return Avionics.Utils.bearingDistanceToCoordinates(
        bearing,
        2,
        this.fix.infos.coordinates.long,
        this.fix.infos.coordinates.long
      );
    }
    recomputeWithParameters(_isActive, _tas, _gs, _ppos, _trueTrack) {
      var _a, _b;
      const newStart = (_b = (_a = this.inboundGuidable) == null ? void 0 : _a.getPathEndPoint()) != null ? _b : this.estimateStartPoint();
      if (newStart) {
        this.start = newStart;
      }
      this.computedPath = [{
        type: 0 /* Line */,
        startPoint: this.start,
        endPoint: this.getPathEndPoint()
      }];
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.computedPath.push(
          {
            type: 2 /* DebugPoint */,
            startPoint: this.start,
            annotation: "DF START"
          },
          {
            type: 2 /* DebugPoint */,
            startPoint: this.getPathEndPoint(),
            annotation: "DF END"
          }
        );
      }
      this.isComputed = true;
    }
    get inboundCourse() {
      return bearingTo(this.start, this.fix.infos.coordinates);
    }
    get outboundCourse() {
      return bearingTo(this.start, this.fix.infos.coordinates);
    }
    getDistanceToGo(ppos) {
      return courseToFixDistanceToGo(ppos, this.outboundCourse, this.getPathEndPoint());
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return fixToFixGuidance(ppos, trueTrack, this.start, this.fix.infos.coordinates);
    }
    getNominalRollAngle(_gs) {
      return void 0;
    }
    isAbeam(_ppos) {
      return false;
    }
    get repr() {
      return `DF TO '${this.fix.ident}'`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/RF.ts
  var RFLeg = class extends XFLeg {
    constructor(from, to, center, metadata, segment) {
      super(to);
      this.metadata = metadata;
      __publicField(this, "from");
      __publicField(this, "to");
      __publicField(this, "center");
      __publicField(this, "radius");
      __publicField(this, "angle");
      __publicField(this, "clockwise");
      __publicField(this, "mDistance");
      __publicField(this, "computedPath", []);
      this.from = from;
      this.to = to;
      this.center = center;
      this.radius = Avionics.Utils.computeGreatCircleDistance(this.center, this.to.infos.coordinates);
      this.segment = segment;
      const bearingFrom = Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates);
      const bearingTo2 = Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates);
      switch (to.turnDirection) {
        case 1:
          this.clockwise = false;
          this.angle = Avionics.Utils.clampAngle(bearingFrom - bearingTo2);
          break;
        case 2:
          this.clockwise = true;
          this.angle = Avionics.Utils.clampAngle(bearingTo2 - bearingFrom);
          break;
        case 0:
        case 3:
        default:
          const angle = Avionics.Utils.diffAngle(bearingTo2, bearingFrom);
          this.clockwise = angle > 0;
          this.angle = Math.abs(angle);
          break;
      }
      this.mDistance = 2 * Math.PI * this.radius / 360 * this.angle;
      this.computedPath = [
        {
          type: 1 /* Arc */,
          startPoint: this.from.infos.coordinates,
          centrePoint: this.center,
          endPoint: this.to.infos.coordinates,
          sweepAngle: this.clockwise ? this.angle : -this.angle
        }
      ];
      this.isComputed = true;
    }
    getPathStartPoint() {
      return this.from.infos.coordinates;
    }
    getPathEndPoint() {
      return this.to.infos.coordinates;
    }
    get predictedPath() {
      return this.computedPath;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    get inboundCourse() {
      return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.from.infos.coordinates) + (this.clockwise ? 90 : -90));
    }
    get outboundCourse() {
      return Avionics.Utils.clampAngle(Avionics.Utils.computeGreatCircleHeading(this.center, this.to.infos.coordinates) + (this.clockwise ? 90 : -90));
    }
    get distance() {
      return this.mDistance;
    }
    get distanceToTermination() {
      return arcLength(this.radius, this.angle);
    }
    getGuidanceParameters(ppos, trueTrack, _tas) {
      return arcGuidance(ppos, trueTrack, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
    }
    getNominalRollAngle(gs) {
      const gsMs = gs * (463 / 900);
      return (this.clockwise ? 1 : -1) * Math.atan(gsMs ** 2 / (this.radius * 1852 * 9.81)) * (180 / Math.PI);
    }
    getDistanceToGo(ppos) {
      return arcDistanceToGo(ppos, this.from.infos.coordinates, this.center, this.clockwise ? this.angle : -this.angle);
    }
    isAbeam(ppos) {
      const bearingPpos = Avionics.Utils.computeGreatCircleHeading(
        this.center,
        ppos
      );
      const bearingFrom = Avionics.Utils.computeGreatCircleHeading(
        this.center,
        this.from.infos.coordinates
      );
      const trackAngleError = this.clockwise ? Avionics.Utils.diffAngle(bearingFrom, bearingPpos) : Avionics.Utils.diffAngle(bearingPpos, bearingFrom);
      return trackAngleError >= 0;
    }
    toString() {
      return `<RFLeg radius=${this.radius} to=${this.to}>`;
    }
    get repr() {
      return `RF(${this.radius.toFixed(1)}NM. ${this.angle.toFixed(1)}\xB0) TO ${this.to.ident}`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/transitions/HoldEntryTransition.ts
  var HoldEntryTransition = class extends Transition {
    constructor(previousLeg, nextLeg, _predictWithCurrentSpeed = true) {
      super(previousLeg, nextLeg);
      this.previousLeg = previousLeg;
      this.nextLeg = nextLeg;
      __publicField(this, "entry", 0 /* Null */);
      __publicField(this, "computedPath", []);
      __publicField(this, "turn1", {});
      __publicField(this, "turn2", {});
      __publicField(this, "turn3", {});
      __publicField(this, "straightCourse");
      __publicField(this, "state", 0 /* Turn1 */);
      __publicField(this, "wasAbeam", false);
      __publicField(this, "guidanceActive", false);
      __publicField(this, "frozen", false);
    }
    get distance() {
      return 0;
    }
    getDistanceToGo(_ppos) {
      if (this.entry === 0 /* Null */ || this.state === 4 /* Done */) {
        return 0;
      }
      return 1;
    }
    setHxEntry() {
      switch (this.entry) {
        case 4 /* DirectTurn */:
        case 2 /* Parallel */:
        case 1 /* Teardrop */:
        case 0 /* Null */:
          this.nextLeg.setInitialState(1 /* Arc1 */);
          break;
        case 3 /* DirectOutbound */:
          this.nextLeg.setInitialState(2 /* Outbound */);
          break;
        default:
      }
    }
    getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs) {
      let dtg;
      switch (this.state) {
        case 0 /* Turn1 */:
          dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          if (dtg <= 0) {
            this.state = 1 /* Straight1 */;
          }
          break;
        case 1 /* Straight1 */:
          dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);
          if (dtg <= 0) {
            this.state = 2 /* Turn2 */;
          }
          break;
        case 2 /* Turn2 */:
          dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          const refFrameOffset = Avionics.Utils.diffAngle(0, this.outboundCourse);
          const trackAngleError = this.turn2.sweepAngle < 0 ? Avionics.Utils.clampAngle(refFrameOffset - trueTrack) : Avionics.Utils.clampAngle(trueTrack - refFrameOffset);
          if (trackAngleError < 130) {
            this.state = 3 /* Capture */;
          }
          break;
        case 3 /* Capture */:
          dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          if (dtg < 0.1) {
            this.nextLeg.updatePrediction();
            this.state = 4 /* Done */;
          }
          break;
        default:
      }
      let bankNext = 0;
      let params;
      switch (this.state) {
        case 0 /* Turn1 */:
          params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          break;
        case 1 /* Straight1 */:
          params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
          bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          break;
        case 2 /* Turn2 */:
          const phiCommand = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          bankNext = phiCommand;
          params = {
            law: 3 /* LATERAL_PATH */,
            trackAngleError: 0,
            phiCommand,
            crossTrackError: 0
          };
          break;
        case 3 /* Capture */:
          params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          const { sweepAngle } = this.nextLeg.geometry;
          bankNext = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          break;
        case 4 /* Done */:
          params = this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
          bankNext = params.phiCommand;
          break;
        default:
      }
      const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);
      if (rad > 0 && dtg <= rad) {
        params.phiCommand = bankNext;
      }
      return params;
    }
    getDirectTurnGuidanceParameters(ppos, trueTrack, tas, _gs) {
      let dtg;
      switch (this.state) {
        case 0 /* Turn1 */:
          dtg = arcDistanceToGo(ppos, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          if (dtg <= 0) {
            this.state = 1 /* Straight1 */;
          }
          break;
        case 1 /* Straight1 */:
          dtg = courseToFixDistanceToGo(ppos, this.straightCourse, this.turn2.itp);
          if (dtg <= 0) {
            this.state = 2 /* Turn2 */;
          }
          break;
        case 2 /* Turn2 */:
          dtg = arcDistanceToGo(ppos, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          if (dtg <= 0) {
            this.state = 3 /* Capture */;
          }
          break;
        case 3 /* Capture */:
          dtg = courseToFixDistanceToGo(ppos, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          if (dtg < 0.1) {
            this.state = 4 /* Done */;
          }
          break;
        default:
      }
      let params;
      let bankNext;
      switch (this.state) {
        case 0 /* Turn1 */:
          params = arcGuidance(ppos, trueTrack, this.turn1.itp, this.turn1.arcCentre, this.turn1.sweepAngle);
          bankNext = 0;
          break;
        case 1 /* Straight1 */:
          params = courseToFixGuidance(ppos, trueTrack, this.straightCourse, this.turn2.itp);
          bankNext = this.turn2.sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          break;
        case 2 /* Turn2 */:
          params = arcGuidance(ppos, trueTrack, this.turn2.itp, this.turn2.arcCentre, this.turn2.sweepAngle);
          bankNext = 0;
          break;
        case 3 /* Capture */:
          params = courseToFixGuidance(ppos, trueTrack, this.outboundCourse, this.nextLeg.fix.infos.coordinates);
          bankNext = 0;
          break;
        default:
      }
      const rad = Geometry.getRollAnticipationDistance(tas, params.phiCommand, bankNext);
      if (rad > 0 && dtg <= rad) {
        params.phiCommand = bankNext;
      }
      return params;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (!this.guidanceActive) {
        this.nextLeg.updatePrediction();
        this.guidanceActive = true;
      }
      switch (this.entry) {
        case 2 /* Parallel */:
        case 1 /* Teardrop */:
          return this.getParallelTeardropGuidanceParameters(ppos, trueTrack, tas, gs);
        case 3 /* DirectOutbound */:
          return this.nextLeg.getGuidanceParameters(ppos, trueTrack, tas, gs);
        case 4 /* DirectTurn */:
          return this.getDirectTurnGuidanceParameters(ppos, trueTrack, tas, gs);
        default:
      }
      return void 0;
    }
    getNominalRollAngle(gs) {
      if (this.entry === 0 /* Null */) {
        return this.nextLeg.getNominalRollAngle(gs);
      }
      if (Math.abs(this.turn1.sweepAngle) <= 3) {
        return 0;
      }
      return this.turn1.sweepAngle > 0 ? maxBank(gs, true) : -maxBank(gs, true);
    }
    getTurningPoints() {
      switch (this.entry) {
        case 2 /* Parallel */:
        case 1 /* Teardrop */:
          return [this.nextLeg.fix.infos.coordinates, this.turn3.ftp];
        case 4 /* DirectTurn */:
        case 3 /* DirectOutbound */:
          return [this.nextLeg.fix.infos.coordinates, this.turn1.ftp];
        case 0 /* Null */:
        default:
          return [this.nextLeg.fix.infos.coordinates, this.nextLeg.fix.infos.coordinates];
      }
    }
    isAbeam(ppos) {
      if (!this.wasAbeam && this.previousLeg.getDistanceToGo(ppos) <= 0) {
        this.wasAbeam = true;
        return true;
      }
      return this.wasAbeam && this.state !== 4 /* Done */;
    }
    get startsInCircularArc() {
      return true;
    }
    get endsInCircularArc() {
      return true;
    }
    get inboundCourse() {
      return this.previousLeg.outboundCourse;
    }
    get outboundCourse() {
      return this.nextLeg.inboundCourse;
    }
    get predictedPath() {
      if (this.entry === 0 /* Null */) {
        return [];
      }
      if (this.entry === 3 /* DirectOutbound */) {
        if (this.nextLeg instanceof HFLeg) {
          return this.nextLeg.getHippodromePath();
        }
        return [];
      }
      return this.computedPath;
    }
    getPathDebugPoints() {
      if (this.entry === 0 /* Null */) {
        return [];
      }
      const debugPoints = [
        {
          type: 2 /* DebugPoint */,
          startPoint: this.turn1.arcCentre,
          annotation: "AC1"
        },
        {
          type: 2 /* DebugPoint */,
          startPoint: this.turn1.ftp,
          annotation: "FTP1"
        }
      ];
      if (this.entry === 2 /* Parallel */ || this.entry === 1 /* Teardrop */) {
        debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn2.itp,
          annotation: "ITP2",
          colour: 4 /* Magenta */
        });
        debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn2.arcCentre,
          annotation: "AC2",
          colour: 4 /* Magenta */
        });
        debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn2.ftp,
          annotation: "FTP2",
          colour: 4 /* Magenta */
        });
        debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn3.itp,
          annotation: "ITP3",
          colour: 2 /* Yellow */
        });
        debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn3.arcCentre,
          annotation: "AC3",
          colour: 2 /* Yellow */
        });
        debugPoints.push({
          type: 2 /* DebugPoint */,
          startPoint: this.turn3.ftp,
          annotation: "FTP3",
          colour: 2 /* Yellow */
        });
      }
      return debugPoints;
    }
    computeNullEntry() {
      this.entry = 0 /* Null */;
      this.computedPath.length = 0;
    }
    computeDirectOutboundEntry() {
      this.entry = 3 /* DirectOutbound */;
      const { radius: maxRadius } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === 2 /* Right */ ? 1 : -1;
      const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
      const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundCourse + turnSign * 90,
        radius,
        this.turn1.itp.lat,
        this.turn1.itp.long
      );
      this.turn1.sweepAngle = turnSign * 180 + trackChange;
      const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
    }
    computeDirectTurnEntry() {
      this.entry = 4 /* DirectTurn */;
      const { fixB, fixC, arcCentreFix2, sweepAngle, radius: maxRadius } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === 2 /* Right */ ? 1 : -1;
      const trackChange = Avionics.Utils.diffAngle(this.inboundCourse, this.nextLeg.inboundCourse);
      const radius = 2 * maxRadius / (1 + Math.cos(trackChange * Math.PI / 180));
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundCourse + turnSign * 90,
        radius,
        this.turn1.itp.lat,
        this.turn1.itp.long
      );
      this.turn1.sweepAngle = turnSign * 180 + trackChange;
      const bearing1 = Avionics.Utils.clampAngle(this.nextLeg.inboundCourse + turnSign * 90);
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
      this.straightCourse = (this.outboundCourse + 180) % 360;
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: this.turn1.ftp,
        endPoint: fixB
      });
      this.turn2.itp = fixB;
      this.turn2.ftp = fixC;
      this.turn2.sweepAngle = sweepAngle;
      this.turn2.arcCentre = arcCentreFix2;
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: fixB,
        centrePoint: arcCentreFix2,
        endPoint: fixC,
        sweepAngle
      });
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: fixC,
        endPoint: this.nextLeg.fix.infos.coordinates
      });
    }
    computeTeardropEntry() {
      this.entry = 1 /* Teardrop */;
      const { radius, legLength } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === 2 /* Right */ ? 1 : -1;
      this.straightCourse = Avionics.Utils.clampAngle(this.outboundCourse + 150 * turnSign);
      this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.straightCourse);
      const turn1Clockwise = this.turn1.sweepAngle >= 0;
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundCourse + (turn1Clockwise ? 90 : -90),
        radius,
        this.turn1.itp.lat,
        this.turn1.itp.long
      );
      const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (turn1Clockwise ? -90 : 90));
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
      const kekRads = Math.abs(Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180)) * Math.PI / 180;
      let minStraightDistance = radius * 2 / Math.sqrt(3) * (0.1 + Math.SQRT2 - 1 / 2 - Math.abs(Math.sin(kekRads) - 1 / 2));
      const nominalStraightDistance = 1.15 * legLength;
      let straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
      let radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
      if (Math.SQRT2 - radii2Inbound > 0) {
        const extraCapComponent = Math.SQRT2 - radii2Inbound;
        minStraightDistance += radius * 2 / Math.sqrt(3) * extraCapComponent;
        straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
        radii2Inbound = Math.abs(Math.cos(kekRads) - Math.sqrt(3) / 2) + straightDistance / radius / 2 + (1 - Math.sqrt(3) / 2);
      }
      this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(
        this.straightCourse,
        straightDistance,
        this.turn1.ftp.lat,
        this.turn1.ftp.long
      );
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: this.turn1.ftp,
        endPoint: this.turn2.itp
      });
      this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse - turnSign * 120,
        radius,
        this.turn2.itp.lat,
        this.turn2.itp.long
      );
      if (radii2Inbound >= 2) {
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(
          this.straightCourse + turnSign * 75,
          radius,
          this.turn2.arcCentre.lat,
          this.turn2.arcCentre.long
        );
        this.turn2.sweepAngle = turnSign * 165;
        const straightDist = (radii2Inbound - 2) * Math.SQRT2 * radius;
        this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(
          this.straightCourse + turnSign * 165,
          straightDist,
          this.turn2.ftp.lat,
          this.turn2.ftp.long
        );
        this.turn3.sweepAngle = turnSign * 45;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
          this.straightCourse - turnSign * 105,
          radius,
          this.turn3.itp.lat,
          this.turn3.itp.long
        );
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(
          this.outboundCourse - turnSign * 90,
          radius,
          this.turn3.arcCentre.lat,
          this.turn3.arcCentre.long
        );
        this.computedPath.push({
          type: 0 /* Line */,
          startPoint: this.turn2.ftp,
          endPoint: this.turn3.itp
        });
      } else if (Math.SQRT2 - radii2Inbound < 0) {
        const interceptAngle = Math.acos(radii2Inbound / 2) * 180 / Math.PI;
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(
          this.straightCourse + turnSign * (120 + interceptAngle),
          radius,
          this.turn2.arcCentre.lat,
          this.turn2.arcCentre.long
        );
        this.turn2.sweepAngle = turnSign * (210 + interceptAngle);
        this.turn3.itp = this.turn2.ftp;
        this.turn3.sweepAngle = -turnSign * interceptAngle;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
          this.straightCourse + turnSign * (120 + interceptAngle),
          radius,
          this.turn3.itp.lat,
          this.turn3.itp.long
        );
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(
          this.outboundCourse + turnSign * 90,
          radius,
          this.turn3.arcCentre.lat,
          this.turn3.arcCentre.long
        );
      } else {
        this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(
          this.outboundCourse - turnSign * 45,
          radius,
          this.turn2.arcCentre.lat,
          this.turn2.arcCentre.long
        );
        this.turn2.sweepAngle = turnSign * 255;
        const straightDist = Math.sqrt(2 * (Math.SQRT2 - radii2Inbound) ** 2) * radius;
        this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(
          this.straightCourse + turnSign * 255,
          straightDist,
          this.turn2.ftp.lat,
          this.turn2.ftp.long
        );
        this.turn3.sweepAngle = -turnSign * 45;
        this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
          this.outboundCourse - turnSign * 45,
          radius,
          this.turn3.itp.lat,
          this.turn3.itp.long
        );
        this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(
          this.outboundCourse + turnSign * 90,
          radius,
          this.turn3.arcCentre.lat,
          this.turn3.arcCentre.long
        );
        this.computedPath.push({
          type: 0 /* Line */,
          startPoint: this.turn2.ftp,
          endPoint: this.turn3.itp
        });
      }
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn2.itp,
        endPoint: this.turn2.ftp,
        centrePoint: this.turn2.arcCentre,
        sweepAngle: this.turn2.sweepAngle
      });
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn3.itp,
        endPoint: this.turn3.ftp,
        centrePoint: this.turn3.arcCentre,
        sweepAngle: this.turn3.sweepAngle
      });
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: this.turn3.ftp,
        endPoint: this.nextLeg.fix.infos.coordinates
      });
    }
    computeParallelEntry() {
      this.entry = 2 /* Parallel */;
      const { radius, legLength } = this.nextLeg.geometry;
      const turnSign = this.nextLeg.turnDirection === 2 /* Right */ ? 1 : -1;
      this.turn1.itp = this.nextLeg.fix.infos.coordinates;
      this.turn1.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundCourse + (this.nextLeg.turnDirection === 2 /* Right */ ? -90 : 90),
        radius,
        this.turn1.itp.lat,
        this.turn1.itp.long
      );
      this.turn1.sweepAngle = Avionics.Utils.diffAngle(this.inboundCourse, this.outboundCourse + 180);
      const bearing1 = Avionics.Utils.clampAngle(this.inboundCourse + this.turn1.sweepAngle + (this.nextLeg.turnDirection === 2 /* Right */ ? 90 : -90));
      this.turn1.ftp = Avionics.Utils.bearingDistanceToCoordinates(bearing1, radius, this.turn1.arcCentre.lat, this.turn1.arcCentre.long);
      this.computedPath.length = 0;
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn1.itp,
        endPoint: this.turn1.ftp,
        centrePoint: this.turn1.arcCentre,
        sweepAngle: this.turn1.sweepAngle
      });
      const turn1Rads = Math.abs(this.turn1.sweepAngle) * Math.PI / 180;
      const minStraightDistance = 0.1 + 2 * Math.cos(1 - Math.SQRT2 / 2 - Math.sin(turn1Rads)) * radius;
      const nominalStraightDistance = 1.15 * legLength - radius * Math.sin(turn1Rads);
      const straightDistance = Math.max(minStraightDistance, nominalStraightDistance);
      this.turn2.itp = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse + 180,
        straightDistance,
        this.turn1.ftp.lat,
        this.turn1.ftp.long
      );
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: this.turn1.ftp,
        endPoint: this.turn2.itp
      });
      this.straightCourse = Avionics.Utils.computeGreatCircleHeading(this.turn1.ftp, this.turn2.itp);
      this.turn2.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse + turnSign * 90,
        radius,
        this.turn2.itp.lat,
        this.turn2.itp.long
      );
      this.turn2.ftp = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse + turnSign * 45,
        radius,
        this.turn2.arcCentre.lat,
        this.turn2.arcCentre.long
      );
      this.turn2.sweepAngle = turnSign * -225;
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn2.itp,
        endPoint: this.turn2.ftp,
        centrePoint: this.turn2.arcCentre,
        sweepAngle: this.turn2.sweepAngle
      });
      const ftp2ToInboundAbeamRadii = Math.cos(turn1Rads) + Math.SQRT2 / 2;
      const straightDist = Math.sqrt(2 * (ftp2ToInboundAbeamRadii - (1 - Math.SQRT2 / 2)) ** 2) * radius;
      this.turn3.itp = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse - turnSign * 45,
        straightDist,
        this.turn2.ftp.lat,
        this.turn2.ftp.long
      );
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: this.turn2.ftp,
        endPoint: this.turn3.itp
      });
      this.turn3.sweepAngle = turnSign * 45;
      this.turn3.arcCentre = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse + turnSign * 45,
        radius,
        this.turn3.itp.lat,
        this.turn3.itp.long
      );
      this.turn3.ftp = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundCourse - turnSign * 90,
        radius,
        this.turn3.arcCentre.lat,
        this.turn3.arcCentre.long
      );
      this.computedPath.push({
        type: 1 /* Arc */,
        startPoint: this.turn3.itp,
        endPoint: this.turn3.ftp,
        centrePoint: this.turn3.arcCentre,
        sweepAngle: this.turn3.sweepAngle
      });
      this.computedPath.push({
        type: 0 /* Line */,
        startPoint: this.turn3.ftp,
        endPoint: this.nextLeg.fix.infos.coordinates
      });
    }
    recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack) {
      const hxInbound = this.outboundCourse;
      const entryAngle = Avionics.Utils.diffAngle(this.inboundCourse, hxInbound);
      if (this.frozen) {
        if (this.state === 4 /* Done */) {
          this.computedPath.length = 0;
        }
        return;
      }
      if (isActive && !this.frozen) {
        this.frozen = true;
      }
      if (!this.previousLeg || entryAngle >= -3 && entryAngle <= 3) {
        this.computeNullEntry();
        this.setHxEntry();
        this.isNull = true;
        return;
      }
      this.isNull = false;
      if (this.nextLeg.turnDirection === 1 /* Left */) {
        if (entryAngle > 110 && entryAngle < 177) {
          this.computeTeardropEntry();
        } else if (entryAngle >= 177 && entryAngle <= 180 || entryAngle > -180 && entryAngle < -70) {
          this.computeParallelEntry();
        } else if (entryAngle >= -70 && entryAngle < -3) {
          this.computeDirectTurnEntry();
        } else {
          this.computeDirectOutboundEntry();
        }
      } else if (this.nextLeg.turnDirection === 2 /* Right */) {
        if (entryAngle > -177 && entryAngle < -110) {
          this.computeTeardropEntry();
        } else if (entryAngle > 70 && entryAngle <= 180 || entryAngle > -180 && entryAngle <= -177) {
          this.computeParallelEntry();
        } else if (entryAngle > 3 && entryAngle <= 70) {
          this.computeDirectTurnEntry();
        } else {
          this.computeDirectOutboundEntry();
        }
      }
      if (LnavConfig.DEBUG_PREDICTED_PATH) {
        this.computedPath.push(...this.getPathDebugPoints());
      }
      this.setHxEntry();
    }
    getPathStartPoint() {
      return this.getTurningPoints()[0];
    }
    getPathEndPoint() {
      return this.getTurningPoints()[1];
    }
    get repr() {
      return `HOLD ENTRY(${this.nextLeg.repr})`;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/TransitionPicker.ts
  var TransitionPicker = class {
    static forLegs(from, to) {
      if (from instanceof AFLeg) {
        return TransitionPicker.fromAF(from, to);
      }
      if (from instanceof CALeg) {
        return TransitionPicker.fromCA(from, to);
      }
      if (from instanceof CFLeg) {
        return TransitionPicker.fromCF(from, to);
      }
      if (from instanceof DFLeg) {
        return TransitionPicker.fromDF(from, to);
      }
      if (from instanceof HALeg || from instanceof HFLeg || from instanceof HMLeg) {
        return TransitionPicker.fromHX(from, to);
      }
      if (from instanceof PILeg) {
        return TransitionPicker.fromPI(from, to);
      }
      if (from instanceof RFLeg) {
        return TransitionPicker.fromRF(from, to);
      }
      if (from instanceof TFLeg) {
        return TransitionPicker.fromTF(from, to);
      }
      if (from instanceof CILeg) {
        return TransitionPicker.fromCI(from, to);
      }
      if (from instanceof CRLeg) {
        return TransitionPicker.fromCR(from, to);
      }
      if (from instanceof VMLeg) {
        return TransitionPicker.fromVM(from, to);
      }
      if (DEBUG) {
        console.error(`[FMS/Geometry] Could not pick transition between '${from.repr}' and '${to.repr}'.`);
      }
      return null;
    }
    static fromCA(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG) {
        console.error(`Illegal sequence CALeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromAF(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG) {
        console.error(`Illegal sequence AFLEg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromCF(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof PILeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG) {
        console.error(`Illegal sequence CFLeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromCI(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (DEBUG) {
        console.error(`Illegal sequence CILeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromDF(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof PILeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG && !(to instanceof RFLeg)) {
        console.error(`Illegal sequence DFLeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromHX(from, to) {
      if (to instanceof AFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG && !(to instanceof RFLeg)) {
        console.error(`Illegal sequence DFLeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromPI(from, to) {
      if (!(to instanceof CFLeg)) {
        console.error("PI -> !CF", from, to);
      }
      return null;
    }
    static fromRF(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (DEBUG && !(to instanceof RFLeg) && !(to instanceof TFLeg)) {
        console.error(`Illegal sequence RFLeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromTF(from, to) {
      if (to instanceof AFLeg) {
        return new DmeArcTransition(from, to);
      }
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof HALeg || to instanceof HFLeg || to instanceof HMLeg) {
        return new HoldEntryTransition(from, to);
      }
      if (to instanceof PILeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof TFLeg) {
        return new FixedRadiusTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG && !(to instanceof RFLeg)) {
        console.error(`Illegal sequence TFLeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromCR(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CFLeg) {
        return new PathCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof VMLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG) {
        console.error(`Illegal sequence CRLeg -> ${to.constructor.name}`);
      }
      return null;
    }
    static fromVM(from, to) {
      if (to instanceof CALeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof DFLeg) {
        return new DirectToFixTransition(from, to);
      }
      if (to instanceof CILeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (to instanceof CRLeg) {
        return new CourseCaptureTransition(from, to);
      }
      if (DEBUG) {
        console.error(`Illegal sequence VMLeg -> ${to.constructor.name}`);
      }
      return null;
    }
  };

  // src/systems/fmgc/src/guidance/Geometry.ts
  function isGuidableCapturingPath(guidable) {
    return !(guidable instanceof CALeg || guidable instanceof CILeg || guidable instanceof CRLeg || guidable instanceof VMLeg || guidable instanceof CourseCaptureTransition);
  }
  var Geometry = class {
    constructor(transitions, legs, temp) {
      this.temp = temp;
      __publicField(this, "transitions");
      __publicField(this, "legs");
      __publicField(this, "version", 0);
      __publicField(this, "listener", RegisterViewListener("JS_LISTENER_SIMVARS", null, true));
      __publicField(this, "isComputed", false);
      __publicField(this, "cachedVectors", []);
      __publicField(this, "cachedVectorsVersion", 0);
      this.transitions = transitions;
      this.legs = legs;
    }
    getAllPathVectors(activeLegIndex) {
      if (this.version === this.cachedVectorsVersion) {
        return this.cachedVectors;
      }
      const transmitHoldEntry = !this.temp;
      const ret = [];
      for (const [index, leg] of this.legs.entries()) {
        if (leg.isNull) {
          continue;
        }
        const transmitCourseReversal = LnavConfig.DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS || index === activeLegIndex || index === activeLegIndex + 1;
        if (activeLegIndex !== void 0) {
          if (isCourseReversalLeg(leg) && !transmitCourseReversal) {
            continue;
          }
          if (index < activeLegIndex) {
            continue;
          }
        }
        const legInboundTransition = leg.inboundGuidable instanceof Transition ? leg.inboundGuidable : null;
        if (legInboundTransition && !legInboundTransition.isNull && (!isHold(leg) || transmitHoldEntry)) {
          ret.push(...legInboundTransition.predictedPath);
        }
        if (leg) {
          ret.push(...leg.predictedPath);
        }
      }
      this.cachedVectors = ret;
      this.cachedVectorsVersion = this.version;
      return ret;
    }
    recomputeWithParameters(tas, gs, ppos, trueTrack, activeLegIdx, _activeTransIdx) {
      this.version++;
      if (LnavConfig.DEBUG_GEOMETRY) {
        console.log(`[FMS/Geometry] Recomputing geometry with current_tas: ${tas}kts`);
        console.time("geometry_recompute");
      }
      for (let i = activeLegIdx != null ? activeLegIdx : 0; this.legs.get(i) || this.legs.get(i + 1); i++) {
        if (!this.legs.has(i)) {
          continue;
        }
        const leg = this.legs.get(i);
        const wasNull = leg.isNull;
        this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);
        if (!wasNull && leg.isNull || wasNull && !leg.isNull) {
          this.computeLeg(i, activeLegIdx, ppos, trueTrack, tas, gs);
        }
      }
      if (LnavConfig.DEBUG_GEOMETRY) {
        console.timeEnd("geometry_recompute");
      }
    }
    static getLegPredictedTas(leg, currentTas) {
      var _a;
      return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_a = leg.predictedTas) != null ? _a : currentTas);
    }
    static getLegPredictedGs(leg, currentGs) {
      var _a;
      return Math.max(LnavConfig.DEFAULT_MIN_PREDICTED_TAS, (_a = leg.predictedGs) != null ? _a : currentGs);
    }
    computeLeg(index, activeLegIdx, ppos, trueTrack, tas, gs) {
      const prevLeg = this.legs.get(index - 1);
      const leg = this.legs.get(index);
      const nextLeg = this.legs.get(index + 1);
      const nextNextLeg = this.legs.get(index + 2);
      const inboundTransition = this.transitions.get(index - 1);
      const outboundTransition = this.transitions.get(index);
      const legPredictedTas = Geometry.getLegPredictedTas(leg, tas);
      const legPredictedGs = Geometry.getLegPredictedGs(leg, gs);
      if (leg == null ? void 0 : leg.isNull) {
        if (nextLeg) {
          let newInboundTransition;
          if (LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1 || index - activeLegIdx < LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE) {
            newInboundTransition = TransitionPicker.forLegs(prevLeg, nextLeg);
          }
          let newOutboundTransition;
          if (nextNextLeg && LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE === -1 || index + 1 - activeLegIdx < LnavConfig.NUM_COMPUTED_TRANSITIONS_AFTER_ACTIVE) {
            newOutboundTransition = TransitionPicker.forLegs(nextLeg, nextNextLeg);
          }
          if (newInboundTransition && prevLeg) {
            const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
            const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
            newInboundTransition.setNeighboringGuidables(prevLeg, nextLeg);
            newInboundTransition.recomputeWithParameters(
              activeLegIdx === index,
              prevLegPredictedLegTas,
              prevLegPredictedLegGs,
              ppos,
              trueTrack
            );
          }
          const nextLegPredictedLegTas = Geometry.getLegPredictedTas(nextLeg, tas);
          const nextLegPredictedLegGs = Geometry.getLegPredictedGs(nextLeg, gs);
          nextLeg.setNeighboringGuidables(newInboundTransition != null ? newInboundTransition : prevLeg, newOutboundTransition != null ? newOutboundTransition : nextNextLeg);
          nextLeg.recomputeWithParameters(
            activeLegIdx === index,
            nextLegPredictedLegTas,
            nextLegPredictedLegGs,
            ppos,
            trueTrack
          );
          if (newOutboundTransition) {
            newOutboundTransition.setNeighboringGuidables(nextLeg, nextNextLeg);
            newOutboundTransition.recomputeWithParameters(
              activeLegIdx === index + 1,
              nextLegPredictedLegTas,
              nextLegPredictedLegGs,
              ppos,
              trueTrack
            );
            nextLeg.recomputeWithParameters(
              activeLegIdx === index,
              nextLegPredictedLegTas,
              nextLegPredictedLegGs,
              ppos,
              trueTrack
            );
          }
        }
      }
      if (inboundTransition && prevLeg) {
        const prevLegPredictedLegTas = Geometry.getLegPredictedTas(prevLeg, tas);
        const prevLegPredictedLegGs = Geometry.getLegPredictedGs(prevLeg, gs);
        inboundTransition.setNeighboringGuidables(prevLeg, leg);
        inboundTransition.setNeighboringLegs(prevLeg, leg);
        inboundTransition.recomputeWithParameters(
          activeLegIdx === index,
          prevLegPredictedLegTas,
          prevLegPredictedLegGs,
          ppos,
          trueTrack
        );
      }
      if (!(prevLeg && prevLeg.isNull)) {
        leg.setNeighboringGuidables(inboundTransition != null ? inboundTransition : prevLeg, outboundTransition != null ? outboundTransition : nextLeg);
        leg.recomputeWithParameters(
          activeLegIdx === index,
          legPredictedTas,
          legPredictedGs,
          ppos,
          trueTrack
        );
        if (outboundTransition && nextLeg) {
          outboundTransition.setNeighboringGuidables(leg, nextLeg);
          outboundTransition.setNeighboringLegs(leg, nextLeg);
          outboundTransition.recomputeWithParameters(
            activeLegIdx === index + 1,
            legPredictedTas,
            legPredictedGs,
            ppos,
            trueTrack
          );
          leg.setNeighboringGuidables(inboundTransition != null ? inboundTransition : prevLeg, outboundTransition);
          leg.recomputeWithParameters(
            activeLegIdx === index,
            legPredictedTas,
            legPredictedGs,
            ppos,
            trueTrack
          );
        }
      }
    }
    getGuidanceParameters(activeLegIdx, ppos, trueTrack, gs, tas) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
      const activeLeg = this.legs.get(activeLegIdx);
      const nextLeg = this.legs.get(activeLegIdx + 1);
      const autoSequencing = !(activeLeg == null ? void 0 : activeLeg.disableAutomaticSequencing);
      let activeGuidable = null;
      let nextGuidable = null;
      const fromTransition = this.transitions.get(activeLegIdx - 1);
      const toTransition = this.transitions.get(activeLegIdx);
      if (fromTransition && !fromTransition.isNull && fromTransition.isAbeam(ppos)) {
        if (!fromTransition.isFrozen) {
          fromTransition.freeze();
        }
        if (fromTransition instanceof CourseCaptureTransition && activeLeg instanceof CALeg) {
          activeGuidable = activeLeg;
          nextGuidable = toTransition;
        } else {
          activeGuidable = fromTransition;
          nextGuidable = activeLeg;
        }
      } else if (toTransition && !toTransition.isNull && autoSequencing) {
        if (toTransition.isAbeam(ppos)) {
          if (toTransition instanceof FixedRadiusTransition && !toTransition.isFrozen) {
            toTransition.freeze();
          }
          activeGuidable = toTransition;
          nextGuidable = nextLeg;
        } else if (activeLeg) {
          activeGuidable = activeLeg;
          nextGuidable = toTransition;
        }
      } else if (activeLeg) {
        activeGuidable = activeLeg;
        if (nextLeg && autoSequencing) {
          nextGuidable = nextLeg;
        }
      }
      let guidanceParams;
      let rad;
      let dtg;
      if (activeGuidable) {
        const phiLimit = maxBank(tas, isGuidableCapturingPath(activeGuidable));
        guidanceParams = __spreadProps(__spreadValues({}, activeGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs)), {
          phiLimit
        });
        dtg = activeGuidable.getDistanceToGo(ppos);
        if (activeGuidable && nextGuidable) {
          rad = this.getGuidableRollAnticipationDistance(gs, activeGuidable, nextGuidable);
          if (rad > 0 && dtg <= rad) {
            const nextGuidanceParams = nextGuidable.getGuidanceParameters(ppos, trueTrack, tas, gs);
            if (nextGuidanceParams.law === 3 /* LATERAL_PATH */) {
              guidanceParams.phiCommand = (_a = nextGuidanceParams == null ? void 0 : nextGuidanceParams.phiCommand) != null ? _a : 0;
            }
          }
        }
      }
      if (LnavConfig.DEBUG_GUIDANCE) {
        this.listener.triggerToAllSubscribers(
          "A32NX_FM_DEBUG_LNAV_STATUS",
          `A32NX FMS LNAV STATUS
XTE ${(_c = (_b = guidanceParams.crossTrackError) == null ? void 0 : _b.toFixed(3)) != null ? _c : "(NO DATA)"}
TAE ${(_e = (_d = guidanceParams.trackAngleError) == null ? void 0 : _d.toFixed(3)) != null ? _e : "(NO DATA)"}
PHI ${(_g = (_f = guidanceParams.phiCommand) == null ? void 0 : _f.toFixed(5)) != null ? _g : "(NO DATA)"}
---
CURR GUIDABLE ${(_h = activeGuidable == null ? void 0 : activeGuidable.repr) != null ? _h : "---"}
CURR GUIDABLE DTG ${(_i = dtg == null ? void 0 : dtg.toFixed(3)) != null ? _i : "---"}
` + (activeGuidable instanceof DirectToFixTransition ? `DFX STATE ${DirectToFixTransitionGuidanceState[activeGuidable.state]}
` : "") + `---
RAD GUIDABLE ${(_j = nextGuidable == null ? void 0 : nextGuidable.repr) != null ? _j : "---"}
RAD DISTANCE ${(_k = rad == null ? void 0 : rad.toFixed(3)) != null ? _k : "---"}
---
L0 ${(_m = (_l = this.legs.get(activeLegIdx - 1)) == null ? void 0 : _l.repr) != null ? _m : "---"}
T0 ${(_o = (_n = this.transitions.get(activeLegIdx - 1)) == null ? void 0 : _n.repr) != null ? _o : "---"}
L1 ${(_q = (_p = this.legs.get(activeLegIdx)) == null ? void 0 : _p.repr) != null ? _q : "---"}
T1 ${(_s = (_r = this.transitions.get(activeLegIdx)) == null ? void 0 : _r.repr) != null ? _s : "---"}
L2 ${(_u = (_t = this.legs.get(activeLegIdx + 1)) == null ? void 0 : _t.repr) != null ? _u : "---"}
`
        );
      }
      return guidanceParams;
    }
    getGuidableRollAnticipationDistance(gs, from, to) {
      if (!from.endsInCircularArc && !to.startsInCircularArc) {
        return 0;
      }
      const phiNominalFrom = from.endsInCircularArc ? from.getNominalRollAngle(gs) : 0;
      const phiNominalTo = to.startsInCircularArc ? to.getNominalRollAngle(gs) : 0;
      return Geometry.getRollAnticipationDistance(gs, phiNominalFrom, phiNominalTo);
    }
    static getRollAnticipationDistance(gs, bankA, bankB) {
      const deltaPhi = Math.abs(bankA - bankB);
      const maxRollRate = 5;
      const k2 = 38e-4;
      const rad = gs / 3600 * (Math.sqrt(1 + 2 * k2 * 9.81 * deltaPhi / maxRollRate) - 1) / (k2 * 9.81);
      return rad;
    }
    getDistanceToGo(activeLegIdx, ppos) {
      const activeLeg = this.legs.get(activeLegIdx);
      if (activeLeg) {
        return activeLeg.getDistanceToGo(ppos);
      }
      return null;
    }
    shouldSequenceLeg(activeLegIdx, ppos) {
      const activeLeg = this.legs.get(activeLegIdx);
      const inboundTransition = this.transitions.get(activeLegIdx - 1);
      if (!(inboundTransition == null ? void 0 : inboundTransition.isNull) && (inboundTransition == null ? void 0 : inboundTransition.isAbeam(ppos)) && activeLeg.distance > 0.01) {
        return false;
      }
      const dtg = activeLeg.getDistanceToGo(ppos);
      if (dtg <= 0 || activeLeg.isNull) {
        return true;
      }
      if (activeLeg) {
        return activeLeg.getDistanceToGo(ppos) < 1e-3;
      }
      return false;
    }
    onLegSequenced(_sequencedLeg, nextLeg, followingLeg) {
      if (isCourseReversalLeg(nextLeg) || isCourseReversalLeg(followingLeg)) {
        this.version++;
      }
    }
    legsInSegment(segmentType) {
      const newMap = /* @__PURE__ */ new Map();
      for (const entry of this.legs.entries()) {
        if (entry[1].segment === segmentType) {
          newMap.set(...entry);
        }
      }
      return newMap;
    }
    static completeLegPathDistanceToGo(ppos, leg, inbound, outbound) {
      const [, legPartLength, outboundTransLength] = Geometry.completeLegPathLengths(
        leg,
        inbound,
        outbound
      );
      if (outbound && outbound.isAbeam(ppos)) {
        return outbound.getDistanceToGo(ppos) - outbound.distance / 2;
      }
      if (inbound && inbound.isAbeam(ppos)) {
        return inbound.getDistanceToGo(ppos) + legPartLength + outboundTransLength;
      }
      return leg.getDistanceToGo(ppos) - (outbound && outbound instanceof FixedRadiusTransition ? outbound.unflownDistance : 0) + outboundTransLength;
    }
    static completeLegPathLengths(leg, inbound, outbound) {
      let inboundLength = 0;
      let outboundLength = 0;
      let legDistance = leg.distance;
      if (outbound) {
        if (outbound instanceof FixedRadiusTransition && !outbound.isReverted) {
          outboundLength = outbound.distance / 2;
        }
      }
      if (inbound) {
        if (inbound instanceof FixedRadiusTransition && !inbound.isReverted) {
          inboundLength = inbound.distance / 2;
        } else {
          inboundLength = inbound.distance;
        }
        if (leg instanceof XFLeg && leg.overshot && leg.distance > 0) {
          legDistance = -leg.distance;
        }
      }
      return [inboundLength, legDistance, outboundLength];
    }
  };

  // src/systems/fmgc/src/guidance/lnav/legs/HX.ts
  var HxLegGuidanceState = /* @__PURE__ */ ((HxLegGuidanceState2) => {
    HxLegGuidanceState2[HxLegGuidanceState2["Inbound"] = 0] = "Inbound";
    HxLegGuidanceState2[HxLegGuidanceState2["Arc1"] = 1] = "Arc1";
    HxLegGuidanceState2[HxLegGuidanceState2["Outbound"] = 2] = "Outbound";
    HxLegGuidanceState2[HxLegGuidanceState2["Arc2"] = 3] = "Arc2";
    return HxLegGuidanceState2;
  })(HxLegGuidanceState || {});
  var HXLeg = class extends XFLeg {
    constructor(fix, metadata, segment) {
      super(fix);
      this.metadata = metadata;
      this.segment = segment;
      __publicField(this, "state", 0 /* Inbound */);
      __publicField(this, "initialState", 0 /* Inbound */);
      __publicField(this, "termConditionMet", false);
      __publicField(this, "nextPredictedTas", 180);
      __publicField(this, "currentPredictedTas", 180);
      __publicField(this, "currentPredictedGs", 180);
      __publicField(this, "inboundWindSpeed");
      __publicField(this, "geometry");
      this.geometry = this.computeGeometry();
    }
    get inboundLegCourse() {
      return this.fix.additionalData.course;
    }
    get outboundLegCourse() {
      return (this.inboundLegCourse + 180) % 360;
    }
    get turnDirection() {
      return this.fix.turnDirection;
    }
    get ident() {
      return this.fix.ident;
    }
    setInitialState(initialState) {
      this.state = initialState;
      this.initialState = initialState;
    }
    get outboundStartPoint() {
      const { fixB } = this.computeGeometry();
      return fixB;
    }
    computeLegDistance() {
      var _a, _b;
      if (this.fix.additionalData.distance !== void 0) {
        return this.fix.additionalData.distance;
      }
      const alt = (_a = this.fix.legAltitude1) != null ? _a : SimVar.GetSimVarValue("INDICATED ALTITUDE", "feet");
      const defaultMinutes = alt < 14e3 ? 1 : 1.5;
      const inboundGroundSpeed = this.currentPredictedTas + ((_b = this.inboundWindSpeed) != null ? _b : 0);
      return (this.fix.additionalData.distanceInMinutes !== void 0 ? this.fix.additionalData.distanceInMinutes : defaultMinutes) * inboundGroundSpeed / 60;
    }
    computeGeometry() {
      const legLength = this.computeLegDistance();
      const radius = this.radius;
      const turnSign = this.turnDirection === 1 /* Left */ ? -1 : 1;
      const fixA = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundLegCourse + turnSign * 90,
        radius * 2,
        this.fix.infos.coordinates.lat,
        this.fix.infos.coordinates.long
      );
      const fixB = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundLegCourse,
        legLength,
        fixA.lat,
        fixA.long
      );
      const fixC = Avionics.Utils.bearingDistanceToCoordinates(
        this.outboundLegCourse,
        legLength,
        this.fix.infos.coordinates.lat,
        this.fix.infos.coordinates.long
      );
      const arcCentreFix1 = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundLegCourse + turnSign * 90,
        radius,
        this.fix.infos.coordinates.lat,
        this.fix.infos.coordinates.long
      );
      const arcCentreFix2 = Avionics.Utils.bearingDistanceToCoordinates(
        this.inboundLegCourse + turnSign * 90,
        radius,
        fixC.lat,
        fixC.long
      );
      return {
        fixA,
        fixB,
        fixC,
        arcCentreFix1,
        arcCentreFix2,
        sweepAngle: turnSign * 180,
        legLength,
        radius
      };
    }
    get radius() {
      const gsMs = this.currentPredictedGs / 1.94384;
      const radius = gsMs ** 2 / (9.81 * Math.tan(maxBank(this.currentPredictedTas, true) * Math.PI / 180)) / 1852;
      return radius;
    }
    get terminationPoint() {
      return this.fix.infos.coordinates;
    }
    get distance() {
      return 0;
    }
    get inboundCourse() {
      return this.inboundLegCourse;
    }
    get outboundCourse() {
      return this.inboundLegCourse;
    }
    get startsInCircularArc() {
      return this.state === 1 /* Arc1 */ || this.state === 3 /* Arc2 */;
    }
    getNominalRollAngle(gs) {
      return this.endsInCircularArc ? maxBank(gs, true) : 0;
    }
    getDistanceToGoThisOrbit(ppos) {
      const { fixB, arcCentreFix1, arcCentreFix2, sweepAngle } = this.geometry;
      switch (this.state) {
        case 0 /* Inbound */:
          return courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
        case 1 /* Arc1 */:
          return arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle) + this.computeLegDistance() * 2 + this.radius * Math.PI;
        case 2 /* Outbound */:
          return courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB) + this.computeLegDistance() + this.radius * Math.PI;
        case 3 /* Arc2 */:
          return arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle) + this.computeLegDistance();
      }
      return 1;
    }
    getDistanceToGo(ppos) {
      return this.getDistanceToGoThisOrbit(ppos);
    }
    getHippodromePath() {
      const { fixA, fixB, fixC, arcCentreFix1, arcCentreFix2, sweepAngle } = this.geometry;
      return [
        {
          type: 1 /* Arc */,
          startPoint: this.fix.infos.coordinates,
          centrePoint: arcCentreFix1,
          endPoint: fixA,
          sweepAngle
        },
        {
          type: 0 /* Line */,
          startPoint: fixA,
          endPoint: fixB
        },
        {
          type: 1 /* Arc */,
          startPoint: fixB,
          centrePoint: arcCentreFix2,
          endPoint: fixC,
          sweepAngle
        },
        {
          type: 0 /* Line */,
          startPoint: fixC,
          endPoint: this.fix.infos.coordinates
        }
      ];
    }
    get predictedPath() {
      return this.getHippodromePath();
    }
    updateState(ppos, tas, geometry) {
      let dtg = 0;
      switch (this.state) {
        case 0 /* Inbound */: {
          dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
          break;
        }
        case 1 /* Arc1 */: {
          dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, geometry.arcCentreFix1, geometry.sweepAngle);
          break;
        }
        case 2 /* Outbound */: {
          dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, geometry.fixB);
          break;
        }
        case 3 /* Arc2 */: {
          dtg = arcDistanceToGo(ppos, geometry.fixB, geometry.arcCentreFix2, geometry.sweepAngle);
          break;
        }
        default:
          throw new Error(`Bad HxLeg state ${this.state}`);
      }
      if (dtg <= 0) {
        if (this.state === 0 /* Inbound */) {
          if (this.termConditionMet) {
            return;
          }
          this.updatePrediction();
        }
        this.state = (this.state + 1) % (3 /* Arc2 */ + 1);
        console.log(`HX switched to state ${HxLegGuidanceState[this.state]}`);
      }
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      const { fixB, arcCentreFix1, arcCentreFix2, sweepAngle, legLength } = this.geometry;
      this.updateState(ppos, tas, this.geometry);
      let params;
      let dtg;
      let nextPhi = 0;
      let rad = 0;
      switch (this.state) {
        case 0 /* Inbound */:
          params = courseToFixGuidance(ppos, trueTrack, this.inboundLegCourse, this.fix.infos.coordinates);
          dtg = courseToFixDistanceToGo(ppos, this.inboundLegCourse, this.fix.infos.coordinates);
          nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          break;
        case 1 /* Arc1 */:
          params = arcGuidance(ppos, trueTrack, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
          dtg = arcDistanceToGo(ppos, this.fix.infos.coordinates, arcCentreFix1, sweepAngle);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          if (legLength <= rad) {
            nextPhi = params.phiCommand;
          }
          break;
        case 2 /* Outbound */:
          params = courseToFixGuidance(ppos, trueTrack, this.outboundLegCourse, fixB);
          dtg = courseToFixDistanceToGo(ppos, this.outboundLegCourse, fixB);
          nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          break;
        case 3 /* Arc2 */:
          params = arcGuidance(ppos, trueTrack, fixB, arcCentreFix2, sweepAngle);
          dtg = arcDistanceToGo(ppos, fixB, arcCentreFix2, sweepAngle);
          rad = Geometry.getRollAnticipationDistance(gs, params.phiCommand, nextPhi);
          if (legLength <= rad) {
            nextPhi = params.phiCommand;
          }
          break;
        default:
          throw new Error(`Bad HxLeg state ${this.state}`);
      }
      if (dtg <= rad && !(this.state === 0 /* Inbound */ && this.termConditionMet)) {
        params.phiCommand = nextPhi;
      }
      return params;
    }
    recomputeWithParameters(isActive, _tas, _gs, _ppos, _trueTrack, _startAltitude, _verticalSpeed) {
      if (!isActive) {
        this.updatePrediction();
      }
    }
    setPredictedTas(tas) {
      this.nextPredictedTas = tas;
    }
    updatePrediction() {
      const windDirection = SimVar.GetSimVarValue("AMBIENT WIND DIRECTION", "Degrees");
      const windSpeed = SimVar.GetSimVarValue("AMBIENT WIND VELOCITY", "Knots");
      const windAngleToInbound = Math.abs(Avionics.Utils.diffAngle(reciprocal(windDirection), this.inboundLegCourse));
      this.inboundWindSpeed = Math.cos(windAngleToInbound * Math.PI / 180) * windSpeed;
      this.currentPredictedTas = this.nextPredictedTas;
      this.currentPredictedGs = this.currentPredictedTas + windSpeed;
      this.geometry = this.computeGeometry();
    }
    isAbeam(_ppos) {
      return false;
    }
    getPathStartPoint() {
      return this.fix.infos.coordinates;
    }
    getPathEndPoint() {
      return this.fix.infos.coordinates;
    }
  };
  var HMLeg = class extends HXLeg {
    constructor() {
      super(...arguments);
      __publicField(this, "immExitLength");
    }
    setImmediateExit(exit, ppos, tas) {
      const { legLength, fixA, sweepAngle } = this.geometry;
      if (exit) {
        switch (this.state) {
          case 1 /* Arc1 */:
            this.immExitLength = 0;
            break;
          case 2 /* Outbound */:
            const nextPhi = sweepAngle > 0 ? maxBank(tas, true) : -maxBank(tas, true);
            const rad = Geometry.getRollAnticipationDistance(tas, 0, nextPhi);
            this.immExitLength = Math.min(legLength, rad + courseToFixDistanceToGo(ppos, this.inboundLegCourse, fixA));
            break;
          case 3 /* Arc2 */:
          case 0 /* Inbound */:
            this.immExitLength = legLength;
            break;
        }
      }
      this.fix.additionalData.immExit = exit;
      this.termConditionMet = exit;
      if (exit) {
        this.geometry = this.computeGeometry();
      }
    }
    computeLegDistance() {
      if (this.termConditionMet) {
        return this.immExitLength;
      }
      return super.computeLegDistance();
    }
    get disableAutomaticSequencing() {
      return !this.termConditionMet;
    }
    get repr() {
      return `HM '${this.fix.ident}' ${TurnDirection[this.turnDirection]}`;
    }
  };
  var HALeg = class extends HXLeg {
    constructor(to, metadata, segment) {
      super(to, metadata, segment);
      this.to = to;
      this.metadata = metadata;
      this.segment = segment;
      __publicField(this, "targetAltitude");
      if (this.fix.legAltitudeDescription !== 2 /* AtOrAbove */) {
        console.warn(`HALeg invalid altitude descriptor ${this.fix.legAltitudeDescription}, must be ${2 /* AtOrAbove */}`);
      }
      this.targetAltitude = this.fix.legAltitude1;
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (SimVar.GetSimVarValue("INDICATED ALTITUDE", "feet") >= this.targetAltitude) {
        this.termConditionMet = true;
      }
      return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
      if (SimVar.GetSimVarValue("INDICATED ALTITUDE", "feet") >= this.targetAltitude) {
        this.termConditionMet = true;
      }
      if (!isActive && this.termConditionMet) {
        this.isNull = true;
      }
      this.setPredictedTas(tas);
      super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
    }
    getDistanceToGo(ppos) {
      if (this.isNull) {
        return 0;
      }
      if (this.termConditionMet) {
        return this.getDistanceToGoThisOrbit(ppos);
      }
      const { legLength, radius } = this.geometry;
      return legLength * 2 + radius * Math.PI * 2;
    }
    get disableAutomaticSequencing() {
      return !this.termConditionMet;
    }
    get predictedPath() {
      if (!this.isNull) {
        return super.predictedPath;
      }
      return [];
    }
    get repr() {
      return `HA '${this.fix.ident}' ${TurnDirection[this.turnDirection]} - ${this.targetAltitude.toFixed(0)}`;
    }
  };
  var HFLeg = class extends HXLeg {
    constructor() {
      super(...arguments);
      __publicField(this, "entryTransition");
    }
    getGuidanceParameters(ppos, trueTrack, tas, gs) {
      if (this.entryTransition) {
        this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === 3 /* Capture */ || this.entryTransition.state === 4 /* Done */;
      }
      return super.getGuidanceParameters(ppos, trueTrack, tas, gs);
    }
    recomputeWithParameters(isActive, tas, gs, ppos, trueTrack) {
      if (this.inboundGuidable instanceof HoldEntryTransition) {
        this.entryTransition = this.inboundGuidable;
        this.termConditionMet = this.entryTransition.isNull || this.entryTransition.state === 3 /* Capture */ || this.entryTransition.state === 4 /* Done */;
      }
      this.setPredictedTas(tas);
      super.recomputeWithParameters(isActive, tas, gs, ppos, trueTrack);
    }
    getDistanceToGo(ppos) {
      var _a, _b;
      return (_b = (_a = this.entryTransition) == null ? void 0 : _a.getDistanceToGo(ppos)) != null ? _b : 0;
    }
    get predictedPath() {
      return [];
    }
    get disableAutomaticSequencing() {
      return false;
    }
    get repr() {
      return `HF '${this.fix.ident}' ${TurnDirection[this.turnDirection]}`;
    }
  };

  // src/systems/shared/src/NavigationDisplay.ts
  var rangeSettings = [10, 20, 40, 80, 160, 320];
  var EfisVectorsGroup = /* @__PURE__ */ ((EfisVectorsGroup2) => {
    EfisVectorsGroup2[EfisVectorsGroup2["ACTIVE"] = 0] = "ACTIVE";
    EfisVectorsGroup2[EfisVectorsGroup2["DASHED"] = 1] = "DASHED";
    EfisVectorsGroup2[EfisVectorsGroup2["OFFSET"] = 2] = "OFFSET";
    EfisVectorsGroup2[EfisVectorsGroup2["TEMPORARY"] = 3] = "TEMPORARY";
    EfisVectorsGroup2[EfisVectorsGroup2["SECONDARY"] = 4] = "SECONDARY";
    EfisVectorsGroup2[EfisVectorsGroup2["SECONDARY_DASHED"] = 5] = "SECONDARY_DASHED";
    EfisVectorsGroup2[EfisVectorsGroup2["MISSED"] = 6] = "MISSED";
    EfisVectorsGroup2[EfisVectorsGroup2["ALTERNATE"] = 7] = "ALTERNATE";
    EfisVectorsGroup2[EfisVectorsGroup2["ACTIVE_EOSID"] = 8] = "ACTIVE_EOSID";
    return EfisVectorsGroup2;
  })(EfisVectorsGroup || {});

  // src/systems/fmgc/src/guidance/vnav/descent/DescentStrategy.ts
  var DEFAULT_AIRCRAFT_CONFIG = {
    flapConfig: 0 /* CLEAN */,
    speedbrakesExtended: false,
    gearExtended: false
  };

  // ../node_modules/@microsoft/msfs-sdk/msfssdk.js
  var SimVarValueType;
  (function(SimVarValueType2) {
    SimVarValueType2["Number"] = "number";
    SimVarValueType2["Percent"] = "percent";
    SimVarValueType2["Degree"] = "degrees";
    SimVarValueType2["Knots"] = "knots";
    SimVarValueType2["Feet"] = "feet";
    SimVarValueType2["Meters"] = "meters";
    SimVarValueType2["FPM"] = "feet per minute";
    SimVarValueType2["Radians"] = "radians";
    SimVarValueType2["InHG"] = "inches of mercury";
    SimVarValueType2["MB"] = "Millibars";
    SimVarValueType2["Bool"] = "bool";
    SimVarValueType2["Celsius"] = "celsius";
    SimVarValueType2["MHz"] = "MHz";
    SimVarValueType2["KHz"] = "KHz";
    SimVarValueType2["NM"] = "nautical mile";
    SimVarValueType2["String"] = "string";
    SimVarValueType2["RPM"] = "Rpm";
    SimVarValueType2["PPH"] = "Pounds per hour";
    SimVarValueType2["GPH"] = "gph";
    SimVarValueType2["Farenheit"] = "farenheit";
    SimVarValueType2["PSI"] = "psi";
    SimVarValueType2["GAL"] = "gallons";
    SimVarValueType2["LBS"] = "pounds";
    SimVarValueType2["Hours"] = "Hours";
    SimVarValueType2["Volts"] = "Volts";
    SimVarValueType2["Amps"] = "Amperes";
    SimVarValueType2["Seconds"] = "seconds";
    SimVarValueType2["Enum"] = "enum";
    SimVarValueType2["LLA"] = "latlonalt";
    SimVarValueType2["MetersPerSecond"] = "meters per second";
    SimVarValueType2["Mach"] = "mach";
    SimVarValueType2["Pounds"] = "pounds";
    SimVarValueType2["SlugsPerCubicFoot"] = "slug per cubic foot";
  })(SimVarValueType || (SimVarValueType = {}));
  var latlonaltRegEx = new RegExp(/latlonalt/i);
  var latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
  var pbhRegex = new RegExp(/pbh/i);
  var pid_structRegex = new RegExp(/pid_struct/i);
  var xyzRegex = new RegExp(/xyz/i);
  var stringRegex = new RegExp(/string/i);
  var boolRegex = new RegExp(/boolean|bool/i);
  var numberRegex = new RegExp(/number/i);
  var defaultSource = "";
  SimVar.GetSimVarValue = (name69, unit, dataSource = defaultSource) => {
    try {
      if (simvar) {
        let output;
        const registeredID = SimVar.GetRegisteredId(name69, unit, dataSource);
        if (registeredID >= 0) {
          if (numberRegex.test(unit)) {
            output = simvar.getValueReg(registeredID);
          } else if (stringRegex.test(unit)) {
            output = simvar.getValueReg_String(registeredID);
          } else if (latlonaltRegEx.test(unit)) {
            output = new LatLongAlt(simvar.getValue_LatLongAlt(name69, dataSource));
          } else if (latlonaltpbhRegex.test(unit)) {
            output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name69, dataSource));
          } else if (pbhRegex.test(unit)) {
            output = new PitchBankHeading(simvar.getValue_PBH(name69, dataSource));
          } else if (pid_structRegex.test(unit)) {
            output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name69, dataSource));
          } else if (xyzRegex.test(unit)) {
            output = new XYZ(simvar.getValue_XYZ(name69, dataSource));
          } else {
            output = simvar.getValueReg(registeredID);
          }
        }
        return output;
      } else {
        console.warn("SimVar handler is not defined (" + name69 + ")");
      }
    } catch (error) {
      console.warn("ERROR ", error, " GetSimVarValue " + name69 + " unit : " + unit);
      return null;
    }
    return null;
  };
  SimVar.SetSimVarValue = (name69, unit, value, dataSource = defaultSource) => {
    if (value == void 0) {
      console.warn(name69 + " : Trying to set a null value");
      return Promise.resolve();
    }
    try {
      if (simvar) {
        const regID = SimVar.GetRegisteredId(name69, unit, dataSource);
        if (regID >= 0) {
          if (stringRegex.test(unit)) {
            return Coherent.call("setValueReg_String", regID, value);
          } else if (boolRegex.test(unit)) {
            return Coherent.call("setValueReg_Bool", regID, !!value);
          } else if (numberRegex.test(unit)) {
            return Coherent.call("setValueReg_Number", regID, value);
          } else if (latlonaltRegEx.test(unit)) {
            return Coherent.call("setValue_LatLongAlt", name69, value, dataSource);
          } else if (latlonaltpbhRegex.test(unit)) {
            return Coherent.call("setValue_LatLongAltPBH", name69, value, dataSource);
          } else if (pbhRegex.test(unit)) {
            return Coherent.call("setValue_PBH", name69, value, dataSource);
          } else if (pid_structRegex.test(unit)) {
            return Coherent.call("setValue_PID_STRUCT", name69, value, dataSource);
          } else if (xyzRegex.test(unit)) {
            return Coherent.call("setValue_XYZ", name69, value, dataSource);
          } else {
            return Coherent.call("setValueReg_Number", regID, value);
          }
        }
      } else {
        console.warn("SimVar handler is not defined");
      }
    } catch (error) {
      console.warn("error SetSimVarValue " + error);
    }
    return Promise.resolve();
  };
  var NumberUnit = class {
    constructor(number2, unit) {
      this._number = number2;
      this._unit = unit;
      this.readonly = new NumberUnitReadOnly(this);
    }
    get number() {
      return this._number;
    }
    get unit() {
      return this._unit;
    }
    toNumberOfThisUnit(value, unit) {
      if (typeof value !== "number" && this.unit.canConvert(value.unit)) {
        return this.unit.convertFrom(value.number, value.unit);
      }
      if (typeof value === "number" && (!unit || this.unit.canConvert(unit))) {
        return unit ? this.unit.convertFrom(value, unit) : value;
      }
      return void 0;
    }
    set(arg1, arg2) {
      const converted = this.toNumberOfThisUnit(arg1, arg2);
      if (converted !== void 0) {
        this._number = converted;
        return this;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number + converted, this.unit);
        } else {
          out = this;
          this._number += converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? void 0 : arg2);
      if (converted !== void 0) {
        let out = isArg2NumberUnit ? arg2 : arg3;
        if (out) {
          out.set(this.number - converted, this.unit);
        } else {
          out = this;
          this._number -= converted;
        }
        return out;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    scale(factor, out) {
      if (out) {
        return out.set(this.number * factor, this.unit);
      } else {
        this._number *= factor;
        return this;
      }
    }
    ratio(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted) {
        return this.number / converted;
      }
      throw new Error("Invalid unit conversion attempted.");
    }
    abs(out) {
      if (out) {
        return out.set(Math.abs(this.number), this.unit);
      } else {
        this._number = Math.abs(this._number);
        return this;
      }
    }
    asUnit(unit) {
      return this.unit.convertTo(this.number, unit);
    }
    compare(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        throw new Error("Invalid unit conversion attempted.");
      }
      const diff = this.number - converted;
      if (Math.abs(diff) < 1e-14) {
        return 0;
      }
      return Math.sign(diff);
    }
    equals(value, unit) {
      const converted = this.toNumberOfThisUnit(value, unit);
      if (converted === void 0) {
        return false;
      }
      if (isNaN(converted) && this.isNaN()) {
        return true;
      }
      const diff = this.number - converted;
      return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    isNaN() {
      return isNaN(this.number);
    }
    copy() {
      return new NumberUnit(this.number, this.unit);
    }
  };
  var NumberUnitReadOnly = class {
    constructor(source) {
      this.source = source;
    }
    get number() {
      return this.source.number;
    }
    get unit() {
      return this.source.unit;
    }
    add(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.add(arg1, arg2, out);
      } else {
        return this.source.add(arg1, out);
      }
    }
    subtract(arg1, arg2, arg3) {
      const isArg2NumberUnit = arg2 instanceof NumberUnit;
      const out = isArg2NumberUnit ? arg2 : arg3;
      if (typeof arg1 === "number") {
        return this.source.subtract(arg1, arg2, out);
      } else {
        return this.source.subtract(arg1, out);
      }
    }
    scale(factor, out) {
      return this.source.scale(factor, out);
    }
    ratio(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.ratio(arg1, arg2);
      } else {
        return this.source.ratio(arg1);
      }
    }
    abs(out) {
      return this.source.abs(out);
    }
    asUnit(unit) {
      return this.source.asUnit(unit);
    }
    compare(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.compare(arg1, arg2);
      } else {
        return this.source.compare(arg1);
      }
    }
    equals(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2);
      } else {
        return this.source.equals(arg1);
      }
    }
    isNaN() {
      return this.source.isNaN();
    }
    copy() {
      return this.source.copy();
    }
  };
  var AbstractUnit = class {
    constructor(name69) {
      this.name = name69;
    }
    canConvert(otherUnit) {
      return this.family === otherUnit.family;
    }
    createNumber(value) {
      return new NumberUnit(value, this);
    }
    equals(other) {
      return this.family === other.family && this.name === other.name;
    }
  };
  var SimpleUnit = class extends AbstractUnit {
    constructor(family, name69, scaleFactor, zeroOffset = 0) {
      super(name69);
      this.family = family;
      this.scaleFactor = scaleFactor;
      this.zeroOffset = zeroOffset;
    }
    canConvert(otherUnit) {
      return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
  };
  var CompoundUnit = class extends AbstractUnit {
    constructor(family, numerator, denominator, name69) {
      if (name69 === void 0) {
        name69 = "";
        let i = 0;
        while (i < numerator.length - 1) {
          name69 += `${numerator[i++].name}-`;
        }
        name69 += `${numerator[i].name}`;
        if (denominator.length > 0) {
          name69 += " per ";
          i = 0;
          while (i < denominator.length - 1) {
            name69 += `${denominator[i++].name}-`;
          }
          name69 += `${denominator[i].name}`;
        }
      }
      super(name69);
      this.family = family;
      this.numerator = Array.from(numerator);
      this.denominator = Array.from(denominator);
      this.numerator.sort((a, b) => a.family.localeCompare(b.family));
      this.denominator.sort((a, b) => a.family.localeCompare(b.family));
      this.scaleFactor = this.getScaleFactor();
    }
    getScaleFactor() {
      let factor = 1;
      factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
      factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
      return factor;
    }
    canConvert(otherUnit) {
      return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
  };
  var UnitFamily;
  (function(UnitFamily2) {
    UnitFamily2["Distance"] = "distance";
    UnitFamily2["Angle"] = "angle";
    UnitFamily2["Duration"] = "duration";
    UnitFamily2["Weight"] = "weight";
    UnitFamily2["Volume"] = "volume";
    UnitFamily2["Pressure"] = "pressure";
    UnitFamily2["Temperature"] = "temperature";
    UnitFamily2["TemperatureDelta"] = "temperature_delta";
    UnitFamily2["Speed"] = "speed";
    UnitFamily2["Acceleration"] = "acceleration";
    UnitFamily2["WeightFlux"] = "weight_flux";
    UnitFamily2["VolumeFlux"] = "volume_flux";
  })(UnitFamily || (UnitFamily = {}));
  var UnitType = class {
  };
  UnitType.METER = new SimpleUnit(UnitFamily.Distance, "meter", 1);
  UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, "foot", 0.3048);
  UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, "kilometer", 1e3);
  UnitType.MILE = new SimpleUnit(UnitFamily.Distance, "mile", 1609.34);
  UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, "nautical mile", 1852);
  UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, "great arc radian", 6378100);
  UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, "radian", 1);
  UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, "degree", Math.PI / 180);
  UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, "minute", Math.PI / 180 / 60);
  UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, "second", Math.PI / 180 / 3600);
  UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, "millisecond", 1e-3);
  UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, "second", 1);
  UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, "minute", 60);
  UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, "hour", 3600);
  UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, "kilogram", 1);
  UnitType.POUND = new SimpleUnit(UnitFamily.Weight, "pound", 0.453592);
  UnitType.TON = new SimpleUnit(UnitFamily.Weight, "ton", 907.185);
  UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, "tonne", 1e3);
  UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, "liter", 0.80283679);
  UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "gallon", 3.0390664);
  UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, "imperial gallon", 3.6497683);
  UnitType.LITER = new SimpleUnit(UnitFamily.Volume, "liter", 1);
  UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, "gallon", 3.78541);
  UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, "hectopascal", 1);
  UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, "atmosphere", 1013.25);
  UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, "inch of mercury", 33.8639);
  UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, "millimeter of mercury", 1.33322);
  UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, "kelvin", 1, 0);
  UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, "\xB0 Celsius", 1, 273.15);
  UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, "\xB0 Fahrenheit", 5 / 9, 459.67);
  UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, "\xB0 Rankine", 5 / 9, 0);
  UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Celsius", 1);
  UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, "\u0394\xB0 Fahrenheit", 5 / 9);
  UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], "knot");
  UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
  UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
  UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
  UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
  UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
  UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
  UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
  UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [new SimpleUnit(UnitFamily.Distance, "9.80665 meter", 9.80665)], [UnitType.SECOND, UnitType.SECOND]);
  UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
  UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
  UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
  UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
  UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
  var BasePublisher = class {
    constructor(bus, pacer = void 0) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.publishActive = false;
      this.pacer = pacer;
    }
    startPublish() {
      this.publishActive = true;
    }
    stopPublish() {
      this.publishActive = false;
    }
    isPublishing() {
      return this.publishActive;
    }
    onUpdate() {
      return;
    }
    publish(topic, data, sync = false, isCached = true) {
      if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
        this.publisher.pub(topic, data, sync, isCached);
      }
    }
  };
  var SimVarPublisher = class extends BasePublisher {
    constructor(simVarMap, bus, pacer) {
      super(bus, pacer);
      this.resolvedSimVars = /* @__PURE__ */ new Map();
      this.indexedSimVars = /* @__PURE__ */ new Map();
      this.subscribed = /* @__PURE__ */ new Set();
      for (const [topic, entry] of simVarMap) {
        if (entry.indexed) {
          this.indexedSimVars.set(topic, entry);
          this.resolveIndexedSimVar(topic, entry);
        } else {
          this.resolvedSimVars.set(topic, entry);
        }
      }
      const handleSubscribedTopic = (topic) => {
        if (this.resolvedSimVars.has(topic)) {
          this.onTopicSubscribed(topic);
        } else {
          this.tryMatchIndexedSubscribedTopic(topic);
        }
      };
      this.bus.forEachSubscribedTopic(handleSubscribedTopic);
      this.bus.getSubscriber().on("event_bus_topic_first_sub").handle(handleSubscribedTopic);
    }
    tryMatchIndexedSubscribedTopic(topic) {
      if (this.indexedSimVars.size === 0) {
        return;
      }
      if (!SimVarPublisher.INDEXED_REGEX.test(topic)) {
        return;
      }
      const match = topic.match(SimVarPublisher.INDEXED_REGEX);
      const [, matchedTopic, index] = match;
      const entry = this.indexedSimVars.get(matchedTopic);
      if (entry) {
        this.onTopicSubscribed(this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index)));
      }
    }
    resolveIndexedSimVar(topic, entry, index) {
      const resolvedTopic = index === void 0 ? topic : `${topic}_${index}`;
      if (this.resolvedSimVars.has(resolvedTopic)) {
        return resolvedTopic;
      }
      this.resolvedSimVars.set(resolvedTopic, { name: entry.name.replace("#index#", `${index !== null && index !== void 0 ? index : 1}`), type: entry.type, map: entry.map });
      return resolvedTopic;
    }
    onTopicSubscribed(topic) {
      if (this.subscribed.has(topic)) {
        return;
      }
      this.subscribed.add(topic);
      if (this.publishActive) {
        this.publishTopic(topic);
      }
    }
    subscribe(data) {
      return;
    }
    unsubscribe(data) {
      return;
    }
    onUpdate() {
      for (const topic of this.subscribed.values()) {
        this.publishTopic(topic);
      }
    }
    publishTopic(topic) {
      const value = this.getValue(topic);
      if (value !== void 0) {
        this.publish(topic, value);
      }
    }
    getValue(topic) {
      const entry = this.resolvedSimVars.get(topic);
      if (entry === void 0) {
        return void 0;
      }
      return entry.map === void 0 ? this.getSimVarValue(entry) : entry.map(this.getSimVarValue(entry));
    }
    getSimVarValue(entry) {
      const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
      if (entry.type === SimVarValueType.Bool) {
        return svValue === 1;
      }
      return svValue;
    }
  };
  SimVarPublisher.INDEXED_REGEX = /(.*)_([1-9]\d*)$/;
  var AeroMath = class {
    static pressureAir(temperature, density) {
      return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    static densityAir(pressure, temperature) {
      return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    static temperatureAir(pressure, density) {
      return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    static soundSpeedAir(temperature) {
      return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    static totalPressureRatioAir(mach) {
      return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    static isaTemperature(altitude) {
      if (altitude < 11e3) {
        return 15 + Math.max(altitude, -610) * -65e-4;
      } else if (altitude < 2e4) {
        return -56.5;
      } else if (altitude < 32e3) {
        return -56.5 + (altitude - 2e4) * 1e-3;
      } else if (altitude < 47e3) {
        return -44.5 + (altitude - 32e3) * 28e-4;
      } else if (altitude < 51e3) {
        return -2.5;
      } else if (altitude < 71e3) {
        return -2.5 + (altitude - 51e3) * -28e-4;
      } else {
        return -58.5 + (Math.min(altitude, 8e4) - 71e3) * -2e-3;
      }
    }
    static isaPressure(altitude) {
      if (altitude < -610) {
        return 1099.15;
      } else if (altitude <= 11e3) {
        return 1013.25 * Math.pow(1 - 22558e-9 * altitude, 5.2558);
      } else if (altitude <= 2e4) {
        return 226.32 * Math.exp(-157686e-9 * (altitude - 11e3));
      } else if (altitude <= 32e3) {
        return 54.7499 * Math.pow(1 + 461574e-11 * (altitude - 2e4), -34.1627);
      } else if (altitude <= 47e3) {
        return 8.68058 * Math.pow(1 + 122458e-10 * (altitude - 32e3), -12.201);
      } else if (altitude <= 51e3) {
        return 1.10914 * Math.exp(-126225e-9 * (altitude - 47e3));
      } else if (altitude <= 71e3) {
        return 0.669439 * Math.pow(1 - 103455e-10 * (altitude - 51e3), 12.201);
      } else if (altitude <= 8e4) {
        return 0.039568 * Math.pow(1 - 931749e-11 * (altitude - 71e3), 17.0814);
      } else {
        return 88638e-7;
      }
    }
    static isaDensity(altitude, deltaIsa = 0) {
      return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    static soundSpeedIsa(altitude, deltaIsa = 0) {
      return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    static tasToMach(tas, soundSpeed) {
      return tas / soundSpeed;
    }
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
      return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static machToTas(mach, soundSpeed) {
      return mach * soundSpeed;
    }
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
      return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static casToMach(cas, pressure) {
      const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
      const impactPressure = 1013.25 * (Math.pow(1 + 0.2 * mach0 * mach0, 3.5) - 1);
      return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    static casToMachIsa(cas, altitude) {
      return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    static machToCas(mach, pressure) {
      const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
      return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    static machToCasIsa(mach, altitude) {
      return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    static casToTas(cas, pressure, temperature) {
      return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
      return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    static tasToCas(tas, pressure, temperature) {
      return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
      return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    static flowCoefFromForce(force, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return force / (dynamicPressure * area);
    }
    static flowForceFromCoef(coef, area, arg3, arg4) {
      const dynamicPressure = arg4 === void 0 ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
      return coef * dynamicPressure * area;
    }
  };
  AeroMath.R = 8.314462618153;
  AeroMath.R_AIR = 287.057;
  AeroMath.GAMMA_AIR = 1.4;
  AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
  AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.lift = AeroMath.flowForceFromCoef;
  AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
  AeroMath.drag = AeroMath.flowForceFromCoef;
  var BitFlags = class {
    static createFlag(index) {
      if (index < 0 || index > 32) {
        throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
      }
      return 1 << index;
    }
    static not(flags, mask = ~0) {
      return flags ^ mask;
    }
    static union(...flags) {
      let result = 0;
      const len = flags.length;
      for (let i = 0; i < len; i++) {
        result |= flags[i];
      }
      return result;
    }
    static intersection(...flags) {
      const len = flags.length;
      if (len === 0) {
        return 0;
      }
      let result = flags[0];
      for (let i = 1; i < len; i++) {
        result &= flags[i];
      }
      return result;
    }
    static set(flags, valuesToSet, mask) {
      return flags & ~mask | valuesToSet & mask;
    }
    static isAny(flags, conditions) {
      return (flags & conditions) !== 0;
    }
    static isAll(flags, conditions) {
      return (flags & conditions) === conditions;
    }
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
      startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0, 0, 32);
      endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = 32, 0, 32);
      for (let i = startIndex; i < endIndex; i++) {
        const value = (flags & 1 << i) !== 0;
        if (valueFilter === void 0 || valueFilter === value) {
          callback(value, i, flags);
        }
      }
    }
  };
  var HandlerSubscription = class {
    constructor(handler, initialNotifyFunc, onDestroy) {
      this.handler = handler;
      this.initialNotifyFunc = initialNotifyFunc;
      this.onDestroy = onDestroy;
      this._isAlive = true;
      this._isPaused = false;
      this.canInitialNotify = initialNotifyFunc !== void 0;
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    initialNotify() {
      if (!this._isAlive) {
        throw new Error("HandlerSubscription: cannot notify a dead Subscription.");
      }
      this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot pause a dead Subscription.");
      }
      this._isPaused = true;
      return this;
    }
    resume(initialNotify = false) {
      if (!this._isAlive) {
        throw new Error("Subscription: cannot resume a dead Subscription.");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      if (initialNotify) {
        this.initialNotify();
      }
      return this;
    }
    destroy() {
      if (!this._isAlive) {
        return;
      }
      this._isAlive = false;
      this.onDestroy && this.onDestroy(this);
    }
  };
  var SubscribablePipe = class extends HandlerSubscription {
    constructor(from, to, arg3, arg4) {
      let handler;
      let onDestroy;
      if (typeof arg4 === "function") {
        handler = (fromVal) => {
          to.set(arg3(fromVal, to.get()));
        };
        onDestroy = arg4;
      } else {
        handler = (fromVal) => {
          to.set(fromVal);
        };
        onDestroy = arg3;
      }
      super(handler, (sub2) => {
        sub2.handler(from.get());
      }, onDestroy);
    }
  };
  var AbstractSubscribable = class {
    constructor() {
      this.isSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.notifySubscription.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub2 = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub2);
      if (paused) {
        sub2.pause();
      } else if (initialNotify) {
        sub2.initialNotify();
      }
      return sub2;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub2) => sub2.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    notify() {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub2 = this.subs[i];
          if (sub2.isAlive && !sub2.isPaused) {
            this.notifySubscription(sub2);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub2.isAlive);
        } catch (error) {
          console.error(`AbstractSubscribable: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub2) => sub2.isAlive);
      }
    }
    notifySubscription(sub2) {
      sub2.handler(this.get());
    }
    onSubDestroyed(sub2) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub2), 1);
      }
    }
    map(fn, equalityFunc, mutateFunc, initialVal) {
      return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    pipe(to, arg2, arg3) {
      let sub2;
      let paused;
      if (typeof arg2 === "function") {
        sub2 = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub2 = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub2);
      if (paused) {
        sub2.pause();
      } else {
        sub2.initialNotify();
      }
      return sub2;
    }
  };
  AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var MappedSubscribableClass = class extends AbstractSubscribable {
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
      super();
      this.input = input;
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.input.get()));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.input.get());
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSub = this.input.sub((inputValue) => {
        this.updateValue(inputValue);
      }, true);
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    updateValue(inputValue) {
      const value = this.mapFunc(inputValue, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    get() {
      return this.value;
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot pause a dead subscribable");
      }
      if (this._isPaused) {
        return this;
      }
      this.inputSub.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubscribable: cannot resume a dead subscribable");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this.inputSub.resume(true);
      return this;
    }
    destroy() {
      this._isAlive = false;
      this.inputSub.destroy();
    }
  };
  var NumberUnitSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    static createFromNumberUnit(initialVal) {
      return new NumberUnitSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var Vec2Math = class {
    static create(x, y) {
      const vec = new Float64Array(2);
      if (x !== void 0 && y !== void 0) {
        vec[0] = x;
        vec[1] = y;
      }
      return vec;
    }
    static theta(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    static set(x, y, vec) {
      vec[0] = x;
      vec[1] = y;
      return vec;
    }
    static setFromPolar(r, theta, vec) {
      vec[0] = r * Math.cos(theta);
      vec[1] = r * Math.sin(theta);
      return vec;
    }
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      return out;
    }
    static abs(v1) {
      return Math.hypot(v1[0], v1[1]);
    }
    static normalize(v1, out) {
      const mag = Vec2Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      return out;
    }
    static normal(v1, out, counterClockwise = false) {
      const x = v1[0];
      const y = v1[1];
      if (!counterClockwise) {
        out[0] = y;
        out[1] = -x;
      } else {
        out[0] = -y;
        out[1] = x;
      }
      return out;
    }
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    static copy(from, to) {
      return Vec2Math.set(from[0], from[1], to);
    }
    static pointWithinPolygon(polygon, point) {
      let k = 0;
      let f = 0;
      let u1 = 0;
      let v1 = 0;
      let u2 = 0;
      let v2 = 0;
      let currentP = null;
      let nextP = null;
      const x = point[0];
      const y = point[1];
      const contourLen = polygon.length - 1;
      currentP = polygon[0];
      if (currentP[0] !== polygon[contourLen][0] && currentP[1] !== polygon[contourLen][1]) {
        throw new Error("First and last coordinates in a ring must be the same");
      }
      u1 = currentP[0] - x;
      v1 = currentP[1] - y;
      for (let i = 0; i < polygon.length - 1; i++) {
        nextP = polygon[i + 1];
        v2 = nextP[1] - y;
        if (v1 < 0 && v2 < 0 || v1 > 0 && v2 > 0) {
          currentP = nextP;
          v1 = v2;
          u1 = currentP[0] - x;
          continue;
        }
        u2 = nextP[0] - point[0];
        if (v2 > 0 && v1 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f > 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v1 > 0 && v2 <= 0) {
          f = u1 * v2 - u2 * v1;
          if (f < 0) {
            k = k + 1;
          } else if (f === 0) {
            return void 0;
          }
        } else if (v2 === 0 && v1 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 < 0) {
          f = u1 * v2 - u2 * v1;
          if (f === 0) {
            return void 0;
          }
        } else if (v1 === 0 && v2 === 0) {
          if (u2 <= 0 && u1 >= 0) {
            return void 0;
          } else if (u1 <= 0 && u2 >= 0) {
            return void 0;
          }
        }
        currentP = nextP;
        v1 = v2;
        u1 = u2;
      }
      if (k % 2 === 0) {
        return false;
      }
      return true;
    }
  };
  var Vec3Math = class {
    static create(x, y, z) {
      const vec = new Float64Array(3);
      if (x !== void 0 && y !== void 0 && z !== void 0) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
      }
      return vec;
    }
    static theta(vec) {
      return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    static phi(vec) {
      return Math.atan2(vec[1], vec[0]);
    }
    static set(x, y, z, vec) {
      vec[0] = x;
      vec[1] = y;
      vec[2] = z;
      return vec;
    }
    static setFromSpherical(r, theta, phi, vec) {
      const sinTheta = Math.sin(theta);
      vec[0] = sinTheta * Math.cos(phi);
      vec[1] = sinTheta * Math.sin(phi);
      vec[2] = Math.cos(theta);
      return vec;
    }
    static add(v1, v2, out) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      out[2] = v1[2] + v2[2];
      return out;
    }
    static sub(v1, v2, out) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      out[2] = v1[2] - v2[2];
      return out;
    }
    static dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    static cross(v1, v2, out) {
      const x1 = v1[0];
      const y1 = v1[1];
      const z1 = v1[2];
      const x2 = v2[0];
      const y2 = v2[1];
      const z2 = v2[2];
      out[0] = y1 * z2 - z1 * y2;
      out[1] = z1 * x2 - x1 * z2;
      out[2] = x1 * y2 - y1 * x2;
      return out;
    }
    static multScalar(v1, scalar, out) {
      out[0] = v1[0] * scalar;
      out[1] = v1[1] * scalar;
      out[2] = v1[2] * scalar;
      return out;
    }
    static abs(v1) {
      return Math.hypot(v1[0], v1[1], v1[2]);
    }
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      out[0] = v1[0] / mag;
      out[1] = v1[1] / mag;
      out[2] = v1[2] / mag;
      return out;
    }
    static distance(vec1, vec2) {
      return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    static equals(vec1, vec2) {
      return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    static copy(from, to) {
      return Vec3Math.set(from[0], from[1], from[2], to);
    }
  };
  var VecNMath = class {
    static create(length, ...components2) {
      const vec = new Float64Array(length);
      for (let i = 0; i < length && components2.length; i++) {
        vec[i] = components2[i];
      }
      return vec;
    }
    static set(vec, ...components2) {
      for (let i = 0; i < vec.length && components2.length; i++) {
        vec[i] = components2[i];
      }
      return vec;
    }
    static abs(vec) {
      return Math.hypot(...vec);
    }
    static dot(v1, v2) {
      if (v1.length !== v2.length) {
        throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
      }
      let dot2 = 0;
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        dot2 += v1[i] * v2[i];
      }
      return dot2;
    }
    static normalize(v1, out) {
      const mag = Vec3Math.abs(v1);
      const len = v1.length;
      for (let i = 0; i < len; i++) {
        out[i] = v1[i] / mag;
      }
      return out;
    }
    static equals(vec1, vec2) {
      if (vec1.length !== vec2.length) {
        return false;
      }
      for (let i = 0; i < vec1.length; i++) {
        if (vec1[i] !== vec2[i]) {
          return false;
        }
      }
      return true;
    }
    static copy(from, to) {
      if (from.length !== to.length) {
        throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
      }
      to.set(from);
      return to;
    }
  };
  var Vec2Subject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new Vec2Subject(initialVal);
    }
    static createFromVector(initialVal) {
      return new Vec2Subject(initialVal);
    }
    get() {
      return this.value;
    }
    set(arg1, arg2) {
      let x, y;
      if (typeof arg1 === "number") {
        x = arg1;
        y = arg2;
      } else {
        x = arg1[0];
        y = arg1[1];
      }
      const equals = x === this.value[0] && y === this.value[1];
      if (!equals) {
        Vec2Math.set(x, y, this.value);
        this.notify();
      }
    }
  };
  var VecNSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new VecNSubject(initialVal);
    }
    static createFromVector(initialVal) {
      return new VecNSubject(initialVal);
    }
    get() {
      return this.value;
    }
    set(arg1, ...args) {
      let array;
      if (typeof arg1 === "number") {
        array = args;
        args.unshift(arg1);
      } else {
        array = arg1;
      }
      if (array.length > this.value.length) {
        throw new RangeError(`VecNSubject: Cannot set ${array.length} components on a vector of length ${this.value.length}`);
      }
      let equals = true;
      const len = array.length;
      for (let i = 0; i < len; i++) {
        if (array[i] !== this.value[i]) {
          equals = false;
          break;
        }
      }
      if (!equals) {
        this.value.set(array);
        this.notify();
      }
    }
  };
  var Subject = class extends AbstractSubscribable {
    constructor(value, equalityFunc, mutateFunc) {
      super();
      this.value = value;
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.isMutableSubscribable = true;
    }
    static create(v, equalityFunc, mutateFunc) {
      return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    notifySub(sub2) {
      sub2(this.value);
    }
    set(value) {
      if (!this.equalityFunc(value, this.value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    apply(value) {
      let changed = false;
      for (const prop in value) {
        changed = value[prop] !== this.value[prop];
        if (changed) {
          break;
        }
      }
      Object.assign(this.value, value);
      changed && this.notify();
    }
    notify() {
      super.notify();
    }
    get() {
      return this.value;
    }
  };
  var Transform2D = class {
    constructor() {
      this.array = new Float64Array([1, 0, 0, 0, 1, 0]);
    }
    getParameters() {
      return this.array;
    }
    set(arg1, skewX, translateX, skewY, scaleY, translateY) {
      let scaleX = arg1;
      if (arg1 instanceof Transform2D) {
        [scaleX, skewX, translateX, skewY, scaleY, translateY] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewX;
      array[2] = translateX;
      array[3] = skewY;
      array[4] = scaleY;
      array[5] = translateY;
      return this;
    }
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    setScaleY(value) {
      this.array[4] = value;
      return this;
    }
    setScale(x, y) {
      this.array[0] = x;
      this.array[4] = y;
      return this;
    }
    setSkewX(value) {
      this.array[1] = value;
      return this;
    }
    setSkewY(value) {
      this.array[3] = value;
      return this;
    }
    setTranslateX(value) {
      this.array[2] = value;
      return this;
    }
    setTranslateY(value) {
      this.array[5] = value;
      return this;
    }
    setTranslate(x, y) {
      this.array[2] = x;
      this.array[5] = y;
      return this;
    }
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_10 = array[3];
      const e_11 = array[4];
      const e_12 = array[5];
      const i_00 = e_11;
      const i_01 = -e_10;
      const i_10 = -e_01;
      const i_11 = e_00;
      const i_20 = e_01 * e_12 - e_02 * e_11;
      const i_21 = -(e_00 * e_12 - e_02 * e_10);
      const det2 = e_00 * i_00 + e_01 * i_01;
      return this.set(i_00 / det2, i_10 / det2, i_20 / det2, i_01 / det2, i_11 / det2, i_21 / det2);
    }
    copy() {
      return new Transform2D().set(this);
    }
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + array[2];
      const y = vec[0] * array[3] + vec[1] * array[4] + array[5];
      return Vec2Math.set(x, y, out);
    }
    offsetOrigin(x, y) {
      Transform2D.offsetOriginCache[0].toTranslation(-x, -y);
      Transform2D.offsetOriginCache[1] = this;
      Transform2D.offsetOriginCache[2].toTranslation(x, y);
      return Transform2D.concat(this, Transform2D.offsetOriginCache);
    }
    toIdentity() {
      return this.set(1, 0, 0, 0, 1, 0);
    }
    toTranslation(x, y) {
      return this.set(1, 0, x, 0, 1, y);
    }
    toScale(x, y, originX, originY) {
      this.set(x, 0, 0, 0, y, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    toRotation(theta, originX, originY) {
      const sin5 = Math.sin(theta);
      const cos5 = Math.cos(theta);
      this.set(cos5, -sin5, 0, sin5, cos5, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    toReflection(theta, originX, originY) {
      const sin5 = Math.sin(2 * theta);
      const cos5 = Math.cos(2 * theta);
      this.set(cos5, sin5, 0, sin5, -cos5, 0);
      if (originX !== void 0 && originY !== void 0) {
        this.offsetOrigin(originX, originY);
      }
      return this;
    }
    addTranslation(x, y, order = "after") {
      if (order === "before") {
        Transform2D.addCache[0].toTranslation(x, y);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        Transform2D.addCache[1].toTranslation(x, y);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addScale(x, y, arg3, arg4, arg5) {
      let originX, originY, order;
      if (typeof arg3 === "number") {
        originX = arg3;
        originY = arg4;
        order = arg5;
      } else {
        order = arg3;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toScale(x, y) : Transform2D.addCache[0].toScale(x, y, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toScale(x, y) : Transform2D.addCache[1].toScale(x, y, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addRotation(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toRotation(theta) : Transform2D.addCache[0].toRotation(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toRotation(theta) : Transform2D.addCache[1].toRotation(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    addReflection(theta, arg2, arg3, arg4) {
      let originX, originY, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        order = arg4;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform2D.addCache[0].toReflection(theta) : Transform2D.addCache[0].toReflection(theta, originX, originY);
        Transform2D.addCache[1].set(this);
      } else {
        Transform2D.addCache[0].set(this);
        originX === void 0 ? Transform2D.addCache[1].toReflection(theta) : Transform2D.addCache[1].toReflection(theta, originX, originY);
      }
      return Transform2D.concat(this, Transform2D.addCache);
    }
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform2D.concatCache[0];
      const newTransform = Transform2D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 2; j++) {
            newArray[j * 3 + i] = oldArray[i] * nextArray[j * 3] + oldArray[3 + i] * nextArray[j * 3 + 1] + (i === 2 ? 1 : 0) * nextArray[j * 3 + 2];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform2D.offsetOriginCache = [new Transform2D(), void 0, new Transform2D()];
  Transform2D.addCache = [new Transform2D(), new Transform2D()];
  Transform2D.concatCache = [new Transform2D(), new Transform2D()];
  var Transform3D = class {
    constructor() {
      this.array = new Float64Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ]);
    }
    getParameters() {
      return this.array;
    }
    set(arg1, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ) {
      let scaleX = arg1;
      if (arg1 instanceof Transform3D) {
        [scaleX, skewXY, skewXZ, translateX, skewYX, scaleY, skewYZ, translateY, skewZX, skewZY, scaleZ, translateZ] = arg1.array;
      }
      const array = this.array;
      array[0] = scaleX;
      array[1] = skewXY;
      array[2] = skewXZ;
      array[3] = translateX;
      array[4] = skewYX;
      array[5] = scaleY;
      array[6] = skewYZ;
      array[7] = translateY;
      array[8] = skewZX;
      array[9] = skewZY;
      array[10] = scaleZ;
      array[11] = translateZ;
      return this;
    }
    setScaleX(value) {
      this.array[0] = value;
      return this;
    }
    setScaleY(value) {
      this.array[5] = value;
      return this;
    }
    setScaleZ(value) {
      this.array[10] = value;
      return this;
    }
    setScale(x, y, z) {
      this.array[0] = x;
      this.array[5] = y;
      this.array[10] = z;
      return this;
    }
    setSkewX(y, z) {
      this.array[1] = y;
      this.array[2] = z;
      return this;
    }
    setSkewY(x, z) {
      this.array[4] = x;
      this.array[6] = z;
      return this;
    }
    setSkewZ(x, y) {
      this.array[8] = x;
      this.array[9] = y;
      return this;
    }
    setTranslateX(value) {
      this.array[3] = value;
      return this;
    }
    setTranslateY(value) {
      this.array[7] = value;
      return this;
    }
    setTranslateZ(value) {
      this.array[11] = value;
      return this;
    }
    setTranslate(x, y, z) {
      this.array[3] = x;
      this.array[7] = y;
      this.array[11] = z;
      return this;
    }
    invert() {
      const array = this.array;
      const e_00 = array[0];
      const e_01 = array[1];
      const e_02 = array[2];
      const e_03 = array[3];
      const e_10 = array[4];
      const e_11 = array[5];
      const e_12 = array[6];
      const e_13 = array[7];
      const e_20 = array[8];
      const e_21 = array[9];
      const e_22 = array[10];
      const e_23 = array[11];
      const c_00 = e_11 * e_22 - e_12 * e_21;
      const c_01 = e_12 * e_20 - e_10 * e_22;
      const c_02 = e_10 * e_21 - e_11 * e_20;
      const c_10 = e_02 * e_21 - e_01 * e_22;
      const c_11 = e_00 * e_22 - e_02 * e_20;
      const c_12 = e_01 * e_20 - e_00 * e_21;
      const c_20 = e_01 * e_12 - e_02 * e_11;
      const c_21 = e_02 * e_10 - e_00 * e_12;
      const c_22 = e_00 * e_11 - e_01 * e_10;
      const det2 = e_00 * c_00 + e_01 * c_01 + e_02 * c_02;
      if (det2 === 0) {
        throw new Error(`Transform3D: cannot invert transformation with parameters: ${this.array}`);
      }
      const i_00 = c_00 / det2;
      const i_01 = c_10 / det2;
      const i_02 = c_20 / det2;
      const i_10 = c_01 / det2;
      const i_11 = c_11 / det2;
      const i_12 = c_21 / det2;
      const i_20 = c_02 / det2;
      const i_21 = c_12 / det2;
      const i_22 = c_22 / det2;
      const i_03 = -(i_00 * e_03 + i_01 * e_13 + i_02 * e_23);
      const i_13 = -(i_10 * e_03 + i_11 * e_13 + i_12 * e_23);
      const i_23 = -(i_20 * e_03 + i_21 * e_13 + i_22 * e_23);
      return this.set(i_00, i_01, i_02, i_03, i_10, i_11, i_12, i_13, i_20, i_21, i_22, i_23);
    }
    copy() {
      return new Transform3D().set(this);
    }
    apply(vec, out) {
      const array = this.array;
      const x = vec[0] * array[0] + vec[1] * array[1] + vec[2] * array[2] + array[3];
      const y = vec[0] * array[4] + vec[1] * array[5] + vec[2] * array[6] + array[7];
      const z = vec[0] * array[8] + vec[1] * array[9] + vec[2] * array[10] + array[11];
      return Vec3Math.set(x, y, z, out);
    }
    offsetOrigin(x, y, z) {
      Transform3D.offsetOriginCache[0].toTranslation(-x, -y, -z);
      Transform3D.offsetOriginCache[1] = this;
      Transform3D.offsetOriginCache[2].toTranslation(x, y, z);
      return Transform3D.concat(this, Transform3D.offsetOriginCache);
    }
    toIdentity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);
    }
    toTranslation(x, y, z) {
      return this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z);
    }
    toScale(x, y, z, originX, originY, originZ) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationX(theta, originX, originY, originZ) {
      const sin5 = Math.sin(theta);
      const cos5 = Math.cos(theta);
      this.set(1, 0, 0, 0, 0, cos5, -sin5, 0, 0, sin5, cos5, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationY(theta, originX, originY, originZ) {
      const sin5 = Math.sin(theta);
      const cos5 = Math.cos(theta);
      this.set(cos5, 0, sin5, 0, 0, 1, 0, 0, -sin5, 0, cos5, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotationZ(theta, originX, originY, originZ) {
      const sin5 = Math.sin(theta);
      const cos5 = Math.cos(theta);
      this.set(cos5, -sin5, 0, 0, sin5, cos5, 0, 0, 0, 0, 1, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ) {
      const abs3 = Math.hypot(axisX, axisY, axisZ);
      const ux = axisX / abs3;
      const uy = axisY / abs3;
      const uz = axisZ / abs3;
      const ux_uy = ux * uy;
      const ux_uz = ux * uz;
      const uy_uz = uy * uz;
      const sin5 = Math.sin(theta);
      const cos5 = Math.cos(theta);
      const cosCompl = 1 - cos5;
      this.set(cos5 + ux * ux * cosCompl, ux_uy * cosCompl - uz * sin5, ux_uz * cosCompl * uy * sin5, 0, ux_uy * cosCompl + uz * sin5, cos5 + uy * uy * cosCompl, uy_uz * cosCompl - ux * sin5, 0, ux_uz * cosCompl - uy * sin5, uy_uz * cosCompl + ux * sin5, cos5 + uz * uz * cosCompl, 0);
      if (originX !== void 0 && originY !== void 0 && originZ !== void 0) {
        this.offsetOrigin(originX, originY, originZ);
      }
      return this;
    }
    addTranslation(x, y, z, order = "after") {
      if (order === "before") {
        Transform3D.addCache[0].toTranslation(x, y, z);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        Transform3D.addCache[1].toTranslation(x, y, z);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addScale(x, y, z, arg4, arg5, arg6, arg7) {
      let originX, originY, originZ, order;
      if (typeof arg4 === "number") {
        originX = arg4;
        originY = arg5;
        originZ = arg6;
        order = arg7;
      } else {
        order = arg4;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toScale(x, y, z) : Transform3D.addCache[0].toScale(x, y, z, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toScale(x, y, z) : Transform3D.addCache[1].toScale(x, y, z, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationX(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationX(theta) : Transform3D.addCache[0].toRotationX(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationX(theta) : Transform3D.addCache[1].toRotationX(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationY(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationY(theta) : Transform3D.addCache[0].toRotationY(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationY(theta) : Transform3D.addCache[1].toRotationY(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotationZ(theta, arg2, arg3, arg4, arg5) {
      let originX, originY, originZ, order;
      if (typeof arg2 === "number") {
        originX = arg2;
        originY = arg3;
        originZ = arg4;
        order = arg5;
      } else {
        order = arg2;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotationZ(theta) : Transform3D.addCache[0].toRotationZ(theta, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotationZ(theta) : Transform3D.addCache[1].toRotationZ(theta, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    addRotation(theta, axisX, axisY, axisZ, arg5, arg6, arg7, arg8) {
      let originX, originY, originZ, order;
      if (typeof arg5 === "number") {
        originX = arg5;
        originY = arg6;
        originZ = arg7;
        order = arg8;
      } else {
        order = arg5;
      }
      if (order === "before") {
        originX === void 0 ? Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[0].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
        Transform3D.addCache[1].set(this);
      } else {
        Transform3D.addCache[0].set(this);
        originX === void 0 ? Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ) : Transform3D.addCache[1].toRotation(theta, axisX, axisY, axisZ, originX, originY, originZ);
      }
      return Transform3D.concat(this, Transform3D.addCache);
    }
    static concat(out, transforms) {
      if (transforms.length === 0) {
        return out.toIdentity();
      }
      if (transforms.length === 1) {
        return out.set(transforms[0]);
      }
      let index = 0;
      let next = transforms[index];
      const oldTransform = Transform3D.concatCache[0];
      const newTransform = Transform3D.concatCache[1].set(next);
      const oldArray = oldTransform.array;
      const newArray = newTransform.array;
      const end = transforms.length;
      while (++index < end) {
        next = transforms[index];
        const nextArray = next.array;
        oldTransform.set(newTransform);
        for (let i = 0; i < 4; i++) {
          for (let j = 0; j < 3; j++) {
            newArray[j * 4 + i] = oldArray[i] * nextArray[j * 4] + oldArray[4 + i] * nextArray[j * 4 + 1] + oldArray[8 + i] * nextArray[j * 4 + 2] + (i === 3 ? 1 : 0) * nextArray[j * 4 + 3];
          }
        }
      }
      return out.set(newTransform);
    }
  };
  Transform3D.offsetOriginCache = [new Transform3D(), void 0, new Transform3D()];
  Transform3D.addCache = [new Transform3D(), new Transform3D()];
  Transform3D.concatCache = [new Transform3D(), new Transform3D()];
  var TransformPerspective = class {
    constructor() {
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create(0, 0, 1);
      this.cameraPosTransform = new Transform3D();
      this.cameraRotationTransform = new Transform3D();
      this.cameraRotationInverseTransform = new Transform3D();
      this.allCameraTransforms = [this.cameraPosTransform, this.cameraRotationInverseTransform];
      this.fullTransform = new Transform3D();
    }
    getCameraPosition() {
      return this.cameraPos;
    }
    getCameraRotation() {
      return this.cameraRotationTransform;
    }
    getSurfacePosition() {
      return this.cameraPos;
    }
    set(arg1, arg2, arg3) {
      if (arg1 instanceof Float64Array) {
        this._setCameraPosition(arg1);
        this._setCameraRotation(arg2);
        this.setSurfacePosition(arg3);
        Transform3D.concat(this.fullTransform, this.allCameraTransforms);
        return this;
      } else {
        return this.set(arg1.getCameraPosition(), arg1.getCameraRotation(), arg1.getSurfacePosition());
      }
    }
    _setCameraPosition(cameraPos) {
      Vec3Math.copy(cameraPos, this.cameraPos);
      this.cameraPosTransform.toTranslation(-cameraPos[0], -cameraPos[1], -cameraPos[2]);
    }
    _setCameraRotation(cameraRotation) {
      this.cameraRotationTransform.set(cameraRotation);
      this.cameraRotationInverseTransform.set(cameraRotation).invert();
    }
    setCameraPosition(cameraPos) {
      this._setCameraPosition(cameraPos);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    setCameraRotation(cameraRotation) {
      this._setCameraRotation(cameraRotation);
      Transform3D.concat(this.fullTransform, this.allCameraTransforms);
      return this;
    }
    setSurfacePosition(surfacePos) {
      Vec3Math.copy(surfacePos, this.surfacePos);
      return this;
    }
    copy() {
      return new TransformPerspective().set(this);
    }
    apply(vec, out) {
      const transformedVec = this.fullTransform.apply(vec, TransformPerspective.vec3Cache[0]);
      if (Vec3Math.abs(transformedVec) < 1e-7) {
        return Vec2Math.set(0, 0, out);
      }
      if (transformedVec[2] < 0) {
        return Vec2Math.set(NaN, NaN, out);
      }
      const ratio = this.surfacePos[2] / transformedVec[2];
      return Vec2Math.set(transformedVec[0] * ratio + this.surfacePos[0], transformedVec[1] * ratio + this.surfacePos[1], out);
    }
  };
  TransformPerspective.vec3Cache = [Vec3Math.create()];
  var MathUtils2 = class {
    static clamp(value, min2, max2) {
      return Math.max(min2, Math.min(max2, value));
    }
    static round(value, precision = 1) {
      return Math.round(value / precision) * precision;
    }
    static diffAngle(start, end, directional = true) {
      const diff = ((end - start) % MathUtils2.TWO_PI + MathUtils2.TWO_PI) % MathUtils2.TWO_PI;
      return directional ? diff : Math.min(diff, MathUtils2.TWO_PI - diff);
    }
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      if (x0 !== x1 && y0 !== y1) {
        const fraction2 = MathUtils2.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
        return fraction2 * (y1 - y0) + y0;
      } else {
        return y0;
      }
    }
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
      const length = Math.min(y0.length, y1.length, out.length);
      for (let i = 0; i < length; i++) {
        out[i] = MathUtils2.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
      }
      return out;
    }
  };
  MathUtils2.TWO_PI = Math.PI * 2;
  MathUtils2.HALF_PI = Math.PI / 2;
  var ExpSmoother = class {
    constructor(tau, initial = null, dtThreshold = Infinity) {
      this.tau = tau;
      this.dtThreshold = dtThreshold;
      this.lastValue = initial;
    }
    last() {
      return this.lastValue;
    }
    next(raw, dt) {
      let next;
      if (this.tau > 0 && this.lastValue !== null) {
        const factor = this.calculateFactor(dt);
        next = ExpSmoother.smooth(raw, this.lastValue, factor);
      } else {
        next = raw;
      }
      this.lastValue = next;
      return next;
    }
    calculateFactor(dt) {
      if (dt > this.dtThreshold) {
        return 0;
      } else {
        return Math.exp(-dt / this.tau);
      }
    }
    reset(value) {
      return this.lastValue = value !== null && value !== void 0 ? value : null;
    }
    static smooth(value, last, factor) {
      return value * (1 - factor) + last * factor;
    }
  };
  var GeoPointReadOnly = class {
    constructor(source) {
      this.source = source;
    }
    get lat() {
      return this.source.lat;
    }
    get lon() {
      return this.source.lon;
    }
    distance(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distance(arg1, arg2);
      } else {
        return this.source.distance(arg1);
      }
    }
    distanceRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.distanceRhumb(arg1, arg2);
      } else {
        return this.source.distanceRhumb(arg1);
      }
    }
    bearingTo(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingTo(arg1, arg2);
      } else {
        return this.source.bearingTo(arg1);
      }
    }
    bearingFrom(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingFrom(arg1, arg2);
      } else {
        return this.source.bearingFrom(arg1);
      }
    }
    bearingRhumb(arg1, arg2) {
      if (typeof arg1 === "number") {
        return this.source.bearingRhumb(arg1, arg2);
      } else {
        return this.source.bearingRhumb(arg1);
      }
    }
    offset(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offset(bearing, distance, out);
    }
    offsetRhumb(bearing, distance, out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.offsetRhumb(bearing, distance, out);
    }
    antipode(out) {
      if (!out) {
        throw new Error("Cannot mutate a read-only GeoPoint.");
      }
      return this.source.antipode(out);
    }
    toCartesian(out) {
      return this.source.toCartesian(out);
    }
    equals(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return this.source.equals(arg1, arg2, arg3);
      } else {
        return this.source.equals(arg1, arg2);
      }
    }
    copy(to) {
      return this.source.copy(to);
    }
  };
  var GeoPoint = class {
    constructor(lat, lon) {
      this._lat = 0;
      this._lon = 0;
      this.set(lat, lon);
      this.readonly = new GeoPointReadOnly(this);
    }
    get lat() {
      return this._lat;
    }
    get lon() {
      return this._lon;
    }
    static asLatLonInterface(arg1, arg2) {
      if (typeof arg1 === "number") {
        return GeoPoint.tempGeoPoint.set(arg1, arg2);
      } else {
        return arg1;
      }
    }
    static asVec3(arg1, arg2, arg3) {
      if (typeof arg1 === "number") {
        return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
      } else {
        return arg1;
      }
    }
    set(arg1, arg2) {
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      lat = GeoPoint.toPlusMinus180(lat);
      lon = GeoPoint.toPlusMinus180(lon);
      if (Math.abs(lat) > 90) {
        lat = 180 - lat;
        lat = GeoPoint.toPlusMinus180(lat);
        lon += 180;
        lon = GeoPoint.toPlusMinus180(lon);
      }
      this._lat = lat;
      this._lon = lon;
      return this;
    }
    setFromCartesian(arg1, arg2, arg3) {
      const vec = GeoPoint.asVec3(arg1, arg2, arg3);
      const theta = Vec3Math.theta(vec);
      const phi = Vec3Math.phi(vec);
      return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    distance(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    distanceRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    bearingTo(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    bearingFrom(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    bearingRhumb(arg1, arg2) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    offset(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(latRad);
      const cosLat = Math.cos(latRad);
      const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
      const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
      const angularDistance = distance;
      const sinAngularDistance = Math.sin(angularDistance);
      const cosAngularDistance = Math.cos(angularDistance);
      const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
      const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
      const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
      const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    offsetRhumb(bearing, distance, out) {
      const latRad = this.lat * Avionics.Utils.DEG2RAD;
      const lonRad = this.lon * Avionics.Utils.DEG2RAD;
      const bearingRad = bearing * Avionics.Utils.DEG2RAD;
      const deltaLat = distance * Math.cos(bearingRad);
      let offsetLat = latRad + deltaLat;
      let offsetLon;
      if (Math.abs(offsetLat) >= Math.PI / 2) {
        offsetLat = Math.sign(offsetLat) * 90;
        offsetLon = 0;
      } else {
        const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
        const deltaLon = distance * Math.sin(bearingRad) / correction;
        offsetLon = lonRad + deltaLon;
        offsetLat *= Avionics.Utils.RAD2DEG;
        offsetLon *= Avionics.Utils.RAD2DEG;
      }
      return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    antipode(out) {
      return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    toCartesian(out) {
      return GeoPoint.sphericalToCartesian(this, out);
    }
    equals(arg1, arg2, arg3) {
      const other = GeoPoint.asLatLonInterface(arg1, arg2);
      if (other) {
        if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
          return true;
        }
        const tolerance = typeof arg1 === "number" ? arg3 : arg2;
        const distance = this.distance(other);
        return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return false;
      }
    }
    copy(to) {
      return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    static sphericalToCartesian(arg1, arg2, arg3) {
      const point = GeoPoint.asLatLonInterface(arg1, arg2);
      const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
      const phi = point.lon * Avionics.Utils.DEG2RAD;
      return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    static equals(arg1, arg2, arg3, arg4, arg5) {
      if (arg1 instanceof Float64Array) {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      } else if (typeof arg1 === "number") {
        return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
      } else {
        return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
      }
    }
    static distance(arg1, arg2, arg3, arg4) {
      if (arg1 instanceof Float64Array) {
        return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
      } else {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === "number") {
          lat1 = arg1;
          lon1 = arg2;
          lat2 = arg3;
          lon2 = arg4;
        } else {
          lat1 = arg1.lat;
          lon1 = arg1.lon;
          lat2 = arg2.lat;
          lon2 = arg2.lon;
        }
        lat1 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
        const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
        const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
    }
    static distanceRhumb(arg1, arg2, arg3, arg4) {
      let lat1, lon1, lat2, lon2;
      if (typeof arg1 === "number") {
        lat1 = arg1 * Avionics.Utils.DEG2RAD;
        lon1 = arg2 * Avionics.Utils.DEG2RAD;
        lat2 = arg3 * Avionics.Utils.DEG2RAD;
        lon2 = arg4 * Avionics.Utils.DEG2RAD;
      } else if (arg1 instanceof Float64Array) {
        const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
        lat1 = point1.lat;
        lon1 = point1.lon;
        const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
        lat2 = point2.lat;
        lon2 = point2.lon;
      } else {
        lat1 = arg1.lat;
        lon1 = arg1.lon;
        lat2 = arg2.lat;
        lon2 = arg2.lon;
      }
      const deltaLat = lat2 - lat1;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    static initialBearing(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      const cosLat2 = Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
      const y = Math.sin(lon2 - lon1) * cosLat2;
      const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
      return (bearing + 360) % 360;
    }
    static finalBearing(lat1, lon1, lat2, lon2) {
      return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    static bearingRhumb(lat1, lon1, lat2, lon2) {
      lat1 *= Avionics.Utils.DEG2RAD;
      lat2 *= Avionics.Utils.DEG2RAD;
      lon1 *= Avionics.Utils.DEG2RAD;
      lon2 *= Avionics.Utils.DEG2RAD;
      let deltaLon = lon2 - lon1;
      const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
      if (Math.abs(deltaLon) > Math.PI) {
        deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
      }
      return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    static toPlusMinus180(angle) {
      return (angle % 360 + 540) % 360 - 180;
    }
    static deltaPsi(latRad1, latRad2) {
      return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
      return Math.abs(deltaPsi) > 1e-12 ? (latRad2 - latRad1) / deltaPsi : Math.cos(latRad1);
    }
  };
  GeoPoint.EQUALITY_TOLERANCE = 1e-7;
  GeoPoint.tempVec3 = new Float64Array(3);
  GeoPoint.tempGeoPoint = new GeoPoint(0, 0);
  var GeoCircle = class {
    constructor(center, radius) {
      this._center = new Float64Array(3);
      this._radius = 0;
      this._sinRadius = 0;
      this.set(center, radius);
    }
    get center() {
      return this._center;
    }
    get radius() {
      return this._radius;
    }
    isGreatCircle() {
      return this._radius === Math.PI / 2;
    }
    arcLength(angle) {
      return this._sinRadius * angle;
    }
    angularWidth(length) {
      return length / this._sinRadius;
    }
    set(center, radius) {
      if (center instanceof Float64Array) {
        if (Vec3Math.abs(center) === 0) {
          Vec3Math.set(1, 0, 0, this._center);
        } else {
          Vec3Math.normalize(center, this._center);
        }
      } else {
        GeoPoint.sphericalToCartesian(center, this._center);
      }
      this._radius = Math.abs(radius) % Math.PI;
      this._sinRadius = Math.sin(this._radius);
      return this;
    }
    setAsGreatCircle(arg1, arg2) {
      this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
      return this;
    }
    reverse() {
      Vec3Math.multScalar(this._center, -1, this._center);
      this._radius = Math.PI - this._radius;
      return this;
    }
    distanceToCenter(point) {
      if (point instanceof Float64Array) {
        point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
      } else {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const dot2 = Vec3Math.dot(point, this._center);
      return Math.acos(Utils.Clamp(dot2, -1, 1));
    }
    closest(point, out) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
      }
      const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
      const dot2 = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
      const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot2, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
        return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
      }
      const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
      const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
      return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    distance(point) {
      const distanceToCenter = this.distanceToCenter(point);
      return distanceToCenter - this._radius;
    }
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return Math.abs(distance) < tolerance;
    }
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const distance = this.distance(point);
      return inclusive ? distance <= tolerance : distance < -tolerance;
    }
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
      }
      if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
        throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
      const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
      const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
      const angle = isArcGreaterThanSemi ? MathUtils2.TWO_PI - angularDistance : angularDistance;
      return angle >= MathUtils2.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
      return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
      const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
      return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angle = distance / Math.sin(this.radius);
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      if (!(point instanceof Float64Array)) {
        point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
      }
      if (!this.includes(point, tolerance)) {
        throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
      }
      if (this.radius === 0) {
        return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
      }
      point = this.closest(point, GeoCircle.vec3Cache[3]);
      const sin5 = Math.sin(angle / 2);
      const q0 = Math.cos(angle / 2);
      const q1 = sin5 * this._center[0];
      const q2 = sin5 * this._center[1];
      const q3 = sin5 * this._center[2];
      const q0Sq = q0 * q0;
      const q1Sq = q1 * q1;
      const q2Sq = q2 * q2;
      const q3Sq = q3 * q3;
      const q01 = q0 * q1;
      const q02 = q0 * q2;
      const q03 = q0 * q3;
      const q12 = q1 * q2;
      const q13 = q1 * q3;
      const q23 = q2 * q3;
      const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
      const rot_12 = 2 * (q12 - q03);
      const rot_13 = 2 * (q13 + q02);
      const rot_21 = 2 * (q12 + q03);
      const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
      const rot_23 = 2 * (q23 - q01);
      const rot_31 = 2 * (q13 - q02);
      const rot_32 = 2 * (q23 + q01);
      const rot_33 = q0Sq - q1Sq - q2Sq + q3Sq;
      const x = point[0];
      const y = point[1];
      const z = point[2];
      const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
      const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
      const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
      return out instanceof Float64Array ? Vec3Math.set(rotX, rotY, rotZ, out) : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    intersection(other, out) {
      const center1 = this._center;
      const center2 = other._center;
      const radius1 = this._radius;
      const radius2 = other._radius;
      const dot2 = Vec3Math.dot(center1, center2);
      const dotSquared = dot2 * dot2;
      if (dotSquared === 1) {
        return 0;
      }
      const a = (Math.cos(radius1) - dot2 * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot2 * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross2 = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross2, cross2);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
      let solutionCount = 1;
      if (!out[0]) {
        out[0] = new Float64Array(3);
      }
      out[0].set(cross2);
      Vec3Math.multScalar(out[0], offset, out[0]);
      Vec3Math.add(out[0], intersection, out[0]);
      if (offset > 0) {
        if (!out[1]) {
          out[1] = new Float64Array(3);
        }
        out[1].set(cross2);
        Vec3Math.multScalar(out[1], -offset, out[1]);
        Vec3Math.add(out[1], intersection, out[1]);
        solutionCount++;
      }
      return solutionCount;
    }
    intersectionGeoPoint(other, out) {
      const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
      for (let i = 0; i < solutionCount; i++) {
        if (!out[i]) {
          out[i] = new GeoPoint(0, 0);
        }
        out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
      }
      return solutionCount;
    }
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const center1 = this.center;
      const center2 = other.center;
      const radius1 = this.radius;
      const radius2 = other.radius;
      const dot2 = Vec3Math.dot(center1, center2);
      const dotSquared = dot2 * dot2;
      if (dotSquared === 1) {
        if (dot2 === 1) {
          return Math.abs(this.radius - other.radius) <= tolerance ? NaN : 0;
        } else {
          return Math.abs(Math.PI - this.radius - other.radius) <= tolerance ? NaN : 0;
        }
      }
      const a = (Math.cos(radius1) - dot2 * Math.cos(radius2)) / (1 - dotSquared);
      const b = (Math.cos(radius2) - dot2 * Math.cos(radius1)) / (1 - dotSquared);
      const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
      const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
      if (intersectionLengthSquared > 1) {
        return 0;
      }
      const cross2 = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
      const crossLengthSquared = Vec3Math.dot(cross2, cross2);
      if (crossLengthSquared === 0) {
        return 0;
      }
      const sinTol = Math.sin(tolerance);
      return (1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol ? 2 : 1;
    }
    static createFromPoint(point, radius) {
      return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
      return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    static createGreatCircleFromPointBearing(point, bearing) {
      return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    static getGreatCircleNormal(arg1, arg2, out) {
      return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    static _getGreatCircleNormal(arg1, arg2, out) {
      if (typeof arg2 === "number") {
        return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
      } else {
        return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
      }
    }
    static getGreatCircleNormalFromPoints(point1, point2, out) {
      if (!(point1 instanceof Float64Array)) {
        point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
      }
      return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
      if (point instanceof Float64Array) {
        point = GeoCircle.tempGeoPoint.setFromCartesian(point);
      }
      const lat = point.lat * Avionics.Utils.DEG2RAD;
      const long = point.lon * Avionics.Utils.DEG2RAD;
      bearing *= Avionics.Utils.DEG2RAD;
      const sinLat = Math.sin(lat);
      const sinLon = Math.sin(long);
      const cosLon = Math.cos(long);
      const sinBearing = Math.sin(bearing);
      const cosBearing = Math.cos(bearing);
      const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
      const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
      const z = Math.cos(lat) * sinBearing;
      return Vec3Math.set(x, y, z, out);
    }
  };
  GeoCircle.ANGULAR_TOLERANCE = 1e-7;
  GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
  GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
  GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var NavMath = class {
    static clamp(val, min2, max2) {
      return Math.min(Math.max(val, min2), max2);
    }
    static normalizeHeading(heading) {
      if (isFinite(heading)) {
        return (heading % 360 + 360) % 360;
      } else {
        console.error(`normalizeHeading: Invalid heading: ${heading}`);
        return NaN;
      }
    }
    static reciprocateHeading(heading) {
      return NavMath.normalizeHeading(heading + 180);
    }
    static turnRadius(airspeedTrue, bankAngle) {
      return Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)) / 3.2808399;
    }
    static bankAngle(airspeedTrue, radius) {
      const airspeedMS = airspeedTrue * 0.51444444;
      return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    static getTurnDirection(startCourse, endCourse) {
      return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? "left" : "right";
    }
    static polarToDegreesNorth(radians) {
      return NavMath.normalizeHeading(180 / Math.PI * (Math.PI / 2 - radians));
    }
    static degreesNorthToPolar(degrees) {
      return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    static calculateArcDistance(startBearing, endBearing, radius) {
      const angularWidth = (endBearing - startBearing + 360) % 360 * Avionics.Utils.DEG2RAD;
      const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
      return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const a = dx * dx + dy * dy;
      const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
      const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
      const det2 = b * b - 4 * a * c;
      if (a < 1e-7 || det2 < 0) {
        sRef.x1 = NaN;
        sRef.x2 = NaN;
        sRef.y1 = NaN;
        sRef.y2 = NaN;
        return 0;
      } else if (det2 == 0) {
        const t = -b / (2 * a);
        sRef.x1 = x1 + t * dx;
        sRef.y1 = y1 + t * dy;
        sRef.x2 = NaN;
        sRef.y2 = NaN;
        return 1;
      } else {
        const t1 = (-b + Math.sqrt(det2)) / (2 * a);
        sRef.x1 = x1 + t1 * dx;
        sRef.y1 = y1 + t1 * dy;
        const t2 = (-b - Math.sqrt(det2)) / (2 * a);
        sRef.x2 = x1 + t2 * dx;
        sRef.y2 = y1 + t2 * dy;
        return 2;
      }
    }
    static northAngle(cx, cy, x, y) {
      return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    static bearingIsBetween(bearing, start, end) {
      const range2 = this.normalizeHeading(end - start);
      const relativeBearing = this.normalizeHeading(bearing - start);
      return relativeBearing >= 0 && relativeBearing <= range2;
    }
    static headingToAngle(heading, turnDirection) {
      return NavMath.normalizeHeading(heading + (turnDirection === "left" ? 90 : -90));
    }
    static angleToHeading(angle, turnDirection) {
      return NavMath.normalizeHeading(angle + (turnDirection === "left" ? -90 : 90));
    }
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
      const currCrosswind = windSpeed * Math.sin(course * Math.PI / 180 - windDirection * Math.PI / 180);
      const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
      return windCorrection;
    }
    static crossTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    static alongTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
      return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    static desiredTrack(start, end, pos) {
      const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
      if (isNaN(path.center[0])) {
        return NaN;
      }
      return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    static desiredTrackArc(center, turnDirection, pos) {
      const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
      return NavMath.angleToHeading(northAngle, turnDirection);
    }
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
      const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
      const sign4 = turnDirection === "right" ? 1 : -1;
      const alpha = ((end - start) * sign4 + 360) % 360;
      const mid = (start + alpha / 2 * sign4 + 360) % 360;
      const rotBearing = (bearingFromCenter - mid + 540) % 360 - 180;
      const frac = rotBearing * sign4 / alpha + 0.5;
      return frac;
    }
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
      const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
      const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
      const bearing = turnDirection === "right" ? start + theta : start - theta;
      center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
      return out;
    }
    static crossTrackArc(center, radius, pos) {
      return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    static diffAngle(a, b) {
      let diff = b - a;
      while (diff > 180) {
        diff -= 360;
      }
      while (diff <= -180) {
        diff += 360;
      }
      return diff;
    }
    static napierSide(b, c, beta, gamma) {
      return 2 * Math.atan(Math.tan(0.5 * (b - c)) * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    static normal(course, turnDirection, outVector) {
      const normalCourse = NavMath.headingToAngle(course, turnDirection);
      const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
      outVector[0] = Math.cos(polarCourse);
      outVector[1] = Math.sin(polarCourse);
    }
  };
  NavMath.vec3Cache = [new Float64Array(3)];
  NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MagVar = class {
    static get(arg1, arg2) {
      return MagVar.getMagVar(arg1, arg2);
    }
    static magneticToTrue(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing + (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    static trueToMagnetic(bearing, arg1, arg2) {
      return NavMath.normalizeHeading(bearing - (typeof arg1 === "number" && arg2 === void 0 ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    static getMagVar(arg1, arg2) {
      if (typeof Facilities === "undefined") {
        return 0;
      }
      let lat, lon;
      if (typeof arg1 === "number") {
        lat = arg1;
        lon = arg2;
      } else {
        lat = arg1.lat;
        lon = arg1.lon;
      }
      return Facilities.getMagVar(lat, lon);
    }
  };
  var GeoPointSubject = class extends AbstractSubscribable {
    constructor(value, tolerance) {
      super();
      this.value = value;
      this.tolerance = tolerance;
      this.isMutableSubscribable = true;
    }
    static create(initialVal, tolerance) {
      return new GeoPointSubject(initialVal, tolerance);
    }
    static createFromGeoPoint(initialVal) {
      return new GeoPointSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2) {
      const isArg1Number = typeof arg1 === "number";
      const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
      if (!equals) {
        isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
        this.notify();
      }
    }
  };
  var AbstractGeoProjection = class {
    constructor() {
      this.center = new GeoPoint(0, 0);
      this.centerTranslation = new Float64Array(2);
      this.scaleFactor = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
      this.preRotation = new Float64Array(3);
      this.translation = new Float64Array(2);
      this.postRotation = 0;
      this.rotationSin = 0;
      this.rotationCos = 1;
      this.reflectY = 1;
      this.preRotationForwardTransform = new Transform3D();
      this.preRotationReverseTransform = new Transform3D();
      this.rotationCache = [new Transform3D(), new Transform3D()];
    }
    getCenter() {
      return this.center.readonly;
    }
    getScaleFactor() {
      return this.scaleFactor;
    }
    getPreRotation() {
      return this.preRotation;
    }
    getTranslation() {
      return this.translation;
    }
    getPostRotation() {
      return this.postRotation;
    }
    getReflectY() {
      return this.reflectY === -1;
    }
    setCenter(point) {
      this.center.set(point);
      this.updateCenterTranslation();
      return this;
    }
    setScaleFactor(factor) {
      this.scaleFactor = factor;
      return this;
    }
    setPreRotation(vec) {
      this.preRotation.set(vec);
      this.updatePreRotationTransforms();
      this.updateCenterTranslation();
      return this;
    }
    setTranslation(vec) {
      this.translation.set(vec);
      return this;
    }
    setPostRotation(rotation) {
      this.postRotation = rotation;
      this.rotationCos = Math.cos(rotation);
      this.rotationSin = Math.sin(rotation);
      return this;
    }
    setReflectY(val) {
      this.reflectY = val ? -1 : 1;
      return this;
    }
    copyParametersFrom(other) {
      return this.setCenter(other.getCenter()).setPreRotation(other.getPreRotation()).setScaleFactor(other.getScaleFactor()).setTranslation(other.getTranslation()).setPostRotation(other.getPostRotation()).setReflectY(other.getReflectY());
    }
    updatePreRotationTransforms() {
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      this.rotationCache[0].toRotationX(gamma);
      this.rotationCache[1].toRotationY(-phi);
      Transform3D.concat(this.preRotationForwardTransform, this.rotationCache);
      this.preRotationReverseTransform.set(this.preRotationForwardTransform);
      this.preRotationReverseTransform.invert();
    }
    updateCenterTranslation() {
      const centerArray = AbstractGeoProjection.vec2Cache[0];
      centerArray[0] = this.center.lon;
      centerArray[1] = this.center.lat;
      this.preRotateForward(centerArray, centerArray);
      this.projectRaw(centerArray, this.centerTranslation);
    }
    preRotateForward(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      const rotatedLon = ((lon + lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      if (phi === 0 && gamma === 0) {
        return Vec2Math.set(rotatedLon, lat, out);
      }
      const cartesianVec = GeoPoint.sphericalToCartesian(lat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
      const rotatedCartesianVec = this.preRotationForwardTransform.apply(cartesianVec, cartesianVec);
      const rotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(rotatedCartesianVec);
      return Vec2Math.set(rotated.lon, rotated.lat, out);
    }
    preRotateReverse(vec, out) {
      const lambda = this.preRotation[0];
      const phi = this.preRotation[1];
      const gamma = this.preRotation[2];
      if (lambda === 0 && phi === 0 && gamma === 0) {
        out.set(vec);
        return out;
      }
      const lat = vec[1];
      const lon = vec[0];
      let rotatedLat = lat;
      let rotatedLon = lon;
      if (phi !== 0 || gamma !== 0) {
        const rotatedCartesianVec = GeoPoint.sphericalToCartesian(rotatedLat, rotatedLon, AbstractGeoProjection.vec3Cache[0]);
        const cartesianVec = this.preRotationReverseTransform.apply(rotatedCartesianVec, rotatedCartesianVec);
        const unrotated = AbstractGeoProjection.geoPointCache[0].setFromCartesian(cartesianVec);
        rotatedLat = unrotated.lat;
        rotatedLon = unrotated.lon;
      }
      rotatedLon = ((rotatedLon - lambda * Avionics.Utils.RAD2DEG) % 360 + 540) % 360 - 180;
      return Vec2Math.set(rotatedLon, rotatedLat, out);
    }
    project(point, out) {
      if (point instanceof Float64Array) {
        out.set(point);
      } else {
        out[0] = point.lon;
        out[1] = point.lat;
      }
      this.preRotateForward(out, out);
      this.projectRaw(out, out);
      out[0] -= this.centerTranslation[0];
      out[1] -= this.centerTranslation[1];
      out[1] *= this.reflectY;
      out[0] *= this.scaleFactor;
      out[1] *= this.scaleFactor;
      const x = out[0];
      const y = out[1];
      out[0] = x * this.rotationCos - y * this.rotationSin;
      out[1] = x * this.rotationSin + y * this.rotationCos;
      out[0] += this.translation[0];
      out[1] += this.translation[1];
      return out;
    }
    invert(vec, out) {
      const projected = AbstractGeoProjection.vec2Cache[0];
      projected.set(vec);
      projected[0] -= this.translation[0];
      projected[1] -= this.translation[1];
      const x = projected[0];
      const y = projected[1];
      projected[0] = x * this.rotationCos + y * this.rotationSin;
      projected[1] = -x * this.rotationSin + y * this.rotationCos;
      projected[0] /= this.scaleFactor;
      projected[1] /= this.scaleFactor;
      projected[1] *= this.reflectY;
      projected[0] += this.centerTranslation[0];
      projected[1] += this.centerTranslation[1];
      const inverted = this.invertRaw(projected, projected);
      this.preRotateReverse(inverted, inverted);
      if (out instanceof Float64Array) {
        out.set(inverted);
        return out;
      } else {
        return out.set(inverted[1], inverted[0]);
      }
    }
  };
  AbstractGeoProjection.vec2Cache = [new Float64Array(2)];
  AbstractGeoProjection.vec3Cache = [new Float64Array(3)];
  AbstractGeoProjection.geoPointCache = [new GeoPoint(0, 0)];
  var MercatorProjection = class extends AbstractGeoProjection {
    projectRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.DEG2RAD;
      out[1] = Math.log(Math.tan((90 + vec[1]) * Avionics.Utils.DEG2RAD / 2));
      return out;
    }
    invertRaw(vec, out) {
      out[0] = vec[0] * Avionics.Utils.RAD2DEG;
      out[1] = 2 * Math.atan(Math.exp(vec[1])) * Avionics.Utils.RAD2DEG - 90;
      return out;
    }
  };
  var GeoCircleResampler = class {
    constructor(minDistance, dpTolerance, maxDepth) {
      this.minDistance = minDistance;
      this.dpTolerance = dpTolerance;
      this.maxDepth = maxDepth;
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.startVector = {
        type: "start",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.lineVector = {
        type: "line",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        index: 0
      };
      this.arcVector = {
        type: "arc",
        point: new GeoPoint(0, 0),
        projected: new Float64Array(2),
        projectedArcCenter: new Float64Array(2),
        projectedArcRadius: 0,
        projectedArcStartAngle: 0,
        projectedArcEndAngle: 0,
        index: 0
      };
      this.state = {
        index: 0,
        prevX: 0,
        prevY: 0,
        vectorType: "line",
        arcCenterX: 0,
        arcCenterY: 0,
        arcRadius: 0,
        isArcCounterClockwise: false
      };
      this.cosMinDistance = Math.cos(minDistance);
      this.dpTolSq = dpTolerance * dpTolerance;
    }
    resample(projection, circle, start, end, handler) {
      let startPoint, startVec, endPoint, endVec;
      if (start instanceof Float64Array) {
        startPoint = this.geoPointCache[0].setFromCartesian(start);
        startVec = start;
      } else {
        startPoint = start;
        startVec = GeoPoint.sphericalToCartesian(start, this.vec3Cache[0]);
      }
      if (end instanceof Float64Array) {
        endPoint = this.geoPointCache[0].setFromCartesian(end);
        endVec = end;
      } else {
        endPoint = end;
        endVec = GeoPoint.sphericalToCartesian(end, this.vec3Cache[1]);
      }
      const startLat = startPoint.lat;
      const startLon = startPoint.lon;
      const endLat = endPoint.lat;
      const endLon = endPoint.lon;
      const startProjected = projection.project(start, this.vec2Cache[0]);
      const endProjected = projection.project(end, this.vec2Cache[1]);
      const startX = startProjected[0];
      const startY = startProjected[1];
      const endX = endProjected[0];
      const endY = endProjected[1];
      this.startVector.point.set(startLat, startLon);
      Vec2Math.copy(startProjected, this.startVector.projected);
      handler(this.startVector);
      this.state.index = 1;
      this.state.prevX = startX;
      this.state.prevY = startY;
      this.state.vectorType = "line";
      const state = this.resampleHelper(projection, circle, startLat, startLon, startVec[0], startVec[1], startVec[2], startX, startY, endLat, endLon, endVec[0], endVec[1], endVec[2], endX, endY, handler, 0, this.state);
      this.callHandler(handler, endLat, endLon, endX, endY, state);
    }
    resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth, state) {
      if (depth >= this.maxDepth) {
        return state;
      }
      const startVec = Vec3Math.set(x1, y1, z1, this.vec3Cache[0]);
      const endVec = Vec3Math.set(x2, y2, z2, this.vec3Cache[1]);
      const angularWidth = circle.angleAlong(startVec, endVec, Math.PI);
      if (angularWidth <= GeoCircle.ANGULAR_TOLERANCE) {
        return state;
      }
      const midVec = circle.offsetAngleAlong(startVec, angularWidth / 2, this.vec3Cache[2]);
      const startProjected = Vec2Math.set(projX1, projY1, this.vec2Cache[0]);
      const endProjected = Vec2Math.set(projX2, projY2, this.vec2Cache[1]);
      const deltaProjected = Vec2Math.sub(endProjected, startProjected, this.vec2Cache[2]);
      const deltaProjectedDot = Vec2Math.dot(deltaProjected, deltaProjected);
      const midPoint = this.geoPointCache[0].setFromCartesian(midVec);
      const midProjected = projection.project(midPoint, this.vec2Cache[2]);
      const lat0 = midPoint.lat;
      const lon0 = midPoint.lon;
      const x0 = midVec[0];
      const y0 = midVec[1];
      const z0 = midVec[2];
      const projX0 = midProjected[0];
      const projY0 = midProjected[1];
      const A = projX2 - projX1;
      const B = projY2 - projY1;
      const C = projX1 * projX1 - projX2 * projX2 + projY1 * projY1 - projY2 * projY2;
      const D = projX0 - projX1;
      const E = projY0 - projY1;
      const F = projX1 * projX1 - projX0 * projX0 + projY1 * projY1 - projY0 * projY0;
      const det2 = 2 * (A * E - B * D);
      const dpDisSq = det2 * det2 / 4 / deltaProjectedDot;
      if (dpDisSq > this.dpTolSq) {
        const arcCenterX = (B * F - C * E) / det2;
        const arcCenterY = (C * D - A * F) / det2;
        const arcRadius = Math.hypot(arcCenterX - projX1, arcCenterY - projY1);
        const startToEndVec = Vec3Math.set(A, B, 0, this.vec3Cache[3]);
        const centerToMidVec = Vec3Math.set(projX0 - arcCenterX, projY0 - arcCenterY, 0, this.vec3Cache[4]);
        const cross2 = Vec3Math.cross(startToEndVec, centerToMidVec, this.vec3Cache[4]);
        state.vectorType = "arc";
        state.arcCenterX = arcCenterX;
        state.arcCenterY = arcCenterY;
        state.arcRadius = arcRadius;
        state.isArcCounterClockwise = cross2[2] > 0;
      } else {
        state.vectorType = "line";
      }
      const cosDistance = Vec3Math.dot(startVec, midVec);
      if (cosDistance > this.cosMinDistance) {
        if (state.vectorType === "line") {
          return state;
        }
        const query = circle.offsetAngleAlong(startVec, angularWidth / 4, this.geoPointCache[0]);
        const projectedQuery = projection.project(query, this.vec2Cache[0]);
        let distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
        if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
          circle.offsetAngleAlong(startVec, 3 * angularWidth / 4, query);
          projection.project(query, projectedQuery);
          distance = Math.hypot(projectedQuery[0] - state.arcCenterX, projectedQuery[1] - state.arcCenterY);
          if ((distance - state.arcRadius) * (distance - state.arcRadius) <= this.dpTolSq) {
            return state;
          }
        }
      }
      state = this.resampleHelper(projection, circle, lat1, lon1, x1, y1, z1, projX1, projY1, lat0, lon0, x0, y0, z0, projX0, projY0, handler, depth + 1, state);
      this.callHandler(handler, lat0, lon0, projX0, projY0, state);
      state.index++;
      state.prevX = projX0;
      state.prevY = projY0;
      return this.resampleHelper(projection, circle, lat0, lon0, x0, y0, z0, projX0, projY0, lat2, lon2, x2, y2, z2, projX2, projY2, handler, depth + 1, state);
    }
    callHandler(handler, lat, lon, projX, projY, state) {
      let vector;
      if (state.vectorType === "line") {
        vector = this.lineVector;
      } else {
        vector = this.arcVector;
        Vec2Math.set(state.arcCenterX, state.arcCenterY, vector.projectedArcCenter);
        vector.projectedArcRadius = state.arcRadius;
        vector.projectedArcStartAngle = Math.atan2(state.prevY - state.arcCenterY, state.prevX - state.arcCenterX);
        vector.projectedArcEndAngle = Math.atan2(projY - state.arcCenterY, projX - state.arcCenterX);
        if (vector.projectedArcEndAngle < vector.projectedArcStartAngle !== state.isArcCounterClockwise) {
          vector.projectedArcEndAngle += state.isArcCounterClockwise ? -MathUtils2.TWO_PI : MathUtils2.TWO_PI;
        }
      }
      vector.point.set(lat, lon);
      Vec2Math.set(projX, projY, vector.projected);
      vector.index = state.index;
      handler(vector);
    }
  };
  var NavAngleUnitReferenceNorth;
  (function(NavAngleUnitReferenceNorth2) {
    NavAngleUnitReferenceNorth2["True"] = "true";
    NavAngleUnitReferenceNorth2["Magnetic"] = "magnetic";
  })(NavAngleUnitReferenceNorth || (NavAngleUnitReferenceNorth = {}));
  var BasicNavAngleUnit = class extends AbstractUnit {
    constructor(referenceNorth, magVar) {
      super(referenceNorth === NavAngleUnitReferenceNorth.True ? "true bearing" : "magnetic bearing");
      this.family = "navangle";
      this._magVar = 0;
      this._magVar = magVar;
    }
    get magVar() {
      return this._magVar;
    }
    isMagnetic() {
      return this.name === "magnetic bearing";
    }
    convertTo(value, toUnit) {
      if (!this.canConvert(toUnit)) {
        throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === toUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.magneticToTrue(value, this.magVar) : MagVar.trueToMagnetic(value, this.magVar);
    }
    convertFrom(value, fromUnit) {
      if (!this.canConvert(fromUnit)) {
        throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
      }
      if (!isFinite(value)) {
        return NaN;
      }
      if (this.isMagnetic() === fromUnit.isMagnetic()) {
        return value;
      }
      return this.isMagnetic() ? MagVar.trueToMagnetic(value, this.magVar) : MagVar.magneticToTrue(value, this.magVar);
    }
    setMagVar(magVar) {
      this._magVar = magVar;
    }
    setMagVarFromLocation(arg1, arg2) {
      if (typeof arg1 === "number") {
        this._magVar = MagVar.get(arg1, arg2);
      } else {
        this._magVar = MagVar.get(arg1);
      }
    }
    equals(other) {
      return other instanceof BasicNavAngleUnit && this.name === other.name && this.magVar === other.magVar;
    }
    static create(isMagnetic, arg2, arg3) {
      const referenceNorth = isMagnetic ? NavAngleUnitReferenceNorth.Magnetic : NavAngleUnitReferenceNorth.True;
      let magVar = 0;
      if (arg2 !== void 0) {
        if (typeof arg2 === "number") {
          if (arg3 === void 0) {
            magVar = arg2;
          } else {
            magVar = MagVar.get(arg2, arg3);
          }
        } else {
          magVar = MagVar.get(arg2);
        }
      }
      return new BasicNavAngleUnit(referenceNorth, magVar);
    }
  };
  var BasicNavAngleSubject = class extends AbstractSubscribable {
    constructor(value) {
      super();
      this.value = value;
      this.isMutableSubscribable = true;
    }
    static create(initialVal) {
      return new BasicNavAngleSubject(initialVal);
    }
    get() {
      return this.value.readonly;
    }
    set(arg1, arg2, arg3) {
      const isArg1Number = typeof arg1 === "number";
      const isArg2Number = typeof arg2 === "number";
      const isArg2LatLon = typeof arg2 === "object" && "lat" in arg2 && "lon" in arg2;
      const unit = isArg1Number ? isArg2Number || isArg2LatLon || arg2 === void 0 ? this.value.unit : arg2 : arg1.unit;
      const oldMagVar = this.value.unit.magVar;
      const oldValue = this.value.number;
      if (isArg2LatLon) {
        this.value.unit.setMagVarFromLocation(arg2);
      } else if (isArg2Number) {
        if (typeof arg3 === "number") {
          this.value.unit.setMagVarFromLocation(arg2, arg3);
        } else {
          this.value.unit.setMagVar(arg2);
        }
      } else {
        this.value.unit.setMagVar(unit.magVar);
      }
      if (isArg1Number) {
        this.value.set(arg1, unit);
      } else {
        this.value.set(arg1);
      }
      if (!(isNaN(oldMagVar) && isNaN(this.value.unit.magVar)) && oldMagVar !== this.value.unit.magVar || !(isNaN(oldValue) && isNaN(this.value.number)) && oldValue !== this.value.number) {
        this.notify();
      }
    }
  };
  BasicNavAngleSubject.TRUE_BEARING = BasicNavAngleUnit.create(false);
  var AntiIcePublisher = class extends SimVarPublisher {
    constructor(bus, pacer) {
      const engineIndexedSimVars = [
        ["anti_ice_engine_switch_on", { name: "ENG ANTI ICE", type: SimVarValueType.Bool }],
        ["anti_ice_prop_switch_on", { name: "PROP DEICE SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(AntiIcePublisher.nonIndexedSimVars);
      const engineCount = SimVar.GetSimVarValue("NUMBER OF ENGINES", SimVarValueType.Number);
      for (const [topic, simvar2] of engineIndexedSimVars) {
        for (let i = 1; i <= engineCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  AntiIcePublisher.nonIndexedSimVars = [
    ["anti_ice_structural_switch_on", { name: "STRUCTURAL DEICE SWITCH", type: SimVarValueType.Bool }],
    ["anti_ice_windshield_switch_on", { name: "WINDSHIELD DEICE SWITCH", type: SimVarValueType.Bool }]
  ];
  var APLockType;
  (function(APLockType2) {
    APLockType2[APLockType2["Heading"] = 0] = "Heading";
    APLockType2[APLockType2["Nav"] = 1] = "Nav";
    APLockType2[APLockType2["Alt"] = 2] = "Alt";
    APLockType2[APLockType2["Bank"] = 3] = "Bank";
    APLockType2[APLockType2["WingLevel"] = 4] = "WingLevel";
    APLockType2[APLockType2["Vs"] = 5] = "Vs";
    APLockType2[APLockType2["Flc"] = 6] = "Flc";
    APLockType2[APLockType2["Pitch"] = 7] = "Pitch";
    APLockType2[APLockType2["Approach"] = 8] = "Approach";
    APLockType2[APLockType2["Backcourse"] = 9] = "Backcourse";
    APLockType2[APLockType2["Glideslope"] = 10] = "Glideslope";
    APLockType2[APLockType2["VNav"] = 11] = "VNav";
  })(APLockType || (APLockType = {}));
  var APSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(APSimVarPublisher.simvars, bus, pacer);
    }
  };
  APSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["ap_heading_selected", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_1", { name: "AUTOPILOT HEADING LOCK DIR:1", type: SimVarValueType.Degree }],
    ["ap_heading_selected_2", { name: "AUTOPILOT HEADING LOCK DIR:2", type: SimVarValueType.Degree }],
    ["ap_heading_selected_3", { name: "AUTOPILOT HEADING LOCK DIR:3", type: SimVarValueType.Degree }],
    ["ap_altitude_selected", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_1", { name: "AUTOPILOT ALTITUDE LOCK VAR:1", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_2", { name: "AUTOPILOT ALTITUDE LOCK VAR:2", type: SimVarValueType.Feet }],
    ["ap_altitude_selected_3", { name: "AUTOPILOT ALTITUDE LOCK VAR:3", type: SimVarValueType.Feet }],
    ["ap_master_status", { name: "AUTOPILOT MASTER", type: SimVarValueType.Bool }],
    ["ap_yd_status", { name: "AUTOPILOT YAW DAMPER", type: SimVarValueType.Bool }],
    ["ap_heading_hold", { name: "AUTOPILOT HEADING LOCK", type: SimVarValueType.Bool }],
    ["ap_nav_hold", { name: "AUTOPILOT NAV1 LOCK", type: SimVarValueType.Bool }],
    ["ap_bank_hold", { name: "AUTOPILOT BANK HOLD", type: SimVarValueType.Bool }],
    ["ap_max_bank_id", { name: "AUTOPILOT MAX BANK ID", type: SimVarValueType.Number }],
    ["ap_max_bank_value", { name: "AUTOPILOT MAX BANK", type: SimVarValueType.Degree }],
    ["ap_wing_lvl_hold", { name: "AUTOPILOT WING LEVELER", type: SimVarValueType.Bool }],
    ["ap_approach_hold", { name: "AUTOPILOT APPROACH HOLD", type: SimVarValueType.Bool }],
    ["ap_backcourse_hold", { name: "AUTOPILOT BACKCOURSE HOLD", type: SimVarValueType.Bool }],
    ["ap_vs_hold", { name: "AUTOPILOT VERTICAL HOLD", type: SimVarValueType.Bool }],
    ["ap_flc_hold", { name: "AUTOPILOT FLIGHT LEVEL CHANGE", type: SimVarValueType.Bool }],
    ["ap_alt_hold", { name: "AUTOPILOT ALTITUDE LOCK", type: SimVarValueType.Bool }],
    ["ap_glideslope_hold", { name: "AUTOPILOT GLIDESLOPE HOLD", type: SimVarValueType.Bool }],
    ["ap_pitch_hold", { name: "AUTOPILOT PITCH HOLD", type: SimVarValueType.Bool }],
    ["ap_toga_hold", { name: "AUTOPILOT TAKEOFF POWER ACTIVE", type: SimVarValueType.Bool }],
    ["ap_vs_selected", { name: "AUTOPILOT VERTICAL HOLD VAR:1", type: SimVarValueType.FPM }],
    ["ap_fpa_selected", { name: "L:WT_AP_FPA_Target:1", type: SimVarValueType.Degree }],
    ["ap_ias_selected", { name: "AUTOPILOT AIRSPEED HOLD VAR", type: SimVarValueType.Knots }],
    ["ap_mach_selected", { name: "AUTOPILOT MACH HOLD VAR", type: SimVarValueType.Number }],
    ["ap_selected_speed_is_mach", { name: "AUTOPILOT MANAGED SPEED IN MACH", type: SimVarValueType.Bool }],
    ["ap_selected_speed_is_manual", { name: "L:XMLVAR_SpeedIsManuallySet", type: SimVarValueType.Bool }],
    ["flight_director_bank", { name: "AUTOPILOT FLIGHT DIRECTOR BANK", type: SimVarValueType.Degree }],
    ["flight_director_pitch", { name: "AUTOPILOT FLIGHT DIRECTOR PITCH", type: SimVarValueType.Degree }],
    ["flight_director_is_active_1", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:1", type: SimVarValueType.Bool }],
    ["flight_director_is_active_2", { name: "AUTOPILOT FLIGHT DIRECTOR ACTIVE:2", type: SimVarValueType.Bool }],
    ["vnav_active", { name: "L:XMLVAR_VNAVButtonValue", type: SimVarValueType.Bool }],
    ["ap_pitch_selected", { name: "AUTOPILOT PITCH HOLD REF", type: SimVarValueType.Degree }]
  ]);
  var RadioUtils = class {
    static isNavFrequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 108e3 || freqKhz > 117950) {
        return false;
      }
      return freqKhz % 50 === 0;
    }
    static isLocalizerFrequency(freq) {
      return freq >= 108.1 && freq <= 111.95 && Math.trunc(freq * 10) % 2 === 1;
    }
    static isCom833Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136990) {
        return false;
      }
      return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    static isCom25Frequency(freq) {
      const freqKhz = Math.round(freq * 1e3);
      if (freqKhz < 118e3 || freqKhz > 136975) {
        return false;
      }
      return freqKhz % 25 === 0;
    }
    static isAdfFrequency(freq) {
      const freqHz = Math.round(freq * 1e3);
      if (freqHz < 19e4 || freqHz > 1799500) {
        return false;
      }
      return freqHz % 500 === 0;
    }
  };
  RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];
  var RadioType;
  (function(RadioType2) {
    RadioType2["Com"] = "COM";
    RadioType2["Nav"] = "NAV";
    RadioType2["Adf"] = "ADF";
  })(RadioType || (RadioType = {}));
  var FrequencyBank;
  (function(FrequencyBank2) {
    FrequencyBank2[FrequencyBank2["Active"] = 0] = "Active";
    FrequencyBank2[FrequencyBank2["Standby"] = 1] = "Standby";
  })(FrequencyBank || (FrequencyBank = {}));
  var ComSpacing;
  (function(ComSpacing2) {
    ComSpacing2[ComSpacing2["Spacing25Khz"] = 0] = "Spacing25Khz";
    ComSpacing2[ComSpacing2["Spacing833Khz"] = 1] = "Spacing833Khz";
  })(ComSpacing || (ComSpacing = {}));
  var NavProcSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    static createNavRadioDefinitions(index) {
      return [
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
        [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
        [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
        [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
        [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
        [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
        [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
        [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
        [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
        [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
        [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
        [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
        [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
        [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
      ];
    }
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
        [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
      ];
    }
  };
  NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ["gps_dtk", { name: "GPS WP DESIRED TRACK", type: SimVarValueType.Degree }],
    ["gps_xtk", { name: "GPS WP CROSS TRK", type: SimVarValueType.NM }],
    ["gps_wp", { name: "GPS WP NEXT ID", type: SimVarValueType.NM }],
    ["gps_wp_bearing", { name: "GPS WP BEARING", type: SimVarValueType.String }],
    ["gps_wp_distance", { name: "GPS WP DISTANCE", type: SimVarValueType.NM }],
    ["mkr_bcn_state_simvar", { name: "MARKER BEACON STATE", type: SimVarValueType.Number }],
    ["gps_obs_active_simvar", { name: "GPS OBS ACTIVE", type: SimVarValueType.Bool }],
    ["gps_obs_value_simvar", { name: "GPS OBS VALUE", type: SimVarValueType.Degree }]
  ]);
  var NavSourceType;
  (function(NavSourceType2) {
    NavSourceType2[NavSourceType2["Nav"] = 0] = "Nav";
    NavSourceType2[NavSourceType2["Gps"] = 1] = "Gps";
    NavSourceType2[NavSourceType2["Adf"] = 2] = "Adf";
  })(NavSourceType || (NavSourceType = {}));
  var VorToFrom;
  (function(VorToFrom2) {
    VorToFrom2[VorToFrom2["OFF"] = 0] = "OFF";
    VorToFrom2[VorToFrom2["TO"] = 1] = "TO";
    VorToFrom2[VorToFrom2["FROM"] = 2] = "FROM";
  })(VorToFrom || (VorToFrom = {}));
  var MarkerBeaconState;
  (function(MarkerBeaconState2) {
    MarkerBeaconState2[MarkerBeaconState2["Inactive"] = 0] = "Inactive";
    MarkerBeaconState2[MarkerBeaconState2["Outer"] = 1] = "Outer";
    MarkerBeaconState2[MarkerBeaconState2["Middle"] = 2] = "Middle";
    MarkerBeaconState2[MarkerBeaconState2["Inner"] = 3] = "Inner";
  })(MarkerBeaconState || (MarkerBeaconState = {}));
  var EventBusSyncBase = class {
    constructor(recvEventCb, busId) {
      this.isPaused = false;
      this.lastEventSynced = -1;
      this.dataPackageQueue = [];
      this.recvEventCb = recvEventCb;
      this.busId = busId;
      this.hookReceiveEvent();
      const sendFn = () => {
        if (!this.isPaused && this.dataPackageQueue.length > 0) {
          const syncDataPackage = {
            busId: this.busId,
            packagedId: Math.floor(Math.random() * 1e9),
            data: this.dataPackageQueue
          };
          if (this.executeSync(syncDataPackage)) {
            this.dataPackageQueue.length = 0;
          } else {
            console.warn("Failed to send sync data package");
          }
        }
        requestAnimationFrame(sendFn);
      };
      requestAnimationFrame(sendFn);
    }
    processEventsReceived(syncData) {
      if (this.busId !== syncData.busId) {
        if (this.lastEventSynced !== syncData.packagedId) {
          this.lastEventSynced = syncData.packagedId;
          syncData.data.forEach((data) => {
            try {
              this.recvEventCb(data.topic, data.data !== void 0 ? data.data : void 0, false, data.isCached);
            } catch (e) {
              console.error(e);
              if (e instanceof Error) {
                console.error(e.stack);
              }
            }
          });
        }
      }
    }
    sendEvent(topic, data, isCached) {
      const dataObj = data;
      const dataPackage = {
        topic,
        data: dataObj,
        isCached
      };
      this.dataPackageQueue.push(dataPackage);
    }
  };
  var EventBusCoherentSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, void 0, true);
      this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
        try {
          const evt = JSON.parse(e);
          this.processEventsReceived(evt);
        } catch (error) {
          console.error(error);
        }
      });
    }
  };
  EventBusCoherentSync.EB_KEY = "eb.evt";
  EventBusCoherentSync.EB_LISTENER_KEY = "JS_LISTENER_SIMVARS";
  var EventBusFlowEventSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        LaunchFlowEvent("ON_MOUSERECT_HTMLEVENT", EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      Coherent.on("OnInteractionEvent", (target, args) => {
        if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
          return;
        }
        this.processEventsReceived(JSON.parse(args[2]));
      });
    }
  };
  EventBusFlowEventSync.EB_LISTENER_KEY = "EB_EVENTS";
  var EventBusListenerSync = class extends EventBusSyncBase {
    executeSync(syncDataPackage) {
      try {
        this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
        return true;
      } catch (error) {
        return false;
      }
    }
    hookReceiveEvent() {
      this.isPaused = true;
      this.listener = RegisterGenericDataListener(() => {
        this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
          try {
            this.processEventsReceived(data);
          } catch (error) {
            console.error(error);
          }
        });
        this.isPaused = false;
      });
    }
  };
  EventBusListenerSync.EB_KEY = "wt.eb.evt";
  EventBusListenerSync.EB_LISTENER_KEY = "JS_LISTENER_GENERICDATA";
  var ConsumerValue = class {
    constructor(consumer, initialValue) {
      this.consumerHandler = (v) => {
        this.value = v;
      };
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialValue;
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    get isPaused() {
      return this._isPaused;
    }
    get() {
      return this.value;
    }
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    destroy() {
      var _a;
      this.isDestroyed = true;
      (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    static create(consumer, initialValue) {
      return new ConsumerValue(consumer, initialValue);
    }
  };
  var ConsumerSubject = class extends AbstractSubscribable {
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
      super();
      this.equalityFunc = equalityFunc;
      this.mutateFunc = mutateFunc;
      this.consumerHandler = this.onEventConsumed.bind(this);
      this._isPaused = false;
      this.isDestroyed = false;
      this.value = initialVal;
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    get isPaused() {
      return this._isPaused;
    }
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
      return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    onEventConsumed(value) {
      if (!this.equalityFunc(this.value, value)) {
        if (this.mutateFunc) {
          this.mutateFunc(this.value, value);
        } else {
          this.value = value;
        }
        this.notify();
      }
    }
    setConsumer(consumer) {
      var _a;
      if (this.isDestroyed) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
      return this;
    }
    pause() {
      var _a;
      if (this._isPaused) {
        return this;
      }
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
      this._isPaused = true;
      return this;
    }
    resume() {
      var _a;
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      return this;
    }
    get() {
      return this.value;
    }
    destroy() {
      var _a;
      (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.isDestroyed = true;
    }
  };
  var CompositeLogicXMLValueType;
  (function(CompositeLogicXMLValueType2) {
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Any"] = 0] = "Any";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["Number"] = 1] = "Number";
    CompositeLogicXMLValueType2[CompositeLogicXMLValueType2["String"] = 2] = "String";
  })(CompositeLogicXMLValueType || (CompositeLogicXMLValueType = {}));
  var DataStore;
  (function(DataStore2) {
    function set(key, value) {
      SetStoredData(key, JSON.stringify(value));
    }
    DataStore2.set = set;
    function get(key) {
      try {
        const string = GetStoredData(key);
        return JSON.parse(string);
      } catch (e) {
        return void 0;
      }
    }
    DataStore2.get = get;
    function remove(key) {
      DeleteStoredData(key);
    }
    DataStore2.remove = remove;
  })(DataStore || (DataStore = {}));
  var GameStateProvider = class {
    constructor() {
      this.gameState = Subject.create(void 0);
      window.document.addEventListener("OnVCockpitPanelAttributesChanged", this.onAttributesChanged.bind(this));
      this.onAttributesChanged();
    }
    onAttributesChanged() {
      var _a;
      if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute("gamestate")) {
        const attribute = window.parent.document.body.getAttribute("gamestate");
        if (attribute !== null) {
          this.gameState.set(GameState[attribute]);
          return;
        }
      }
      this.gameState.set(void 0);
    }
    static get() {
      var _a;
      return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : GameStateProvider.INSTANCE = new GameStateProvider()).gameState;
    }
  };
  var KeyEventManager = class {
    constructor(keyListener, bus) {
      this.keyListener = keyListener;
      this.bus = bus;
      Coherent.on("keyIntercepted", this.onKeyIntercepted.bind(this));
    }
    onKeyIntercepted(key, value1, value0, value2) {
      if (value0 !== void 0 && value0 >= 2147483648) {
        value0 -= 4294967296;
      }
      this.bus.pub("key_intercept", { key, value0, value1, value2 }, false, false);
    }
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
      return Coherent.call("TRIGGER_KEY_EVENT", key, bypass, value0, value1, value2);
    }
    interceptKey(key, passThrough) {
      Coherent.call("INTERCEPT_KEY_EVENT", key, passThrough ? 0 : 1);
    }
    static getManager(bus) {
      if (KeyEventManager.INSTANCE) {
        return Promise.resolve(KeyEventManager.INSTANCE);
      }
      if (!KeyEventManager.isCreatingInstance) {
        KeyEventManager.createInstance(bus);
      }
      return new Promise((resolve) => {
        KeyEventManager.pendingPromiseResolves.push(resolve);
      });
    }
    static async createInstance(bus) {
      KeyEventManager.isCreatingInstance = true;
      KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
      KeyEventManager.isCreatingInstance = false;
      for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
        KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
      }
    }
    static create(bus) {
      return new Promise((resolve, reject) => {
        const gameState = GameStateProvider.get();
        const sub2 = gameState.sub((state) => {
          if (window["IsDestroying"]) {
            sub2.destroy();
            reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            sub2.destroy();
            const keyListener = RegisterViewListener("JS_LISTENER_KEYEVENT", () => {
              if (window["IsDestroying"]) {
                reject("KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed");
                return;
              }
              resolve(new KeyEventManager(keyListener, bus));
            });
          }
        }, false, true);
        sub2.resume(true);
      });
    }
  };
  KeyEventManager.isCreatingInstance = false;
  KeyEventManager.pendingPromiseResolves = [];
  var FacilityFrequencyType;
  (function(FacilityFrequencyType2) {
    FacilityFrequencyType2[FacilityFrequencyType2["None"] = 0] = "None";
    FacilityFrequencyType2[FacilityFrequencyType2["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType2[FacilityFrequencyType2["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType2[FacilityFrequencyType2["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType2[FacilityFrequencyType2["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType2[FacilityFrequencyType2["Ground"] = 5] = "Ground";
    FacilityFrequencyType2[FacilityFrequencyType2["Tower"] = 6] = "Tower";
    FacilityFrequencyType2[FacilityFrequencyType2["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType2[FacilityFrequencyType2["Approach"] = 8] = "Approach";
    FacilityFrequencyType2[FacilityFrequencyType2["Departure"] = 9] = "Departure";
    FacilityFrequencyType2[FacilityFrequencyType2["Center"] = 10] = "Center";
    FacilityFrequencyType2[FacilityFrequencyType2["FSS"] = 11] = "FSS";
    FacilityFrequencyType2[FacilityFrequencyType2["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType2[FacilityFrequencyType2["ASOS"] = 13] = "ASOS";
    FacilityFrequencyType2[FacilityFrequencyType2["CPT"] = 14] = "CPT";
    FacilityFrequencyType2[FacilityFrequencyType2["GCO"] = 15] = "GCO";
  })(FacilityFrequencyType || (FacilityFrequencyType = {}));
  var AdditionalApproachType;
  (function(AdditionalApproachType2) {
    AdditionalApproachType2[AdditionalApproachType2["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
  })(AdditionalApproachType || (AdditionalApproachType = {}));
  var FixTypeFlags2;
  (function(FixTypeFlags3) {
    FixTypeFlags3[FixTypeFlags3["None"] = 0] = "None";
    FixTypeFlags3[FixTypeFlags3["IAF"] = 1] = "IAF";
    FixTypeFlags3[FixTypeFlags3["IF"] = 2] = "IF";
    FixTypeFlags3[FixTypeFlags3["MAP"] = 4] = "MAP";
    FixTypeFlags3[FixTypeFlags3["FAF"] = 8] = "FAF";
    FixTypeFlags3[FixTypeFlags3["MAHP"] = 16] = "MAHP";
  })(FixTypeFlags2 || (FixTypeFlags2 = {}));
  var RnavTypeFlags;
  (function(RnavTypeFlags2) {
    RnavTypeFlags2[RnavTypeFlags2["None"] = 0] = "None";
    RnavTypeFlags2[RnavTypeFlags2["LNAV"] = 1] = "LNAV";
    RnavTypeFlags2[RnavTypeFlags2["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags2[RnavTypeFlags2["LP"] = 4] = "LP";
    RnavTypeFlags2[RnavTypeFlags2["LPV"] = 8] = "LPV";
  })(RnavTypeFlags || (RnavTypeFlags = {}));
  var AirportClass;
  (function(AirportClass2) {
    AirportClass2[AirportClass2["None"] = 0] = "None";
    AirportClass2[AirportClass2["HardSurface"] = 1] = "HardSurface";
    AirportClass2[AirportClass2["SoftSurface"] = 2] = "SoftSurface";
    AirportClass2[AirportClass2["AllWater"] = 3] = "AllWater";
    AirportClass2[AirportClass2["HeliportOnly"] = 4] = "HeliportOnly";
    AirportClass2[AirportClass2["Private"] = 5] = "Private";
  })(AirportClass || (AirportClass = {}));
  var AirportClassMask;
  (function(AirportClassMask2) {
    AirportClassMask2[AirportClassMask2["None"] = 0] = "None";
    AirportClassMask2[AirportClassMask2["HardSurface"] = 2] = "HardSurface";
    AirportClassMask2[AirportClassMask2["SoftSurface"] = 4] = "SoftSurface";
    AirportClassMask2[AirportClassMask2["AllWater"] = 8] = "AllWater";
    AirportClassMask2[AirportClassMask2["HeliportOnly"] = 16] = "HeliportOnly";
    AirportClassMask2[AirportClassMask2["Private"] = 32] = "Private";
  })(AirportClassMask || (AirportClassMask = {}));
  var IntersectionType;
  (function(IntersectionType2) {
    IntersectionType2[IntersectionType2["None"] = 0] = "None";
    IntersectionType2[IntersectionType2["Named"] = 1] = "Named";
    IntersectionType2[IntersectionType2["Unnamed"] = 2] = "Unnamed";
    IntersectionType2[IntersectionType2["Vor"] = 3] = "Vor";
    IntersectionType2[IntersectionType2["NDB"] = 4] = "NDB";
    IntersectionType2[IntersectionType2["Offroute"] = 5] = "Offroute";
    IntersectionType2[IntersectionType2["IAF"] = 6] = "IAF";
    IntersectionType2[IntersectionType2["FAF"] = 7] = "FAF";
    IntersectionType2[IntersectionType2["RNAV"] = 8] = "RNAV";
    IntersectionType2[IntersectionType2["VFR"] = 9] = "VFR";
  })(IntersectionType || (IntersectionType = {}));
  var UserFacilityType;
  (function(UserFacilityType2) {
    UserFacilityType2[UserFacilityType2["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType2[UserFacilityType2["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType2[UserFacilityType2["LAT_LONG"] = 2] = "LAT_LONG";
  })(UserFacilityType || (UserFacilityType = {}));
  var LegType2;
  (function(LegType3) {
    LegType3[LegType3["Unknown"] = 0] = "Unknown";
    LegType3[LegType3["AF"] = 1] = "AF";
    LegType3[LegType3["CA"] = 2] = "CA";
    LegType3[LegType3["CD"] = 3] = "CD";
    LegType3[LegType3["CF"] = 4] = "CF";
    LegType3[LegType3["CI"] = 5] = "CI";
    LegType3[LegType3["CR"] = 6] = "CR";
    LegType3[LegType3["DF"] = 7] = "DF";
    LegType3[LegType3["FA"] = 8] = "FA";
    LegType3[LegType3["FC"] = 9] = "FC";
    LegType3[LegType3["FD"] = 10] = "FD";
    LegType3[LegType3["FM"] = 11] = "FM";
    LegType3[LegType3["HA"] = 12] = "HA";
    LegType3[LegType3["HF"] = 13] = "HF";
    LegType3[LegType3["HM"] = 14] = "HM";
    LegType3[LegType3["IF"] = 15] = "IF";
    LegType3[LegType3["PI"] = 16] = "PI";
    LegType3[LegType3["RF"] = 17] = "RF";
    LegType3[LegType3["TF"] = 18] = "TF";
    LegType3[LegType3["VA"] = 19] = "VA";
    LegType3[LegType3["VD"] = 20] = "VD";
    LegType3[LegType3["VI"] = 21] = "VI";
    LegType3[LegType3["VM"] = 22] = "VM";
    LegType3[LegType3["VR"] = 23] = "VR";
    LegType3[LegType3["Discontinuity"] = 99] = "Discontinuity";
    LegType3[LegType3["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
  })(LegType2 || (LegType2 = {}));
  var AltitudeRestrictionType;
  (function(AltitudeRestrictionType2) {
    AltitudeRestrictionType2[AltitudeRestrictionType2["Unused"] = 0] = "Unused";
    AltitudeRestrictionType2[AltitudeRestrictionType2["At"] = 1] = "At";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType2[AltitudeRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType2[AltitudeRestrictionType2["Between"] = 4] = "Between";
  })(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
  var LegTurnDirection;
  (function(LegTurnDirection2) {
    LegTurnDirection2[LegTurnDirection2["None"] = 0] = "None";
    LegTurnDirection2[LegTurnDirection2["Left"] = 1] = "Left";
    LegTurnDirection2[LegTurnDirection2["Right"] = 2] = "Right";
    LegTurnDirection2[LegTurnDirection2["Either"] = 3] = "Either";
  })(LegTurnDirection || (LegTurnDirection = {}));
  var AirwayType;
  (function(AirwayType2) {
    AirwayType2[AirwayType2["None"] = 0] = "None";
    AirwayType2[AirwayType2["Victor"] = 1] = "Victor";
    AirwayType2[AirwayType2["Jet"] = 2] = "Jet";
    AirwayType2[AirwayType2["Both"] = 3] = "Both";
  })(AirwayType || (AirwayType = {}));
  var NdbType;
  (function(NdbType2) {
    NdbType2[NdbType2["CompassPoint"] = 0] = "CompassPoint";
    NdbType2[NdbType2["MH"] = 1] = "MH";
    NdbType2[NdbType2["H"] = 2] = "H";
    NdbType2[NdbType2["HH"] = 3] = "HH";
  })(NdbType || (NdbType = {}));
  var VorType;
  (function(VorType3) {
    VorType3[VorType3["Unknown"] = 0] = "Unknown";
    VorType3[VorType3["VOR"] = 1] = "VOR";
    VorType3[VorType3["VORDME"] = 2] = "VORDME";
    VorType3[VorType3["DME"] = 3] = "DME";
    VorType3[VorType3["TACAN"] = 4] = "TACAN";
    VorType3[VorType3["VORTAC"] = 5] = "VORTAC";
    VorType3[VorType3["ILS"] = 6] = "ILS";
    VorType3[VorType3["VOT"] = 7] = "VOT";
  })(VorType || (VorType = {}));
  var RunwaySurfaceType;
  (function(RunwaySurfaceType2) {
    RunwaySurfaceType2[RunwaySurfaceType2["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType2[RunwaySurfaceType2["Grass"] = 1] = "Grass";
    RunwaySurfaceType2[RunwaySurfaceType2["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType2[RunwaySurfaceType2["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType2[RunwaySurfaceType2["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType2[RunwaySurfaceType2["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType2[RunwaySurfaceType2["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType2[RunwaySurfaceType2["Snow"] = 8] = "Snow";
    RunwaySurfaceType2[RunwaySurfaceType2["Ice"] = 9] = "Ice";
    RunwaySurfaceType2[RunwaySurfaceType2["Urban"] = 10] = "Urban";
    RunwaySurfaceType2[RunwaySurfaceType2["Forest"] = 11] = "Forest";
    RunwaySurfaceType2[RunwaySurfaceType2["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType2[RunwaySurfaceType2["Coral"] = 13] = "Coral";
    RunwaySurfaceType2[RunwaySurfaceType2["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType2[RunwaySurfaceType2["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType2[RunwaySurfaceType2["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType2[RunwaySurfaceType2["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType2[RunwaySurfaceType2["Brick"] = 18] = "Brick";
    RunwaySurfaceType2[RunwaySurfaceType2["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType2[RunwaySurfaceType2["Planks"] = 20] = "Planks";
    RunwaySurfaceType2[RunwaySurfaceType2["Sand"] = 21] = "Sand";
    RunwaySurfaceType2[RunwaySurfaceType2["Shale"] = 22] = "Shale";
    RunwaySurfaceType2[RunwaySurfaceType2["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType2[RunwaySurfaceType2["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    RunwaySurfaceType2[RunwaySurfaceType2["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType2[RunwaySurfaceType2["Water"] = 27] = "Water";
    RunwaySurfaceType2[RunwaySurfaceType2["Pond"] = 28] = "Pond";
    RunwaySurfaceType2[RunwaySurfaceType2["Lake"] = 29] = "Lake";
    RunwaySurfaceType2[RunwaySurfaceType2["River"] = 30] = "River";
    RunwaySurfaceType2[RunwaySurfaceType2["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType2[RunwaySurfaceType2["Paint"] = 32] = "Paint";
  })(RunwaySurfaceType || (RunwaySurfaceType = {}));
  var RunwayLightingType;
  (function(RunwayLightingType2) {
    RunwayLightingType2[RunwayLightingType2["Unknown"] = 0] = "Unknown";
    RunwayLightingType2[RunwayLightingType2["None"] = 1] = "None";
    RunwayLightingType2[RunwayLightingType2["PartTime"] = 2] = "PartTime";
    RunwayLightingType2[RunwayLightingType2["FullTime"] = 3] = "FullTime";
    RunwayLightingType2[RunwayLightingType2["Frequency"] = 4] = "Frequency";
  })(RunwayLightingType || (RunwayLightingType = {}));
  var AirportPrivateType;
  (function(AirportPrivateType2) {
    AirportPrivateType2[AirportPrivateType2["Uknown"] = 0] = "Uknown";
    AirportPrivateType2[AirportPrivateType2["Public"] = 1] = "Public";
    AirportPrivateType2[AirportPrivateType2["Military"] = 2] = "Military";
    AirportPrivateType2[AirportPrivateType2["Private"] = 3] = "Private";
  })(AirportPrivateType || (AirportPrivateType = {}));
  var GpsBoolean;
  (function(GpsBoolean2) {
    GpsBoolean2[GpsBoolean2["Unknown"] = 0] = "Unknown";
    GpsBoolean2[GpsBoolean2["No"] = 1] = "No";
    GpsBoolean2[GpsBoolean2["Yes"] = 2] = "Yes";
  })(GpsBoolean || (GpsBoolean = {}));
  var VorClass;
  (function(VorClass3) {
    VorClass3[VorClass3["Unknown"] = 0] = "Unknown";
    VorClass3[VorClass3["Terminal"] = 1] = "Terminal";
    VorClass3[VorClass3["LowAlt"] = 2] = "LowAlt";
    VorClass3[VorClass3["HighAlt"] = 3] = "HighAlt";
    VorClass3[VorClass3["ILS"] = 4] = "ILS";
    VorClass3[VorClass3["VOT"] = 5] = "VOT";
  })(VorClass || (VorClass = {}));
  var FacilityType;
  (function(FacilityType2) {
    FacilityType2["Airport"] = "LOAD_AIRPORT";
    FacilityType2["Intersection"] = "LOAD_INTERSECTION";
    FacilityType2["VOR"] = "LOAD_VOR";
    FacilityType2["NDB"] = "LOAD_NDB";
    FacilityType2["USR"] = "USR";
    FacilityType2["RWY"] = "RWY";
    FacilityType2["VIS"] = "VIS";
  })(FacilityType || (FacilityType = {}));
  var FacilitySearchType;
  (function(FacilitySearchType2) {
    FacilitySearchType2[FacilitySearchType2["All"] = 0] = "All";
    FacilitySearchType2[FacilitySearchType2["Airport"] = 1] = "Airport";
    FacilitySearchType2[FacilitySearchType2["Intersection"] = 2] = "Intersection";
    FacilitySearchType2[FacilitySearchType2["Vor"] = 3] = "Vor";
    FacilitySearchType2[FacilitySearchType2["Ndb"] = 4] = "Ndb";
    FacilitySearchType2[FacilitySearchType2["Boundary"] = 5] = "Boundary";
    FacilitySearchType2[FacilitySearchType2["User"] = 6] = "User";
    FacilitySearchType2[FacilitySearchType2["Visual"] = 7] = "Visual";
    FacilitySearchType2[FacilitySearchType2["AllExceptVisual"] = 8] = "AllExceptVisual";
  })(FacilitySearchType || (FacilitySearchType = {}));
  var BoundaryType;
  (function(BoundaryType2) {
    BoundaryType2[BoundaryType2["None"] = 0] = "None";
    BoundaryType2[BoundaryType2["Center"] = 1] = "Center";
    BoundaryType2[BoundaryType2["ClassA"] = 2] = "ClassA";
    BoundaryType2[BoundaryType2["ClassB"] = 3] = "ClassB";
    BoundaryType2[BoundaryType2["ClassC"] = 4] = "ClassC";
    BoundaryType2[BoundaryType2["ClassD"] = 5] = "ClassD";
    BoundaryType2[BoundaryType2["ClassE"] = 6] = "ClassE";
    BoundaryType2[BoundaryType2["ClassF"] = 7] = "ClassF";
    BoundaryType2[BoundaryType2["ClassG"] = 8] = "ClassG";
    BoundaryType2[BoundaryType2["Tower"] = 9] = "Tower";
    BoundaryType2[BoundaryType2["Clearance"] = 10] = "Clearance";
    BoundaryType2[BoundaryType2["Ground"] = 11] = "Ground";
    BoundaryType2[BoundaryType2["Departure"] = 12] = "Departure";
    BoundaryType2[BoundaryType2["Approach"] = 13] = "Approach";
    BoundaryType2[BoundaryType2["MOA"] = 14] = "MOA";
    BoundaryType2[BoundaryType2["Restricted"] = 15] = "Restricted";
    BoundaryType2[BoundaryType2["Prohibited"] = 16] = "Prohibited";
    BoundaryType2[BoundaryType2["Warning"] = 17] = "Warning";
    BoundaryType2[BoundaryType2["Alert"] = 18] = "Alert";
    BoundaryType2[BoundaryType2["Danger"] = 19] = "Danger";
    BoundaryType2[BoundaryType2["NationalPark"] = 20] = "NationalPark";
    BoundaryType2[BoundaryType2["ModeC"] = 21] = "ModeC";
    BoundaryType2[BoundaryType2["Radar"] = 22] = "Radar";
    BoundaryType2[BoundaryType2["Training"] = 23] = "Training";
  })(BoundaryType || (BoundaryType = {}));
  var BoundaryAltitudeType;
  (function(BoundaryAltitudeType2) {
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType2[BoundaryAltitudeType2["MSL"] = 1] = "MSL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["AGL"] = 2] = "AGL";
    BoundaryAltitudeType2[BoundaryAltitudeType2["Unlimited"] = 3] = "Unlimited";
  })(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
  var BoundaryVectorType;
  (function(BoundaryVectorType2) {
    BoundaryVectorType2[BoundaryVectorType2["None"] = 0] = "None";
    BoundaryVectorType2[BoundaryVectorType2["Start"] = 1] = "Start";
    BoundaryVectorType2[BoundaryVectorType2["Line"] = 2] = "Line";
    BoundaryVectorType2[BoundaryVectorType2["Origin"] = 3] = "Origin";
    BoundaryVectorType2[BoundaryVectorType2["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType2[BoundaryVectorType2["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType2[BoundaryVectorType2["Circle"] = 6] = "Circle";
  })(BoundaryVectorType || (BoundaryVectorType = {}));
  var MetarWindSpeedUnits;
  (function(MetarWindSpeedUnits2) {
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits2[MetarWindSpeedUnits2["KilometerPerHour"] = 2] = "KilometerPerHour";
  })(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
  var MetarVisibilityUnits;
  (function(MetarVisibilityUnits2) {
    MetarVisibilityUnits2[MetarVisibilityUnits2["Meter"] = 0] = "Meter";
    MetarVisibilityUnits2[MetarVisibilityUnits2["StatuteMile"] = 1] = "StatuteMile";
  })(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
  var MetarCloudLayerCoverage;
  (function(MetarCloudLayerCoverage2) {
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Few"] = 3] = "Few";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage2[MetarCloudLayerCoverage2["Overcast"] = 6] = "Overcast";
  })(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
  var MetarCloudLayerType;
  (function(MetarCloudLayerType2) {
    MetarCloudLayerType2[MetarCloudLayerType2["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType2[MetarCloudLayerType2["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType2[MetarCloudLayerType2["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType2[MetarCloudLayerType2["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
  })(MetarCloudLayerType || (MetarCloudLayerType = {}));
  var MetarPhenomenonType;
  (function(MetarPhenomenonType2) {
    MetarPhenomenonType2[MetarPhenomenonType2["None"] = 0] = "None";
    MetarPhenomenonType2[MetarPhenomenonType2["Mist"] = 1] = "Mist";
    MetarPhenomenonType2[MetarPhenomenonType2["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType2[MetarPhenomenonType2["Dust"] = 3] = "Dust";
    MetarPhenomenonType2[MetarPhenomenonType2["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType2[MetarPhenomenonType2["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType2[MetarPhenomenonType2["Fog"] = 6] = "Fog";
    MetarPhenomenonType2[MetarPhenomenonType2["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType2[MetarPhenomenonType2["Hail"] = 8] = "Hail";
    MetarPhenomenonType2[MetarPhenomenonType2["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType2[MetarPhenomenonType2["Haze"] = 10] = "Haze";
    MetarPhenomenonType2[MetarPhenomenonType2["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType2[MetarPhenomenonType2["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType2[MetarPhenomenonType2["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType2[MetarPhenomenonType2["Spray"] = 14] = "Spray";
    MetarPhenomenonType2[MetarPhenomenonType2["Rain"] = 15] = "Rain";
    MetarPhenomenonType2[MetarPhenomenonType2["Sand"] = 16] = "Sand";
    MetarPhenomenonType2[MetarPhenomenonType2["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType2[MetarPhenomenonType2["Shower"] = 18] = "Shower";
    MetarPhenomenonType2[MetarPhenomenonType2["Snow"] = 19] = "Snow";
    MetarPhenomenonType2[MetarPhenomenonType2["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType2[MetarPhenomenonType2["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType2[MetarPhenomenonType2["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType2[MetarPhenomenonType2["VolcanicAsh"] = 23] = "VolcanicAsh";
  })(MetarPhenomenonType || (MetarPhenomenonType = {}));
  var MetarPhenomenonIntensity;
  (function(MetarPhenomenonIntensity2) {
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Light"] = -1] = "Light";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity2[MetarPhenomenonIntensity2["Heavy"] = 1] = "Heavy";
  })(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
  var ICAO = class {
    static getFacilityType(icao) {
      switch (icao[0]) {
        case "A":
          return FacilityType.Airport;
        case "W":
          return FacilityType.Intersection;
        case "V":
          return FacilityType.VOR;
        case "N":
          return FacilityType.NDB;
        case "U":
          return FacilityType.USR;
        case "R":
          return FacilityType.RWY;
        case "S":
          return FacilityType.VIS;
        default:
          throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
      }
    }
    static getAssociatedAirportIdent(icao) {
      return icao.substr(3, 4).trim();
    }
    static isFacility(icao, type) {
      switch (icao[0]) {
        case "A":
          return type === void 0 || type === FacilityType.Airport;
        case "W":
          return type === void 0 || type === FacilityType.Intersection;
        case "V":
          return type === void 0 || type === FacilityType.VOR;
        case "N":
          return type === void 0 || type === FacilityType.NDB;
        case "U":
          return type === void 0 || type === FacilityType.USR;
        case "R":
          return type === void 0 || type === FacilityType.RWY;
        case "S":
          return type === void 0 || type === FacilityType.VIS;
        default:
          return false;
      }
    }
    static getIdent(icao) {
      return icao.substr(7).trim();
    }
    static getRegionCode(icao) {
      return icao.substr(1, 2).trim();
    }
  };
  ICAO.emptyIcao = "            ";
  var FacilityUtils = class {
    static isFacilityType(facility, type) {
      if (facility["__Type"] === "JS_FacilityIntersection") {
        return type === FacilityType.Intersection;
      }
      return ICAO.isFacility(facility.icao, type);
    }
    static getMagVar(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
        return -facility.magneticVariation;
      } else {
        return MagVar.get(facility.lat, facility.lon);
      }
    }
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
      return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
      const magVar1 = FacilityUtils.getMagVar(reference1);
      const magVar2 = FacilityUtils.getMagVar(reference2);
      const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
      const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
      const radial1IncludesRef2 = radialCircle1.includes(reference2);
      const radial2IncludesRef1 = radialCircle2.includes(reference1);
      if (radial1IncludesRef2 && radial2IncludesRef1) {
        return out.set(NaN, NaN);
      } else if (radial1IncludesRef2) {
        return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
      } else if (radial2IncludesRef1) {
        return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
      }
      const numIntersections = radialCircle1.encircles(reference2) ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache) : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
      if (numIntersections === 0) {
        return out.set(NaN, NaN);
      }
      return out.set(FacilityUtils.intersectionCache[0]);
    }
  };
  FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
  FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var IntersectionFacilityUtils = class {
    static isTerminal(arg) {
      const icao = typeof arg === "string" ? arg : arg.icao;
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao);
    }
    static getNonTerminalICAO(icao) {
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        throw new Error(`Facility with ICAO ${icao} is not an intersection`);
      }
      return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao) ? `${icao.substring(0, 3)}    ${icao.substring(7)}` : icao;
    }
    static getIcaoIdentity(icao) {
      return icao;
    }
    static getIcaoFacility(facility) {
      return facility.icao;
    }
    static filterDuplicates(array, arg2, arg3) {
      if (array.length === 0) {
        return [];
      }
      let getIcao;
      let retainTerminal;
      if (typeof arg2 === "function") {
        getIcao = arg2;
        retainTerminal = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        retainTerminal = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        if (typeof array[0] === "string") {
          getIcao = IntersectionFacilityUtils.getIcaoIdentity;
        } else {
          getIcao = IntersectionFacilityUtils.getIcaoFacility;
        }
      }
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      for (let i = 0; i < array.length; i++) {
        const icao = getIcao(array[i]);
        if (ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) === retainTerminal) {
          IntersectionFacilityUtils.filterDuplicatesSet.add(IntersectionFacilityUtils.getNonTerminalICAO(icao));
        }
      }
      if (IntersectionFacilityUtils.filterDuplicatesSet.size === 0) {
        return array.slice();
      }
      const filtered = array.filter((icao) => {
        return IntersectionFacilityUtils.filterDuplicatesHelper(icao, getIcao, retainTerminal, IntersectionFacilityUtils.filterDuplicatesSet);
      });
      IntersectionFacilityUtils.filterDuplicatesSet.clear();
      return filtered;
    }
    static filterDuplicatesHelper(element, getIcao, retainTerminal, nonTerminalIcaosToFilter) {
      const icao = getIcao(element);
      if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
        return true;
      }
      const isTerminal = IntersectionFacilityUtils.isTerminal(icao);
      if (isTerminal === retainTerminal) {
        return true;
      }
      if (isTerminal) {
        return !nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao));
      } else {
        return !nonTerminalIcaosToFilter.has(icao);
      }
    }
  };
  IntersectionFacilityUtils.TERMINAL_REGEX = /^...[a-zA-Z\d]/;
  IntersectionFacilityUtils.filterDuplicatesSet = /* @__PURE__ */ new Set();
  var UserFacilityUtils = class {
    static createFromLatLon(icao, lat, lon, isTemporary = false, name69) {
      const fac = {
        icao,
        name: name69 !== null && name69 !== void 0 ? name69 : "",
        lat,
        lon,
        userFacilityType: UserFacilityType.LAT_LONG,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(lat, lon)
      };
      return fac;
    }
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name69) {
      const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
      return {
        icao,
        name: name69 !== null && name69 !== void 0 ? name69 : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_DISTANCE,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference.icao,
        reference1Radial: radial,
        reference1MagVar: FacilityUtils.getMagVar(reference),
        reference1Distance: distance
      };
    }
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name69) {
      const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
      if (isNaN(location.lat) || isNaN(location.lon)) {
        return void 0;
      }
      return {
        icao,
        name: name69 !== null && name69 !== void 0 ? name69 : "",
        lat: location.lat,
        lon: location.lon,
        userFacilityType: UserFacilityType.RADIAL_RADIAL,
        isTemporary,
        region: "",
        city: "",
        magvar: MagVar.get(location),
        reference1Icao: reference1.icao,
        reference1Radial: radial1,
        reference1MagVar: FacilityUtils.getMagVar(reference1),
        reference2Icao: reference2.icao,
        reference2Radial: radial2,
        reference2MagVar: FacilityUtils.getMagVar(reference2)
      };
    }
  };
  UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
  var RunwaySurfaceCategory;
  (function(RunwaySurfaceCategory2) {
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory2[RunwaySurfaceCategory2["Water"] = 8] = "Water";
  })(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
  var RunwayUtils2 = class {
    static getDesignatorLetter(designator, lowerCase = false) {
      const letter = RunwayUtils2.RUNWAY_DESIGNATOR_LETTERS[designator];
      return lowerCase ? letter.toLowerCase() : letter;
    }
    static createEmptyOneWayRunway() {
      return {
        parentRunwayIndex: -1,
        designation: "",
        direction: 36,
        runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
        course: 0,
        elevation: 0,
        elevationEnd: 0,
        gradient: 0,
        latitude: 0,
        longitude: 0,
        length: 0,
        width: 0,
        startThresholdLength: 0,
        endThresholdLength: 0,
        surface: RunwaySurfaceType.Concrete,
        lighting: RunwayLightingType.Unknown
      };
    }
    static getOneWayRunwaysFromAirport(airport) {
      const runways = [];
      airport.runways.map((r, i) => RunwayUtils2.getOneWayRunways(r, i)).forEach((d) => {
        runways.push(d[0]);
        runways.push(d[1]);
      });
      runways.sort(RunwayUtils2.sortRunways);
      return runways;
    }
    static getOneWayRunways(runway, index) {
      const splitRunways = [];
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        let course = 0;
        let thresholdDistanceFromCenter = 0;
        let thresholdElevation = 0;
        let endThresholdElevation = 0;
        let ilsFrequency;
        let startThresholdLength = 0, endThresholdLength = 0;
        if (i === 0) {
          designator = runway.designatorCharPrimary;
          course = runway.direction;
          thresholdDistanceFromCenter = runway.length / 2 - runway.primaryThresholdLength;
          thresholdElevation = runway.primaryElevation;
          endThresholdElevation = runway.secondaryElevation;
          ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? void 0 : runway.primaryILSFrequency;
          startThresholdLength = runway.primaryThresholdLength;
          endThresholdLength = runway.secondaryThresholdLength;
        } else if (i === 1) {
          designator = runway.designatorCharSecondary;
          course = NavMath.normalizeHeading(runway.direction + 180);
          thresholdDistanceFromCenter = runway.length / 2 - runway.secondaryThresholdLength;
          thresholdElevation = runway.secondaryElevation;
          endThresholdElevation = runway.primaryElevation;
          ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? void 0 : runway.secondaryILSFrequency;
          startThresholdLength = runway.secondaryThresholdLength;
          endThresholdLength = runway.primaryThresholdLength;
        }
        const designation = RunwayUtils2.getRunwayNameString(runwayNumber, designator);
        const coordinates = RunwayUtils2.tempGeoPoint.set(runway.latitude, runway.longitude).offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
        splitRunways.push({
          parentRunwayIndex: index,
          designation,
          direction: runwayNumber,
          runwayDesignator: designator,
          course,
          elevation: thresholdElevation,
          elevationEnd: endThresholdElevation,
          gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
          latitude: coordinates.lat,
          longitude: coordinates.lon,
          ilsFrequency,
          length: runway.length,
          width: runway.width,
          startThresholdLength,
          endThresholdLength,
          surface: runway.surface,
          lighting: runway.lighting
        });
      }
      return splitRunways;
    }
    static getRunwayPairNameString(runway, padded = true) {
      const pad = padded ? 2 : 0;
      const dashIndex = runway.designation.search("-");
      const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils2.getDesignatorLetter(runway.designatorCharPrimary)}`;
      const secondary = dashIndex < 0 ? "" : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils2.getDesignatorLetter(runway.designatorCharSecondary)}`;
      return primary + secondary;
    }
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = "") {
      let numberText = `${runwayNumber}`;
      if (padded) {
        numberText = numberText.padStart(2, "0");
      }
      return prefix + numberText + RunwayUtils2.getDesignatorLetter(designator);
    }
    static getRunwayNumberPrimary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return parseInt(runway.designation);
      } else {
        return parseInt(runway.designation.substring(0, dashIndex));
      }
    }
    static getRunwayNumberSecondary(runway) {
      const dashIndex = runway.designation.search("-");
      if (dashIndex < 0) {
        return void 0;
      } else {
        return parseInt(runway.designation.substring(dashIndex + 1));
      }
    }
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const length = airport.runways.length;
      for (let r = 0; r < length; r++) {
        const runway = airport.runways[r];
        const designation = runway.designation;
        const primaryRunwayNumber = parseInt(designation.split("-")[0]);
        const secondaryRunwayNumber = parseInt(designation.split("-")[1]);
        if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
          const oneWayRunways = RunwayUtils2.getOneWayRunways(runway, r);
          return oneWayRunways[0];
        } else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
          const oneWayRunways = RunwayUtils2.getOneWayRunways(runway, r);
          return oneWayRunways[1];
        }
      }
      return void 0;
    }
    static matchOneWayRunwayFromDesignation(airport, designation) {
      const length = airport.runways.length;
      for (let i = 0; i < length; i++) {
        const match = RunwayUtils2.getOneWayRunways(airport.runways[i], i).find((r) => {
          return r.designation === designation;
        });
        if (match) {
          return match;
        }
      }
      return void 0;
    }
    static matchOneWayRunwayFromIdent(airport, ident) {
      return RunwayUtils2.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    static getProceduresForRunway(procedures, runway) {
      const oneways = new Array();
      const designations = runway.designation.split("-");
      for (let i = 0; i < designations.length; i++) {
        const runwayNumber = parseInt(designations[i]);
        let runwayName;
        if (i === 0) {
          runwayName = RunwayUtils2.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, "");
        } else {
          runwayName = RunwayUtils2.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, "");
        }
        oneways.push(runwayName);
      }
      const found = new Array();
      for (const procedure of procedures) {
        if (oneways.includes(procedure.runway.trim())) {
          found.push(procedure);
        } else if (procedure.runwayNumber === 0) {
          found.push(procedure);
        }
      }
      return found;
    }
    static getLocFrequency(airport, arg1, arg2) {
      let runway;
      if (typeof arg1 === "string") {
        const matchedRunway = RunwayUtils2.matchOneWayRunwayFromDesignation(airport, arg1);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else if (typeof arg1 === "number") {
        const matchedRunway = RunwayUtils2.matchOneWayRunway(airport, arg1, arg2);
        if (!matchedRunway) {
          return void 0;
        }
        runway = matchedRunway;
      } else {
        runway = arg1;
      }
      const runwayDesignation = runway.designation;
      if (runway.ilsFrequency) {
        return runway.ilsFrequency;
      }
      for (let i = 0; i < airport.frequencies.length; i++) {
        const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ""));
        if (match > -1) {
          return airport.frequencies[i];
        }
      }
      return void 0;
    }
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
      const matchedRunway = RunwayUtils2.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
      if (!matchedRunway) {
        return void 0;
      }
      return RunwayUtils2.getLocFrequency(airport, matchedRunway);
    }
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
      const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
      let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
      switch (runwayDesignator) {
        case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
          break;
        case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
          oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
          break;
        default:
          oppositeRunwayDesignator = runwayDesignator;
          break;
      }
      return RunwayUtils2.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    static sortRunways(r1, r2) {
      if (r1.direction === r2.direction) {
        let v1 = 0;
        if (r1.designation.indexOf("L") != -1) {
          v1 = 1;
        } else if (r1.designation.indexOf("C") != -1) {
          v1 = 2;
        } else if (r1.designation.indexOf("R") != -1) {
          v1 = 3;
        }
        let v2 = 0;
        if (r2.designation.indexOf("L") != -1) {
          v2 = 1;
        } else if (r2.designation.indexOf("C") != -1) {
          v2 = 2;
        } else if (r2.designation.indexOf("R") != -1) {
          v2 = 3;
        }
        return v1 - v2;
      }
      return r1.direction - r2.direction;
    }
    static getRunwayFacilityIcao(airport, runway) {
      const icao = typeof airport === "string" ? airport : airport.icao;
      return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, " ")}`;
    }
    static createRunwayFacility(airport, runway) {
      return {
        icao: RunwayUtils2.getRunwayFacilityIcao(airport, runway),
        name: `Runway ${runway.designation}`,
        region: airport.region,
        city: airport.city,
        lat: runway.latitude,
        lon: runway.longitude,
        magvar: airport.magvar,
        runway
      };
    }
    static getRunwayCode(number2) {
      const n = Math.round(number2);
      return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    static getSurfaceCategory(runway) {
      const surface = typeof runway === "object" ? runway.surface : runway;
      if (this.SURFACES_HARD.includes(surface)) {
        return RunwaySurfaceCategory.Hard;
      } else if (this.SURFACES_SOFT.includes(surface)) {
        return RunwaySurfaceCategory.Soft;
      } else if (this.SURFACES_WATER.includes(surface)) {
        return RunwaySurfaceCategory.Water;
      } else {
        return RunwaySurfaceCategory.Unknown;
      }
    }
  };
  RunwayUtils2.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: "",
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: "L",
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: "R",
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: "C",
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: "W",
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: "A",
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: "B"
  };
  RunwayUtils2.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban
  ];
  RunwayUtils2.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
  ];
  RunwayUtils2.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
  ];
  RunwayUtils2.tempGeoPoint = new GeoPoint(0, 0);
  var AirportUtils = class {
    static tryGetRegionCode(facility) {
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        if (approach.runway.length === 0 || approach.finalLegs.length === 0) {
          continue;
        }
        const fixIcao = approach.finalLegs[approach.finalLegs.length - 1].fixIcao;
        if (ICAO.isFacility(fixIcao, FacilityType.RWY)) {
          const region = ICAO.getRegionCode(fixIcao);
          if (AirportUtils.REGION_CODES.has(region)) {
            return region;
          }
        }
      }
      if (facility.approaches.length > 1) {
        let region = void 0;
        let regionCount = 0;
        for (let i = 0; i < facility.approaches.length; i++) {
          const approach = facility.approaches[i];
          for (let j = 0; j < approach.finalLegs.length; j++) {
            const leg = approach.finalLegs[j];
            if (leg.fixTypeFlags === FixTypeFlags2.FAF && ICAO.isFacility(leg.fixIcao)) {
              const fafRegion = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(fafRegion)) {
                region !== null && region !== void 0 ? region : region = fafRegion;
                if (region !== fafRegion) {
                  region = void 0;
                }
                regionCount++;
                break;
              }
            }
          }
          if (region === void 0 && regionCount > 0) {
            break;
          }
        }
        if (region !== void 0 && regionCount > 1) {
          return region;
        }
      }
      const ident = ICAO.getIdent(facility.icao);
      if (ident.length === 4 && ident.search(AirportUtils.NUMERAL_REGEX) < 0) {
        const region = ident.substring(0, 2);
        if (AirportUtils.REGION_CODES.has(region)) {
          return region;
        }
      }
      for (let i = 0; i < facility.departures.length; i++) {
        const departure = facility.departures[i];
        for (let j = 0; j < departure.commonLegs.length; j++) {
          const leg = departure.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < departure.runwayTransitions.length; j++) {
          const transition = departure.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.arrivals.length; i++) {
        const arrival = facility.arrivals[i];
        for (let j = 0; j < arrival.commonLegs.length; j++) {
          const leg = arrival.commonLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < arrival.runwayTransitions.length; j++) {
          const transition = arrival.runwayTransitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      for (let i = 0; i < facility.approaches.length; i++) {
        const approach = facility.approaches[i];
        for (let j = 0; j < approach.finalLegs.length; j++) {
          const leg = approach.finalLegs[j];
          if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
            const region = ICAO.getRegionCode(leg.fixIcao);
            if (AirportUtils.REGION_CODES.has(region)) {
              return region;
            }
          }
        }
        for (let j = 0; j < approach.transitions.length; j++) {
          const transition = approach.transitions[j];
          for (let k = 0; k < transition.legs.length; k++) {
            const leg = transition.legs[k];
            if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
              const region = ICAO.getRegionCode(leg.fixIcao);
              if (AirportUtils.REGION_CODES.has(region)) {
                return region;
              }
            }
          }
        }
      }
      return void 0;
    }
    static getElevation(facility) {
      if (facility.runways.length === 0) {
        return void 0;
      }
      return facility.runways.reduce((sum2, runway) => sum2 + runway.elevation, 0) / facility.runways.length;
    }
    static getLongestRunway(facility) {
      let longestRunway = null;
      for (const runway of facility.runways) {
        if (longestRunway === null || runway.length > longestRunway.length) {
          longestRunway = runway;
        }
      }
      return longestRunway;
    }
    static getFilteredRunways(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      const result = [];
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils2.getSurfaceCategory(runway), surfaceTypes)) {
            result.push(runway);
          }
        }
      }
      return result;
    }
    static hasMatchingRunway(facility, minLength, surfaceTypes) {
      minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
      for (const runway of facility.runways) {
        if (runway.length >= minLength) {
          if (surfaceTypes === void 0 || BitFlags.isAny(RunwayUtils2.getSurfaceCategory(runway), surfaceTypes)) {
            return true;
          }
        }
      }
      return false;
    }
  };
  AirportUtils.REGION_CODES = /* @__PURE__ */ new Set([
    "AG",
    "AN",
    "AY",
    "BG",
    "BI",
    "BK",
    "CY",
    "DA",
    "DB",
    "DF",
    "DG",
    "DI",
    "DN",
    "DR",
    "DT",
    "DX",
    "EB",
    "ED",
    "EE",
    "EF",
    "EG",
    "EH",
    "EI",
    "EK",
    "EL",
    "EN",
    "EP",
    "ES",
    "ET",
    "EV",
    "EY",
    "FA",
    "FB",
    "FC",
    "FD",
    "FE",
    "FG",
    "FH",
    "FI",
    "FJ",
    "FK",
    "FL",
    "FM",
    "FN",
    "FO",
    "FP",
    "FQ",
    "FS",
    "FT",
    "FV",
    "FW",
    "FX",
    "FY",
    "FZ",
    "GA",
    "GB",
    "GC",
    "GE",
    "GF",
    "GG",
    "GL",
    "GM",
    "GO",
    "GQ",
    "GS",
    "GU",
    "GV",
    "HA",
    "HB",
    "HD",
    "HE",
    "HH",
    "HK",
    "HL",
    "HR",
    "HS",
    "HT",
    "HU",
    "K1",
    "K2",
    "K3",
    "K4",
    "K5",
    "K6",
    "K7",
    "LA",
    "LB",
    "LC",
    "LD",
    "LE",
    "LF",
    "LG",
    "LH",
    "LI",
    "LJ",
    "LK",
    "LL",
    "LM",
    "LO",
    "LP",
    "LQ",
    "LR",
    "LS",
    "LT",
    "LU",
    "LV",
    "LW",
    "LX",
    "LY",
    "LZ",
    "MB",
    "MD",
    "MG",
    "MH",
    "MK",
    "MM",
    "MN",
    "MP",
    "MR",
    "MS",
    "MT",
    "MU",
    "MW",
    "MY",
    "MZ",
    "NC",
    "NF",
    "NG",
    "NI",
    "NL",
    "NS",
    "NT",
    "NV",
    "NW",
    "NZ",
    "OA",
    "OB",
    "OE",
    "OI",
    "OJ",
    "OK",
    "OL",
    "OM",
    "OO",
    "OP",
    "OR",
    "OS",
    "OT",
    "OY",
    "PA",
    "PG",
    "PH",
    "PJ",
    "PK",
    "PL",
    "PM",
    "PO",
    "PP",
    "PT",
    "PW",
    "RC",
    "RJ",
    "RK",
    "RO",
    "RP",
    "SA",
    "SB",
    "SC",
    "SD",
    "SE",
    "SG",
    "SI",
    "SJ",
    "SK",
    "SL",
    "SM",
    "SO",
    "SP",
    "SS",
    "SU",
    "SV",
    "SW",
    "SY",
    "TA",
    "TB",
    "TD",
    "TF",
    "TG",
    "TI",
    "TJ",
    "TK",
    "TL",
    "TN",
    "TQ",
    "TT",
    "TU",
    "TV",
    "TX",
    "UA",
    "UB",
    "UC",
    "UD",
    "UE",
    "UG",
    "UH",
    "UI",
    "UK",
    "UL",
    "UM",
    "UN",
    "UO",
    "UR",
    "US",
    "UT",
    "UU",
    "UW",
    "VA",
    "VC",
    "VD",
    "VE",
    "VG",
    "VH",
    "VI",
    "VL",
    "VM",
    "VN",
    "VO",
    "VR",
    "VT",
    "VV",
    "VY",
    "WA",
    "WB",
    "WI",
    "WM",
    "WR",
    "WS",
    "YB",
    "YM",
    "ZB",
    "ZG",
    "ZH",
    "ZK",
    "ZL",
    "ZM",
    "ZP",
    "ZS",
    "ZU",
    "ZW",
    "ZY"
  ]);
  AirportUtils.NUMERAL_REGEX = /\d/;
  var AirspaceType;
  (function(AirspaceType2) {
    AirspaceType2[AirspaceType2["None"] = 0] = "None";
    AirspaceType2[AirspaceType2["Center"] = 1] = "Center";
    AirspaceType2[AirspaceType2["ClassA"] = 2] = "ClassA";
    AirspaceType2[AirspaceType2["ClassB"] = 3] = "ClassB";
    AirspaceType2[AirspaceType2["ClassC"] = 4] = "ClassC";
    AirspaceType2[AirspaceType2["ClassD"] = 5] = "ClassD";
    AirspaceType2[AirspaceType2["ClassE"] = 6] = "ClassE";
    AirspaceType2[AirspaceType2["ClassF"] = 7] = "ClassF";
    AirspaceType2[AirspaceType2["ClassG"] = 8] = "ClassG";
    AirspaceType2[AirspaceType2["Tower"] = 9] = "Tower";
    AirspaceType2[AirspaceType2["Clearance"] = 10] = "Clearance";
    AirspaceType2[AirspaceType2["Ground"] = 11] = "Ground";
    AirspaceType2[AirspaceType2["Departure"] = 12] = "Departure";
    AirspaceType2[AirspaceType2["Approach"] = 13] = "Approach";
    AirspaceType2[AirspaceType2["MOA"] = 14] = "MOA";
    AirspaceType2[AirspaceType2["Restricted"] = 15] = "Restricted";
    AirspaceType2[AirspaceType2["Prohibited"] = 16] = "Prohibited";
    AirspaceType2[AirspaceType2["Warning"] = 17] = "Warning";
    AirspaceType2[AirspaceType2["Alert"] = 18] = "Alert";
    AirspaceType2[AirspaceType2["Danger"] = 19] = "Danger";
    AirspaceType2[AirspaceType2["Nationalpark"] = 20] = "Nationalpark";
    AirspaceType2[AirspaceType2["ModeC"] = 21] = "ModeC";
    AirspaceType2[AirspaceType2["Radar"] = 22] = "Radar";
    AirspaceType2[AirspaceType2["Training"] = 23] = "Training";
    AirspaceType2[AirspaceType2["Max"] = 24] = "Max";
  })(AirspaceType || (AirspaceType = {}));
  var CoherentAirspace = class {
    constructor(def, uid) {
      this.name = "";
      this._segments = [];
      this.type = def.type;
      this.uid = uid;
      const segments = def.segments;
      const len = segments.length;
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        this._segments[i] = new GeoPoint(point.lat, point.long);
      }
    }
    get segments() {
      return this._segments;
    }
    equals(other) {
      if (other instanceof CoherentAirspace) {
        return this.uid === other.uid;
      }
      return this.type === other.type && this.segments.length === other.segments.length && this.segments.every((point, index) => point.equals(other.segments[index]));
    }
  };
  var AirspaceSearcher = class {
    constructor(cacheSize = AirspaceSearcher.DEFAULT_CACHE_SIZE) {
      this.cacheSize = cacheSize;
      this.cache = /* @__PURE__ */ new Map();
      this._isBusy = false;
      this.queue = [];
    }
    isBusy() {
      return this._isBusy;
    }
    search(center) {
      return new Promise((resolve) => {
        if (this._isBusy || this.queue.length > 0) {
          this.enqueueSearch(center, resolve);
        } else {
          this.doSearch(center, resolve);
        }
      });
    }
    enqueueSearch(center, resolve) {
      this.queue.push(this.doSearch.bind(this, center, resolve));
    }
    processQueue() {
      const next = this.queue.shift();
      if (next) {
        next();
      }
    }
    async doSearch(center, resolve) {
      this._isBusy = true;
      try {
        const coherentDefs = await Promise.race([
          this.executeCoherentSearch(center),
          new Promise((timeoutResolve, reject) => setTimeout(() => reject("Airspace search timed out."), AirspaceSearcher.SEARCH_TIMEOUT))
        ]);
        const airspaces = this.processCoherentDefs(coherentDefs);
        resolve(airspaces);
      } catch (e) {
        resolve([]);
      }
      this._isBusy = false;
      this.processQueue();
    }
    async executeCoherentSearch(center) {
      await Coherent.call("SET_LOAD_LATLON", center.lat, center.lon);
      return await Coherent.call("GET_NEAREST_AIRSPACES");
    }
    processCoherentDefs(defs) {
      const result = [];
      const len = defs.length;
      for (let i = 0; i < len; i++) {
        const def = defs[i];
        if (def.type === AirspaceType.None) {
          continue;
        }
        const uid = AirspaceSearcher.generateUID(def);
        let airspace = this.cache.get(uid);
        if (!airspace) {
          airspace = new CoherentAirspace(def, uid);
          this.cacheAirspace(airspace);
        }
        result.push(airspace);
      }
      return result;
    }
    cacheAirspace(airspace) {
      this.cache.set(airspace.uid, airspace);
      if (this.cache.size > this.cacheSize) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    static generateUID(def) {
      const segments = def.segments;
      let uid = `${def.type}[${segments.length}]:`;
      const len = Math.min(segments.length - 1, 10);
      for (let i = 0; i < len; i++) {
        const point = segments[i];
        uid += `(${point.lat},${point.long})`;
      }
      if (len < segments.length - 1) {
        const point = segments[segments.length - 2];
        uid += `(${point.lat},${point.long})`;
      }
      return uid;
    }
  };
  AirspaceSearcher.SEARCH_TIMEOUT = 5e3;
  AirspaceSearcher.DEFAULT_CACHE_SIZE = 1e3;
  var MSFSAPStates;
  (function(MSFSAPStates2) {
    MSFSAPStates2[MSFSAPStates2["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates2[MSFSAPStates2["APOn"] = 2] = "APOn";
    MSFSAPStates2[MSFSAPStates2["FDOn"] = 4] = "FDOn";
    MSFSAPStates2[MSFSAPStates2["FLC"] = 8] = "FLC";
    MSFSAPStates2[MSFSAPStates2["Alt"] = 16] = "Alt";
    MSFSAPStates2[MSFSAPStates2["AltArm"] = 32] = "AltArm";
    MSFSAPStates2[MSFSAPStates2["GS"] = 64] = "GS";
    MSFSAPStates2[MSFSAPStates2["GSArm"] = 128] = "GSArm";
    MSFSAPStates2[MSFSAPStates2["Pitch"] = 256] = "Pitch";
    MSFSAPStates2[MSFSAPStates2["VS"] = 512] = "VS";
    MSFSAPStates2[MSFSAPStates2["Heading"] = 1024] = "Heading";
    MSFSAPStates2[MSFSAPStates2["Nav"] = 2048] = "Nav";
    MSFSAPStates2[MSFSAPStates2["NavArm"] = 4096] = "NavArm";
    MSFSAPStates2[MSFSAPStates2["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates2[MSFSAPStates2["Attitude"] = 16384] = "Attitude";
    MSFSAPStates2[MSFSAPStates2["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates2[MSFSAPStates2["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates2[MSFSAPStates2["ATArm"] = 131072] = "ATArm";
    MSFSAPStates2[MSFSAPStates2["YD"] = 262144] = "YD";
    MSFSAPStates2[MSFSAPStates2["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates2[MSFSAPStates2["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates2[MSFSAPStates2["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates2[MSFSAPStates2["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates2[MSFSAPStates2["Bank"] = 8388608] = "Bank";
    MSFSAPStates2[MSFSAPStates2["FBW"] = 16777216] = "FBW";
    MSFSAPStates2[MSFSAPStates2["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates2[MSFSAPStates2["None"] = -2147483648] = "None";
  })(MSFSAPStates || (MSFSAPStates = {}));
  var airportIcaoRegionPattern = new RegExp(/^A../);
  var FacilityTypeSearchType = {
    [FacilityType.Airport]: FacilitySearchType.Airport,
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    [FacilityType.VOR]: FacilitySearchType.Vor,
    [FacilityType.USR]: FacilitySearchType.User,
    [FacilityType.VIS]: FacilitySearchType.Visual
  };
  var FacilityLoader = class {
    constructor(facilityRepo, onInitialized = () => {
    }) {
      this.facilityRepo = facilityRepo;
      this.onInitialized = onInitialized;
      if (FacilityLoader.facilityListener === void 0) {
        FacilityLoader.facilityListener = RegisterViewListener("JS_LISTENER_FACILITY", () => {
          FacilityLoader.facilityListener.on("SendAirport", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendIntersection", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendVor", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("SendNdb", FacilityLoader.onFacilityReceived);
          FacilityLoader.facilityListener.on("NearestSearchCompleted", FacilityLoader.onNearestSearchCompleted);
          setTimeout(() => FacilityLoader.init(), 2e3);
        }, true);
      }
      this.awaitInitialization().then(() => this.onInitialized());
    }
    static init() {
      FacilityLoader.isInitialized = true;
      for (const resolve of this.initPromiseResolveQueue) {
        resolve();
      }
      this.initPromiseResolveQueue.length = 0;
    }
    awaitInitialization() {
      if (FacilityLoader.isInitialized) {
        return Promise.resolve();
      } else {
        return new Promise((resolve) => {
          FacilityLoader.initPromiseResolveQueue.push(resolve);
        });
      }
    }
    getFacility(type, icao) {
      switch (type) {
        case FacilityType.USR:
        case FacilityType.RWY:
        case FacilityType.VIS:
          return this.getFacilityFromRepo(type, icao);
        default:
          return this.getFacilityFromCoherent(type, icao);
      }
    }
    async getFacilityFromRepo(type, icao) {
      const fac = this.facilityRepo.get(icao);
      if (fac) {
        return fac;
      } else if (type === FacilityType.RWY) {
        try {
          const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
          const runway = RunwayUtils2.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
          if (runway) {
            const runwayFac = RunwayUtils2.createRunwayFacility(airport, runway);
            this.facilityRepo.add(runwayFac);
            return runwayFac;
          }
        } catch (e) {
        }
      }
      throw `Facility ${icao} could not be found.`;
    }
    async getFacilityFromCoherent(type, icao) {
      const isMismatch = ICAO.getFacilityType(icao) !== type;
      if (type === FacilityType.Airport) {
        icao = icao.replace(airportIcaoRegionPattern, "A  ");
      }
      let queue = FacilityLoader.requestQueue;
      let cache = FacilityLoader.facCache;
      if (isMismatch) {
        queue = FacilityLoader.mismatchRequestQueue;
        cache = FacilityLoader.typeMismatchFacCache;
      }
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const cachedFac = cache.get(icao);
      if (cachedFac !== void 0) {
        return Promise.resolve(cachedFac);
      }
      const currentTime = Date.now();
      let request = queue.get(icao);
      if (request === void 0 || currentTime - request.timeStamp > 1e4) {
        if (request !== void 0) {
          request.reject(`Facility request for ${icao} has timed out.`);
        }
        let resolve = void 0;
        let reject = void 0;
        const promise = new Promise((resolution, rejection) => {
          resolve = resolution;
          reject = rejection;
          Coherent.call(type, icao).then((isValid) => {
            if (!isValid) {
              rejection(`Facility ${icao} could not be found.`);
              queue.delete(icao);
            }
          });
        });
        request = { promise, timeStamp: currentTime, resolve, reject };
        queue.set(icao, request);
      }
      return request.promise;
    }
    async getAirway(airwayName, airwayType, icao) {
      if (FacilityLoader.airwayCache.has(airwayName)) {
        const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
        const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
          w.icao === icao;
        });
        if (match !== void 0 && cachedAirway !== void 0) {
          return cachedAirway;
        }
      }
      const fac = await this.getFacility(FacilityType.Intersection, icao);
      const route = fac.routes.find((r) => r.name === airwayName);
      if (route !== void 0) {
        const airwayBuilder = new AirwayBuilder(fac, route, this);
        const status = await airwayBuilder.startBuild();
        if (status === AirwayStatus.COMPLETE) {
          const waypoints = airwayBuilder.waypoints;
          if (waypoints !== null) {
            const airway = new AirwayObject(airwayName, airwayType);
            airway.waypoints = [...waypoints];
            FacilityLoader.addToAirwayCache(airway);
            return airway;
          }
        }
      }
      throw new Error("Airway could not be found.");
    }
    async startNearestSearchSession(type) {
      switch (type) {
        case FacilitySearchType.User:
        case FacilitySearchType.Visual:
          return this.startRepoNearestSearchSession(type);
        case FacilitySearchType.AllExceptVisual:
          return this.startCoherentNearestSearchSession(FacilitySearchType.All);
        default:
          return this.startCoherentNearestSearchSession(type);
      }
    }
    async startCoherentNearestSearchSession(type) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const sessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", type);
      let session;
      switch (type) {
        case FacilitySearchType.Airport:
          session = new NearestAirportSearchSession(sessionId);
          break;
        case FacilitySearchType.Intersection:
          session = new NearestIntersectionSearchSession(sessionId);
          break;
        case FacilitySearchType.Vor:
          session = new NearestVorSearchSession(sessionId);
          break;
        case FacilitySearchType.Boundary:
          session = new NearestBoundarySearchSession(sessionId);
          break;
        default:
          session = new CoherentNearestSearchSession(sessionId);
          break;
      }
      FacilityLoader.searchSessions.set(sessionId, session);
      return session;
    }
    startRepoNearestSearchSession(type) {
      const sessionId = FacilityLoader.repoSearchSessionId--;
      switch (type) {
        case FacilitySearchType.User:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        case FacilitySearchType.Visual:
          return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
        default:
          throw new Error();
      }
    }
    async getMetar(arg) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const ident = typeof arg === "string" ? arg : ICAO.getIdent(arg.icao);
      const metar = await Coherent.call("GET_METAR_BY_IDENT", ident);
      return FacilityLoader.cleanMetar(metar);
    }
    async searchMetar(lat, lon) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      const metar = await Coherent.call("GET_METAR_BY_LATLON", lat, lon);
      return FacilityLoader.cleanMetar(metar);
    }
    static cleanMetar(raw) {
      if (raw.icao === "") {
        return void 0;
      }
      raw.gust < 0 && delete raw.gust;
      raw.vertVis < 0 && delete raw.vertVis;
      isNaN(raw.altimeterA) && delete raw.altimeterA;
      raw.altimeterQ < 0 && delete raw.altimeterQ;
      isNaN(raw.slp) && delete raw.slp;
      return raw;
    }
    async searchByIdent(filter, ident, maxItems = 40) {
      if (!FacilityLoader.isInitialized) {
        await this.awaitInitialization();
      }
      let results;
      if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
        const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
        results = await Coherent.call("SEARCH_BY_IDENT", ident, coherentFilter, maxItems);
      } else {
        results = [];
      }
      const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
      if (facRepositorySearchTypes) {
        this.facilityRepo.forEach((fac) => {
          const facIdent = ICAO.getIdent(fac.icao);
          if (facIdent === ident) {
            results.unshift(fac.icao);
          } else if (facIdent.startsWith(ident)) {
            results.push(fac.icao);
          }
        }, facRepositorySearchTypes);
      }
      return results;
    }
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
      const results = await this.searchByIdent(filter, ident, maxItems);
      if (!results) {
        return [];
      }
      const promises = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i];
        const facIdent = ICAO.getIdent(icao);
        if (facIdent === ident) {
          const facType = ICAO.getFacilityType(icao);
          promises.push(this.getFacility(facType, icao));
        }
      }
      const foundFacilities = await Promise.all(promises);
      if (foundFacilities.length > 1) {
        foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
        return foundFacilities;
      } else if (foundFacilities.length === 1) {
        return foundFacilities;
      } else {
        return [];
      }
    }
    static onFacilityReceived(facility) {
      const isMismatch = facility["__Type"] === "JS_FacilityIntersection" && facility.icao[0] !== "W";
      const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
      const request = queue.get(facility.icao);
      if (request !== void 0) {
        request.resolve(facility);
        FacilityLoader.addToFacilityCache(facility, isMismatch);
        queue.delete(facility.icao);
      }
    }
    static onNearestSearchCompleted(results) {
      const session = FacilityLoader.searchSessions.get(results.sessionId);
      if (session instanceof CoherentNearestSearchSession) {
        session.onSearchCompleted(results);
      }
    }
    static addToFacilityCache(fac, isTypeMismatch) {
      const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
      cache.set(fac.icao, fac);
      if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
        cache.delete(cache.keys().next().value);
      }
    }
    static addToAirwayCache(airway) {
      FacilityLoader.airwayCache.set(airway.name, airway);
      if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
        FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
      }
    }
  };
  FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1e3;
  FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1e3;
  FacilityLoader.requestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.mismatchRequestQueue = /* @__PURE__ */ new Map();
  FacilityLoader.facCache = /* @__PURE__ */ new Map();
  FacilityLoader.typeMismatchFacCache = /* @__PURE__ */ new Map();
  FacilityLoader.airwayCache = /* @__PURE__ */ new Map();
  FacilityLoader.searchSessions = /* @__PURE__ */ new Map();
  FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
  };
  FacilityLoader.repoSearchSessionId = -1;
  FacilityLoader.isInitialized = false;
  FacilityLoader.initPromiseResolveQueue = [];
  var CoherentNearestSearchSession = class {
    constructor(sessionId) {
      this.sessionId = sessionId;
      this.searchQueue = /* @__PURE__ */ new Map();
    }
    searchNearest(lat, lon, radius, maxItems) {
      const promise = new Promise((resolve) => {
        Coherent.call("SEARCH_NEAREST", this.sessionId, lat, lon, radius, maxItems).then((searchId) => {
          this.searchQueue.set(searchId, { promise, resolve });
        });
      });
      return promise;
    }
    onSearchCompleted(results) {
      const request = this.searchQueue.get(results.searchId);
      if (request !== void 0) {
        request.resolve(results);
        this.searchQueue.delete(results.searchId);
      }
    }
  };
  var NearestAirportSearchSession = class extends CoherentNearestSearchSession {
    setAirportFilter(showClosed, classMask) {
      Coherent.call("SET_NEAREST_AIRPORT_FILTER", this.sessionId, showClosed ? 1 : 0, classMask);
    }
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      Coherent.call("SET_NEAREST_EXTENDED_AIRPORT_FILTERS", this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
  };
  NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
  };
  var NearestIntersectionSearchSession = class extends CoherentNearestSearchSession {
    setIntersectionFilter(typeMask) {
      Coherent.call("SET_NEAREST_INTERSECTION_FILTER", this.sessionId, typeMask);
    }
  };
  NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
  };
  var NearestVorSearchSession = class extends CoherentNearestSearchSession {
    setVorFilter(classMask, typeMask) {
      Coherent.call("SET_NEAREST_VOR_FILTER", this.sessionId, classMask, typeMask);
    }
  };
  NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
  };
  var NearestBoundarySearchSession = class extends CoherentNearestSearchSession {
    setBoundaryFilter(classMask) {
      Coherent.call("SET_NEAREST_BOUNDARY_FILTER", this.sessionId, classMask);
    }
  };
  var NearestRepoFacilitySearchSession = class {
    constructor(repo, sessionId) {
      this.repo = repo;
      this.sessionId = sessionId;
      this.filter = void 0;
      this.cachedResults = /* @__PURE__ */ new Set();
      this.searchId = 0;
    }
    searchNearest(lat, lon, radius, maxItems) {
      const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
      const added = [];
      for (let i = 0; i < results.length; i++) {
        const icao = results[i].icao;
        if (this.cachedResults.has(icao)) {
          this.cachedResults.delete(icao);
        } else {
          added.push(icao);
        }
      }
      const removed = Array.from(this.cachedResults);
      this.cachedResults.clear();
      for (let i = 0; i < results.length; i++) {
        this.cachedResults.add(results[i].icao);
      }
      return Promise.resolve({
        sessionId: this.sessionId,
        searchId: this.searchId++,
        added,
        removed
      });
    }
    setUserFacilityFilter(filter) {
      this.filter = filter;
    }
  };
  var AirwayObject = class {
    constructor(name69, type) {
      this._waypoints = [];
      this._name = name69;
      this._type = type;
    }
    get name() {
      return this._name;
    }
    get type() {
      return this._type;
    }
    get waypoints() {
      return this._waypoints;
    }
    set waypoints(waypoints) {
      this._waypoints = waypoints;
    }
  };
  var AirwayStatus;
  (function(AirwayStatus2) {
    AirwayStatus2[AirwayStatus2["INCOMPLETE"] = 0] = "INCOMPLETE";
    AirwayStatus2[AirwayStatus2["COMPLETE"] = 1] = "COMPLETE";
    AirwayStatus2[AirwayStatus2["PARTIAL"] = 2] = "PARTIAL";
  })(AirwayStatus || (AirwayStatus = {}));
  var AirwayBuilder = class {
    constructor(_initialWaypoint, _initialData, facilityLoader) {
      this._initialWaypoint = _initialWaypoint;
      this._initialData = _initialData;
      this.facilityLoader = facilityLoader;
      this._waypointsArray = [];
      this._hasStarted = false;
      this._isDone = false;
    }
    get hasStarted() {
      return this._hasStarted;
    }
    get isDone() {
      return this._isDone;
    }
    get waypoints() {
      return this._waypointsArray;
    }
    async _step(stepForward, arrayInsertFunc) {
      let isDone = false;
      let current = this._initialData;
      while (!isDone && current) {
        const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
        if (nextICAO && nextICAO.length > 0 && nextICAO[0] != " " && this._waypointsArray !== null && !this._waypointsArray.find((waypoint) => waypoint.icao === nextICAO)) {
          const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
          arrayInsertFunc(fac);
          const next = fac.routes.find((route) => route.name === current.name);
          if (next !== void 0) {
            current = next;
          } else {
            isDone = true;
          }
        } else {
          isDone = true;
        }
      }
    }
    async _stepForward() {
      if (this._waypointsArray !== null) {
        return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
      }
    }
    async _stepBackward() {
      if (this._waypointsArray !== null) {
        return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
      }
    }
    setWaypointsArray(array) {
      this._waypointsArray = array;
    }
    startBuild() {
      if (this.hasStarted) {
        return Promise.reject(new Error("Airway builder has already started building."));
      }
      return new Promise((resolve) => {
        this._hasStarted = true;
        if (this._waypointsArray !== null) {
          this._waypointsArray.push(this._initialWaypoint);
          Promise.all([
            this._stepForward(),
            this._stepBackward()
          ]).then(() => {
            this._isDone = true;
            resolve(AirwayStatus.COMPLETE);
          }).catch(() => {
            this._isDone = true;
            resolve(AirwayStatus.PARTIAL);
          });
        }
      });
    }
  };
  var ArrayUtils = class {
    static create(length, init2) {
      const newArray = [];
      for (let i = 0; i < length; i++) {
        newArray[i] = init2(i);
      }
      return newArray;
    }
    static at(array, index) {
      if (index < 0) {
        index += array.length;
      }
      if (index < 0 || index >= array.length) {
        throw new RangeError();
      }
      return array[index];
    }
    static peekAt(array, index) {
      if (index < 0) {
        index += array.length;
      }
      return array[index];
    }
    static first(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[0];
    }
    static peekFirst(array) {
      return array[0];
    }
    static last(array) {
      if (array.length === 0) {
        throw new RangeError();
      }
      return array[array.length - 1];
    }
    static peekLast(array) {
      return array[array.length - 1];
    }
    static includes(array, searchElement, fromIndex) {
      return array.includes(searchElement, fromIndex);
    }
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalsFunc(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    static flatMap(array, map) {
      const out = [];
      for (let i = 0; i < array.length; i++) {
        const mapped = map(array[i], i, array);
        if (Array.isArray(mapped)) {
          for (let j = 0; j < mapped.length; j++) {
            out[out.length] = mapped[j];
          }
        } else {
          out[out.length] = mapped;
        }
      }
      return out;
    }
    static flat(array, depth = 1) {
      const out = [];
      this.flatHelper(array, depth, 0, out);
      return out;
    }
    static flatHelper(array, maxDepth, depth, out) {
      for (let i = 0; i < array.length; i++) {
        const element = array[i];
        if (Array.isArray(element) && depth < maxDepth) {
          this.flatHelper(element, maxDepth, depth + 1, out);
        } else {
          out[out.length] = element;
        }
      }
    }
    static shallowCopy(source, target = []) {
      target.length = source.length;
      for (let i = 0; i < source.length; i++) {
        target[i] = source[i];
      }
      return target;
    }
    static binarySearch(array, element, comparator, first = true) {
      let min2 = 0;
      let max2 = array.length;
      let index = Math.floor((min2 + max2) / 2);
      while (min2 < max2) {
        const compare = comparator(element, array[index]);
        if (compare < 0) {
          max2 = index;
        } else if (compare > 0) {
          min2 = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min2 + max2) / 2);
      }
      return -(index + 1);
    }
    static getMaxStringLength(array) {
      return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
  };
  ArrayUtils.STRICT_EQUALS = (a, b) => a === b;
  var BinaryHeap = class {
    constructor(comparator) {
      this.comparator = comparator;
      this.tree = [];
    }
    get size() {
      return this.tree.length;
    }
    findMin() {
      return this.tree[0];
    }
    removeMin() {
      if (this.tree.length === 0) {
        return void 0;
      }
      const min2 = this.tree[0];
      this.swap(0, this.tree.length - 1);
      this.tree.length--;
      this.heapifyDown(0);
      return min2;
    }
    insert(element) {
      this.tree.push(element);
      this.heapifyUp(this.tree.length - 1);
      return this;
    }
    insertAndRemoveMin(element) {
      if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
        return element;
      }
      return this.removeMinAndInsert(element);
    }
    removeMinAndInsert(element) {
      const min2 = this.tree[0];
      this.tree[0] = element;
      this.heapifyDown(0);
      return min2;
    }
    clear() {
      this.tree.length = 0;
      return this;
    }
    heapifyUp(index) {
      let parent = BinaryHeap.parent(index);
      while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
        this.swap(parent, index);
        index = parent;
        parent = BinaryHeap.parent(index);
      }
    }
    heapifyDown(index) {
      const len = this.tree.length;
      while (index < len) {
        const left = BinaryHeap.left(index);
        const right = BinaryHeap.right(index);
        let needSwapFlags = 0;
        if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
          needSwapFlags |= 1;
        }
        if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
          needSwapFlags |= 2;
        }
        if (needSwapFlags === 3) {
          needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
        }
        if (needSwapFlags === 0) {
          break;
        }
        const swapChild = needSwapFlags === 1 ? left : right;
        this.swap(index, swapChild);
        index = swapChild;
      }
    }
    swap(index1, index2) {
      const old1 = this.tree[index1];
      this.tree[index1] = this.tree[index2];
      this.tree[index2] = old1;
    }
    static parent(index) {
      return index - 1 >> 1;
    }
    static left(index) {
      return index * 2 + 1;
    }
    static right(index) {
      return index * 2 + 2;
    }
  };
  var SortedArray = class {
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
      this.comparatorFunc = comparatorFunc;
      this.equalityFunc = equalityFunc;
      this._array = [];
    }
    get array() {
      return this._array;
    }
    get length() {
      return this._array.length;
    }
    findIndex(element, first = true) {
      let min2 = 0;
      let max2 = this._array.length;
      let index = Math.floor((min2 + max2) / 2);
      while (min2 < max2) {
        const compare = this.comparatorFunc(element, this._array[index]);
        if (compare < 0) {
          max2 = index;
        } else if (compare > 0) {
          min2 = index + 1;
        } else {
          const delta = first ? -1 : 1;
          while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
            index += delta;
          }
          return index;
        }
        index = Math.floor((min2 + max2) / 2);
      }
      return -(index + 1);
    }
    searchEquals(element, startIndex) {
      let index = startIndex;
      while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
        if (this.equalityFunc(element, this._array[index])) {
          return index;
        }
        index++;
      }
      return -1;
    }
    get(index) {
      if (index < 0 || index >= this._array.length) {
        throw new RangeError();
      }
      return this._array[index];
    }
    peek(index) {
      return this._array[index];
    }
    first() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[0];
    }
    peekFirst() {
      return this._array[0];
    }
    last() {
      if (this._array.length === 0) {
        throw new RangeError();
      }
      return this._array[this._array.length - 1];
    }
    peekLast() {
      return this._array[this._array.length - 1];
    }
    has(element) {
      return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    insert(element) {
      let index = this.findIndex(element, false);
      if (index < 0) {
        index = -index - 1;
      }
      this._array.splice(index, 0, element);
      return index;
    }
    insertAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let toInsertIndex = 0;
      let toInsert = sorted[toInsertIndex];
      const len = this._array.length;
      const insertLen = sorted.length;
      for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
        if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
          this._array.splice(i, 0, toInsert);
          toInsert = sorted[++toInsertIndex];
        }
      }
      for (; toInsertIndex < insertLen; toInsertIndex++) {
        this._array.push(sorted[toInsertIndex]);
      }
      return sorted.length;
    }
    remove(element) {
      const index = this.searchEquals(element, this.findIndex(element));
      if (index >= 0) {
        this._array.splice(index, 1);
      }
      return index;
    }
    removeAll(elements) {
      const sorted = Array.from(elements).sort(this.comparatorFunc);
      let numRemoved = 0;
      let toRemoveIndex = 0;
      let toRemove = sorted[toRemoveIndex];
      const len = this._array.length;
      const removeLen = sorted.length;
      for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
        if (this.equalityFunc(toRemove, this._array[i])) {
          this._array.splice(i--, 1);
          toRemove = sorted[++toRemoveIndex];
          numRemoved++;
        }
      }
      return numRemoved;
    }
    removeAt(index) {
      if (index < 0 || index >= this._array.length) {
        return void 0;
      }
      return this._array.splice(index, 1)[0];
    }
    pop() {
      return this._array.pop();
    }
    shift() {
      return this._array.shift();
    }
    resort() {
      this._array.sort(this.comparatorFunc);
    }
    indexOf(element) {
      return this.searchEquals(element, this.findIndex(element));
    }
    match(query) {
      const index = this.matchIndex(query);
      return this._array[index];
    }
    matchIndex(query) {
      return this.findIndex(query);
    }
    clear() {
      this._array.length = 0;
    }
    values() {
      return this._array.values();
    }
    [Symbol.iterator]() {
      return this._array.values();
    }
  };
  SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
  var LerpLookupTable = class {
    constructor(arg) {
      this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg === "number") {
        this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
        return;
      }
      const leastDimension = arg.reduce((accum, current) => current.length < accum.length ? current : accum);
      this._dimensionCount = Math.max(0, leastDimension ? leastDimension.length - 1 : 0);
      if (this._dimensionCount === 0) {
        return;
      }
      for (let i = 0; i < arg.length; i++) {
        this.insertBreakpoint(arg[i]);
      }
    }
    get dimensionCount() {
      return this._dimensionCount;
    }
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    get(...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table);
      if (value === void 0) {
        throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    lookupHelper(key, dimension, lookupArray) {
      const dimensionKey = key[dimension];
      const query = LerpLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array);
        endValue = this.lookupHelper(key, dimension + 1, end.array);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      if (startValue === endValue) {
        return startValue;
      }
      return MathUtils2.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpLookupTable.tempBreakpoint = { key: 0 };
  var LerpVectorLookupTable = class {
    constructor(arg1, arg2) {
      var _a, _b;
      this.table = new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR);
      if (typeof arg1 === "number") {
        this._dimensionCount = isFinite(arg1) ? 0 : Math.max(0, arg1);
        this._vectorLength = isFinite(arg2) ? 0 : Math.max(0, arg2);
      } else {
        let leastBreakpointDimension = Infinity;
        let leastVectorLength = Infinity;
        for (let i = 0; i < arg1.length; i++) {
          leastBreakpointDimension = Math.min(leastBreakpointDimension, Math.max(arg1[i].length - 1, 0));
          leastVectorLength = Math.min(leastVectorLength, (_b = (_a = arg1[i][0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        }
        this._dimensionCount = isFinite(leastBreakpointDimension) ? leastBreakpointDimension : 0;
        this._vectorLength = isFinite(leastVectorLength) ? leastVectorLength : 0;
        if (this._dimensionCount > 0) {
          for (let i = 0; i < arg1.length; i++) {
            this.insertBreakpoint(arg1[i]);
          }
        }
      }
      this.tempVectors = ArrayUtils.create(this._dimensionCount * 2, () => new Float64Array(this._vectorLength));
    }
    get dimensionCount() {
      return this._dimensionCount;
    }
    get vectorLength() {
      return this._vectorLength;
    }
    insertBreakpoint(breakpoint) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot insert a breakpoint into a 0-dimensional table");
      }
      if (breakpoint.length - 1 < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
      }
      if (breakpoint[0].length < this._vectorLength) {
        throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint[0].length}-length vector into a table with vectors of length ${this._vectorLength}`);
      }
      this.insertBreakpointHelper(breakpoint, 0, this.table);
      return this;
    }
    insertBreakpointHelper(breakpoint, dimension, array) {
      const dimensionKey = breakpoint[dimension + 1];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      if (dimension === this._dimensionCount - 1) {
        let match = array.match(query);
        if (!match) {
          match = { key: dimensionKey, value: breakpoint[0] };
          array.insert(match);
        }
      } else {
        let next = array.match(query);
        if (!next) {
          array.insert(next = { key: dimensionKey, array: new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR) });
        }
        this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
      }
    }
    get(out, ...key) {
      if (this._dimensionCount === 0) {
        throw new Error("LerpVectorLookupTable: cannot look up a key in a 0-dimensional table");
      }
      if (key.length < this._dimensionCount) {
        throw new Error(`LerpVectorLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
      }
      const value = this.lookupHelper(key, 0, this.table, out);
      if (value === void 0) {
        throw new Error(`LerpVectorLookupTable: could not retrieve value for key ${key}`);
      }
      return value;
    }
    lookupHelper(key, dimension, lookupArray, out) {
      const dimensionKey = key[dimension];
      const query = LerpVectorLookupTable.tempBreakpoint;
      query.key = dimensionKey;
      const index = lookupArray.matchIndex(query);
      let start;
      let end;
      if (index >= 0) {
        start = lookupArray.peek(index);
        end = start;
      } else {
        start = lookupArray.peek(-index - 2);
        end = lookupArray.peek(-index - 1);
        if (!start) {
          start = end;
        }
        if (!end) {
          end = start;
        }
      }
      if (!start || !end) {
        return void 0;
      }
      let startValue;
      let endValue;
      if (dimension === this.dimensionCount - 1) {
        startValue = start.value;
        endValue = end.value;
      } else {
        startValue = this.lookupHelper(key, dimension + 1, start.array, this.tempVectors[dimension * 2]);
        endValue = this.lookupHelper(key, dimension + 1, end.array, this.tempVectors[dimension * 2 + 1]);
      }
      if (startValue === void 0 || endValue === void 0) {
        return void 0;
      }
      return MathUtils2.lerpVector(out, dimensionKey, start.key, end.key, startValue, endValue);
    }
  };
  LerpVectorLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
  LerpVectorLookupTable.tempBreakpoint = { key: 0 };
  var KdTree = class {
    constructor(dimensionCount, keyFunc) {
      this.keyFunc = keyFunc;
      this.elements = [];
      this.keys = [];
      this.nodes = [];
      this.minDepth = -1;
      this.maxDepth = -1;
      this.dimensionCount = Math.trunc(dimensionCount);
      if (this.dimensionCount < 2) {
        throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
      }
      this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
      this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
        return (a, b) => {
          const aKey = this.keys[a];
          const bKey = this.keys[b];
          for (let i = 0; i < this.dimensionCount; i++) {
            const dimension = (i + index) % this.dimensionCount;
            if (aKey[dimension] < bKey[dimension]) {
              return -1;
            } else if (aKey[dimension] > bKey[dimension]) {
              return 1;
            }
          }
          return 0;
        };
      });
      this.keyCache = [
        new Float64Array(this.dimensionCount)
      ];
    }
    get size() {
      return this.elements.length;
    }
    searchKey(key, radius, arg3, out, filter) {
      if (typeof arg3 === "number") {
        return this.doResultsSearch(void 0, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(void 0, key, radius, arg3);
      }
    }
    search(element, radius, arg3, out, filter) {
      const key = this.keyFunc(element, this.keyCache[0]);
      if (typeof arg3 === "number") {
        return this.doResultsSearch(element, key, radius, arg3, out, filter);
      } else {
        this.doVisitorSearch(element, key, radius, arg3);
      }
    }
    doVisitorSearch(element, key, radius, visitor) {
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        return visitor(elementInner, keyInner, distance, queryKey, queryElement);
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        return searchRadius + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
      if (maxResultCount <= 0) {
        out.length = 0;
        return out;
      }
      const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
      const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
        if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
          if (heap.size === maxResultCount) {
            heap.insertAndRemoveMin(elementIndex);
          } else {
            heap.insert(elementIndex);
          }
        }
        return true;
      };
      const traversalHandler = (offsetFromPivot, searchRadius, child) => {
        let maxDist = searchRadius;
        if (heap.size === maxResultCount) {
          maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
        }
        return maxDist + offsetFromPivot * child >= 0;
      };
      this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
      out.length = heap.size;
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = this.elements[heap.removeMin()];
      }
      return out;
    }
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
      const elementIndex = this.nodes[nodeIndex];
      if (elementIndex === void 0) {
        return true;
      }
      const nodeKey = this.keys[elementIndex];
      const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
      if (distanceFromNode <= radius) {
        if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
          return false;
        }
      }
      const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      const lesserNodeIndex = KdTree.lesser(nodeIndex);
      const greaterNodeIndex = KdTree.greater(nodeIndex);
      if (this.nodes[lesserNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, -1)) {
        if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      if (this.nodes[greaterNodeIndex] !== void 0 && traversalHandler(offsetFromPivot, radius, 1)) {
        if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
          return false;
        }
      }
      return true;
    }
    insert(element) {
      const insertDepth = this.insertElementInTree(element) + 1;
      this.maxDepth = Math.max(this.maxDepth, insertDepth);
      if (insertDepth === this.minDepth + 1) {
        this.minDepth = KdTree.depth(this.nodes.indexOf(void 0, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
      }
      if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
        this.rebuild();
      }
    }
    insertAll(elements) {
      for (const element of elements) {
        this.elements.push(element);
        this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
        const insertedIndex = this.elements.length - 1;
        for (let i = 0; i < this.dimensionCount; i++) {
          this.indexArrays[i].push(insertedIndex);
        }
      }
      this.rebuild();
    }
    insertElementInTree(element) {
      const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
      let index = 0;
      let depth = 0;
      let elementIndex;
      while ((elementIndex = this.nodes[index]) !== void 0) {
        const pivotDimension = depth % this.dimensionCount;
        const keyToCompare = key[pivotDimension];
        if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
          index = KdTree.lesser(index);
        } else {
          index = KdTree.greater(index);
        }
        depth++;
      }
      this.elements.push(element);
      this.keys.push(key);
      const insertedIndex = this.elements.length - 1;
      this.nodes[index] = insertedIndex;
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].push(insertedIndex);
      }
      return depth;
    }
    remove(element) {
      if (!this.removeElementFromArrays(element)) {
        return false;
      }
      this.resetIndexArrays();
      this.rebuild();
      return true;
    }
    removeAll(elements) {
      let removed = false;
      for (const element of elements) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
        this.rebuild();
      }
      return removed;
    }
    removeElementFromArrays(element) {
      const index = this.elements.indexOf(element);
      if (index < 0) {
        return false;
      }
      const lastIndex = this.elements.length - 1;
      this.elements[index] = this.elements[lastIndex];
      this.keys[index] = this.keys[lastIndex];
      this.elements.length--;
      this.keys.length--;
      return true;
    }
    resetIndexArrays() {
      for (let i = 0; i < this.dimensionCount; i++) {
        const array = this.indexArrays[i];
        array.length = this.elements.length;
        for (let j = 0; j < array.length; j++) {
          array[j] = j;
        }
      }
    }
    removeAndInsert(toRemove, toInsert) {
      let removed = false;
      for (const element of toRemove) {
        removed = this.removeElementFromArrays(element) || removed;
      }
      if (removed) {
        this.resetIndexArrays();
      }
      this.insertAll(toInsert);
    }
    rebuild() {
      this.nodes.length = 0;
      if (this.size === 0) {
        return;
      }
      for (let i = 0; i < this.dimensionCount; i++) {
        this.indexArrays[i].sort(this.indexSortFuncs[i]);
      }
      this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
      const log3 = Math.log2(this.elements.length + 1);
      this.minDepth = Math.floor(log3) - 1;
      this.maxDepth = Math.ceil(log3) - 1;
    }
    buildSubTree(nodeIndex, pivotDimension, start, end) {
      const tempArray = this.indexArrays[this.dimensionCount];
      const sortedArray = this.indexArrays[0];
      const medianIndex = Math.trunc((start + end) / 2);
      const medianKeyIndex = sortedArray[medianIndex];
      this.nodes[nodeIndex] = medianKeyIndex;
      if (end - start === 1) {
        return;
      }
      if (end - start <= 3) {
        const lesserIndex = medianIndex - 1;
        const greaterIndex = medianIndex + 1;
        if (lesserIndex >= start) {
          this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
        }
        if (greaterIndex < end) {
          this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
        }
        return;
      }
      for (let i = start; i < end; i++) {
        tempArray[i] = sortedArray[i];
      }
      for (let i = 1; i < this.dimensionCount; i++) {
        const targetArray = this.indexArrays[i - 1];
        const toPartitionArray = this.indexArrays[i];
        let lesserCount = 0;
        let greaterCount = 0;
        for (let j = start; j < end; j++) {
          const keyIndex = toPartitionArray[j];
          if (keyIndex === medianKeyIndex) {
            targetArray[medianIndex] = keyIndex;
          } else {
            const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
            if (comparison <= 0) {
              const index = start + lesserCount++;
              targetArray[index] = keyIndex;
            } else {
              const index = medianIndex + 1 + greaterCount++;
              targetArray[index] = keyIndex;
            }
          }
        }
      }
      const newSortedArray = this.indexArrays[this.dimensionCount - 1];
      for (let i = start; i < end; i++) {
        newSortedArray[i] = tempArray[i];
      }
      const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
      this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
      this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    clear() {
      this.elements.length = 0;
      this.keys.length = 0;
      this.nodes.length = 0;
      for (let i = 0; i < this.indexArrays.length; i++) {
        this.indexArrays[i].length = 0;
      }
      this.minDepth = -1;
      this.maxDepth = -1;
    }
    static parent(index) {
      return index - 1 >> 1;
    }
    static lesser(index) {
      return index * 2 + 1;
    }
    static greater(index) {
      return index * 2 + 2;
    }
    static leastIndexAtDepth(depth) {
      return 1 << depth - 1;
    }
    static depth(index) {
      return Math.trunc(Math.log2(index + 1));
    }
    static distance(key1, key2, dimensionCount) {
      let sumSq = 0;
      for (let i = 0; i < dimensionCount; i++) {
        const diff = key1[i] - key2[i];
        sumSq += diff * diff;
      }
      return Math.sqrt(sumSq);
    }
  };
  var GeoKdTree = class {
    constructor(keyFunc) {
      this.keyFunc = keyFunc;
      this.cartesianTree = new KdTree(3, (element, out) => {
        const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
        out[0] = vec[0];
        out[1] = vec[1];
        out[2] = vec[2];
        return out;
      });
    }
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
      let center, radius;
      let argA, argB, argC;
      if (typeof arg1 === "number") {
        center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
        radius = arg3;
        argA = arg4;
        argB = arg5;
        argC = arg6;
      } else if (!(arg1 instanceof Float64Array)) {
        center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      } else {
        center = arg1;
        radius = arg2;
        argA = arg3;
        argB = arg4;
        argC = arg5;
      }
      const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
      if (typeof argA === "number") {
        return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
      } else {
        this.doVisitorSearch(center, radiusCartesian, argA);
      }
    }
    doVisitorSearch(center, radiusCartesian, visitor) {
      this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return visitor(element, vec, greatCircleDist, center);
      });
    }
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
      const cartesianFilter = filter ? (element, key) => {
        const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
        const greatCircleDist = GeoPoint.distance(vec, center);
        return filter(element, vec, greatCircleDist, center);
      } : void 0;
      return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    insert(element) {
      this.cartesianTree.insert(element);
    }
    insertAll(elements) {
      this.cartesianTree.insertAll(elements);
    }
    remove(element) {
      return this.cartesianTree.remove(element);
    }
    removeAll(elements) {
      return this.cartesianTree.removeAll(elements);
    }
    removeAndInsert(toRemove, toInsert) {
      this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    rebuild() {
      this.cartesianTree.rebuild();
    }
    clear() {
      this.cartesianTree.clear();
    }
  };
  GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  var SubscribableArrayEventType;
  (function(SubscribableArrayEventType2) {
    SubscribableArrayEventType2["Added"] = "Added";
    SubscribableArrayEventType2["Removed"] = "Removed";
    SubscribableArrayEventType2["Cleared"] = "Cleared";
  })(SubscribableArrayEventType || (SubscribableArrayEventType = {}));
  var AbstractSubscribableArray = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub2 = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub2);
      if (paused) {
        sub2.pause();
      } else if (initialNotify) {
        sub2.initialNotify();
      }
      return sub2;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub2) => sub2.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    get(index) {
      const array = this.getArray();
      if (index > array.length - 1) {
        throw new Error("Index out of range");
      }
      return array[index];
    }
    tryGet(index) {
      return this.getArray()[index];
    }
    notify(index, type, modifiedItem) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub2 = this.subs[i];
          if (sub2.isAlive && !sub2.isPaused) {
            sub2.handler(index, type, modifiedItem, this.getArray());
          }
          needCleanUpSubs || (needCleanUpSubs = !sub2.isAlive);
        } catch (error) {
          console.error(`ArraySubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub2) => sub2.isAlive);
      }
    }
    initialNotify(sub2) {
      const array = this.getArray();
      sub2.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    onSubDestroyed(sub2) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub2), 1);
      }
    }
  };
  var FacilityRepositorySyncType;
  (function(FacilityRepositorySyncType2) {
    FacilityRepositorySyncType2["Add"] = "Add";
    FacilityRepositorySyncType2["Remove"] = "Remove";
    FacilityRepositorySyncType2["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType2["DumpResponse"] = "DumpResponse";
  })(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
  var FacilityRepository = class {
    constructor(bus) {
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.repos = /* @__PURE__ */ new Map();
      this.trees = {
        [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc)
      };
      this.ignoreSync = false;
      bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
      this.pubSyncEvent({
        type: FacilityRepositorySyncType.DumpRequest,
        uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
      });
    }
    size(types) {
      var _a, _b;
      let size2 = 0;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          size2 += repo.size;
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          size2 += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
        }
      }
      return size2;
    }
    get(icao) {
      var _a;
      if (!ICAO.isFacility(icao)) {
        return void 0;
      }
      return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    search(type, lat, lon, radius, arg5, out, filter) {
      if (type !== FacilityType.USR && type !== FacilityType.VIS) {
        throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
      }
      if (typeof arg5 === "number") {
        return this.trees[type].search(lat, lon, radius, arg5, out, filter);
      } else {
        this.trees[type].search(lat, lon, radius, arg5);
      }
    }
    add(fac) {
      if (!ICAO.isFacility(fac.icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
      }
      this.addToRepo(fac);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    addMultiple(facs) {
      this.addMultipleToRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    remove(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      if (!ICAO.isFacility(icao)) {
        throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
      }
      this.removeFromRepo(icao);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    removeMultiple(facs) {
      this.removeMultipleFromRepo(facs);
      this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map((fac) => typeof fac === "object" ? fac.icao : fac) });
    }
    forEach(fn, types) {
      var _a;
      if (types === void 0) {
        for (const repo of this.repos.values()) {
          repo.forEach(fn);
        }
      } else {
        for (let i = 0; i < types.length; i++) {
          (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
        }
      }
    }
    addToRepo(fac) {
      const facilityType = ICAO.getFacilityType(fac.icao);
      let repo = this.repos.get(facilityType);
      if (repo === void 0) {
        this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
      }
      const existing = repo.get(fac.icao);
      repo.set(fac.icao, fac);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        if (existing === void 0) {
          this.trees[facilityType].insert(fac);
        } else {
          this.trees[facilityType].removeAndInsert([existing], [fac]);
        }
      }
      if (existing === void 0) {
        this.publisher.pub("facility_added", fac, false, false);
      } else {
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    addMultipleToRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const addedFacilities = [];
      const changedFacilitiesRemoved = [];
      const changedFacilitiesAdded = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === void 0) {
          this.repos.set(facilityType, repo = /* @__PURE__ */ new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (existing === void 0) {
          addedFacilities.push(fac);
        } else {
          changedFacilitiesRemoved.push(existing);
          changedFacilitiesAdded.push(fac);
        }
      }
      const addedUserFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (addedUserFacilities.length > 0) {
        const removedUserFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
      }
      const addedVisFacilities = facs.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (addedVisFacilities.length > 0) {
        const removedVisFacilities = changedFacilitiesRemoved.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
      }
      for (let i = 0; i < addedFacilities.length; i++) {
        const fac = addedFacilities[i];
        this.publisher.pub("facility_added", fac, false, false);
      }
      for (let i = 0; i < changedFacilitiesAdded.length; i++) {
        const fac = changedFacilitiesAdded[i];
        this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
        this.publisher.pub("facility_changed", fac, false, false);
      }
    }
    removeFromRepo(fac) {
      const icao = typeof fac === "string" ? fac : fac.icao;
      const facilityType = ICAO.getFacilityType(icao);
      const repo = this.repos.get(ICAO.getFacilityType(icao));
      if (repo === void 0) {
        return;
      }
      const facilityInRepo = repo.get(icao);
      if (facilityInRepo === void 0) {
        return;
      }
      repo.delete(icao);
      if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
        this.trees[facilityType].remove(facilityInRepo);
      }
      this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
      this.publisher.pub("facility_removed", facilityInRepo, false, false);
    }
    removeMultipleFromRepo(facs) {
      if (facs.length === 0) {
        return;
      }
      const removedFacilities = [];
      for (let i = 0; i < facs.length; i++) {
        const fac = facs[i];
        const icao = typeof fac === "string" ? fac : fac.icao;
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === void 0) {
          continue;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === void 0) {
          continue;
        }
        repo.delete(icao);
        removedFacilities.push(facilityInRepo);
      }
      const removedUserFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.USR));
      if (removedUserFacilities.length > 0) {
        this.trees[FacilityType.USR].removeAll(removedUserFacilities);
      }
      const removedVisFacilities = removedFacilities.filter((fac) => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
      if (removedVisFacilities.length > 0) {
        this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
      }
      for (let i = 0; i < removedFacilities.length; i++) {
        const removedFac = removedFacilities[i];
        this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
        this.publisher.pub("facility_removed", removedFac, false, false);
      }
    }
    pubSyncEvent(data) {
      this.ignoreSync = true;
      this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
      this.ignoreSync = false;
    }
    onSyncEvent(data) {
      if (this.ignoreSync) {
        return;
      }
      switch (data.type) {
        case FacilityRepositorySyncType.DumpResponse:
          if (data.uid !== this.lastDumpRequestUid) {
            break;
          } else {
            this.lastDumpRequestUid = void 0;
          }
        case FacilityRepositorySyncType.Add:
          if (data.facs.length === 1) {
            this.addToRepo(data.facs[0]);
          } else {
            this.addMultipleToRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.Remove:
          if (data.facs.length === 1) {
            this.removeFromRepo(data.facs[0]);
          } else {
            this.removeMultipleFromRepo(data.facs);
          }
          break;
        case FacilityRepositorySyncType.DumpRequest:
          if (data.uid !== this.lastDumpRequestUid) {
            const facs = [];
            this.forEach((fac) => facs.push(fac));
            this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
          }
          break;
      }
    }
    static getRepository(bus) {
      var _a;
      return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : FacilityRepository.INSTANCE = new FacilityRepository(bus);
    }
  };
  FacilityRepository.SYNC_TOPIC = "facilityrepo_sync";
  FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
  };
  var HoldEntryType;
  (function(HoldEntryType2) {
    HoldEntryType2[HoldEntryType2["Direct"] = 0] = "Direct";
    HoldEntryType2[HoldEntryType2["Teardrop"] = 1] = "Teardrop";
    HoldEntryType2[HoldEntryType2["Parallel"] = 2] = "Parallel";
    HoldEntryType2[HoldEntryType2["None"] = 3] = "None";
  })(HoldEntryType || (HoldEntryType = {}));
  var HoldMaxSpeedRule;
  (function(HoldMaxSpeedRule2) {
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Faa"] = 0] = "Faa";
    HoldMaxSpeedRule2[HoldMaxSpeedRule2["Icao"] = 1] = "Icao";
  })(HoldMaxSpeedRule || (HoldMaxSpeedRule = {}));
  var SubscribableUtils = class {
    static isSubscribable(query) {
      return typeof query === "object" && query !== null && query.isSubscribable === true;
    }
    static isMutableSubscribable(query) {
      return typeof query === "object" && query !== null && query.isMutableSubscribable === true;
    }
    static toSubscribable(value, excludeSubscribables) {
      if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
        return value;
      } else {
        return Subject.create(value);
      }
    }
  };
  SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || isNaN(a) && isNaN(b);
  var facilitySearchTypeMap = /* @__PURE__ */ new Map([
    [FacilitySearchType.Airport, FacilityType.Airport],
    [FacilitySearchType.Intersection, FacilityType.Intersection],
    [FacilitySearchType.Vor, FacilityType.VOR],
    [FacilitySearchType.Ndb, FacilityType.NDB],
    [FacilitySearchType.User, FacilityType.USR]
  ]);
  var AbstractNearestSubscription = class extends AbstractSubscribableArray {
    constructor(facilityLoader, type) {
      super();
      this.facilityLoader = facilityLoader;
      this.type = type;
      this.facilities = [];
      this.facilityIndex = /* @__PURE__ */ new Map();
      this.startPromiseResolves = [];
      this.updatePromiseResolves = [];
      this.hasRequestedSession = false;
      this.searchInProgress = false;
    }
    get length() {
      return this.facilities.length;
    }
    get started() {
      return this.session !== void 0;
    }
    getArray() {
      return this.facilities;
    }
    awaitStart() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        this.startPromiseResolves.push(resolve);
      });
    }
    start() {
      if (this.session !== void 0) {
        return Promise.resolve();
      }
      if (this.hasRequestedSession) {
        return this.awaitStart();
      }
      return new Promise((resolve) => {
        this.hasRequestedSession = true;
        this.startPromiseResolves.push(resolve);
        this.facilityLoader.startNearestSearchSession(this.type).then((session) => {
          this.session = session;
          this.startPromiseResolves.forEach((queuedResolve) => {
            queuedResolve();
          });
          this.startPromiseResolves.length = 0;
        });
      });
    }
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      if (!this.started) {
        await this.start();
      }
      const results = await this.session.searchNearest(lat, lon, radius, maxItems);
      await this.onResults(results);
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    addFacility(facility, key) {
      if (this.facilityIndex.has(key)) {
        console.warn(`Facility ${key} is already in the collection.`);
      }
      this.facilities.push(facility);
      this.facilityIndex.set(key, facility);
      this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, facility);
    }
    removeFacility(key) {
      const facility = this.facilityIndex.get(key);
      if (facility !== void 0) {
        const index = this.facilities.indexOf(facility);
        this.facilities.splice(index, 1);
        this.facilityIndex.delete(key);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Removed, facility);
      }
    }
  };
  var NearestWaypointSubscription = class extends AbstractNearestSubscription {
    constructor(facilityLoader, type, filterCb) {
      super(facilityLoader, type);
      this.facilityCache = /* @__PURE__ */ new Map();
      this.filterCb = filterCb;
    }
    setFilterCb(filter) {
      this.filterCb = filter;
      this.refilter();
    }
    refilter() {
      if (this.filterCb) {
        for (const icao of this.facilityIndex.keys()) {
          if (!this.filterCb(this.facilityIndex.get(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
          this.addFacility(this.facilityCache.get(icao), icao);
        }
      }
    }
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          this.facilityCache.set(added[i].icao, added[i]);
          if (this.filterCb === void 0 || this.filterCb(added[i])) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestAirportSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader, filterCb) {
      super(facilityLoader, FacilitySearchType.Airport, filterCb);
    }
    setFilter(showClosed, classMask) {
      if (this.session !== void 0) {
        this.session.setAirportFilter(showClosed, classMask);
      }
    }
    setExtendedFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
      if (this.session !== void 0) {
        this.session.setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
      }
    }
  };
  var NearestIntersectionSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader, filterCb, filterDupTerminal = false) {
      super(facilityLoader, FacilitySearchType.Intersection, filterCb);
      this.nonTerminalIcaosToFilter = /* @__PURE__ */ new Set();
      this.filterDupTerminal = filterDupTerminal;
    }
    setFilter(typeMask) {
      if (this.session !== void 0) {
        this.session.setIntersectionFilter(typeMask);
      }
    }
    setFilterDupTerminal(filter) {
      if (filter === this.filterDupTerminal) {
        return;
      }
      this.filterDupTerminal = filter;
      this.refilter();
    }
    refilter() {
      this.nonTerminalIcaosToFilter.clear();
      if (this.filterDupTerminal) {
        for (const icao of this.facilityCache.keys()) {
          if (ICAO.isFacility(icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(icao) && (this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao)))) {
            this.nonTerminalIcaosToFilter.add(icao);
          }
        }
      }
      if (this.filterCb || this.filterDupTerminal) {
        for (const icao of this.facilityIndex.keys()) {
          if (this.filterCb && !this.filterCb(this.facilityIndex.get(icao)) || this.filterDupTerminal && ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) && this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao))) {
            this.removeFacility(icao);
          }
        }
      }
      for (const icao of this.facilityCache.keys()) {
        if (!this.facilityIndex.get(icao)) {
          if ((this.filterCb === void 0 || this.filterCb(this.facilityCache.get(icao))) && (!this.filterDupTerminal || !ICAO.isFacility(icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(icao) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao)))) {
            this.addFacility(this.facilityCache.get(icao), icao);
          }
        }
      }
    }
    async onResults(results) {
      const facilityType = facilitySearchTypeMap.get(this.type);
      if (facilityType !== void 0) {
        const added = await Promise.all(results.added.map((icao) => this.facilityLoader.getFacility(facilityType, icao)));
        for (let i = 0; i < results.removed.length; i++) {
          this.nonTerminalIcaosToFilter.delete(results.removed[i]);
          this.facilityCache.delete(results.removed[i]);
          this.removeFacility(results.removed[i]);
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          this.facilityCache.set(fac.icao, fac);
          if (this.filterDupTerminal && ICAO.isFacility(fac.icao, FacilityType.Intersection) && !IntersectionFacilityUtils.isTerminal(fac) && (this.filterCb === void 0 || this.filterCb(fac))) {
            this.nonTerminalIcaosToFilter.add(fac.icao);
          }
        }
        for (let i = 0; i < added.length; i++) {
          const fac = added[i];
          if ((this.filterCb === void 0 || this.filterCb(fac)) && (!this.filterDupTerminal || !ICAO.isFacility(fac.icao, FacilityType.Intersection) || !IntersectionFacilityUtils.isTerminal(fac) || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(fac.icao)))) {
            this.addFacility(added[i], added[i].icao);
          }
        }
      }
    }
  };
  var NearestVorSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Vor);
    }
    setVorFilter(classMask, typeMask) {
      if (this.session !== void 0) {
        this.session.setVorFilter(classMask, typeMask);
      }
    }
  };
  var NearestNdbSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.Ndb);
    }
  };
  var NearestUsrSubscription = class extends NearestWaypointSubscription {
    constructor(facilityLoader) {
      super(facilityLoader, FacilitySearchType.User);
    }
  };
  var AdaptiveNearestSubscription = class extends AbstractSubscribableArray {
    constructor(innerSubscription, absoluteMaxItems) {
      super();
      this.innerSubscription = innerSubscription;
      this.sortFunc = (a, b) => this.pos.distance(a) - this.pos.distance(b);
      this.facilities = [];
      this.derivedMaxItems = 0;
      this.searchInProgress = false;
      this.pos = new GeoPoint(0, 0);
      this.diffMap = /* @__PURE__ */ new Map();
      this.updatePromiseResolves = [];
      this.absoluteMaxItems = SubscribableUtils.toSubscribable(absoluteMaxItems, true);
    }
    get length() {
      return this.facilities.length;
    }
    getArray() {
      return this.facilities;
    }
    get started() {
      return this.innerSubscription.started;
    }
    awaitStart() {
      return this.innerSubscription.awaitStart();
    }
    start() {
      return this.innerSubscription.start();
    }
    update(lat, lon, radius, maxItems) {
      return new Promise((resolve) => {
        this.updatePromiseResolves.push(resolve);
        if (this.searchInProgress) {
          return;
        }
        this.doUpdate(lat, lon, radius, maxItems);
      });
    }
    async doUpdate(lat, lon, radius, maxItems) {
      this.searchInProgress = true;
      this.pos.set(lat, lon);
      maxItems = Math.max(0, maxItems);
      if (maxItems > this.derivedMaxItems) {
        this.derivedMaxItems = maxItems;
      }
      await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
      if (this.innerSubscription.length > maxItems) {
        this.derivedMaxItems = Math.max(Math.round(this.derivedMaxItems - this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_DOWN_FACTOR), maxItems);
      } else {
        const absoluteMaxItems = this.absoluteMaxItems.get();
        while (this.innerSubscription.length < maxItems && this.derivedMaxItems < absoluteMaxItems) {
          this.derivedMaxItems = Math.min(Math.round(this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_UP_FACTOR), absoluteMaxItems);
          await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
        }
      }
      if (this.innerSubscription.length > maxItems) {
        if (maxItems > 1) {
          const sorted = Array.from(this.innerSubscription.getArray()).sort(this.sortFunc);
          sorted.length = maxItems;
          this.diffAndNotify(sorted);
        } else if (maxItems === 1) {
          this.diffAndNotify([this.findNearest(this.innerSubscription.getArray())]);
        } else {
          this.diffAndNotify(AdaptiveNearestSubscription.EMPTY_ARRAY);
        }
      } else {
        this.diffAndNotify(this.innerSubscription.getArray());
      }
      this.searchInProgress = false;
      this.updatePromiseResolves.forEach((resolve) => {
        resolve();
      });
      this.updatePromiseResolves.length = 0;
    }
    findNearest(array) {
      let nearest = array[0];
      let nearestDistance = this.pos.distance(nearest);
      for (let i = 1; i < array.length; i++) {
        const fac = array[i];
        const distance = this.pos.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    diffAndNotify(newArray) {
      if (this.facilities.length === 0 && newArray.length === 0) {
        return;
      }
      if (newArray.length === 0) {
        this.facilities.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
        return;
      }
      if (this.facilities.length === 0) {
        for (let i = 0; i < newArray.length; i++) {
          this.facilities[i] = newArray[i];
        }
        this.facilities.length = newArray.length;
        this.notify(0, SubscribableArrayEventType.Added, this.facilities);
        return;
      }
      for (let i = 0; i < newArray.length; i++) {
        this.diffMap.set(newArray[i].icao, newArray[i]);
      }
      for (let i = this.facilities.length - 1; i >= 0; i--) {
        const old = this.facilities[i];
        if (this.diffMap.has(old.icao)) {
          this.diffMap.delete(old.icao);
        } else {
          this.facilities.splice(i, 1);
          this.notify(i, SubscribableArrayEventType.Removed, old);
        }
      }
      for (const toAdd of this.diffMap.values()) {
        this.facilities.push(toAdd);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, toAdd);
      }
      this.diffMap.clear();
    }
  };
  AdaptiveNearestSubscription.RAMP_UP_FACTOR = 1.33;
  AdaptiveNearestSubscription.RAMP_DOWN_FACTOR = 0.1;
  AdaptiveNearestSubscription.EMPTY_ARRAY = [];
  var LodBoundary = class {
    constructor(facility, lodDistanceThresholds, lodVectorCountTargets) {
      this.facility = facility;
      this.lodDistanceThresholds = (lodDistanceThresholds === null || lodDistanceThresholds === void 0 ? void 0 : lodDistanceThresholds.length) ? [...lodDistanceThresholds] : [0];
      this.lodVectorCountTargets = lodVectorCountTargets ? [...lodVectorCountTargets] : [];
      this.lods = this.processLods();
    }
    processLods() {
      var _a;
      const lodShapes = [];
      const originalShapes = this.processShapes(this.facility.vectors);
      if (Array.isArray(this.facility.lods)) {
        lodShapes.push(originalShapes);
        for (let i = 0; i < this.facility.lods.length; i++) {
          lodShapes.push(this.processShapes(this.facility.lods[i]));
        }
      } else {
        let startIndex = 0;
        if (this.lodDistanceThresholds[0] === 0 && ((_a = this.lodVectorCountTargets[0]) !== null && _a !== void 0 ? _a : 0) <= 0) {
          lodShapes.push(originalShapes);
          startIndex = 1;
        }
        const len = this.lodDistanceThresholds.length;
        for (let i = startIndex; i < len; i++) {
          lodShapes.push(this.simplifyShapes(originalShapes, this.lodDistanceThresholds[i], this.lodVectorCountTargets[i]));
        }
      }
      return lodShapes;
    }
    processShapes(vectors) {
      const shapes = [];
      const len = vectors.length;
      let index = 0;
      let currentShape;
      while (index < len) {
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            currentShape = [];
            index = this.processShape(currentShape, vectors, index);
            shapes.push(currentShape);
            break;
          case BoundaryVectorType.Circle:
            currentShape = [];
            index = this.processCircle(currentShape, vectors, index - 1);
            shapes.push(currentShape);
            break;
        }
        index++;
      }
      return shapes;
    }
    processShape(shape, vectors, index) {
      const start = vectors[index++];
      shape.push({ end: new GeoPoint(start.lat, start.lon) });
      const origins = [];
      const len = vectors.length;
      while (index < len) {
        const lastEndpoint = shape[shape.length - 1].end;
        const vector = vectors[index];
        switch (vector.type) {
          case BoundaryVectorType.Start:
            break;
          case BoundaryVectorType.Line:
            if (!lastEndpoint.equals(vector)) {
              shape.push({ circle: GeoCircle.createGreatCircle(lastEndpoint, vector), end: new GeoPoint(vector.lat, vector.lon) });
            }
            break;
          case BoundaryVectorType.Origin:
            origins[vector.originId] = vector;
            break;
          case BoundaryVectorType.ArcCCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const radius = end.distance(origin);
            shape.push({ circle: GeoCircle.createFromPoint(origin, radius), end });
            break;
          }
          case BoundaryVectorType.ArcCW: {
            const origin = origins[vector.originId];
            const end = new GeoPoint(vector.lat, vector.lon);
            const circle = GeoCircle.createFromPoint(origin, end.distance(origin)).reverse();
            shape.push({ circle, end });
            break;
          }
          case BoundaryVectorType.Circle:
            return index - 1;
        }
        index++;
      }
      return index - 1;
    }
    processCircle(shape, vectors, index) {
      const originVector = vectors[index];
      const circleVector = vectors[index + 1];
      if (originVector.type === BoundaryVectorType.Origin && circleVector.originId === originVector.originId) {
        const radius = UnitType.METER.convertTo(circleVector.radius, UnitType.GA_RADIAN);
        const circle = GeoCircle.createFromPoint(originVector, radius);
        const isCenterPole = circle.center[0] === 0 && circle.center[1] === 0 && Math.abs(circle.center[2]) === 1;
        const end = isCenterPole ? new GeoPoint(0, 0) : new GeoPoint(90, 0);
        circle.closest(end, end);
        shape.push({ end });
        shape.push({ circle, end });
      }
      return index + 1;
    }
    simplifyShapes(shapes, distanceThreshold, vectorCountTarget) {
      const simplified = [];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        simplified.push(this.simplifyShape(shapes[i], distanceThreshold, vectorCountTarget));
      }
      return simplified;
    }
    simplifyShape(shape, distanceThreshold, vectorCountTarget) {
      if (shape.length < 3) {
        return shape;
      }
      const simplified = [];
      const retain = [];
      retain[0] = true;
      retain[shape.length - 1] = true;
      if (vectorCountTarget === void 0 || vectorCountTarget <= 0) {
        this.simplify(distanceThreshold, shape, 0, shape.length, retain);
      } else {
        this.simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, 0, shape.length, retain);
      }
      this.rebuildSimplifiedVectors(shape, retain, simplified);
      return simplified;
    }
    simplify(distanceThreshold, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.index < 0) {
        return;
      }
      if (farthest.distance >= distanceThreshold) {
        retain[farthest.index] = true;
        this.simplify(distanceThreshold, shape, startIndex, farthest.index + 1, retain);
        this.simplify(distanceThreshold, shape, farthest.index, endIndex, retain);
      }
    }
    simplifyToVectorCount(distanceThreshold, vectorCountTarget, shape, startIndex, endIndex, retain) {
      if (startIndex + 1 >= endIndex) {
        return;
      }
      const queue = LodBoundary.queue;
      queue.clear();
      let edgeIndex = 0;
      let currentStartIndex = startIndex;
      let currentEndIndex = endIndex;
      let currentFarthestIndex;
      let retainCount = 2;
      while (retainCount < vectorCountTarget) {
        if (currentFarthestIndex === void 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentEndIndex, queue, edgeIndex++);
        } else if (currentFarthestIndex >= 0) {
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentStartIndex, currentFarthestIndex + 1, queue, edgeIndex++);
          this.computeAndInsertEdgeToQueue(distanceThreshold, shape, currentFarthestIndex, currentEndIndex, queue, edgeIndex++);
        }
        if (queue.size === 0) {
          break;
        }
        const edge = queue.removeMin();
        currentStartIndex = edge.startIndex;
        currentEndIndex = edge.endIndex;
        currentFarthestIndex = edge.farthestVectorIndex;
        retain[currentFarthestIndex] = true;
        retainCount++;
      }
    }
    computeAndInsertEdgeToQueue(distanceThreshold, shape, startIndex, endIndex, queue, edgeIndex) {
      var _a;
      var _b;
      const start = shape[startIndex].end;
      const end = shape[endIndex - 1].end;
      const reference = start.equals(end) ? start : LodBoundary.geoCircleCache[0].setAsGreatCircle(start, end);
      const farthest = this.findFarthestVector(shape, startIndex + 1, endIndex - 1, reference);
      if (farthest.distance >= distanceThreshold) {
        const edge = (_a = (_b = LodBoundary.edgeCache)[edgeIndex]) !== null && _a !== void 0 ? _a : _b[edgeIndex] = LodBoundary.createEdge();
        edge.startIndex = startIndex;
        edge.endIndex = endIndex;
        edge.farthestVectorIndex = farthest.index;
        edge.distanceToFarthestVector = farthest.distance;
        queue.insert(edge);
      }
    }
    findFarthestVector(shape, startIndex, endIndex, reference) {
      let maxDistance = 0;
      let index = -1;
      for (let i = startIndex; i < endIndex; i++) {
        const distance = this.getDistanceFromReference(shape, i, reference);
        if (distance > maxDistance) {
          index = i;
          maxDistance = distance;
        }
      }
      return { index, distance: maxDistance };
    }
    getDistanceFromReference(shape, index, reference) {
      const vector = shape[index];
      if (!vector.circle) {
        return reference instanceof GeoCircle ? Math.abs(reference.distance(vector.end)) : reference.distance(vector.end);
      } else {
        const center = reference instanceof GeoCircle ? reference.center : reference;
        const arcStart = shape[index - 1].end;
        const maxAngularDist = vector.circle.angleAlong(arcStart, vector.end, Math.PI);
        const projectedAngularDist = vector.circle.angleAlong(arcStart, center, Math.PI);
        const oppositeAngularDist = (projectedAngularDist + Math.PI) % (2 * Math.PI);
        let arcDistance;
        if (oppositeAngularDist > 0 && oppositeAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center) + vector.circle.radius * 2);
          arcDistance = Math.min(arcDistance, 2 * Math.PI - arcDistance);
        } else if (projectedAngularDist > 0 && projectedAngularDist < maxAngularDist) {
          arcDistance = Math.abs(vector.circle.distance(center));
        }
        if (reference instanceof GeoCircle) {
          return arcDistance ? Math.abs(arcDistance - Math.PI / 2) : Math.abs(reference.distance(vector.end));
        } else {
          return arcDistance !== null && arcDistance !== void 0 ? arcDistance : vector.end.distance(reference);
        }
      }
    }
    rebuildSimplifiedVectors(shape, retain, simplified) {
      var _a;
      let lastRetained;
      const len = shape.length;
      for (let i = 0; i < len; i++) {
        if (!retain[i]) {
          continue;
        }
        const currentVector = shape[i];
        if (currentVector) {
          const prevRetain = retain[i - 1];
          const prevVector = shape[i - 1];
          if (!prevRetain) {
            if (lastRetained) {
              if (currentVector.circle && !currentVector.circle.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, prevVector.end), end: prevVector.end });
                simplified.push(LodBoundary.copyVector(currentVector));
              } else if ((_a = currentVector.circle) === null || _a === void 0 ? void 0 : _a.isGreatCircle()) {
                simplified.push({ circle: GeoCircle.createGreatCircle(lastRetained.end, currentVector.end), end: currentVector.end });
              } else {
                simplified.push(LodBoundary.copyVector(currentVector));
              }
            } else {
              simplified.push({ end: currentVector.end });
            }
          } else {
            simplified.push(LodBoundary.copyVector(currentVector));
          }
          lastRetained = currentVector;
        }
      }
    }
    static copyVector(source) {
      return { circle: source.circle ? new GeoCircle(source.circle.center, source.circle.radius) : void 0, end: source.end.copy() };
    }
    static createEdge() {
      return {
        startIndex: -1,
        endIndex: -1,
        farthestVectorIndex: -1,
        distanceToFarthestVector: 0
      };
    }
  };
  LodBoundary.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  LodBoundary.edgeCache = [];
  LodBoundary.queue = new BinaryHeap((a, b) => b.distanceToFarthestVector - a.distanceToFarthestVector);
  var LodBoundaryCache = class {
    constructor(size2, lodDistanceThresholds, lodVectorCountTargets) {
      this.size = size2;
      this.lodDistanceThresholds = lodDistanceThresholds;
      this.lodVectorCountTargets = lodVectorCountTargets;
      this.cache = /* @__PURE__ */ new Map();
    }
    get(facility) {
      const existing = this.cache.get(facility.id);
      if (existing) {
        return existing;
      }
      return this.create(facility);
    }
    create(facility) {
      const boundary = new LodBoundary(facility, this.lodDistanceThresholds, this.lodVectorCountTargets);
      this.cache.set(facility.id, boundary);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
      return boundary;
    }
  };
  var ArrayTaskQueue = class {
    constructor(tasks) {
      this.tasks = tasks;
      this.head = 0;
    }
    hasNext() {
      return this.head < this.tasks.length;
    }
    next() {
      return this.tasks[this.head++];
    }
  };
  var ThrottledTaskQueueProcess = class {
    constructor(queue, handler) {
      this.queue = queue;
      this.handler = handler;
      this._hasStarted = false;
      this._hasEnded = false;
      this._shouldAbort = false;
    }
    hasStarted() {
      return this._hasStarted;
    }
    hasEnded() {
      return this._hasEnded;
    }
    start() {
      this._hasStarted = true;
      this.processQueue(0);
    }
    processQueue(elapsedFrameCount) {
      let dispatchCount = 0;
      const t0 = performance.now();
      while (!this._shouldAbort && this.queue.hasNext()) {
        if (this.handler.canContinue(elapsedFrameCount, dispatchCount, performance.now() - t0)) {
          const task = this.queue.next();
          task();
          dispatchCount++;
        } else {
          break;
        }
      }
      if (this._shouldAbort) {
        return;
      }
      if (!this.queue.hasNext()) {
        this.handler.onFinished(elapsedFrameCount);
        this._hasEnded = true;
      } else {
        this.handler.onPaused(elapsedFrameCount);
        requestAnimationFrame(this.processQueue.bind(this, elapsedFrameCount + 1));
      }
    }
    abort() {
      if (this._hasStarted && !this._hasEnded) {
        this.handler.onAborted();
        this._shouldAbort = true;
        this._hasEnded = true;
      }
    }
  };
  var NearestLodBoundarySearchSession = class {
    constructor(cache, session, frameBudget) {
      this.cache = cache;
      this.session = session;
      this.frameBudget = frameBudget;
    }
    async searchNearest(lat, lon, radius, maxItems) {
      const facilityResults = await this.session.searchNearest(lat, lon, radius, maxItems);
      const results = { added: [], removed: facilityResults.removed };
      const tasks = facilityResults.added.map((fac, index) => () => {
        results.added[index] = this.cache.get(fac);
      });
      await new Promise((resolve) => {
        const taskQueue = new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), new NearestLodBoundarySearchTaskQueueHandler(this.frameBudget, resolve));
        taskQueue.start();
      });
      return results;
    }
    setFilter(classMask) {
      this.session.setBoundaryFilter(classMask);
    }
  };
  var NearestLodBoundarySearchTaskQueueHandler = class {
    constructor(frameBudget, resolve) {
      this.frameBudget = frameBudget;
      this.resolve = resolve;
    }
    onStarted() {
    }
    canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
      return timeElapsed < this.frameBudget;
    }
    onPaused() {
    }
    onFinished() {
      this.resolve();
    }
    onAborted() {
    }
  };
  var FlightPathVectorFlags;
  (function(FlightPathVectorFlags2) {
    FlightPathVectorFlags2[FlightPathVectorFlags2["None"] = 0] = "None";
    FlightPathVectorFlags2[FlightPathVectorFlags2["TurnToCourse"] = 1] = "TurnToCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Arc"] = 2] = "Arc";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Direct"] = 4] = "Direct";
    FlightPathVectorFlags2[FlightPathVectorFlags2["InterceptCourse"] = 8] = "InterceptCourse";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    FlightPathVectorFlags2[FlightPathVectorFlags2["CourseReversal"] = 512] = "CourseReversal";
    FlightPathVectorFlags2[FlightPathVectorFlags2["LegToLegTurn"] = 1024] = "LegToLegTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    FlightPathVectorFlags2[FlightPathVectorFlags2["Fallback"] = 4096] = "Fallback";
  })(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
  var ProcedureDetails2 = class {
    constructor() {
      this.originRunway = void 0;
      this.departureIndex = -1;
      this.departureTransitionIndex = -1;
      this.departureRunwayIndex = -1;
      this.arrivalIndex = -1;
      this.arrivalTransitionIndex = -1;
      this.arrivalRunwayTransitionIndex = -1;
      this.arrivalRunway = void 0;
      this.approachIndex = -1;
      this.approachTransitionIndex = -1;
      this.destinationRunway = void 0;
    }
  };
  var FlightPlanSegmentType;
  (function(FlightPlanSegmentType2) {
    FlightPlanSegmentType2["Origin"] = "Origin";
    FlightPlanSegmentType2["Departure"] = "Departure";
    FlightPlanSegmentType2["Enroute"] = "Enroute";
    FlightPlanSegmentType2["Arrival"] = "Arrival";
    FlightPlanSegmentType2["Approach"] = "Approach";
    FlightPlanSegmentType2["Destination"] = "Destination";
    FlightPlanSegmentType2["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType2["RandomDirectTo"] = "RandomDirectTo";
  })(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
  var FlightPlanSegment2 = class {
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
      this.segmentIndex = segmentIndex;
      this.offset = offset;
      this.legs = legs;
      this.segmentType = segmentType;
      this.airway = airway;
    }
  };
  FlightPlanSegment2.Empty = new FlightPlanSegment2(-1, -1, []);
  var LegDefinitionFlags;
  (function(LegDefinitionFlags2) {
    LegDefinitionFlags2[LegDefinitionFlags2["None"] = 0] = "None";
    LegDefinitionFlags2[LegDefinitionFlags2["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags2[LegDefinitionFlags2["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags2[LegDefinitionFlags2["Obs"] = 4] = "Obs";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags2[LegDefinitionFlags2["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
  })(LegDefinitionFlags || (LegDefinitionFlags = {}));
  var VerticalFlightPhase;
  (function(VerticalFlightPhase2) {
    VerticalFlightPhase2["Climb"] = "Climb";
    VerticalFlightPhase2["Descent"] = "Descent";
  })(VerticalFlightPhase || (VerticalFlightPhase = {}));
  var SpeedUnit;
  (function(SpeedUnit2) {
    SpeedUnit2[SpeedUnit2["IAS"] = 0] = "IAS";
    SpeedUnit2[SpeedUnit2["MACH"] = 1] = "MACH";
  })(SpeedUnit || (SpeedUnit = {}));
  var SpeedRestrictionType;
  (function(SpeedRestrictionType2) {
    SpeedRestrictionType2[SpeedRestrictionType2["Unused"] = 0] = "Unused";
    SpeedRestrictionType2[SpeedRestrictionType2["At"] = 1] = "At";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType2[SpeedRestrictionType2["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType2[SpeedRestrictionType2["Between"] = 4] = "Between";
  })(SpeedRestrictionType || (SpeedRestrictionType = {}));
  var FlightPathUtils = class {
    static createEmptyCircleVector() {
      return {
        vectorType: "circle",
        flags: FlightPathVectorFlags.None,
        radius: 0,
        centerX: 1,
        centerY: 0,
        centerZ: 0,
        startLat: 0,
        startLon: 0,
        endLat: 0,
        endLon: 0,
        distance: 0
      };
    }
    static setCircleVector(vector, circle, start, end, flags) {
      vector.flags = flags;
      vector.radius = circle.radius;
      vector.centerX = circle.center[0];
      vector.centerY = circle.center[1];
      vector.centerZ = circle.center[2];
      vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
      start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
      end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
      vector.startLat = start.lat;
      vector.startLon = start.lon;
      vector.endLat = end.lat;
      vector.endLon = end.lon;
      return vector;
    }
    static isVectorGreatCircle(vector) {
      return vector.radius === Math.PI / 2;
    }
    static setGeoCircleFromVector(vector, out) {
      return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    static getVectorTurnDirection(vector) {
      return vector.radius > MathUtils2.HALF_PI ? "right" : "left";
    }
    static getVectorTurnRadius(vector) {
      return Math.min(vector.radius, Math.PI - vector.radius);
    }
    static getVectorInitialCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    static getVectorFinalCourse(vector) {
      return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    static getLegTrueCourse(leg, point, magVarFacility) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      const magVar = magVarFacility ? -magVarFacility.magneticVariation : Facilities.getMagVar(point.lat, point.lon);
      return NavMath.normalizeHeading(leg.course + magVar);
    }
    static getLegFinalPosition(legCalc, out) {
      if (legCalc.endLat !== void 0 && legCalc.endLon !== void 0) {
        return out.set(legCalc.endLat, legCalc.endLon);
      }
      return void 0;
    }
    static getLegFinalCourse(legCalc) {
      if (legCalc.flightPath.length > 0) {
        const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
        return this.getVectorFinalCourse(vector);
      }
      return void 0;
    }
    static getTurnCircle(center, radius, turnDirection, out) {
      out.set(center, radius);
      if (turnDirection === "right") {
        out.reverse();
      }
      return out;
    }
    static reverseTurnCircle(circle, out) {
      return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    static getTurnDirectionFromCircle(circle) {
      return circle.radius > MathUtils2.HALF_PI ? "right" : "left";
    }
    static getTurnRadiusFromCircle(circle) {
      return Math.min(circle.radius, Math.PI - circle.radius);
    }
    static getTurnCenterFromCircle(circle, out) {
      return circle.radius > MathUtils2.HALF_PI ? out instanceof Float64Array ? Vec3Math.multScalar(circle.center, -1, out) : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2]) : out instanceof Float64Array ? Vec3Math.copy(circle.center, out) : out.setFromCartesian(circle.center);
    }
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
      }
      const radius = turnDirection === "left" ? turnRadius : Math.PI - turnRadius;
      const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
      const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils2.HALF_PI);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
      return out.set(turnCenter, radius);
    }
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils2.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      return circle.arcLength((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils2.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
      if (Math.min(posAngularDistance, MathUtils2.TWO_PI - posAngularDistance) <= tolerance) {
        return 0;
      }
      const endAngularDistance = circle.angleAlong(start, end, Math.PI);
      if (Math.min(endAngularDistance, MathUtils2.TWO_PI - endAngularDistance) <= tolerance) {
        return posAngularDistance >= Math.PI ? -Infinity : Infinity;
      }
      return ((posAngularDistance - endAngularDistance / 2 + Math.PI) % MathUtils2.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
      const angularTolerance = circle.angularWidth(tolerance);
      if (typeof end !== "number") {
        end = circle.angleAlong(start, end, Math.PI, angularTolerance);
      }
      if (inclusive && Math.abs(end) >= MathUtils2.TWO_PI - angularTolerance) {
        return true;
      }
      const angle = circle.angleAlong(start, pos, Math.PI);
      if (inclusive && angle >= MathUtils2.TWO_PI - angularTolerance) {
        return true;
      }
      const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
      return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    static projectVelocityToCircle(speed, position, direction, projectTo) {
      if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
        return NaN;
      }
      if (speed === 0) {
        return 0;
      }
      if (!(position instanceof Float64Array)) {
        position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
      }
      const velocityPath = typeof direction === "number" ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction) : direction.isGreatCircle() ? direction : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
      const sign4 = velocityPath.encircles(projectTo.center) ? 1 : -1;
      const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
      const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
      const dot2 = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
      const sinTheta = Math.sqrt(1 - MathUtils2.clamp(dot2 * dot2, 0, 1));
      return speed * sinTheta * sign4;
    }
    static resolveIngressToEgress(legCalc) {
      var _a, _b, _c, _d, _e, _f;
      var _g, _h, _j, _k, _l, _m;
      const vectors = legCalc.ingressToEgress;
      let vectorIndex = 0;
      let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
      const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
      const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
      const firstEgressVector = legCalc.egress[0];
      const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
      if (lastIngressVector && ingressJoinVector) {
        const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
        const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
        const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon) : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
        const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
        const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
        const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
        if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
          if (ingressEndAlongVectorDistance > normalizedTolerance) {
            ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
            FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : vectors[_g] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
          } else {
            Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : vectors[_h] = FlightPathUtils.createEmptyCircleVector(), ingressJoinVector);
          }
        }
        flightPathVectorIndex++;
      }
      const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
      for (let i = flightPathVectorIndex; i < end; i++) {
        Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : vectors[_j] = FlightPathUtils.createEmptyCircleVector(), legCalc.flightPath[i]);
        flightPathVectorIndex++;
      }
      if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
        if (firstEgressVector) {
          const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
          const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
          const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
          const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
          const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
          const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
          if (egressStartAlongVectorDistance > normalizedTolerance) {
            if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
              egressJoinVectorCircle.closest(egressStart, egressStart);
              FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : vectors[_k] = FlightPathUtils.createEmptyCircleVector(), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
            } else {
              Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : vectors[_l] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
            }
          }
        } else {
          Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : vectors[_m] = FlightPathUtils.createEmptyCircleVector(), egressJoinVector);
        }
      }
      vectors.length = vectorIndex;
      return legCalc;
    }
  };
  FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var CircleVectorBuilder = class {
    build(vectors, index, ...args) {
      if (args[0] instanceof GeoCircle) {
        this.setFromCircle(vectors, index, ...args);
      } else {
        this.setFromPoints(vectors, index, ...args);
      }
      return 1;
    }
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
      return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
      var _a;
      const vector = ((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === "circle" ? vectors[index] : vectors[index] = FlightPathUtils.createEmptyCircleVector();
      return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
  };
  CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var GreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, pathArg, endArg, flags) {
      if (pathArg instanceof GeoCircle) {
        return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
      } else {
        return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
      }
    }
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
      const startPoint = start instanceof Float64Array ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start) : GreatCircleBuilder.geoPointCache[0].set(start);
      const endPoint = end instanceof Float64Array ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end) : GreatCircleBuilder.geoPointCache[1].set(end);
      const distance = startPoint.distance(endPoint);
      const path = GreatCircleBuilder.geoCircleCache[0];
      if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
        if (initialCourse === void 0) {
          throw new Error("GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.");
        } else {
          path.setAsGreatCircle(start, initialCourse);
        }
      } else {
        path.setAsGreatCircle(start, end);
      }
      return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
      if (!path.isGreatCircle()) {
        throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
      }
      const end = typeof endArg === "number" ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI) : endArg;
      return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
  };
  GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
  GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var TurnToCourseBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
      if (start instanceof Float64Array) {
        start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
      }
      const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === "left" ? -90 : 90), radiusRad);
      const turnStartBearing = turnCenterPoint.bearingTo(start);
      const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
      if (turnEndPoint.equals(start)) {
        return 0;
      }
      return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
  };
  TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  var CircleInterceptBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, pathArg, circle, flags = 0) {
      if (circle.includes(start)) {
        return 0;
      }
      let startPath;
      if (pathArg instanceof GeoCircle) {
        if (!pathArg.includes(start)) {
          throw new Error("CircleInterceptBuilder: the starting point does not lie on the starting path.");
        }
        startPath = pathArg;
      } else {
        startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
      }
      const intersections = CircleInterceptBuilder.intersectionCache;
      const numIntersections = startPath.intersection(circle, intersections);
      if (numIntersections === 0) {
        return 0;
      }
      const intersectionIndex = numIntersections === 1 || circle.encircles(start) ? 0 : 1;
      const endVec = intersections[intersectionIndex];
      return startPath.isGreatCircle() ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags) : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
  };
  CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
      if (!endPath.isGreatCircle()) {
        throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
      }
      let startPath;
      if (startPathArg instanceof GeoCircle) {
        if (!startPathArg.isGreatCircle()) {
          throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
        } else if (!startPathArg.includes(start)) {
          throw new Error("TurnToJoinPathBuilder: the starting point does not lie on the starting path.");
        }
        startPath = startPathArg;
      } else {
        startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
      }
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
      }
      const turnDirection = endPath.encircles(start) ? "left" : "right";
      const radiusRad = turnDirection === "left" ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
      const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
      const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
      const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
      const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === "left" ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
      return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
  };
  TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var ConnectCirclesBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, fromCircle, toCircle, radius, from, to, fromCircleVectorFlags = 0, toCircleVectorFlags = 0, connectVectorFlags = 0) {
      if (radius === 0) {
        return 0;
      }
      const angle = Math.acos(Vec3Math.dot(fromCircle.center, toCircle.center));
      if (angle <= GeoPoint.EQUALITY_TOLERANCE && fromCircle.radius === toCircle.radius || Math.PI - angle <= GeoPoint.EQUALITY_TOLERANCE && Math.PI - fromCircle.radius - toCircle.radius <= GeoPoint.EQUALITY_TOLERANCE) {
        return 0;
      }
      if (from && !(from instanceof Float64Array)) {
        from = GeoPoint.sphericalToCartesian(from, ConnectCirclesBuilder.vec3Cache[0]);
      }
      if (to && !(to instanceof Float64Array)) {
        to = GeoPoint.sphericalToCartesian(to, ConnectCirclesBuilder.vec3Cache[1]);
      }
      const radiusRad = Math.min(Math.PI / 2, radius ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN) : Infinity);
      const joinCircle = this.findCircleToJoinCircles(fromCircle, toCircle, radiusRad, ConnectCirclesBuilder.geoCircleCache[0], from, to);
      if (!joinCircle) {
        return 0;
      }
      let vectorIndex = index;
      const joinStart = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[2]), ConnectCirclesBuilder.vec3Cache[2]);
      const joinEnd = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[3]), ConnectCirclesBuilder.vec3Cache[3]);
      if (from && Math.acos(Vec3Math.dot(from, joinStart)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, fromCircle, from, joinStart, fromCircleVectorFlags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, joinCircle, joinStart, joinEnd, connectVectorFlags);
      if (to && Math.acos(Vec3Math.dot(to, joinEnd)) > GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, toCircle, joinEnd, to, toCircleVectorFlags);
      }
      return vectorIndex - index;
    }
    findCircleToJoinCircles(fromCircle, toCircle, radius, out, from, to) {
      const solutions = [];
      const intersections = ConnectCirclesBuilder.intersectionCache;
      const leftTurnRadius = radius;
      let fromCircleOffsetRadius = Math.abs(leftTurnRadius - fromCircle.radius);
      let toCircleOffsetRadius = Math.abs(leftTurnRadius - toCircle.radius);
      let fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[1].set(fromCircle.center, fromCircleOffsetRadius);
      let toCircleOffset = ConnectCirclesBuilder.geoCircleCache[2].set(toCircle.center, toCircleOffsetRadius);
      const numLeftTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
      if (numLeftTurnSolutions === 1) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
      } else if (numLeftTurnSolutions === 2) {
        solutions.push(ConnectCirclesBuilder.geoCircleCache[1].set(intersections[0], leftTurnRadius));
        solutions.push(ConnectCirclesBuilder.geoCircleCache[2].set(intersections[1], leftTurnRadius));
      }
      if (radius !== Math.PI / 2) {
        const rightTurnRadius = Math.PI - radius;
        fromCircleOffsetRadius = Math.abs(rightTurnRadius - fromCircle.radius);
        toCircleOffsetRadius = Math.abs(rightTurnRadius - toCircle.radius);
        fromCircleOffset = ConnectCirclesBuilder.geoCircleCache[3].set(fromCircle.center, fromCircleOffsetRadius);
        toCircleOffset = ConnectCirclesBuilder.geoCircleCache[4].set(toCircle.center, toCircleOffsetRadius);
        const numRightTurnSolutions = fromCircleOffset.intersection(toCircleOffset, intersections);
        if (numRightTurnSolutions === 1) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
        } else if (numRightTurnSolutions === 2) {
          solutions.push(ConnectCirclesBuilder.geoCircleCache[3].set(intersections[0], rightTurnRadius));
          solutions.push(ConnectCirclesBuilder.geoCircleCache[4].set(intersections[1], rightTurnRadius));
        }
      }
      if (solutions.length === 0) {
        return null;
      } else if (solutions.length === 1) {
        return out.set(solutions[0].center, solutions[0].radius);
      } else {
        let circle = solutions[0];
        let minDistance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[0], from, to);
        for (let i = 1; i < solutions.length; i++) {
          const distance = this.calculateJoinCirclesPathDistance(fromCircle, toCircle, solutions[i], from, to);
          if (distance < minDistance) {
            circle = solutions[i];
            minDistance = distance;
          }
        }
        return out.set(circle.center, circle.radius);
      }
    }
    calculateJoinCirclesPathDistance(fromCircle, toCircle, joinCircle, from, to) {
      let distance = 0;
      const joinStartVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(fromCircle, ConnectCirclesBuilder.vec3Cache[6]), ConnectCirclesBuilder.vec3Cache[6]);
      const joinEndVec = joinCircle.closest(FlightPathUtils.getTurnCenterFromCircle(toCircle, ConnectCirclesBuilder.vec3Cache[7]), ConnectCirclesBuilder.vec3Cache[7]);
      if (from) {
        distance += fromCircle.distanceAlong(from, joinStartVec, Math.PI);
      }
      distance += joinCircle.distanceAlong(joinStartVec, joinEndVec, Math.PI);
      if (to) {
        distance += toCircle.distanceAlong(joinEndVec, to, Math.PI);
      }
      return distance;
    }
  };
  ConnectCirclesBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  ConnectCirclesBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  ConnectCirclesBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var TurnToJoinGreatCircleAtPointBuilder = class {
    constructor() {
      this.connectCirclesBuilder = new ConnectCirclesBuilder();
    }
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, end, endPath, endTurnRadius, endTurnDirection, startTurnVectorFlags = 0, endTurnVectorFlags = 0, connectVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[1]);
      }
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      const startTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath.center);
      const startTurnCircleRadiusRad = startTurnDirection === "left" ? startTurnRadiusRad : Math.PI - startTurnRadiusRad;
      const startTurnCircleCenter = startTurnOffsetPath.offsetDistanceAlong(start, startTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const startTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[0].set(startTurnCircleCenter, startTurnCircleRadiusRad);
      const endTurnRadiusRad = UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      const endTurnOffsetPath = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].setAsGreatCircle(end, endPath.center);
      const endTurnCircleRadiusRad = endTurnDirection === "left" ? endTurnRadiusRad : Math.PI - endTurnRadiusRad;
      const endTurnCircleCenter = endTurnOffsetPath.offsetDistanceAlong(end, endTurnCircleRadiusRad, TurnToJoinGreatCircleAtPointBuilder.vec3Cache[3]);
      const endTurnCircle = TurnToJoinGreatCircleAtPointBuilder.geoCircleCache[1].set(endTurnCircleCenter, endTurnCircleRadiusRad);
      return this.connectCirclesBuilder.build(vectors, index, startTurnCircle, endTurnCircle, void 0, start, end, startTurnVectorFlags, endTurnVectorFlags, connectVectorFlags);
    }
  };
  TurnToJoinGreatCircleAtPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  TurnToJoinGreatCircleAtPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var InterceptGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
      }
      const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
      if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        return 0;
      }
      const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
      const interceptAngleRad = MathUtils2.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils2.HALF_PI);
      const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
      const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
      if (startTurnDirection === void 0) {
        const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils2.HALF_PI), intersections);
        if (interceptCount === 0) {
          startTurnDirection = startPath.encircles(end) ? "left" : "right";
        } else {
          let intersectionIndex = 0;
          if (interceptCount > 1) {
            intersectionIndex = endPath.encircles(start) ? 0 : 1;
          }
          let cross2 = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
          if (Vec3Math.abs(cross2) <= GeoCircle.ANGULAR_TOLERANCE) {
            cross2 = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            if (Vec3Math.abs(cross2) <= GeoCircle.ANGULAR_TOLERANCE) {
              startTurnDirection = "right";
            } else {
              startTurnDirection = Vec3Math.dot(cross2, start) >= 0 ? "left" : "right";
            }
          } else {
            startTurnDirection = Vec3Math.dot(cross2, start) >= 0 ? "left" : "right";
          }
        }
      }
      const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
      const endTurnRadiusRad = endTurnRadius === void 0 ? void 0 : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
      if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
        if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils2.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        const startTurnEnd2 = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd2, end, Math.PI);
        if (startTurnEndToEndDistance < MathUtils2.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
          return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd2, startTurnVectorFlags);
      }
      const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils2.HALF_PI - startTurnRadiusRad));
      const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
      if (interceptPathCount === 0) {
        return 0;
      }
      const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
      let interceptCrossSign;
      if (startToEndPathAngleRad >= interceptAngleRad) {
        const overshootThreshold = Math.asin(MathUtils2.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
        const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
        interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils2.HALF_PI);
        interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === "right") ? 1 : -1;
      } else {
        interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils2.HALF_PI);
        interceptCrossSign = startTurnDirection === "right" ? 1 : -1;
      }
      const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
      const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
      const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      let minDInterceptEnd = 0;
      if (endTurnRadiusRad !== void 0) {
        const endTheta = Math.PI - interceptAngleRad;
        minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
        if (isNaN(minDInterceptEnd)) {
          return 0;
        }
      }
      const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
      const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils2.TWO_PI - Math.PI;
      if (interceptToEndOffset < minDInterceptEnd) {
        return 0;
      }
      let vectorIndex = index;
      if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
        if (endTurnRadiusRad === void 0) {
          const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
          if (startTurnEndPathIntersectionCount === 0) {
            return 0;
          }
          const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === "right" ? 0 : 1];
          if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
        } else {
          const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
          const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === "left" ? 1 : -1));
          const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
          if (endTurnCircleCount === 0) {
            return 0;
          }
          const endTurnCenter = intersections[0];
          const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === "left" ? "right" : "left", InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
          endTurnCircle.closest(startTurnCenter, startTurnEnd);
          const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
          if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
          }
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
        }
      } else {
        if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        let interceptPathEnd = intercept;
        if (endTurnRadiusRad !== void 0) {
          interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
        }
        if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
          vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
        }
        if (endTurnRadius !== void 0) {
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
        }
      }
      return vectorIndex - index;
    }
  };
  InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3),
    new Float64Array(3)
  ];
  InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var JoinGreatCircleToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
      this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
      }
      if (!intersection) {
        const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
        const solutionCount = startPath.intersection(endPath, intersections);
        if (solutionCount === 0) {
          return 0;
        }
        intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0 ? intersections[0] : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
      const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
      const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1 : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
      const isEndForwardOfIntersection = intersectionToEndSign > 0;
      minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : minTurnRadius = 0;
      const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
      const pathDot = Vec3Math.dot(startPath.center, endPath.center);
      const theta = Math.acos(-pathDot);
      const tanHalfTheta = Math.tan(theta / 2);
      let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
      if (isNaN(minD)) {
        minD = Infinity;
      }
      const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
      const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
      const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
      const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
      const towardEndPointTurnDirection = startPath.encircles(end, false) ? "left" : "right";
      let needCalculateTwoTurnPath = false;
      let needCalculateOneTurnPath = false;
      if (isEndForwardOfIntersection) {
        if (desiredTurnDirection === void 0 || desiredTurnDirection === towardEndPointTurnDirection) {
          const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
          const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
          if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          } else {
            const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
            if (intersectionStartDistance <= intersectionEndDistance) {
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
              if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
              }
            } else {
              let turnStart = start;
              if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
              }
              vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
            }
          }
        } else {
          if (pathDot >= 0) {
            if (intersectionStartOffset <= minD) {
              needCalculateOneTurnPath = true;
            } else {
              needCalculateTwoTurnPath = !preferSingleTurn;
              needCalculateOneTurnPath = preferSingleTurn;
            }
          } else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
          }
        }
      } else {
        needCalculateTwoTurnPath = !preferSingleTurn;
        needCalculateOneTurnPath = preferSingleTurn;
      }
      let needDirectFallback = false;
      if (needCalculateTwoTurnPath) {
        const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
        const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, void 0, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
        if (numInterceptVectors === 0) {
          needDirectFallback = allowDirectFallback;
        } else {
          vectorIndex += numInterceptVectors;
          const lastVector = vectors[vectorIndex - 1];
          const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
          if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
          }
        }
      } else if (needCalculateOneTurnPath) {
        minD = Math.min(minD, Math.PI / 2);
        if (minD > Math.PI / 2) {
          needDirectFallback = allowDirectFallback;
        } else {
          const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
          const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
          const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
          const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
          if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
          }
          vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
          if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
            const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
          }
        }
      }
      if (needDirectFallback) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
      }
      return vectorIndex - index;
    }
  };
  JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45;
  JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var ProcedureTurnBuilder = class {
    constructor() {
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.circleVectorBuilder = new CircleVectorBuilder();
    }
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
      let vectorIndex = index;
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
      }
      initialCourse !== null && initialCourse !== void 0 ? initialCourse : initialCourse = startPath.bearingAt(start, Math.PI);
      finalCourse !== null && finalCourse !== void 0 ? finalCourse : finalCourse = endPath.bearingAt(end, Math.PI);
      const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
      const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
      const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === "left");
      const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
      const thetaOutbound = (Math.PI - deltaOutbound) / 2;
      const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : initialTurnDirection === "left" === deltaOutbound < Math.PI ? "right" : "left";
      const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
      let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10 ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1) : 0;
      desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound)) * (isInitialTurnTowardEndPath ? 1 : -1);
      const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
      let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
      desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
      desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
      const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
      const initialTurnStartPoint = alongStartPathDistance > 0 ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1]) : startPoint;
      const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
      const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
      const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
      const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === "left" ? -1 : 1));
      const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
      const turnStartPoint = alongTurnOutboundPathDistance > 0 ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4]) : initialTurnEndPoint;
      const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === "left" ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
      const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
      let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
      const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
      const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
      let finalTurnDirection;
      let finalTurnRadius;
      let finalTurnStartPoint;
      let finalTurnCenterPoint;
      let finalTurnEndPoint;
      let endPoint;
      if (endPath.encircles(turnEndVec) === (initialTurnDirection === "left")) {
        const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnCircle.intersection(endPath, intersections);
        if (numIntersections === 0) {
          endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
        } else {
          if (numIntersections === 2) {
            const headingAdjustment = turnDirection === "left" ? -90 : 90;
            const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
            turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
          } else {
            turnEndPoint.setFromCartesian(intersections[0]);
          }
          turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
        }
      } else {
        const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
        const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
        const intersections = ProcedureTurnBuilder.intersectionCache;
        const numIntersections = turnInboundPath.intersection(endPath, intersections);
        if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
          const intersection = intersections[numIntersections === 1 || endPath.encircles(turnEndVec) ? 0 : 1];
          if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
            const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
            const thetaInbound = (Math.PI - deltaInbound) / 2;
            const tanThetaInbound = Math.tan(thetaInbound);
            const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
            const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
            const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance ? desiredTurnRadiusRad : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
            finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
            finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
            finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
            finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === "left" ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
            finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
          }
        }
      }
      const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
      if (initialTurnStartPoint !== startPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
      if (turnStartPoint !== initialTurnEndPoint) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, void 0, flags);
      }
      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
      if (finalTurnCenterPoint) {
        if (!finalTurnStartPoint.equals(turnEndPoint)) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, void 0, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
      } else {
        if (endPoint) {
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, void 0, flags);
        }
      }
      return vectorIndex - index;
    }
  };
  ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0),
    new GeoPoint(0, 0)
  ];
  ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
  var DirectToPointBuilder = class {
    constructor() {
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
    }
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
      let vectorIndex = index;
      if (typeof startPath === "number") {
        startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
      }
      const endPos = DirectToPointBuilder.geoPointCache[0];
      if (!(start instanceof Float64Array)) {
        start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
      }
      if (!(end instanceof Float64Array)) {
        endPos.set(end);
        end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
      } else {
        endPos.setFromCartesian(end);
      }
      const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
      if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
        return vectorIndex - index;
      } else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
        return vectorIndex - index;
      }
      const startPathEncirclesTerminator = startPath.encircles(end);
      const startPathIncludesTerminator = startPath.includes(end);
      const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPathEncirclesTerminator && !startPathIncludesTerminator ? "left" : "right";
      const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === "left" ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2]) : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils2.HALF_PI);
      let maxTurnRadiusRad;
      if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === "left")) {
        const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
        const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
        maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
      } else {
        maxTurnRadiusRad = Math.PI / 2;
      }
      const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
      const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
      const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
      const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
      const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
      const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
      const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === "left" ? -1 : 1) + 180);
      const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
      const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
      flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
      if (!GeoPoint.equals(turnEndVec, start)) {
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
      }
      if (!GeoPoint.equals(turnEndVec, end)) {
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, void 0, flags);
      }
      return vectorIndex - index;
    }
  };
  DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
  DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var AbstractFlightPathLegCalculator = class {
    constructor(facilityCache, skipWhenActive = false) {
      this.facilityCache = facilityCache;
      this.skipWhenActive = skipWhenActive;
    }
    getPositionFromIcao(icao, out) {
      const facility = this.facilityCache.get(icao);
      return facility ? out.set(facility) : void 0;
    }
    getTerminatorPosition(leg, icao, out) {
      if (leg.lat !== void 0 && leg.lon !== void 0) {
        return out.set(leg.lat, leg.lon);
      } else {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility.lat, facility.lon) : void 0;
      }
    }
    getLegMagVar(leg, point) {
      const facIcao = leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR) ? leg.originIcao : leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR) ? leg.fixIcao : void 0;
      const facility = facIcao !== void 0 ? this.facilityCache.get(facIcao) : void 0;
      return facility === void 0 ? MagVar.get(point) : -facility.magneticVariation;
    }
    getLegTrueCourse(leg, point) {
      if (leg.trueDegrees) {
        return leg.course;
      }
      return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
      var _a, _b, _c;
      var _d;
      const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : _d.calculated = {
        courseMagVar: 0,
        startLat: void 0,
        startLon: void 0,
        endLat: void 0,
        endLon: void 0,
        distance: 0,
        distanceWithTransitions: 0,
        initialDtk: void 0,
        cumulativeDistance: 0,
        cumulativeDistanceWithTransitions: 0,
        flightPath: [],
        ingress: [],
        ingressJoinIndex: -1,
        ingressToEgress: [],
        egressJoinIndex: -1,
        egress: [],
        endsInFallback: false
      };
      const vectors = calcs.flightPath;
      if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
        state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
        state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
        state.isFallback = calcs.endsInFallback;
        return calcs;
      }
      try {
        this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
        this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
        resolveIngressToEgress && this.resolveIngressToEgress(calcs);
        calcs.endsInFallback = state.isFallback;
      } catch (e) {
        console.error(e);
        if (e instanceof Error) {
          console.error(e.stack);
        }
        vectors.length = 0;
        calcs.ingress.length = 0;
        calcs.ingressJoinIndex = 0;
        calcs.egress.length = 0;
        calcs.egressJoinIndex = -1;
        calcs.ingressToEgress.length = 0;
        calcs.endsInFallback = false;
        state.isFallback = false;
      }
      return calcs;
    }
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
      return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    resolveIngressToEgress(legCalc) {
      FlightPathUtils.resolveIngressToEgress(legCalc);
    }
  };
  var CourseToFixLegCalculator = class extends AbstractFlightPathLegCalculator {
    constructor(facilityCache) {
      super(facilityCache, true);
      this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0),
        new GeoCircle(new Float64Array(3), 0)
      ];
      this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
      this.circleVectorBuilder = new CircleVectorBuilder();
      this.greatCircleBuilder = new GreatCircleBuilder();
      this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
      this.procTurnBuilder = new ProcedureTurnBuilder();
      this.directToPointBuilder = new DirectToPointBuilder();
    }
    calculateMagVar(legs, calculateIndex) {
      const leg = legs[calculateIndex];
      const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
      leg.calculated.courseMagVar = terminatorPos === void 0 ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const leg = legs[calculateIndex].leg;
      const prevLeg = legs[calculateIndex - 1];
      const vectors = legs[calculateIndex].calculated.flightPath;
      let vectorIndex = 0;
      const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : void 0;
      const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
      if (!endPoint) {
        vectors.length = vectorIndex;
        state.isFallback = false;
        return;
      }
      const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
      if (state.isFallback && state.currentPosition !== void 0 && state.currentCourse !== void 0) {
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, void 0, FlightPathVectorFlags.Fallback);
        state.isFallback = false;
      } else {
        state.isFallback = false;
        const endCourse = this.getLegTrueCourse(leg, endPoint);
        const endVec = endPoint.toCartesian(this.vec3Cache[1]);
        const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
        if (!startPoint || prevLeg && (prevLeg.leg.type === LegType2.FM || prevLeg.leg.type === LegType2.VM)) {
          const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
          vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
        } else {
          const startVec = startPoint.toCartesian(this.vec3Cache[0]);
          const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
          const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
          const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
          const isStartEqualToEnd = startPoint.equals(endPoint);
          const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
          if (!leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type) && threshold.encircles(startVec, false)) {
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
            (_d = state.currentCourse) !== null && _d !== void 0 ? _d : state.currentCourse = currentCourse;
            state.isFallback = true;
          } else {
            const pathAngleDiff = Math.acos(MathUtils2.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
            if (pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE) {
              let desiredTurnDirection;
              switch (leg.turnDirection) {
                case LegTurnDirection.Left:
                  desiredTurnDirection = "left";
                  break;
                case LegTurnDirection.Right:
                  desiredTurnDirection = "right";
                  break;
                default: {
                  const endDistanceFromStartPath = startPath.distance(endVec);
                  if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                    const cross2 = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                    desiredTurnDirection = Vec3Math.dot(cross2, endPath.center) > 0 ? "left" : "right";
                  } else {
                    desiredTurnDirection = endDistanceFromStartPath < 0 ? "left" : "right";
                  }
                }
              }
              vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === "left" ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
              if (vectorIndex > 0) {
                const lastVector2 = vectors[vectorIndex - 1];
                const interceptVec = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                  vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector2.endLat, lastVector2.endLon), endPoint);
                }
              }
            } else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE || !isStartEqualToEnd && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 || ((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))) {
              if (!isStartEqualToEnd) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
              }
            } else {
              const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? "left" : leg.turnDirection === LegTurnDirection.Right ? "right" : void 0;
              vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
              const lastVector2 = vectors[vectorIndex - 1];
              if (lastVector2 !== void 0 && Math.abs(FlightPathUtils.getVectorFinalCourse(lastVector2) - endCourse) > 1 && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                let startTurnCircle;
                let startTurnEnd;
                const isLastVectorGreatCircle = FlightPathUtils.isVectorGreatCircle(lastVector2);
                if (isLastVectorGreatCircle && vectors[vectorIndex - 2] !== void 0) {
                  const startTurnVector = vectors[vectorIndex - 2];
                  startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                  startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[2]);
                } else if (!isLastVectorGreatCircle) {
                  startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : startPath.encircles(endVec) ? "left" : "right", this.geoCircleCache[3]);
                  if (Math.min(lastVector2.radius, Math.PI - lastVector2.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                    startTurnEnd = GeoPoint.sphericalToCartesian(lastVector2.endLat, lastVector2.endLon, this.vec3Cache[2]);
                  }
                }
                if (startTurnCircle !== void 0) {
                  const intersections = this.intersectionCache;
                  const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                  if (intersectionCount === 1) {
                    if (threshold.encircles(FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, this.vec3Cache[2]))) {
                      vectorIndex = 0;
                      ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : state.currentPosition = new GeoPoint(0, 0)).set(startPoint);
                      (_h = state.currentCourse) !== null && _h !== void 0 ? _h : state.currentCourse = currentCourse;
                      state.isFallback = true;
                    }
                  } else if (startTurnEnd === void 0 || intersectionCount === 2) {
                    const thresholdCrossing = intersections[0];
                    const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                    if (startTurnEnd === void 0 || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                      vectorIndex = 0;
                      vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                      state.isFallback = true;
                    }
                  }
                }
              }
            }
          }
        }
      }
      const lastVector = vectors[vectorIndex - 1];
      if (lastVector !== void 0) {
        ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : state.currentPosition = new GeoPoint(0, 0)).set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
      }
      vectors.length = vectorIndex;
    }
  };
  CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType2.AF,
    LegType2.RF,
    LegType2.PI
  ];
  var FlightPathTurnCalculator = class {
    constructor() {
      this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
      var _a, _b, _c, _d, _e, _f;
      const end = startIndex + count;
      let currentIndex = startIndex;
      while (currentIndex < end) {
        const fromLegCalc = (_a = legs[currentIndex]) === null || _a === void 0 ? void 0 : _a.calculated;
        const toLegCalc = (_b = legs[currentIndex + 1]) === null || _b === void 0 ? void 0 : _b.calculated;
        if (fromLegCalc && toLegCalc) {
          const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
          const toVector = toLegCalc.flightPath[0];
          if (fromVector && toVector && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn)) && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
              currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
              continue;
            } else if (toVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
              continue;
            } else if (fromVector.radius === Math.PI / 2) {
              currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
              continue;
            }
          }
        }
        if (fromLegCalc && BitFlags.isAll((_d = (_c = fromLegCalc.egress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
          fromLegCalc.egress.length = 0;
          fromLegCalc.egressJoinIndex = -1;
        }
        if (toLegCalc && BitFlags.isAll((_f = (_e = toLegCalc.ingress[0]) === null || _e === void 0 ? void 0 : _e.flags) !== null && _f !== void 0 ? _f : 0, FlightPathVectorFlags.LegToLegTurn)) {
          toLegCalc.ingress.length = 0;
          toLegCalc.ingressJoinIndex = -1;
        }
        currentIndex++;
      }
    }
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
      const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
      const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
      if (trackAngleDiff < 1 || fromTrack.distance === 0 || toTrack.distance === 0 || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      if (trackAngleDiff > 175) {
        return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
      }
      const theta = (180 - trackAngleDiff) / 2;
      const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
      const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
      let restrictedD = Infinity;
      if (isRestrictedByPrevTurn) {
        if (previousTanTheta === void 0) {
          if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
            const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
            restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
          }
        } else {
          const tanThetaRatio = previousTanTheta / tanTheta;
          const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
          const cosTotalD = Math.cos(totalD);
          let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
          if (prevTurnRestrictedD > totalD) {
            prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
          }
          restrictedD = prevTurnRestrictedD;
        }
      }
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          let nextTurnRestrictedD;
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
          }
          restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
        }
      }
      const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
      const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
      const turnRadiusRad = desiredD === D ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN) : Math.atan(Math.sin(D) * tanTheta);
      if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return lastComputedIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
      const turnBisectorBearing = toTrackBearing + theta * (turnDirection === "left" ? -1 : 1);
      const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
      const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
      const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
      return lastComputedIndex;
    }
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
      var _a;
      let lastComputedIndex = toIndex;
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
      if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
        const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
        const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
        if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
          if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
            courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
          } else {
            lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
            turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
            const nextTurnEgress = toLegCalc.egress[0];
            courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
          }
        }
      }
      const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
      const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
      const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
      const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? "left" : "right";
      const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === "left" ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
      toLegCalc.ingress.length = length;
      toLegCalc.ingressJoinIndex = 0;
      return lastComputedIndex;
    }
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
      const fromLegCalc = legs[fromIndex].calculated;
      const toLegCalc = legs[toIndex].calculated;
      if (arc.distance === 0 || track.distance === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const fromVector = isArcFirst ? arc : track;
      const toVector = isArcFirst ? track : arc;
      const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
      const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
      if (!fromVectorEndPoint.equals(toVectorStartPoint, 1e-5)) {
        return toIndex;
      }
      const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
      const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
      const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
      if (vectorBearingDiff < 1) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
      const arcCenter = FlightPathUtils.getTurnCenterFromCircle(circle, FlightPathTurnCalculator.geoPointCache[2]);
      const arcRadius = FlightPathUtils.getTurnRadiusFromCircle(circle);
      const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const arcCircle = FlightPathTurnCalculator.geoCircleCache[0].set(arcCenter, arcRadius);
      const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[1]);
      const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
      const arcStartRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.startLat, arc.startLon), Math.PI) + 90;
      const arcEndRadial = arcCircle.bearingAt(FlightPathTurnCalculator.geoPointCache[4].set(arc.endLat, arc.endLon), Math.PI) + 90;
      const arcTrackIntersectionCount = arcCircle.numIntersectionPoints(trackPath);
      if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
      let isInside;
      let turnRadiusRad;
      let arcCircleOffsetSign;
      let trackPathOffsetSign;
      if (arcTrackIntersectionCount === 1) {
        const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
        if (isForward) {
          this.setEmptyTurn(fromLegCalc, toLegCalc);
          return toIndex;
        } else {
          isInside = false;
          turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
          arcCircleOffsetSign = 1;
          trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
        }
      } else {
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        isInside = isArcFirst ? Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), toVectorStartBearing)) >= 90 : Math.abs(NavMath.diffAngle(fromVectorEndPoint.bearingFrom(arcCenter), fromVectorEndBearing)) < 90;
        const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, fromVectorEndPoint, FlightPathTurnCalculator.vector3Cache[0]);
        const maxTrackLimitDistance = isInside ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadius)) : Infinity;
        const trackLimitDistance = Math.min(UnitType.METER.convertTo(track.distance / 2, UnitType.GA_RADIAN), maxTrackLimitDistance);
        const trackLimitPoint = isArcFirst ? toVectorStartPoint.offset(toVectorStartBearing, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]) : fromVectorEndPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, FlightPathTurnCalculator.geoPointCache[4]);
        const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[2].set(Vec3Math.cross(Vec3Math.multScalar(trackPath.center, isArcFirst === isInside ? -1 : 1, FlightPathTurnCalculator.vector3Cache[1]), arcCircle.center, FlightPathTurnCalculator.vector3Cache[1]), Math.PI / 2);
        const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
        trackPerpendicularDiameter.intersection(arcCircle, antipodes);
        const intersectingPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(isInside === (turnDirection === "left") ? antipodes[0] : antipodes[1], trackLimitPoint);
        const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
        let arcLimitAngularWidth = Infinity;
        if (numArcIntersections > 0) {
          const pseudoArcLimitPoint = arcIntersections[0];
          const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
          arcLimitAngularWidth = Math.abs(NavMath.diffAngle(isArcFirst ? arcEndRadial : arcStartRadial, pseudoArcLimitPointAngle));
        }
        let arcTurnRadiusLimit = 0;
        const arcAngularWidth = ((arcDirection === "left" ? arcStartRadial - arcEndRadial : arcEndRadial - arcStartRadial) + 360) % 360;
        arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcAngularWidth / 2);
        if (arcLimitAngularWidth > 0) {
          const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * (arcDirection === "left" ? -1 : 1);
          const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadius, FlightPathTurnCalculator.geoPointCache[4]);
          const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[2].setAsGreatCircle(arcCenter, arcLimitPoint);
          const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
          if (theta >= Math.PI / 2) {
            if (isInside) {
              const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadius));
              arcTurnRadiusLimit = (arcRadius - d) / 2;
            } else {
              arcTurnRadiusLimit = Infinity;
            }
          } else {
            const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
            arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
            const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
            const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[1]), FlightPathTurnCalculator.vector3Cache[1]);
            const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
            const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
            const sinTheta = Math.sin(theta);
            const sign4 = isInside ? -1 : 1;
            arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign4) / Math.sqrt(1 + 2 * sinTheta * cosD * sign4 + sinTheta * sinTheta));
          }
        }
        turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
        arcCircleOffsetSign = isInside ? -1 : 1;
        trackPathOffsetSign = turnDirection === "left" ? -1 : 1;
      }
      if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[2].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
      const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[3].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
      const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
      const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
      if (intersectionCount === 0) {
        this.setEmptyTurn(fromLegCalc, toLegCalc);
        return toIndex;
      }
      let turnCenter;
      if (intersectionCount === 2) {
        if (arcTrackIntersectionCount === 1 || fromVectorEndPoint.distance(intersections[0]) >= fromVectorEndPoint.distance(intersections[1])) {
          turnCenter = intersections[1];
        } else {
          turnCenter = intersections[0];
        }
      } else {
        turnCenter = intersections[0];
      }
      const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
      const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
      const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
      const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
      let turnAngularDelta = turnEndBearing - turnStartBearing;
      if (turnDirection === "right" && turnEndBearing <= turnStartBearing) {
        turnAngularDelta += 360;
      } else if (turnDirection === "left" && turnEndBearing >= turnStartBearing) {
        turnAngularDelta -= 360;
      }
      const turnMiddleBearing = (turnStartBearing + turnAngularDelta / 2 + 360) % 360;
      const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
      const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
      const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
      turnRadiusRad = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
      this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusRad, turnCenter, turnStart, turnMiddle, turnEnd);
      return toIndex;
    }
    setEmptyTurn(fromLegCalc, toLegCalc) {
      fromLegCalc.egress.length = 0;
      fromLegCalc.egressJoinIndex = -1;
      toLegCalc.ingress.length = 0;
      toLegCalc.ingressJoinIndex = -1;
    }
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end) {
      var _a, _b;
      var _c, _d;
      const egress = (_a = (_c = fromLegCalc.egress)[0]) !== null && _a !== void 0 ? _a : _c[0] = FlightPathUtils.createEmptyCircleVector();
      const ingress = (_b = (_d = toLegCalc.ingress)[0]) !== null && _b !== void 0 ? _b : _d[0] = FlightPathUtils.createEmptyCircleVector();
      fromLegCalc.egress.length = 1;
      toLegCalc.ingress.length = 1;
      fromLegCalc.egressJoinIndex = fromLegCalc.flightPath.length - 1;
      toLegCalc.ingressJoinIndex = 0;
      const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
      const egressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | fromLegCalc.flightPath[fromLegCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      const ingressFlags = FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.AnticipatedTurn | toLegCalc.flightPath[toLegCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback;
      FlightPathUtils.setCircleVector(egress, circle, start, middle, egressFlags);
      FlightPathUtils.setCircleVector(ingress, circle, middle, end, ingressFlags);
    }
  };
  FlightPathTurnCalculator.vector3Cache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
  ];
  FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
  FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
  };
  var FlightPlanUtils = class {
    static isAltitudeLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    static isHeadingToLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    static isHoldLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    static isManualDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    static isDiscontinuityLeg(legType) {
      return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    static getTerminatorIcao(leg) {
      switch (leg.type) {
        case LegType2.IF:
        case LegType2.TF:
        case LegType2.DF:
        case LegType2.CF:
        case LegType2.AF:
        case LegType2.RF:
        case LegType2.HA:
        case LegType2.HF:
        case LegType2.HM:
          return leg.fixIcao;
        default:
          return void 0;
      }
    }
  };
  FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType2.CA, LegType2.FA, LegType2.VA];
  FlightPlanUtils.HEADING_LEG_TYPES = [LegType2.VA, LegType2.VD, LegType2.VI, LegType2.VM, LegType2.VR];
  FlightPlanUtils.HOLD_LEG_TYPES = [LegType2.HA, LegType2.HF, LegType2.HM];
  FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType2.FM, LegType2.VM];
  FlightPlanUtils.DISCO_LEG_TYPES = [LegType2.Discontinuity, LegType2.ThruDiscontinuity];
  var FlightPathAirplaneSpeedMode;
  (function(FlightPathAirplaneSpeedMode2) {
    FlightPathAirplaneSpeedMode2["Default"] = "Default";
    FlightPathAirplaneSpeedMode2["GroundSpeed"] = "GroundSpeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeed"] = "TrueAirspeed";
    FlightPathAirplaneSpeedMode2["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
  })(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
  var LegEventType;
  (function(LegEventType2) {
    LegEventType2["Added"] = "Added";
    LegEventType2["Removed"] = "Removed";
    LegEventType2["Changed"] = "Changed";
  })(LegEventType || (LegEventType = {}));
  var SegmentEventType;
  (function(SegmentEventType2) {
    SegmentEventType2["Added"] = "Added";
    SegmentEventType2["Removed"] = "Removed";
    SegmentEventType2["Changed"] = "Changed";
    SegmentEventType2["Inserted"] = "Inserted";
  })(SegmentEventType || (SegmentEventType = {}));
  var ActiveLegType;
  (function(ActiveLegType2) {
    ActiveLegType2["Lateral"] = "Lateral";
    ActiveLegType2["Vertical"] = "Vertical";
    ActiveLegType2["Calculating"] = "Calculating";
  })(ActiveLegType || (ActiveLegType = {}));
  var OriginDestChangeType;
  (function(OriginDestChangeType2) {
    OriginDestChangeType2["OriginAdded"] = "OriginAdded";
    OriginDestChangeType2["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType2["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType2["DestinationRemoved"] = "DestinationRemoved";
  })(OriginDestChangeType || (OriginDestChangeType = {}));
  var FlightPlan = class {
    constructor(planIndex, calculator, onLegNameRequested) {
      this.planIndex = planIndex;
      this.calculator = calculator;
      this.onLegNameRequested = onLegNameRequested;
      this._activeLateralLeg = 0;
      this._activeVerticalLeg = 0;
      this._activeCalculatingLeg = 0;
      this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
      this.events = {};
      this.procedureDetails = new ProcedureDetails2();
      this.planSegments = [];
      this.userData = {};
    }
    get originAirport() {
      return this._originAirport;
    }
    get destinationAirport() {
      return this._destinationAirport;
    }
    get activeLateralLeg() {
      return this._activeLateralLeg;
    }
    get activeVerticalLeg() {
      return this._activeVerticalLeg;
    }
    get activeCalculatingLeg() {
      return this._activeCalculatingLeg;
    }
    get length() {
      const segment = this.planSegments[this.planSegments.length - 1];
      if (segment !== void 0) {
        return segment.offset + segment.legs.length;
      }
      return 0;
    }
    get segmentCount() {
      return this.planSegments.length;
    }
    legs(reverse = false, startIndex, endIndex) {
      return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    *_legs(startIndex = 0, endIndex = this.length) {
      endIndex = Math.min(this.length, endIndex);
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.min(segment.legs.length, endIndex - segment.offset);
          if (end <= 0) {
            return;
          }
          for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
            yield segment.legs[l];
          }
        }
      }
    }
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
      endIndex = Math.max(-1, endIndex);
      for (let i = this.planSegments.length - 1; i > -1; i--) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.legs.length > 0) {
          const end = Math.max(-1, endIndex - segment.offset);
          if (end >= segment.legs.length) {
            return;
          }
          for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
            yield segment.legs[l];
          }
        }
      }
    }
    *segments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0) {
          yield segment;
        }
      }
    }
    *segmentsOfType(segmentType) {
      for (const segment of this.segments()) {
        if (segment.segmentType == segmentType) {
          yield segment;
        }
      }
    }
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = new FlightPlanSegment2(segmentIndex, -1, [], segmentType, airway);
      this.planSegments[segmentIndex] = segment;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
      return segment;
    }
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segment !== void 0) {
        const newSegment = new FlightPlanSegment2(segmentIndex, -1, [], segmentType, airway);
        this.planSegments.splice(segmentIndex, 0, newSegment);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
        return newSegment;
      } else {
        return this.addSegment(segmentIndex, segmentType, airway, notify);
      }
    }
    reflowSegments() {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment !== void 0 && segment.segmentIndex !== i) {
          segment.segmentIndex = i;
        }
      }
    }
    deleteSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      if (segmentIndex === this.planSegments.length - 1) {
        this.planSegments.splice(segmentIndex, 1);
      } else {
        delete this.planSegments[segmentIndex];
      }
      if (this.directToData.segmentIndex === segmentIndex)
        ;
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    removeSegment(segmentIndex, notify = true) {
      const segment = this.planSegments[segmentIndex];
      this.planSegments.splice(segmentIndex, 1);
      this.reflowSegments();
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    getSegment(segmentIndex) {
      const segment = this.tryGetSegment(segmentIndex);
      if (segment === null) {
        throw new Error(`Flight plan segment with ${segmentIndex === void 0 ? "active leg" : `segment index ${segmentIndex}`} could not be found.`);
      } else {
        return segment;
      }
    }
    tryGetSegment(segmentIndex) {
      if (segmentIndex === void 0) {
        let calculatedSegmentIndex = 0;
        for (const segment2 of this.segments()) {
          if (this.activeLateralLeg == 0 && segment2.legs.length == 0) {
            calculatedSegmentIndex++;
          } else if (this.activeLateralLeg > segment2.offset + segment2.legs.length) {
            calculatedSegmentIndex++;
          } else {
            break;
          }
        }
        const segment = this.planSegments[calculatedSegmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      } else if (segmentIndex >= 0) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== void 0) {
          return segment;
        }
      }
      return null;
    }
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
      const segment = this.getSegment(segmentIndex);
      const legDefinition = {
        name: this.onLegNameRequested(leg),
        leg,
        flags,
        verticalData: {
          phase: VerticalFlightPhase.Descent,
          altDesc: AltitudeRestrictionType.Unused,
          altitude1: 0,
          altitude2: 0,
          displayAltitude1AsFlightLevel: false,
          displayAltitude2AsFlightLevel: false,
          speedDesc: SpeedRestrictionType.Unused,
          speed: 0,
          speedUnit: SpeedUnit.IAS
        }
      };
      if (segmentLegIndex === void 0) {
        segment.legs.push(legDefinition);
        segmentLegIndex = segment.legs.length - 1;
      } else {
        segment.legs.splice(segmentLegIndex, 0, legDefinition);
      }
      this.reflowSegmentOffsets();
      notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
      return legDefinition;
    }
    getLeg(arg1, arg2) {
      const leg = this._tryGetLeg(arg1, arg2);
      if (leg) {
        return leg;
      }
      throw new Error(`Leg with ${arg2 === void 0 ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    tryGetLeg(arg1, arg2) {
      return this._tryGetLeg(arg1, arg2);
    }
    _tryGetLeg(arg1, arg2) {
      var _a, _b;
      if (arg2 === void 0) {
        const legIndex = arg1;
        for (const segment of this.segments()) {
          if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
            return segment.legs[legIndex - segment.offset];
          }
        }
        return null;
      } else {
        const segmentIndex = arg1;
        const segmentLegIndex = arg2;
        return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
      }
    }
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
      const segment = this.getSegment(segmentIndex);
      let legDefinition;
      if (segmentLegIndex === void 0) {
        legDefinition = segment.legs.pop();
        segmentLegIndex = segment.legs.length;
      } else {
        const deleted = segment.legs.splice(segmentLegIndex, 1);
        legDefinition = deleted[0];
      }
      if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex)
        ;
      this.reflowSegmentOffsets();
      notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
      return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    async calculate(globalLegIndex, notify = true) {
      const legs = [...this.legs()];
      await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === void 0 ? this.activeCalculatingLeg : globalLegIndex);
      notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    setOriginAirport(facilityIcao, notify = true) {
      this._originAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    removeOriginAirport(notify = true) {
      const facilityIcao = this._originAirport;
      this._originAirport = void 0;
      this.procedureDetails.departureIndex = -1;
      this.procedureDetails.departureRunwayIndex = -1;
      this.procedureDetails.departureTransitionIndex = -1;
      this.procedureDetails.originRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    setDestinationAirport(facilityIcao, notify = true) {
      this._destinationAirport = facilityIcao;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    removeDestinationAirport(notify = true) {
      const facilityIcao = this._destinationAirport;
      this._destinationAirport = void 0;
      this.procedureDetails.approachIndex = -1;
      this.procedureDetails.approachTransitionIndex = -1;
      this.procedureDetails.arrivalIndex = -1;
      this.procedureDetails.arrivalRunwayTransitionIndex = -1;
      this.procedureDetails.arrivalRunway = void 0;
      this.procedureDetails.arrivalTransitionIndex = -1;
      this.procedureDetails.destinationRunway = void 0;
      notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    setLateralLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeLateralLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    setVerticalLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeVerticalLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    setCalculatingLeg(globalLegIndex, notify = true) {
      let previousLegIndex = -1;
      let previousSegmentIndex = -1;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      if (this.length > 0) {
        previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (previousSegmentIndex > -1) {
          previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
        }
        this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
        segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
        if (segmentIndex > -1) {
          segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
        }
      } else {
        this._activeCalculatingLeg = 0;
      }
      notify && this.events.onActiveLegChanged && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    setProcedureDetails(details, notify = true) {
      for (const key of Object.keys(this.procedureDetails)) {
        this.procedureDetails[key] = details[key];
      }
      notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    getLegIndexFromLeg(leg) {
      let index = 0;
      for (const toCompare of this.legs()) {
        if (toCompare === leg) {
          return index;
        }
        index++;
      }
      return -1;
    }
    getSegmentFromLeg(leg) {
      for (const segment of this.segments()) {
        if (segment.legs.includes(leg)) {
          return segment;
        }
      }
      return null;
    }
    getSegmentIndex(globalLegIndex) {
      for (const segment of this.segments()) {
        if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.segmentIndex;
        }
      }
      return -1;
    }
    getSegmentLegIndex(globalLegIndex) {
      const segmentIndex = this.getSegmentIndex(globalLegIndex);
      if (segmentIndex === -1) {
        return -1;
      }
      return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    getPrevLeg(segmentIndex, legIndex) {
      var _a, _b;
      if (segmentIndex < 0) {
        return null;
      }
      segmentIndex = Math.min(segmentIndex, this.planSegments.length);
      legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
      while (!leg && --segmentIndex >= 0) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[segment.legs.length - 1];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    getNextLeg(segmentIndex, legIndex) {
      if (segmentIndex >= this.planSegments.length) {
        return null;
      }
      segmentIndex = Math.max(segmentIndex, -1);
      legIndex = Math.max(legIndex, -1);
      let segment = this.planSegments[segmentIndex];
      let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
      while (!leg && ++segmentIndex < this.planSegments.length) {
        segment = this.planSegments[segmentIndex];
        if (segment) {
          leg = segment.legs[0];
        }
      }
      return leg !== null && leg !== void 0 ? leg : null;
    }
    setDirectToData(arg1, arg2, arg3) {
      if (typeof arg1 !== "number") {
        arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
      }
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let notify = true;
      if (typeof arg2 !== "number") {
        const globalLegIndex = arg1;
        if (globalLegIndex >= 0) {
          segmentIndex = this.getSegmentIndex(globalLegIndex);
          if (segmentIndex >= 0) {
            segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
          }
        }
        notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
      }
      this.directToData.segmentIndex = segmentIndex;
      this.directToData.segmentLegIndex = segmentLegIndex;
      notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    setLegVerticalData(arg1, arg2, arg3, arg4) {
      let notify = true;
      let segmentIndex = -1;
      let segmentLegIndex = -1;
      let verticalData;
      if (typeof arg2 !== "number") {
        segmentIndex = this.getSegmentIndex(arg1);
        const segment = this.getSegment(segmentIndex);
        segmentLegIndex = arg1 - segment.offset;
        verticalData = arg2;
        notify = arg3 !== void 0 ? arg3 : notify;
      } else {
        segmentIndex = arg1;
        segmentLegIndex = arg2;
        verticalData = arg3;
        notify = arg4 !== void 0 ? arg4 : notify;
      }
      const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
      if (leg) {
        Object.assign(leg.verticalData, verticalData);
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
      } else {
        console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
      }
    }
    setAirway(segmentIndex, airway, notify = true) {
      const segment = this.getSegment(segmentIndex);
      if (!airway) {
        segment.airway = void 0;
      } else {
        segment.airway = airway;
      }
      this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    setUserData(key, data, notify = true) {
      this.userData[key] = data;
      this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    deleteUserData(key, notify = true) {
      if (this.userData[key] !== void 0) {
        delete this.userData[key];
      }
      this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    getUserData(key) {
      return this.userData[key];
    }
    reflowSegmentOffsets() {
      let nextOffset = void 0;
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment) {
          if (nextOffset === void 0) {
            segment.offset = 0;
          } else {
            segment.offset = nextOffset;
          }
          nextOffset = segment.legs.length + segment.offset;
        }
      }
    }
    setOriginRunway(runway = void 0, notify = true) {
      this.procedureDetails.originRunway = runway;
      const details = new ProcedureDetails2();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setDestinationRunway(runway = void 0, notify = true) {
      this.procedureDetails.destinationRunway = runway;
      const details = new ProcedureDetails2();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setDeparture(facilityIcao = void 0, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
      this.procedureDetails.departureIndex = departureIndex;
      this.procedureDetails.departureFacilityIcao = facilityIcao;
      this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
      this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
      const details = new ProcedureDetails2();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setArrival(facilityIcao = void 0, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = void 0, notify = true) {
      this.procedureDetails.arrivalIndex = arrivalIndex;
      this.procedureDetails.arrivalFacilityIcao = facilityIcao;
      this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
      this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
      this.procedureDetails.arrivalRunway = arrivalRunway;
      const details = new ProcedureDetails2();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    setApproach(facilityIcao = void 0, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachFacilityIcao = facilityIcao;
      this.procedureDetails.approachIndex = approachIndex;
      this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
      const details = new ProcedureDetails2();
      Object.assign(details, this.procedureDetails);
      this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    copy(planIndex, copyCalcs = false) {
      if (planIndex === void 0) {
        planIndex = this.planIndex;
      }
      const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
      newPlan.setProcedureDetails(this.procedureDetails, false);
      newPlan.setDirectToData(this.directToData.segmentIndex, this.directToData.segmentLegIndex);
      for (const segment of this.segments()) {
        newPlan.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
        for (const leg of segment.legs) {
          const newLeg = newPlan.addLeg(segment.segmentIndex, leg.leg, void 0, leg.flags, false);
          const legIndex = newPlan.getLegIndexFromLeg(newLeg);
          newPlan.setLegVerticalData(legIndex, leg.verticalData);
          copyCalcs && this.copyLegCalculations(leg, newLeg);
        }
      }
      if (this.originAirport !== void 0) {
        newPlan.setOriginAirport(this.originAirport, false);
      }
      if (this.destinationAirport !== void 0) {
        newPlan.setDestinationAirport(this.destinationAirport, false);
      }
      newPlan.setLateralLeg(this.activeLateralLeg);
      newPlan.setVerticalLeg(this.activeVerticalLeg);
      newPlan.setCalculatingLeg(this.activeCalculatingLeg);
      for (const key in this.userData) {
        newPlan.setUserData(key, this.userData[key], false);
      }
      return newPlan;
    }
    copyLegCalculations(existingLeg, newLeg) {
      if (existingLeg.calculated !== void 0) {
        newLeg.calculated = {
          courseMagVar: existingLeg.calculated.courseMagVar,
          initialDtk: existingLeg.calculated.initialDtk,
          distance: existingLeg.calculated.distance,
          cumulativeDistance: existingLeg.calculated.cumulativeDistance,
          distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
          cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
          startLat: existingLeg.calculated.startLat,
          startLon: existingLeg.calculated.startLon,
          endLat: existingLeg.calculated.endLat,
          endLon: existingLeg.calculated.endLon,
          flightPath: existingLeg.calculated.flightPath.map((vector) => Object.assign({}, vector)),
          ingress: existingLeg.calculated.ingress.map((vector) => Object.assign({}, vector)),
          ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
          ingressToEgress: existingLeg.calculated.ingressToEgress.map((vector) => Object.assign({}, vector)),
          egressJoinIndex: existingLeg.calculated.egressJoinIndex,
          egress: existingLeg.calculated.egress.map((vector) => Object.assign({}, vector)),
          endsInFallback: existingLeg.calculated.endsInFallback
        };
      }
      return newLeg;
    }
  };
  FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0
  }, partial);
  var SubEvent = class {
    constructor() {
      this.subs = [];
      this.notifyDepth = 0;
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    on(handler, paused = false) {
      const sub2 = new HandlerSubscription(handler, void 0, this.onSubDestroyedFunc);
      this.subs.push(sub2);
      if (paused) {
        sub2.pause();
      }
      return sub2;
    }
    off(handler) {
      const toDestroy = this.subs.find((sub2) => sub2.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    clear() {
      this.notifyDepth++;
      for (let i = 0; i < this.subs.length; i++) {
        this.subs[i].destroy();
      }
      this.notifyDepth--;
      if (this.notifyDepth === 0) {
        this.subs.length = 0;
      }
    }
    notify(sender, data) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub2 = this.subs[i];
          if (sub2.isAlive && !sub2.isPaused) {
            sub2.handler(sender, data);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub2.isAlive);
        } catch (error) {
          console.error(`SubEvent: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub2) => sub2.isAlive);
      }
    }
    onSubDestroyed(sub2) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub2), 1);
      }
    }
  };
  var WaypointTypes;
  (function(WaypointTypes2) {
    WaypointTypes2["Custom"] = "Custom";
    WaypointTypes2["Airport"] = "Airport";
    WaypointTypes2["NDB"] = "NDB";
    WaypointTypes2["VOR"] = "VOR";
    WaypointTypes2["Intersection"] = "Intersection";
    WaypointTypes2["Runway"] = "Runway";
    WaypointTypes2["User"] = "User";
    WaypointTypes2["Visual"] = "Visual";
    WaypointTypes2["FlightPlan"] = "FlightPlan";
    WaypointTypes2["VNAV"] = "VNAV";
  })(WaypointTypes || (WaypointTypes = {}));
  var AbstractWaypoint = class {
    equals(other) {
      return this.uid === other.uid;
    }
  };
  var BasicFacilityWaypoint = class extends AbstractWaypoint {
    constructor(facility, bus) {
      super();
      this.bus = bus;
      this.isFacilityWaypoint = true;
      this._facility = Subject.create(facility);
      this._location = GeoPointSubject.createFromGeoPoint(new GeoPoint(facility.lat, facility.lon));
      this._type = BasicFacilityWaypoint.getType(facility);
      const facType = ICAO.getFacilityType(facility.icao);
      if (facType === FacilityType.VIS || facType === FacilityType.USR) {
        this.facChangeSub = this.bus.getSubscriber().on(`facility_changed_${facility.icao}`).handle((newFacility) => {
          this._facility.set(newFacility);
          this._location.set(newFacility.lat, newFacility.lon);
        });
      }
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this.facility.get().icao;
    }
    get type() {
      return this._type;
    }
    get facility() {
      return this._facility;
    }
    static getType(facility) {
      switch (ICAO.getFacilityType(facility.icao)) {
        case FacilityType.Airport:
          return WaypointTypes.Airport;
        case FacilityType.Intersection:
          return WaypointTypes.Intersection;
        case FacilityType.NDB:
          return WaypointTypes.NDB;
        case FacilityType.RWY:
          return WaypointTypes.Runway;
        case FacilityType.USR:
          return WaypointTypes.User;
        case FacilityType.VIS:
          return WaypointTypes.Visual;
        case FacilityType.VOR:
          return WaypointTypes.VOR;
        default:
          return WaypointTypes.User;
      }
    }
  };
  var FacilityWaypointUtils = class {
    static isFacilityWaypoint(waypoint, facilityType) {
      if (waypoint.isFacilityWaypoint !== true) {
        return false;
      }
      return facilityType === void 0 || FacilityUtils.isFacilityType(waypoint.facility.get(), facilityType);
    }
  };
  var FlightPathWaypoint = class extends AbstractWaypoint {
    constructor(arg1, arg2, arg3, arg4, arg5) {
      super();
      if (typeof arg1 === "number") {
        this._location = GeoPointSubject.create(new GeoPoint(arg1, arg2));
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg4}`;
        this.leg = arg3;
        this.ident = arg5;
      } else {
        this._location = arg1;
        this._uid = `${FlightPathWaypoint.UID_PREFIX}_${arg3}`;
        this.leg = arg2;
        this.ident = arg4;
      }
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this._uid;
    }
    get type() {
      return WaypointTypes.FlightPlan;
    }
  };
  FlightPathWaypoint.UID_PREFIX = "FLPTH";
  var VNavWaypoint = class extends AbstractWaypoint {
    constructor(leg, distanceFromEnd, uid, ident) {
      super();
      this.ident = ident;
      this._uid = uid;
      this._location = GeoPointSubject.create(this.getWaypointLocation(leg, distanceFromEnd, new GeoPoint(0, 0)));
    }
    get type() {
      return WaypointTypes.VNAV;
    }
    get location() {
      return this._location;
    }
    get uid() {
      return this._uid;
    }
    setLocation(leg, distanceFromEnd) {
      this._location.set(this.getWaypointLocation(leg, distanceFromEnd, VNavWaypoint.geoPointCache[0]));
    }
    getWaypointLocation(leg, distanceFromEnd, out) {
      var _a, _b;
      if (leg.calculated !== void 0) {
        const vectors = [...leg.calculated.ingress, ...leg.calculated.ingressToEgress, ...leg.calculated.egress];
        let vectorIndex = vectors.length - 1;
        while (vectorIndex >= 0) {
          const vector = vectors[vectorIndex];
          const vectorDistance = vector.distance;
          if (vectorDistance >= distanceFromEnd) {
            const end = GeoPoint.sphericalToCartesian(vector.endLat, vector.endLon, VNavWaypoint.vec3Cache[0]);
            return FlightPathUtils.setGeoCircleFromVector(vector, VNavWaypoint.geoCircleCache[0]).offsetDistanceAlong(end, UnitType.METER.convertTo(-distanceFromEnd, UnitType.GA_RADIAN), out, Math.PI);
          } else {
            distanceFromEnd -= vectorDistance;
          }
          vectorIndex--;
        }
        if (vectors.length > 0) {
          out.set(vectors[0].startLat, vectors[0].startLon);
        } else {
          out.set((_a = leg.calculated.endLat) !== null && _a !== void 0 ? _a : 0, (_b = leg.calculated.endLon) !== null && _b !== void 0 ? _b : 0);
        }
      }
      return out;
    }
  };
  VNavWaypoint.vec3Cache = [new Float64Array(3)];
  VNavWaypoint.geoPointCache = [new GeoPoint(0, 0)];
  VNavWaypoint.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var DefaultFacilityWaypointCache = class {
    constructor(bus, size2) {
      this.bus = bus;
      this.size = size2;
      this.cache = /* @__PURE__ */ new Map();
    }
    get(facility) {
      const key = DefaultFacilityWaypointCache.getFacilityKey(facility);
      let existing = this.cache.get(key);
      if (!existing) {
        existing = new BasicFacilityWaypoint(facility, this.bus);
        this.addToCache(key, existing);
      }
      return existing;
    }
    addToCache(key, waypoint) {
      this.cache.set(key, waypoint);
      if (this.cache.size > this.size) {
        this.cache.delete(this.cache.keys().next().value);
      }
    }
    static getCache(bus) {
      var _a;
      return (_a = DefaultFacilityWaypointCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.INSTANCE = new DefaultFacilityWaypointCache(bus, 1e3);
    }
    static getFacilityKey(facility) {
      if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection) && ICAO.getFacilityType(facility.icao) !== FacilityType.Intersection) {
        return `mismatch.${facility.icao}`;
      }
      return facility.icao;
    }
  };
  var DefaultLodBoundaryCache = class {
    static getCache() {
      var _a;
      return (_a = DefaultLodBoundaryCache.INSTANCE) !== null && _a !== void 0 ? _a : DefaultLodBoundaryCache.INSTANCE = new LodBoundaryCache(DefaultLodBoundaryCache.SIZE, DefaultLodBoundaryCache.DISTANCE_THRESHOLDS, DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS);
    }
  };
  DefaultLodBoundaryCache.SIZE = 500;
  DefaultLodBoundaryCache.DISTANCE_THRESHOLDS = [0, 3e-5, 1e-4, 3e-4];
  DefaultLodBoundaryCache.VECTOR_COUNT_TARGETS = [500, 300, 200, 100];
  var SubscribableMapFunctions = class {
    static identity() {
      return (input) => input;
    }
    static not() {
      return (input) => !input;
    }
    static negate() {
      return (input) => -input;
    }
    static abs() {
      return Math.abs;
    }
    static withPrecision(precision) {
      return SubscribableUtils.isSubscribable(precision) ? (input) => {
        const precisionVal = precision.get();
        return Math.round(input / precisionVal) * precisionVal;
      } : (input) => {
        return Math.round(input / precision) * precision;
      };
    }
    static changedBy(threshold) {
      return SubscribableUtils.isSubscribable(threshold) ? (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal : (input, currentVal) => currentVal === void 0 || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    static atFrequency(freq, timeFunc = Date.now) {
      let t0;
      let timeRemaining = 0;
      if (SubscribableUtils.isSubscribable(freq)) {
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            const period = 1e3 / freq.get();
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      } else {
        const period = 1e3 / freq;
        return (input, currentVal) => {
          let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
          const currentTime = timeFunc();
          const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : t0 = currentTime);
          t0 = currentTime;
          timeRemaining -= dt;
          if (timeRemaining <= 0) {
            timeRemaining = period + timeRemaining % period;
            returnValue = input;
          }
          return returnValue;
        };
      }
    }
  };
  var MappedSubject = class extends AbstractSubscribable {
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
      super();
      this.mapFunc = mapFunc;
      this.equalityFunc = equalityFunc;
      this.isSubscribable = true;
      this._isAlive = true;
      this._isPaused = false;
      this.inputs = inputs;
      this.inputValues = inputs.map((input) => input.get());
      if (initialVal && mutateFunc) {
        this.value = initialVal;
        mutateFunc(this.value, this.mapFunc(this.inputValues, void 0));
        this.mutateFunc = (newVal) => {
          mutateFunc(this.value, newVal);
        };
      } else {
        this.value = this.mapFunc(this.inputValues, void 0);
        this.mutateFunc = (newVal) => {
          this.value = newVal;
        };
      }
      this.inputSubs = this.inputs.map((input, index) => input.sub((inputValue) => {
        this.inputValues[index] = inputValue;
        this.updateValue();
      }));
    }
    get isAlive() {
      return this._isAlive;
    }
    get isPaused() {
      return this._isPaused;
    }
    static create(...args) {
      let mapFunc, equalityFunc, mutateFunc, initialVal;
      if (typeof args[0] === "function") {
        mapFunc = args.shift();
        if (typeof args[0] === "function") {
          equalityFunc = args.shift();
        } else {
          equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
        }
        if (typeof args[0] === "function") {
          mutateFunc = args.shift();
          initialVal = args.shift();
        }
      } else {
        mapFunc = MappedSubject.IDENTITY_MAP;
        equalityFunc = MappedSubject.NEVER_EQUALS;
      }
      return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    updateValue() {
      const value = this.mapFunc(this.inputValues, this.value);
      if (!this.equalityFunc(this.value, value)) {
        this.mutateFunc(value);
        this.notify();
      }
    }
    get() {
      return this.value;
    }
    pause() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot pause a dead subject");
      }
      if (this._isPaused) {
        return this;
      }
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].pause();
      }
      this._isPaused = true;
      return this;
    }
    resume() {
      if (!this._isAlive) {
        throw new Error("MappedSubject: cannot resume a dead subject");
      }
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputValues[i] = this.inputs[i].get();
        this.inputSubs[i].resume();
      }
      this.updateValue();
      return this;
    }
    destroy() {
      this._isAlive = false;
      for (let i = 0; i < this.inputSubs.length; i++) {
        this.inputSubs[i].destroy();
      }
    }
  };
  MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
  MappedSubject.NEVER_EQUALS = () => false;
  var SubscribableSetEventType;
  (function(SubscribableSetEventType2) {
    SubscribableSetEventType2["Added"] = "Added";
    SubscribableSetEventType2["Deleted"] = "Deleted";
  })(SubscribableSetEventType || (SubscribableSetEventType = {}));
  var ArraySubject = class extends AbstractSubscribableArray {
    constructor(arr) {
      super();
      this.array = arr;
    }
    get length() {
      return this.array.length;
    }
    static create(arr = []) {
      return new ArraySubject(arr);
    }
    insert(item, index) {
      if (index === void 0 || index > this.array.length - 1) {
        index = this.array.length;
        this.array.push(item);
      } else {
        this.array.splice(index, 0, item);
      }
      this.notify(index, SubscribableArrayEventType.Added, item);
    }
    insertRange(index = 0, arr) {
      this.array.splice(index, 0, ...arr);
      this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    removeAt(index) {
      const removedItem = this.array.splice(index, 1);
      this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    removeItem(item) {
      const index = this.array.indexOf(item);
      if (index > -1) {
        this.removeAt(index);
        return true;
      } else {
        return false;
      }
    }
    set(arr) {
      this.clear();
      this.insertRange(0, arr);
    }
    clear() {
      this.array.length = 0;
      this.notify(0, SubscribableArrayEventType.Cleared);
    }
    getArray() {
      return this.array;
    }
  };
  var ObjectSubject = class {
    constructor(obj) {
      this.obj = obj;
      this.isSubscribable = true;
      this.isMutableSubscribable = true;
      this.subs = [];
      this.notifyDepth = 0;
      this.initialNotifyFunc = this.initialNotify.bind(this);
      this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    static create(v) {
      return new ObjectSubject(v);
    }
    get() {
      return this.obj;
    }
    sub(handler, initialNotify = false, paused = false) {
      const sub2 = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
      this.subs.push(sub2);
      if (paused) {
        sub2.pause();
      } else if (initialNotify) {
        sub2.initialNotify();
      }
      return sub2;
    }
    unsub(handler) {
      const toDestroy = this.subs.find((sub2) => sub2.handler === handler);
      toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    set(arg1, value) {
      if (typeof arg1 === "object") {
        for (const prop in arg1) {
          if (prop in this.obj) {
            this.set(prop, arg1[prop]);
          }
        }
      } else {
        const oldValue = this.obj[arg1];
        if (value !== oldValue) {
          this.obj[arg1] = value;
          this.notify(arg1, oldValue);
        }
      }
    }
    notify(key, oldValue) {
      let needCleanUpSubs = false;
      this.notifyDepth++;
      const subLen = this.subs.length;
      for (let i = 0; i < subLen; i++) {
        try {
          const sub2 = this.subs[i];
          if (sub2.isAlive && !sub2.isPaused) {
            sub2.handler(this.obj, key, this.obj[key], oldValue);
          }
          needCleanUpSubs || (needCleanUpSubs = !sub2.isAlive);
        } catch (error) {
          console.error(`ObjectSubject: error in handler: ${error}`);
          if (error instanceof Error) {
            console.error(error.stack);
          }
        }
      }
      this.notifyDepth--;
      if (needCleanUpSubs && this.notifyDepth === 0) {
        this.subs = this.subs.filter((sub2) => sub2.isAlive);
      }
    }
    initialNotify(sub2) {
      for (const key in this.obj) {
        const v = this.obj[key];
        sub2.handler(this.obj, key, v, v);
      }
    }
    onSubDestroyed(sub2) {
      if (this.notifyDepth === 0) {
        this.subs.splice(this.subs.indexOf(sub2), 1);
      }
    }
    map(fn, equalityFunc, mutateFunc, initialVal) {
      const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
      return mutateFunc ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this) : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    pipe(to, arg2, arg3) {
      let sub2;
      let paused;
      if (typeof arg2 === "function") {
        sub2 = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
        paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
      } else {
        sub2 = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
        paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
      }
      this.subs.push(sub2);
      if (paused) {
        sub2.pause();
      } else {
        sub2.initialNotify();
      }
      return sub2;
    }
  };
  var NearestContext = class {
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this.airports = new NearestAirportSubscription(facilityLoader);
      this.vors = new NearestVorSubscription(facilityLoader);
      this.intersections = new NearestIntersectionSubscription(facilityLoader);
      this.ndbs = new NearestNdbSubscription(facilityLoader);
      this.usrs = new NearestUsrSubscription(facilityLoader);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("NearestContext was not initialized.");
    }
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new NearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("NearestContext was already initialized.");
      }
    }
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    getRegionCode() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region;
        }
      }
      return void 0;
    }
    getRegionIdent() {
      const region = this.getRegionCode();
      if (region !== void 0) {
        return region[0] === "K" ? "K" : region;
      }
      return void 0;
    }
    getRegionLetter() {
      const region = this.getRegionCode();
      return region !== void 0 ? region[0] : void 0;
    }
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  NearestContext.initializedSubEvent = new SubEvent();
  var AdaptiveNearestContext = class {
    constructor(facilityLoader, bus, planePos) {
      this.facilityLoader = facilityLoader;
      this.bus = bus;
      this.maxAirports = 25;
      this.maxVors = 25;
      this.maxIntersections = 25;
      this.maxNdbs = 25;
      this.maxUsrs = 25;
      this.airportRadius = 50;
      this.vorRadius = 150;
      this.intersectionRadius = 10;
      this.ndbRadius = 150;
      this.usrRadius = 150;
      this.position = new GeoPoint(0, 0);
      this._maxAirportsAbsolute = Subject.create(100);
      this._maxVorsAbsolute = Subject.create(100);
      this._maxIntersectionsAbsolute = Subject.create(100);
      this._maxNdbsAbsolute = Subject.create(100);
      this._maxUsrsAbsolute = Subject.create(100);
      this.airports = new AdaptiveNearestSubscription(new NearestAirportSubscription(facilityLoader), this._maxAirportsAbsolute);
      this.vors = new AdaptiveNearestSubscription(new NearestVorSubscription(facilityLoader), this._maxVorsAbsolute);
      this.intersections = new AdaptiveNearestSubscription(new NearestIntersectionSubscription(facilityLoader), this._maxIntersectionsAbsolute);
      this.ndbs = new AdaptiveNearestSubscription(new NearestNdbSubscription(facilityLoader), this._maxNdbsAbsolute);
      this.usrs = new AdaptiveNearestSubscription(new NearestUsrSubscription(facilityLoader), this._maxUsrsAbsolute);
      if (planePos) {
        planePos.sub((pos) => this.position.set(pos));
      } else {
        this.bus.getSubscriber().on("gps-position").handle((pos) => this.position.set(pos.lat, pos.long));
      }
      this.airports.start();
      this.vors.start();
      this.intersections.start();
      this.ndbs.start();
      this.usrs.start();
    }
    get maxAirportsAbsolute() {
      return this._maxAirportsAbsolute.get();
    }
    set maxAirportsAbsolute(val) {
      this._maxAirportsAbsolute.set(val);
    }
    get maxVorsAbsolute() {
      return this._maxVorsAbsolute.get();
    }
    set maxVorsAbsolute(val) {
      this._maxVorsAbsolute.set(val);
    }
    get maxIntersectionsAbsolute() {
      return this._maxIntersectionsAbsolute.get();
    }
    set maxIntersectionsAbsolute(val) {
      this._maxIntersectionsAbsolute.set(val);
    }
    get maxNdbsAbsolute() {
      return this._maxNdbsAbsolute.get();
    }
    set maxNdbsAbsolute(val) {
      this._maxNdbsAbsolute.set(val);
    }
    get maxUsrsAbsolute() {
      return this._maxUsrsAbsolute.get();
    }
    set maxUsrsAbsolute(val) {
      this._maxUsrsAbsolute.set(val);
    }
    static getInstance() {
      if (this.instance !== void 0) {
        return this.instance;
      }
      throw new Error("AdaptiveNearestContext was not initialized.");
    }
    static initialize(facilityLoader, bus, planePos) {
      if (this.instance === void 0) {
        this.instance = new AdaptiveNearestContext(facilityLoader, bus, planePos);
        this.initializedSubEvent.notify(null, this.instance);
      } else {
        throw new Error("AdaptiveNearestContext was already initialized.");
      }
    }
    static onInitialized(handler) {
      if (this.instance) {
        handler(this.instance);
        return null;
      } else {
        return this.initializedSubEvent.on((_, instance) => handler(instance));
      }
    }
    async update() {
      await Promise.all([
        this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
        this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
        this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
        this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
        this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs)
      ]);
    }
    getRegionLetter() {
      const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
      for (let i = 0; i < nearest.length; i++) {
        const region = AirportUtils.tryGetRegionCode(nearest[i]);
        if (region !== void 0) {
          return region[0];
        }
      }
      return void 0;
    }
    getNearest(facilityType) {
      switch (facilityType) {
        case FacilityType.Airport:
          return this.findNearest(this.airports.getArray());
        case FacilityType.Intersection:
          return this.findNearest(this.intersections.getArray());
        case FacilityType.VOR:
          return this.findNearest(this.vors.getArray());
        case FacilityType.NDB:
          return this.findNearest(this.ndbs.getArray());
        case FacilityType.USR:
          return this.findNearest(this.usrs.getArray());
        default:
          return void 0;
      }
    }
    findNearest(array) {
      let nearest = void 0;
      let nearestDistance = Infinity;
      for (let i = 0; i < array.length; i++) {
        const fac = array[i];
        const distance = this.position.distance(fac);
        if (distance < nearestDistance) {
          nearest = fac;
          nearestDistance = distance;
        }
      }
      return nearest;
    }
    orderByPPosDistance(a, b) {
      const aDist = this.position.distance(a.lat, a.lon);
      const bDist = this.position.distance(b.lat, b.lon);
      if (aDist < bDist) {
        return -1;
      }
      if (aDist > bDist) {
        return 1;
      }
      return 0;
    }
  };
  AdaptiveNearestContext.initializedSubEvent = new SubEvent();
  var IcaoSearchFilter;
  (function(IcaoSearchFilter2) {
    IcaoSearchFilter2[IcaoSearchFilter2["ALL"] = 0] = "ALL";
    IcaoSearchFilter2[IcaoSearchFilter2["AIRPORT"] = 1] = "AIRPORT";
    IcaoSearchFilter2[IcaoSearchFilter2["VOR"] = 2] = "VOR";
    IcaoSearchFilter2[IcaoSearchFilter2["NDB"] = 3] = "NDB";
    IcaoSearchFilter2[IcaoSearchFilter2["INTERSECTION"] = 4] = "INTERSECTION";
    IcaoSearchFilter2[IcaoSearchFilter2["USR"] = 5] = "USR";
  })(IcaoSearchFilter || (IcaoSearchFilter = {}));
  var ElectricalPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(ElectricalPublisher.simvars, bus, pacer);
      this.flightStarted = false;
      this.avBusList = ["elec_av1_bus", "elec_av2_bus"];
      for (const topic of this.avBusList) {
        if (bus.getTopicSubscriberCount(topic)) {
          this.subscribed.add(topic);
        }
      }
      bus.getSubscriber().on("event_bus_topic_first_sub").handle((event) => {
        if (this.avBusList.includes(event)) {
          this.subscribed.add(event);
        }
      });
      const gameStateSub = GameStateProvider.get().sub((state) => {
        if (state === GameState.briefing || state === GameState.ingame) {
          gameStateSub.destroy();
          this.flightStarted = true;
        }
      }, false, true);
      gameStateSub.resume(true);
    }
    onUpdate() {
      if (this.flightStarted) {
        super.onUpdate();
        if (this.av1BusLogic && this.subscribed.has("elec_av1_bus")) {
          this.publish("elec_av1_bus", this.av1BusLogic.getValue() !== 0);
        }
        if (this.av2BusLogic && this.subscribed.has("elec_av2_bus")) {
          this.publish("elec_av2_bus", this.av2BusLogic.getValue() !== 0);
        }
      }
    }
    setAv1Bus(logicElement) {
      this.av1BusLogic = logicElement;
    }
    setAv2Bus(logicElement) {
      this.av2BusLogic = logicElement;
    }
  };
  ElectricalPublisher.simvars = /* @__PURE__ */ new Map([
    ["elec_master_battery", { name: "ELECTRICAL MASTER BATTERY", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_1", { name: "CIRCUIT AVIONICS ON:1", type: SimVarValueType.Bool }],
    ["elec_circuit_avionics_on_2", { name: "CIRCUIT AVIONICS ON:2", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom1_on", { name: "CIRCUIT NAVCOM1 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom2_on", { name: "CIRCUIT NAVCOM2 ON", type: SimVarValueType.Bool }],
    ["elec_circuit_navcom3_on", { name: "CIRCUIT NAVCOM3 ON", type: SimVarValueType.Bool }],
    ["elec_bus_main_v", { name: "ELECTRICAL MAIN BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_main_a", { name: "ELECTRICAL MAIN BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_avionics_v", { name: "ELECTRICAL AVIONICS BUS VOLTAGE", type: SimVarValueType.Volts }],
    ["elec_bus_avionics_a", { name: "ELECTRICAL AVIONICS BUS AMPS", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_1_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_2_v", { name: "ELECTRICAL GENALT BUS VOLTAGE:2", type: SimVarValueType.Volts }],
    ["elec_bus_genalt_1_a", { name: "ELECTRICAL GENALT BUS AMPS:1", type: SimVarValueType.Amps }],
    ["elec_bus_genalt_2_a", { name: "ELECTRICAL GENALT BUS AMPS:2", type: SimVarValueType.Amps }],
    ["elec_bat_a_1", { name: "ELECTRICAL BATTERY LOAD:1", type: SimVarValueType.Amps }],
    ["elec_bat_v_1", { name: "ELECTRICAL BATTERY VOLTAGE:1", type: SimVarValueType.Volts }],
    ["elec_bat_a_2", { name: "ELECTRICAL BATTERY LOAD:2", type: SimVarValueType.Amps }],
    ["elec_bat_v_2", { name: "ELECTRICAL BATTERY VOLTAGE:2", type: SimVarValueType.Volts }]
  ]);
  var FlightTimerMode;
  (function(FlightTimerMode2) {
    FlightTimerMode2[FlightTimerMode2["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode2[FlightTimerMode2["CountingUp"] = 1] = "CountingUp";
  })(FlightTimerMode || (FlightTimerMode = {}));
  var SBASGroupName;
  (function(SBASGroupName2) {
    SBASGroupName2["WAAS"] = "WAAS";
    SBASGroupName2["EGNOS"] = "EGNOS";
    SBASGroupName2["GAGAN"] = "GAGAN";
    SBASGroupName2["MSAS"] = "MSAS";
  })(SBASGroupName || (SBASGroupName = {}));
  var GPSSatelliteState;
  (function(GPSSatelliteState2) {
    GPSSatelliteState2["None"] = "None";
    GPSSatelliteState2["Unreachable"] = "Unreachable";
    GPSSatelliteState2["Acquired"] = "Acquired";
    GPSSatelliteState2["Faulty"] = "Faulty";
    GPSSatelliteState2["DataCollected"] = "DataCollected";
    GPSSatelliteState2["InUse"] = "InUse";
    GPSSatelliteState2["InUseDiffApplied"] = "InUseDiffApplied";
  })(GPSSatelliteState || (GPSSatelliteState = {}));
  var GPSSystemState;
  (function(GPSSystemState2) {
    GPSSystemState2["Searching"] = "Searching";
    GPSSystemState2["Acquiring"] = "Acquiring";
    GPSSystemState2["SolutionAcquired"] = "SolutionAcquired";
    GPSSystemState2["DiffSolutionAcquired"] = "DiffSolutionAcquired";
  })(GPSSystemState || (GPSSystemState = {}));
  var GPSSystemSBASState;
  (function(GPSSystemSBASState2) {
    GPSSystemSBASState2["Disabled"] = "Disabled";
    GPSSystemSBASState2["Inactive"] = "Inactive";
    GPSSystemSBASState2["Active"] = "Active";
  })(GPSSystemSBASState || (GPSSystemSBASState = {}));
  var MinimumsMode;
  (function(MinimumsMode2) {
    MinimumsMode2[MinimumsMode2["OFF"] = 0] = "OFF";
    MinimumsMode2[MinimumsMode2["BARO"] = 1] = "BARO";
    MinimumsMode2[MinimumsMode2["RA"] = 2] = "RA";
    MinimumsMode2[MinimumsMode2["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
  })(MinimumsMode || (MinimumsMode = {}));
  var MinimumsSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(MinimumsSimVarPublisher.simvars, bus);
    }
  };
  MinimumsSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["decision_height_feet", { name: "DECISION HEIGHT", type: SimVarValueType.Feet }],
    ["decision_altitude_feet", { name: "DECISION ALTITUDE MSL", type: SimVarValueType.Feet }],
    ["minimums_mode", { name: "L:WT_MINIMUMS_MODE", type: SimVarValueType.Number }]
  ]);
  var NavComSimVarPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(NavComSimVarPublisher.simvars, bus, pacer);
    }
    static createNavRadioDefinitions(index) {
      return [
        [`nav_active_frequency_${index}`, { name: `NAV ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_standby_frequency_${index}`, { name: `NAV STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
        [`nav_sound_${index}`, { name: `NAV SOUND:${index}`, type: SimVarValueType.Bool }],
        [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
        [`nav_volume_${index}`, { name: `NAV VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    static createComRadioDefinitions(index) {
      return [
        [`com_active_frequency_${index}`, { name: `COM ACTIVE FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_standby_frequency_${index}`, { name: `COM STANDBY FREQUENCY:${index}`, type: SimVarValueType.MHz }],
        [`com_active_facility_name_${index}`, { name: `COM ACTIVE FREQ NAME:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_type_${index}`, { name: `COM ACTIVE FREQ TYPE:${index}`, type: SimVarValueType.String }],
        [`com_active_facility_ident_${index}`, { name: `COM ACTIVE FREQ IDENT:${index}`, type: SimVarValueType.String }],
        [`com_receive_${index}`, { name: `COM RECEIVE EX1:${index}`, type: SimVarValueType.Bool }],
        [`com_status_${index}`, { name: `COM STATUS:${index}`, type: SimVarValueType.Number }],
        [`com_transmit_${index}`, { name: `COM TRANSMIT:${index}`, type: SimVarValueType.Bool }],
        [`com_spacing_mode_${index}`, { name: `COM SPACING MODE:${index}`, type: SimVarValueType.Enum }],
        [`com_volume_${index}`, { name: `COM VOLUME:${index}`, type: SimVarValueType.Percent }]
      ];
    }
    static createAdfRadioDefinitions(index) {
      return [
        [`adf_active_frequency_${index}`, { name: `ADF ACTIVE FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_standby_frequency_${index}`, { name: `ADF STANDBY FREQUENCY:${index}`, type: SimVarValueType.KHz }],
        [`adf_sound_${index}`, { name: `ADF SOUND:${index}`, type: SimVarValueType.Bool }],
        [`adf_volume_${index}`, { name: `ADF VOLUME:${index}`, type: SimVarValueType.Percent }],
        [`adf_ident_${index}`, { name: `ADF IDENT:${index}`, type: SimVarValueType.String }],
        [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }]
      ];
    }
  };
  NavComSimVarPublisher.simvars = new Map([
    ...NavComSimVarPublisher.createNavRadioDefinitions(1),
    ...NavComSimVarPublisher.createNavRadioDefinitions(2),
    ...NavComSimVarPublisher.createNavRadioDefinitions(3),
    ...NavComSimVarPublisher.createNavRadioDefinitions(4),
    ...NavComSimVarPublisher.createComRadioDefinitions(1),
    ...NavComSimVarPublisher.createComRadioDefinitions(2),
    ...NavComSimVarPublisher.createComRadioDefinitions(3),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavComSimVarPublisher.createAdfRadioDefinitions(2),
    ["marker_beacon_hisense_on", { name: "MARKER BEACON SENSITIVITY HIGH", type: SimVarValueType.Bool }],
    ["marker_beacon_sound", { name: "MARKER SOUND", type: SimVarValueType.Bool }]
  ]);
  var PitotPublisher = class extends SimVarPublisher {
    constructor(bus, pitotCount, pacer) {
      const indexedSimVars = [
        ["pitot_heat_switch_on", { name: "PITOT HEAT SWITCH", type: SimVarValueType.Bool }]
      ];
      const simvars = new Map(PitotPublisher.nonIndexedSimVars);
      for (const [topic, simvar2] of indexedSimVars) {
        for (let i = 1; i <= pitotCount; i++) {
          simvars.set(`${topic}_${i}`, {
            name: `${simvar2.name}:${i}`,
            type: simvar2.type,
            map: simvar2.map
          });
        }
      }
      super(simvars, bus, pacer);
    }
  };
  PitotPublisher.nonIndexedSimVars = [
    ["pitot_heat_on", { name: "PITOT HEAT", type: SimVarValueType.Bool }],
    ["pitot_icing_pct", { name: "PITOT ICE PCT", type: SimVarValueType.Percent }]
  ];
  var PressurizationPublisher = class extends SimVarPublisher {
    constructor(bus, pacer = void 0) {
      super(PressurizationPublisher.simvars, bus, pacer);
    }
    onUpdate() {
      super.onUpdate();
    }
  };
  PressurizationPublisher.simvars = /* @__PURE__ */ new Map([
    ["cabin_altitude", { name: "PRESSURIZATION CABIN ALTITUDE", type: SimVarValueType.Feet }],
    ["cabin_altitude_rate", { name: "PRESSURIZATION CABIN ALTITUDE RATE", type: SimVarValueType.FPM }],
    ["pressure_diff", { name: "PRESSURIZATION PRESSURE DIFFERENTIAL", type: SimVarValueType.PSI }]
  ]);
  var DebounceTimer = class {
    constructor() {
      this.timer = null;
    }
    isPending() {
      return this.timer !== null;
    }
    schedule(action, delay) {
      this.clear();
      this.timer = setTimeout(() => {
        this.timer = null;
        action();
      }, delay);
    }
    clear() {
      if (this.timer === null) {
        return;
      }
      clearTimeout(this.timer);
      this.timer = null;
    }
  };
  var XPDRMode;
  (function(XPDRMode2) {
    XPDRMode2[XPDRMode2["OFF"] = 0] = "OFF";
    XPDRMode2[XPDRMode2["STBY"] = 1] = "STBY";
    XPDRMode2[XPDRMode2["TEST"] = 2] = "TEST";
    XPDRMode2[XPDRMode2["ON"] = 3] = "ON";
    XPDRMode2[XPDRMode2["ALT"] = 4] = "ALT";
    XPDRMode2[XPDRMode2["GROUND"] = 5] = "GROUND";
  })(XPDRMode || (XPDRMode = {}));
  var Wait = class {
    static awaitDelay(delay) {
      return new Promise((resolve) => setTimeout(() => resolve(), delay));
    }
    static awaitCondition(predicate, interval = 0, timeout = 0) {
      const t0 = Date.now();
      if (interval <= 0) {
        const loopFunc = (resolve, reject) => {
          if (timeout > 0 && Date.now() - t0 >= timeout) {
            reject("Await condition timed out.");
          } else {
            predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(void 0, resolve, reject));
          }
        };
        return new Promise((resolve, reject) => {
          loopFunc(resolve, reject);
        });
      } else {
        return new Promise((resolve, reject) => {
          const timer = setInterval(() => {
            if (timeout > 0 && Date.now() - t0 > timeout) {
              clearInterval(timer);
              reject("Await condition timed out.");
            } else if (predicate()) {
              clearInterval(timer);
              resolve();
            }
          }, interval);
        });
      }
    }
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub2 = subscribable.sub((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub2.destroy();
            resolve(val);
          }
        }, false, true);
        sub2.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub2.isAlive) {
              sub2.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub2 = consumer.handle((val) => {
          if (predicate === void 0 || predicate(val)) {
            sub2.destroy();
            resolve(val);
          }
        }, true);
        sub2.resume(initialCheck);
        if (timeout > 0) {
          setTimeout(() => {
            if (sub2.isAlive) {
              sub2.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
    static awaitSubEvent(event, predicate, timeout = 0) {
      return new Promise((resolve, reject) => {
        const sub2 = event.on((sender, data) => {
          if (predicate === void 0 || predicate(data, sender)) {
            sub2.destroy();
            resolve(data);
          }
        }, true);
        sub2.resume();
        if (timeout > 0) {
          setTimeout(() => {
            if (sub2.isAlive) {
              sub2.destroy();
              reject("Await condition timed out.");
            }
          }, timeout);
        }
      });
    }
  };
  var TrafficContactClass = class {
    constructor(uid, contactTimeResetThreshold) {
      this.uid = uid;
      this.contactTimeResetThreshold = contactTimeResetThreshold;
      this._lastPosition = new GeoPoint(NaN, NaN);
      this.lastPosition = this._lastPosition.readonly;
      this._lastAltitude = UnitType.FOOT.createNumber(NaN);
      this.lastAltitude = this._lastAltitude.readonly;
      this._lastHeading = NaN;
      this._lastContactTime = NaN;
      this._groundSpeed = UnitType.KNOT.createNumber(NaN);
      this.groundSpeed = this._groundSpeed.readonly;
      this._groundTrack = NaN;
      this._verticalSpeed = UnitType.FPM.createNumber(NaN);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
      this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1e3);
    }
    get lastHeading() {
      return this._lastHeading;
    }
    get lastContactTime() {
      return this._lastContactTime;
    }
    get groundTrack() {
      return this._groundTrack;
    }
    predict(simTime, positionOut, altitudeOut) {
      if (this.groundSpeed.isNaN()) {
        positionOut.set(NaN, NaN);
        altitudeOut.set(NaN);
        return;
      }
      const dt = simTime - this.lastContactTime;
      const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 36e5), UnitType.GA_RADIAN);
      this._lastPosition.offset(this._groundTrack, distance, positionOut);
      const deltaAlt = this._verticalSpeed.number * (dt / 6e4);
      this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    update(lat, lon, altitude, heading, simTime) {
      const dt = simTime - this._lastContactTime;
      if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
        this.reset(lat, lon, altitude, heading, simTime);
        return;
      }
      if (!isNaN(dt) && dt > 0) {
        this.updateComputedValues(dt / 1e3, lat, lon, altitude);
      }
      this.setReportedValues(lat, lon, altitude, heading);
      if (this.areComputedValuesValid()) {
        this._lastContactTime = simTime;
      } else {
        this.reset(lat, lon, altitude, heading, simTime);
      }
    }
    reset(lat, lon, altitude, heading, simTime) {
      this.setReportedValues(lat, lon, altitude, heading);
      this._groundSpeed.set(NaN);
      this._groundTrack = NaN;
      this._verticalSpeed.set(NaN);
      this.groundSpeedSmoother.reset();
      this.groundTrackSmoother.reset();
      this.verticalSpeedSmoother.reset();
      this._lastContactTime = simTime;
    }
    setReportedValues(lat, lon, altitude, heading) {
      this._lastPosition.set(lat, lon);
      this._lastAltitude.set(altitude);
      this._lastHeading = heading;
    }
    updateComputedValues(dt, lat, lon, altitude) {
      const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
      const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
      const track = pos.bearingFrom(this._lastPosition);
      this.updateGroundSpeed(dt, distanceNM);
      this.updateGroundTrack(dt, track, distanceNM);
      this.updateVerticalSpeed(dt, altitude);
    }
    updateGroundSpeed(dt, distanceNM) {
      const dtHours = dt / 3600;
      const speedKnots = distanceNM / dtHours;
      this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    updateGroundTrack(dt, track, distanceNM) {
      const last = this.groundTrackSmoother.last();
      if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
        if (last !== null && !isNaN(last)) {
          let delta = track - last;
          if (delta > 180) {
            delta = delta - 360;
          } else if (delta < -180) {
            delta = delta + 360;
          }
          track = last + delta;
        }
      } else {
        track = last === null ? NaN : last;
      }
      const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
      this._groundTrack = (next + 360) % 360;
    }
    updateVerticalSpeed(dt, altitude) {
      const dtMin = dt / 60;
      const deltaAltFeet = altitude - this._lastAltitude.number;
      const vsFPM = deltaAltFeet / dtMin;
      this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    areComputedValuesValid() {
      const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
      const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
      return isGroundSpeedValid && isVerticalSpeedValid;
    }
  };
  TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
  TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500;
  TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 1e4;
  TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852;
  TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);
  var Easing = class {
    static linear() {
      return (x) => MathUtils2.clamp(x, 0, 1);
    }
    static quad(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x;
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - (1 - x) * (1 - x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 2 * x * x : 1 - 2 * (1 - x) * (1 - x);
        default:
          throw new Error(`Easing.quad(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static cubic(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 4 * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 4 * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.cubic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static quart(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 8 * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 8 * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quart(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static quint(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x * x * x * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl * compl * compl;
            }
          };
        case "both":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 16 * x * x * x * x * x;
            } else {
              const compl = 1 - x;
              return 1 - 16 * compl * compl * compl * compl * compl;
            }
          };
        default:
          throw new Error(`Easing.quint(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static polynomial(order, end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(x, order);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(1 - x, order);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2 * x, order) : 1 - 0.5 * Math.pow(2 * (1 - x), order);
        default:
          throw new Error(`Easing.polynomial(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static sin(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.cos(x * MathUtils2.HALF_PI);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sin(x * MathUtils2.HALF_PI);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : (1 - Math.cos(x * Math.PI)) * 0.5;
        default:
          throw new Error(`Easing.sin(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static circ(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.sqrt(1 - x * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.sqrt(1 - (x - 1) * (x - 1));
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? (1 - Math.sqrt(1 - 4 * x * x)) * 0.5 : (Math.sqrt(1 - 4 * (1 - x) * (1 - x)) + 1) * 0.5;
        default:
          throw new Error(`Easing.circ(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static exp(end) {
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : Math.pow(2, 10 * (x - 1));
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - Math.pow(2, -10 * x);
        case "both":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : x < 0.5 ? 0.5 * Math.pow(2, 20 * (x - 0.5)) : 1 - 0.5 * Math.pow(2, 20 * (0.5 - x));
        default:
          throw new Error(`Easing.exp(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static back(end) {
      const c1 = 2.70158;
      const c2 = 1.70158;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * x * x * x - c2 * x * x;
        case "out":
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else {
              const compl = 1 - x;
              return 1 - compl * compl * compl + c2 * compl * compl;
            }
          };
        case "both": {
          const c3 = c2 * 1.525;
          const c4 = c3 + 1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 2 * (x * x * (2 * c4 * x - c3));
            } else {
              const compl = 1 - x;
              return 1 - 2 * compl * compl * (2 * c4 * compl - c3);
            }
          };
        }
        default:
          throw new Error(`Easing.back(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static elastic(end) {
      const c1 = MathUtils2.TWO_PI / 3;
      switch (end) {
        case "in":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : c1 * Math.pow(2, 10 * (x - 1)) * Math.sin(10.75 - 10 * x);
        case "out":
          return (x) => x <= 0 ? 0 : x >= 1 ? 1 : 1 - c1 * Math.pow(2, -10 * x) * Math.sin(0.75 - 10 * x);
        case "both": {
          const c2 = c1 * c1;
          return (x) => {
            if (x <= 0) {
              return 0;
            } else if (x >= 1) {
              return 1;
            } else if (x < 0.5) {
              return 0.5 * Math.pow(2, 20 * (x - 0.5)) * Math.sin(c2 * (11.125 - 20 * x));
            } else {
              return 1 - 0.5 * Math.pow(2, 20 * (0.5 - x)) * Math.sin(c2 * (11.125 - 20 * x));
            }
          };
        }
        default:
          throw new Error(`Easing.elastic(): unrecognized end option '${end}'. Expected 'in' | 'out' | 'both'.`);
      }
    }
    static bezier(c1x, c1y, c2x, c2y, precompute = false, minXResolution, epsilon = 1e-3, maxDepth = 10) {
      c1x = MathUtils2.clamp(c1x, 0, 1);
      c2x = MathUtils2.clamp(c2x, 0, 1);
      if (precompute) {
        const minXRes = minXResolution !== null && minXResolution !== void 0 ? minXResolution : 0.1;
        const lookup = new LerpLookupTable(1);
        lookup.insertBreakpoint([0, 0]);
        lookup.insertBreakpoint([1, 1]);
        if (maxDepth > 0) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, 0, 0, 0, 1, 1, 1, 1);
        }
        return (x) => {
          return x <= 0 ? 0 : x >= 1 ? 1 : lookup.get(x);
        };
      } else {
        const minXRes = Math.max(minXResolution !== null && minXResolution !== void 0 ? minXResolution : 1e-4, 1e-6);
        return (x) => {
          if (x <= 0) {
            return 0;
          } else if (x >= 1) {
            return 1;
          }
          let t0 = 0, t1 = 1;
          let tquery = (t0 + t1) / 2;
          let xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          while (Math.abs(x - xquery) > minXRes) {
            if (x - xquery < 0) {
              t1 = tquery;
            } else {
              t0 = tquery;
            }
            tquery = (t0 + t1) / 2;
            xquery = Easing.easingBezierFunc(tquery, c1x, c2x);
          }
          return Easing.easingBezierFunc(tquery, c1y, c2y);
        };
      }
    }
    static precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, t1, x1, y1, depth) {
      const tmid = (t0 + t1) / 2;
      const xdelta = x1 - x0;
      const xmid = Easing.easingBezierFunc(tmid, c1x, c2x);
      const ymid = Easing.easingBezierFunc(tmid, c1y, c2y);
      const ylerp = MathUtils2.lerp(xmid, x0, x1, y0, y1);
      let shouldContinue = false;
      shouldContinue = xdelta > minXRes || Math.abs(ylerp - ymid) > epsilon;
      if (shouldContinue) {
        lookup.insertBreakpoint([ymid, xmid]);
        if (depth < maxDepth) {
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, t0, x0, y0, tmid, xmid, ymid, depth + 1);
          Easing.precomputeBezier(c1x, c1y, c2x, c2y, lookup, minXRes, epsilon, maxDepth, tmid, xmid, ymid, t1, x1, y1, depth + 1);
        }
      }
    }
    static easingBezierFunc(t, c1, c2) {
      return 3 * (1 - t) * (1 - t) * t * c1 + 3 * (1 - t) * t * t * c2 + t * t * t;
    }
    static withEndpointParams(ease) {
      return (start, stop, progress) => {
        return start + (stop - start) * ease(progress);
      };
    }
    static withEndpoints(ease, start, stop) {
      const delta = stop - start;
      return (progress) => {
        return start + delta * ease(progress);
      };
    }
  };
  var Animator = class {
    constructor() {
      this._value = Subject.create(0);
      this._isAnimating = false;
      this.isAnimationLoopActive = false;
      this.animationEaseFunc = Animator.DEFAULT_EASE_FUNC;
      this.animationStart = 0;
      this.animationStop = 0;
      this.animationStartTime = 0;
      this.animationDuration = 0;
      this.animationLoop = () => {
        if (!this._isAnimating) {
          this.isAnimationLoopActive = false;
          return;
        }
        const progress = (Date.now() - this.animationStartTime) / this.animationDuration;
        if (progress < 1) {
          this._value.set(this.animationEaseFunc(this.animationStart, this.animationStop, progress));
          requestAnimationFrame(this.animationLoop);
        } else {
          this._isAnimating = false;
          this.isAnimationLoopActive = false;
          this._value.set(this.animationStop);
        }
      };
    }
    get value() {
      return this._value;
    }
    isAnimating() {
      return this._isAnimating;
    }
    start(target, duration, easeFunc) {
      if (duration <= 0) {
        this.set(target);
        return;
      }
      this._isAnimating = true;
      this.animationStart = this._value.get();
      this.animationStop = target;
      this.animationStartTime = Date.now();
      this.animationDuration = duration;
      this.animationEaseFunc = easeFunc !== null && easeFunc !== void 0 ? easeFunc : Animator.DEFAULT_EASE_FUNC;
      if (!this.isAnimationLoopActive) {
        this.isAnimationLoopActive = true;
        requestAnimationFrame(this.animationLoop);
      }
    }
    set(value) {
      this._isAnimating = false;
      this._value.set(value);
    }
    stop(setAnimationTarget = false) {
      if (!this._isAnimating) {
        return;
      }
      this._isAnimating = false;
      if (setAnimationTarget) {
        this._value.set(this.animationStop);
      }
    }
  };
  Animator.DEFAULT_EASE_FUNC = Easing.withEndpointParams(Easing.linear());
  var BacklightLevelController = class {
    constructor(bus, paused = false, minIntensity = BacklightLevelController.DEFAULT_MIN_INTENSITY, maxIntensity = BacklightLevelController.DEFAULT_MAX_INTENSITY) {
      this.simTime = ConsumerSubject.create(null, 0);
      this.ppos = new Float64Array(3);
      this.needRecalcAuto = true;
      this.lastSimTime = 0;
      this.paused = false;
      this._intensity = Subject.create(0);
      this.intensity = this._intensity;
      this._autoMinIntensity = minIntensity;
      this._autoMaxIntensity = maxIntensity;
      this._autoIntensityRange = this.autoMaxIntensity - this.autoMinIntensity;
      this.needRecalcAuto = true;
      const sub2 = bus.getSubscriber();
      this.simTime.setConsumer(sub2.on("simTime"));
      this.pposSub = sub2.on("gps-position").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onPPosChanged.bind(this));
      this.updateSub = sub2.on("realTime").atFrequency(BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ).handle(this.onUpdate.bind(this));
      this.setPaused(paused);
    }
    get autoMaxIntensity() {
      return this._autoMaxIntensity;
    }
    set autoMaxIntensity(max_intensity) {
      this._autoMaxIntensity = max_intensity;
      this._autoIntensityRange = this._autoMaxIntensity - this._autoMinIntensity;
      this.needRecalcAuto = true;
    }
    get autoMinIntensity() {
      return this._autoMinIntensity;
    }
    set autoMinIntensity(min_intensity) {
      this._autoMinIntensity = min_intensity;
      this._autoIntensityRange = this._autoMinIntensity - min_intensity;
      this.needRecalcAuto = true;
    }
    setPaused(paused) {
      if (paused !== this.paused) {
        this.paused = paused;
        if (paused) {
          this.updateSub.pause();
          this.pposSub.pause();
          this.simTime.pause();
          this.needRecalcAuto = false;
        } else {
          this.needRecalcAuto = true;
          this.simTime.resume();
          this.pposSub.resume(true);
          this.updateSub.resume(true);
        }
      }
    }
    onPPosChanged(ppos) {
      const pposVec = GeoPoint.sphericalToCartesian(ppos.lat, ppos.long, BacklightLevelController.tempVec3);
      if (Vec3Math.dot(pposVec, this.ppos) >= 1 - 1e-4) {
        return;
      }
      Vec3Math.copy(pposVec, this.ppos);
      this.needRecalcAuto = true;
    }
    onUpdate() {
      const simTime = this.simTime.get();
      this.needRecalcAuto || (this.needRecalcAuto = Math.abs(simTime - this.lastSimTime) >= BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD);
      if (this.needRecalcAuto) {
        this.needRecalcAuto = false;
        this.updateAutoBacklightIntensity(simTime);
      }
    }
    updateAutoBacklightIntensity(simTime) {
      this.lastSimTime = simTime;
      const subSolarPoint = BacklightLevelController.calculateSubSolarPoint(simTime, BacklightLevelController.tempVec3);
      const sinSolarAngle = Vec3Math.dot(this.ppos, subSolarPoint);
      const sinSolarAngleClamped = Utils.Clamp(sinSolarAngle, BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN, BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN);
      const intensityFrac = (sinSolarAngleClamped - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN) / BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN;
      this._intensity.set(this._autoMinIntensity + intensityFrac * this._autoIntensityRange);
    }
    static calculateSubSolarPoint(time, out) {
      const PI2 = 2 * Math.PI;
      const days = (time - BacklightLevelController.EPOCH) / BacklightLevelController.DAY;
      const daysFrac = days - Math.floor(days);
      const L = 4.895055 + 0.01720279 * days;
      const g = 6.240041 + 0.01720197 * days;
      const lambda = L + 0.033423 * Math.sin(g) + 349e-6 * Math.sin(2 * g);
      const epsilon = 0.40910518 - 698e-11 * days;
      const rAscension = Math.atan2(Math.cos(epsilon) * Math.sin(lambda), Math.cos(lambda));
      const declination = Math.asin(Math.sin(epsilon) * Math.sin(lambda));
      const E = (((L - rAscension) % PI2 + 3 * Math.PI) % PI2 - Math.PI) * 0.159155;
      const lat = declination * Avionics.Utils.RAD2DEG;
      const lon = -15 * (daysFrac - 0.5 + E) * 24;
      return GeoPoint.sphericalToCartesian(lat, lon, out);
    }
  };
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE = 3;
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE = -8;
  BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MAX_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN = Math.sin(BacklightLevelController.AUTO_MIN_SOLAR_ANGLE * Avionics.Utils.DEG2RAD);
  BacklightLevelController.AUTO_SOLAR_ANGLE_RANGE_SIN = BacklightLevelController.AUTO_MAX_SOLAR_ANGLE_SIN - BacklightLevelController.AUTO_MIN_SOLAR_ANGLE_SIN;
  BacklightLevelController.AUTO_UPDATE_REALTIME_FREQ = 10;
  BacklightLevelController.AUTO_UPDATE_SIMTIME_THRESHOLD = 6e4;
  BacklightLevelController.EPOCH = 9466848e5;
  BacklightLevelController.DAY = 864e5;
  BacklightLevelController.DEFAULT_MIN_INTENSITY = 0;
  BacklightLevelController.DEFAULT_MAX_INTENSITY = 1;
  BacklightLevelController.tempVec3 = new Float64Array(3);
  var LinearServo = class {
    constructor(rate) {
      this.rate = rate;
    }
    drive(currentValue, setValue) {
      if (this.currentTime === void 0) {
        this.currentTime = new Date().appTime();
        return currentValue;
      }
      const currentTime = new Date().appTime();
      const deltaTime = currentTime - this.currentTime;
      this.currentTime = currentTime;
      const deltaValue = setValue - currentValue;
      const maximumDrive = this.rate * (deltaTime / 1e3);
      const output = Math.abs(deltaValue) > maximumDrive ? currentValue + Math.sign(deltaValue) * maximumDrive : setValue;
      return output;
    }
    reset() {
      this.currentTime = void 0;
    }
  };
  var PidController = class {
    constructor(kP, kI, kD, maxOut, minOut, maxI = Number.MAX_SAFE_INTEGER, minI = Number.MIN_SAFE_INTEGER) {
      this.kP = kP;
      this.kI = kI;
      this.kD = kD;
      this.maxOut = maxOut;
      this.minOut = minOut;
      this.maxI = maxI;
      this.minI = minI;
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    getOutput(deltaTime, error) {
      var _a;
      const p = this.kP * error;
      if (this.previousError !== void 0 && Math.sign(error) === Math.sign(this.previousError)) {
        this.integral += (error * deltaTime + deltaTime * (error - this.previousError) / 2) * this.kI;
        this.integral = PidController.clamp(this.integral, this.maxI, this.minI);
      } else {
        this.integral = 0;
      }
      const i = this.integral;
      const d = this.kD * ((error - ((_a = this.previousError) !== null && _a !== void 0 ? _a : error)) / deltaTime);
      const output = PidController.clamp(p + i + d, this.maxOut, this.minOut);
      this.previousError = error;
      this.previousOutput = output;
      return output;
    }
    reset() {
      this.previousError = void 0;
      this.previousOutput = void 0;
      this.integral = 0;
    }
    static clamp(value, max2, min2) {
      return Math.min(Math.max(value, min2), max2);
    }
  };
  var ResourceModerator = class {
    constructor(resource) {
      this.resource = resource;
      this.pendingConsumer = null;
      this.assignedConsumer = null;
      this.queuedConsumers = new SortedArray((a, b) => a.priority - b.priority);
    }
    claim(consumer) {
      var _a;
      const consumerToDisplace = (_a = this.pendingConsumer) !== null && _a !== void 0 ? _a : this.assignedConsumer;
      if (consumerToDisplace === consumer) {
        return;
      }
      if (this.queuedConsumers.has(consumer)) {
        return;
      }
      if (consumerToDisplace === null || consumerToDisplace.priority < consumer.priority) {
        if (consumerToDisplace === null || consumerToDisplace === this.pendingConsumer) {
          if (consumerToDisplace) {
            this.queuedConsumers.insert(consumerToDisplace);
            this.pendingConsumer = null;
          }
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        }
        this.assignedConsumer = null;
        this.pendingConsumer = consumer;
        this.queuedConsumers.insert(consumerToDisplace);
        consumerToDisplace.onCeded(this.resource);
        if (this.pendingConsumer === consumer) {
          this.pendingConsumer = null;
          this.assignedConsumer = consumer;
          this.assignedConsumer.onAcquired(this.resource);
          return;
        } else {
          return;
        }
      }
      this.queuedConsumers.insert(consumer);
    }
    forfeit(consumer) {
      var _a;
      if (this.pendingConsumer === consumer) {
        this.pendingConsumer = null;
        return;
      }
      if (this.assignedConsumer === null || this.assignedConsumer !== consumer) {
        this.queuedConsumers.remove(consumer);
        return;
      }
      const next = (_a = this.queuedConsumers.pop()) !== null && _a !== void 0 ? _a : null;
      this.pendingConsumer = next;
      this.assignedConsumer = null;
      consumer.onCeded(this.resource);
      if (next !== null && this.pendingConsumer === next) {
        this.pendingConsumer = null;
        this.assignedConsumer = next;
        this.assignedConsumer.onAcquired(this.resource);
      }
    }
  };
  var AuralAlertSystem = class {
    constructor(bus) {
      this.bus = bus;
      this.soundServerSub = this.bus.getSubscriber();
      this.controlSub = this.bus.getSubscriber();
      this.soundServerPublisher = this.bus.getPublisher();
      this.publisher = this.bus.getPublisher();
      this.registeredAlerts = /* @__PURE__ */ new Map();
      this.queueToPacketKeyMap = /* @__PURE__ */ new Map();
      this.packetKeyToQueueMap = /* @__PURE__ */ new Map();
      this.queues = /* @__PURE__ */ new Map();
      this.playing = /* @__PURE__ */ new Map();
      this.activeAliasToUuid = /* @__PURE__ */ new Map();
      this.triggeredAliasToUuid = /* @__PURE__ */ new Map();
      this.activeSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToActiveSuffixedIds = /* @__PURE__ */ new Map();
      this.triggeredSuffixedIdToId = /* @__PURE__ */ new Map();
      this.idToTriggeredSuffixedIds = /* @__PURE__ */ new Map();
      this.activeAlerts = /* @__PURE__ */ new Map();
      this.triggeredAlerts = /* @__PURE__ */ new Map();
      this.isSoundServerInit = false;
      this.isAwake = false;
      this.controlSub.on("aural_alert_register").handle(this.onAlertRegistered.bind(this));
      this.publisher.pub("aural_alert_request_all_registrations", void 0, true, false);
      this.soundServerSub.on("sound_server_packet_ended").handle(this.onPacketEnded.bind(this));
      this.controlSub.on("aural_alert_activate").handle(this.activateAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate").handle(this.deactivateAlert.bind(this));
      this.controlSub.on("aural_alert_trigger").handle(this.triggerAlert.bind(this));
      this.controlSub.on("aural_alert_untrigger").handle(this.untriggerAlert.bind(this));
      this.controlSub.on("aural_alert_kill").handle(this.killAlert.bind(this));
      this.controlSub.on("aural_alert_deactivate_all").handle(this.deactivateAllAlerts.bind(this));
      this.controlSub.on("aural_alert_untrigger_all").handle(this.untriggerAllAlerts.bind(this));
      this.controlSub.on("aural_alert_kill_all").handle(this.killAllAlerts.bind(this));
      Wait.awaitConsumer(this.soundServerSub.on("sound_server_initialized"), (init2) => init2, true).then(() => {
        this.isSoundServerInit = true;
        for (const queue of this.queues.values()) {
          this.dequeueAlert(queue);
        }
      });
    }
    wake() {
      if (this.isAwake) {
        return;
      }
      this.isAwake = true;
      for (const alert of this.activeAlerts.values()) {
        if (alert.repeat || alert.packet.continuous) {
          this.queueAlert(alert);
        }
      }
    }
    sleep() {
      if (!this.isAwake) {
        return;
      }
      this.isAwake = false;
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const queueEntry of this.queues.values()) {
        queueEntry.queue.clear();
      }
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    onAlertRegistered(alert) {
      this.registeredAlerts.set(alert.uuid, alert);
      !this.queues.has(alert.queue) && this.createQueue(alert.queue);
    }
    createQueue(queueName) {
      const entry = {
        queue: new BinaryHeap(AuralAlertSystem.ALERT_COMPARATOR),
        debounceTimer: new DebounceTimer()
      };
      this.queues.set(queueName, entry);
      const packetKey = AuralAlertSystem.createPacketKey(queueName);
      this.queueToPacketKeyMap.set(queueName, packetKey);
      this.packetKeyToQueueMap.set(packetKey, queueName);
      return entry;
    }
    isAliasUnique(uuid, alias) {
      if (this.registeredAlerts.has(alias)) {
        return false;
      }
      const existingActive = this.activeAliasToUuid.get(alias);
      if (existingActive !== void 0 && existingActive !== uuid) {
        return false;
      }
      const existingTriggered = this.triggeredAliasToUuid.get(alias);
      if (existingTriggered !== void 0 && existingTriggered !== uuid) {
        return false;
      }
      return true;
    }
    isSuffixedIdUnique(id, suffixedId) {
      if (this.registeredAlerts.has(suffixedId) || this.activeAliasToUuid.has(suffixedId) || this.triggeredAliasToUuid.has(suffixedId)) {
        return false;
      }
      const existingActive = this.activeSuffixedIdToId.get(suffixedId);
      if (existingActive !== void 0 && existingActive !== id) {
        return false;
      }
      const existingTriggered = this.triggeredSuffixedIdToId.get(suffixedId);
      if (existingTriggered !== void 0 && existingTriggered !== id) {
        return false;
      }
      return true;
    }
    activateAlert(activation) {
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.activeAliasToUuid.set(alias, uuid);
      }
      this.activateSuffix(queuedId, suffixedId);
      if (this.activeAlerts.has(queuedId)) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.activeAlerts.set(queuedId, queuedAlert);
      if (this.isAwake) {
        this.queueAlert(queuedAlert);
      }
    }
    activateSuffix(id, suffixedId = id) {
      this.activeSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToActiveSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    triggerAlert(activation) {
      if (!this.isAwake) {
        return;
      }
      let uuid;
      let alias;
      let queuedId;
      let suffixedId;
      let activationObject;
      if (typeof activation === "string") {
        uuid = activation;
        alias = void 0;
        queuedId = uuid;
        suffixedId = void 0;
        activationObject = void 0;
      } else {
        uuid = activation.uuid;
        alias = activation.alias;
        queuedId = alias !== null && alias !== void 0 ? alias : uuid;
        suffixedId = activation.suffix === void 0 ? void 0 : `${queuedId}::${activation.suffix}`;
        activationObject = activation;
      }
      const alertDef = this.registeredAlerts.get(uuid);
      if (!alertDef) {
        return;
      }
      if (alias !== void 0 && !this.isAliasUnique(uuid, alias)) {
        return;
      }
      if (suffixedId !== void 0 && !this.isSuffixedIdUnique(queuedId, suffixedId)) {
        return;
      }
      if (alias !== void 0) {
        this.triggeredAliasToUuid.set(alias, uuid);
      }
      this.triggerSuffix(queuedId, suffixedId);
      const existing = this.triggeredAlerts.get(queuedId);
      if (existing && this.playing.get(existing.definition.queue) === existing) {
        return;
      }
      const queuedAlert = this.createQueuedAlert(alertDef, activationObject);
      this.triggeredAlerts.set(queuedId, queuedAlert);
      this.queueAlert(queuedAlert);
    }
    triggerSuffix(id, suffixedId = id) {
      this.triggeredSuffixedIdToId.set(suffixedId, id);
      let suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.idToTriggeredSuffixedIds.set(id, suffixedIds = /* @__PURE__ */ new Set());
      }
      suffixedIds.add(suffixedId);
    }
    createQueuedAlert(definition, activation) {
      var _a, _b, _c, _d, _e;
      return {
        definition,
        id: (_a = activation === null || activation === void 0 ? void 0 : activation.alias) !== null && _a !== void 0 ? _a : definition.uuid,
        repeat: (_b = activation === null || activation === void 0 ? void 0 : activation.repeat) !== null && _b !== void 0 ? _b : definition.repeat,
        packet: {
          key: this.queueToPacketKeyMap.get(definition.queue),
          sequence: (_c = activation === null || activation === void 0 ? void 0 : activation.sequence) !== null && _c !== void 0 ? _c : definition.sequence,
          continuous: (_d = activation === null || activation === void 0 ? void 0 : activation.continuous) !== null && _d !== void 0 ? _d : definition.continuous,
          timeout: (_e = activation === null || activation === void 0 ? void 0 : activation.timeout) !== null && _e !== void 0 ? _e : definition.timeout
        },
        timestamp: Date.now()
      };
    }
    queueAlert(alert) {
      var _a;
      const queueName = alert.definition.queue;
      const queueEntry = (_a = this.queues.get(queueName)) !== null && _a !== void 0 ? _a : this.createQueue(queueName);
      queueEntry.queue.insert(alert);
      if (this.isSoundServerInit) {
        const playing = this.playing.get(queueName);
        if (!playing) {
          if (!queueEntry.debounceTimer.isPending()) {
            queueEntry.debounceTimer.schedule(this.dequeueAlert.bind(this, queueEntry), 0);
          }
        }
      }
    }
    dequeueAlert(entry) {
      if (this.isAwake) {
        let next = void 0;
        while (entry.queue.size > 0) {
          next = entry.queue.removeMin();
          if (this.activeAlerts.get(next.id) === next || this.triggeredAlerts.get(next.id) === next) {
            break;
          } else {
            next = void 0;
          }
        }
        if (next) {
          this.playing.set(next.definition.queue, next);
          this.soundServerPublisher.pub("sound_server_interrupt", next.packet, true, false);
        }
      } else {
        entry.queue.clear();
      }
    }
    deactivateAlert(id) {
      var _a;
      const deactivatedId = this.deactivateSuffix(id);
      if (deactivatedId === void 0) {
        return;
      }
      const deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
      if (deactivatedUuid !== deactivatedId) {
        this.activeAliasToUuid.delete(deactivatedId);
      }
      const alertDef = this.registeredAlerts.get(deactivatedUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    deactivateSuffix(suffixedId) {
      const id = this.activeSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.activeSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToActiveSuffixedIds.get(id);
      if (!suffixedIds) {
        this.activeAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.activeAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    untriggerAlert(uuid) {
      var _a;
      const untriggeredId = this.untriggerSuffix(uuid);
      if (untriggeredId === void 0) {
        return;
      }
      const untriggeredUuid = (_a = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _a !== void 0 ? _a : untriggeredId;
      if (untriggeredUuid !== untriggeredId) {
        this.triggeredAliasToUuid.delete(untriggeredId);
      }
      const alertDef = this.registeredAlerts.get(untriggeredUuid);
      if (alertDef) {
        const playing = this.playing.get(alertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    untriggerSuffix(suffixedId) {
      const id = this.triggeredSuffixedIdToId.get(suffixedId);
      if (id === void 0) {
        return void 0;
      }
      this.triggeredSuffixedIdToId.delete(suffixedId);
      const suffixedIds = this.idToTriggeredSuffixedIds.get(id);
      if (!suffixedIds) {
        this.triggeredAlerts.delete(id);
        return id;
      } else {
        suffixedIds.delete(suffixedId);
        if (suffixedIds.size === 0) {
          this.triggeredAlerts.delete(id);
          return id;
        } else {
          return void 0;
        }
      }
    }
    killAlert(uuid) {
      var _a, _b;
      const deactivatedId = this.deactivateSuffix(uuid);
      const untriggeredId = this.untriggerSuffix(uuid);
      let deactivatedUuid = void 0;
      let untriggeredUuid = void 0;
      if (deactivatedId !== void 0) {
        deactivatedUuid = (_a = this.activeAliasToUuid.get(deactivatedId)) !== null && _a !== void 0 ? _a : deactivatedId;
        if (deactivatedUuid !== deactivatedId) {
          this.activeAliasToUuid.delete(deactivatedId);
        }
      }
      if (untriggeredId !== void 0) {
        untriggeredUuid = (_b = this.triggeredAliasToUuid.get(untriggeredId)) !== null && _b !== void 0 ? _b : untriggeredId;
        if (untriggeredUuid !== untriggeredId) {
          this.triggeredAliasToUuid.delete(untriggeredId);
        }
      }
      const deactivatedAlertDef = deactivatedUuid === void 0 ? void 0 : this.registeredAlerts.get(deactivatedUuid);
      const untriggeredAlertDef = untriggeredUuid === void 0 ? void 0 : this.registeredAlerts.get(untriggeredUuid);
      let killedPacketKey = void 0;
      if (deactivatedAlertDef) {
        const playing = this.playing.get(deactivatedAlertDef.queue);
        if (playing && playing.id === deactivatedId && this.triggeredAlerts.get(deactivatedId) !== playing) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
          killedPacketKey = playing.packet.key;
        }
      }
      if (untriggeredAlertDef) {
        const playing = this.playing.get(untriggeredAlertDef.queue);
        if (playing && playing.id === untriggeredId && this.activeAlerts.get(untriggeredId) !== playing && killedPacketKey !== playing.packet.key) {
          this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
        }
      }
    }
    deactivateAllAlerts() {
      this.activeAlerts.clear();
      this.activeAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.triggeredAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    untriggerAllAlerts() {
      this.triggeredAlerts.clear();
      this.triggeredAliasToUuid.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        if (this.activeAlerts.get(playing.id) !== playing) {
          this.soundServerPublisher.pub("sound_server_stop", playing.packet.key, true, false);
        }
      }
    }
    killAllAlerts() {
      this.activeAlerts.clear();
      this.triggeredAlerts.clear();
      this.activeAliasToUuid.clear();
      this.triggeredAliasToUuid.clear();
      this.activeSuffixedIdToId.clear();
      this.idToActiveSuffixedIds.clear();
      this.triggeredSuffixedIdToId.clear();
      this.idToTriggeredSuffixedIds.clear();
      for (const playing of this.playing.values()) {
        this.soundServerPublisher.pub("sound_server_kill", playing.packet.key, true, false);
      }
    }
    onPacketEnded(key) {
      const queueName = this.packetKeyToQueueMap.get(key);
      if (queueName === void 0) {
        return;
      }
      const queueEntry = this.queues.get(queueName);
      if (!queueEntry) {
        this.packetKeyToQueueMap.delete(key);
        this.queueToPacketKeyMap.delete(queueName);
        return;
      }
      const finishedAlert = this.playing.get(queueName);
      if (finishedAlert) {
        if (this.triggeredAlerts.get(finishedAlert.id) === finishedAlert) {
          this.triggeredAlerts.delete(finishedAlert.id);
          if (finishedAlert.id !== finishedAlert.definition.uuid) {
            this.triggeredAliasToUuid.delete(finishedAlert.id);
          }
          const suffixedIds = this.idToTriggeredSuffixedIds.get(finishedAlert.id);
          if (suffixedIds) {
            for (const suffixedId of suffixedIds) {
              this.triggeredSuffixedIdToId.delete(suffixedId);
            }
            this.idToTriggeredSuffixedIds.delete(finishedAlert.id);
          }
        }
        if (finishedAlert.repeat && this.activeAlerts.get(finishedAlert.id) === finishedAlert) {
          this.queueAlert(finishedAlert);
        }
      }
      this.playing.delete(queueName);
      this.dequeueAlert(queueEntry);
    }
    static createPacketKey(queue) {
      return `$$aural-alert-system-queue-${queue}$$`;
    }
  };
  AuralAlertSystem.ALERT_COMPARATOR = (a, b) => {
    const priorityDiff = b.definition.priority - a.definition.priority;
    if (priorityDiff === 0) {
      return a.timestamp - b.timestamp;
    } else {
      return priorityDiff;
    }
  };
  var SoundServer = class {
    constructor(bus) {
      this.bus = bus;
      this.controlSub = this.bus.getSubscriber();
      this.publisher = this.bus.getPublisher();
      this.active = /* @__PURE__ */ new Map();
      this.queued = /* @__PURE__ */ new Map();
      this.publisher.pub("sound_server_initialized", false, true, true);
      this.init();
    }
    async init() {
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      await Wait.awaitDelay(500);
      await Wait.awaitSubscribable(GameStateProvider.get(), (state) => state === GameState.ingame, true);
      this.controlSub.on("sound_server_play").handle(this.playPacket.bind(this));
      this.controlSub.on("sound_server_queue").handle(this.queuePacket.bind(this));
      this.controlSub.on("sound_server_interrupt").handle(this.interruptPacket.bind(this));
      this.controlSub.on("sound_server_stop").handle(this.stopPacket.bind(this));
      this.controlSub.on("sound_server_kill").handle(this.killPacket.bind(this));
      this.controlSub.on("sound_server_stop_all").handle(this.stopAllPackets.bind(this));
      this.controlSub.on("sound_server_kill_all").handle(this.killAllPackets.bind(this));
      this.controlSub.on("sound_server_play_sound").handle(this.playSound.bind(this));
      this.controlSub.on("sound_server_start_sound").handle(this.startSound.bind(this));
      this.controlSub.on("sound_server_stop_sound").handle(this.stopPacket.bind(this));
      this.publisher.pub("sound_server_initialized", true, true, true);
    }
    onSoundEnd(id) {
      const activeEntries = Array.from(this.active.values());
      for (let i = 0; i < activeEntries.length; i++) {
        const entry = activeEntries[i];
        const entrySoundPlaying = entry.sequence[entry.currentIndexPlaying];
        if (!entrySoundPlaying) {
          this.cleanupPacket(entry);
        } else if (Name_Z.compare(entrySoundPlaying, id)) {
          this.advancePacket(entry);
        }
      }
    }
    playPacket(packet) {
      if (!this.active.get(packet.key)) {
        this.queuePacket(packet);
      }
    }
    interruptPacket(packet) {
      const active = this.active.get(packet.key);
      if (active) {
        active.alive = false;
      }
      this.queued.delete(packet.key);
      this.queuePacket(packet);
    }
    queuePacket(packet) {
      var _a;
      const sequence = SoundServer.getSoundSequence(packet);
      const entry = {
        key: packet.key,
        sequence,
        continuous: packet.continuous,
        currentIndexPlaying: 0,
        timeout: (_a = packet.timeout) !== null && _a !== void 0 ? _a : SoundServer.DEFAULT_TIMEOUT,
        alive: true,
        timer: new DebounceTimer(),
        timeoutCallback: () => {
          this.cleanupPacket(entry);
        }
      };
      if (this.active.get(packet.key)) {
        let queue = this.queued.get(entry.key);
        if (!queue) {
          this.queued.set(entry.key, queue = []);
        }
        queue.push(entry);
      } else {
        this.startPacket(entry);
      }
    }
    stopPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.continuous = false;
      }
    }
    killPacket(key) {
      this.queued.delete(key);
      const active = this.active.get(key);
      if (active) {
        active.alive = false;
      }
    }
    stopAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.continuous = false;
      }
    }
    killAllPackets() {
      this.queued.clear();
      for (const entry of this.active.values()) {
        entry.alive = false;
      }
    }
    playSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: false });
    }
    startSound(id) {
      this.playPacket({ key: id, sequence: id, continuous: true });
    }
    startPacket(entry) {
      this.active.set(entry.key, entry);
      this.publisher.pub("sound_server_packet_started", entry.key, true, false);
      if (entry.sequence.length === 0) {
        this.cleanupPacket(entry);
      } else {
        Coherent.call("PLAY_INSTRUMENT_SOUND", entry.sequence[0].originalStr);
        entry.currentIndexPlaying = 0;
        entry.timer.schedule(entry.timeoutCallback, entry.timeout);
      }
    }
    advancePacket(entry) {
      if (!entry.alive) {
        this.cleanupPacket(entry);
        return;
      }
      let nextSoundToPlayIndex = entry.currentIndexPlaying + 1;
      if (nextSoundToPlayIndex >= entry.sequence.length) {
        if (entry.continuous) {
          nextSoundToPlayIndex = 0;
          entry.timer.schedule(entry.timeoutCallback, entry.timeout);
        } else {
          this.cleanupPacket(entry);
          return;
        }
      }
      const soundToPlay = entry.sequence[nextSoundToPlayIndex];
      Coherent.call("PLAY_INSTRUMENT_SOUND", soundToPlay.originalStr);
      entry.currentIndexPlaying = nextSoundToPlayIndex;
    }
    cleanupPacket(entry) {
      entry.alive = false;
      entry.timer.clear();
      const deleted = this.active.delete(entry.key);
      if (!deleted) {
        return;
      }
      this.publisher.pub("sound_server_packet_ended", entry.key, true, false);
      const queue = this.queued.get(entry.key);
      if (queue) {
        const next = queue.shift();
        if (queue.length === 0) {
          this.queued.delete(entry.key);
        }
        if (next) {
          this.startPacket(next);
        }
      }
    }
    static getSoundSequence(packet) {
      const sequence = [];
      if (typeof packet.sequence === "string") {
        if (packet.sequence !== "") {
          sequence.push(new Name_Z(packet.sequence));
        }
      } else {
        for (let i = 0; i < packet.sequence.length; i++) {
          if (packet.sequence[i] !== "") {
            sequence.push(new Name_Z(packet.sequence[i]));
          }
        }
      }
      return sequence;
    }
  };
  SoundServer.DEFAULT_TIMEOUT = 1e4;
  var StringUtils = class {
    static useZeroSlash(text) {
      return text === null || text === void 0 ? void 0 : text.replace(StringUtils.ZERO_REGEX, "0\u0338");
    }
    static trimStart(str) {
      return str.replace(StringUtils.TRIM_START_REGEX, "");
    }
    static trimEnd(str) {
      return str.replace(StringUtils.TRIM_END_REGEX, "");
    }
  };
  StringUtils.DIRECT_TO = "\xD0";
  StringUtils.DEGREE = "\xB0";
  StringUtils.EN_DASH = "\u2013";
  StringUtils.ZERO_REGEX = /0/g;
  StringUtils.TRIM_START_REGEX = /^\s+/;
  StringUtils.TRIM_END_REGEX = /\s+$/;
  var AnnunciationType;
  (function(AnnunciationType2) {
    AnnunciationType2[AnnunciationType2["Warning"] = 0] = "Warning";
    AnnunciationType2[AnnunciationType2["Caution"] = 1] = "Caution";
    AnnunciationType2[AnnunciationType2["Advisory"] = 2] = "Advisory";
    AnnunciationType2[AnnunciationType2["SafeOp"] = 3] = "SafeOp";
  })(AnnunciationType || (AnnunciationType = {}));
  var RenderPosition;
  (function(RenderPosition2) {
    RenderPosition2[RenderPosition2["Before"] = 0] = "Before";
    RenderPosition2[RenderPosition2["After"] = 1] = "After";
    RenderPosition2[RenderPosition2["In"] = 2] = "In";
  })(RenderPosition || (RenderPosition = {}));
  var DisplayComponent = class {
    constructor(props) {
      this.context = void 0;
      this.contextType = void 0;
      this.props = props;
    }
    onBeforeRender() {
      return;
    }
    onAfterRender(node) {
      return;
    }
    destroy() {
      return;
    }
    getContext(context) {
      if (this.context !== void 0 && this.contextType !== void 0) {
        const index = this.contextType.indexOf(context);
        return this.context[index];
      }
      throw new Error("Could not find the provided context type.");
    }
  };
  var NodeReference = class {
    constructor() {
      this._instance = null;
    }
    get instance() {
      if (this._instance !== null) {
        return this._instance;
      }
      throw new Error("Instance was null.");
    }
    set instance(val) {
      this._instance = val;
    }
    getOrDefault() {
      return this._instance;
    }
  };
  var Context = class {
    constructor(defaultValue) {
      this.defaultValue = defaultValue;
      this.Provider = (props) => new ContextProvider(props, this);
    }
  };
  var ContextProvider = class extends DisplayComponent {
    constructor(props, parent) {
      super(props);
      this.parent = parent;
    }
    render() {
      var _a;
      const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
      return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
  };
  var FSComponent;
  (function(FSComponent2) {
    const svgTags = {
      "circle": true,
      "clipPath": true,
      "color-profile": true,
      "cursor": true,
      "defs": true,
      "desc": true,
      "ellipse": true,
      "g": true,
      "image": true,
      "line": true,
      "linearGradient": true,
      "marker": true,
      "mask": true,
      "path": true,
      "pattern": true,
      "polygon": true,
      "polyline": true,
      "radialGradient": true,
      "rect": true,
      "stop": true,
      "svg": true,
      "text": true
    };
    function Fragment2(props) {
      return props.children;
    }
    FSComponent2.Fragment = Fragment2;
    function buildComponent(type, props, ...children) {
      let vnode = null;
      if (typeof type === "string") {
        let element;
        if (svgTags[type] !== void 0) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
        if (props !== null) {
          for (const key in props) {
            if (key === "ref" && props.ref !== void 0) {
              props.ref.instance = element;
            } else {
              const prop = props[key];
              if (key === "class" && typeof prop === "object" && "isSubscribableSet" in prop) {
                prop.sub((set, eventType, modifiedKey) => {
                  if (eventType === SubscribableSetEventType.Added) {
                    element.classList.add(modifiedKey);
                  } else {
                    element.classList.remove(modifiedKey);
                  }
                }, true);
              } else if (typeof prop === "object" && "isSubscribable" in prop) {
                if (key === "style" && prop instanceof ObjectSubject) {
                  prop.sub((v, style, newValue) => {
                    element.style.setProperty(style.toString(), newValue);
                  }, true);
                } else {
                  prop.sub((v) => {
                    element.setAttribute(key, v);
                  }, true);
                }
              } else {
                element.setAttribute(key, prop);
              }
            }
          }
        }
        vnode = {
          instance: element,
          props,
          children: null
        };
        vnode.children = createChildNodes(vnode, children);
      } else if (typeof type === "function") {
        if (children !== null && props === null) {
          props = {
            children
          };
        } else if (props !== null) {
          props.children = children;
        }
        if (typeof type === "function" && type.name === Fragment2.name) {
          let childNodes = type(props);
          while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
            childNodes = childNodes[0];
          }
          vnode = {
            instance: null,
            props,
            children: childNodes
          };
        } else {
          let instance;
          const pluginSystem = window._pluginSystem;
          try {
            instance = type(props);
          } catch (_a) {
            let pluginInstance = void 0;
            if (pluginSystem !== void 0) {
              pluginInstance = pluginSystem.onComponentCreating(type, props);
            }
            if (pluginInstance !== void 0) {
              instance = pluginInstance;
            } else {
              instance = new type(props);
            }
          }
          if (props !== null && props.ref !== null && props.ref !== void 0) {
            props.ref.instance = instance;
          }
          if (instance.contextType !== void 0) {
            instance.context = instance.contextType.map((c) => Subject.create(c.defaultValue));
          }
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentCreated(instance);
          }
          vnode = {
            instance,
            props,
            children: [instance.render()]
          };
        }
      }
      return vnode;
    }
    FSComponent2.buildComponent = buildComponent;
    function createChildNodes(parent, children) {
      let vnodes = null;
      if (children !== null && children !== void 0 && children.length > 0) {
        vnodes = [];
        for (const child of children) {
          if (child !== null) {
            if (child instanceof Array) {
              const arrayNodes = createChildNodes(parent, child);
              if (arrayNodes !== null) {
                vnodes.push(...arrayNodes);
              }
            } else if (typeof child === "object") {
              if ("isSubscribable" in child) {
                const node = {
                  instance: child,
                  children: null,
                  props: null,
                  root: void 0
                };
                child.sub((v) => {
                  if (node.root !== void 0) {
                    node.root.nodeValue = v === "" || v === null || v === void 0 ? " " : v.toString();
                  }
                });
                vnodes.push(node);
              } else {
                vnodes.push(child);
              }
            } else if (typeof child === "string" || typeof child === "number") {
              vnodes.push(createStaticContentNode(child));
            }
          }
        }
      }
      return vnodes;
    }
    FSComponent2.createChildNodes = createChildNodes;
    function createStaticContentNode(content) {
      return {
        instance: content,
        children: null,
        props: null
      };
    }
    FSComponent2.createStaticContentNode = createStaticContentNode;
    function render2(node, element, position = RenderPosition.In) {
      if (node.children && node.children.length > 0 && element !== null) {
        const componentInstance = node.instance;
        if (componentInstance !== null && componentInstance.onBeforeRender !== void 0) {
          componentInstance.onBeforeRender();
        }
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
          insertNode(node, position, element);
        } else {
          if (position === RenderPosition.After) {
            for (let i = node.children.length - 1; i >= 0; i--) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          } else {
            for (let i = 0; i < node.children.length; i++) {
              if (node.children[i] === void 0 || node.children[i] === null) {
                continue;
              }
              insertNode(node.children[i], position, element);
            }
          }
        }
        const instance = node.instance;
        if (instance instanceof ContextProvider) {
          visitNodes(node, (n) => {
            if (n === void 0 || n === null) {
              return false;
            }
            const nodeInstance = n.instance;
            if (nodeInstance !== null && nodeInstance.contextType !== void 0) {
              const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
              if (contextSlot >= 0) {
                if (nodeInstance.context === void 0) {
                  nodeInstance.context = [];
                }
                nodeInstance.context[contextSlot].set(instance.props.value);
              }
              if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                return true;
              }
            }
            return false;
          });
        }
        if (componentInstance !== null && componentInstance.onAfterRender !== void 0) {
          const pluginSystem = window._pluginSystem;
          componentInstance.onAfterRender(node);
          if (pluginSystem !== void 0) {
            pluginSystem.onComponentRendered(node);
          }
        }
      }
    }
    FSComponent2.render = render2;
    function insertNode(node, position, element) {
      var _a, _b, _c, _d, _e, _f;
      if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
        switch (position) {
          case RenderPosition.In:
            element.appendChild(node.instance);
            node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentElement("beforebegin", node.instance);
            node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentElement("afterend", node.instance);
            node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : void 0;
            break;
        }
        if (node.children !== null) {
          for (const child of node.children) {
            insertNode(child, RenderPosition.In, node.instance);
          }
        }
      } else if (typeof node.instance === "string" || typeof node.instance === "object" && node.instance !== null && "isSubscribable" in node.instance) {
        let toRender;
        if (typeof node.instance === "string") {
          toRender = node.instance;
        } else {
          toRender = node.instance.get();
          if (toRender === "") {
            toRender = " ";
          }
        }
        switch (position) {
          case RenderPosition.In:
            element.insertAdjacentHTML("beforeend", toRender);
            node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : void 0;
            break;
          case RenderPosition.Before:
            element.insertAdjacentHTML("beforebegin", toRender);
            node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : void 0;
            break;
          case RenderPosition.After:
            element.insertAdjacentHTML("afterend", toRender);
            node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : void 0;
            break;
        }
      } else if (Array.isArray(node)) {
        if (position === RenderPosition.After) {
          for (let i = node.length - 1; i >= 0; i--) {
            render2(node[i], element, position);
          }
        } else {
          for (let i = 0; i < node.length; i++) {
            render2(node[i], element, position);
          }
        }
      } else {
        render2(node, element, position);
      }
    }
    function renderBefore(node, element) {
      render2(node, element, RenderPosition.Before);
    }
    FSComponent2.renderBefore = renderBefore;
    function renderAfter(node, element) {
      render2(node, element, RenderPosition.After);
    }
    FSComponent2.renderAfter = renderAfter;
    function remove(element) {
      if (element !== null) {
        element.remove();
      }
    }
    FSComponent2.remove = remove;
    function createRef() {
      return new NodeReference();
    }
    FSComponent2.createRef = createRef;
    function createContext(defaultValue) {
      return new Context(defaultValue);
    }
    FSComponent2.createContext = createContext;
    function visitNodes(node, visitor) {
      if (node === void 0 || node === null) {
        return;
      }
      const stopVisitation = visitor(node);
      if (!stopVisitation && node.children !== void 0 && node.children !== null) {
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (Array.isArray(child)) {
            for (let childIndex = 0; childIndex < child.length; childIndex++) {
              visitNodes(child[childIndex], visitor);
            }
          } else {
            visitNodes(child, visitor);
          }
        }
      }
      return;
    }
    FSComponent2.visitNodes = visitNodes;
    function parseCssClassesFromString(classString, filter) {
      return classString.split(" ").filter((str) => str !== "" && (filter === void 0 || filter(str)));
    }
    FSComponent2.parseCssClassesFromString = parseCssClassesFromString;
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
      const reservedClassSet = new Set(reservedClasses);
      if (reservedClassSet.size === 0) {
        return classesToSubscribe.sub((set, type, key) => {
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      } else {
        return classesToSubscribe.sub((set, type, key) => {
          if (reservedClassSet.has(key)) {
            return;
          }
          if (type === SubscribableSetEventType.Added) {
            setToBind.add(key);
          } else {
            setToBind.delete(key);
          }
        }, true);
      }
    }
    FSComponent2.bindCssClassSet = bindCssClassSet;
    function shallowDestroy(root) {
      FSComponent2.visitNodes(root, (node) => {
        if (node !== root && node.instance instanceof DisplayComponent) {
          node.instance.destroy();
          return true;
        }
        return false;
      });
    }
    FSComponent2.shallowDestroy = shallowDestroy;
    FSComponent2.EmptyHandler = () => {
      return;
    };
  })(FSComponent || (FSComponent = {}));
  var Fragment = FSComponent.Fragment;
  var BingComponent = class extends DisplayComponent {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.modeFlags = this.props.mode === EBingMode.HORIZON ? 4 : 0;
      this.isListenerRegistered = false;
      this.imgRef = FSComponent.createRef();
      this.uid = 0;
      this._isBound = false;
      this._isAwake = true;
      this.isDestroyed = false;
      this.pos = new LatLong(0, 0);
      this.radius = 10;
      this.resolution = (_a = this.props.resolution) !== null && _a !== void 0 ? _a : Vec2Subject.create(Vec2Math.create(BingComponent.DEFAULT_RESOLUTION, BingComponent.DEFAULT_RESOLUTION));
      this.earthColors = (_b = this.props.earthColors) !== null && _b !== void 0 ? _b : ArraySubject.create(ArrayUtils.create(2, () => BingComponent.hexaToRGBColor("#000000")));
      this.earthColorsElevationRange = (_c = this.props.earthColorsElevationRange) !== null && _c !== void 0 ? _c : Vec2Subject.create(Vec2Math.create(0, 3e4));
      this.skyColor = (_d = this.props.skyColor) !== null && _d !== void 0 ? _d : Subject.create(BingComponent.hexaToRGBColor("#000000"));
      this.reference = (_e = this.props.reference) !== null && _e !== void 0 ? _e : Subject.create(EBingReference.SEA);
      this.wxrMode = (_f = this.props.wxrMode) !== null && _f !== void 0 ? _f : Subject.create({ mode: EWeatherRadar.OFF, arcRadians: 0.5 });
      this.wxrColors = (_g = this.props.wxrColors) !== null && _g !== void 0 ? _g : ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this.isoLines = (_h = this.props.isoLines) !== null && _h !== void 0 ? _h : Subject.create(false);
      this.wxrColorsArray = [];
      this.wxrRateArray = [];
      this.resolutionHandler = (resolution) => {
        Coherent.call("SET_MAP_RESOLUTION", this.uid, resolution[0], resolution[1]);
        this.positionRadiusInhibitFramesRemaining = BingComponent.POSITION_RADIUS_INHIBIT_FRAMES;
        if (!this.positionRadiusInhibitTimer.isPending()) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        }
      };
      this.earthColorsHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        Coherent.call("SET_MAP_HEIGHT_COLORS", this.uid, colors);
      };
      this.earthColorsElevationRangeHandler = () => {
        const colors = this.earthColors.getArray();
        if (colors.length < 2) {
          return;
        }
        const range2 = this.earthColorsElevationRange.get();
        const terrainColorCount = colors.length - 1;
        const desiredElevationStep = (range2[1] - range2[0]) / Math.max(terrainColorCount - 1, 1);
        const requiredMin = range2[0] - desiredElevationStep;
        const requiredMax = range2[1] + desiredElevationStep;
        Coherent.call("SET_MAP_ALTITUDE_RANGE", this.uid, requiredMin, requiredMax);
      };
      this.skyColorHandler = (color) => {
        Coherent.call("SET_MAP_CLEAR_COLOR", this.uid, color);
      };
      this.referenceHandler = (reference) => {
        const flags = this.modeFlags | (reference === EBingReference.PLANE ? 1 : 0);
        this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, flags);
      };
      this.wxrModeHandler = (wxrMode) => {
        Coherent.call("SHOW_MAP_WEATHER", this.uid, wxrMode.mode, wxrMode.arcRadians);
      };
      this.wxrColorsHandler = () => {
        const array = this.wxrColors.getArray();
        if (array.length === 0) {
          return;
        }
        this.wxrColorsArray.length = array.length;
        this.wxrRateArray.length = array.length;
        for (let i = 0; i < array.length; i++) {
          this.wxrColorsArray[i] = array[i][0];
          this.wxrRateArray[i] = array[i][1];
        }
        Coherent.call("SET_MAP_WEATHER_RADAR_COLORS", this.uid, this.wxrColorsArray, this.wxrRateArray);
      };
      this.isoLinesHandler = (showIsolines) => {
        Coherent.call("SHOW_MAP_ISOLINES", this.uid, showIsolines);
      };
      this.setCurrentMapParamsTimer = null;
      this.positionRadiusInhibitFramesRemaining = 0;
      this.isPositionRadiusPending = false;
      this.positionRadiusInhibitTimer = new DebounceTimer();
      this.processPendingPositionRadius = () => {
        if (this.isPositionRadiusPending) {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
        if (--this.positionRadiusInhibitFramesRemaining > 0) {
          this.positionRadiusInhibitTimer.schedule(this.processPendingPositionRadius, 0);
        } else {
          this.isPositionRadiusPending = false;
        }
      };
      this.onListenerBound = (binder, uid) => {
        if (this.isDestroyed) {
          return;
        }
        if (binder.friendlyName === this.props.id) {
          this.binder = binder;
          this.uid = uid;
          if (this._isBound) {
            return;
          }
          this._isBound = true;
          Coherent.call("SHOW_MAP", uid, true);
          const pause = !this._isAwake;
          this.earthColorsSub = this.earthColors.sub(() => {
            this.earthColorsHandler();
            this.earthColorsElevationRangeHandler();
          }, true, pause);
          this.earthColorsElevationRangeSub = this.earthColorsElevationRange.sub(this.earthColorsElevationRangeHandler, true, pause);
          this.skyColorSub = this.skyColor.sub(this.skyColorHandler, true, pause);
          this.referenceSub = this.reference.sub(this.referenceHandler, true, pause);
          this.wxrModeSub = this.wxrMode.sub(this.wxrModeHandler, true, pause);
          this.wxrColorsSub = this.wxrColors.sub(this.wxrColorsHandler, true, pause);
          this.resolutionSub = this.resolution.sub(this.resolutionHandler, true, pause);
          this.isoLinesSub = this.isoLines.sub(this.isoLinesHandler, true, pause);
          if (this.modeFlags !== 4) {
            Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
          }
          this.props.onBoundCallback && this.props.onBoundCallback(this);
        }
      };
      this.onMapUpdate = (uid, imgSrc) => {
        if (this.binder !== void 0 && this.uid === uid && this.imgRef.instance !== null) {
          if (this.imgRef.instance.src !== imgSrc) {
            this.imgRef.instance.src = imgSrc;
          }
        }
      };
      this.setCurrentMapParams = () => {
        this.setPositionRadius(this.pos, this.radius);
      };
    }
    isBound() {
      return this._isBound;
    }
    isAwake() {
      return this._isAwake;
    }
    onAfterRender() {
      if (window["IsDestroying"]) {
        this.destroy();
        return;
      }
      const gameStateSubscribable = GameStateProvider.get();
      const gameState = gameStateSubscribable.get();
      if (gameState === GameState.briefing || gameState === GameState.ingame) {
        this.registerListener();
      } else {
        this.gameStateSub = gameStateSubscribable.sub((state) => {
          var _a;
          if (this.isDestroyed) {
            return;
          }
          if (state === GameState.briefing || state === GameState.ingame) {
            (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.registerListener();
          }
        });
      }
      window.addEventListener("OnDestroy", this.destroy.bind(this));
    }
    registerListener() {
      var _a;
      if (((_a = this.props.delay) !== null && _a !== void 0 ? _a : 0) > 0) {
        setTimeout(() => {
          if (this.isDestroyed) {
            return;
          }
          this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
        }, this.props.delay);
      } else {
        this.mapListener = RegisterViewListener("JS_LISTENER_MAPS", this.onListenerRegistered.bind(this));
      }
    }
    onListenerRegistered() {
      if (this.isDestroyed || this.isListenerRegistered) {
        return;
      }
      this.mapListener.on("MapBinded", this.onListenerBound);
      this.mapListener.on("MapUpdated", this.onMapUpdate);
      this.isListenerRegistered = true;
      this.mapListener.trigger("JS_BIND_BINGMAP", this.props.id, this.modeFlags);
    }
    wake() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = true;
      if (!this._isBound) {
        return;
      }
      this.setCurrentMapParams();
      if (this.modeFlags !== 4) {
        this.setCurrentMapParamsTimer = setInterval(this.setCurrentMapParams, 200);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.resume(true);
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.resume(true);
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.resume(true);
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.resume(true);
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.resume(true);
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.resume(true);
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.resume(true);
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.resume(true);
    }
    sleep() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this._isAwake = false;
      if (!this._isBound) {
        return;
      }
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.earthColorsSub) === null || _a === void 0 ? void 0 : _a.pause();
      (_b = this.earthColorsElevationRangeSub) === null || _b === void 0 ? void 0 : _b.pause();
      (_c = this.skyColorSub) === null || _c === void 0 ? void 0 : _c.pause();
      (_d = this.referenceSub) === null || _d === void 0 ? void 0 : _d.pause();
      (_e = this.wxrModeSub) === null || _e === void 0 ? void 0 : _e.pause();
      (_f = this.wxrColorsSub) === null || _f === void 0 ? void 0 : _f.pause();
      (_g = this.resolutionSub) === null || _g === void 0 ? void 0 : _g.pause();
      (_h = this.isoLinesSub) === null || _h === void 0 ? void 0 : _h.pause();
    }
    setPositionRadius(pos, radius) {
      this.pos = pos;
      this.radius = Math.max(radius, 10);
      if (this._isBound && this._isAwake) {
        if (this.positionRadiusInhibitFramesRemaining > 0) {
          this.isPositionRadiusPending = true;
        } else {
          Coherent.call("SET_MAP_PARAMS", this.uid, this.pos, this.radius, 1);
        }
      }
    }
    render() {
      var _a;
      return FSComponent.buildComponent("img", { ref: this.imgRef, src: "", style: "position: absolute; left: 0; top: 0; width: 100%; height: 100%;", class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      this.isDestroyed = true;
      this._isBound = false;
      if (this.setCurrentMapParamsTimer !== null) {
        clearInterval(this.setCurrentMapParamsTimer);
      }
      (_a = this.gameStateSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.earthColorsSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.earthColorsElevationRangeSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.skyColorSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.referenceSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.wxrModeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.wxrColorsSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.resolutionSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.isoLinesSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.mapListener) === null || _k === void 0 ? void 0 : _k.off("MapBinded", this.onListenerBound);
      (_l = this.mapListener) === null || _l === void 0 ? void 0 : _l.off("MapUpdated", this.onMapUpdate);
      (_m = this.mapListener) === null || _m === void 0 ? void 0 : _m.trigger("JS_UNBIND_BINGMAP", this.props.id);
      this.isListenerRegistered = false;
      this.imgRef.instance.src = "";
      (_o = this.imgRef.instance.parentNode) === null || _o === void 0 ? void 0 : _o.removeChild(this.imgRef.instance);
      super.destroy();
    }
    resetImgSrc() {
      const imgRef = this.imgRef.getOrDefault();
      if (imgRef !== null) {
        const currentSrc = imgRef.src;
        imgRef.src = "";
        imgRef.src = currentSrc;
      }
    }
    static hexaToRGBColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      return BingComponent.rgbColor(r, g, b);
    }
    static rgbToHexaColor(rgb, poundPrefix = true) {
      const b = Math.floor(rgb % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgb % (256 * 256) / 256);
      const r = rgb % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
    }
    static rgbColor(r, g, b) {
      return 256 * 256 * b + 256 * g + r;
    }
    static hexaToRGBAColor(hexColor) {
      const hexStringColor = hexColor;
      let offset = 0;
      if (hexStringColor[0] === "#") {
        offset = 1;
      }
      const r = parseInt(hexStringColor.substr(0 + offset, 2), 16);
      const g = parseInt(hexStringColor.substr(2 + offset, 2), 16);
      const b = parseInt(hexStringColor.substr(4 + offset, 2), 16);
      const a = parseInt(hexStringColor.substr(6 + offset, 2), 16);
      return BingComponent.rgbaColor(r, g, b, a);
    }
    static rgbaToHexaColor(rgba, poundPrefix = true) {
      const a = Math.floor(rgba % (256 * 256 * 256 * 256) / (256 * 256 * 256));
      const b = Math.floor(rgba % (256 * 256 * 256) / (256 * 256));
      const g = Math.floor(rgba % (256 * 256) / 256);
      const r = rgba % 256;
      return `${poundPrefix ? "#" : ""}${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}${a.toString(16).padStart(2, "0")}`;
    }
    static rgbaColor(r, g, b, a) {
      return 256 * 256 * 256 * a + 256 * 256 * b + 256 * g + r;
    }
    static createEarthColorsArray(waterColor, terrainColors, minElevation = 0, maxElevation = 3e4, stepCount = 61) {
      const earthColors = [BingComponent.hexaToRGBColor(waterColor)];
      const curve = new Avionics.Curve();
      curve.interpolationFunction = Avionics.CurveTool.StringColorRGBInterpolation;
      for (let i = 0; i < terrainColors.length; i++) {
        curve.add(terrainColors[i].elev, terrainColors[i].color);
      }
      const elevationStep = (maxElevation - minElevation) / Math.max(stepCount - 1, 1);
      for (let i = 0; i < stepCount; i++) {
        const color = curve.evaluate(minElevation + i * elevationStep);
        earthColors[i + 1] = BingComponent.hexaToRGBColor(color);
      }
      return earthColors;
    }
  };
  BingComponent.DEFAULT_RESOLUTION = 1024;
  BingComponent.DEFAULT_WEATHER_COLORS = [
    [BingComponent.hexaToRGBAColor("#00000000"), 0.5],
    [BingComponent.hexaToRGBAColor("#004d00ff"), 2.75],
    [BingComponent.hexaToRGBAColor("#cb7300ff"), 12.5],
    [BingComponent.hexaToRGBAColor("#ff0000ff"), 12.5]
  ];
  BingComponent.POSITION_RADIUS_INHIBIT_FRAMES = 10;
  var DurationDisplayFormat;
  (function(DurationDisplayFormat2) {
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_ss"] = 0] = "hh_mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm"] = 1] = "hh_mm";
    DurationDisplayFormat2[DurationDisplayFormat2["mm_ss"] = 2] = "mm_ss";
    DurationDisplayFormat2[DurationDisplayFormat2["hh_mm_or_mm_ss"] = 3] = "hh_mm_or_mm_ss";
  })(DurationDisplayFormat || (DurationDisplayFormat = {}));
  var DurationDisplayDelim;
  (function(DurationDisplayDelim2) {
    DurationDisplayDelim2[DurationDisplayDelim2["Colon"] = 0] = "Colon";
    DurationDisplayDelim2[DurationDisplayDelim2["ColonOrCross"] = 1] = "ColonOrCross";
    DurationDisplayDelim2[DurationDisplayDelim2["Space"] = 2] = "Space";
  })(DurationDisplayDelim || (DurationDisplayDelim = {}));
  var DurationDisplay = class extends DisplayComponent {
    constructor(props) {
      super(props);
      this.value = "isSubscribable" in this.props.value ? this.props.value : Subject.create(this.props.value);
      this.options = Object.assign({}, DurationDisplay.DEFAULT_OPTIONS, this.props.options);
      this.negativeSign = this.options.useMinusSign ? "\u2212" : "-";
      this.positiveSign = this.options.forceSign ? "+" : "";
      this.text = Subject.create("");
      switch (this.options.delim) {
        case DurationDisplayDelim.Colon:
          this.delim = ":";
          break;
        case DurationDisplayDelim.Space:
          this.delim = " ";
          break;
        default:
          this.delim = "";
      }
    }
    onAfterRender() {
      this.valueSub = this.value.sub(this.onValueChanged.bind(this), true);
    }
    onValueChanged(value) {
      this.setDisplay(value);
    }
    setDisplay(value) {
      let text;
      if (value.isNaN()) {
        text = this.options.nanString;
      } else {
        let hrText = "";
        let minText = "";
        let secText = "";
        let hrUnitText = "";
        let minUnitText = "";
        let secUnitText = "";
        let hrDelim = "";
        let minDelim = "";
        const valueAsSeconds = Math.abs(value.asUnit(UnitType.SECOND));
        const isNegative = value.number < 0;
        let hours = Math.floor(valueAsSeconds / 3600);
        if (this.options.format != DurationDisplayFormat.mm_ss && !(this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours == 0)) {
          hrText = hours.toFixed(0);
          if (this.options.delim === DurationDisplayDelim.ColonOrCross) {
            if (this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss || this.options.format === DurationDisplayFormat.hh_mm) {
              hrDelim = "+";
            } else {
              hrDelim = ":";
            }
          } else {
            hrDelim = this.delim;
          }
        }
        const hoursInMinutes = hours * 60;
        let minutes;
        let seconds;
        if (this.options.format === DurationDisplayFormat.hh_mm || this.options.format === DurationDisplayFormat.hh_mm_or_mm_ss && hours !== 0) {
          minutes = valueAsSeconds / 60 - hoursInMinutes;
          minText = this.options.numberFormatter(minutes);
        } else {
          minutes = Math.floor(valueAsSeconds / 60 - hoursInMinutes);
          minText = minutes.toFixed(0);
          minDelim = this.options.delim === DurationDisplayDelim.ColonOrCross ? ":" : this.delim;
          seconds = valueAsSeconds - (hoursInMinutes + minutes) * 60;
          secText = this.options.numberFormatter(seconds);
        }
        if (secText && secText.replace(/\b0+/, "").substring(0, 2) === "60") {
          seconds = parseFloat(secText) - 60;
          minutes++;
          secText = this.options.numberFormatter(seconds);
          minText = `${minutes}`;
        }
        if (minText && minText.replace(/\b0+/, "").substring(0, 2) === "60" && hrText) {
          if (secText) {
            minutes = 0;
            minText = "00";
          } else {
            minutes = parseFloat(minText) - 60;
            minText = this.options.numberFormatter(minutes);
          }
          hours++;
          hrText = `${hours}`;
        }
        if (hrText) {
          hrText = hrText.padStart(this.options.pad, "0");
          if (secText) {
            minText = minText.padStart(2, "0");
            secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
          } else {
            minText = DurationDisplay.padIntegerPart(minText.replace(/^0+/, ""), 2, "0");
          }
        } else {
          minText = minText.padStart(this.options.pad, "0");
          secText = DurationDisplay.padIntegerPart(secText.replace(/^0+/, ""), 2, "0");
        }
        if (this.options.showUnits) {
          hrText && (hrUnitText = this.options.unitFormatter(parseFloat(hrText), UnitType.HOUR));
          minUnitText = this.options.unitFormatter(parseFloat(minText), UnitType.MINUTE);
          secText && (secUnitText = this.options.unitFormatter(parseFloat(secText), UnitType.SECOND));
        }
        const sign4 = isNegative ? this.negativeSign : this.positiveSign;
        text = `${sign4}${hrText}${hrUnitText}${hrDelim}${minText}${minUnitText}${minDelim}${secText}${secUnitText}`;
      }
      this.text.set(text);
    }
    static padIntegerPart(str, maxLength, fillString) {
      const decimalIndex = str.indexOf(".");
      return str.padStart(decimalIndex < 0 ? maxLength : str.length - decimalIndex + maxLength, fillString);
    }
    render() {
      var _a;
      return FSComponent.buildComponent("div", { class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: "white-space: nowrap;" }, this.text);
    }
    destroy() {
      var _a;
      (_a = this.valueSub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  DurationDisplay.DEFAULT_OPTIONS = {
    pad: 0,
    format: DurationDisplayFormat.hh_mm_ss,
    delim: DurationDisplayDelim.Colon,
    showUnits: false,
    numberFormatter: (value) => value.toFixed(0),
    unitFormatter: (value, unit) => unit.name[0],
    useMinusSign: false,
    forceSign: false,
    nanString: ""
  };
  var DmsDirection;
  (function(DmsDirection2) {
    DmsDirection2["NORTH"] = "N";
    DmsDirection2["SOUTH"] = "S";
    DmsDirection2["WEST"] = "W";
    DmsDirection2["EAST"] = "E";
  })(DmsDirection || (DmsDirection = {}));
  var FocusPosition;
  (function(FocusPosition2) {
    FocusPosition2["MostRecent"] = "MostRecent";
    FocusPosition2["First"] = "First";
    FocusPosition2["Last"] = "Last";
    FocusPosition2["None"] = "None";
  })(FocusPosition || (FocusPosition = {}));
  var BlurReconciliation;
  (function(BlurReconciliation2) {
    BlurReconciliation2["First"] = "First";
    BlurReconciliation2["Last"] = "Last";
    BlurReconciliation2["Next"] = "Next";
    BlurReconciliation2["Prev"] = "Prev";
    BlurReconciliation2["None"] = "None";
  })(BlurReconciliation || (BlurReconciliation = {}));
  var HorizonProjectionChangeType;
  (function(HorizonProjectionChangeType2) {
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Position"] = 1] = "Position";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Altitude"] = 2] = "Altitude";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Heading"] = 4] = "Heading";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Pitch"] = 8] = "Pitch";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Roll"] = 16] = "Roll";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Offset"] = 32] = "Offset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedSize"] = 64] = "ProjectedSize";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["Fov"] = 128] = "Fov";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["FovEndpoints"] = 256] = "FovEndpoints";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ScaleFactor"] = 512] = "ScaleFactor";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["ProjectedOffset"] = 1024] = "ProjectedOffset";
    HorizonProjectionChangeType2[HorizonProjectionChangeType2["OffsetCenterProjected"] = 2048] = "OffsetCenterProjected";
  })(HorizonProjectionChangeType || (HorizonProjectionChangeType = {}));
  var HorizonProjection = class {
    constructor(projectedWidth, projectedHeight, fov) {
      this.position = new GeoPoint(0, 0);
      this.altitude = 0;
      this.heading = 0;
      this.roll = 0;
      this.pitch = 0;
      this.offset = Vec3Math.create();
      this.fovEndpoints = VecNMath.create(4, 0.5, 0, 0.5, 1);
      this.scaleFactor = 1;
      this.projectedOffset = Vec2Math.create();
      this.offsetCenterProjected = Vec2Math.create();
      this.positionAngleTransforms = [new Transform3D(), new Transform3D()];
      this.altitudeTransform = new Transform3D();
      this.positionAltitudeTransforms = [...this.positionAngleTransforms, this.altitudeTransform];
      this.positionTransform = new Transform3D();
      this.planeAngles = Vec3Math.create();
      this.planeAngleTransforms = [new Transform3D(), new Transform3D(), new Transform3D()];
      this.planeTransform = new Transform3D();
      this.cameraPos = Vec3Math.create();
      this.surfacePos = Vec3Math.create();
      this.perspectiveTransform = new TransformPerspective();
      this.oldParameters = {
        position: new GeoPoint(0, 0),
        altitude: 0,
        heading: 0,
        pitch: 0,
        roll: 0,
        offset: Vec3Math.create(),
        projectedSize: Vec2Math.create(),
        fov: 0,
        fovEndpoints: VecNMath.create(4),
        scaleFactor: 1,
        projectedOffset: Vec2Math.create(),
        offsetCenterProjected: Vec2Math.create()
      };
      this.queuedParameters = {};
      this.updateQueued = false;
      this.changeEvent = new SubEvent();
      this.projectedSize = Vec2Math.create(projectedWidth, projectedHeight);
      this.fov = fov;
      this.recompute();
    }
    getPosition() {
      return this.position.readonly;
    }
    getAltitude() {
      return this.altitude;
    }
    getHeading() {
      return this.heading;
    }
    getPitch() {
      return this.pitch;
    }
    getRoll() {
      return this.roll;
    }
    getProjectedSize() {
      return this.projectedSize;
    }
    getFov() {
      return this.fov;
    }
    getFovEndpoints() {
      return this.fovEndpoints;
    }
    getFocalLength() {
      return this.surfacePos[2];
    }
    getScaleFactor() {
      return this.scaleFactor;
    }
    getProjectedOffset() {
      return this.projectedOffset;
    }
    getOffsetCenterProjected() {
      return this.offsetCenterProjected;
    }
    recompute() {
      Vec2Math.set(this.projectedSize[0] / 2 + this.projectedOffset[0], this.projectedSize[1] / 2 + this.projectedOffset[1], this.offsetCenterProjected);
      this.positionAngleTransforms[0].toRotationZ(-this.position.lon * Avionics.Utils.DEG2RAD);
      this.positionAngleTransforms[1].toRotationY(this.position.lat * Avionics.Utils.DEG2RAD);
      this.altitudeTransform.toTranslation(-(UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + this.altitude), 0, 0);
      Transform3D.concat(this.positionTransform, this.positionAltitudeTransforms);
      this.planeAngles[0] = -this.heading * Avionics.Utils.DEG2RAD;
      this.planeAngles[1] = this.pitch * Avionics.Utils.DEG2RAD;
      this.planeAngles[2] = this.roll * Avionics.Utils.DEG2RAD;
      this.planeAngleTransforms[0].toRotationZ(this.planeAngles[2]);
      this.planeAngleTransforms[1].toRotationY(this.planeAngles[1]);
      this.planeAngleTransforms[2].toRotationX(this.planeAngles[0]);
      Transform3D.concat(this.planeTransform, this.planeAngleTransforms);
      this.planeTransform.apply(this.offset, this.cameraPos);
      this.scaleFactor = Math.hypot(this.fovEndpoints[2] * this.projectedSize[0] - this.fovEndpoints[0] * this.projectedSize[0], this.fovEndpoints[3] * this.projectedSize[1] - this.fovEndpoints[1] * this.projectedSize[1]);
      this.surfacePos[2] = 1 / (2 * Math.tan(this.fov * 0.5 * Avionics.Utils.DEG2RAD));
      this.perspectiveTransform.set(this.cameraPos, this.planeTransform, this.surfacePos);
    }
    set(parameters) {
      var _a, _b, _c, _d, _e;
      this.storeParameters(this.oldParameters);
      parameters.position !== void 0 && this.position.set(parameters.position);
      this.altitude = (_a = parameters.altitude) !== null && _a !== void 0 ? _a : this.altitude;
      this.heading = (_b = parameters.heading) !== null && _b !== void 0 ? _b : this.heading;
      this.pitch = (_c = parameters.pitch) !== null && _c !== void 0 ? _c : this.pitch;
      this.roll = (_d = parameters.roll) !== null && _d !== void 0 ? _d : this.roll;
      parameters.offset !== void 0 && this.offset.set(parameters.offset);
      parameters.projectedSize !== void 0 && this.projectedSize.set(parameters.projectedSize);
      this.fov = (_e = parameters.fov) !== null && _e !== void 0 ? _e : this.fov;
      parameters.fovEndpoints !== void 0 && this.fovEndpoints.set(parameters.fovEndpoints);
      parameters.projectedOffset !== void 0 && this.projectedOffset.set(parameters.projectedOffset);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        this.changeEvent.notify(this, changeFlags);
      }
    }
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    storeParameters(record) {
      record.position.set(this.position);
      record.altitude = this.altitude;
      record.heading = this.heading;
      record.pitch = this.pitch;
      record.roll = this.roll;
      record.offset.set(this.offset);
      record.projectedSize.set(this.projectedSize);
      record.fov = this.fov;
      record.fovEndpoints.set(this.fovEndpoints);
      record.scaleFactor = this.scaleFactor;
      record.projectedOffset.set(this.projectedOffset);
      record.offsetCenterProjected.set(this.offsetCenterProjected);
    }
    computeChangeFlags(oldParameters) {
      return (oldParameters.position.equals(this.position) ? 0 : HorizonProjectionChangeType.Position) | (oldParameters.altitude === this.altitude ? 0 : HorizonProjectionChangeType.Altitude) | (oldParameters.heading === this.heading ? 0 : HorizonProjectionChangeType.Heading) | (oldParameters.pitch === this.pitch ? 0 : HorizonProjectionChangeType.Pitch) | (oldParameters.roll === this.roll ? 0 : HorizonProjectionChangeType.Roll) | (Vec3Math.equals(oldParameters.offset, this.offset) ? 0 : HorizonProjectionChangeType.Offset) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : HorizonProjectionChangeType.ProjectedSize) | (oldParameters.fov === this.fov ? 0 : HorizonProjectionChangeType.Fov) | (VecNMath.equals(oldParameters.fovEndpoints, this.fovEndpoints) ? 0 : HorizonProjectionChangeType.ProjectedOffset) | (Vec2Math.equals(oldParameters.projectedOffset, this.projectedOffset) ? 0 : HorizonProjectionChangeType.ProjectedOffset);
    }
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.scaleFactor === this.scaleFactor ? 0 : HorizonProjectionChangeType.ScaleFactor) | (Vec2Math.equals(oldParameters.offsetCenterProjected, this.offsetCenterProjected) ? 0 : HorizonProjectionChangeType.OffsetCenterProjected);
    }
    onChange(listener) {
      return this.changeEvent.on(listener);
    }
    project(position, altitude, out) {
      const vec = GeoPoint.sphericalToCartesian(position, HorizonProjection.vec3Cache[0]);
      Vec3Math.multScalar(vec, UnitType.GA_RADIAN.convertTo(1, UnitType.METER) + altitude, vec);
      this.positionTransform.apply(vec, vec);
      return this.projectRelativeVec(vec, out);
    }
    projectRelativeSpherical(bearing, distance, height, out) {
      return this.project(this.position.offset(bearing, UnitType.METER.convertTo(distance, UnitType.GA_RADIAN), HorizonProjection.geoPointCache[0]), this.altitude + height, out);
    }
    projectRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    projectRelativeVec(vec, out) {
      this.perspectiveTransform.apply(vec, out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    projectCameraRelativeEuclidean(bearing, distance, height, out) {
      const vec = Vec2Math.setFromPolar(distance, bearing * Avionics.Utils.DEG2RAD, HorizonProjection.vec3Cache[0]);
      const x = height;
      const y = vec[1];
      const z = vec[0];
      return this.projectCameraRelativeVec(Vec3Math.set(x, y, z, vec), out);
    }
    projectCameraRelativeVec(vec, out) {
      this.perspectiveTransform.apply(Vec3Math.add(vec, this.perspectiveTransform.getCameraPosition(), HorizonProjection.cameraRelativeVec3Cache[0]), out);
      return Vec2Math.set(out[1] * this.scaleFactor + this.projectedSize[0] / 2 + this.projectedOffset[0], -out[0] * this.scaleFactor + this.projectedSize[1] / 2 + this.projectedOffset[1], out);
    }
    isInProjectedBounds(point, arg2, arg3) {
      let bounds;
      if (point instanceof Float64Array) {
        bounds = arg2;
      } else {
        point = this.project(point, arg2, HorizonProjection.vec2Cache[0]);
        bounds = arg3;
      }
      const x = point[0];
      const y = point[1];
      if (!isFinite(x) || !isFinite(y)) {
        return false;
      }
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      return x >= left && x <= right && y >= top && y <= bottom;
    }
  };
  HorizonProjection.vec2Cache = [Vec2Math.create()];
  HorizonProjection.vec3Cache = [Vec3Math.create()];
  HorizonProjection.geoPointCache = [new GeoPoint(0, 0)];
  HorizonProjection.cameraRelativeVec3Cache = [Vec3Math.create()];
  var MapLayer = class extends DisplayComponent {
    constructor() {
      super(...arguments);
      this._isVisible = true;
    }
    isVisible() {
      return this._isVisible;
    }
    setVisible(val) {
      if (this._isVisible === val) {
        return;
      }
      this._isVisible = val;
      this.onVisibilityChanged(val);
    }
    onVisibilityChanged(isVisible) {
    }
    onAttached() {
    }
    onWake() {
    }
    onSleep() {
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    onUpdated(time, elapsed) {
    }
    onDetached() {
    }
  };
  var MapProjectionChangeType;
  (function(MapProjectionChangeType2) {
    MapProjectionChangeType2[MapProjectionChangeType2["Target"] = 1] = "Target";
    MapProjectionChangeType2[MapProjectionChangeType2["Center"] = 2] = "Center";
    MapProjectionChangeType2[MapProjectionChangeType2["TargetProjected"] = 4] = "TargetProjected";
    MapProjectionChangeType2[MapProjectionChangeType2["Range"] = 8] = "Range";
    MapProjectionChangeType2[MapProjectionChangeType2["RangeEndpoints"] = 16] = "RangeEndpoints";
    MapProjectionChangeType2[MapProjectionChangeType2["ScaleFactor"] = 32] = "ScaleFactor";
    MapProjectionChangeType2[MapProjectionChangeType2["Rotation"] = 64] = "Rotation";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedSize"] = 128] = "ProjectedSize";
    MapProjectionChangeType2[MapProjectionChangeType2["ProjectedResolution"] = 256] = "ProjectedResolution";
  })(MapProjectionChangeType || (MapProjectionChangeType = {}));
  var MapProjection = class {
    constructor(projectedWidth, projectedHeight) {
      this.target = new GeoPoint(0, 0);
      this.targetProjectedOffset = new Float64Array(2);
      this.targetProjected = new Float64Array(2);
      this.range = 1;
      this.rangeEndpoints = new Float64Array([0.5, 0, 0.5, 1]);
      this.projectedSize = new Float64Array(2);
      this.center = new GeoPoint(0, 0);
      this.centerProjected = new Float64Array(2);
      this.projectedRange = 0;
      this.widthRange = 0;
      this.heightRange = 0;
      this.oldParameters = {
        target: new GeoPoint(0, 0),
        center: new GeoPoint(0, 0),
        targetProjected: new Float64Array(2),
        range: 1,
        rangeEndpoints: new Float64Array(4),
        scaleFactor: 1,
        rotation: 0,
        projectedSize: new Float64Array(2),
        projectedResolution: 0
      };
      this.queuedParameters = Object.assign({}, this.oldParameters);
      this.updateQueued = false;
      this.changeListeners = [];
      Vec2Math.set(projectedWidth, projectedHeight, this.projectedSize);
      this.geoProjection = new MercatorProjection();
      Vec2Math.set(projectedWidth / 2, projectedHeight / 2, this.centerProjected);
      this.targetProjected.set(this.centerProjected);
      this.geoProjection.setReflectY(true).setTranslation(this.centerProjected);
      this.recompute();
    }
    getGeoProjection() {
      return this.geoProjection;
    }
    getTarget() {
      return this.target.readonly;
    }
    getTargetProjectedOffset() {
      return this.targetProjectedOffset;
    }
    getTargetProjected() {
      return this.targetProjected;
    }
    getRange() {
      return this.range;
    }
    getRangeEndpoints() {
      return this.rangeEndpoints;
    }
    getWidthRange() {
      return this.widthRange;
    }
    getHeightRange() {
      return this.heightRange;
    }
    getScaleFactor() {
      return this.geoProjection.getScaleFactor();
    }
    getRotation() {
      return this.geoProjection.getPostRotation();
    }
    getProjectedSize() {
      return this.projectedSize;
    }
    getCenter() {
      return this.center.readonly;
    }
    getCenterProjected() {
      return this.centerProjected;
    }
    getProjectedResolution() {
      return this.range / this.projectedRange;
    }
    calculateRangeAtCenter(centerProjected) {
      const endpoints = this.rangeEndpoints;
      const projectedWidth = this.projectedSize[0];
      const projectedHeight = this.projectedSize[1];
      const endpoint1 = MapProjection.tempVec2_3;
      endpoint1[0] = centerProjected[0] + projectedWidth * (endpoints[0] - 0.5);
      endpoint1[1] = centerProjected[1] + projectedHeight * (endpoints[1] - 0.5);
      const endpoint2 = MapProjection.tempVec2_4;
      endpoint2[0] = centerProjected[0] + projectedWidth * (endpoints[2] - 0.5);
      endpoint2[1] = centerProjected[1] + projectedHeight * (endpoints[3] - 0.5);
      const top = this.geoProjection.invert(endpoint1, MapProjection.tempGeoPoint_1);
      const bottom = this.geoProjection.invert(endpoint2, MapProjection.tempGeoPoint_2);
      return top.distance(bottom);
    }
    recompute() {
      const currentTargetProjected = this.geoProjection.project(this.target, MapProjection.tempVec2_1);
      if (!isFinite(currentTargetProjected[0] + currentTargetProjected[1])) {
        const translation = this.geoProjection.getTranslation();
        if (isFinite(this.target.lat) && isFinite(this.target.lon) && isFinite(this.geoProjection.getPostRotation()) && isFinite(translation[0]) && isFinite(translation[1])) {
          this.geoProjection.setScaleFactor(MapProjection.DEFAULT_SCALE_FACTOR);
          this.geoProjection.setCenter(MapProjection.tempGeoPoint_1.set(0, 0));
          this.geoProjection.setPreRotation(Vec3Math.set(0, 0, 0, MapProjection.vec3Cache[0]));
        } else {
          return;
        }
      }
      const currentCenterProjected = MapProjection.tempVec2_2;
      currentCenterProjected.set(currentTargetProjected);
      currentCenterProjected[0] -= this.targetProjectedOffset[0];
      currentCenterProjected[1] -= this.targetProjectedOffset[1];
      let currentRange = this.calculateRangeAtCenter(currentCenterProjected);
      let ratio = currentRange / this.range;
      if (!isFinite(ratio) || ratio === 0) {
        return;
      }
      let lastScaleFactor = this.geoProjection.getScaleFactor();
      let iterCount = 0;
      let ratioError = Math.abs(ratio - 1);
      let deltaRatioError = MapProjection.SCALE_FACTOR_TOLERANCE + 1;
      while (iterCount++ < MapProjection.SCALE_FACTOR_MAX_ITER && ratioError > MapProjection.SCALE_FACTOR_TOLERANCE && deltaRatioError > MapProjection.SCALE_FACTOR_TOLERANCE) {
        this.geoProjection.setScaleFactor(ratio * lastScaleFactor);
        this.geoProjection.project(this.target, currentTargetProjected);
        currentCenterProjected.set(currentTargetProjected);
        currentCenterProjected[0] -= this.targetProjectedOffset[0];
        currentCenterProjected[1] -= this.targetProjectedOffset[1];
        currentRange = this.calculateRangeAtCenter(currentCenterProjected);
        const newRatio = currentRange / this.range;
        const ratioDelta = newRatio - ratio;
        if (!isFinite(ratio) || ratio < 1 && ratioDelta <= 0 || ratio > 1 && ratioDelta >= 0) {
          this.geoProjection.setScaleFactor(lastScaleFactor);
        }
        lastScaleFactor = this.geoProjection.getScaleFactor();
        ratio = newRatio;
        const newRatioError = Math.abs(ratio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.invert(currentCenterProjected, this.center);
      this.geoProjection.setCenter(this.center);
      const preRotation = Vec3Math.set(-this.center.lon * Avionics.Utils.DEG2RAD, 0, 0, MapProjection.vec3Cache[0]);
      this.geoProjection.setPreRotation(preRotation);
      const width = this.projectedSize[0];
      const height = this.projectedSize[1];
      this.projectedRange = Math.hypot((this.rangeEndpoints[2] - this.rangeEndpoints[0]) * width, (this.rangeEndpoints[3] - this.rangeEndpoints[1]) * height);
      const left = Vec2Math.set(0, height / 2, MapProjection.tempVec2_1);
      const right = Vec2Math.set(width, height / 2, MapProjection.tempVec2_2);
      this.widthRange = this.geoDistance(left, right);
      const top = Vec2Math.set(width / 2, 0, MapProjection.tempVec2_1);
      const bottom = Vec2Math.set(width / 2, height, MapProjection.tempVec2_2);
      this.heightRange = this.geoDistance(top, bottom);
    }
    set(parameters) {
      this.storeParameters(this.oldParameters);
      parameters.projectedSize && this.setProjectedSize(parameters.projectedSize);
      parameters.target && this.target.set(parameters.target);
      parameters.targetProjectedOffset && this.setTargetProjectedOffset(parameters.targetProjectedOffset);
      parameters.range !== void 0 && (this.range = parameters.range);
      parameters.rangeEndpoints && this.rangeEndpoints.set(parameters.rangeEndpoints);
      parameters.rotation !== void 0 && this.geoProjection.setPostRotation(parameters.rotation);
      let changeFlags = this.computeChangeFlags(this.oldParameters);
      if (changeFlags !== 0) {
        this.recompute();
        changeFlags |= this.computeDerivedChangeFlags(this.oldParameters);
        if (changeFlags !== 0) {
          this.notifyChangeListeners(changeFlags);
        }
      }
    }
    setQueued(parameters) {
      Object.assign(this.queuedParameters, parameters);
      this.updateQueued = true;
    }
    applyQueued() {
      if (this.updateQueued) {
        this.updateQueued = false;
        this.set(this.queuedParameters);
        for (const key in this.queuedParameters) {
          delete this.queuedParameters[key];
        }
      }
    }
    setProjectedSize(size2) {
      this.projectedSize.set(size2);
      Vec2Math.set(size2[0] / 2, size2[1] / 2, this.centerProjected);
      this.geoProjection.setTranslation(this.centerProjected);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    setTargetProjectedOffset(offset) {
      this.targetProjectedOffset.set(offset);
      Vec2Math.add(this.centerProjected, this.targetProjectedOffset, this.targetProjected);
    }
    storeParameters(record) {
      record.target.set(this.target);
      record.center.set(this.center);
      record.targetProjected.set(this.targetProjected);
      record.range = this.range;
      record.rangeEndpoints.set(this.rangeEndpoints);
      record.scaleFactor = this.geoProjection.getScaleFactor();
      record.rotation = this.getRotation();
      record.projectedSize.set(this.projectedSize);
      record.projectedResolution = this.getProjectedResolution();
    }
    computeChangeFlags(oldParameters) {
      return (oldParameters.target.equals(this.target) ? 0 : MapProjectionChangeType.Target) | (Vec2Math.equals(oldParameters.targetProjected, this.targetProjected) ? 0 : MapProjectionChangeType.TargetProjected) | (oldParameters.range === this.range ? 0 : MapProjectionChangeType.Range) | (VecNMath.equals(oldParameters.rangeEndpoints, this.rangeEndpoints) ? 0 : MapProjectionChangeType.RangeEndpoints) | (oldParameters.rotation === this.getRotation() ? 0 : MapProjectionChangeType.Rotation) | (Vec2Math.equals(oldParameters.projectedSize, this.projectedSize) ? 0 : MapProjectionChangeType.ProjectedSize);
    }
    computeDerivedChangeFlags(oldParameters) {
      return (oldParameters.center.equals(this.center) ? 0 : MapProjectionChangeType.Center) | (oldParameters.scaleFactor === this.geoProjection.getScaleFactor() ? 0 : MapProjectionChangeType.ScaleFactor) | (oldParameters.projectedResolution === this.getProjectedResolution() ? 0 : MapProjectionChangeType.ProjectedResolution);
    }
    project(point, out) {
      return this.geoProjection.project(point, out);
    }
    invert(vec, out) {
      return this.geoProjection.invert(vec, out);
    }
    isInProjectedBounds(point, bounds) {
      let left;
      let top;
      let right;
      let bottom;
      if (bounds) {
        left = bounds[0];
        top = bounds[1];
        right = bounds[2];
        bottom = bounds[3];
      } else {
        left = 0;
        top = 0;
        right = this.projectedSize[0];
        bottom = this.projectedSize[1];
      }
      if (!(point instanceof Float64Array)) {
        point = this.project(point, MapProjection.tempVec2_2);
      }
      const x = point[0];
      const y = point[1];
      return x >= left && x <= right && y >= top && y <= bottom;
    }
    geoDistance(point1, point2) {
      if (point1 instanceof Float64Array) {
        point1 = this.invert(point1, MapProjection.tempGeoPoint_1);
      }
      if (point2 instanceof Float64Array) {
        point2 = this.invert(point2, MapProjection.tempGeoPoint_2);
      }
      return point1.distance(point2);
    }
    projectedDistance(point1, point2) {
      if (!(point1 instanceof Float64Array)) {
        point1 = this.project(point1, MapProjection.tempVec2_1);
      }
      if (!(point2 instanceof Float64Array)) {
        point2 = this.project(point2, MapProjection.tempVec2_2);
      }
      return Vec2Math.distance(point1, point2);
    }
    notifyChangeListeners(changeFlags) {
      for (let i = 0; i < this.changeListeners.length; i++) {
        this.changeListeners[i](this, changeFlags);
      }
    }
    addChangeListener(listener) {
      this.changeListeners.push(listener);
    }
    removeChangeListener(listener) {
      const index = this.changeListeners.lastIndexOf(listener);
      if (index >= 0) {
        this.changeListeners.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
  };
  MapProjection.DEFAULT_SCALE_FACTOR = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
  MapProjection.SCALE_FACTOR_MAX_ITER = 20;
  MapProjection.SCALE_FACTOR_TOLERANCE = 1e-6;
  MapProjection.tempVec2_1 = new Float64Array(2);
  MapProjection.tempVec2_2 = new Float64Array(2);
  MapProjection.tempVec2_3 = new Float64Array(2);
  MapProjection.tempVec2_4 = new Float64Array(2);
  MapProjection.tempGeoPoint_1 = new GeoPoint(0, 0);
  MapProjection.tempGeoPoint_2 = new GeoPoint(0, 0);
  MapProjection.vec3Cache = [Vec3Math.create()];
  var MapComponent = class extends DisplayComponent {
    constructor(props) {
      var _a;
      super(props);
      this.layerEntries = [];
      this.lastUpdateTime = 0;
      this._isAwake = true;
      this.updateCycleHandler = this.update.bind(this);
      this.projectedSize = "isSubscribable" in this.props.projectedSize ? this.props.projectedSize : Subject.create(this.props.projectedSize);
      const initialSize = this.projectedSize.get();
      if (this.props.projection !== void 0) {
        this.props.projection.set({ projectedSize: new Float64Array(initialSize) });
      }
      this.mapProjection = (_a = this.props.projection) !== null && _a !== void 0 ? _a : new MapProjection(initialSize[0], initialSize[1]);
    }
    getProjectedSize() {
      return this.mapProjection.getProjectedSize();
    }
    get isAwake() {
      return this._isAwake;
    }
    sleep() {
      this.setAwakeState(false);
    }
    wake() {
      this.setAwakeState(true);
    }
    setAwakeState(isAwake) {
      if (this._isAwake === isAwake) {
        return;
      }
      this._isAwake = isAwake;
      this._isAwake ? this.onWake() : this.onSleep();
    }
    onAfterRender(thisNode) {
      var _a;
      this.mapProjection.addChangeListener(this.onMapProjectionChanged.bind(this));
      this.projectedSizeSub = this.projectedSize.sub((size2) => {
        this.mapProjection.set({ projectedSize: size2 });
      });
      (_a = this.props.updateFreq) === null || _a === void 0 ? void 0 : _a.sub((freq) => {
        var _a2;
        (_a2 = this.updateCycleSub) === null || _a2 === void 0 ? void 0 : _a2.destroy();
        this.updateCycleSub = this.props.bus.getSubscriber().on("realTime").whenChanged().atFrequency(freq).handle(this.updateCycleHandler);
      }, true);
      this.attachLayers(thisNode);
    }
    attachLayers(thisNode) {
      FSComponent.visitNodes(thisNode, (node) => {
        if (node.instance instanceof MapLayer) {
          this.attachLayer(node.instance);
          return true;
        }
        return false;
      });
    }
    onWake() {
      this.wakeLayers();
    }
    wakeLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onWake();
      }
    }
    onSleep() {
      this.sleepLayers();
    }
    sleepLayers() {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onSleep();
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.onProjectedSizeChanged();
      }
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].layer.onMapProjectionChanged(mapProjection, changeFlags);
      }
    }
    attachLayer(layer) {
      if (this.layerEntries.findIndex((entry2) => entry2.layer === layer) >= 0) {
        return;
      }
      const entry = new LayerEntry(layer);
      this.layerEntries.push(entry);
      entry.attach();
    }
    detachLayer(layer) {
      const index = this.layerEntries.findIndex((entry) => entry.layer === layer);
      if (index >= 0) {
        const entry = this.layerEntries[index];
        entry.detach();
        this.layerEntries.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    update(time) {
      if (!this._isAwake) {
        return;
      }
      this.onUpdated(time, time - this.lastUpdateTime);
      this.lastUpdateTime = time;
    }
    onUpdated(time, elapsed) {
      this.updateLayers(time, elapsed);
    }
    updateLayers(time, elapsed) {
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].update(time);
      }
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateCycleSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.projectedSizeSub) === null || _b === void 0 ? void 0 : _b.destroy();
      const len = this.layerEntries.length;
      for (let i = 0; i < len; i++) {
        this.layerEntries[i].destroy();
      }
    }
  };
  var LayerEntry = class {
    constructor(layer) {
      this.layer = layer;
      this.updatePeriod = 0;
      this.lastUpdated = 0;
    }
    attach() {
      var _a, _b;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.updateFreqSub = (_b = this.layer.props.updateFreq) === null || _b === void 0 ? void 0 : _b.sub((freq) => {
        const clamped = Math.max(0, freq);
        this.updatePeriod = clamped === 0 ? 0 : 1e3 / clamped;
      }, true);
      this.layer.onAttached();
    }
    update(currentTime) {
      if (currentTime - this.lastUpdated >= this.updatePeriod) {
        this.layer.onUpdated(currentTime, currentTime - this.lastUpdated);
        this.lastUpdated = currentTime;
      }
    }
    detach() {
      var _a;
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.layer.onDetached();
    }
    destroy() {
      this.detach();
      this.layer.destroy();
    }
  };
  var MapModel = class {
    constructor() {
      this.modules = /* @__PURE__ */ new Map();
    }
    getModule(nameOrModule) {
      if (typeof nameOrModule === "string") {
        return this.modules.get(nameOrModule);
      } else if (typeof nameOrModule === "function") {
        return this.modules.get(nameOrModule.name);
      }
      throw new Error("Invalid type supplied: must be a string key or a module constructor.");
    }
    addModule(name69, module2) {
      if (this.modules.has(name69)) {
        return;
      }
      this.modules.set(name69, module2);
    }
  };
  var AbstractMapTextLabel = class {
    constructor(text, priority, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.text = SubscribableUtils.toSubscribable(text, true);
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
      this.font = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.font) !== null && _b !== void 0 ? _b : "", true);
      this.fontSize = SubscribableUtils.toSubscribable((_c = options === null || options === void 0 ? void 0 : options.fontSize) !== null && _c !== void 0 ? _c : 10, true);
      this.fontStr = MappedSubject.create(([s, f]) => {
        return `${s}px ${f}`;
      }, this.fontSize, this.font);
      this.fontColor = SubscribableUtils.toSubscribable((_d = options === null || options === void 0 ? void 0 : options.fontColor) !== null && _d !== void 0 ? _d : "white", true);
      this.fontOutlineWidth = SubscribableUtils.toSubscribable((_e = options === null || options === void 0 ? void 0 : options.fontOutlineWidth) !== null && _e !== void 0 ? _e : 0, true);
      this.fontOutlineColor = SubscribableUtils.toSubscribable((_f = options === null || options === void 0 ? void 0 : options.fontOutlineColor) !== null && _f !== void 0 ? _f : "black", true);
      this.showBg = SubscribableUtils.toSubscribable((_g = options === null || options === void 0 ? void 0 : options.showBg) !== null && _g !== void 0 ? _g : false, true);
      this.bgColor = SubscribableUtils.toSubscribable((_h = options === null || options === void 0 ? void 0 : options.bgColor) !== null && _h !== void 0 ? _h : "black", true);
      this.bgPadding = SubscribableUtils.toSubscribable((_j = options === null || options === void 0 ? void 0 : options.bgPadding) !== null && _j !== void 0 ? _j : VecNMath.create(4), true);
      this.bgBorderRadius = SubscribableUtils.toSubscribable((_k = options === null || options === void 0 ? void 0 : options.bgBorderRadius) !== null && _k !== void 0 ? _k : 0, true);
      this.bgOutlineWidth = SubscribableUtils.toSubscribable((_l = options === null || options === void 0 ? void 0 : options.bgOutlineWidth) !== null && _l !== void 0 ? _l : 0, true);
      this.bgOutlineColor = SubscribableUtils.toSubscribable((_m = options === null || options === void 0 ? void 0 : options.bgOutlineColor) !== null && _m !== void 0 ? _m : "white", true);
    }
    draw(context, mapProjection) {
      if (this.fontSize.get() !== 0) {
        this.setTextStyle(context);
        const width = context.measureText(this.text.get()).width;
        const height = this.fontSize.get();
        const showBg = this.showBg.get();
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        const bgExtraWidth = showBg ? bgPadding[1] + bgPadding[3] + bgOutlineWidth * 2 : 0;
        const bgExtraHeight = showBg ? bgPadding[0] + bgPadding[2] + bgOutlineWidth * 2 : 0;
        const anchor = this.anchor.get();
        const pos = this.getPosition(mapProjection, AbstractMapTextLabel.tempVec2);
        const centerX = pos[0] - (anchor[0] - 0.5) * (width + bgExtraWidth);
        const centerY = pos[1] - (anchor[1] - 0.5) * (height + bgExtraHeight);
        if (showBg) {
          this.drawBackground(context, centerX, centerY, width, height);
        }
        this.drawText(context, centerX, centerY);
      }
    }
    setTextStyle(context) {
      context.font = this.fontStr.get();
      context.textBaseline = "middle";
      context.textAlign = "center";
    }
    drawText(context, centerX, centerY) {
      const text = this.text.get();
      const fontOutlineWidth = this.fontOutlineWidth.get();
      if (fontOutlineWidth > 0) {
        context.lineWidth = fontOutlineWidth * 2;
        context.strokeStyle = this.fontOutlineColor.get();
        context.strokeText(text, centerX, centerY);
      }
      context.fillStyle = this.fontColor.get();
      context.fillText(text, centerX, centerY);
    }
    drawBackground(context, centerX, centerY, width, height) {
      const bgPadding = this.bgPadding.get();
      const bgOutlineWidth = this.bgOutlineWidth.get();
      const bgBorderRadius = this.bgBorderRadius.get();
      const backgroundLeft = centerX - width / 2 - (bgPadding[3] + bgOutlineWidth);
      const backgroundTop = centerY - height / 2 - (bgPadding[0] + bgOutlineWidth);
      const backgroundWidth = width + (bgPadding[1] + bgPadding[3] + 2 * bgOutlineWidth);
      const backgroundHeight = height + (bgPadding[0] + bgPadding[2] + 2 * bgOutlineWidth);
      let isRounded = false;
      if (bgBorderRadius > 0) {
        isRounded = true;
        this.loadBackgroundPath(context, backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight, bgBorderRadius);
      }
      if (bgOutlineWidth > 0) {
        context.lineWidth = bgOutlineWidth * 2;
        context.strokeStyle = this.bgOutlineColor.get();
        if (isRounded) {
          context.stroke();
        } else {
          context.strokeRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
        }
      }
      context.fillStyle = this.bgColor.get();
      if (isRounded) {
        context.fill();
      } else {
        context.fillRect(backgroundLeft, backgroundTop, backgroundWidth, backgroundHeight);
      }
    }
    loadBackgroundPath(context, left, top, width, height, radius) {
      const right = left + width;
      const bottom = top + height;
      context.beginPath();
      context.moveTo(left + radius, top);
      context.lineTo(right - radius, top);
      context.arcTo(right, top, right, top + radius, radius);
      context.lineTo(right, bottom - radius);
      context.arcTo(right, bottom, right - radius, bottom, radius);
      context.lineTo(left + radius, bottom);
      context.arcTo(left, bottom, left, bottom - radius, radius);
      context.lineTo(left, top + radius);
      context.arcTo(left, top, left + radius, top, radius);
    }
  };
  AbstractMapTextLabel.tempVec2 = new Float64Array(2);
  var MapLocationTextLabel = class extends AbstractMapTextLabel {
    constructor(text, priority, location, options) {
      var _a;
      super(text, priority, options);
      this.location = SubscribableUtils.toSubscribable(location, true);
      this.offset = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : Vec2Math.create(), true);
    }
    getPosition(mapProjection, out) {
      mapProjection.project(this.location.get(), out);
      Vec2Math.add(out, this.offset.get(), out);
      return out;
    }
  };
  var MapCullableLocationTextLabel = class extends MapLocationTextLabel {
    constructor(text, priority, location, alwaysShow, options) {
      super(text, priority, location, options);
      this.bounds = new Float64Array(4);
      this.invalidation = new SubEvent();
      this.subs = [];
      this.alwaysShow = SubscribableUtils.toSubscribable(alwaysShow, true);
      this.subs.push(this.priority.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.alwaysShow.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.location.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.text.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.fontSize.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.anchor.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.offset.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgPadding.sub(() => {
        this.invalidation.notify(this);
      }));
      this.subs.push(this.bgOutlineWidth.sub(() => {
        this.invalidation.notify(this);
      }));
    }
    updateBounds(mapProjection) {
      const fontSize = this.fontSize.get();
      const anchor = this.anchor.get();
      const width = 0.6 * fontSize * this.text.get().length;
      const height = fontSize;
      const pos = this.getPosition(mapProjection, MapCullableLocationTextLabel.tempVec2);
      let left = pos[0] - anchor[0] * width;
      let right = left + width;
      let top = pos[1] - anchor[1] * height;
      let bottom = top + height;
      if (this.showBg.get()) {
        const bgPadding = this.bgPadding.get();
        const bgOutlineWidth = this.bgOutlineWidth.get();
        left -= bgPadding[3] + bgOutlineWidth;
        right += bgPadding[1] + bgOutlineWidth;
        top -= bgPadding[0] + bgOutlineWidth;
        bottom += bgPadding[2] + bgOutlineWidth;
      }
      this.bounds[0] = left;
      this.bounds[1] = top;
      this.bounds[2] = right;
      this.bounds[3] = bottom;
    }
    destroy() {
      for (const sub2 of this.subs) {
        sub2.destroy();
      }
    }
  };
  var MapCullableTextLabelManager = class {
    constructor(cullingEnabled = true) {
      this.cullingEnabled = cullingEnabled;
      this.registered = /* @__PURE__ */ new Map();
      this._visibleLabels = [];
      this.needUpdate = false;
      this.lastScaleFactor = 1;
      this.lastRotation = 0;
      this.invalidationHandler = () => {
        this.needUpdate = true;
      };
    }
    get visibleLabels() {
      return this._visibleLabels;
    }
    register(label) {
      if (this.registered.has(label)) {
        return;
      }
      this.registered.set(label, label.invalidation.on(this.invalidationHandler));
      this.needUpdate = true;
    }
    deregister(label) {
      const sub2 = this.registered.get(label);
      if (sub2 === void 0) {
        return;
      }
      sub2.destroy();
      this.registered.delete(label);
      this.needUpdate = true;
    }
    setCullingEnabled(enabled) {
      this.cullingEnabled = enabled;
      this.needUpdate = true;
    }
    update(mapProjection) {
      if (!this.needUpdate) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this.lastScaleFactor;
        if (scaleFactorRatio < MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD && scaleFactorRatio > 1 / MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD) {
          const rotationDelta = Math.abs(mapProjection.getRotation() - this.lastRotation);
          if (Math.min(rotationDelta, 2 * Math.PI - rotationDelta) < MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD) {
            return;
          }
        }
      }
      this._visibleLabels = [];
      if (this.cullingEnabled) {
        const labelArray = Array.from(this.registered.keys());
        const len = labelArray.length;
        for (let i = 0; i < len; i++) {
          labelArray[i].updateBounds(mapProjection);
        }
        labelArray.sort(MapCullableTextLabelManager.SORT_FUNC);
        const collisionArray = [];
        for (let i = 0; i < len; i++) {
          const label = labelArray[i];
          let show = true;
          if (!label.alwaysShow.get()) {
            const len2 = collisionArray.length;
            for (let j = 0; j < len2; j++) {
              const other = collisionArray[j];
              if (MapCullableTextLabelManager.doesCollide(label.bounds, other)) {
                show = false;
                break;
              }
            }
          }
          if (show) {
            collisionArray.push(label.bounds);
            this._visibleLabels.push(label);
          }
        }
      } else {
        this._visibleLabels.push(...this.registered.keys());
      }
      this.lastScaleFactor = mapProjection.getScaleFactor();
      this.lastRotation = mapProjection.getRotation();
      this.needUpdate = false;
    }
    static doesCollide(a, b) {
      return a[0] < b[2] && a[2] > b[0] && a[1] < b[3] && a[3] > b[1];
    }
  };
  MapCullableTextLabelManager.SCALE_UPDATE_THRESHOLD = 1.2;
  MapCullableTextLabelManager.ROTATION_UPDATE_THRESHOLD = Math.PI / 6;
  MapCullableTextLabelManager.SORT_FUNC = (a, b) => {
    const alwaysShowA = a.alwaysShow.get();
    const alwaysShowB = b.alwaysShow.get();
    if (alwaysShowA && !alwaysShowB) {
      return -1;
    } else if (alwaysShowB && !alwaysShowA) {
      return 1;
    } else {
      return b.priority.get() - a.priority.get();
    }
  };
  var AbstractMapWaypointIcon = class {
    constructor(waypoint, priority, size2, options) {
      var _a, _b;
      this.waypoint = waypoint;
      this.priority = SubscribableUtils.toSubscribable(priority, true);
      this.size = SubscribableUtils.toSubscribable(size2, true);
      this.anchor = SubscribableUtils.toSubscribable((_a = options === null || options === void 0 ? void 0 : options.anchor) !== null && _a !== void 0 ? _a : Vec2Math.create(0.5, 0.5), true);
      this.offset = SubscribableUtils.toSubscribable((_b = options === null || options === void 0 ? void 0 : options.offset) !== null && _b !== void 0 ? _b : Vec2Math.create(), true);
    }
    draw(context, mapProjection) {
      const size2 = this.size.get();
      const offset = this.offset.get();
      const anchor = this.anchor.get();
      const projected = mapProjection.project(this.waypoint.location.get(), MapWaypointImageIcon.tempVec2);
      const left = projected[0] + offset[0] - anchor[0] * size2[0];
      const top = projected[1] + offset[1] - anchor[1] * size2[1];
      this.drawIconAt(context, mapProjection, left, top);
    }
  };
  AbstractMapWaypointIcon.tempVec2 = new Float64Array(2);
  var MapWaypointImageIcon = class extends AbstractMapWaypointIcon {
    constructor(waypoint, priority, img, size2, options) {
      super(waypoint, priority, size2, options);
      this.img = img;
    }
    drawIconAt(context, mapProjection, left, top) {
      const size2 = this.size.get();
      context.drawImage(this.img, left, top, size2[0], size2[1]);
    }
  };
  var MapWaypointRenderer = class {
    constructor(textManager, selectRoleToRender = MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR) {
      this.textManager = textManager;
      this.selectRoleToRender = selectRoleToRender;
      this.registered = /* @__PURE__ */ new Map();
      this.toCleanUp = /* @__PURE__ */ new Set();
      this.roleDefinitions = /* @__PURE__ */ new Map();
      this.onWaypointAdded = new SubEvent();
      this.onWaypointRemoved = new SubEvent();
    }
    hasRenderRole(role) {
      return this.roleDefinitions.has(role);
    }
    addRenderRole(role, def) {
      if (this.roleDefinitions.has(role)) {
        return false;
      }
      this.roleDefinitions.set(role, Object.assign({}, def !== null && def !== void 0 ? def : MapWaypointRenderer.NULL_ROLE_DEF));
      return true;
    }
    removeRenderRole(role) {
      return this.roleDefinitions.delete(role);
    }
    getRenderRoleDefinition(role) {
      return this.roleDefinitions.get(role);
    }
    renderRoles() {
      return this.roleDefinitions.keys();
    }
    clearRenderRoles() {
      this.roleDefinitions.clear();
    }
    setIconFactory(role, factory2) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.iconFactory = factory2;
      return true;
    }
    setLabelFactory(role, factory2) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.labelFactory = factory2;
      return true;
    }
    setCanvasContext(role, context) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.canvasContext = context;
      return true;
    }
    setVisibilityHandler(role, handler) {
      const roleDef = this.roleDefinitions.get(role);
      if (!roleDef) {
        return false;
      }
      roleDef.visibilityHandler = handler;
      return true;
    }
    isRegistered(waypoint, role) {
      if (!waypoint) {
        return false;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return false;
      }
      if (role === void 0) {
        return true;
      }
      return entry.isAllRoles(role);
    }
    register(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      let entry = this.registered.get(waypoint.uid);
      if (!entry) {
        entry = new MapWaypointRendererEntry(waypoint, this.textManager, this.roleDefinitions, this.selectRoleToRender);
        this.registered.set(waypoint.uid, entry);
        this.onWaypointAdded.notify(this, waypoint);
      }
      entry.addRole(role, sourceId);
    }
    deregister(waypoint, role, sourceId) {
      if (role === 0 || sourceId === "") {
        return;
      }
      const entry = this.registered.get(waypoint.uid);
      if (!entry) {
        return;
      }
      entry.removeRole(role, sourceId);
      if (entry.roles === 0) {
        this.deleteEntry(entry);
        this.onWaypointRemoved.notify(this, waypoint);
      }
    }
    deleteEntry(entry) {
      this.registered.delete(entry.waypoint.uid);
      this.toCleanUp.add(entry);
    }
    update(mapProjection) {
      var _a;
      this.toCleanUp.forEach((entry) => {
        entry.destroy();
      });
      this.toCleanUp.clear();
      const entriesToDrawIcon = [];
      this.registered.forEach((entry) => {
        entry.update();
        if (entry.icon) {
          entriesToDrawIcon.push(entry);
        }
      });
      const projectedSize = mapProjection.getProjectedSize();
      for (const roleDef of this.roleDefinitions.values()) {
        const context = roleDef.canvasContext;
        if (context) {
          context.clearRect(0, 0, projectedSize[0], projectedSize[1]);
        }
      }
      entriesToDrawIcon.sort(MapWaypointRenderer.ENTRY_SORT_FUNC);
      const len2 = entriesToDrawIcon.length;
      for (let i = 0; i < len2; i++) {
        const entry = entriesToDrawIcon[i];
        const icon = entry.icon;
        const context = (_a = this.roleDefinitions.get(entry.lastRenderedRole)) === null || _a === void 0 ? void 0 : _a.canvasContext;
        if (context) {
          icon.draw(context, mapProjection);
        }
      }
    }
    getNearestWaypoint(pos, first) {
      var _a, _b;
      const ordered = [...this.registered.values()].sort((a, b) => this.orderByDistance(a.waypoint, b.waypoint, pos)).filter((w) => {
        const roleDef = this.getRenderRoleDefinition(w.lastRenderedRole);
        if (roleDef !== void 0) {
          return roleDef.visibilityHandler(w.waypoint);
        }
        return false;
      });
      if (first !== void 0) {
        return (_a = ordered.find((entry) => first(entry.waypoint))) === null || _a === void 0 ? void 0 : _a.waypoint;
      }
      return (_b = ordered[0]) === null || _b === void 0 ? void 0 : _b.waypoint;
    }
    orderByDistance(a, b, pos) {
      const aDist = a.location.get().distance(pos);
      const bDist = b.location.get().distance(pos);
      return aDist - bDist;
    }
  };
  MapWaypointRenderer.NULL_ROLE_DEF = {
    iconFactory: null,
    labelFactory: null,
    canvasContext: null,
    visibilityHandler: () => true
  };
  MapWaypointRenderer.ENTRY_SORT_FUNC = (a, b) => {
    return a.icon.priority.get() - b.icon.priority.get();
  };
  MapWaypointRenderer.DEFAULT_RENDER_ROLE_SELECTOR = (entry, roleDefinitions) => {
    for (const role of roleDefinitions.keys()) {
      if (entry.isAllRoles(role) && roleDefinitions.get(role).visibilityHandler(entry.waypoint)) {
        return role;
      }
    }
    return 0;
  };
  var MapWaypointRendererEntry = class {
    constructor(waypoint, textManager, roleDefinitions, selectRoleToRender) {
      this.waypoint = waypoint;
      this.textManager = textManager;
      this.roleDefinitions = roleDefinitions;
      this.selectRoleToRender = selectRoleToRender;
      this.registrations = {};
      this._roles = 0;
      this._icon = null;
      this._label = null;
      this._lastRenderedRole = 0;
    }
    get roles() {
      return this._roles;
    }
    get lastRenderedRole() {
      return this._lastRenderedRole;
    }
    get icon() {
      return this._icon;
    }
    get label() {
      return this._label;
    }
    isAnyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAny(toCompare, roles);
    }
    isOnlyRole(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return toCompare === roles;
    }
    isAllRoles(roles, useLastRendered = false) {
      let toCompare;
      if (useLastRendered) {
        toCompare = this.lastRenderedRole;
      } else {
        toCompare = this.roles;
      }
      return BitFlags.isAll(toCompare, roles);
    }
    addRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        var _a;
        var _b, _c;
        ((_a = (_b = this.registrations)[_c = 1 << index]) !== null && _a !== void 0 ? _a : _b[_c] = /* @__PURE__ */ new Set()).add(sourceId);
      }, true);
      this._roles = this._roles | roles;
    }
    removeRole(roles, sourceId) {
      BitFlags.forEach(roles, (value, index) => {
        const role = 1 << index;
        const registrations = this.registrations[role];
        if (registrations) {
          registrations.delete(sourceId);
          if (registrations.size === 0) {
            this._roles = this._roles & ~role;
          }
        }
      }, true);
    }
    prepareRender(showRole, iconFactory, labelFactory) {
      var _a, _b;
      if (showRole === this._lastRenderedRole) {
        return;
      }
      this._icon = (_a = iconFactory === null || iconFactory === void 0 ? void 0 : iconFactory.getIcon(showRole, this.waypoint)) !== null && _a !== void 0 ? _a : null;
      const label = (_b = labelFactory === null || labelFactory === void 0 ? void 0 : labelFactory.getLabel(showRole, this.waypoint)) !== null && _b !== void 0 ? _b : null;
      if (this._label && this._label !== label) {
        this.textManager.deregister(this._label);
      }
      if (label && label !== this._label) {
        this.textManager.register(label);
      }
      this._label = label;
      this._lastRenderedRole = showRole;
    }
    update() {
      var _a, _b;
      const showRole = this.selectRoleToRender(this, this.roleDefinitions);
      const roleDef = this.roleDefinitions.get(showRole);
      const iconFactory = (_a = roleDef === null || roleDef === void 0 ? void 0 : roleDef.iconFactory) !== null && _a !== void 0 ? _a : null;
      const labelFactory = (_b = roleDef === null || roleDef === void 0 ? void 0 : roleDef.labelFactory) !== null && _b !== void 0 ? _b : null;
      this.prepareRender(showRole, iconFactory, labelFactory);
    }
    destroy() {
      if (this._label) {
        this.textManager.deregister(this._label);
      }
    }
  };
  var NullPathStream = class {
    beginPath() {
    }
    moveTo() {
    }
    lineTo() {
    }
    bezierCurveTo() {
    }
    quadraticCurveTo() {
    }
    arc() {
    }
    closePath() {
    }
  };
  NullPathStream.INSTANCE = new NullPathStream();
  var AbstractTransformingPathStream = class {
    constructor(consumer) {
      this.consumer = consumer;
    }
    getConsumer() {
      return this.consumer;
    }
    setConsumer(consumer) {
      this.consumer = consumer;
    }
  };
  var Outcode;
  (function(Outcode2) {
    Outcode2[Outcode2["Inside"] = 0] = "Inside";
    Outcode2[Outcode2["Left"] = 1] = "Left";
    Outcode2[Outcode2["Top"] = 2] = "Top";
    Outcode2[Outcode2["Right"] = 4] = "Right";
    Outcode2[Outcode2["Bottom"] = 8] = "Bottom";
  })(Outcode || (Outcode = {}));
  var ClippedPathStream = class extends AbstractTransformingPathStream {
    constructor(consumer, bounds) {
      super(consumer);
      this.bounds = bounds;
      this.boundsHandler = this.onBoundsChanged.bind(this);
      this.boundsLines = [
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3),
        new Float64Array(3)
      ];
      this.isBoundingRectNonZero = false;
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.prevPointOutcode = 0;
      bounds.sub(this.boundsHandler, true);
    }
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    moveTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
      if (this.prevPointOutcode === 0) {
        this.consumer.moveTo(x, y);
      }
    }
    lineTo(x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      const outcode = this.getOutcode(x, y);
      if ((this.prevPointOutcode | outcode) === 0) {
        this.consumer.lineTo(x, y);
      } else if ((this.prevPointOutcode & outcode) === 0) {
        const bounds = this.bounds.get();
        const line = ClippedPathStream.getLineCoordinates(this.prevPoint[0], this.prevPoint[1], x, y, ClippedPathStream.vec3Cache[1]);
        let entryPoint, exitPoint;
        const outcodeOr = this.prevPointOutcode | outcode;
        if ((outcodeOr & ~(Outcode.Left | Outcode.Right)) === 0 || (outcodeOr & ~(Outcode.Top | Outcode.Bottom)) === 0) {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              entryPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              break;
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              exitPoint = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              break;
            }
          }
        } else {
          for (let i = 0; i < 4; i++) {
            if (this.prevPointOutcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[0]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                entryPoint = intersection;
                break;
              }
            }
          }
          for (let i = 0; i < 4; i++) {
            if (outcode & 1 << i) {
              const boundsAxisIndex = i % 2;
              const intersection = ClippedPathStream.findLineLineIntersection(line, this.boundsLines[i], ClippedPathStream.vec2Cache[1]);
              if (intersection && intersection[boundsAxisIndex] >= bounds[boundsAxisIndex] && intersection[boundsAxisIndex] <= bounds[boundsAxisIndex + 2]) {
                exitPoint = intersection;
                break;
              }
            }
          }
        }
        if (entryPoint) {
          this.consumer.moveTo(entryPoint[0], entryPoint[1]);
        }
        if (exitPoint) {
          this.consumer.lineTo(exitPoint[0], exitPoint[1]);
        } else if (outcode === Outcode.Inside) {
          this.consumer.lineTo(x, y);
        }
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = outcode;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.prevPointOutcode !== Outcode.Inside) {
        this.consumer.moveTo(this.prevPoint[0], this.prevPoint[1]);
      }
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
      Vec2Math.set(x, y, this.prevPoint);
      this.prevPointOutcode = this.getOutcode(x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise = false) {
      if (!this.isBoundingRectNonZero) {
        return;
      }
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const pi2 = 2 * Math.PI;
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(pi2, (endAngle - startAngle) * directionSign);
      const bounds = this.bounds.get();
      const radiusSq = radius * radius;
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[2]), Vec2Math.setFromPolar(radius, startAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[2]);
      const startPointOutcode = this.getOutcode(startPoint[0], startPoint[1]);
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, ClippedPathStream.vec2Cache[3]), Vec2Math.setFromPolar(radius, endAngle, ClippedPathStream.vec2Cache[0]), ClippedPathStream.vec2Cache[3]);
      const endPointOutcode = this.getOutcode(endPoint[0], endPoint[1]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const intersections = ClippedPathStream.intersectionCache;
      let intersectionCount = 0;
      for (let i = 0; i < 4; i++) {
        const axisCoordIndex = i % 2;
        const crossAxisCoordIndex = (i + 1) % 2;
        const centerAxisCoord = i % 2 === 0 ? x : y;
        const centerCrossAxisCoord = i % 2 === 0 ? y : x;
        const deltaToBound = bounds[i] - centerAxisCoord;
        if (Math.abs(deltaToBound) < radius) {
          const crossAxisBoundMin = bounds[crossAxisCoordIndex];
          const crossAxisBoundMax = bounds[crossAxisCoordIndex + 2];
          const crossAxisOffset = Math.sqrt(radiusSq - deltaToBound * deltaToBound);
          let intersectionRadialOffset;
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord + crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 + (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
          {
            const intersectionCrossAxisCoord = centerCrossAxisCoord - crossAxisOffset;
            if (intersectionCrossAxisCoord >= crossAxisBoundMin && intersectionCrossAxisCoord <= crossAxisBoundMax) {
              const intersection = intersections[intersectionCount];
              intersection.point[axisCoordIndex] = bounds[i];
              intersection.point[crossAxisCoordIndex] = intersectionCrossAxisCoord;
              const radial = axisCoordIndex * Math.PI / 2 - (intersectionRadialOffset !== null && intersectionRadialOffset !== void 0 ? intersectionRadialOffset : intersectionRadialOffset = Math.acos(deltaToBound / radius)) * (axisCoordIndex === 0 ? 1 : -1);
              intersection.radial = (radial + pi2) % pi2;
              intersectionCount++;
            }
          }
        }
      }
      let isOutside = startPointOutcode !== Outcode.Inside;
      const startAngleNormalized = (startAngle % pi2 + pi2) % pi2;
      let lastRadial = startAngleNormalized;
      let intersectionStartIndex = -1;
      let minAngularDiff = Infinity;
      for (let i = 0; i < intersectionCount; i++) {
        const angularDiff = ((intersections[i].radial - startAngleNormalized) * directionSign + pi2) % pi2;
        if (angularDiff < minAngularDiff) {
          intersectionStartIndex = i;
          minAngularDiff = angularDiff;
        }
      }
      if (intersectionStartIndex >= 0) {
        for (let i = 0; i < intersectionCount; i++) {
          const index = (intersectionStartIndex + intersectionCount + i * directionSign) % intersectionCount;
          const intersection = intersections[index];
          if (((intersection.radial - startAngleNormalized) * directionSign + pi2) % pi2 >= angularWidth) {
            break;
          }
          if (isOutside) {
            this.consumer.moveTo(intersection.point[0], intersection.point[1]);
          } else {
            const segmentAngularWidth = ((intersection.radial - lastRadial) * directionSign + pi2) % pi2;
            this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
          }
          isOutside = !isOutside;
          lastRadial = intersection.radial;
        }
      }
      const endAngleNormalized = (startAngleNormalized + angularWidth * directionSign + pi2) % pi2;
      if (!isOutside) {
        const segmentAngularWidth = ((endAngleNormalized - lastRadial) * directionSign + pi2) % pi2;
        this.consumer.arc(x, y, radius, lastRadial, lastRadial + segmentAngularWidth * directionSign, counterClockwise);
        if (Math.abs((endAngleNormalized - endAngle) % pi2) > 1e-14) {
          this.consumer.moveTo(endPoint[0], endPoint[1]);
        }
      }
      Vec2Math.copy(endPoint, this.prevPoint);
      this.prevPointOutcode = endPointOutcode;
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.prevPointOutcode = 0;
    }
    getOutcode(x, y) {
      const bounds = this.bounds.get();
      let code = 0;
      if (x < bounds[0]) {
        code |= Outcode.Left;
      } else if (x > bounds[2]) {
        code |= Outcode.Right;
      }
      if (y < bounds[1]) {
        code |= Outcode.Top;
      } else if (y > bounds[3]) {
        code |= Outcode.Bottom;
      }
      return code;
    }
    onBoundsChanged() {
      const bounds = this.bounds.get();
      Vec3Math.set(1, 0, -bounds[0], this.boundsLines[0]);
      Vec3Math.set(0, 1, -bounds[1], this.boundsLines[1]);
      Vec3Math.set(1, 0, -bounds[2], this.boundsLines[2]);
      Vec3Math.set(0, 1, -bounds[3], this.boundsLines[3]);
      this.isBoundingRectNonZero = bounds[0] < bounds[2] && bounds[1] < bounds[3];
      this.beginPath();
    }
    destroy() {
      this.bounds.unsub(this.boundsHandler);
    }
    static getLineCoordinates(x1, y1, x2, y2, out) {
      const a = y1 - y2;
      const b = x2 - x1;
      const c = -(a * x1 + b * y1);
      return Vec3Math.set(a, b, c, out);
    }
    static findLineLineIntersection(line1, line2, out) {
      const cross2 = Vec3Math.cross(line1, line2, ClippedPathStream.vec3Cache[0]);
      const w = cross2[2];
      if (w === 0) {
        return void 0;
      }
      return Vec2Math.set(cross2[0] / w, cross2[1] / w, out);
    }
  };
  ClippedPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  ClippedPathStream.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  ClippedPathStream.intersectionCache = Array.from({ length: 8 }, () => {
    return { point: new Float64Array(2), radial: 0 };
  });
  var GeoProjectionPathStream = class extends AbstractTransformingPathStream {
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.projection = projection;
      this.firstPoint = new GeoPoint(NaN, NaN);
      this.prevPoint = new GeoPoint(NaN, NaN);
      this.prevPointProjected = new Float64Array(2);
      this.resampleHandler = this.onResampled.bind(this);
      if (arg1 instanceof GeoCircleResampler) {
        this.resampler = arg1;
      } else {
        this.resampler = new GeoCircleResampler(arg1, arg2, arg3);
      }
    }
    getProjection() {
      return this.projection;
    }
    setProjection(projection) {
      this.projection = projection;
    }
    beginPath() {
      this.reset();
      this.consumer.beginPath();
    }
    moveTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (isNaN(this.firstPoint.lat)) {
        this.firstPoint.set(lat, lon);
      }
      this.prevPoint.set(lat, lon);
      const projected = this.projection.project(this.prevPoint, this.prevPointProjected);
      this.consumer.moveTo(projected[0], projected[1]);
    }
    lineTo(lon, lat) {
      if (!(isFinite(lon) && isFinite(lat))) {
        return;
      }
      if (!isNaN(this.prevPoint.lat) && this.prevPoint.equals(lat, lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(lon, lat);
        return;
      }
      const point = GeoProjectionPathStream.geoPointCache[0].set(lat, lon);
      const circle = GeoProjectionPathStream.geoCircleCache[0].setAsGreatCircle(this.prevPoint, point);
      if (!isFinite(circle.center[0])) {
        throw new Error(`Cannot unambiguously path a great circle from ${this.prevPoint.lat} lat, ${this.prevPoint.lon} lon to ${lat} lat, ${lon} lon`);
      }
      this.resampler.resample(this.projection, circle, this.prevPoint, point, this.resampleHandler);
      this.prevPoint.set(lat, lon);
    }
    bezierCurveTo() {
      throw new Error("GeodesicResamplerStream: bezierCurveTo() is not supported");
    }
    quadraticCurveTo() {
      throw new Error("GeodesicResamplerStream: quadraticCurveTo() is not supported");
    }
    arc(lon, lat, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(lon) && isFinite(lat) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || Math.abs(startAngle - endAngle) <= GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        return;
      }
      if (MathUtils2.diffAngle(startAngle * Avionics.Utils.DEG2RAD, endAngle * Avionics.Utils.DEG2RAD, false) <= GeoCircle.ANGULAR_TOLERANCE) {
        const midAngle = startAngle + 180 * Math.sign(endAngle - startAngle);
        this.arc(lon, lat, radius, startAngle, midAngle, counterClockwise);
        this.arc(lon, lat, radius, midAngle, endAngle, counterClockwise);
        return;
      }
      const center = GeoProjectionPathStream.geoPointCache[1].set(lat, lon);
      const start = GeoProjectionPathStream.geoPointCache[2];
      const end = GeoProjectionPathStream.geoPointCache[3];
      if (Math.abs(lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG) {
        const circleLat = Math.sign(lat) * (MathUtils2.HALF_PI - radius) * Avionics.Utils.RAD2DEG;
        start.set(circleLat, startAngle);
        end.set(circleLat, endAngle);
      } else {
        center.offset(startAngle, radius, start);
        center.offset(endAngle, radius, end);
      }
      if (isNaN(start.lat) || isNaN(start.lon) || isNaN(end.lat) || isNaN(end.lon)) {
        return;
      }
      if (isNaN(this.prevPoint.lat)) {
        this.moveTo(start.lon, start.lat);
      } else if (!start.equals(this.prevPoint)) {
        this.lineTo(start.lon, start.lat);
      }
      const circle = GeoProjectionPathStream.geoCircleCache[0].set(center, radius);
      if (!counterClockwise) {
        circle.reverse();
      }
      this.resampler.resample(this.projection, circle, start, end, this.resampleHandler);
      this.prevPoint.set(end);
    }
    closePath() {
      if (!isNaN(this.firstPoint.lat)) {
        this.lineTo(this.firstPoint.lon, this.firstPoint.lat);
      }
    }
    reset() {
      this.firstPoint.set(NaN, NaN);
      this.prevPoint.set(NaN, NaN);
    }
    onResampled(vector) {
      switch (vector.type) {
        case "start":
          return;
        case "line":
          this.consumer.lineTo(vector.projected[0], vector.projected[1]);
          break;
        case "arc":
          this.consumer.arc(vector.projectedArcCenter[0], vector.projectedArcCenter[1], vector.projectedArcRadius, vector.projectedArcStartAngle, vector.projectedArcEndAngle, vector.projectedArcStartAngle > vector.projectedArcEndAngle);
          break;
      }
      Vec2Math.copy(vector.projected, this.prevPointProjected);
    }
  };
  GeoProjectionPathStream.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoProjectionPathStream.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var AffineTransformPathStream = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.transform = new Transform2D();
      this.concatCache = [];
      this.scale = 1;
      this.rotation = 0;
    }
    addTranslation(x, y, order = "after") {
      const translation = AffineTransformPathStream.transformCache[0].toTranslation(x, y);
      if (order === "before") {
        this.concatCache[0] = translation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = translation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      return this;
    }
    addScale(factor, order = "after") {
      const scale = AffineTransformPathStream.transformCache[0].toScale(factor, factor);
      if (order === "before") {
        this.concatCache[0] = scale;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = scale;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    addRotation(angle, order = "after") {
      const rotation = AffineTransformPathStream.transformCache[0].toRotation(angle);
      if (order === "before") {
        this.concatCache[0] = rotation;
        this.concatCache[1] = this.transform;
      } else {
        this.concatCache[0] = this.transform;
        this.concatCache[1] = rotation;
      }
      Transform2D.concat(this.transform, this.concatCache);
      this.updateScaleRotation();
      return this;
    }
    resetTransform() {
      this.transform.toIdentity();
      this.updateScaleRotation();
      return this;
    }
    beginPath() {
      this.consumer.beginPath();
    }
    moveTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.moveTo(transformed[0], transformed[1]);
    }
    lineTo(x, y) {
      const transformed = this.applyTransform(x, y);
      this.consumer.lineTo(transformed[0], transformed[1]);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      const cp1Transformed = this.applyTransform(cp1x, cp1y);
      cp1x = cp1Transformed[0];
      cp1y = cp1Transformed[1];
      const cp2Transformed = this.applyTransform(cp2x, cp2y);
      cp2x = cp2Transformed[0];
      cp2y = cp2Transformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      const cpTransformed = this.applyTransform(cpx, cpy);
      cpx = cpTransformed[0];
      cpy = cpTransformed[1];
      const endTransformed = this.applyTransform(x, y);
      x = endTransformed[0];
      y = endTransformed[1];
      this.consumer.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      const transformed = this.applyTransform(x, y);
      this.consumer.arc(transformed[0], transformed[1], radius * this.scale, startAngle + this.rotation, endAngle + this.rotation, counterClockwise);
    }
    closePath() {
      this.consumer.closePath();
    }
    updateScaleRotation() {
      const params = this.transform.getParameters();
      this.scale = Math.sqrt(params[0] * params[0] + params[3] * params[3]);
      this.rotation = Math.atan2(params[3], params[0]);
    }
    applyTransform(x, y) {
      const vec = Vec2Math.set(x, y, AffineTransformPathStream.vec2Cache[0]);
      return this.transform.apply(vec, vec);
    }
  };
  AffineTransformPathStream.vec2Cache = [new Float64Array(2)];
  AffineTransformPathStream.transformCache = [new Transform2D()];
  var PatternPathStream = class {
    constructor(consumer, pattern) {
      this.pattern = pattern;
      this.clipBounds = VecNSubject.createFromVector(new Float64Array([Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER]));
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.distanceLeft = NaN;
      this.transformStream = new AffineTransformPathStream(consumer);
      this.clipStream = new ClippedPathStream(this.transformStream, this.clipBounds);
    }
    getPattern() {
      return this.pattern;
    }
    setPattern(pattern) {
      if (!isNaN(this.distanceLeft) && this.pattern) {
        this.distanceLeft = Math.max(0, this.distanceLeft - this.pattern.anchor * this.pattern.length);
      }
      this.pattern = pattern;
      if (pattern) {
        if (!isNaN(this.distanceLeft)) {
          this.distanceLeft += pattern.anchor * pattern.length;
        }
      } else {
        this.distanceLeft = NaN;
      }
    }
    getConsumer() {
      return this.transformStream.getConsumer();
    }
    setConsumer(consumer) {
      this.transformStream.setConsumer(consumer);
    }
    beginPath() {
      this.reset();
      this.getConsumer().beginPath();
    }
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      Vec2Math.set(x, y, this.prevPoint);
      this.distanceLeft = NaN;
    }
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (this.prevPoint[0] === x && this.prevPoint[1] === y) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      if (this.pattern) {
        const x0 = this.prevPoint[0];
        const y0 = this.prevPoint[1];
        const dx = x - x0;
        const dy = y - y0;
        const distance = Math.hypot(dx, dy);
        const angle = Math.atan2(dy, dx);
        this.transformStream.resetTransform().addRotation(angle).addTranslation(x0, y0);
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            this.transformStream.addTranslation(distanceToNextAnchor, 0, "before");
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            this.transformStream.addTranslation(distanceToPatternEnd, 0, "before");
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().lineTo(x, y);
      }
      Vec2Math.set(x, y, this.prevPoint);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this.moveTo(x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      if (radius === 0 || startAngle === endAngle) {
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, PatternPathStream.vec2Cache[1]), PatternPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      if (this.pattern) {
        const pi2 = 2 * Math.PI;
        const directionSign = counterClockwise ? -1 : 1;
        if (Math.sign(endAngle - startAngle) !== directionSign) {
          const angleDiff = ((counterClockwise ? startAngle - endAngle : endAngle - startAngle) % pi2 + pi2) % pi2;
          endAngle = startAngle + angleDiff * directionSign;
        }
        const angularWidth = (endAngle - startAngle) * directionSign;
        const distance = angularWidth * radius;
        let nextLength = this.pattern.length;
        if (nextLength > 0) {
          let nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
          let distanceToNextAnchor = isNaN(this.distanceLeft) ? nextLength * nextAnchor : this.distanceLeft;
          let angle = startAngle;
          this.distanceLeft = distance;
          while (this.distanceLeft >= 0 && distanceToNextAnchor <= this.distanceLeft && this.distanceLeft >= nextLength * 0.5) {
            this.distanceLeft -= distanceToNextAnchor;
            angle += distanceToNextAnchor / radius * directionSign;
            this.transformStream.resetTransform().addRotation(Math.PI / 2 * directionSign).addTranslation(radius, 0).addRotation(angle).addTranslation(x, y);
            this.clipBounds.set(-nextLength * nextAnchor, Number.MIN_SAFE_INTEGER, nextLength * (1 - nextAnchor), Number.MAX_SAFE_INTEGER);
            this.clipStream.beginPath();
            this.pattern.draw(this.clipStream);
            const distanceToPatternEnd = nextLength * (1 - nextAnchor);
            this.distanceLeft -= distanceToPatternEnd;
            angle += distanceToPatternEnd / radius * directionSign;
            nextLength = this.pattern.length;
            if (nextLength <= 0) {
              this.distanceLeft = NaN;
              break;
            }
            nextAnchor = Utils.Clamp(this.pattern.anchor, 0, 1);
            distanceToNextAnchor = nextLength * nextAnchor;
          }
          if (!isNaN(this.distanceLeft)) {
            this.distanceLeft = Math.max(0, distanceToNextAnchor - this.distanceLeft);
          }
        }
      } else {
        this.getConsumer().arc(x, y, radius, startAngle, endAngle, counterClockwise);
      }
      Vec2Math.add(Vec2Math.set(x, y, PatternPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, endAngle, PatternPathStream.vec2Cache[1]), this.prevPoint);
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.distanceLeft = NaN;
    }
  };
  PatternPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var TransformingPathStreamStack = class extends AbstractTransformingPathStream {
    constructor() {
      super(...arguments);
      this.stack = [];
    }
    push(stream) {
      var _a;
      stream.setConsumer((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer);
      this.stack.push(stream);
    }
    pop() {
      const removed = this.stack.pop();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      return removed;
    }
    unshift(stream) {
      const displaced = this.stack[0];
      displaced === null || displaced === void 0 ? void 0 : displaced.setConsumer(stream);
      stream.setConsumer(this.consumer);
      this.stack.unshift(stream);
    }
    shift() {
      var _a;
      const removed = this.stack.shift();
      removed === null || removed === void 0 ? void 0 : removed.setConsumer(NullPathStream.INSTANCE);
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(this.consumer);
      return removed;
    }
    setConsumer(consumer) {
      var _a;
      (_a = this.stack[0]) === null || _a === void 0 ? void 0 : _a.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    beginPath() {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).beginPath();
    }
    moveTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).moveTo(x, y);
    }
    lineTo(x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).lineTo(x, y);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      var _a;
      ((_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : this.consumer).arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    closePath() {
      this.stack[this.stack.length - 1].closePath();
    }
  };
  var GeoProjectionPathStreamStack = class extends AbstractTransformingPathStream {
    constructor(consumer, projection, arg1, arg2, arg3) {
      super(consumer);
      this.postStack = new TransformingPathStreamStack(consumer);
      if (arg1 instanceof GeoCircleResampler) {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1);
      } else {
        this.projectionStream = new GeoProjectionPathStream(this.postStack, projection, arg1, arg2, arg3);
      }
      this.preStack = new TransformingPathStreamStack(this.projectionStream);
    }
    getProjection() {
      return this.projectionStream.getProjection();
    }
    setProjection(projection) {
      this.projectionStream.setProjection(projection);
    }
    pushPreProjected(stream) {
      this.preStack.push(stream);
    }
    popPreProjected() {
      return this.preStack.pop();
    }
    unshiftPreProjected(stream) {
      this.preStack.unshift(stream);
    }
    shiftPreProjected() {
      return this.preStack.shift();
    }
    pushPostProjected(stream) {
      this.postStack.push(stream);
    }
    popPostProjected() {
      return this.postStack.pop();
    }
    unshiftPostProjected(stream) {
      this.postStack.unshift(stream);
    }
    shiftPostProjected() {
      return this.postStack.shift();
    }
    setConsumer(consumer) {
      this.postStack.setConsumer(consumer);
      super.setConsumer(consumer);
    }
    beginPath() {
      this.preStack.beginPath();
    }
    moveTo(x, y) {
      this.preStack.moveTo(x, y);
    }
    lineTo(x, y) {
      this.preStack.lineTo(x, y);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this.preStack.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      this.preStack.quadraticCurveTo(cpx, cpy, x, y);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      this.preStack.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    closePath() {
      this.preStack.closePath();
    }
  };
  var GeoCirclePathRenderer = class {
    render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath = false) {
      if (!continuePath) {
        streamStack.beginPath();
        streamStack.moveTo(startLon, startLat);
      }
      if (circle.isGreatCircle()) {
        const startPoint = GeoPoint.sphericalToCartesian(startLat, startLon, GeoCirclePathRenderer.vec3Cache[0]);
        const distance = circle.distanceAlong(startPoint, GeoCirclePathRenderer.geoPointCache[0].set(endLat, endLon), Math.PI);
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
          const midPoint = circle.offsetDistanceAlong(startPoint, distance / 2, GeoCirclePathRenderer.geoPointCache[0], Math.PI);
          const midLat = midPoint.lat;
          const midLon = midPoint.lon;
          streamStack.lineTo(midLon, midLat);
          streamStack.lineTo(endLon, endLat);
        } else {
          streamStack.lineTo(endLon, endLat);
        }
      } else {
        const turnCenter = FlightPathUtils.getTurnCenterFromCircle(circle, GeoCirclePathRenderer.geoPointCache[0]);
        const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        const isCenterPole = Math.abs(turnCenter.lat) >= 90 - GeoCircle.ANGULAR_TOLERANCE * Avionics.Utils.RAD2DEG;
        let startAngle, endAngle;
        if (isCenterPole) {
          startAngle = startLon;
          endAngle = endLon;
        } else {
          startAngle = turnCenter.bearingTo(startLat, startLon);
          endAngle = turnCenter.bearingTo(endLat, endLon);
        }
        streamStack.arc(turnCenter.lon, turnCenter.lat, FlightPathUtils.getTurnRadiusFromCircle(circle), startAngle, endAngle, turnDirection === "left");
      }
    }
  };
  GeoCirclePathRenderer.NORTH_POLE_VEC = new Float64Array([0, 0, 1]);
  GeoCirclePathRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  GeoCirclePathRenderer.vec3Cache = [new Float64Array(3)];
  var GeoCircleLineRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
    }
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, width, style, dash, outlineWidth = 0, outlineStyle = "black") {
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack);
      if (outlineWidth > 0) {
        context.lineWidth = width + outlineWidth * 2;
        context.strokeStyle = outlineStyle;
        context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash !== null && dash !== void 0 ? dash : GeoCircleLineRenderer.EMPTY_DASH);
      context.stroke();
    }
  };
  GeoCircleLineRenderer.EMPTY_DASH = [];
  var GeoCirclePatternRenderer = class {
    constructor() {
      this.pathRenderer = new GeoCirclePathRenderer();
      this.patternStream = new PatternPathStream(NullPathStream.INSTANCE, null);
    }
    render(circle, startLat, startLon, endLat, endLon, context, streamStack, pattern, continuePath = false) {
      this.patternStream.setPattern(pattern);
      streamStack.unshiftPostProjected(this.patternStream);
      this.pathRenderer.render(circle, startLat, startLon, endLat, endLon, streamStack, continuePath);
      streamStack.shiftPostProjected();
    }
  };
  var AbstractFlightPathPlanRenderer = class {
    constructor(renderOrder = "forward", renderActiveLegLast = true) {
      this.renderOrder = renderOrder;
      this.renderActiveLegLast = renderActiveLegLast;
    }
    render(plan, startIndex, endIndex, context, streamStack, ...args) {
      startIndex !== null && startIndex !== void 0 ? startIndex : startIndex = 0;
      endIndex !== null && endIndex !== void 0 ? endIndex : endIndex = plan.length - 1;
      const activeLegIndex = plan.activeLateralLeg < plan.length ? plan.activeLateralLeg : -1;
      const activeLeg = plan.activeLateralLeg < plan.length ? plan.getLeg(plan.activeLateralLeg) : void 0;
      const isReverse = this.renderOrder === "reverse";
      if (isReverse) {
        const oldEndIndex = endIndex;
        endIndex = startIndex;
        startIndex = oldEndIndex;
      }
      let index = startIndex;
      const delta = isReverse ? -1 : 1;
      for (const leg of plan.legs(isReverse, startIndex)) {
        if ((index - endIndex) * delta > 0) {
          break;
        }
        if (this.renderActiveLegLast && index === activeLegIndex) {
          index += delta;
          continue;
        }
        this.renderLeg(leg, plan, activeLeg, index, activeLegIndex, context, streamStack, ...args);
        index += delta;
      }
      if (this.renderActiveLegLast && activeLeg) {
        this.renderLeg(activeLeg, plan, activeLeg, activeLegIndex, activeLegIndex, context, streamStack, ...args);
      }
    }
  };
  var FlightPathLegRenderPart;
  (function(FlightPathLegRenderPart2) {
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["None"] = 0] = "None";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Ingress"] = 1] = "Ingress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Base"] = 2] = "Base";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["Egress"] = 4] = "Egress";
    FlightPathLegRenderPart2[FlightPathLegRenderPart2["All"] = 7] = "All";
  })(FlightPathLegRenderPart || (FlightPathLegRenderPart = {}));
  var AbstractFlightPathLegRenderer = class {
    constructor() {
      this.tempVector = FlightPathUtils.createEmptyCircleVector();
    }
    render(leg, context, streamStack, partsToRender, ...args) {
      const legCalc = leg.calculated;
      if (!legCalc || !BitFlags.isAny(partsToRender, FlightPathLegRenderPart.Ingress | FlightPathLegRenderPart.Base | FlightPathLegRenderPart.Egress)) {
        return;
      }
      const excludeIngress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Ingress);
      const excludeBase = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Base);
      const excludeEgress = !BitFlags.isAll(partsToRender, FlightPathLegRenderPart.Egress);
      let mainVectors = legCalc.ingressToEgress;
      let mainVectorStartIndex = 0;
      let mainVectorEndIndex = legCalc.ingressToEgress.length;
      if (excludeIngress || excludeEgress) {
        mainVectors = legCalc.flightPath;
        mainVectorEndIndex = excludeEgress || legCalc.egressJoinIndex < 0 || legCalc.egress.length === 0 ? legCalc.flightPath.length : legCalc.egressJoinIndex;
      }
      if (!excludeIngress) {
        for (let i = 0; i < legCalc.ingress.length; i++) {
          this.renderVector(legCalc.ingress[i], true, false, leg, context, streamStack, ...args);
        }
        if (excludeEgress && !excludeBase) {
          mainVectorStartIndex = Math.max(0, legCalc.ingressJoinIndex);
          const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
          const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
          if (lastIngressVector && ingressJoinVector) {
            const ingressEnd = AbstractFlightPathLegRenderer.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const vectorEnd = AbstractFlightPathLegRenderer.geoPointCache[1].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            if (!ingressEnd.equals(vectorEnd)) {
              const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, ingressJoinVectorCircle, ingressEnd, vectorEnd, ingressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
            mainVectorStartIndex++;
          }
        }
      }
      if (!excludeBase) {
        const len = Math.min(mainVectorEndIndex, mainVectors.length);
        for (let i = mainVectorStartIndex; i < len; i++) {
          this.renderVector(mainVectors[i], false, false, leg, context, streamStack, ...args);
        }
      }
      if (!excludeEgress) {
        if (excludeIngress && !excludeBase) {
          const firstEgressVector = legCalc.egress[0];
          const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
          if (firstEgressVector && egressJoinVector) {
            const egressStart = AbstractFlightPathLegRenderer.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
            const egressJoinVectorStart = AbstractFlightPathLegRenderer.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
            if (!egressStart.equals(egressJoinVectorStart)) {
              const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, AbstractFlightPathLegRenderer.geoCircleCache[0]);
              FlightPathUtils.setCircleVector(this.tempVector, egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
              this.renderVector(this.tempVector, false, false, leg, context, streamStack, ...args);
            }
          }
        }
        for (let i = 0; i < legCalc.egress.length; i++) {
          this.renderVector(legCalc.egress[i], false, true, leg, context, streamStack, ...args);
        }
      }
    }
  };
  AbstractFlightPathLegRenderer.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  AbstractFlightPathLegRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathLegLineRenderer = class extends AbstractFlightPathLegRenderer {
    constructor(styleSelector) {
      super();
      this.styleSelector = styleSelector;
      this.pathRenderer = new GeoCirclePathRenderer();
      this.styleBuffer = [
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        },
        {
          strokeWidth: 1,
          strokeStyle: "white",
          strokeDash: null,
          outlineWidth: 0,
          outlineStyle: "black",
          outlineDash: null,
          isContinuous: false
        }
      ];
      this.activeStyleIndex = 0;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = false;
    }
    render(leg, context, streamStack, partsToRender, ...args) {
      this.isAtLegStart = true;
      this.needStrokeLineAtLegEnd = false;
      super.render(leg, context, streamStack, partsToRender, ...args);
      if (this.needStrokeLineAtLegEnd) {
        this.strokeLine(context, this.styleBuffer[(this.activeStyleIndex + 1) % 2]);
        this.needStrokeLineAtLegEnd = false;
      }
    }
    renderVector(vector, isIngress, isEgress, leg, context, streamStack, ...args) {
      const style = this.styleSelector(vector, isIngress, isEgress, leg, streamStack.getProjection(), this.styleBuffer[this.activeStyleIndex], ...args);
      const previousStyle = this.styleBuffer[(this.activeStyleIndex + 1) % 2];
      const didStyleChange = !this.isAtLegStart && !FlightPathLegLineRenderer.areStylesEqual(style, previousStyle);
      const continuePath = !this.isAtLegStart && style.isContinuous && !didStyleChange;
      if (didStyleChange) {
        this.strokeLine(context, previousStyle);
        this.needStrokeLineAtLegEnd = false;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathLegLineRenderer.geoCircleCache[1]);
      this.pathRenderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, streamStack, continuePath);
      this.activeStyleIndex = (this.activeStyleIndex + 1) % 2;
      this.isAtLegStart = false;
      this.needStrokeLineAtLegEnd = true;
    }
    strokeLine(context, style) {
      var _a, _b;
      if (style.outlineWidth > 0) {
        const outlineWidth = style.strokeWidth + 2 * style.outlineWidth;
        context.lineWidth = outlineWidth;
        context.strokeStyle = style.outlineStyle;
        context.setLineDash((_a = style.outlineDash) !== null && _a !== void 0 ? _a : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
      if (style.strokeWidth > 0) {
        context.lineWidth = style.strokeWidth;
        context.strokeStyle = style.strokeStyle;
        context.setLineDash((_b = style.strokeDash) !== null && _b !== void 0 ? _b : FlightPathLegLineRenderer.EMPTY_DASH);
        context.stroke();
      }
    }
    static areStylesEqual(style1, style2) {
      return (style1.strokeWidth === 0 && style2.strokeWidth === 0 || style1.strokeWidth === style2.strokeWidth && style1.strokeStyle === style2.strokeStyle && style1.strokeDash === style2.strokeDash) && (style1.outlineWidth === 0 && style2.outlineWidth === 0 || style1.outlineWidth === style2.outlineWidth && style1.outlineStyle === style2.outlineStyle && style1.outlineDash === style2.outlineDash);
    }
  };
  FlightPathLegLineRenderer.EMPTY_DASH = [];
  FlightPathLegLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorPatternRenderer = class {
    constructor() {
      this.renderer = new GeoCirclePatternRenderer();
    }
    render(vector, context, streamStack, pattern, continuePath = false) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorPatternRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, pattern, continuePath);
    }
  };
  FlightPathVectorPatternRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var FlightPathVectorLineRenderer = class {
    constructor() {
      this.renderer = new GeoCircleLineRenderer();
    }
    render(vector, context, streamStack, width, style, dash, outlineWidth, outlineStyle) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, FlightPathVectorLineRenderer.geoCircleCache[0]);
      this.renderer.render(circle, vector.startLat, vector.startLon, vector.endLat, vector.endLon, context, streamStack, width, style, dash, outlineWidth, outlineStyle);
    }
  };
  FlightPathVectorLineRenderer.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
  var MapAbstractAirspaceRenderer = class {
    render(airspace, projection, context, lod = 0, stream) {
      const shapes = airspace.lods[lod];
      const len = shapes.length;
      for (let i = 0; i < len; i++) {
        this.renderShape(shapes[i], projection, context, stream);
      }
    }
  };
  var MapSingleLineAirspaceRenderer = class extends MapAbstractAirspaceRenderer {
    constructor(lineWidth, strokeStyle, dash) {
      super();
      this.lineWidth = lineWidth;
      this.strokeStyle = strokeStyle;
      this.dash = dash;
    }
    renderShape(shape, projection, context, stream) {
      if (shape.length < 2) {
        return;
      }
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const firstProjected = projection.project(shape[0].end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.moveTo(firstProjected[0], firstProjected[1]);
      let start = shape[0].end;
      const len = shape.length;
      for (let i = 1; i < len; i++) {
        const vector = shape[i];
        const circle = vector.circle;
        if (circle) {
          if (circle.isGreatCircle()) {
            this.pathGreatCircle(circle, start, vector.end, projection, stream);
          } else {
            this.pathSmallCircle(circle, start, vector.end, projection, stream);
          }
        } else {
          const endProjected = projection.project(vector.end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
          stream.moveTo(endProjected[0], endProjected[1]);
        }
        start = vector.end;
      }
      context.lineWidth = this.lineWidth;
      context.strokeStyle = this.strokeStyle;
      context.setLineDash(this.dash);
      context.stroke();
    }
    pathGreatCircle(circle, start, end, projection, stream) {
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      stream.lineTo(endProjected[0], endProjected[1]);
    }
    pathSmallCircle(circle, start, end, projection, stream) {
      const center = MapSingleLineAirspaceRenderer.geoPointCache[0].setFromCartesian(circle.radius < Math.PI / 2 ? circle.center : Vec3Math.multScalar(circle.center, -1, MapSingleLineAirspaceRenderer.vec3Cache[0]));
      const centerProjected = projection.project(center, MapSingleLineAirspaceRenderer.vec2Cache[0]);
      const endProjected = projection.project(end, MapSingleLineAirspaceRenderer.vec2Cache[1]);
      if (start.equals(end)) {
        const radius = Vec2Math.distance(endProjected, centerProjected);
        const startAngle = Math.atan2(endProjected[1] - centerProjected[1], endProjected[0] - centerProjected[0]);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, startAngle + 2 * Math.PI);
        stream.moveTo(endProjected[0], endProjected[1]);
      } else {
        const startProjected = projection.project(start, MapSingleLineAirspaceRenderer.vec2Cache[2]);
        const startDelta = Vec2Math.sub(startProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[3]);
        const startDeltaMag = Vec2Math.abs(startDelta);
        const endDelta = Vec2Math.sub(endProjected, centerProjected, MapSingleLineAirspaceRenderer.vec2Cache[4]);
        const endDeltaMag = Vec2Math.abs(endDelta);
        const radius = (startDeltaMag + endDeltaMag) / 2;
        const startAngle = Vec2Math.theta(startDelta);
        const arcStartX = centerProjected[0] + radius / startDeltaMag * startDelta[0];
        const arcStartY = centerProjected[1] + radius / startDeltaMag * startDelta[1];
        const endAngle = Vec2Math.theta(endDelta);
        const arcEndX = centerProjected[0] + radius / endDeltaMag * endDelta[0];
        const arcEndY = centerProjected[1] + radius / endDeltaMag * endDelta[1];
        stream.lineTo(arcStartX, arcStartY);
        stream.arc(centerProjected[0], centerProjected[1], radius, startAngle, endAngle, circle.radius < Math.PI / 2);
        stream.lineTo(arcEndX, arcEndY);
      }
    }
  };
  MapSingleLineAirspaceRenderer.geoPointCache = [new GeoPoint(0, 0)];
  MapSingleLineAirspaceRenderer.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  MapSingleLineAirspaceRenderer.vec3Cache = [new Float64Array(3)];
  var Shape = class {
    constructor() {
      this.segments = [];
      this.length = 0;
      this.isClosed = false;
      this.windingOrder = 1;
    }
    build(shape, projection) {
      if (shape.length < 2) {
        return;
      }
      this.buildSegments(shape, projection);
      let signedArea = 0;
      let prev = this.segments[0];
      for (let i = 1; i < this.length; i++) {
        const segment = this.segments[i];
        signedArea += this.calculateSignedArea(segment, prev);
        prev = segment;
      }
      const first = this.segments[0].end;
      const last = this.segments[this.length - 1].end;
      this.isClosed = Vec2Math.equals(first, last);
      if (!this.isClosed) {
        signedArea += last[0] * first[1] - first[0] * last[1];
      }
      this.windingOrder = signedArea >= 0 ? 1 : -1;
      this.calculateVertices();
    }
    buildSegments(shape, projection) {
      this.buildStartSegment(projection, 0, shape[0]);
      let start = shape[0].end;
      this.length = shape.length;
      for (let i = 1; i < this.length; i++) {
        const vector = shape[i];
        this.buildSegment(projection, i, vector, start);
        start = vector.end;
      }
    }
    buildSegment(projection, index, vector, start) {
      const circle = vector.circle;
      if (circle) {
        if (circle.isGreatCircle()) {
          this.buildSegmentFromGreatCircle(projection, index, circle, start, vector.end);
        } else {
          this.buildSegmentFromSmallCircle(projection, index, circle, start, vector.end);
        }
      } else {
        this.buildStartSegment(projection, index, vector);
      }
    }
    buildStartSegment(projection, index, vector) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "start";
      projection.project(vector.end, segment.end);
    }
    buildSegmentFromGreatCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "line";
      projection.project(end, segment.end);
      const delta = Vec2Math.sub(segment.end, this.segments[index - 1].end, Shape.vec2Cache[0]);
      Vec2Math.normalize(Vec2Math.normal(delta, segment.endNormal), segment.endNormal);
    }
    buildSegmentFromSmallCircle(projection, index, circle, start, end) {
      var _a;
      var _b;
      const isClockwise = circle.radius > Math.PI / 2;
      const center = Shape.geoPointCache[0].setFromCartesian(isClockwise ? Vec3Math.multScalar(circle.center, -1, Shape.vec3Cache[0]) : circle.center);
      const startProjected = this.segments[index - 1].end;
      const centerProjected = projection.project(center, Shape.vec2Cache[0]);
      const endProjected = projection.project(end, Shape.vec2Cache[1]);
      const startRadial = Vec2Math.sub(startProjected, centerProjected, Shape.vec2Cache[2]);
      const startRadialMag = Vec2Math.abs(startRadial);
      const endRadial = Vec2Math.sub(endProjected, centerProjected, Shape.vec2Cache[3]);
      const endRadialMag = Vec2Math.abs(endRadial);
      const radius = (startRadialMag + endRadialMag) / 2;
      const segment = (_a = (_b = this.segments)[index]) !== null && _a !== void 0 ? _a : _b[index] = Shape.createSegment();
      segment.type = "arc";
      segment.radius = radius;
      segment.isClockwise = isClockwise;
      Vec2Math.copy(centerProjected, segment.center);
      Vec2Math.copy(endProjected, segment.end);
      Vec2Math.normalize(startRadial, segment.startNormal);
      Vec2Math.normalize(endRadial, segment.endNormal);
    }
    calculateSignedArea(segment, prevSegment) {
      if (segment.type === "start") {
        return 0;
      }
      if (segment.type === "line") {
        return prevSegment.end[0] * segment.end[1] - segment.end[0] * prevSegment.end[1];
      }
      const startRadial = Vec2Math.sub(prevSegment.end, segment.center, Shape.vec2Cache[0]);
      const startTheta = Vec2Math.theta(startRadial);
      const endRadial = Vec2Math.sub(segment.end, segment.center, Shape.vec2Cache[1]);
      const endTheta = Vec2Math.theta(endRadial);
      const angularWidth = Shape.getAngularWidth(startTheta, endTheta, segment.isClockwise, true);
      return prevSegment.end[0] * segment.center[1] - segment.center[0] * prevSegment.end[1] + segment.center[0] * segment.end[1] - segment.end[0] * segment.center[1] + angularWidth * segment.radius * segment.radius * (segment.isClockwise ? 1 : -1);
    }
    calculateVertices() {
      const max2 = this.isClosed ? this.length - 1 : this.length;
      for (let i = 0; i < this.length; i++) {
        const next = this.isClosed ? i % max2 + 1 : (i + 1) % max2;
        this.calculateVertex(i, next);
      }
    }
    calculateVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      if (curr.type === "start" && next.type === "start") {
        curr.vertex.type = "null";
        curr.vertex.fromIndex = currIndex;
        curr.vertex.toIndex = nextIndex;
      } else if (curr.type === "start" && next.type === "line") {
        this.calculateLineStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "line" && next.type === "start") {
        this.calculateLineStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "start" && next.type === "arc") {
        this.calculateArcStartVertex(currIndex, nextIndex, true);
      } else if (curr.type === "arc" && next.type === "start") {
        this.calculateArcStartVertex(currIndex, nextIndex, false);
      } else if (curr.type === "line" && next.type === "line") {
        this.calculateLineLineVertex(currIndex, nextIndex);
      } else if (curr.type === "line" && next.type === "arc") {
        this.calculateLineArcVertex(currIndex, nextIndex, false);
      } else if (curr.type === "arc" && next.type === "line") {
        this.calculateLineArcVertex(currIndex, nextIndex, true);
      } else {
        this.calculateArcArcVertex(currIndex, nextIndex);
      }
    }
    calculateLineStartVertex(currIndex, nextIndex, isStartFirst) {
      const line = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "line-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.multScalar(line.endNormal, this.windingOrder, vertex.normal);
    }
    calculateArcStartVertex(currIndex, nextIndex, isStartFirst) {
      const arc = this.segments[isStartFirst ? nextIndex : currIndex];
      const vertex = this.segments[currIndex].vertex;
      vertex.type = "arc-start";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const arcNormal = isStartFirst ? arc.startNormal : arc.endNormal;
      Vec2Math.multScalar(arcNormal, this.windingOrder * (arc.isClockwise ? 1 : -1), vertex.normal);
    }
    calculateLineLineVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "line-line";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      Vec2Math.normalize(Vec2Math.multScalar(Vec2Math.add(curr.endNormal, next.endNormal, vertex.normal), this.windingOrder, vertex.normal), vertex.normal);
      const deltaUnit = Vec2Math.normalize(Vec2Math.sub(next.end, curr.end, Shape.vec2Cache[0]), Shape.vec2Cache[0]);
      const scaleFactor = Math.abs(1 / (vertex.normal[0] * deltaUnit[1] - vertex.normal[1] * deltaUnit[0]));
      Vec2Math.multScalar(vertex.normal, scaleFactor, vertex.normal);
    }
    calculateLineArcVertex(currIndex, nextIndex, isArcFirst) {
      const curr = this.segments[currIndex];
      const line = this.segments[isArcFirst ? nextIndex : currIndex];
      const arc = this.segments[isArcFirst ? currIndex : nextIndex];
      const end = curr.end;
      const vertex = curr.vertex;
      vertex.type = "line-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      vertex.arcOffsetSign = this.windingOrder * (arc.isClockwise ? 1 : -1);
      const centerEndDelta = Vec2Math.sub(isArcFirst ? arc.end : line.end, arc.center, Shape.vec2Cache[0]);
      const dot2 = centerEndDelta[1] * line.endNormal[0] - centerEndDelta[0] * line.endNormal[1];
      const theta = Vec2Math.theta(line.endNormal) + (dot2 >= 0 ? Math.PI / 2 : -Math.PI / 2);
      Shape.transformCache[0].toTranslation(-arc.center[0], -arc.center[1]);
      const rotation = Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.r0 = arc.radius;
      vertex.y0 = vertex.transform.apply(end, Shape.vec2Cache[0])[1];
      vertex.lineOffsetSign = rotation.apply(line.endNormal, Shape.vec2Cache[0])[1] >= 0 ? this.windingOrder : -this.windingOrder;
      vertex.transform.invert();
    }
    calculateArcArcVertex(currIndex, nextIndex) {
      const curr = this.segments[currIndex];
      const next = this.segments[nextIndex];
      const vertex = curr.vertex;
      vertex.type = "arc-arc";
      vertex.fromIndex = currIndex;
      vertex.toIndex = nextIndex;
      const centerDelta = Vec2Math.sub(next.center, curr.center, Shape.vec2Cache[0]);
      const centerEndDelta = Vec2Math.sub(curr.end, curr.center, Shape.vec2Cache[1]);
      const dot2 = centerDelta[0] * centerEndDelta[1] - centerDelta[1] * centerEndDelta[0];
      const theta = Vec2Math.theta(centerDelta) + (dot2 >= 0 ? 0 : Math.PI);
      Shape.transformCache[0].toTranslation(-curr.center[0], -curr.center[1]);
      Shape.transformCache[1].toRotation(-theta);
      Transform2D.concat(vertex.transform, Shape.transformCache);
      vertex.d = vertex.transform.apply(next.center, Shape.vec2Cache[0])[0];
      vertex.arcOffsetSign = this.windingOrder * (curr.isClockwise ? 1 : -1);
      vertex.arc2OffsetSign = this.windingOrder * (next.isClockwise ? 1 : -1);
      vertex.transform.invert();
    }
    renderLine(context, offset, lineWidth, strokeStyle, dash, stream) {
      stream !== null && stream !== void 0 ? stream : stream = context;
      stream.beginPath();
      const startPoint = Vec2Math.set(0, 0, Shape.vec2Cache[0]);
      if (this.isClosed) {
        if (offset === 0) {
          Vec2Math.copy(this.segments[0].end, startPoint);
        } else {
          const lastIndex = this.length - 1;
          const result = this.calculateOffsetVertex(lastIndex, offset, startPoint);
          if (!result || Shape.isPointInSegmentBounds(this.segments[lastIndex], this.segments[lastIndex - 1].end, result)) {
            this.calculateOffsetEndPoint(lastIndex, offset, startPoint);
          }
        }
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      for (let i = this.isClosed ? 1 : 0; i < this.length; i++) {
        const segment = this.segments[i];
        let newStartPoint;
        switch (segment.type) {
          case "start":
            newStartPoint = this.pathStartSegment(stream, i, offset);
            break;
          case "line":
            newStartPoint = this.pathLineSegment(stream, i, startPoint, offset);
            break;
          case "arc":
            newStartPoint = this.pathArcSegment(stream, i, startPoint, offset);
            break;
        }
        Vec2Math.copy(newStartPoint, startPoint);
      }
      context.lineWidth = lineWidth;
      context.strokeStyle = strokeStyle;
      context.setLineDash(dash);
      context.stroke();
    }
    pathStartSegment(stream, index, offset) {
      const segment = this.segments[index];
      if (offset === 0) {
        stream.moveTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd) {
          stream.moveTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          stream.moveTo(segment.end[0], segment.end[1]);
          return segment.end;
        }
      }
    }
    pathLineSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
      }
      if (offset === 0) {
        stream.lineTo(segment.end[0], segment.end[1]);
        return segment.end;
      } else {
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          stream.lineTo(offsetEnd[0], offsetEnd[1]);
          return offsetEnd;
        } else {
          const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
          stream.lineTo(endPoint[0], endPoint[1]);
          const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
          stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
          return nextStartPoint;
        }
      }
    }
    pathArcSegment(stream, index, start, offset) {
      const segment = this.segments[index];
      let startAngle;
      if (offset !== 0 && !Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, start)) {
        const startPoint = this.calculateOffsetStartPoint(index, offset, Shape.vec2Cache[1]);
        stream.moveTo(startPoint[0], startPoint[1]);
        startAngle = Math.atan2(startPoint[1] - segment.center[1], startPoint[0] - segment.center[0]);
      } else {
        startAngle = Math.atan2(start[1] - segment.center[1], start[0] - segment.center[0]);
      }
      if (offset === 0) {
        const endAngle = Vec2Math.theta(segment.endNormal);
        const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
        stream.arc(segment.center[0], segment.center[1], segment.radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), !segment.isClockwise);
        return segment.end;
      } else {
        const baseEndAngle = Vec2Math.theta(segment.endNormal);
        const baseAngularWidth = Shape.getAngularWidth(startAngle, baseEndAngle, segment.isClockwise, true);
        const sign4 = this.windingOrder * (segment.isClockwise ? 1 : -1);
        const radius = segment.radius + offset * sign4;
        const offsetEnd = this.calculateOffsetVertex(index, offset, Shape.vec2Cache[1]);
        if (offsetEnd && Shape.isPointInSegmentBounds(segment, this.segments[index - 1].end, offsetEnd)) {
          const endAngle = Math.atan2(offsetEnd[1] - segment.center[1], offsetEnd[0] - segment.center[0]);
          const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
          const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
          stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
          return offsetEnd;
        } else {
          if (radius > 0) {
            const endPoint = this.calculateOffsetEndPoint(index, offset, Shape.vec2Cache[1]);
            const endAngle = Math.atan2(endPoint[1] - segment.center[1], endPoint[0] - segment.center[0]);
            const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
            const angularWidthDiff = Math.abs(angularWidth - baseAngularWidth);
            stream.arc(segment.center[0], segment.center[1], radius, startAngle, startAngle + angularWidth * (segment.isClockwise ? 1 : -1), angularWidthDiff < Math.PI ? !segment.isClockwise : segment.isClockwise);
            const nextStartPoint = this.calculateOffsetStartPoint(segment.vertex.toIndex, offset, Shape.vec2Cache[1]);
            stream.moveTo(nextStartPoint[0], nextStartPoint[1]);
            return nextStartPoint;
          } else {
            stream.moveTo(segment.center[0], segment.center[1]);
            return segment.center;
          }
        }
      }
    }
    calculateOffsetVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      switch (vertex.type) {
        case "line-start":
        case "arc-start":
        case "line-line":
          return this.calculateOffsetVertexFromNormal(index, offset, out);
        case "line-arc":
          return this.calculateOffsetLineArcVertex(index, offset, out);
        case "arc-arc":
          return this.calculateOffsetArcArcVertex(index, offset, out);
        default:
          return Vec2Math.copy(this.segments[vertex.fromIndex].end, out);
      }
    }
    calculateOffsetVertexFromNormal(index, offset, out) {
      const segment = this.segments[index];
      const vertex = segment.vertex;
      return Vec2Math.add(segment.end, Vec2Math.multScalar(vertex.normal, offset, out), out);
    }
    calculateOffsetLineArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      const radius = vertex.r0 + offset * vertex.arcOffsetSign;
      if (radius <= 0) {
        return void 0;
      }
      const y = vertex.y0 + offset * vertex.lineOffsetSign;
      const xSq = radius * radius - y * y;
      if (xSq < 0) {
        return void 0;
      }
      const x = Math.sqrt(xSq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    calculateOffsetArcArcVertex(index, offset, out) {
      const vertex = this.segments[index].vertex;
      if (vertex.d === 0) {
        return void 0;
      }
      const segment1 = this.segments[vertex.fromIndex];
      const segment2 = this.segments[vertex.toIndex];
      const radius1 = segment1.radius + offset * vertex.arcOffsetSign;
      const radius2 = segment2.radius + offset * vertex.arc2OffsetSign;
      if (radius1 <= 0 || radius2 <= 0) {
        return void 0;
      }
      const dSq = vertex.d * vertex.d;
      const radius1Sq = radius1 * radius1;
      const radius2Sq = radius2 * radius2;
      const x = (dSq - radius2Sq + radius1Sq) / (2 * vertex.d);
      const ySq = radius1Sq - x * x;
      if (ySq < 0) {
        return void 0;
      }
      const y = Math.sqrt(ySq);
      return vertex.transform.apply(Vec2Math.set(x, y, out), out);
    }
    calculateOffsetStartPoint(index, offset, out) {
      const prevSegment = this.segments[index - 1];
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(prevSegment.end[0] + segment.endNormal[0] * this.windingOrder * offset, prevSegment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign4 = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(prevSegment.end[0] + segment.startNormal[0] * sign4 * offset, prevSegment.end[1] + segment.startNormal[1] * sign4 * offset, out);
        }
      }
    }
    calculateOffsetEndPoint(index, offset, out) {
      const segment = this.segments[index];
      switch (segment.type) {
        case "start":
          return Vec2Math.copy(segment.end, out);
        case "line":
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * this.windingOrder * offset, segment.end[1] + segment.endNormal[1] * this.windingOrder * offset, out);
        case "arc": {
          const sign4 = this.windingOrder * (segment.isClockwise ? 1 : -1);
          return Vec2Math.set(segment.end[0] + segment.endNormal[0] * sign4 * offset, segment.end[1] + segment.endNormal[1] * sign4 * offset, out);
        }
      }
    }
    static isPointInSegmentBounds(segment, start, point) {
      if (segment.type === "start") {
        return true;
      }
      if (segment.type === "line") {
        const lineDeltaX = segment.end[0] - start[0];
        const lineDeltaY = segment.end[1] - start[1];
        const startDeltaX = point[0] - start[0];
        const startDeltaY = point[1] - start[1];
        const endDeltaX = point[0] - segment.end[0];
        const endDeltaY = point[1] - segment.end[1];
        const startDot = startDeltaX * lineDeltaX + startDeltaY * lineDeltaY;
        const endDot = endDeltaX * lineDeltaX + endDeltaY * lineDeltaY;
        return startDot >= 0 && endDot <= 0;
      }
      const startAngle = Vec2Math.theta(segment.startNormal);
      const endAngle = Vec2Math.theta(segment.endNormal);
      const angularWidth = Shape.getAngularWidth(startAngle, endAngle, segment.isClockwise, true);
      const pointAngle = Math.atan2(point[1] - segment.center[1], point[0] - segment.center[0]);
      const angleDiff = Shape.getAngularWidth(startAngle, pointAngle, segment.isClockwise);
      return angleDiff <= angularWidth;
    }
    static getAngularWidth(startAngle, endAngle, isClockwise, zeroIsCircle = false, zeroTolerance = 1e-6) {
      const width = ((isClockwise ? endAngle - startAngle : startAngle - endAngle) + 2 * Math.PI) % (2 * Math.PI);
      return zeroIsCircle && Math.min(width, 2 * Math.PI - width) < zeroTolerance ? 2 * Math.PI : width;
    }
    static createSegment() {
      return {
        type: "arc",
        center: new Float64Array(2),
        radius: 0,
        isClockwise: false,
        end: new Float64Array(2),
        endNormal: new Float64Array(2),
        startNormal: new Float64Array(2),
        vertex: {
          type: "null",
          fromIndex: -1,
          toIndex: -1,
          normal: new Float64Array(2),
          transform: new Transform2D(),
          r0: 0,
          y0: 0,
          lineOffsetSign: 1,
          arcOffsetSign: 1,
          arc2OffsetSign: 1,
          d: 0
        }
      };
    }
  };
  Shape.geoPointCache = [new GeoPoint(0, 0)];
  Shape.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  Shape.vec3Cache = [new Float64Array(3)];
  Shape.transformCache = [new Transform2D(), new Transform2D()];
  var MapFieldOfViewCalculator = class {
    constructor(maxIter = MapFieldOfViewCalculator.DEFAULT_MAX_ITER, rangeTolerance = MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE) {
      this.maxIter = maxIter;
      this.rangeTolerance = rangeTolerance;
      this.tempProjection = new MapProjection(100, 100);
    }
    calculateFov(mapProjection, focus, margins, out) {
      out.range = NaN;
      out.target.set(NaN, NaN);
      if (focus.length === 0) {
        return out;
      }
      const projectedSize = mapProjection.getProjectedSize();
      const targetWidth = projectedSize[0] - margins[0] - margins[2];
      const targetHeight = projectedSize[1] - margins[1] - margins[3];
      if (targetWidth * targetHeight <= 0) {
        return out;
      }
      const mean = Vec3Math.set(0, 0, 0, MapFieldOfViewCalculator.vec3Cache[0]);
      for (let i = 0; i < focus.length; i++) {
        Vec3Math.add(mean, GeoPoint.sphericalToCartesian(focus[i], MapFieldOfViewCalculator.vec3Cache[1]), mean);
      }
      Vec3Math.multScalar(mean, 1 / focus.length, mean);
      this.tempProjection.set({
        projectedSize: mapProjection.getProjectedSize(),
        rotation: mapProjection.getRotation(),
        target: MapFieldOfViewCalculator.geoPointCache[0].setFromCartesian(mean),
        targetProjectedOffset: Vec2Math.set(margins[0] + (targetWidth - projectedSize[0]) / 2, margins[1] + (targetHeight - projectedSize[1]) / 2, MapFieldOfViewCalculator.vec2Cache[0]),
        rangeEndpoints: mapProjection.getRangeEndpoints(),
        range: mapProjection.getRange()
      });
      let minX;
      let minY;
      let maxX;
      let maxY;
      for (let i = 0; i < focus.length; i++) {
        const projected = this.tempProjection.project(focus[i], MapFieldOfViewCalculator.vec2Cache[0]);
        minX = Math.min(projected[0], minX !== null && minX !== void 0 ? minX : Infinity);
        minY = Math.min(projected[1], minY !== null && minY !== void 0 ? minY : Infinity);
        maxX = Math.max(projected[0], maxX !== null && maxX !== void 0 ? maxX : -Infinity);
        maxY = Math.max(projected[1], maxY !== null && maxY !== void 0 ? maxY : -Infinity);
      }
      if (minX === void 0 || minY === void 0 || maxX === void 0 || maxY === void 0) {
        return out;
      }
      let focusWidth = maxX - minX;
      let focusHeight = maxY - minY;
      if (focusWidth === 0 && focusHeight === 0) {
        out.target.set(focus[0]);
        out.range = 0;
        return out;
      }
      this.tempProjection.invert(Vec2Math.set((minX + maxX) / 2, (minY + maxY) / 2, MapFieldOfViewCalculator.vec2Cache[0]), out.target);
      this.tempProjection.set({
        target: out.target
      });
      let widthRatio = focusWidth / targetWidth;
      let heightRatio = focusHeight / targetHeight;
      let constrainedRatio = Math.max(widthRatio, heightRatio);
      const range2 = out.range = this.tempProjection.getRange();
      const topLeft = this.tempProjection.invert(Vec2Math.set(minX, minY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[0]);
      const bottomRight = this.tempProjection.invert(Vec2Math.set(maxX, maxY, MapFieldOfViewCalculator.vec2Cache[0]), MapFieldOfViewCalculator.geoPointCache[1]);
      let iterCount = 0;
      const rangeParam = { range: range2 };
      let ratioError = Math.abs(constrainedRatio - 1);
      let deltaRatioError = this.rangeTolerance + 1;
      while (iterCount++ < this.maxIter && ratioError > this.rangeTolerance && deltaRatioError > this.rangeTolerance) {
        rangeParam.range = out.range = this.tempProjection.getRange() * constrainedRatio;
        if (out.range <= GeoPoint.EQUALITY_TOLERANCE) {
          out.range = GeoPoint.EQUALITY_TOLERANCE;
          return out;
        }
        this.tempProjection.set(rangeParam);
        const topLeftProjected = this.tempProjection.project(topLeft, MapFieldOfViewCalculator.vec2Cache[0]);
        const bottomRightProjected = this.tempProjection.project(bottomRight, MapFieldOfViewCalculator.vec2Cache[1]);
        focusWidth = bottomRightProjected[0] - topLeftProjected[0];
        focusHeight = bottomRightProjected[1] - topLeftProjected[1];
        widthRatio = focusWidth / targetWidth;
        heightRatio = focusHeight / targetHeight;
        constrainedRatio = Math.max(widthRatio, heightRatio);
        const newRatioError = Math.abs(constrainedRatio - 1);
        deltaRatioError = Math.abs(newRatioError - ratioError);
        ratioError = newRatioError;
      }
      this.tempProjection.invert(mapProjection.getTargetProjected(), out.target);
      return out;
    }
  };
  MapFieldOfViewCalculator.DEFAULT_MAX_ITER = 20;
  MapFieldOfViewCalculator.DEFAULT_RANGE_TOLERANCE = 0.01;
  MapFieldOfViewCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
  MapFieldOfViewCalculator.vec2Cache = [Vec2Math.create(), Vec2Math.create()];
  MapFieldOfViewCalculator.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
  var MapOwnAirplaneIconOrientation;
  (function(MapOwnAirplaneIconOrientation2) {
    MapOwnAirplaneIconOrientation2["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation2["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation2["MapUp"] = "MapUp";
  })(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));
  var MapOwnAirplaneIconModule = class {
    constructor() {
      this.show = Subject.create(true);
      this.orientation = Subject.create(MapOwnAirplaneIconOrientation.HeadingUp);
    }
  };
  var MapOwnAirplanePropsModule = class {
    constructor() {
      this.position = GeoPointSubject.createFromGeoPoint(new GeoPoint(0, 0));
      this.hdgTrue = Subject.create(0);
      this.turnRate = Subject.create(0);
      this.altitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.verticalSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.FPM.createNumber(0));
      this.trackTrue = Subject.create(0);
      this.groundSpeed = NumberUnitSubject.createFromNumberUnit(UnitType.KNOT.createNumber(0));
      this.isOnGround = Subject.create(true);
      this.magVar = Subject.create(0);
    }
  };
  var MapAutopilotPropsModule = class {
    constructor() {
      this.selectedAltitude = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(0));
      this.apSelectedAltitudeHandler = (alt) => {
        this.selectedAltitude.set(alt);
      };
    }
  };
  var MapAirspaceModule = class {
    constructor(showTypes) {
      this.showTypes = showTypes;
      this.show = {};
      for (const type in showTypes) {
        this.show[type] = Subject.create(false);
      }
    }
  };
  var AbstractCssTransform = class {
    constructor(initialParams) {
      this.params = new Float64Array(initialParams);
      this.cachedParams = new Float64Array(initialParams);
    }
    resolve() {
      if (this.stringValue !== void 0 && VecNMath.equals(this.params, this.cachedParams)) {
        return this.stringValue;
      }
      VecNMath.copy(this.params, this.cachedParams);
      this.stringValue = this.buildString(this.params);
      return this.stringValue;
    }
  };
  var CssMatrixTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssMatrixTransform.DEFAULT_PARAMS);
    }
    set(arg1, skewY, skewX, scaleY, translateX, translateY) {
      let scaleX;
      if (typeof arg1 === "number") {
        scaleX = arg1;
      } else {
        [scaleX, skewX, skewY, scaleY, translateX, translateY] = arg1.getParameters();
      }
      this.params[0] = scaleX;
      this.params[1] = skewY;
      this.params[2] = skewX;
      this.params[3] = scaleY;
      this.params[4] = translateX;
      this.params[5] = translateY;
    }
    buildString(params) {
      return `matrix(${params.join(", ")})`;
    }
  };
  CssMatrixTransform.DEFAULT_PARAMS = [1, 0, 0, 1, 0, 0];
  var CssRotateTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssRotateTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(angle, precision = 0) {
      this.params[0] = precision === 0 ? angle : MathUtils2.round(angle, precision);
    }
    buildString(params) {
      return `rotate(${params[0]}${this.unit})`;
    }
  };
  CssRotateTransform.DEFAULT_PARAMS = [0];
  var CssRotate3dTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssRotate3dTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(x, y, z, angle, precision = 0) {
      this.params[0] = x;
      this.params[1] = y;
      this.params[2] = z;
      this.params[3] = precision === 0 ? angle : MathUtils2.round(angle, precision);
    }
    buildString(params) {
      return `rotate3d(${params[0]}, ${params[1]}, ${params[2]}, ${params[3]}${this.unit})`;
    }
  };
  CssRotate3dTransform.DEFAULT_PARAMS = [0, 0, 1, 0];
  var CssTranslateXTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateXTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils2.round(x, precision);
    }
    buildString(params) {
      return `translateX(${params[0]}${this.unit})`;
    }
  };
  CssTranslateXTransform.DEFAULT_PARAMS = [0];
  var CssTranslateYTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateYTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils2.round(y, precision);
    }
    buildString(params) {
      return `translateY(${params[0]}${this.unit})`;
    }
  };
  CssTranslateYTransform.DEFAULT_PARAMS = [0];
  var CssTranslateZTransform = class extends AbstractCssTransform {
    constructor(unit) {
      super(CssTranslateZTransform.DEFAULT_PARAMS);
      this.unit = unit;
    }
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils2.round(z, precision);
    }
    buildString(params) {
      return `translateZ(${params[0]}${this.unit})`;
    }
  };
  CssTranslateZTransform.DEFAULT_PARAMS = [0];
  var CssTranslateTransform = class extends AbstractCssTransform {
    constructor(unitX, unitY = unitX) {
      super(CssTranslateTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
    }
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils2.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils2.round(y, precisionY);
    }
    buildString(params) {
      return `translate(${params[0]}${this.unitX}, ${params[1]}${this.unitY})`;
    }
  };
  CssTranslateTransform.DEFAULT_PARAMS = [0, 0];
  var CssTranslate3dTransform = class extends AbstractCssTransform {
    constructor(unitX, unitY = unitX, unitZ = unitX) {
      super(CssTranslate3dTransform.DEFAULT_PARAMS);
      this.unitX = unitX;
      this.unitY = unitY;
      this.unitZ = unitZ;
    }
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils2.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils2.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils2.round(z, precisionZ);
    }
    buildString(params) {
      return `translate3d(${params[0]}${this.unitX}, ${params[1]}${this.unitY}, ${params[2]}${this.unitZ})`;
    }
  };
  CssTranslate3dTransform.DEFAULT_PARAMS = [0, 0, 0];
  var CssScaleXTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleXTransform.DEFAULT_PARAMS);
    }
    set(x, precision = 0) {
      this.params[0] = precision === 0 ? x : MathUtils2.round(x, precision);
    }
    buildString(params) {
      return `scaleX(${params[0]})`;
    }
  };
  CssScaleXTransform.DEFAULT_PARAMS = [1];
  var CssScaleYTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleYTransform.DEFAULT_PARAMS);
    }
    set(y, precision = 0) {
      this.params[0] = precision === 0 ? y : MathUtils2.round(y, precision);
    }
    buildString(params) {
      return `scaleY(${params[0]})`;
    }
  };
  CssScaleYTransform.DEFAULT_PARAMS = [1];
  var CssScaleZTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleZTransform.DEFAULT_PARAMS);
    }
    set(z, precision = 0) {
      this.params[0] = precision === 0 ? z : MathUtils2.round(z, precision);
    }
    buildString(params) {
      return `scaleZ(${params[0]})`;
    }
  };
  CssScaleZTransform.DEFAULT_PARAMS = [1];
  var CssScaleTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScaleTransform.DEFAULT_PARAMS);
    }
    set(x, y, precisionX = 0, precisionY = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils2.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils2.round(y, precisionY);
    }
    buildString(params) {
      return `scale(${params[0]}, ${params[1]})`;
    }
  };
  CssScaleTransform.DEFAULT_PARAMS = [1, 1];
  var CssScale3dTransform = class extends AbstractCssTransform {
    constructor() {
      super(CssScale3dTransform.DEFAULT_PARAMS);
    }
    set(x, y, z, precisionX = 0, precisionY = precisionX, precisionZ = precisionX) {
      this.params[0] = precisionX === 0 ? x : MathUtils2.round(x, precisionX);
      this.params[1] = precisionY === 0 ? y : MathUtils2.round(y, precisionY);
      this.params[2] = precisionZ === 0 ? z : MathUtils2.round(y, precisionZ);
    }
    buildString(params) {
      return `scale3d(${params[0]}, ${params[1]}, ${params[2]})`;
    }
  };
  CssScale3dTransform.DEFAULT_PARAMS = [1, 1, 1];
  var CssTransformChain = class {
    constructor(...transforms) {
      this.stringValues = [];
      this.transforms = transforms;
    }
    getChild(index) {
      if (index < 0 || index >= this.transforms.length) {
        throw new RangeError();
      }
      return this.transforms[index];
    }
    resolve() {
      let needRebuildString = false;
      for (let i = 0; i < this.transforms.length; i++) {
        const stringValue = this.transforms[i].resolve();
        if (this.stringValues[i] !== stringValue) {
          this.stringValues[i] = stringValue;
          needRebuildString = true;
        }
      }
      if (needRebuildString || this.chainedStringValue === void 0) {
        this.chainedStringValue = this.stringValues.join(" ");
      }
      return this.chainedStringValue;
    }
  };
  var CssTransformSubject = class extends AbstractSubscribable {
    constructor(transform) {
      super();
      this._transform = transform;
      this.stringValue = transform.resolve();
      this.transform = transform;
    }
    get() {
      return this.stringValue;
    }
    resolve() {
      const stringValue = this._transform.resolve();
      if (stringValue !== this.stringValue) {
        this.stringValue = stringValue;
        this.notify();
      }
    }
    static create(transform) {
      return new CssTransformSubject(transform);
    }
  };
  var CssTransformBuilder = class {
    static matrix() {
      return new CssMatrixTransform();
    }
    static rotate(unit) {
      return new CssRotateTransform(unit);
    }
    static rotate3d(unit) {
      return new CssRotate3dTransform(unit);
    }
    static translateX(unit) {
      return new CssTranslateXTransform(unit);
    }
    static translateY(unit) {
      return new CssTranslateYTransform(unit);
    }
    static translateZ(unit) {
      return new CssTranslateZTransform(unit);
    }
    static translate(unitX, unitY) {
      return new CssTranslateTransform(unitX, unitY);
    }
    static translate3d(unitX, unitY, unitZ) {
      return new CssTranslate3dTransform(unitX, unitY, unitZ);
    }
    static scaleX() {
      return new CssScaleXTransform();
    }
    static scaleY() {
      return new CssScaleYTransform();
    }
    static scaleZ() {
      return new CssScaleZTransform();
    }
    static scale() {
      return new CssScaleTransform();
    }
    static scale3d() {
      return new CssScale3dTransform();
    }
    static concat(...transforms) {
      return new CssTransformChain(...transforms);
    }
  };
  var NumberFormatter = class {
    static formatNumber(number2, opts) {
      if (isNaN(number2)) {
        return opts.nanString;
      }
      const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
      const sign4 = number2 < 0 ? -1 : 1;
      const abs3 = Math.abs(number2);
      let rounded = abs3;
      if (precision !== 0) {
        rounded = roundFunc(abs3 / precision) * precision;
      }
      if (cache) {
        if (opts.cachedString !== void 0 && opts.cachedNumber === rounded) {
          return opts.cachedString;
        }
        opts.cachedNumber = rounded;
      }
      const signText = sign4 === -1 ? useMinusSign ? "\u2212" : "-" : "+";
      let formatted;
      if (precision != 0) {
        const precisionString = `${precision}`;
        const decimalIndex2 = precisionString.indexOf(".");
        if (decimalIndex2 >= 0) {
          formatted = rounded.toFixed(precisionString.length - decimalIndex2 - 1);
        } else {
          formatted = `${rounded}`;
        }
      } else {
        formatted = `${abs3}`;
      }
      let decimalIndex = formatted.indexOf(".");
      if (!forceDecimalZeroes && decimalIndex >= 0) {
        formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, "");
        if (formatted.indexOf(".") == formatted.length - 1) {
          formatted = formatted.substring(0, formatted.length - 1);
        }
      }
      decimalIndex = formatted.indexOf(".");
      if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
        const shift = Math.max(maxDigits - decimalIndex, 0);
        const shiftPrecision = Math.pow(0.1, shift);
        formatted = (roundFunc(abs3 / shiftPrecision) * shiftPrecision).toFixed(shift);
      }
      if (pad === 0) {
        formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, ".");
      } else if (pad > 1) {
        decimalIndex = formatted.indexOf(".");
        if (decimalIndex < 0) {
          decimalIndex = formatted.length;
        }
        formatted = formatted.padStart(pad + formatted.length - decimalIndex, "0");
      }
      if (showCommas) {
        const parts = formatted.split(".");
        parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ",");
        formatted = parts.join(".");
      }
      formatted = (forceSign || signText !== "+" ? signText : "") + formatted;
      if (cache) {
        opts.cachedString = formatted;
      }
      return formatted;
    }
    static create(options) {
      const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
      optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
      return (number2) => {
        return NumberFormatter.formatNumber(number2, optsToUse);
      };
    }
  };
  NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: "NaN",
    cache: false
  };
  NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
  };
  NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
  NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
  NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;
  var SvgPathStream = class {
    constructor(precision = 0) {
      this.svgPath = "";
      this.firstPoint = new Float64Array([NaN, NaN]);
      this.prevPoint = new Float64Array([NaN, NaN]);
      this.precision = precision;
      this.formatter = NumberFormatter.create({ precision, forceDecimalZeroes: false });
    }
    getSvgPath() {
      return this.svgPath.trim();
    }
    getPrecision() {
      return this.precision;
    }
    setPrecision(precision) {
      this.precision = Math.abs(precision);
      this.formatter = NumberFormatter.create({ precision: this.precision, forceDecimalZeroes: false });
    }
    beginPath() {
      this.reset();
    }
    moveTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.firstPoint[0])) {
        Vec2Math.set(x, y, this.firstPoint);
      }
      this.svgPath += `M ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    lineTo(x, y) {
      if (!(isFinite(x) && isFinite(y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `L ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cp1x) && isFinite(cp1y) && isFinite(cp2x) && isFinite(cp2y))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `C ${this.formatter(cp1x)} ${this.formatter(cp1y)} ${this.formatter(cp2x)} ${this.formatter(cp2y)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
      if (!(isFinite(x) && isFinite(y) && isFinite(cpx) && isFinite(cpy))) {
        return;
      }
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(x, y);
        return;
      }
      this.svgPath += `Q ${this.formatter(cpx)} ${this.formatter(cpy)} ${this.formatter(x)} ${this.formatter(y)} `;
      Vec2Math.set(x, y, this.prevPoint);
    }
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      if (!(isFinite(x) && isFinite(y) && isFinite(radius) && isFinite(startAngle) && isFinite(endAngle))) {
        return;
      }
      const directionSign = counterClockwise ? -1 : 1;
      if (Math.sign(endAngle - startAngle) !== directionSign) {
        const angleDiff = counterClockwise ? MathUtils2.diffAngle(endAngle, startAngle) : MathUtils2.diffAngle(startAngle, endAngle);
        endAngle = startAngle + angleDiff * directionSign;
      }
      const angularWidth = Math.min(MathUtils2.TWO_PI, (endAngle - startAngle) * directionSign);
      if (angularWidth === MathUtils2.TWO_PI) {
        const midAngle = startAngle + Math.PI * directionSign;
        this.arc(x, y, radius, startAngle, midAngle, counterClockwise);
        this.arc(x, y, radius, midAngle, startAngle, counterClockwise);
        return;
      }
      const startPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[0]), Vec2Math.setFromPolar(radius, startAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[0]);
      if (isNaN(this.prevPoint[0])) {
        this.moveTo(startPoint[0], startPoint[1]);
      } else if (!Vec2Math.equals(this.prevPoint, startPoint)) {
        this.lineTo(startPoint[0], startPoint[1]);
      }
      const endPoint = Vec2Math.add(Vec2Math.set(x, y, SvgPathStream.vec2Cache[1]), Vec2Math.setFromPolar(radius, endAngle, SvgPathStream.vec2Cache[2]), SvgPathStream.vec2Cache[1]);
      const radiusString = this.formatter(radius);
      this.svgPath += `A ${radiusString} ${radiusString} 0 ${angularWidth > Math.PI ? 1 : 0} ${counterClockwise ? 0 : 1} ${this.formatter(endPoint[0])} ${this.formatter(endPoint[1])} `;
      Vec2Math.copy(endPoint, this.prevPoint);
    }
    closePath() {
      if (!isNaN(this.firstPoint[0])) {
        this.lineTo(this.firstPoint[0], this.firstPoint[1]);
      }
    }
    reset() {
      Vec2Math.set(NaN, NaN, this.firstPoint);
      Vec2Math.set(NaN, NaN, this.prevPoint);
      this.svgPath = "";
    }
  };
  SvgPathStream.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var MapSystemKeys = class {
  };
  MapSystemKeys.TargetControl = "targetControlModerator";
  MapSystemKeys.RotationControl = "rotationControlModerator";
  MapSystemKeys.RangeControl = "rangeControlModerator";
  MapSystemKeys.ClockUpdate = "clockUpdate";
  MapSystemKeys.OwnAirplaneProps = "ownAirplaneProps";
  MapSystemKeys.AutopilotProps = "autopilotProps";
  MapSystemKeys.AltitudeArc = "altitudeArc";
  MapSystemKeys.TerrainColors = "terrainColors";
  MapSystemKeys.Weather = "weather";
  MapSystemKeys.FollowAirplane = "followAirplane";
  MapSystemKeys.Rotation = "rotation";
  MapSystemKeys.OwnAirplaneIcon = "ownAirplaneIcon";
  MapSystemKeys.OwnAirplaneIconOrientation = "ownAirplaneIconOrientation";
  MapSystemKeys.TextLayer = "text";
  MapSystemKeys.TextManager = "textManager";
  MapSystemKeys.Bing = "bing";
  MapSystemKeys.WaypointRenderer = "waypointRenderer";
  MapSystemKeys.IconFactory = "iconFactory";
  MapSystemKeys.LabelFactory = "labelFactory";
  MapSystemKeys.NearestWaypoints = "nearestWaypoints";
  MapSystemKeys.FlightPlan = "flightPlan";
  MapSystemKeys.FlightPlanner = "flightPlanner";
  MapSystemKeys.FlightPathRenderer = "flightPathRenderer";
  MapSystemKeys.Airspace = "airspace";
  MapSystemKeys.AirspaceManager = "airspaceRenderManager";
  MapSystemKeys.Traffic = "traffic";
  MapSystemKeys.DataIntegrity = "dataIntegrity";
  var MapCanvasLayerCanvasInstanceClass = class {
    constructor(canvas, context, isDisplayed) {
      this.canvas = canvas;
      this.context = context;
      this.isDisplayed = isDisplayed;
    }
    clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    reset() {
      const width = this.canvas.width;
      this.canvas.width = 0;
      this.canvas.width = width;
    }
  };
  var MapCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.displayCanvasRef = FSComponent.createRef();
      this.width = 0;
      this.height = 0;
      this.displayCanvasContext = null;
      this.isInit = false;
    }
    get display() {
      if (!this._display) {
        throw new Error("MapCanvasLayer: attempted to access display before it was initialized");
      }
      return this._display;
    }
    get buffer() {
      if (!this._buffer) {
        throw new Error("MapCanvasLayer: attempted to access buffer before it was initialized");
      }
      return this._buffer;
    }
    tryGetDisplay() {
      return this._display;
    }
    tryGetBuffer() {
      return this._buffer;
    }
    getWidth() {
      return this.width;
    }
    getHeight() {
      return this.height;
    }
    setWidth(width) {
      if (width === this.width) {
        return;
      }
      this.width = width;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    setHeight(height) {
      if (height === this.height) {
        return;
      }
      this.height = height;
      if (this.isInit) {
        this.updateCanvasSize();
      }
    }
    copyBufferToDisplay() {
      if (!this.isInit || !this.props.useBuffer) {
        return;
      }
      this.display.context.drawImage(this.buffer.canvas, 0, 0, this.width, this.height);
    }
    onAfterRender() {
      this.displayCanvasContext = this.displayCanvasRef.instance.getContext("2d");
    }
    onVisibilityChanged(isVisible) {
      if (this.isInit) {
        this.updateCanvasVisibility();
      }
    }
    updateFromVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    onAttached() {
      this.initCanvasInstances();
      this.isInit = true;
      this.updateCanvasVisibility();
      this.updateCanvasSize();
    }
    initCanvasInstances() {
      this._display = this.createCanvasInstance(this.displayCanvasRef.instance, this.displayCanvasContext, true);
      if (this.props.useBuffer) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        this._buffer = this.createCanvasInstance(canvas, context, false);
      }
    }
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed);
    }
    updateCanvasSize() {
      const displayCanvas = this.display.canvas;
      displayCanvas.width = this.width;
      displayCanvas.height = this.height;
      displayCanvas.style.width = `${this.width}px`;
      displayCanvas.style.height = `${this.height}px`;
      if (this._buffer) {
        const bufferCanvas = this._buffer.canvas;
        bufferCanvas.width = this.width;
        bufferCanvas.height = this.height;
      }
    }
    updateCanvasVisibility() {
      this.display.canvas.style.display = this.isVisible() ? "block" : "none";
    }
    render() {
      var _a;
      return FSComponent.buildComponent("canvas", { ref: this.displayCanvasRef, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", width: "0", height: "0", style: "position: absolute;" });
    }
  };
  var MapSyncedCanvasLayer = class extends MapCanvasLayer {
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
    }
    updateFromProjectedSize(projectedSize) {
      this.setWidth(projectedSize[0]);
      this.setHeight(projectedSize[1]);
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = "0px";
      displayCanvas.style.top = "0px";
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
    }
  };
  var MapAltitudeArcLayer = class extends MapLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      super(...arguments);
      this.layerRef = FSComponent.createRef();
      this.arcAngularWidth = ((_a = this.props.arcAngularWidth) !== null && _a !== void 0 ? _a : MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH) * Avionics.Utils.DEG2RAD;
      this.arcRadius = (_b = this.props.arcRadius) !== null && _b !== void 0 ? _b : MapAltitudeArcLayer.DEFAULT_ARC_RADIUS;
      this.strokeWidth = (_c = this.props.strokeWidth) !== null && _c !== void 0 ? _c : MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_d = this.props.strokeStyle) !== null && _d !== void 0 ? _d : MapAltitudeArcLayer.DEFAULT_STROKE_STYLE;
      this.strokeLineCap = (_e = this.props.strokeLineCap) !== null && _e !== void 0 ? _e : MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP;
      this.outlineWidth = (_f = this.props.outlineWidth) !== null && _f !== void 0 ? _f : MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_g = this.props.outlineStyle) !== null && _g !== void 0 ? _g : MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineLineCap = (_h = this.props.outlineLineCap) !== null && _h !== void 0 ? _h : MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP;
      this.ownAirplanePropsModule = this.props.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.autopilotModule = this.props.model.getModule(MapSystemKeys.AutopilotProps);
      this.vsPrecisionFpm = "isSubscribable" in this.props.verticalSpeedPrecision ? this.vsPrecisionMap = this.props.verticalSpeedPrecision.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedPrecision.asUnit(UnitType.FPM));
      this.vsThresholdFpm = "isSubscribable" in this.props.verticalSpeedThreshold ? this.vsThresholdMap = this.props.verticalSpeedThreshold.map((v) => v.asUnit(UnitType.FPM)) : Subject.create(this.props.verticalSpeedThreshold.asUnit(UnitType.FPM));
      this.altDevThresholdFeet = "isSubscribable" in this.props.altitudeDeviationThreshold ? this.altDevThresholdMap = this.props.altitudeDeviationThreshold.map((v) => v.asUnit(UnitType.FOOT)) : Subject.create(this.props.altitudeDeviationThreshold.asUnit(UnitType.FOOT));
      this.vsFpm = this.ownAirplanePropsModule.verticalSpeed.map((vs) => vs.asUnit(UnitType.FPM));
      this.vsFpmQuantized = MappedSubject.create(([vsFpm, precision]) => {
        return Math.round(vsFpm / precision) * precision;
      }, this.vsFpm, this.vsPrecisionFpm);
      this.projectedPlanePosition = Vec2Subject.create(Vec2Math.create());
      this.projectPlanePositionHandler = () => {
        const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapAltitudeArcLayer.vec2Cache[0]);
        this.projectedPlanePosition.set(projected);
      };
      this.isArcVisibleDynamic = MappedSubject.create(([vsFpm, alt, selectedAlt, vsThreshold, altDevThresholdFeet]) => {
        if (Math.abs(vsFpm) < vsThreshold) {
          return false;
        }
        const altDevFeet = selectedAlt.asUnit(UnitType.FOOT) - alt.asUnit(UnitType.FOOT);
        return Math.abs(altDevFeet) >= altDevThresholdFeet && altDevFeet * vsFpm > 0;
      }, this.vsFpmQuantized, this.ownAirplanePropsModule.altitude, this.autopilotModule.selectedAltitude, this.vsThresholdFpm, this.altDevThresholdFeet).pause();
      this.projectedArcPosition = Vec2Subject.create(Vec2Math.create());
      this.projectedArcAngle = Subject.create(0);
      this.needUpdate = false;
      this.subscriptions = [];
    }
    onVisibilityChanged(isVisible) {
      var _a;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.setVisible(isVisible);
      if (isVisible) {
        this.needUpdate = true;
      }
    }
    onAttached() {
      var _a, _b;
      this.layerRef.instance.onAttached();
      this.subscriptions.push(this.ownAirplanePropsModule.position.sub(this.projectPlanePositionHandler));
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      const altitudeArcModule = this.props.model.getModule(MapSystemKeys.AltitudeArc);
      const dataIntegrityModule = this.props.model.getModule(MapSystemKeys.DataIntegrity);
      this.isArcVisibleStatic = MappedSubject.create(([show, isGpsValid, isAdcValid]) => {
        return show && isGpsValid && isAdcValid;
      }, altitudeArcModule.show, (_a = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.gpsSignalValid) !== null && _a !== void 0 ? _a : Subject.create(true), (_b = dataIntegrityModule === null || dataIntegrityModule === void 0 ? void 0 : dataIntegrityModule.adcSignalValid) !== null && _b !== void 0 ? _b : Subject.create(true));
      const isArcVisibleDynamicSub = this.isArcVisibleDynamic.sub((isVisible) => {
        this.setVisible(isVisible);
      }, false, true);
      this.isArcVisibleStatic.sub((isVisible) => {
        if (isVisible) {
          this.isArcVisibleDynamic.resume();
          isArcVisibleDynamicSub.resume(true);
        } else {
          this.isArcVisibleDynamic.pause();
          isArcVisibleDynamicSub.pause();
          this.setVisible(false);
        }
      }, true);
      this.subscriptions.push(this.projectedPlanePosition.sub(scheduleUpdate), this.ownAirplanePropsModule.trackTrue.sub(scheduleUpdate), this.ownAirplanePropsModule.groundSpeed.sub(scheduleUpdate), this.ownAirplanePropsModule.altitude.sub(scheduleUpdate));
      this.vsFpmQuantized.sub(scheduleUpdate);
      this.subscriptions.push(this.autopilotModule.selectedAltitude.sub(scheduleUpdate, true));
      this.layerRef.instance.setVisible(this.isVisible());
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.layerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.projectPlanePositionHandler();
      this.needUpdate = true;
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const track = this.ownAirplanePropsModule.trackTrue.get();
      const groundSpeed = this.ownAirplanePropsModule.groundSpeed.get();
      const altitude = this.ownAirplanePropsModule.altitude.get();
      const selectedAltitude = this.autopilotModule.selectedAltitude.get();
      const vsFpm = this.vsFpmQuantized.get();
      const timeToAltitudeMinute = (selectedAltitude.asUnit(UnitType.FOOT) - altitude.asUnit(UnitType.FOOT)) / vsFpm;
      const distanceToAltitudeFeet = groundSpeed.asUnit(UnitType.FPM) * timeToAltitudeMinute;
      const distancePx = UnitType.FOOT.convertTo(distanceToAltitudeFeet, UnitType.GA_RADIAN) / this.props.mapProjection.getProjectedResolution();
      const projectedTrackAngle = track * Avionics.Utils.DEG2RAD + this.props.mapProjection.getRotation() - MathUtils2.HALF_PI;
      const projectedPlanePos = this.projectedPlanePosition.get();
      const projectedArcPos = Vec2Math.add(Vec2Math.setFromPolar(distancePx, projectedTrackAngle, MapAltitudeArcLayer.vec2Cache[0]), projectedPlanePos, MapAltitudeArcLayer.vec2Cache[0]);
      this.projectedArcPosition.set(projectedArcPos);
      this.projectedArcAngle.set(projectedTrackAngle);
      this.layerRef.instance.onUpdated();
      this.needUpdate = false;
    }
    render() {
      const props = {
        ref: this.layerRef,
        model: this.props.model,
        mapProjection: this.props.mapProjection,
        arcAngularWidth: this.arcAngularWidth,
        arcRadius: this.arcRadius,
        strokeWidth: this.strokeWidth,
        strokeStyle: this.strokeStyle,
        strokeLineCap: this.strokeLineCap,
        outlineWidth: this.outlineWidth,
        outlineStyle: this.outlineStyle,
        outlineLineCap: this.outlineLineCap,
        projectedArcPosition: this.projectedArcPosition,
        projectedArcAngle: this.projectedArcAngle
      };
      return this.props.renderMethod === "canvas" ? FSComponent.buildComponent(MapAltitudeArcCanvasLayer, Object.assign({}, props)) : FSComponent.buildComponent(MapAltitudeArcSvgLayer, Object.assign({}, props));
    }
    destroy() {
      var _a, _b, _c, _d, _e;
      (_a = this.layerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.vsPrecisionMap) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.vsThresholdMap) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.altDevThresholdMap) === null || _d === void 0 ? void 0 : _d.destroy();
      this.vsFpm.destroy();
      (_e = this.isArcVisibleStatic) === null || _e === void 0 ? void 0 : _e.destroy();
      this.isArcVisibleDynamic.destroy();
      this.subscriptions.forEach((sub2) => sub2.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcLayer.DEFAULT_ARC_ANGULAR_WIDTH = 60;
  MapAltitudeArcLayer.DEFAULT_ARC_RADIUS = 64;
  MapAltitudeArcLayer.DEFAULT_STROKE_WIDTH = 2;
  MapAltitudeArcLayer.DEFAULT_STROKE_STYLE = "cyan";
  MapAltitudeArcLayer.DEFAULT_STROKE_LINECAP = "butt";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_WIDTH = 1;
  MapAltitudeArcLayer.DEFAULT_OUTLINE_STYLE = "#505050";
  MapAltitudeArcLayer.DEFAULT_OUTLINE_LINECAP = "butt";
  MapAltitudeArcLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcCanvasLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.canvasLayerRef = FSComponent.createRef();
      this.subscriptions = [];
      this.needUpdate = false;
    }
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (isVisible) {
        this.needUpdate = true;
      } else {
        (_b = (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.tryGetDisplay()) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
      this.needUpdate = true;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const display = this.canvasLayerRef.instance.display;
      display.clear();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        return;
      }
      display.context.beginPath();
      const projectedArcAngle = this.props.projectedArcAngle.get();
      const center = Vec2Math.add(Vec2Math.setFromPolar(-this.props.arcRadius, projectedArcAngle, MapAltitudeArcCanvasLayer.vec2Cache[0]), arcPos, MapAltitudeArcCanvasLayer.vec2Cache[0]);
      const arcStart = Vec2Math.add(Vec2Math.setFromPolar(this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, MapAltitudeArcCanvasLayer.vec2Cache[1]), center, MapAltitudeArcCanvasLayer.vec2Cache[1]);
      display.context.moveTo(arcStart[0], arcStart[1]);
      display.context.arc(center[0], center[1], this.props.arcRadius, projectedArcAngle - this.arcHalfAngularWidth, projectedArcAngle + this.arcHalfAngularWidth);
      if (this.props.outlineWidth > 0) {
        display.context.lineWidth = this.totalArcThickness;
        display.context.strokeStyle = this.props.outlineStyle;
        display.context.lineCap = this.props.outlineLineCap;
        display.context.stroke();
      }
      if (this.props.strokeWidth > 0) {
        display.context.lineWidth = this.props.strokeWidth;
        display.context.strokeStyle = this.props.strokeStyle;
        display.context.lineCap = this.props.strokeLineCap;
        display.context.stroke();
      }
      this.needUpdate = false;
    }
    render() {
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection });
    }
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.subscriptions.forEach((sub2) => sub2.destroy());
      super.destroy();
    }
  };
  MapAltitudeArcCanvasLayer.vec2Cache = [new Float64Array(2), new Float64Array(2)];
  var MapAltitudeArcSvgLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.arcHalfAngularWidth = this.props.arcAngularWidth / 2;
      this.totalArcThickness = this.props.strokeWidth + this.props.outlineWidth * 2;
      this.width = this.props.arcRadius * (1 - Math.cos(this.arcHalfAngularWidth)) + this.totalArcThickness + 2;
      this.height = 2 * this.props.arcRadius * Math.sin(Math.min(this.arcHalfAngularWidth, MathUtils2.HALF_PI)) + this.totalArcThickness + 2;
      this.svgStyle = ObjectSubject.create({
        "display": "",
        "position": "absolute",
        "left": `${this.totalArcThickness / 2 + 1 - this.width}px`,
        "top": `${-this.height / 2}px`,
        "width": `${this.width}px`,
        "height": `${this.height}px`,
        "transform": "translate3d(0px, 0px, 0px) rotate(0rad)",
        "transform-origin": `${this.width - (this.totalArcThickness / 2 + 1)}px ${this.height / 2}px`
      });
      this.svgTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("rad"));
      this.needUpdate = false;
      this.subscriptions = [];
    }
    onVisibilityChanged(isVisible) {
      if (isVisible) {
        this.needUpdate = true;
      } else {
        this.svgStyle.set("display", "none");
      }
    }
    onAttached() {
      const scheduleUpdate = () => {
        this.needUpdate = true;
      };
      this.subscriptions.push(this.props.projectedArcPosition.sub(scheduleUpdate, false), this.props.projectedArcAngle.sub(scheduleUpdate, false));
    }
    onUpdated() {
      if (!this.needUpdate || !this.isVisible()) {
        return;
      }
      const arcPos = this.props.projectedArcPosition.get();
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const arcX = arcPos[0];
      const arcY = arcPos[1];
      const twiceRadius = this.props.arcRadius * 2;
      if (arcX <= -twiceRadius || arcX >= projectedSize[0] + twiceRadius || arcY <= -twiceRadius || arcY >= projectedSize[1] + twiceRadius) {
        this.svgStyle.set("display", "none");
      } else {
        this.svgStyle.set("display", "");
        this.svgTransform.getChild(0).set(arcX, arcY, 0, 0.1);
        this.svgTransform.getChild(1).set(this.props.projectedArcAngle.get(), 1e-4);
        this.svgStyle.set("transform", this.svgTransform.resolve());
      }
      this.needUpdate = false;
    }
    render() {
      const svgPathStream = new SvgPathStream(0.01);
      const transformPathStream = new AffineTransformPathStream(svgPathStream);
      transformPathStream.beginPath();
      transformPathStream.addRotation(-this.arcHalfAngularWidth).addTranslation(-this.props.arcRadius, 0);
      transformPathStream.moveTo(this.props.arcRadius, 0);
      transformPathStream.arc(0, 0, this.props.arcRadius, 0, this.props.arcAngularWidth);
      const path = svgPathStream.getSvgPath();
      return FSComponent.buildComponent(
        "svg",
        { viewBox: `${this.totalArcThickness / 2 + 1 - this.width} ${-this.height / 2} ${this.width} ${this.height}`, style: this.svgStyle },
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.outlineStyle, "stroke-width": this.totalArcThickness, "stroke-linecap": this.props.outlineLineCap }),
        FSComponent.buildComponent("path", { d: path, fill: "none", stroke: this.props.strokeStyle, "stroke-width": this.props.strokeWidth, "stroke-linecap": this.props.strokeLineCap })
      );
    }
    destroy() {
      this.subscriptions.forEach((sub2) => sub2.destroy());
      super.destroy();
    }
  };
  var MapBingLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.bingRef = FSComponent.createRef();
      this.wrapperStyle = ObjectSubject.create({
        "position": "absolute",
        "left": "0px",
        "top": "0px",
        "width": "0px",
        "height": "0px",
        "display": "",
        "transform": ""
      });
      this.resolution = Vec2Subject.create(Vec2Math.create(1024, 1024));
      this.rotationTransform = CssTransformBuilder.rotate("rad");
      this.size = 0;
      this.needUpdate = false;
    }
    onVisibilityChanged(isVisible) {
      this.wrapperStyle.set("display", isVisible ? "" : "none");
    }
    onAttached() {
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      if (this.props.wxrMode !== void 0) {
        this.props.wxrMode.sub(() => {
          this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
          this.needUpdate = true;
        });
      }
    }
    onWake() {
      this.bingRef.instance.wake();
    }
    onSleep() {
      this.bingRef.instance.sleep();
    }
    updateFromProjectedSize(projectedSize) {
      let offsetX, offsetY;
      if (this.props.wxrMode && this.props.wxrMode.get().mode === EWeatherRadar.HORIZONTAL) {
        const offsetSize = new Float64Array([projectedSize[0], projectedSize[1]]);
        const offset = this.props.mapProjection.getTargetProjectedOffset();
        offsetSize[0] += offset[0];
        offsetSize[1] += offset[1];
        this.size = this.getSize(offsetSize);
        offsetX = (projectedSize[0] - this.size) / 2 + offset[0];
        offsetY = (projectedSize[1] - this.size) / 2 + offset[1];
      } else {
        this.size = this.getSize(projectedSize);
        offsetX = (projectedSize[0] - this.size) / 2;
        offsetY = (projectedSize[1] - this.size) / 2;
      }
      this.wrapperStyle.set("left", `${offsetX}px`);
      this.wrapperStyle.set("top", `${offsetY}px`);
      this.wrapperStyle.set("width", `${this.size}px`);
      this.wrapperStyle.set("height", `${this.size}px`);
      this.resolution.set(this.size, this.size);
    }
    getSize(projectedSize) {
      return Vec2Math.abs(projectedSize);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.ProjectedSize | MapProjectionChangeType.TargetProjected)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
      }
      if (this.bingRef.instance.isBound()) {
        this.needUpdate = true;
      }
    }
    onBingBound() {
      this.needUpdate = true;
    }
    onUpdated(time, elapsed) {
      if (!this.needUpdate) {
        return;
      }
      this.updatePositionRadius();
      this.needUpdate = false;
    }
    resetImgSrc() {
      this.bingRef.instance.resetImgSrc();
    }
    updatePositionRadius() {
      const center = this.props.mapProjection.getCenter();
      const radius = this.calculateDesiredRadius(this.props.mapProjection);
      this.bingRef.instance.setPositionRadius(new LatLong(center.lat, center.lon), radius);
      if (!this.props.wxrMode || this.props.wxrMode && this.props.wxrMode.get().mode !== EWeatherRadar.HORIZONTAL) {
        this.rotationTransform.set(this.props.mapProjection.getRotation(), 1e-3);
      } else {
        this.rotationTransform.set(0);
      }
      this.wrapperStyle.set("transform", this.rotationTransform.resolve());
    }
    calculateDesiredRadius(mapProjection) {
      const scaleFactor = mapProjection.getScaleFactor();
      const pointScaleFactor = 1 / Math.cos(mapProjection.getCenter().lat * Avionics.Utils.DEG2RAD);
      const radiusGARad = this.size / (2 * scaleFactor * pointScaleFactor);
      return UnitType.GA_RADIAN.convertTo(radiusGARad, UnitType.METER);
    }
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        "div",
        { style: this.wrapperStyle, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" },
        FSComponent.buildComponent(BingComponent, { ref: this.bingRef, id: this.props.bingId, onBoundCallback: this.onBingBound.bind(this), resolution: this.resolution, mode: (_b = this.props.mode) !== null && _b !== void 0 ? _b : EBingMode.PLANE, earthColors: this.props.earthColors, earthColorsElevationRange: this.props.earthColorsElevationRange, reference: this.props.reference, wxrMode: this.props.wxrMode, wxrColors: this.props.wxrColors, isoLines: this.props.isoLines, delay: this.props.delay })
      );
    }
  };
  var MapCachedCanvasLayerReferenceClass = class {
    constructor() {
      this._center = new GeoPoint(0, 0);
      this._scaleFactor = 1;
      this._rotation = 0;
    }
    get center() {
      return this._center.readonly;
    }
    get scaleFactor() {
      return this._scaleFactor;
    }
    get rotation() {
      return this._rotation;
    }
    syncWithMapProjection(mapProjection) {
      this._center.set(mapProjection.getCenter());
      this._scaleFactor = mapProjection.getScaleFactor();
      this._rotation = mapProjection.getRotation();
    }
    syncWithReference(reference) {
      this._center.set(reference.center);
      this._scaleFactor = reference.scaleFactor;
      this._rotation = reference.rotation;
    }
  };
  var MapCachedCanvasLayerTransformClass = class {
    constructor() {
      this._scale = 0;
      this._rotation = 0;
      this._translation = new Float64Array(2);
      this._margin = 0;
      this._marginRemaining = 0;
    }
    get scale() {
      return this._scale;
    }
    get rotation() {
      return this._rotation;
    }
    get translation() {
      return this._translation;
    }
    get margin() {
      return this._margin;
    }
    get marginRemaining() {
      return this._marginRemaining;
    }
    update(mapProjection, reference, referenceMargin) {
      this._scale = mapProjection.getScaleFactor() / reference.scaleFactor;
      this._rotation = mapProjection.getRotation() - reference.rotation;
      mapProjection.project(reference.center, this._translation);
      Vec2Math.sub(this._translation, mapProjection.getCenterProjected(), this._translation);
      this._margin = referenceMargin * this._scale;
      this._marginRemaining = this._margin - Math.max(Math.abs(this._translation[0]), Math.abs(this._translation[1]));
    }
    copyFrom(other) {
      this._scale = other.scale;
      this._rotation = other.rotation;
      this._translation.set(other.translation);
      this._margin = other.margin;
    }
  };
  var MapCachedCanvasLayerCanvasInstanceClass = class extends MapCanvasLayerCanvasInstanceClass {
    constructor(canvas, context, isDisplayed, getReferenceMargin) {
      super(canvas, context, isDisplayed);
      this.getReferenceMargin = getReferenceMargin;
      this._reference = new MapCachedCanvasLayerReferenceClass();
      this._transform = new MapCachedCanvasLayerTransformClass();
      this._isInvalid = false;
      this._geoProjection = new MercatorProjection();
      this.canvasTransform = CssTransformSubject.create(CssTransformBuilder.concat(CssTransformBuilder.scale(), CssTransformBuilder.translate("px"), CssTransformBuilder.rotate("rad")));
      this.canvasTransform.sub((transform) => {
        this.canvas.style.transform = transform;
      }, true);
    }
    get reference() {
      return this._reference;
    }
    get transform() {
      return this._transform;
    }
    get isInvalid() {
      return this._isInvalid;
    }
    get geoProjection() {
      return this._geoProjection;
    }
    syncWithMapProjection(mapProjection) {
      const projectedCenter = Vec2Math.set(this.canvas.width / 2, this.canvas.height / 2, MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1);
      this._reference.syncWithMapProjection(mapProjection);
      this._geoProjection.copyParametersFrom(mapProjection.getGeoProjection()).setTranslation(projectedCenter);
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      this._isInvalid = false;
      if (this.isDisplayed) {
        this.transformCanvasElement();
      }
    }
    syncWithCanvasInstance(other) {
      this._reference.syncWithReference(other.reference);
      this._geoProjection.copyParametersFrom(other.geoProjection);
      this._transform.copyFrom(other.transform);
      this._isInvalid = other.isInvalid;
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    updateTransform(mapProjection) {
      this._transform.update(mapProjection, this.reference, this.getReferenceMargin());
      if (!this._isInvalid) {
        const scaleFactorRatio = mapProjection.getScaleFactor() / this._reference.scaleFactor;
        this._isInvalid = scaleFactorRatio >= MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || scaleFactorRatio <= 1 / MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD || this._transform.marginRemaining < 0;
      }
      if (this.isDisplayed && !this._isInvalid) {
        this.transformCanvasElement();
      }
    }
    transformCanvasElement() {
      const transform = this.transform;
      const offsetX = transform.translation[0] / transform.scale;
      const offsetY = transform.translation[1] / transform.scale;
      this.canvasTransform.transform.getChild(0).set(transform.scale, transform.scale, 1e-3);
      this.canvasTransform.transform.getChild(1).set(offsetX, offsetY, 0.1);
      this.canvasTransform.transform.getChild(2).set(transform.rotation, 1e-4);
      this.canvasTransform.resolve();
    }
    invalidate() {
      this._isInvalid = true;
      this.clear();
    }
  };
  MapCachedCanvasLayerCanvasInstanceClass.SCALE_INVALIDATION_THRESHOLD = 1.2;
  MapCachedCanvasLayerCanvasInstanceClass.tempVec2_1 = new Float64Array(2);
  var MapCachedCanvasLayer = class extends MapCanvasLayer {
    constructor(props) {
      super(props);
      this.size = 0;
      this.referenceMargin = 0;
      this.needUpdateTransforms = false;
      this.props.overdrawFactor = Math.max(1, this.props.overdrawFactor);
    }
    getSize() {
      return this.size;
    }
    getReferenceMargin() {
      return this.referenceMargin;
    }
    onAttached() {
      super.onAttached();
      this.updateFromProjectedSize(this.props.mapProjection.getProjectedSize());
      this.needUpdateTransforms = true;
    }
    createCanvasInstance(canvas, context, isDisplayed) {
      return new MapCachedCanvasLayerCanvasInstanceClass(canvas, context, isDisplayed, this.getReferenceMargin.bind(this));
    }
    updateFromProjectedSize(projectedSize) {
      const projectedWidth = projectedSize[0];
      const projectedHeight = projectedSize[1];
      const diag2 = Math.hypot(projectedWidth, projectedHeight);
      this.size = diag2 * this.props.overdrawFactor;
      this.referenceMargin = (this.size - diag2) / 2;
      this.setWidth(this.size);
      this.setHeight(this.size);
      const posX = (projectedWidth - this.size) / 2;
      const posY = (projectedHeight - this.size) / 2;
      const displayCanvas = this.display.canvas;
      displayCanvas.style.left = `${posX}px`;
      displayCanvas.style.top = `${posY}px`;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      var _a;
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateFromProjectedSize(mapProjection.getProjectedSize());
        this.display.invalidate();
        (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.invalidate();
      }
      this.needUpdateTransforms = true;
    }
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (!this.needUpdateTransforms) {
        return;
      }
      this.updateTransforms();
    }
    updateTransforms() {
      var _a;
      const mapProjection = this.props.mapProjection;
      this.display.updateTransform(mapProjection);
      (_a = this.tryGetBuffer()) === null || _a === void 0 ? void 0 : _a.updateTransform(mapProjection);
      this.needUpdateTransforms = false;
    }
  };
  var MapLabeledRingLabelClass = class {
    constructor(content, wrapper) {
      this.content = content;
      this.wrapper = wrapper;
      this.center = new Float64Array(2);
      this.radius = 0;
      this.anchor = new Float64Array(2);
      this.radialAngle = 0;
      this.radialOffset = 0;
    }
    getAnchor() {
      return this.anchor;
    }
    getRadialAngle() {
      return this.radialAngle;
    }
    getRadialOffset() {
      return this.radialOffset;
    }
    setAnchor(anchor) {
      this.anchor.set(anchor);
      this.wrapper.style.transform = `translate(${-anchor[0] * 100}%, ${-anchor[1] * 100}%)`;
    }
    setRadialAngle(angle) {
      if (this.radialAngle === angle) {
        return;
      }
      this.radialAngle = angle;
      this.updatePosition();
    }
    setRadialOffset(offset) {
      if (this.radialOffset === offset) {
        return;
      }
      this.radialOffset = offset;
      this.updatePosition();
    }
    setRingPosition(center, radius) {
      if (Vec2Math.equals(this.center, center) && radius === this.radius) {
        return;
      }
      this.center.set(center);
      this.radius = radius;
      this.updatePosition();
    }
    updatePosition() {
      const pos = MapLabeledRingLabelClass.tempVec2_1;
      Vec2Math.setFromPolar(this.radius + this.radialOffset, this.radialAngle, pos);
      Vec2Math.add(this.center, pos, pos);
      this.wrapper.style.left = `${pos[0]}px`;
      this.wrapper.style.top = `${pos[1]}px`;
    }
  };
  MapLabeledRingLabelClass.tempVec2_1 = new Float64Array(2);
  var MapOwnAirplaneLayer = class extends MapLayer {
    constructor() {
      super(...arguments);
      this.imageFilePath = SubscribableUtils.isSubscribable(this.props.imageFilePath) ? this.props.imageFilePath.map(SubscribableMapFunctions.identity()) : this.props.imageFilePath;
      this.style = ObjectSubject.create({
        display: "",
        position: "absolute",
        left: "0px",
        top: "0px",
        width: "0px",
        height: "0px",
        transform: "translate3d(0, 0, 0) rotate(0deg)",
        "transform-origin": "50% 50%"
      });
      this.ownAirplanePropsModule = this.props.model.getModule("ownAirplaneProps");
      this.ownAirplaneIconModule = this.props.model.getModule("ownAirplaneIcon");
      this.iconSize = SubscribableUtils.toSubscribable(this.props.iconSize, true);
      this.iconAnchor = SubscribableUtils.toSubscribable(this.props.iconAnchor, true);
      this.iconOffset = Vec2Math.create();
      this.visibilityBounds = VecNMath.create(4);
      this.iconTransform = CssTransformBuilder.concat(CssTransformBuilder.translate3d("px"), CssTransformBuilder.rotate("deg"));
      this.isGsAboveTrackThreshold = this.ownAirplanePropsModule.groundSpeed.map((gs) => gs.asUnit(UnitType.KNOT) >= 5).pause();
      this.showIcon = true;
      this.isInsideVisibilityBounds = true;
      this.planeRotation = 0;
      this.needUpdateVisibility = false;
      this.needUpdatePositionRotation = false;
    }
    onVisibilityChanged(isVisible) {
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = this.showIcon = isVisible && this.ownAirplaneIconModule.show.get();
    }
    onAttached() {
      this.showSub = this.ownAirplaneIconModule.show.sub((show) => {
        this.needUpdateVisibility = true;
        this.needUpdatePositionRotation = this.showIcon = show && this.isVisible();
      });
      this.positionSub = this.ownAirplanePropsModule.position.sub(() => {
        this.needUpdatePositionRotation = this.showIcon;
      });
      this.headingSub = this.ownAirplanePropsModule.hdgTrue.sub((hdg) => {
        this.planeRotation = hdg;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackSub = this.ownAirplanePropsModule.trackTrue.sub((track) => {
        this.planeRotation = track;
        this.needUpdatePositionRotation = this.showIcon;
      }, false, true);
      this.trackThresholdSub = this.isGsAboveTrackThreshold.sub((isAboveThreshold) => {
        if (isAboveThreshold) {
          this.headingSub.pause();
          this.trackSub.resume(true);
        } else {
          this.trackSub.pause();
          this.headingSub.resume(true);
        }
      }, false, true);
      this.iconSizeSub = this.iconSize.sub((size2) => {
        this.style.set("width", `${size2}px`);
        this.style.set("height", `${size2}px`);
        this.updateOffset();
      }, true);
      this.iconAnchorSub = this.iconAnchor.sub(() => {
        this.updateOffset();
      });
      this.orientationSub = this.ownAirplaneIconModule.orientation.sub((orientation) => {
        switch (orientation) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.trackSub.pause();
            this.headingSub.resume(true);
            break;
          case MapOwnAirplaneIconOrientation.TrackUp:
            this.headingSub.pause();
            this.trackSub.pause();
            this.isGsAboveTrackThreshold.resume();
            this.trackThresholdSub.resume(true);
            break;
          default:
            this.needUpdatePositionRotation = this.showIcon;
            this.isGsAboveTrackThreshold.pause();
            this.trackThresholdSub.pause();
            this.headingSub.pause();
            this.trackSub.pause();
            this.planeRotation = 0;
        }
      }, true);
      this.needUpdateVisibility = true;
      this.needUpdatePositionRotation = true;
    }
    updateOffset() {
      const anchor = this.iconAnchor.get();
      this.iconOffset.set(anchor);
      Vec2Math.multScalar(this.iconOffset, -this.iconSize.get(), this.iconOffset);
      this.style.set("left", `${this.iconOffset[0]}px`);
      this.style.set("top", `${this.iconOffset[1]}px`);
      this.style.set("transform-origin", `${anchor[0] * 100}% ${anchor[1] * 100}%`);
      this.updateVisibilityBounds();
    }
    updateVisibilityBounds() {
      const size2 = this.iconSize.get();
      const maxProtrusion = Math.max(
        Math.hypot(this.iconOffset[0], this.iconOffset[1]),
        Math.hypot(this.iconOffset[0] + size2, this.iconOffset[1]),
        Math.hypot(this.iconOffset[0] + size2, this.iconOffset[1] + size2),
        Math.hypot(this.iconOffset[0], this.iconOffset[1] + size2)
      );
      const boundsOffset = maxProtrusion + 50;
      const projectedSize = this.props.mapProjection.getProjectedSize();
      this.visibilityBounds[0] = -boundsOffset;
      this.visibilityBounds[1] = -boundsOffset;
      this.visibilityBounds[2] = projectedSize[0] + boundsOffset;
      this.visibilityBounds[3] = projectedSize[1] + boundsOffset;
      this.needUpdatePositionRotation = this.showIcon;
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateVisibilityBounds();
      }
      this.needUpdatePositionRotation = this.showIcon;
    }
    onUpdated(time, elapsed) {
      if (this.needUpdatePositionRotation) {
        this.updateIconPositionRotation();
        this.needUpdatePositionRotation = false;
        this.needUpdateVisibility = false;
      } else if (this.needUpdateVisibility) {
        this.updateIconVisibility();
        this.needUpdateVisibility = false;
      }
    }
    updateIconVisibility() {
      this.style.set("display", this.isInsideVisibilityBounds && this.showIcon ? "" : "none");
    }
    updateIconPositionRotation() {
      const projected = this.props.mapProjection.project(this.ownAirplanePropsModule.position.get(), MapOwnAirplaneLayer.vec2Cache[0]);
      this.isInsideVisibilityBounds = this.props.mapProjection.isInProjectedBounds(projected, this.visibilityBounds);
      if (this.isInsideVisibilityBounds) {
        let rotation;
        switch (this.ownAirplaneIconModule.orientation.get()) {
          case MapOwnAirplaneIconOrientation.HeadingUp:
          case MapOwnAirplaneIconOrientation.TrackUp:
            rotation = this.planeRotation + this.props.mapProjection.getRotation() * Avionics.Utils.RAD2DEG;
            break;
          default:
            rotation = 0;
        }
        this.iconTransform.getChild(0).set(projected[0], projected[1], 0, 0.1);
        this.iconTransform.getChild(1).set(rotation, 0.1);
        this.style.set("transform", this.iconTransform.resolve());
      }
      this.updateIconVisibility();
    }
    render() {
      var _a;
      return FSComponent.buildComponent("img", { src: this.imageFilePath, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "", style: this.style });
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (SubscribableUtils.isSubscribable(this.imageFilePath)) {
        this.imageFilePath.destroy();
      }
      this.isGsAboveTrackThreshold.destroy();
      (_a = this.showSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.positionSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.headingSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.trackSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.trackThresholdSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.iconSizeSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.iconAnchorSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.orientationSub) === null || _h === void 0 ? void 0 : _h.destroy();
      super.destroy();
    }
  };
  MapOwnAirplaneLayer.vec2Cache = [Vec2Math.create()];
  var MapCullableTextLayer = class extends MapSyncedCanvasLayer {
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      this.props.manager.update(this.props.mapProjection);
      this.redrawLabels();
    }
    redrawLabels() {
      const labels = this.props.manager.visibleLabels;
      const display = this.display;
      display.clear();
      for (let i = labels.length - 1; i >= 0; i--) {
        labels[i].draw(display.context, this.props.mapProjection);
      }
    }
  };
  var MapAirspaceLayer = class extends MapLayer {
    constructor() {
      var _a, _b;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.clipBoundsSub = VecNSubject.createFromVector(new Float64Array(4));
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), async () => {
        this.searchSession = new NearestLodBoundarySearchSession(this.props.lodBoundaryCache, await this.facLoader.startNearestSearchSession(FacilitySearchType.Boundary), 0.5);
        this.isAttached && this.scheduleSearch(0, true);
      });
      this.searchedAirspaces = /* @__PURE__ */ new Map();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY;
      this.renderTimeBudget = (_b = this.props.renderTimeBudget) !== null && _b !== void 0 ? _b : MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET;
      this.activeRenderProcess = null;
      this.renderTaskQueueHandler = {
        renderTimeBudget: this.renderTimeBudget,
        onStarted() {
        },
        canContinue(elapsedFrameCount, dispatchedTaskCount, timeElapsed) {
          return timeElapsed < this.renderTimeBudget;
        },
        onPaused: this.onRenderPaused.bind(this),
        onFinished: this.onRenderFinished.bind(this),
        onAborted: this.onRenderAborted.bind(this)
      };
      this.searchDebounceTimer = 0;
      this.isSearchScheduled = false;
      this.needRefilter = false;
      this.isSearchBusy = false;
      this.lastDesiredSearchRadius = 0;
      this.lastSearchRadius = 0;
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
      this.isDisplayInvalidated = true;
      this.isAttached = false;
    }
    onAttached() {
      this.canvasLayerRef.instance.onAttached();
      this.updateClipBounds();
      this.clippedPathStream = new ClippedPathStream(this.canvasLayerRef.instance.buffer.context, this.clipBoundsSub);
      this.props.maxSearchRadius.sub((radius) => {
        const radiusMeters = radius.asUnit(UnitType.METER);
        if (radiusMeters < this.lastSearchRadius || radiusMeters > this.lastDesiredSearchRadius) {
          this.scheduleSearch(0, false);
        }
      });
      this.props.maxSearchItemCount.sub(() => {
        this.scheduleSearch(0, false);
      });
      this.initModuleListeners();
      this.isAttached = true;
      this.searchSession && this.scheduleSearch(0, true);
    }
    initModuleListeners() {
      const airspaceModule = this.props.model.getModule("airspace");
      for (const type of Object.values(airspaceModule.show)) {
        type.sub(this.onAirspaceTypeShowChanged.bind(this));
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.updateClipBounds();
      }
    }
    updateClipBounds() {
      const size2 = this.canvasLayerRef.instance.getSize();
      this.clipBoundsSub.set(-MapAirspaceLayer.CLIP_BOUNDS_BUFFER, -MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size2 + MapAirspaceLayer.CLIP_BOUNDS_BUFFER, size2 + MapAirspaceLayer.CLIP_BOUNDS_BUFFER);
    }
    scheduleSearch(delay, refilter) {
      if (!this.searchSession) {
        return;
      }
      this.searchDebounceTimer = delay;
      this.isSearchScheduled = true;
      this.needRefilter || (this.needRefilter = refilter);
    }
    scheduleRender() {
      this.isRenderScheduled = true;
    }
    async searchAirspaces(refilter) {
      this.isSearchBusy = true;
      const center = this.props.mapProjection.getCenter();
      const drawableDiag = this.canvasLayerRef.instance.display.canvas.width * Math.SQRT2;
      this.lastDesiredSearchRadius = UnitType.GA_RADIAN.convertTo(this.props.mapProjection.getProjectedResolution() * drawableDiag / 2, UnitType.METER);
      this.lastSearchRadius = Math.min(this.props.maxSearchRadius.get().asUnit(UnitType.METER), this.lastDesiredSearchRadius);
      const session = this.searchSession;
      refilter && session.setFilter(this.getBoundaryFilter());
      const results = await session.searchNearest(center.lat, center.lon, this.lastSearchRadius, this.props.maxSearchItemCount.get());
      for (let i = 0; i < results.added.length; i++) {
        const airspace = results.added[i];
        this.searchedAirspaces.set(airspace.facility.id, airspace);
      }
      for (let i = 0; i < results.removed.length; i++) {
        this.searchedAirspaces.delete(results.removed[i]);
      }
      this.isSearchBusy = false;
      this.scheduleRender();
    }
    getBoundaryFilter() {
      const module2 = this.props.model.getModule("airspace");
      const show = module2.show;
      let filter = 0;
      for (const type in show) {
        if (show[type].get()) {
          filter |= module2.showTypes[type];
        }
      }
      return filter;
    }
    onUpdated(time, elapsed) {
      this.canvasLayerRef.instance.onUpdated(time, elapsed);
      this.updateFromInvalidation();
      this.updateScheduledRender();
      this.updateScheduledSearch(elapsed);
    }
    updateFromInvalidation() {
      const canvasLayer = this.canvasLayerRef.instance;
      const display = canvasLayer.display;
      const buffer = canvasLayer.buffer;
      const needBackgroundRender = !this.isBackgroundRenderScheduled && !this.activeRenderProcess && display.transform.marginRemaining / display.transform.margin <= MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD;
      const shouldScheduleSearch = needBackgroundRender || display.isInvalid || buffer.isInvalid && this.activeRenderProcess;
      this.isBackgroundRenderScheduled || (this.isBackgroundRenderScheduled = needBackgroundRender);
      if (display.isInvalid) {
        this.isDisplayInvalidated = true;
        this.isBackgroundRenderScheduled = false;
        display.clear();
        display.syncWithMapProjection(this.props.mapProjection);
      }
      if (buffer.isInvalid) {
        if (this.activeRenderProcess) {
          this.activeRenderProcess.abort();
          this.cleanUpRender();
        }
        buffer.clear();
        buffer.syncWithMapProjection(this.props.mapProjection);
      }
      if (shouldScheduleSearch) {
        this.scheduleSearch(this.searchDebounceDelay, false);
      }
    }
    updateScheduledSearch(elapsed) {
      if (!this.isSearchScheduled) {
        return;
      }
      this.searchDebounceTimer = Math.max(0, this.searchDebounceTimer - elapsed);
      if (this.searchDebounceTimer === 0 && !this.isSearchBusy) {
        this.searchAirspaces(this.needRefilter);
        this.isSearchScheduled = false;
        this.needRefilter = false;
      }
    }
    updateScheduledRender() {
      if (!this.isRenderScheduled) {
        return;
      }
      this.startRenderProcess();
      this.isRenderScheduled = false;
      this.isBackgroundRenderScheduled = false;
    }
    startRenderProcess() {
      const canvasLayer = this.canvasLayerRef.instance;
      if (this.activeRenderProcess) {
        this.activeRenderProcess.abort();
      }
      const buffer = canvasLayer.buffer;
      buffer.clear();
      buffer.syncWithMapProjection(this.props.mapProjection);
      this.props.airspaceRenderManager.clearRegisteredAirspaces();
      for (const airspace of this.searchedAirspaces.values()) {
        if (this.isAirspaceInBounds(airspace, buffer)) {
          this.props.airspaceRenderManager.registerAirspace(airspace);
        }
      }
      const lod = this.selectLod(this.props.mapProjection.getProjectedResolution());
      this.activeRenderProcess = this.props.airspaceRenderManager.prepareRenderProcess(buffer.geoProjection, buffer.context, this.renderTaskQueueHandler, lod, this.clippedPathStream);
      this.activeRenderProcess.start();
    }
    isAirspaceInBounds(airspace, canvas) {
      const corner = MapAirspaceLayer.geoPointCache[0];
      const cornerProjected = MapAirspaceLayer.vec2Cache[0];
      let minX, maxX, minY, maxY;
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = maxX = cornerProjected[0];
      minY = maxY = cornerProjected[1];
      canvas.geoProjection.project(corner.set(airspace.facility.topLeft.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.bottomRight.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      canvas.geoProjection.project(corner.set(airspace.facility.bottomRight.lat, airspace.facility.topLeft.long), cornerProjected);
      minX = Math.min(minX, cornerProjected[0]);
      maxX = Math.max(maxX, cornerProjected[0]);
      minY = Math.min(minY, cornerProjected[1]);
      maxY = Math.max(maxY, cornerProjected[1]);
      const width = canvas.canvas.width;
      const height = canvas.canvas.height;
      return minX < width && maxX > 0 && minY < height && maxY > 0;
    }
    selectLod(resolution) {
      const thresholds = this.props.lodBoundaryCache.lodDistanceThresholds;
      let i = thresholds.length - 1;
      while (i >= 0) {
        if (resolution * 2 >= thresholds[i]) {
          break;
        }
        i--;
      }
      return i;
    }
    cleanUpRender() {
      this.canvasLayerRef.instance.buffer.reset();
      this.activeRenderProcess = null;
    }
    renderAirspacesToDisplay() {
      const display = this.canvasLayerRef.instance.display;
      const buffer = this.canvasLayerRef.instance.buffer;
      display.clear();
      display.syncWithCanvasInstance(buffer);
      this.canvasLayerRef.instance.copyBufferToDisplay();
    }
    onRenderPaused() {
      if (this.isDisplayInvalidated) {
        this.renderAirspacesToDisplay();
      }
    }
    onRenderFinished() {
      this.renderAirspacesToDisplay();
      this.cleanUpRender();
      this.isDisplayInvalidated = false;
    }
    onRenderAborted() {
      this.cleanUpRender();
    }
    onAirspaceTypeShowChanged() {
      this.scheduleSearch(0, true);
    }
    render() {
      return FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, useBuffer: true, overdrawFactor: Math.SQRT2 });
    }
  };
  MapAirspaceLayer.DEFAULT_SEARCH_DEBOUNCE_DELAY = 500;
  MapAirspaceLayer.DEFAULT_RENDER_TIME_BUDGET = 0.2;
  MapAirspaceLayer.BACKGROUND_RENDER_MARGIN_THRESHOLD = 0.1;
  MapAirspaceLayer.CLIP_BOUNDS_BUFFER = 10;
  MapAirspaceLayer.geoPointCache = [new GeoPoint(0, 0)];
  MapAirspaceLayer.vec2Cache = [new Float64Array(2)];
  var MapNearestWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.canvasLayerRef = FSComponent.createRef();
      this.searchDebounceDelay = (_a = this.props.searchDebounceDelay) !== null && _a !== void 0 ? _a : 500;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus), this.onFacilityLoaderInitialized.bind(this));
      this.searchRadius = 0;
      this.searchMargin = 0;
      this.userFacilityHasChanged = false;
      this.icaosToRender = /* @__PURE__ */ new Set();
      this.cachedRenderedWaypoints = /* @__PURE__ */ new Map();
      this.isInit = false;
      this.facilityRepoSubs = [];
    }
    onFacilityLoaderInitialized() {
      Promise.all([
        this.facLoader.startNearestSearchSession(FacilitySearchType.Airport),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Vor),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Ndb),
        this.facLoader.startNearestSearchSession(FacilitySearchType.Intersection),
        this.facLoader.startNearestSearchSession(FacilitySearchType.User)
      ]).then((value) => {
        const [airportSession, vorSession, ndbSession, intSession, userSession] = value;
        this.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      });
    }
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession) {
      const callback = this.processSearchResults.bind(this);
      this.facilitySearches = {
        [FacilitySearchType.Airport]: new MapNearestWaypointsLayerSearch(airportSession, callback),
        [FacilitySearchType.Vor]: new MapNearestWaypointsLayerSearch(vorSession, callback),
        [FacilitySearchType.Ndb]: new MapNearestWaypointsLayerSearch(ndbSession, callback),
        [FacilitySearchType.Intersection]: new MapNearestWaypointsLayerSearch(intSession, callback),
        [FacilitySearchType.User]: new MapNearestWaypointsLayerSearch(userSession, callback)
      };
      const sub2 = this.props.bus.getSubscriber();
      this.facilityRepoSubs.push(sub2.on("facility_added").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub2.on("facility_changed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }), sub2.on("facility_removed").handle((fac) => {
        if (ICAO.isFacility(fac.icao, FacilityType.USR)) {
          this.userFacilityHasChanged = true;
        }
      }));
      this.props.onSessionsStarted && this.props.onSessionsStarted(airportSession, vorSession, ndbSession, intSession, userSession);
      if (this.isInit) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    onAttached() {
      super.onAttached();
      this.canvasLayerRef.instance.onAttached();
      this.doInit();
      this.isInit = true;
      this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
    }
    doInit() {
      this.initWaypointRenderer();
      this.updateSearchRadius();
    }
    getSearchCenter() {
      return this.props.getSearchCenter ? this.props.getSearchCenter(this.props.mapProjection) : this.props.mapProjection.getCenter();
    }
    initWaypointRenderer() {
      this.props.initRenderer && this.props.initRenderer(this.props.waypointRenderer, this.canvasLayerRef.instance);
    }
    refreshWaypoints() {
      this.tryRefreshAllSearches(void 0, void 0, true);
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.deregisterWaypoint(w, this.props.waypointRenderer);
      });
      this.cachedRenderedWaypoints.forEach((w) => {
        this.props.registerWaypoint(w, this.props.waypointRenderer);
      });
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.canvasLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAny(changeFlags, MapProjectionChangeType.Range | MapProjectionChangeType.RangeEndpoints | MapProjectionChangeType.ProjectedSize)) {
        this.updateSearchRadius();
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      } else if (BitFlags.isAll(changeFlags, MapProjectionChangeType.Center)) {
        this._tryRefreshAllSearches(this.getSearchCenter(), this.searchRadius);
      }
    }
    updateSearchRadius() {
      let mapHalfDiagRange = Vec2Math.abs(this.props.mapProjection.getProjectedSize()) * this.props.mapProjection.getProjectedResolution() / 2;
      mapHalfDiagRange = Math.max(mapHalfDiagRange, UnitType.NMILE.convertTo(5, UnitType.GA_RADIAN));
      this.searchRadius = mapHalfDiagRange * MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR;
      this.searchMargin = mapHalfDiagRange * (MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR - 1);
    }
    onUpdated(time, elapsed) {
      var _a;
      if (this.userFacilityHasChanged) {
        const search = (_a = this.facilitySearches) === null || _a === void 0 ? void 0 : _a[FacilitySearchType.User];
        if (search !== void 0) {
          this.userFacilityHasChanged = false;
          this.scheduleSearchRefresh(FacilitySearchType.User, search, this.getSearchCenter(), this.searchRadius);
        }
      }
      this.updateSearches(elapsed);
    }
    updateSearches(elapsed) {
      if (!this.facilitySearches) {
        return;
      }
      this.facilitySearches[FacilitySearchType.Airport].update(elapsed);
      this.facilitySearches[FacilitySearchType.Vor].update(elapsed);
      this.facilitySearches[FacilitySearchType.Ndb].update(elapsed);
      this.facilitySearches[FacilitySearchType.Intersection].update(elapsed);
      this.facilitySearches[FacilitySearchType.User].update(elapsed);
    }
    tryRefreshAllSearches(center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshAllSearches(center, radius, force);
    }
    tryRefreshSearch(type, center, radius, force) {
      center !== null && center !== void 0 ? center : center = this.getSearchCenter();
      radius !== null && radius !== void 0 ? radius : radius = this.searchRadius;
      this._tryRefreshSearch(type, center, radius, force);
    }
    _tryRefreshAllSearches(center, radius, force) {
      this._tryRefreshSearch(FacilitySearchType.Airport, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Vor, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Ndb, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.Intersection, center, radius, force);
      this._tryRefreshSearch(FacilitySearchType.User, center, radius, force);
    }
    _tryRefreshSearch(type, center, radius, force) {
      const search = this.facilitySearches && this.facilitySearches[type];
      if (!search || !force && !this.shouldRefreshSearch(type, center, radius)) {
        return;
      }
      const radiusLimit = this.props.searchRadiusLimit ? this.props.searchRadiusLimit(type, center, radius) : void 0;
      if (radiusLimit !== void 0 && isFinite(radiusLimit)) {
        radius = Math.min(radius, Math.max(0, radiusLimit));
      }
      if (force || search.lastRadius !== radius || search.lastCenter.distance(center) >= this.searchMargin) {
        this.scheduleSearchRefresh(type, search, center, radius);
      }
    }
    shouldRefreshSearch(type, center, radius) {
      return this.props.shouldRefreshSearch ? this.props.shouldRefreshSearch(type, center, radius) : true;
    }
    scheduleSearchRefresh(type, search, center, radius) {
      const itemLimit = this.props.searchItemLimit ? this.props.searchItemLimit(type, center, radius) : 100;
      search.scheduleRefresh(center, radius, itemLimit, this.searchDebounceDelay);
    }
    processSearchResults(results) {
      if (!results) {
        return;
      }
      const numAdded = results.added.length;
      for (let i = 0; i < numAdded; i++) {
        const icao = results.added[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.registerIcao(icao);
      }
      const numRemoved = results.removed.length;
      for (let i = 0; i < numRemoved; i++) {
        const icao = results.removed[i];
        if (icao === void 0 || icao === ICAO.emptyIcao) {
          continue;
        }
        this.deregisterIcao(icao);
      }
    }
    async registerIcao(icao) {
      this.icaosToRender.add(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (!this.icaosToRender.has(icao)) {
          return;
        }
        this.registerWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
      }
    }
    registerWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.set(facility.icao, waypoint);
      this.props.registerWaypoint(waypoint, renderer);
    }
    async deregisterIcao(icao) {
      this.icaosToRender.delete(icao);
      try {
        const facility = await this.facLoader.getFacility(ICAO.getFacilityType(icao), icao);
        if (this.icaosToRender.has(icao)) {
          return;
        }
        this.deregisterWaypointWithRenderer(this.props.waypointRenderer, facility);
      } catch (_a) {
        if (this.icaosToRender.has(icao)) {
          return;
        }
        const cachedWaypoint = this.cachedRenderedWaypoints.get(icao);
        if (cachedWaypoint !== void 0) {
          this.cachedRenderedWaypoints.delete(icao);
          this.props.deregisterWaypoint(cachedWaypoint, this.props.waypointRenderer);
        }
      }
    }
    deregisterWaypointWithRenderer(renderer, facility) {
      const waypoint = this.props.waypointForFacility(facility);
      this.cachedRenderedWaypoints.delete(facility.icao);
      this.props.deregisterWaypoint(waypoint, renderer);
    }
    setVisible(val) {
      super.setVisible(val);
      this.canvasLayerRef.instance.setVisible(val);
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.canvasLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    destroy() {
      var _a;
      (_a = this.canvasLayerRef.getOrDefault()) === null || _a === void 0 ? void 0 : _a.destroy();
      this.facilityRepoSubs.forEach((sub2) => {
        sub2.destroy();
      });
      super.destroy();
    }
  };
  MapNearestWaypointsLayer.SEARCH_RADIUS_OVERDRAW_FACTOR = Math.SQRT2;
  var MapNearestWaypointsLayerSearch = class {
    constructor(session, refreshCallback) {
      this.session = session;
      this.refreshCallback = refreshCallback;
      this._lastCenter = new GeoPoint(0, 0);
      this._lastRadius = 0;
      this.maxItemCount = 0;
      this.refreshDebounceTimer = 0;
      this.isRefreshScheduled = false;
    }
    get lastCenter() {
      return this._lastCenter.readonly;
    }
    get lastRadius() {
      return this._lastRadius;
    }
    scheduleRefresh(center, radius, maxItemCount, delay) {
      this._lastCenter.set(center);
      this._lastRadius = radius;
      this.maxItemCount = maxItemCount;
      if (!this.isRefreshScheduled) {
        this.refreshDebounceTimer = delay;
        this.isRefreshScheduled = true;
      }
    }
    update(elapsed) {
      if (!this.isRefreshScheduled) {
        return;
      }
      this.refreshDebounceTimer = Math.max(0, this.refreshDebounceTimer - elapsed);
      if (this.refreshDebounceTimer === 0) {
        this.refresh();
        this.isRefreshScheduled = false;
      }
    }
    async refresh() {
      const results = await this.session.searchNearest(this._lastCenter.lat, this._lastCenter.lon, UnitType.GA_RADIAN.convertTo(this._lastRadius, UnitType.METER), this.maxItemCount);
      this.refreshCallback(results);
    }
  };
  var MapLineLayer = class extends MapSyncedCanvasLayer {
    constructor() {
      var _a, _b, _c, _d, _e, _f;
      super(...arguments);
      this.strokeWidth = (_a = this.props.strokeWidth) !== null && _a !== void 0 ? _a : MapLineLayer.DEFAULT_STROKE_WIDTH;
      this.strokeStyle = (_b = this.props.strokeStyle) !== null && _b !== void 0 ? _b : MapLineLayer.DEFAULT_STROKE_STYLE;
      this.strokeDash = (_c = this.props.strokeDash) !== null && _c !== void 0 ? _c : MapLineLayer.DEFAULT_STROKE_DASH;
      this.outlineWidth = (_d = this.props.outlineWidth) !== null && _d !== void 0 ? _d : MapLineLayer.DEFAULT_OUTLINE_WIDTH;
      this.outlineStyle = (_e = this.props.outlineStyle) !== null && _e !== void 0 ? _e : MapLineLayer.DEFAULT_OUTLINE_STYLE;
      this.outlineDash = (_f = this.props.outlineDash) !== null && _f !== void 0 ? _f : MapLineLayer.DEFAULT_OUTLINE_DASH;
      this.vec = new Float64Array([0, 0]);
      this.isUpdateScheduled = false;
    }
    onAttached() {
      super.onAttached();
      this.props.start.sub(() => {
        this.scheduleUpdate();
      });
      this.props.end.sub(() => {
        this.scheduleUpdate();
      });
      this.scheduleUpdate();
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.scheduleUpdate();
    }
    scheduleUpdate() {
      this.isUpdateScheduled = true;
    }
    onUpdated(time, elapsed) {
      super.onUpdated(time, elapsed);
      if (this.isUpdateScheduled) {
        this.display.clear();
        const start = this.props.start.get();
        const end = this.props.end.get();
        if (start !== null && end !== null) {
          const [x1, y1] = start instanceof Float64Array ? start : this.props.mapProjection.project(start, this.vec);
          const [x2, y2] = end instanceof Float64Array ? end : this.props.mapProjection.project(end, this.vec);
          this.drawLine(x1, y1, x2, y2);
        }
        this.isUpdateScheduled = false;
      }
    }
    drawLine(x1, y1, x2, y2) {
      const context = this.display.context;
      context.beginPath();
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      if (this.outlineWidth > 0) {
        this.stroke(context, this.strokeWidth + this.outlineWidth * 2, this.outlineStyle, this.outlineDash);
      }
      if (this.strokeWidth > 0) {
        this.stroke(context, this.strokeWidth, this.strokeStyle, this.strokeDash);
      }
    }
    stroke(context, width, style, dash) {
      context.lineWidth = width;
      context.strokeStyle = style;
      context.setLineDash(dash);
      context.stroke();
    }
  };
  MapLineLayer.DEFAULT_STROKE_WIDTH = 2;
  MapLineLayer.DEFAULT_STROKE_STYLE = "white";
  MapLineLayer.DEFAULT_STROKE_DASH = [];
  MapLineLayer.DEFAULT_OUTLINE_WIDTH = 0;
  MapLineLayer.DEFAULT_OUTLINE_STYLE = "black";
  MapLineLayer.DEFAULT_OUTLINE_DASH = [];
  var MapSystemController = class {
    constructor(context) {
      this._isAlive = true;
      this.context = context;
    }
    get isAlive() {
      return this._isAlive;
    }
    onAfterMapRender(ref) {
    }
    onDeadZoneChanged(deadZone) {
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
    }
    onBeforeUpdated(time, elapsed) {
    }
    onAfterUpdated(time, elapsed) {
    }
    onWake() {
    }
    onSleep() {
    }
    onMapDestroyed() {
    }
    destroy() {
      this._isAlive = false;
    }
  };
  var MapBindingsController = class extends MapSystemController {
    constructor(context, bindings, onDestroy) {
      super(context);
      this.bindings = bindings;
      this.onDestroy = onDestroy;
      this.maps = [];
      this.pipes = [];
    }
    onAfterMapRender() {
      for (const binding of this.bindings) {
        if ("map" in binding) {
          if ("sources" in binding) {
            const map = MappedSubject.create(...binding.sources);
            this.maps.push(map);
            this.pipes.push(map.pipe(binding.target, binding.map));
          } else {
            this.pipes.push(binding.source.pipe(binding.target, binding.map));
          }
        } else {
          this.pipes.push(binding.source.pipe(binding.target));
        }
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    onWake() {
      this.maps.forEach((map) => {
        map.resume();
      });
      this.pipes.forEach((pipe) => {
        pipe.resume(true);
      });
    }
    onSleep() {
      this.maps.forEach((map) => {
        map.pause();
      });
      this.pipes.forEach((pipe) => {
        pipe.pause();
      });
    }
    destroy() {
      this.onDestroy && this.onDestroy();
      this.maps.forEach((map) => {
        map.destroy();
      });
      this.pipes.forEach((pipe) => {
        pipe.destroy();
      });
      super.destroy();
    }
  };
  var MapClockUpdateController = class extends MapSystemController {
    onAfterMapRender(ref) {
      this.freqSub = this.context.updateFreq.sub((freq) => {
        var _a;
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.clockSub = this.context.bus.getSubscriber().on("realTime").atFrequency(freq).handle((realTime) => {
          ref.update(realTime);
        });
      }, true);
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.freqSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
  };
  var MapFlightPlanController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.flightPlanModule = this.context.model.getModule(MapSystemKeys.FlightPlan);
      this.planCopiedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.targetPlanIndex));
        this.flightPlanModule.getPlanSubjects(evt.targetPlanIndex).planChanged.notify(this);
      };
      this.planCreatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(this.context[MapSystemKeys.FlightPlanner].getFlightPlan(evt.planIndex));
      };
      this.planDeletedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).flightPlan.set(void 0);
      };
      this.planChangeHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planChanged.notify(this);
      };
      this.planCalculatedHandler = (evt) => {
        this.flightPlanModule.getPlanSubjects(evt.planIndex).planCalculated.notify(this);
      };
      this.activeLegChangedHandler = (evt) => {
        if (evt.type === ActiveLegType.Lateral) {
          this.flightPlanModule.getPlanSubjects(evt.planIndex).activeLeg.set(evt.index);
        }
      };
    }
    onAfterMapRender() {
      const sub2 = this.context.bus.getSubscriber();
      this.fplCopiedSub = sub2.on("fplCopied").handle(this.planCopiedHandler);
      this.fplCreatedSub = sub2.on("fplCreated").handle(this.planCreatedHandler);
      this.fplDeletedSub = sub2.on("fplDeleted").handle(this.planDeletedHandler);
      this.fplDirectToDataChangedSub = sub2.on("fplDirectToDataChanged").handle(this.planChangeHandler);
      this.fplLoadedSub = sub2.on("fplLoaded").handle(this.planCreatedHandler);
      this.fplOriginDestChangedSub = sub2.on("fplOriginDestChanged").handle(this.planChangeHandler);
      this.fplProcDetailsChangedSub = sub2.on("fplProcDetailsChanged").handle(this.planChangeHandler);
      this.fplSegmentChangeSub = sub2.on("fplSegmentChange").handle(this.planChangeHandler);
      this.fplUserDataDeleteSub = sub2.on("fplUserDataDelete").handle(this.planChangeHandler);
      this.fplUserDataSetSub = sub2.on("fplUserDataSet").handle(this.planChangeHandler);
      this.fplActiveLegChangeSub = sub2.on("fplActiveLegChange").handle(this.activeLegChangedHandler);
      this.fplCalculatedSub = sub2.on("fplCalculated").handle(this.planCalculatedHandler);
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      super.destroy();
      (_a = this.fplCopiedSub) === null || _a === void 0 ? void 0 : _a.destroy();
      (_b = this.fplCreatedSub) === null || _b === void 0 ? void 0 : _b.destroy();
      (_c = this.fplDeletedSub) === null || _c === void 0 ? void 0 : _c.destroy();
      (_d = this.fplDirectToDataChangedSub) === null || _d === void 0 ? void 0 : _d.destroy();
      (_e = this.fplLoadedSub) === null || _e === void 0 ? void 0 : _e.destroy();
      (_f = this.fplOriginDestChangedSub) === null || _f === void 0 ? void 0 : _f.destroy();
      (_g = this.fplProcDetailsChangedSub) === null || _g === void 0 ? void 0 : _g.destroy();
      (_h = this.fplSegmentChangeSub) === null || _h === void 0 ? void 0 : _h.destroy();
      (_j = this.fplUserDataDeleteSub) === null || _j === void 0 ? void 0 : _j.destroy();
      (_k = this.fplUserDataSetSub) === null || _k === void 0 ? void 0 : _k.destroy();
      (_l = this.fplActiveLegChangeSub) === null || _l === void 0 ? void 0 : _l.destroy();
      (_m = this.fplCalculatedSub) === null || _m === void 0 ? void 0 : _m.destroy();
    }
  };
  var MapFollowAirplaneController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.isFollowingAirplane = this.context.model.getModule(MapSystemKeys.FollowAirplane).isFollowing;
      this.mapProjectionParams = {
        target: new GeoPoint(0, 0)
      };
      this.targetControl = this.context[MapSystemKeys.TargetControl];
      this.targetControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.isFollowingAirplane.set(true);
        },
        onCeded: () => {
          this.isFollowingAirplane.set(false);
        }
      };
    }
    onAfterMapRender() {
      this.targetControl.claim(this.targetControlConsumer);
    }
    onBeforeUpdated() {
      if (this.isFollowingAirplane.get()) {
        this.mapProjectionParams.target.set(this.ownAirplanePropsModule.position.get());
        this.context.projection.setQueued(this.mapProjectionParams);
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      super.destroy();
      this.targetControl.forfeit(this.targetControlConsumer);
    }
  };
  var MapRotation;
  (function(MapRotation2) {
    MapRotation2["Undefined"] = "Undefined";
    MapRotation2["NorthUp"] = "NorthUp";
    MapRotation2["TrackUp"] = "TrackUp";
    MapRotation2["HeadingUp"] = "HeadingUp";
    MapRotation2["DtkUp"] = "DtkUp";
  })(MapRotation || (MapRotation = {}));
  var MapRotationModule = class {
    constructor() {
      this.rotationType = Subject.create(MapRotation.HeadingUp);
    }
  };
  var MapOwnAirplaneIconOrientationController = class extends MapSystemController {
    constructor(context, desiredOrientation) {
      super(context);
      this.ownAirplaneIconModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneIcon);
      this.needUpdateIconOrientation = false;
      this.desiredIconOrientation = SubscribableUtils.toSubscribable(desiredOrientation, true);
      this.orientationState = MappedSubject.create(this.desiredIconOrientation, this.context.model.getModule(MapSystemKeys.Rotation).rotationType);
    }
    onAfterMapRender() {
      var _a;
      (_a = this.orientationState) === null || _a === void 0 ? void 0 : _a.sub(() => {
        this.needUpdateIconOrientation = true;
      }, true);
    }
    onBeforeUpdated() {
      if (this.needUpdateIconOrientation) {
        const [desiredOrientation, rotation] = this.orientationState.get();
        if (desiredOrientation === MapOwnAirplaneIconOrientation.HeadingUp && rotation === MapRotation.HeadingUp || desiredOrientation === MapOwnAirplaneIconOrientation.TrackUp && rotation === MapRotation.TrackUp) {
          this.ownAirplaneIconModule.orientation.set(MapOwnAirplaneIconOrientation.MapUp);
        } else {
          this.ownAirplaneIconModule.orientation.set(desiredOrientation);
        }
        this.needUpdateIconOrientation = false;
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      this.orientationState.destroy();
      super.destroy();
    }
  };
  var MapOwnAirplanePropsController = class extends MapSystemController {
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.subs = {};
    }
    onAfterMapRender() {
      const sub2 = this.context.bus.getSubscriber();
      this.updateFreqSub = this.updateFreq.sub((freq) => {
        var _a;
        for (const property of this.properties) {
          (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
          this.subs[property] = this.bindProperty(sub2, property, freq);
        }
      }, true);
    }
    bindProperty(sub2, property, updateFreq) {
      switch (property) {
        case "position":
          return sub2.on("gps-position").atFrequency(updateFreq).handle((lla) => {
            this.module.position.set(lla.lat, lla.long);
          });
        case "altitude":
          return sub2.on("indicated_alt").atFrequency(updateFreq).handle((alt) => {
            this.module.altitude.set(alt, UnitType.FOOT);
          });
        case "groundSpeed":
          return sub2.on("ground_speed").atFrequency(updateFreq).handle((gs) => {
            this.module.groundSpeed.set(gs, UnitType.KNOT);
          });
        case "hdgTrue":
          return sub2.on("hdg_deg_true").atFrequency(updateFreq).handle((hdg) => {
            this.module.hdgTrue.set(hdg);
          });
        case "trackTrue":
          return sub2.on("track_deg_true").atFrequency(updateFreq).handle((track) => {
            this.module.trackTrue.set(track);
          });
        case "verticalSpeed":
          return sub2.on("vertical_speed").atFrequency(updateFreq).handle((vs) => {
            this.module.verticalSpeed.set(vs, UnitType.FPM);
          });
        case "turnRate":
          return sub2.on("delta_heading_rate").atFrequency(updateFreq).handle((turnRate) => {
            this.module.turnRate.set(turnRate);
          });
        case "isOnGround":
          return sub2.on("on_ground").atFrequency(updateFreq).handle((isOnGround2) => {
            this.module.isOnGround.set(isOnGround2);
          });
        case "magVar":
          return sub2.on("magvar").atFrequency(updateFreq).handle((magVar) => {
            this.module.magVar.set(magVar);
          });
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapRotationController = class extends MapSystemController {
    constructor() {
      super(...arguments);
      this.rotationModule = this.context.model.getModule(MapSystemKeys.Rotation);
      this.ownAirplanePropsModule = this.context.model.getModule(MapSystemKeys.OwnAirplaneProps);
      this.rotationParam = {
        rotation: 0
      };
      this.hasRotationControl = false;
      this.rotationControl = this.context[MapSystemKeys.RotationControl];
      this.rotationControlConsumer = {
        priority: 0,
        onAcquired: () => {
          this.hasRotationControl = true;
        },
        onCeded: () => {
          this.hasRotationControl = false;
        }
      };
      this.rotationFuncs = {
        [MapRotation.NorthUp]: () => 0,
        [MapRotation.HeadingUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.TrackUp]: this.ownAirplanePropsModule === void 0 ? () => 0 : () => this.ownAirplanePropsModule.groundSpeed.get().asUnit(UnitType.KNOT) < 5 ? -this.ownAirplanePropsModule.hdgTrue.get() * Avionics.Utils.DEG2RAD : -this.ownAirplanePropsModule.trackTrue.get() * Avionics.Utils.DEG2RAD,
        [MapRotation.DtkUp]: () => 0
      };
    }
    onAfterMapRender() {
      this.rotationSub = this.rotationModule.rotationType.sub((type) => {
        this.rotationFunc = this.rotationFuncs[type];
      }, true);
      this.rotationControl.claim(this.rotationControlConsumer);
    }
    onBeforeUpdated() {
      if (this.hasRotationControl && this.rotationFunc !== void 0) {
        this.rotationParam.rotation = this.rotationFunc();
        this.context.projection.setQueued(this.rotationParam);
      }
    }
    onMapDestroyed() {
      super.onMapDestroyed();
      this.destroy();
    }
    destroy() {
      var _a;
      super.destroy();
      (_a = this.rotationSub) === null || _a === void 0 ? void 0 : _a.destroy();
      this.rotationControl.forfeit(this.rotationControlConsumer);
    }
  };
  var MapSystemWaypointRoles;
  (function(MapSystemWaypointRoles2) {
    MapSystemWaypointRoles2["Normal"] = "Normal";
    MapSystemWaypointRoles2["FlightPlan"] = "FlightPlan";
  })(MapSystemWaypointRoles || (MapSystemWaypointRoles = {}));
  var MapSystemFlightPlanLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.instanceId = MapSystemFlightPlanLayer.instanceId++;
      this.flightPathLayerRef = FSComponent.createRef();
      this.waypointLayerRef = FSComponent.createRef();
      this.defaultRoleId = (_a = this.props.waypointRenderer.getRoleFromName(MapSystemWaypointRoles.FlightPlan)) !== null && _a !== void 0 ? _a : 0;
      this.planModule = this.props.model.getModule(MapSystemKeys.FlightPlan);
      this.waypointPrefix = `${MapSystemFlightPlanLayer.WAYPOINT_PREFIX}_${this.instanceId}`;
      this.legWaypoints = /* @__PURE__ */ new Map();
      this.waypointsUpdating = false;
      this.waypointId = 0;
      this.facLoader = new FacilityLoader(FacilityRepository.getRepository(this.props.bus));
      this.facWaypointCache = DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.clipBounds = VecNSubject.create(new Float64Array(4));
      this.clippedPathStream = new ClippedPathStream(NullPathStream.INSTANCE, this.clipBounds);
      this.pathStreamStack = new GeoProjectionPathStreamStack(NullPathStream.INSTANCE, this.props.mapProjection.getGeoProjection(), Math.PI / 12, 0.25, 8);
      this.updateScheduled = false;
    }
    onAttached() {
      this.flightPathLayerRef.instance.onAttached();
      this.waypointLayerRef.instance.onAttached();
      this.pathStreamStack.pushPostProjected(this.clippedPathStream);
      this.pathStreamStack.setConsumer(this.flightPathLayerRef.instance.display.context);
      this.initWaypointRenderer();
      this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.sub(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planCalculated.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).planChanged.on(() => this.updateScheduled = true);
      this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.sub(() => this.updateScheduled = true);
      this.props.waypointRenderer.onRolesAdded.on(() => this.initWaypointRenderer());
      super.onAttached();
    }
    initWaypointRenderer() {
      let hasDefaultRole = false;
      const flightPlanRoles = this.props.waypointRenderer.getRoleNamesByGroup(`${MapSystemWaypointRoles.FlightPlan}_${this.props.planIndex}`);
      for (let i = 0; i < flightPlanRoles.length; i++) {
        const roleId = this.props.waypointRenderer.getRoleFromName(flightPlanRoles[i]);
        if (roleId !== void 0) {
          this.props.waypointRenderer.setCanvasContext(roleId, this.waypointLayerRef.instance.display.context);
          this.props.waypointRenderer.setIconFactory(roleId, this.props.iconFactory);
          this.props.waypointRenderer.setLabelFactory(roleId, this.props.labelFactory);
          if (!hasDefaultRole) {
            this.props.flightPathRenderer.defaultRoleId = roleId;
            hasDefaultRole = true;
          }
        }
      }
    }
    onUpdated(time, elapsed) {
      this.flightPathLayerRef.instance.onUpdated(time, elapsed);
      this.waypointLayerRef.instance.onUpdated(time, elapsed);
      if (this.isVisible()) {
        const display = this.flightPathLayerRef.instance.display;
        if (display.isInvalid) {
          display.clear();
          display.syncWithMapProjection(this.props.mapProjection);
          this.updateScheduled = true;
        }
        if (this.updateScheduled) {
          if (!this.waypointsUpdating) {
            this.updateWaypoints();
          }
          const context = display.context;
          display.clear();
          const plan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
          if (plan !== void 0) {
            this.pathStreamStack.setProjection(display.geoProjection);
            this.props.flightPathRenderer.render(plan, void 0, void 0, context, this.pathStreamStack);
          }
          this.updateScheduled = false;
        }
      }
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.flightPathLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      const size2 = this.flightPathLayerRef.instance.getSize();
      this.clipBounds.set(-MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, -MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size2 + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER, size2 + MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER);
    }
    setVisible(val) {
      super.setVisible(val);
      this.waypointLayerRef.instance.setVisible(val);
      this.flightPathLayerRef.instance.setVisible(val);
    }
    async updateWaypoints() {
      if (this.waypointsUpdating) {
        throw new Error("A flight plan waypoint update is already in progress.");
      }
      this.waypointsUpdating = true;
      const flightPlan = this.planModule.getPlanSubjects(this.props.planIndex).flightPlan.get();
      const activeLegIndex = this.planModule.getPlanSubjects(this.props.planIndex).activeLeg.get();
      if (flightPlan === void 0) {
        for (const legWaypoint of this.legWaypoints.values()) {
          const [waypoint, roleId] = legWaypoint;
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
        this.legWaypoints.clear();
        this.waypointsUpdating = false;
        return;
      }
      const activeLeg = flightPlan.tryGetLeg(activeLegIndex);
      const legsToDisplay = /* @__PURE__ */ new Map();
      let legIndex = 0;
      for (const leg of flightPlan.legs()) {
        let roleId = this.defaultRoleId;
        const handler = this.props.flightPathRenderer.legWaypointHandlers.get(this.props.planIndex);
        if (handler !== void 0) {
          roleId = handler(flightPlan, leg, activeLeg, legIndex, activeLegIndex);
        }
        if (roleId !== 0) {
          legsToDisplay.set(leg, roleId);
        }
        legIndex++;
      }
      for (const leg of this.legWaypoints) {
        const [legDefinition, legWaypoint] = leg;
        const [waypoint, roleId] = legWaypoint;
        if (!legsToDisplay.has(legDefinition)) {
          this.props.waypointRenderer.deregister(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.delete(legDefinition);
        }
      }
      const waypointRefreshes = [];
      for (const leg of legsToDisplay) {
        waypointRefreshes.push(this.buildPlanWaypoint(leg[0], leg[1]));
      }
      await Promise.all(waypointRefreshes);
      this.waypointsUpdating = false;
    }
    async buildPlanWaypoint(leg, roleId) {
      switch (leg.leg.type) {
        case LegType2.CD:
        case LegType2.VD:
        case LegType2.CR:
        case LegType2.VR:
        case LegType2.FC:
        case LegType2.FD:
        case LegType2.FA:
        case LegType2.CA:
        case LegType2.VA:
        case LegType2.FM:
        case LegType2.VM:
        case LegType2.CI:
        case LegType2.VI:
          await this.buildTerminatorWaypoint(leg, roleId);
          break;
        case LegType2.Discontinuity:
        case LegType2.ThruDiscontinuity:
          break;
        default:
          await this.buildFixWaypoint(leg, roleId);
          break;
      }
    }
    async buildTerminatorWaypoint(leg, roleId) {
      var _a, _b, _c, _d, _e, _f;
      const currentLeg = this.legWaypoints.get(leg);
      if (currentLeg !== void 0) {
        const [waypoint, currentRoleId] = currentLeg;
        const lastVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[((_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) - 1];
        if (lastVector !== void 0) {
          if (!waypoint.location.get().equals(lastVector.endLat, lastVector.endLon)) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            const ident = (_c = leg.name) !== null && _c !== void 0 ? _c : "";
            const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
            this.legWaypoints.set(leg, [newWaypoint, roleId]);
            this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          } else if (currentRoleId !== roleId) {
            this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
            this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
            this.legWaypoints.set(leg, [waypoint, roleId]);
          }
        } else {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
        }
      } else {
        const lastVector = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.flightPath[((_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) - 1];
        if (lastVector !== void 0) {
          const ident = (_f = leg.name) !== null && _f !== void 0 ? _f : "";
          const newWaypoint = new FlightPathWaypoint(lastVector.endLat, lastVector.endLon, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
        }
      }
    }
    async buildFixWaypoint(leg, roleId) {
      var _a;
      const legWaypoint = this.legWaypoints.get(leg);
      if (legWaypoint === void 0) {
        const facIcao = leg.leg.fixIcao;
        let facility;
        try {
          facility = await this.facLoader.getFacility(ICAO.getFacilityType(facIcao), facIcao);
        } catch (err) {
        }
        if (facility !== void 0) {
          const waypoint = this.facWaypointCache.get(facility);
          const ident = (_a = leg.name) !== null && _a !== void 0 ? _a : "";
          const newWaypoint = new FlightPathWaypoint(waypoint.location, leg, `${this.waypointPrefix}_${this.waypointId++}_${ident}`, ident);
          this.props.waypointRenderer.register(newWaypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [newWaypoint, roleId]);
        }
      } else {
        const [waypoint, currentRoleId] = legWaypoint;
        if (currentRoleId !== roleId) {
          this.props.waypointRenderer.deregister(waypoint, currentRoleId, MapSystemWaypointRoles.FlightPlan);
          this.props.waypointRenderer.register(waypoint, roleId, MapSystemWaypointRoles.FlightPlan);
          this.legWaypoints.set(leg, [waypoint, roleId]);
        }
      }
    }
    render() {
      var _a, _b;
      return FSComponent.buildComponent(
        FSComponent.Fragment,
        null,
        FSComponent.buildComponent(MapCachedCanvasLayer, { ref: this.flightPathLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, overdrawFactor: Math.SQRT2, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }),
        FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.waypointLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_b = this.props.class) !== null && _b !== void 0 ? _b : "" })
      );
    }
  };
  MapSystemFlightPlanLayer.WAYPOINT_PREFIX = "MapSystemFplLayer";
  MapSystemFlightPlanLayer.CLIP_BOUNDS_BUFFER = 10;
  MapSystemFlightPlanLayer.instanceId = 0;
  var AdsbOperatingMode;
  (function(AdsbOperatingMode2) {
    AdsbOperatingMode2["Standby"] = "Standby";
    AdsbOperatingMode2["Surface"] = "Surface";
    AdsbOperatingMode2["Airborne"] = "Airborne";
  })(AdsbOperatingMode || (AdsbOperatingMode = {}));
  var TcasOperatingMode;
  (function(TcasOperatingMode2) {
    TcasOperatingMode2["Off"] = "Off";
    TcasOperatingMode2["Standby"] = "Standby";
    TcasOperatingMode2["TAOnly"] = "TAOnly";
    TcasOperatingMode2["TA_RA"] = "TA/RA";
    TcasOperatingMode2["Test"] = "Test";
    TcasOperatingMode2["Failed"] = "Failed";
  })(TcasOperatingMode || (TcasOperatingMode = {}));
  var TcasAlertLevel;
  (function(TcasAlertLevel2) {
    TcasAlertLevel2[TcasAlertLevel2["None"] = 0] = "None";
    TcasAlertLevel2[TcasAlertLevel2["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel2[TcasAlertLevel2["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
  })(TcasAlertLevel || (TcasAlertLevel = {}));
  var TcasResolutionAdvisoryFlags;
  (function(TcasResolutionAdvisoryFlags2) {
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Corrective"] = 1] = "Corrective";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["UpSense"] = 2] = "UpSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DownSense"] = 4] = "DownSense";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Crossing"] = 8] = "Crossing";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Climb"] = 16] = "Climb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Descend"] = 32] = "Descend";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Increase"] = 64] = "Increase";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["Reversal"] = 128] = "Reversal";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceClimb"] = 256] = "ReduceClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["ReduceDescent"] = 512] = "ReduceDescent";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotClimb"] = 1024] = "DoNotClimb";
    TcasResolutionAdvisoryFlags2[TcasResolutionAdvisoryFlags2["DoNotDescend"] = 2048] = "DoNotDescend";
  })(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
  var TcasResolutionAdvisoryType;
  (function(TcasResolutionAdvisoryType2) {
    TcasResolutionAdvisoryType2["Climb"] = "Climb";
    TcasResolutionAdvisoryType2["CrossingClimb"] = "CrossingClimb";
    TcasResolutionAdvisoryType2["MaintainClimb"] = "MaintainClimb";
    TcasResolutionAdvisoryType2["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    TcasResolutionAdvisoryType2["IncreaseClimb"] = "IncreaseClimb";
    TcasResolutionAdvisoryType2["ReversalClimb"] = "ReversalClimb";
    TcasResolutionAdvisoryType2["ReduceDescent"] = "ReduceDescent";
    TcasResolutionAdvisoryType2["DoNotDescend0"] = "DoNotDescend0";
    TcasResolutionAdvisoryType2["DoNotDescend500"] = "DoNotDescend500";
    TcasResolutionAdvisoryType2["DoNotDescend1000"] = "DoNotDescend1000";
    TcasResolutionAdvisoryType2["DoNotDescend1500"] = "DoNotDescend1500";
    TcasResolutionAdvisoryType2["DoNotDescend2000"] = "DoNotDescend2000";
    TcasResolutionAdvisoryType2["Descend"] = "Descend";
    TcasResolutionAdvisoryType2["CrossingDescend"] = "CrossingDescend";
    TcasResolutionAdvisoryType2["MaintainDescend"] = "MaintainDescend";
    TcasResolutionAdvisoryType2["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    TcasResolutionAdvisoryType2["IncreaseDescend"] = "IncreaseDescend";
    TcasResolutionAdvisoryType2["ReversalDescend"] = "ReversalDescend";
    TcasResolutionAdvisoryType2["ReduceClimb"] = "ReduceClimb";
    TcasResolutionAdvisoryType2["DoNotClimb0"] = "DoNotClimb0";
    TcasResolutionAdvisoryType2["DoNotClimb500"] = "DoNotClimb500";
    TcasResolutionAdvisoryType2["DoNotClimb1000"] = "DoNotClimb1000";
    TcasResolutionAdvisoryType2["DoNotClimb1500"] = "DoNotClimb1500";
    TcasResolutionAdvisoryType2["DoNotClimb2000"] = "DoNotClimb2000";
    TcasResolutionAdvisoryType2["Clear"] = "Clear";
  })(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
  var Tcas = class {
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.bus = bus;
      this.tfcInstrument = tfcInstrument;
      this.maxIntruderCount = maxIntruderCount;
      this.realTimeUpdateFreq = realTimeUpdateFreq;
      this.simTimeUpdateFreq = simTimeUpdateFreq;
      this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
      this.intrudersSorted = [];
      this.intrudersFiltered = [];
      this.intrudersRA = /* @__PURE__ */ new Set();
      this.contactCreatedHandler = this.onContactAdded.bind(this);
      this.contactRemovedHandler = this.onContactRemoved.bind(this);
      this.ownAirplaneSubs = {
        position: GeoPointSubject.create(new GeoPoint(0, 0)),
        altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        groundTrack: ConsumerSubject.create(null, 0),
        groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
        verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
        radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
        isOnGround: ConsumerSubject.create(null, false)
      };
      this.simTime = ConsumerSubject.create(null, 0);
      this.lastUpdateSimTime = 0;
      this.lastUpdateRealTime = 0;
      this.alertLevelSubs = /* @__PURE__ */ new Map();
      this.eventPublisher = this.bus.getPublisher();
      this.eventSubscriber = this.bus.getSubscriber();
      this.paSeparationCache = {
        horizontal: UnitType.NMILE.createNumber(0),
        vertical: UnitType.FOOT.createNumber(0)
      };
      this.sensitivity = this.createSensitivity();
      this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
      const fullRAOptions = {
        initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
        initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
        subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
        subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
        allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : () => true,
        allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : () => true,
        allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100,
        allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : () => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450
      };
      this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    getOperatingMode() {
      return this.operatingModeSub.get();
    }
    setOperatingMode(mode) {
      this.operatingModeSub.set(mode);
    }
    getIntruders() {
      return this.intrudersFiltered;
    }
    getResolutionAdvisoryHost() {
      return this.resolutionAdvisoryHost;
    }
    getEventSubscriber() {
      return this.eventSubscriber;
    }
    init() {
      const sub2 = this.bus.getSubscriber();
      this.contactCreatedConsumer = sub2.on("traffic_contact_added");
      this.contactRemovedConsumer = sub2.on("traffic_contact_removed");
      this.contactCreatedConsumer.handle(this.contactCreatedHandler);
      this.contactRemovedConsumer.handle(this.contactRemovedHandler);
      this.tfcInstrument.forEachContact((contact) => {
        this.onContactAdded(contact.uid);
      });
      sub2.on("gps-position").atFrequency(this.realTimeUpdateFreq).handle((lla) => {
        this.ownAirplaneSubs.position.set(lla.lat, lla.long);
        this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
      });
      sub2.on("ground_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((gs) => {
        this.ownAirplaneSubs.groundSpeed.set(gs);
      });
      sub2.on("vertical_speed").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((vs) => {
        this.ownAirplaneSubs.verticalSpeed.set(vs);
      });
      sub2.on("radio_alt").whenChanged().atFrequency(this.realTimeUpdateFreq).handle((alt) => {
        this.ownAirplaneSubs.radarAltitude.set(alt);
      });
      this.ownAirplaneSubs.groundTrack.setConsumer(sub2.on("track_deg_true"));
      this.ownAirplaneSubs.isOnGround.setConsumer(sub2.on("on_ground"));
      this.simTime.setConsumer(sub2.on("simTime"));
      this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
      sub2.on("simTime").whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    onOperatingModeChanged(mode) {
      this.bus.pub("tcas_operating_mode", mode, false, true);
      if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.cancel(this.simTime.get());
        for (let i = 0; i < this.intrudersFiltered.length; i++) {
          this.cleanUpIntruder(this.intrudersFiltered[i]);
        }
        this.intrudersFiltered = [];
      }
    }
    intruderComparator(a, b) {
      if (a.isPredictionValid && !b.isPredictionValid) {
        return -1;
      } else if (!a.isPredictionValid && b.isPredictionValid) {
        return 1;
      } else if (a.isPredictionValid) {
        let tcaPredictionA, tcaPredictionB;
        const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || a.tcaRA.isValid && a.tcaRA.isThreat;
        const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || b.tcaRA.isValid && b.tcaRA.isThreat;
        if (aRA && !bRA) {
          return -1;
        } else if (!aRA && bRA) {
          return 1;
        } else if (aRA && bRA) {
          tcaPredictionA = a.tcaRA;
          tcaPredictionB = b.tcaRA;
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || a.tcaTA.isValid && a.tcaTA.isThreat;
          const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || b.tcaTA.isValid && b.tcaTA.isThreat;
          if (aTA && !bTA) {
            return -1;
          } else if (!aTA && bTA) {
            return 1;
          } else if (aTA && bTA) {
            tcaPredictionA = a.tcaTA;
            tcaPredictionB = b.tcaTA;
          }
        }
        if (!tcaPredictionA || !tcaPredictionB) {
          if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
            return -1;
          } else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
            return 1;
          } else {
            return 0;
          }
        }
        const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
        const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
        let firstComparison;
        let secondComparison;
        if (tcaPredictionA.isThreat) {
          firstComparison = tcaComparison;
          secondComparison = normComparison;
        } else {
          firstComparison = normComparison;
          secondComparison = tcaComparison;
        }
        if (firstComparison === 0) {
          return secondComparison;
        } else {
          return firstComparison;
        }
      } else {
        return 0;
      }
    }
    onContactAdded(uid) {
      const contact = this.tfcInstrument.getContact(uid);
      const intruder = this.createIntruderEntry(contact);
      this.intrudersSorted.push(intruder);
    }
    onContactRemoved(uid) {
      const sortedIndex = this.intrudersSorted.findIndex((intruder) => intruder.contact.uid === uid);
      const culledIndex = this.intrudersFiltered.findIndex((intruder) => intruder.contact.uid === uid);
      if (sortedIndex >= 0) {
        this.intrudersSorted.splice(sortedIndex, 1);
      }
      if (culledIndex >= 0) {
        const removed = this.intrudersFiltered[culledIndex];
        this.intrudersFiltered.splice(culledIndex, 1);
        this.cleanUpIntruder(removed);
      }
    }
    onSimTimeChanged(simTime) {
      switch (this.operatingModeSub.get()) {
        case TcasOperatingMode.Off:
        case TcasOperatingMode.Standby:
        case TcasOperatingMode.Failed:
        case TcasOperatingMode.Test:
          return;
      }
      const realTime = Date.now();
      if (Math.abs(simTime - this.lastUpdateSimTime) < 1e3 / this.simTimeUpdateFreq || Math.abs(realTime - this.lastUpdateRealTime) < 1e3 / this.realTimeUpdateFreq) {
        return;
      }
      this.doUpdate(simTime);
      this.lastUpdateSimTime = simTime;
      this.lastUpdateRealTime = realTime;
    }
    doUpdate(simTime) {
      this.updateSensitivity();
      this.updateIntruderPredictions(simTime);
      this.updateIntruderArrays();
      this.updateFilteredIntruderAlertLevels(simTime);
      this.updateResolutionAdvisory(simTime);
    }
    updateIntruderPredictions(simTime) {
      this.ownAirplane.update(simTime);
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersSorted[i];
        const sensitivity = this.sensitivity.selectParameters(intruder);
        intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
      }
    }
    updateIntruderArrays() {
      this.intrudersSorted.sort(this.intruderComparator.bind(this));
      const oldCulled = this.intrudersFiltered;
      this.intrudersFiltered = [];
      const len = this.intrudersSorted.length;
      for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
        const intruder = this.intrudersSorted[i];
        if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
          this.intrudersFiltered.push(intruder);
          if (!oldCulled.includes(intruder)) {
            this.initIntruder(intruder);
          }
        } else {
          if (oldCulled.includes(intruder)) {
            this.cleanUpIntruder(intruder);
          }
        }
      }
    }
    filterIntruder(intruder) {
      return true;
    }
    updateFilteredIntruderAlertLevels(simTime) {
      let taCount = 0, raCount = 0;
      const len = this.intrudersFiltered.length;
      for (let i = 0; i < len; i++) {
        const intruder = this.intrudersFiltered[i];
        this.updateIntruderAlertLevel(simTime, intruder);
        switch (intruder.alertLevel.get()) {
          case TcasAlertLevel.TrafficAdvisory:
            taCount++;
            break;
          case TcasAlertLevel.ResolutionAdvisory:
            raCount++;
            break;
        }
      }
      this.eventPublisher.pub("tcas_ta_intruder_count", taCount, false, true);
      this.eventPublisher.pub("tcas_ra_intruder_count", raCount, false, true);
    }
    updateIntruderAlertLevel(simTime, intruder) {
      const currentAlertLevel = intruder.alertLevel.get();
      if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
        if (this.canIssueResolutionAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat) && !this.canCancelResolutionAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
        if (this.canIssueTrafficAdvisory(simTime, intruder)) {
          intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
          return;
        } else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
          return;
        }
      }
      if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat) && !this.canCancelTrafficAdvisory(simTime, intruder)) {
        return;
      }
      if (intruder.isPredictionValid) {
        const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
        const radius = parametersPA.protectedRadius;
        const height = parametersPA.protectedHeight;
        if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
          intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
          if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0 && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
            intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
            return;
          }
        }
      }
      if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
        return;
      }
      intruder.alertLevel.set(TcasAlertLevel.None);
    }
    canIssueResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() === TcasOperatingMode.TA_RA && intruder.tcaRA.isValid && intruder.tcaRA.tcpa.number > 0 && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    canCancelResolutionAdvisory(simTime, intruder) {
      return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    canIssueTrafficAdvisory(simTime, intruder) {
      return true;
    }
    canCancelTrafficAdvisory(simTime, intruder) {
      return true;
    }
    canIssueProximityAdvisory(simTime, intruder) {
      return true;
    }
    canCancelProximityAdvisory(simTime, intruder) {
      return true;
    }
    updateResolutionAdvisory(simTime) {
      if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
        this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
      } else {
        this.resolutionAdvisoryHost.cancel(simTime);
      }
    }
    initIntruder(intruder) {
      this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
      this.eventPublisher.pub("tcas_intruder_added", intruder, false, false);
    }
    cleanUpIntruder(intruder) {
      var _a;
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.delete(intruder);
      }
      (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
      this.eventPublisher.pub("tcas_intruder_removed", intruder, false, false);
    }
    onAlertLevelChanged(intruder) {
      if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
        this.intrudersRA.add(intruder);
      } else {
        this.intrudersRA.delete(intruder);
      }
      this.eventPublisher.pub("tcas_intruder_alert_changed", intruder, false, false);
    }
  };
  Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
  };
  var TcasAirplane = class {
    constructor() {
      this._position = new GeoPoint(0, 0);
      this.position = this._position.readonly;
      this._altitude = UnitType.FOOT.createNumber(0);
      this.altitude = this._altitude.readonly;
      this._groundTrack = 0;
      this._groundSpeed = UnitType.KNOT.createNumber(0);
      this.groundSpeed = this._groundSpeed.readonly;
      this._verticalSpeed = UnitType.FPM.createNumber(0);
      this.verticalSpeed = this._verticalSpeed.readonly;
      this.positionVec = new Float64Array(3);
      this.velocityVec = new Float64Array(3);
      this.lastUpdateTime = 0;
    }
    get groundTrack() {
      return this._groundTrack;
    }
  };
  var OwnAirplane = class extends TcasAirplane {
    constructor(subs) {
      super();
      this.subs = subs;
      this._radarAltitude = UnitType.FOOT.createNumber(0);
      this.radarAltitude = this._radarAltitude.readonly;
      this._isOnGround = false;
    }
    get isOnGround() {
      return this._isOnGround;
    }
    predictPosition(simTime, out) {
      const dt = (simTime - this.lastUpdateTime) / 1e3;
      return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    update(simTime) {
      this.updateParameters();
      this.updateVectors();
      this.lastUpdateTime = simTime;
    }
    updateParameters() {
      this._position.set(this.subs.position.get());
      this._altitude.set(this.subs.altitude.get());
      this._groundTrack = this.subs.groundTrack.get();
      this._groundSpeed.set(this.subs.groundSpeed.get());
      this._verticalSpeed.set(this.subs.verticalSpeed.get());
      this._radarAltitude.set(this.subs.radarAltitude.get());
      this._isOnGround = this.subs.isOnGround.get();
    }
    updateVectors() {
      Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
    }
  };
  var AbstractTcasIntruder = class extends TcasAirplane {
    constructor(contact) {
      super();
      this.contact = contact;
      this.alertLevel = Subject.create(TcasAlertLevel.None);
      this.relativePositionVec = new Float64Array(3);
      this.relativeVelocityVec = new Float64Array(3);
      this._isPredictionValid = false;
      this.tcaTA = new TcasTcaPredictionClass(this);
      this.tcaRA = new TcasTcaPredictionClass(this);
    }
    get isPredictionValid() {
      return this._isPredictionValid;
    }
    predictDisplacement(simTime, out) {
      if (!this._isPredictionValid) {
        return Vec3Math.set(NaN, NaN, NaN, out);
      }
      const dt = (simTime - this.contact.lastContactTime) / 1e3;
      return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    predictSeparation(simTime, horizontalOut, verticalOut) {
      if (!this._isPredictionValid) {
        horizontalOut.set(NaN);
        verticalOut.set(NaN);
        return;
      }
      const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
      AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
      AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    updatePrediction(simTime, ownAirplane, sensitivity) {
      this.updateParameters(simTime, ownAirplane);
      if (this.isPredictionValid) {
        const taParams = sensitivity.parametersTA;
        const raParams = sensitivity.parametersRA;
        this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
        this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
      } else {
        this.invalidatePredictions();
      }
      this.lastUpdateTime = simTime;
    }
    updateParameters(simTime, ownAirplane) {
      if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
        this._isPredictionValid = false;
        this._position.set(NaN, NaN);
        this._altitude.set(NaN);
        this._groundTrack = NaN;
        this._groundSpeed.set(NaN);
        this._verticalSpeed.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.positionVec);
        Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
        Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
      } else {
        this.updatePosition(simTime, ownAirplane);
        this.updateVelocity(ownAirplane);
        this._groundSpeed.set(this.contact.groundSpeed);
        this._verticalSpeed.set(this.contact.verticalSpeed);
        this._isPredictionValid = true;
      }
    }
    updatePosition(simTime, ownAirplane) {
      this.contact.predict(simTime, this._position, this._altitude);
      this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
      const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
      const bearing = ownAirplane.position.bearingTo(this._position);
      Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
      const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
      this.positionVec[2] = verticalPosition;
      Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    updateVelocity(ownAirplane) {
      Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
      const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
      this.velocityVec[2] = verticalVelocity;
      Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    invalidatePredictions() {
      this.tcaTA.invalidate();
      this.tcaRA.invalidate();
    }
    static displacementToHorizontalSeparation(displacement, out) {
      return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    static displacementToVerticalSeparation(displacement, out) {
      return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
  };
  AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
  AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
  var TcasTcaPredictionClass = class {
    constructor(intruder) {
      this.intruder = intruder;
      this._isValid = false;
      this._time = NaN;
      this._tcpa = UnitType.SECOND.createNumber(NaN);
      this.tcpa = this._tcpa.readonly;
      this._tcoa = UnitType.SECOND.createNumber(NaN);
      this.tcoa = this._tcoa.readonly;
      this._isThreat = false;
      this.cpaDisplacement = new Float64Array(3);
      this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
      this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
      this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
      this.cpaVerticalSep = this._cpaVerticalSep.readonly;
      this._cpaNorm = NaN;
    }
    get isValid() {
      return this._isValid;
    }
    get time() {
      return this._time;
    }
    get isThreat() {
      return this._isThreat;
    }
    get cpaNorm() {
      return this._cpaNorm;
    }
    update(simTime, tau, dmod, zthr, hmd) {
      var _a;
      this._time = simTime;
      if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
        this.invalidate();
        return;
      }
      const tauSeconds = tau.asUnit(UnitType.SECOND);
      const s = this.intruder.relativePositionVec;
      const v = this.intruder.relativeVelocityVec;
      const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
      const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
      const h = zthr.asUnit(UnitType.METER);
      const r = dmod.asUnit(UnitType.METER);
      const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
      const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
      const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
      const rSquared = r * r;
      const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
      const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
      const tcoa = -s[2] / v[2];
      const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
      const isVerticalThreat = Math.abs(s[2]) <= h || tcoa >= 0 && tcoa <= tauSeconds;
      let passHmdFilter = true;
      if (hmd !== void 0 && isHorizontalThreat && isVerticalThreat) {
        const d = hmd.asUnit(UnitType.METER);
        const dSquared = d * d;
        if (vHorizSquared === 0) {
          passHmdFilter = sHorizSquared <= dSquared;
        } else {
          const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
          if (delta < 0) {
            passHmdFilter = false;
          } else {
            const a = vHorizSquared;
            const b = 2 * dotSHorizVHoriz;
            const c = sHorizSquared - dSquared;
            const discriminant = b * b - 4 * a * c;
            if (discriminant < 0) {
              passHmdFilter = false;
            } else {
              passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
            }
          }
        }
      }
      this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
      this._tcpa.set(tcpa);
      this._tcoa.set(tcoa);
      TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
      AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
      AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
      this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
      this._isValid = true;
    }
    invalidate() {
      this._isValid = false;
      this._isThreat = false;
      this._tcpa.set(NaN);
      this._tcoa.set(NaN);
      Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
      this._cpaHorizontalSep.set(NaN);
      this._cpaVerticalSep.set(NaN);
      this._cpaNorm = NaN;
    }
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
      return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    static calculateCylindricalNorm(vector, radius, halfHeight) {
      const horizLength = Math.hypot(vector[0], vector[1]);
      return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
  };
  TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
  var TcasResolutionAdvisoryHostClass = class {
    constructor(bus, options, ownAirplane) {
      this.options = options;
      this.ownAirplane = ownAirplane;
      this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
      this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
      this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
      this.intruders = /* @__PURE__ */ new Set();
      this.intruderArray = [];
      this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
      this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
      this.minVerticalSpeed = this._minVerticalSpeed.readonly;
      this._flags = 0;
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._secondaryType = null;
      this._primaryFlags = 0;
      this._secondaryFlags = 0;
      this.vsConstraints = [];
      this.lastStateChangeTime = 0;
      this.stateChangeDelay = 0;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher = bus.getPublisher();
    }
    get flags() {
      return this._flags;
    }
    get primaryType() {
      return this._primaryType;
    }
    get secondaryType() {
      return this._secondaryType;
    }
    get primaryFlags() {
      return this._primaryFlags;
    }
    get secondaryFlags() {
      return this._secondaryFlags;
    }
    canIssueResolutionAdvisory(simTime, intruder) {
      if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
        return false;
      }
      if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    canCancelResolutionAdvisory(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
        return true;
      }
      const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
      return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    update(simTime, alim, intruders) {
      if (this.intruderArray.length === 0 && intruders.size === 0) {
        return;
      }
      if (simTime < this.lastStateChangeTime) {
        this.lastStateChangeTime = simTime;
      }
      if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
        return;
      }
      if (intruders.size === 0) {
        this.cancel(simTime);
      } else {
        const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        const alimMeters = alim.asUnit(UnitType.METER);
        const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
        const responseTimeSecondsRemaining = isInitial ? responseTimeSeconds : MathUtils2.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1e3, 0, responseTimeSeconds);
        const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
        this.updateIntruders(intruders);
        this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
        if (isInitial) {
          this.selectInitialState(simTime, ownAirplaneVsMps);
        } else {
          if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
            this.updatePositive(simTime);
          } else if (this._secondaryType === null) {
            this.updateNegative(simTime, ownAirplaneVsMps);
          } else {
            this.updateComposite(simTime, ownAirplaneVsMps);
          }
        }
      }
    }
    updateIntruders(intruders) {
      for (let i = 0; i < this.intruderArray.length; i++) {
        if (!intruders.has(this.intruderArray[i])) {
          this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
        }
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      for (const intruder of intruders) {
        this.intruders.add(intruder);
        this.intruderArray.push(intruder);
      }
      this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
      var _a;
      var _b;
      const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
      for (let i = 0; i < this.intruderArray.length; i++) {
        const intruder = this.intruderArray[i];
        let above = -Infinity;
        let below = Infinity;
        if (intruder.tcaRA.isValid) {
          const t0 = intruder.tcaRA.time;
          const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
          const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1e3;
          const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
          const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
          const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
          const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
          const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
          const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
          if (aboveAlimSense === 1) {
            above = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters) : NaN;
            if (isNaN(above)) {
              above = Infinity;
            }
          } else {
            above = tcpaSeconds > 0 ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : -Infinity;
          }
          if (belowAlimSense === -1) {
            below = responseTimeSeconds < tcpaSeconds ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters) : NaN;
            if (isNaN(below)) {
              below = -Infinity;
            }
          } else {
            below = tcpaSeconds > 0 ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds : Infinity;
          }
        }
        const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : _b[i] = { above: 0, below: 0 };
        constraint.above = above;
        constraint.below = below;
      }
      this.vsConstraints.length = this.intruderArray.length;
    }
    selectInitialState(simTime, ownAirplaneVsMps) {
      let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
      let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
      let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
      const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
      const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
      const canClimb = this.options.allowClimb(simTime);
      const canDescend = this.options.allowDescend(simTime);
      const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
      const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
      minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
      maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
      let sense;
      let senseIsCrossing = false;
      let doesSenseAchieveAlim = false;
      let senseRequiredVs = 0;
      if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
        sense = 1;
      } else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
        sense = -1;
      } else {
        const closestIntruder = this.intruderArray[0];
        const t0 = closestIntruder.tcaRA.time;
        const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
        const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
        const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
        const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
        if (crossingSense === -1 && !isUpSenseInhibited) {
          sense = 1;
        } else if (crossingSense === 1 && !isDownSenseInhibited) {
          sense = -1;
        } else {
          if (!isUpSenseInhibited && isDownSenseInhibited) {
            sense = 1;
          } else if (isUpSenseInhibited && !isDownSenseInhibited) {
            sense = -1;
          } else {
            if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
              sense = 1;
            } else {
              sense = -1;
            }
          }
          senseIsCrossing = sense === crossingSense;
        }
      }
      doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
      doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
      doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
      senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
      if (this.intruderArray.length > 1) {
        const doesCompositeAchieveAlim = this.vsConstraints.every((constraint) => constraint.above <= 0 || constraint.below >= 0);
        if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
          sense = 0;
          doesSenseAchieveAlim = doesCompositeAchieveAlim;
        } else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
          if (senseIsCrossing) {
            sense = 0;
            doesSenseAchieveAlim = doesCompositeAchieveAlim;
          } else {
            if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
              sense = 0;
              doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
          }
        }
      }
      let primaryType;
      let secondaryType = null;
      switch (sense) {
        case 0:
          if (doesSenseAchieveAlim) {
            const maxVsMps = this.getCompositeRequiredMaxVs();
            const minVsMps = this.getCompositeRequiredMinVs();
            if (ownAirplaneVsMps > maxVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
            } else if (ownAirplaneVsMps < minVsMps) {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
              secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
            }
          } else {
            primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
          }
          break;
        case 1:
          if (ownAirplaneVsMps < minUpSenseVsMps) {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceDescent;
            }
          } else {
            if (minUpSenseVsMps > 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
            }
          }
          break;
        case -1:
          if (ownAirplaneVsMps > maxDownSenseVsMps) {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
            } else {
              primaryType = TcasResolutionAdvisoryType.ReduceClimb;
            }
          } else {
            if (maxDownSenseVsMps < 0) {
              primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
            } else {
              primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
            }
          }
          break;
      }
      this.setState(simTime, primaryType, secondaryType, true);
    }
    updatePositive(simTime) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
      const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
      if (isInhibited) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
        return;
      }
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        if (requiredVsMps * sense <= 0) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
      } else {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
        let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
        }
      }
    }
    updateNegative(simTime, ownAirplaneVsMps) {
      const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
      const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
      if (willAchieveAlim) {
        return;
      }
      const requirePositive = requiredVsMps * sense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
      } else {
        this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
      }
    }
    updateComposite(simTime, ownAirplaneVsMps) {
      if (this._secondaryType === null) {
        throw new Error("TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active");
      }
      const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
      const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
      const requiredMinVsMps = this.getCompositeRequiredMinVs();
      const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
      const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
      let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
      if (primarySense === 1) {
        primaryCurrentVsMps = currentMinVsMps;
        primaryRequiredVsMps = requiredMinVsMps;
        secondaryCurrentVsMps = currentMaxVsMps;
        secondaryRequiredVsMps = requiredMaxVsMps;
      } else {
        primaryCurrentVsMps = currentMaxVsMps;
        primaryRequiredVsMps = requiredMaxVsMps;
        secondaryCurrentVsMps = currentMinVsMps;
        secondaryRequiredVsMps = requiredMinVsMps;
      }
      const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
      const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
      const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0 || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
      if (requirePositive) {
        const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
        let reverseSense = false;
        if (!strengthen && this.senseReversalCount < this.intruderArray.length && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
          const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
          reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
        }
        strengthen = !isStrengthenInhibited && !reverseSense;
        if (strengthen) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
          return;
        } else if (reverseSense) {
          this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
          return;
        }
      }
      let primaryType;
      if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
      } else {
        primaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
      }
      const secondaryType = primarySense === 1 ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps) : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
      this.setState(simTime, primaryType, secondaryType);
    }
    setState(simTime, primaryType, secondaryType, isInitial = false) {
      if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
        return;
      }
      let minSpeed, maxSpeed;
      const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
      this._primaryType = primaryType;
      this._primaryFlags = primaryTypeDef.flags;
      this._secondaryType = secondaryType;
      if (secondaryType !== null) {
        const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
        this._secondaryFlags = secondaryTypeDef.flags;
        minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
        maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
      } else {
        this._secondaryFlags = 0;
        minSpeed = primaryTypeDef.minVerticalSpeed;
        maxSpeed = primaryTypeDef.maxVerticalSpeed;
      }
      this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
      this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
      this.isInitial = isInitial;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1e3;
      if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
        this.senseReversalCount++;
      }
      if (isInitial) {
        this.publisher.pub("tcas_ra_issued", this, false, false);
      } else {
        this.publisher.pub("tcas_ra_updated", this, false, false);
      }
    }
    cancel(simTime) {
      if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
        return;
      }
      this.intruders.clear();
      this.intruderArray.length = 0;
      this._maxVerticalSpeed.set(NaN);
      this._minVerticalSpeed.set(NaN);
      this._primaryType = TcasResolutionAdvisoryType.Clear;
      this._primaryFlags = 0;
      this._secondaryType = null;
      this._secondaryFlags = 0;
      this.lastStateChangeTime = simTime;
      this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
      this.isInitial = true;
      this.senseReversalCount = 0;
      this.publisher.pub("tcas_ra_canceled", void 0, false, false);
    }
    getUpSenseRequiredMinVs() {
      return this.vsConstraints.reduce((min2, constraint) => Math.max(min2, constraint.above), -Infinity);
    }
    getDownSenseRequiredMaxVs() {
      return this.vsConstraints.reduce((max2, constraint) => Math.min(max2, constraint.below), Infinity);
    }
    getCompositeRequiredMinVs() {
      return this.vsConstraints.reduce((min2, constraint) => constraint.above <= 0 ? Math.max(min2, constraint.above) : min2, -Infinity);
    }
    getCompositeRequiredMaxVs() {
      return this.vsConstraints.reduce((max2, constraint) => constraint.below >= 0 ? Math.min(max2, constraint.below) : max2, Infinity);
    }
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
      const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
      if (signedAccel === 0) {
        return vs;
      }
      const y0 = currentAlt + vs * responseTime;
      const tc = tcpa - responseTime;
      const a = signedAccel / 2;
      const b = -signedAccel * tc;
      const c = targetAlt - y0 - vs * tc;
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) {
        return NaN;
      }
      const sqrtDiscr = Math.sqrt(discriminant);
      const t1 = (-b + sqrtDiscr) / (2 * a);
      const t2 = (-b - sqrtDiscr) / (2 * a);
      if (t1 <= tc && t1 >= 0) {
        return vs + signedAccel * t1;
      }
      if (t2 <= tc && t2 >= 0) {
        return vs + signedAccel * t2;
      }
      return NaN;
    }
    static getDoNotDescendType(minVsMps) {
      if (minVsMps > -500) {
        return TcasResolutionAdvisoryType.DoNotDescend0;
      } else if (minVsMps > -1e3) {
        return TcasResolutionAdvisoryType.DoNotDescend500;
      } else if (minVsMps > -1500) {
        return TcasResolutionAdvisoryType.DoNotDescend1000;
      } else if (minVsMps > -2e3) {
        return TcasResolutionAdvisoryType.DoNotDescend1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotDescend2000;
      }
    }
    static getDoNotClimbType(maxVsMps) {
      if (maxVsMps < 500) {
        return TcasResolutionAdvisoryType.DoNotClimb0;
      } else if (maxVsMps < 1e3) {
        return TcasResolutionAdvisoryType.DoNotClimb500;
      } else if (maxVsMps < 1500) {
        return TcasResolutionAdvisoryType.DoNotClimb1000;
      } else if (maxVsMps < 2e3) {
        return TcasResolutionAdvisoryType.DoNotClimb1500;
      } else {
        return TcasResolutionAdvisoryType.DoNotClimb2000;
      }
    }
  };
  TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5e3;
  TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
  TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
      return -1;
    } else if (tcpaComparison > 0) {
      return 1;
    } else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
      return -1;
    } else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
      return 1;
    } else {
      return 0;
    }
  };
  TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
      flags: 0,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 2500,
      maxVerticalSpeed: 3e3
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 1500,
      maxVerticalSpeed: 2e3
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: 0,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -1500,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
      flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
      minVerticalSpeed: -4400,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -3e3,
      maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -2e3,
      maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1e3
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
      flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
      minVerticalSpeed: -Infinity,
      maxVerticalSpeed: 2e3
    }
  };
  TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];
  var TcasIISensitivityParameters = class {
    selectLevel(altitude, radarAltitude) {
      const altFeet = altitude.asUnit(UnitType.FOOT);
      const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
      let level;
      if (radarAltFeet > 2350) {
        if (altFeet > 42e3) {
          level = 6;
        } else if (altFeet > 2e4) {
          level = 5;
        } else if (altFeet > 1e4) {
          level = 4;
        } else if (altFeet > 5e3) {
          level = 3;
        } else {
          level = 2;
        }
      } else if (radarAltFeet > 1e3) {
        level = 1;
      } else {
        level = 0;
      }
      return level;
    }
    selectPA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.PA;
    }
    selectTA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    selectRA(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    selectRAAlim(altitude, radarAltitude) {
      return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    getPA(level) {
      return TcasIISensitivityParameters.PA;
    }
    getTA(level) {
      return TcasIISensitivityParameters.TA_LEVELS[MathUtils2.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    getRA(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils2.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    getRAAlim(level) {
      return TcasIISensitivityParameters.RA_LEVELS[MathUtils2.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
  };
  TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
  };
  TcasIISensitivityParameters.TA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.33),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.48),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(40),
      protectedRadius: UnitType.NMILE.createNumber(0.75),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(45),
      protectedRadius: UnitType.NMILE.createNumber(1),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
      tau: UnitType.SECOND.createNumber(48),
      protectedRadius: UnitType.NMILE.createNumber(1.3),
      protectedHeight: UnitType.FOOT.createNumber(1200)
    }
  ];
  TcasIISensitivityParameters.RA_LEVELS = [
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(15),
      protectedRadius: UnitType.NMILE.createNumber(0.2),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
      tau: UnitType.SECOND.createNumber(20),
      protectedRadius: UnitType.NMILE.createNumber(0.35),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(300),
      hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
      tau: UnitType.SECOND.createNumber(25),
      protectedRadius: UnitType.NMILE.createNumber(0.55),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(350),
      hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
      tau: UnitType.SECOND.createNumber(30),
      protectedRadius: UnitType.NMILE.createNumber(0.8),
      protectedHeight: UnitType.FOOT.createNumber(600),
      alim: UnitType.FOOT.createNumber(400),
      hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(700),
      alim: UnitType.FOOT.createNumber(600),
      hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
      tau: UnitType.SECOND.createNumber(35),
      protectedRadius: UnitType.NMILE.createNumber(1.1),
      protectedHeight: UnitType.FOOT.createNumber(800),
      alim: UnitType.FOOT.createNumber(700),
      hmd: UnitType.NMILE.createNumber(0.98)
    }
  ];
  var MapTrafficAlertLevelVisibility;
  (function(MapTrafficAlertLevelVisibility2) {
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["Other"] = 1] = "Other";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ProximityAdvisory"] = 2] = "ProximityAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["TrafficAdvisory"] = 4] = "TrafficAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["ResolutionAdvisory"] = 8] = "ResolutionAdvisory";
    MapTrafficAlertLevelVisibility2[MapTrafficAlertLevelVisibility2["All"] = 15] = "All";
  })(MapTrafficAlertLevelVisibility || (MapTrafficAlertLevelVisibility = {}));
  var MapTrafficModule = class {
    constructor(tcas) {
      this.tcas = tcas;
      this.show = Subject.create(true);
      this.operatingMode = Subject.create(TcasOperatingMode.Standby);
      this.offScaleRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(NaN));
      this.alertLevelVisibility = Subject.create(MapTrafficAlertLevelVisibility.All);
      this.altitudeRestrictionAbove = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.altitudeRestrictionBelow = NumberUnitSubject.createFromNumberUnit(UnitType.FOOT.createNumber(9900));
      this.isAltitudeRelative = Subject.create(true);
      this.tcas.getEventSubscriber().on("tcas_operating_mode").whenChanged().handle((mode) => {
        this.operatingMode.set(mode);
      });
    }
  };
  var MapSystemTrafficLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.iconLayerRef = FSComponent.createRef();
      this.trafficModule = this.props.model.getModule(MapSystemKeys.Traffic);
      this.intruderIcons = {
        [TcasAlertLevel.None]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ProximityAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.TrafficAdvisory]: /* @__PURE__ */ new Map(),
        [TcasAlertLevel.ResolutionAdvisory]: /* @__PURE__ */ new Map()
      };
      this.needHandleOffscaleOob = this.props.offScaleIntruders !== void 0 || this.props.oobIntruders !== void 0;
      this.oobOffset = (_a = this.props.oobOffset) !== null && _a !== void 0 ? _a : Subject.create(VecNMath.create(4));
      this.oobBounds = VecNSubject.createFromVector(VecNMath.create(4));
      this.isInit = false;
    }
    onVisibilityChanged(isVisible) {
      var _a, _b;
      if (!isVisible) {
        if (this.isInit) {
          this.iconLayerRef.instance.display.clear();
        }
        (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.clear();
      }
    }
    onAttached() {
      this.iconLayerRef.instance.onAttached();
      this.oobOffset.sub(this.updateOobBounds.bind(this), true);
      this.trafficModule.operatingMode.sub(this.updateVisibility.bind(this));
      this.trafficModule.show.sub(this.updateVisibility.bind(this), true);
      this.initCanvasStyles();
      this.initIntruders();
      this.initTCASHandlers();
      this.isInit = true;
    }
    initCanvasStyles() {
      this.props.initCanvasStyles && this.props.initCanvasStyles(this.iconLayerRef.instance.display.context);
    }
    initIntruders() {
      const intruders = this.trafficModule.tcas.getIntruders();
      const len = intruders.length;
      for (let i = 0; i < len; i++) {
        this.onIntruderAdded(intruders[i]);
      }
    }
    initTCASHandlers() {
      const tcasSub = this.props.context.bus.getSubscriber();
      tcasSub.on("tcas_intruder_added").handle(this.onIntruderAdded.bind(this));
      tcasSub.on("tcas_intruder_removed").handle(this.onIntruderRemoved.bind(this));
      tcasSub.on("tcas_intruder_alert_changed").handle(this.onIntruderAlertLevelChanged.bind(this));
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.iconLayerRef.instance.onMapProjectionChanged(mapProjection, changeFlags);
      if (BitFlags.isAll(changeFlags, MapProjectionChangeType.ProjectedSize)) {
        this.initCanvasStyles();
        this.updateOobBounds();
      }
    }
    updateOobBounds() {
      const projectedSize = this.props.mapProjection.getProjectedSize();
      const oobOffset = this.oobOffset.get();
      this.oobBounds.set(oobOffset[0], oobOffset[1], projectedSize[0] - oobOffset[2], projectedSize[1] - oobOffset[3]);
    }
    onUpdated(time, elapsed) {
      if (!this.isVisible()) {
        return;
      }
      this.redrawIntruders();
    }
    redrawIntruders() {
      const alertLevelVisFlags = this.trafficModule.alertLevelVisibility.get();
      const offScaleRange = this.trafficModule.offScaleRange.get();
      const oobBounds = this.oobBounds.get();
      const iconDisplay = this.iconLayerRef.instance.display;
      iconDisplay.clear();
      for (let i = 0; i < MapSystemTrafficLayer.DRAW_GROUPS.length; i++) {
        const group = MapSystemTrafficLayer.DRAW_GROUPS[i];
        if (BitFlags.isAll(alertLevelVisFlags, group.alertLevelVisFlag)) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b, _c, _d, _e, _f;
            icon.draw(this.props.mapProjection, iconDisplay.context, offScaleRange);
            if (this.needHandleOffscaleOob) {
              if (icon.isOffScale) {
                (_a = this.props.oobIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
                (_b = this.props.offScaleIntruders) === null || _b === void 0 ? void 0 : _b.add(icon.intruder);
              } else if (!this.props.mapProjection.isInProjectedBounds(icon.projectedPos, oobBounds)) {
                (_c = this.props.offScaleIntruders) === null || _c === void 0 ? void 0 : _c.delete(icon.intruder);
                (_d = this.props.oobIntruders) === null || _d === void 0 ? void 0 : _d.add(icon.intruder);
              } else {
                (_e = this.props.offScaleIntruders) === null || _e === void 0 ? void 0 : _e.delete(icon.intruder);
                (_f = this.props.oobIntruders) === null || _f === void 0 ? void 0 : _f.delete(icon.intruder);
              }
            }
          });
        } else if (this.needHandleOffscaleOob) {
          this.intruderIcons[group.alertLevel].forEach((icon) => {
            var _a, _b;
            (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(icon.intruder);
            (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(icon.intruder);
          });
        }
      }
    }
    updateVisibility() {
      const operatingMode = this.trafficModule.tcas.getOperatingMode();
      this.setVisible(this.trafficModule.show.get() && (operatingMode === TcasOperatingMode.TAOnly || operatingMode === TcasOperatingMode.TA_RA || operatingMode === TcasOperatingMode.Test));
    }
    onIntruderAdded(intruder) {
      const icon = this.props.iconFactory(intruder, this.props.context);
      this.intruderIcons[intruder.alertLevel.get()].set(intruder, icon);
    }
    onIntruderRemoved(intruder) {
      var _a, _b;
      (_a = this.props.offScaleIntruders) === null || _a === void 0 ? void 0 : _a.delete(intruder);
      (_b = this.props.oobIntruders) === null || _b === void 0 ? void 0 : _b.delete(intruder);
      this.intruderIcons[intruder.alertLevel.get()].delete(intruder);
    }
    onIntruderAlertLevelChanged(intruder) {
      let oldAlertLevel;
      let view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.None].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ProximityAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.TrafficAdvisory].get(intruder);
      view !== null && view !== void 0 ? view : view = this.intruderIcons[oldAlertLevel = TcasAlertLevel.ResolutionAdvisory].get(intruder);
      if (view) {
        this.intruderIcons[oldAlertLevel].delete(intruder);
        this.intruderIcons[intruder.alertLevel.get()].set(intruder, view);
      }
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapSyncedCanvasLayer, { ref: this.iconLayerRef, model: this.props.model, mapProjection: this.props.mapProjection, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
  };
  MapSystemTrafficLayer.DRAW_GROUPS = [
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.Other, alertLevel: TcasAlertLevel.None },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ProximityAdvisory, alertLevel: TcasAlertLevel.ProximityAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.TrafficAdvisory, alertLevel: TcasAlertLevel.TrafficAdvisory },
    { alertLevelVisFlag: MapTrafficAlertLevelVisibility.ResolutionAdvisory, alertLevel: TcasAlertLevel.ResolutionAdvisory }
  ];
  var AbstractMapTrafficIntruderIcon = class {
    constructor(intruder, trafficModule, ownshipModule) {
      this.intruder = intruder;
      this.trafficModule = trafficModule;
      this.ownshipModule = ownshipModule;
      this.projectedPos = new Float64Array(2);
      this.isOffScale = false;
    }
    draw(projection, context, offScaleRange) {
      this.updatePosition(projection, offScaleRange);
      this.drawIcon(projection, context, this.projectedPos, this.isOffScale);
    }
    updatePosition(projection, offScaleRange) {
      const ownAirplanePos = this.ownshipModule.position.get();
      if (offScaleRange.isNaN()) {
        projection.project(this.intruder.position, this.projectedPos);
        this.isOffScale = false;
      } else {
        this.handleOffScaleRange(projection, ownAirplanePos, offScaleRange);
      }
    }
    handleOffScaleRange(projection, ownAirplanePos, offScaleRange) {
      const intruderPos = this.intruder.position;
      const horizontalSeparation = intruderPos.distance(ownAirplanePos);
      const offscaleRangeRad = offScaleRange.asUnit(UnitType.GA_RADIAN);
      if (horizontalSeparation > offscaleRangeRad) {
        this.isOffScale = true;
        projection.project(ownAirplanePos.offset(ownAirplanePos.bearingTo(intruderPos), offscaleRangeRad, AbstractMapTrafficIntruderIcon.geoPointCache[0]), this.projectedPos);
      } else {
        this.isOffScale = false;
        projection.project(intruderPos, this.projectedPos);
      }
    }
  };
  AbstractMapTrafficIntruderIcon.geoPointCache = [new GeoPoint(0, 0)];
  var MapSystemWaypointsLayer = class extends MapLayer {
    constructor() {
      var _a;
      super(...arguments);
      this.waypointsLayer = FSComponent.createRef();
      this.displayModule = this.props.model.getModule(MapSystemKeys.NearestWaypoints);
      this.waypointCache = (_a = this.props.waypointCache) !== null && _a !== void 0 ? _a : DefaultFacilityWaypointCache.getCache(this.props.bus);
      this.searchItemLimits = {
        [FacilitySearchType.Airport]: 500,
        [FacilitySearchType.Vor]: 250,
        [FacilitySearchType.Ndb]: 250,
        [FacilitySearchType.Intersection]: 500,
        [FacilitySearchType.User]: 100
      };
      this.searchRadiusLimits = {
        [FacilitySearchType.Airport]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Vor]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Ndb]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.Intersection]: Number.POSITIVE_INFINITY,
        [FacilitySearchType.User]: Number.POSITIVE_INFINITY
      };
    }
    onAttached() {
      super.onAttached();
      this.waypointsLayer.instance.onAttached();
      this.initEventHandlers();
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.waypointsLayer.instance.onMapProjectionChanged(mapProjection, changeFlags);
    }
    onUpdated(time, elapsed) {
      if (this.isVisible()) {
        this.waypointsLayer.instance.onUpdated(time, elapsed);
      }
    }
    initEventHandlers() {
      this.displayModule.numAirports.sub((num) => this.searchItemLimits[FacilitySearchType.Airport] = num, true);
      this.displayModule.numIntersections.sub((num) => this.searchItemLimits[FacilitySearchType.Intersection] = num, true);
      this.displayModule.numVors.sub((num) => this.searchItemLimits[FacilitySearchType.Vor] = num, true);
      this.displayModule.numNdbs.sub((num) => this.searchItemLimits[FacilitySearchType.Ndb] = num, true);
      this.displayModule.airportsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Airport] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.intersectionsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Intersection] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.vorsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Vor] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.ndbsRange.sub((num) => this.searchRadiusLimits[FacilitySearchType.Ndb] = num.asUnit(UnitType.GA_RADIAN), true);
      this.displayModule.refreshWaypoints.on(() => this.waypointsLayer.instance.refreshWaypoints());
    }
    onSessionsStarted(airportSession, vorSession, ndbSession, intSession) {
      this.displayModule.intersectionsFilter.sub((filters) => intSession.setIntersectionFilter(filters.typeMask));
      this.displayModule.vorsFilter.sub((filters) => vorSession.setVorFilter(filters.classMask, filters.typeMask));
      this.displayModule.airportsFilter.sub((filters) => {
        airportSession.setAirportFilter(filters.showClosed, filters.classMask);
      });
      this.displayModule.extendedAirportsFilter.sub((filters) => {
        airportSession.setExtendedAirportFilters(filters.runwaySurfaceTypeMask, filters.approachTypeMask, filters.toweredMask, filters.minimumRunwayLength);
      });
    }
    initWaypointRenderer(renderer, canvasLayer) {
      this.defineRenderRole(renderer, canvasLayer);
      renderer.onRolesAdded.on(this.defineRenderRole.bind(this, renderer, canvasLayer));
    }
    defineRenderRole(renderer, canvasLayer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.setCanvasContext(roleId, canvasLayer.display.context);
          renderer.setIconFactory(roleId, this.props.iconFactory);
          renderer.setLabelFactory(roleId, this.props.labelFactory);
          renderer.setVisibilityHandler(roleId, this.isWaypointVisible.bind(this));
        }
      });
    }
    setVisible(val) {
      super.setVisible(val);
      this.waypointsLayer.instance.setVisible(val);
    }
    isWaypointVisible(waypoint) {
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        switch (waypoint.type) {
          case WaypointTypes.Airport:
            return this.displayModule.showAirports.get()(waypoint);
          case WaypointTypes.Intersection:
            return this.displayModule.showIntersections.get()(waypoint);
          case WaypointTypes.VOR:
            return this.displayModule.showVors.get()(waypoint);
          case WaypointTypes.NDB:
            return this.displayModule.showNdbs.get()(waypoint);
        }
      }
      return false;
    }
    render() {
      var _a;
      return FSComponent.buildComponent(MapNearestWaypointsLayer, { ref: this.waypointsLayer, model: this.props.model, mapProjection: this.props.mapProjection, bus: this.props.bus, waypointRenderer: this.props.waypointRenderer, waypointForFacility: (facility) => this.waypointCache.get(facility), initRenderer: this.initWaypointRenderer.bind(this), registerWaypoint: this.registerWaypoint.bind(this), deregisterWaypoint: this.deregisterWaypoint.bind(this), searchItemLimit: (type) => this.searchItemLimits[type], searchRadiusLimit: (type) => this.searchRadiusLimits[type], getSearchCenter: this.props.useMapTargetAsSearchCenter === true ? (mapProjection) => mapProjection.getTarget() : void 0, onSessionsStarted: this.onSessionsStarted.bind(this), class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" });
    }
    registerWaypoint(waypoint, renderer) {
      const selector = this.displayModule.waypointRoleSelector.get();
      if (selector) {
        const id = selector(waypoint);
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.register(waypoint, roleId, "waypoints-layer");
        }
      } else {
        const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
        groupRoles.forEach((id) => {
          const roleId = renderer.getRoleFromName(id);
          if (roleId !== void 0) {
            renderer.register(waypoint, roleId, "waypoints-layer");
          }
        });
      }
    }
    deregisterWaypoint(waypoint, renderer) {
      const groupRoles = renderer.getRoleNamesByGroup(MapSystemWaypointRoles.Normal);
      groupRoles.forEach((id) => {
        const roleId = renderer.getRoleFromName(id);
        if (roleId !== void 0) {
          renderer.deregister(waypoint, roleId, "waypoints-layer");
        }
      });
    }
  };
  var MapTerrainColorsModule = class {
    constructor() {
      this.reference = Subject.create(EBingReference.SEA);
      this.showIsoLines = Subject.create(false);
      this.colors = ArraySubject.create(BingComponent.createEarthColorsArray("#0000FF", [
        {
          elev: 0,
          color: "#000000"
        }
      ], 0, 3e4, 1));
      this.colorsElevationRange = Vec2Subject.create(Vec2Math.create(0, 3e4));
    }
  };
  var MapFlightPlanModule = class {
    constructor() {
      this.plans = [];
    }
    getPlanSubjects(index) {
      let planSubject = this.plans[index];
      if (planSubject === void 0) {
        planSubject = new PlanSubjects();
        this.plans[index] = planSubject;
      }
      return planSubject;
    }
  };
  var PlanSubjects = class {
    constructor() {
      this.flightPlan = Subject.create(void 0);
      this.planChanged = new SubEvent();
      this.planCalculated = new SubEvent();
      this.activeLeg = Subject.create(0);
    }
  };
  var MapFollowAirplaneModule = class {
    constructor() {
      this.isFollowing = Subject.create(false);
    }
  };
  var MapWaypointDisplayModule = class {
    constructor() {
      this.showAirports = Subject.create(() => true);
      this.showIntersections = Subject.create(() => false);
      this.showNdbs = Subject.create(() => true);
      this.showVors = Subject.create(() => true);
      this.airportsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.intersectionsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(50));
      this.ndbsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.vorsRange = NumberUnitSubject.createFromNumberUnit(UnitType.NMILE.createNumber(500));
      this.numAirports = Subject.create(40);
      this.numIntersections = Subject.create(40);
      this.numNdbs = Subject.create(40);
      this.numVors = Subject.create(40);
      this.intersectionsFilter = Subject.create({
        typeMask: NearestIntersectionSearchSession.Defaults.TypeMask,
        showTerminalWaypoints: true
      });
      this.vorsFilter = Subject.create({
        typeMask: NearestVorSearchSession.Defaults.TypeMask,
        classMask: NearestVorSearchSession.Defaults.ClassMask
      });
      this.airportsFilter = Subject.create({
        classMask: NearestAirportSearchSession.Defaults.ClassMask,
        showClosed: NearestAirportSearchSession.Defaults.ShowClosed
      });
      this.extendedAirportsFilter = Subject.create({
        runwaySurfaceTypeMask: NearestAirportSearchSession.Defaults.SurfaceTypeMask,
        approachTypeMask: NearestAirportSearchSession.Defaults.ApproachTypeMask,
        minimumRunwayLength: NearestAirportSearchSession.Defaults.MinimumRunwayLength,
        toweredMask: NearestAirportSearchSession.Defaults.ToweredMask
      });
      this.waypointRoleSelector = Subject.create(void 0);
      this.refreshWaypoints = new SubEvent();
    }
  };
  var MapWxrModule = class {
    constructor() {
      this.isEnabled = Subject.create(false);
      this.weatherRadarArc = NumberUnitSubject.create(UnitType.DEGREE.createNumber(90));
      this.weatherRadarMode = Subject.create(EWeatherRadar.HORIZONTAL);
      this.weatherRadarColors = ArraySubject.create(Array.from(BingComponent.DEFAULT_WEATHER_COLORS));
      this._wxrMode = MappedSubject.create(([isEnabled, arc, mode]) => {
        return {
          mode: isEnabled ? mode : EWeatherRadar.OFF,
          arcRadians: arc.asUnit(UnitType.RADIAN)
        };
      }, this.isEnabled, this.weatherRadarArc, this.weatherRadarMode);
    }
    get wxrMode() {
      return this._wxrMode;
    }
  };
  var WaypointDisplayBuilder = class {
    constructor(iconFactory, labelFactory, waypointRenderer) {
      this.iconFactory = iconFactory;
      this.labelFactory = labelFactory;
      this.waypointRenderer = waypointRenderer;
      this.roleGroup = MapSystemWaypointRoles.Normal;
      this.isCenterTarget = false;
    }
    addIcon(role, type, config4) {
      this.iconFactory.addIconFactory(this.determineRoleId(role), type, config4);
      return this;
    }
    addDefaultIcon(role, config4) {
      this.iconFactory.addDefaultIconFactory(this.determineRoleId(role), config4);
      return this;
    }
    addLabel(role, type, config4) {
      this.labelFactory.addLabelFactory(this.determineRoleId(role), type, config4);
      return this;
    }
    addDefaultLabel(role, config4) {
      this.labelFactory.addDefaultLabelFactory(this.determineRoleId(role), config4);
      return this;
    }
    determineRoleId(role) {
      let roleId = 0;
      if (typeof role === "string") {
        const roleIdFromName = this.waypointRenderer.getRoleFromName(role);
        if (roleIdFromName !== void 0) {
          roleId = roleIdFromName;
        }
      } else {
        roleId = role;
      }
      return roleId;
    }
    registerRole(name69) {
      this.waypointRenderer.addRenderRole(name69, void 0, this.roleGroup);
      return this;
    }
    getRoleId(role) {
      const roleId = this.waypointRenderer.getRoleFromName(role);
      if (roleId === void 0) {
        throw new Error(`The role with name ${role} was not defined and could not be found.`);
      }
      return roleId;
    }
    withSearchCenter(center) {
      if (center === "center") {
        this.isCenterTarget = false;
      } else {
        this.isCenterTarget = true;
      }
      return this;
    }
    getIsCenterTarget() {
      return this.isCenterTarget;
    }
    withWaypointCache(cache) {
      this.facilityWaypointCache = cache;
      return this;
    }
    getWaypointCache() {
      return this.facilityWaypointCache;
    }
  };
  var FlightPlanDisplayBuilder = class extends WaypointDisplayBuilder {
    constructor(iconFactory, labelFactory, waypointRenderer, flightPlanRenderer, planIndex) {
      super(iconFactory, labelFactory, waypointRenderer);
      this.flightPlanRenderer = flightPlanRenderer;
      this.planIndex = planIndex;
      this.roleGroup = MapSystemWaypointRoles.FlightPlan;
      this.roleGroup = `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`;
      flightPlanRenderer.legStyleHandlers;
    }
    registerRole(name69) {
      this.waypointRenderer.insertRenderRole(name69, MapSystemWaypointRoles.Normal, void 0, this.roleGroup);
      return this;
    }
    withLegPathStyles(handler) {
      this.flightPlanRenderer.legStyleHandlers.set(this.planIndex, handler);
      return this;
    }
    withLegWaypointRoles(handler) {
      this.flightPlanRenderer.legWaypointHandlers.set(this.planIndex, handler);
      return this;
    }
    withAnticipationTurns(visible) {
      const visibleSub = SubscribableUtils.toSubscribable(visible, true);
      this.flightPlanRenderer.renderEgress = visibleSub;
      this.flightPlanRenderer.renderIngress = visibleSub;
      return this;
    }
  };
  var GenericAirspaceRenderManager = class {
    constructor(renderOrder, selectRenderer) {
      this.renderOrder = renderOrder;
      this.selectRenderer = selectRenderer;
      this.airspaces = /* @__PURE__ */ new Map();
    }
    getRegisteredAirspaces() {
      return Array.from(this.airspaces.values());
    }
    registerAirspace(airspace) {
      if (this.airspaces.has(airspace.facility.id)) {
        return false;
      }
      this.airspaces.set(airspace.facility.id, airspace);
      return true;
    }
    deregisterAirspace(airspace) {
      return this.airspaces.delete(airspace.facility.id);
    }
    replaceRegisteredAirspaces(airspaces) {
      let changed = false;
      let numMatched = 0;
      for (const airspace of airspaces) {
        changed || (changed = !this.airspaces.has(airspace.facility.id));
        if (changed) {
          break;
        } else {
          numMatched++;
        }
      }
      changed || (changed = numMatched !== this.airspaces.size);
      if (!changed) {
        return false;
      }
      this.airspaces.clear();
      for (const airspace of airspaces) {
        this.registerAirspace(airspace);
      }
      return true;
    }
    clearRegisteredAirspaces() {
      if (this.airspaces.size === 0) {
        return false;
      }
      this.airspaces.clear();
      return true;
    }
    prepareRenderProcess(projection, context, taskQueueHandler, lod = 0, stream) {
      const sorted = Array.from(this.airspaces.values()).sort(this.renderOrder);
      const tasks = sorted.map((airspace) => {
        const renderer = this.selectRenderer(airspace);
        return renderer.render.bind(renderer, airspace, projection, context, lod, stream);
      });
      return new ThrottledTaskQueueProcess(new ArrayTaskQueue(tasks), taskQueueHandler);
    }
  };
  var MapAutopilotPropsController = class extends MapSystemController {
    constructor(context, properties, updateFreq) {
      super(context);
      this.properties = properties;
      this.updateFreq = updateFreq;
      this.module = this.context.model.getModule(MapSystemKeys.AutopilotProps);
      this.subs = {};
    }
    onAfterMapRender() {
      const sub2 = this.context.bus.getSubscriber();
      if (this.updateFreq) {
        this.updateFreqSub = this.updateFreq.sub((freq) => {
          var _a;
          for (const property of this.properties) {
            (_a = this.subs[property]) === null || _a === void 0 ? void 0 : _a.destroy();
            this.subs[property] = this.bindProperty(sub2, property, freq);
          }
        }, true);
      } else {
        for (const property of this.properties) {
          this.subs[property] = this.bindProperty(sub2, property);
        }
      }
    }
    bindProperty(sub2, property, updateFreq) {
      switch (property) {
        case "selectedAltitude":
          return (updateFreq === void 0 ? sub2.on("ap_altitude_selected") : sub2.on("ap_altitude_selected").atFrequency(updateFreq)).handle((alt) => {
            this.module.selectedAltitude.set(alt, UnitType.FOOT);
          });
      }
    }
    onMapDestroyed() {
      this.destroy();
    }
    destroy() {
      var _a, _b;
      super.destroy();
      (_a = this.updateFreqSub) === null || _a === void 0 ? void 0 : _a.destroy();
      for (const property of this.properties) {
        (_b = this.subs[property]) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
  var MapSystemComponent = class extends MapComponent {
    constructor(props) {
      var _a;
      super(props);
      this.rootStyles = ObjectSubject.create({
        width: "0px",
        height: "0px"
      });
      this.deadZone = (_a = this.props.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.create(new Float64Array(4));
      this.deadZone.sub(this.onDeadZoneChanged.bind(this));
    }
    onAfterRender(thisNode) {
      super.onAfterRender(thisNode);
      this.onProjectedSizeChanged();
      this.props.onAfterRender();
    }
    onDeadZoneChanged(deadZone) {
      this.props.onDeadZoneChanged(deadZone);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      super.onMapProjectionChanged(mapProjection, changeFlags);
      this.props.onMapProjectionChanged(mapProjection, changeFlags);
    }
    setRootSize(size2) {
      this.rootStyles.set("width", `${size2[0]}px`);
      this.rootStyles.set("height", `${size2[1]}px`);
    }
    onProjectedSizeChanged() {
      this.setRootSize(this.mapProjection.getProjectedSize());
    }
    onUpdated(time, elapsed) {
      this.props.onBeforeUpdated(time, elapsed);
      super.onUpdated(time, elapsed);
      this.props.onAfterUpdated(time, elapsed);
    }
    onWake() {
      super.onWake();
      this.props.onWake();
    }
    onSleep() {
      super.onSleep();
      this.props.onSleep();
    }
    render() {
      var _a;
      return FSComponent.buildComponent("div", { style: this.rootStyles, class: (_a = this.props.class) !== null && _a !== void 0 ? _a : "" }, this.props.children);
    }
    destroy() {
      super.destroy();
      this.props.onDestroy();
    }
  };
  var DefaultMapSystemContext = class {
    constructor(bus, projection, projectedSize, deadZone) {
      this.bus = bus;
      this.projection = projection;
      this.projectedSize = projectedSize;
      this.deadZone = deadZone;
      this.model = new MapModel();
      this.layers = /* @__PURE__ */ new Map();
      this.controllers = /* @__PURE__ */ new Map();
    }
    getLayer(key) {
      return this.layers.get(key);
    }
    getController(key) {
      return this.controllers.get(key);
    }
    setLayer(key, layer) {
      this.layers.set(key, layer);
    }
    setController(key, controller) {
      this.controllers.set(key, controller);
    }
  };
  var MapSystemGenericController = class extends MapSystemController {
    constructor(context, callbacks) {
      super(context);
      this.callbacks = callbacks;
    }
    onAfterMapRender() {
      this.callbacks.onAfterMapRender && this.callbacks.onAfterMapRender(this.context);
    }
    onDeadZoneChanged(deadZone) {
      this.callbacks.onDeadZoneChanged && this.callbacks.onDeadZoneChanged(this.context, deadZone);
    }
    onMapProjectionChanged(mapProjection, changeFlags) {
      this.callbacks.onMapProjectionChanged && this.callbacks.onMapProjectionChanged(this.context, mapProjection, changeFlags);
    }
    onBeforeUpdated(time, elapsed) {
      this.callbacks.onBeforeUpdated && this.callbacks.onBeforeUpdated(this.context, time, elapsed);
    }
    onAfterUpdated(time, elapsed) {
      this.callbacks.onAfterUpdated && this.callbacks.onAfterUpdated(this.context, time, elapsed);
    }
    onWake() {
      this.callbacks.onWake && this.callbacks.onWake(this.context);
    }
    onSleep() {
      this.callbacks.onSleep && this.callbacks.onSleep(this.context);
    }
    onMapDestroyed() {
      this.callbacks.onMapDestroyed && this.callbacks.onMapDestroyed(this.context);
    }
    destroy() {
      super.destroy();
      this.callbacks.onDestroyed && this.callbacks.onDestroyed(this.context);
    }
  };
  var MapSystemPlanRenderer = class extends AbstractFlightPathPlanRenderer {
    constructor(defaultRoleId, renderOrder, renderActiveLegLast) {
      super(renderOrder, renderActiveLegLast);
      this.defaultRoleId = defaultRoleId;
      this.legRenderer = new MapSystemLegRenderer();
      this.legStyleHandlers = /* @__PURE__ */ new Map();
      this.legWaypointHandlers = /* @__PURE__ */ new Map();
      this.renderIngress = Subject.create(false);
      this.renderEgress = Subject.create(false);
    }
    renderLeg(leg, plan, activeLeg, legIndex, activeLegIndex, context, streamStack) {
      this.legRenderer.currentRenderStyle = FlightPathRenderStyle.Default;
      const handler = this.legStyleHandlers.get(plan.planIndex);
      if (handler !== void 0) {
        this.legRenderer.currentRenderStyle = handler(plan, leg, activeLeg, legIndex, activeLegIndex);
      }
      let partsToRender = FlightPathLegRenderPart.Base | (this.renderIngress.get() ? FlightPathLegRenderPart.Ingress : 0) | (this.renderEgress.get() ? FlightPathLegRenderPart.Egress : 0);
      if (this.legRenderer.currentRenderStyle.partsToRender !== void 0) {
        partsToRender = this.legRenderer.currentRenderStyle.partsToRender;
      }
      this.legRenderer.render(leg, context, streamStack, partsToRender);
    }
  };
  var MapSystemLegRenderer = class extends AbstractFlightPathLegRenderer {
    constructor() {
      super(...arguments);
      this.vectorRenderer = new FlightPathVectorLineRenderer();
      this.currentRenderStyle = new FlightPathRenderStyle();
    }
    renderVector(vector, isIngress, isEgress, leg, context, streamStack) {
      if ("styleBuilder" in this.currentRenderStyle) {
        const currentRenderStyle = this.currentRenderStyle.styleBuilder(vector, isIngress, isEgress);
        this.vectorRenderer.render(vector, context, streamStack, currentRenderStyle.width, currentRenderStyle.style, currentRenderStyle.dash, currentRenderStyle.outlineWidth, currentRenderStyle.outlineStyle);
      } else {
        if (this.currentRenderStyle.isDisplayed) {
          this.vectorRenderer.render(vector, context, streamStack, this.currentRenderStyle.width, this.currentRenderStyle.style, this.currentRenderStyle.dash, this.currentRenderStyle.outlineWidth, this.currentRenderStyle.outlineStyle);
        }
      }
    }
  };
  var FlightPathRenderStyle = class {
    constructor(isDisplayed = true) {
      this.isDisplayed = isDisplayed;
      this.width = 2;
      this.style = "";
    }
  };
  FlightPathRenderStyle.Default = new FlightPathRenderStyle();
  FlightPathRenderStyle.Hidden = new FlightPathRenderStyle(false);
  var MapSystemUtils = class {
    static nominalToTrueRelativeX(nominalRelX, width, deadZone) {
      return (nominalRelX * (width - deadZone[0] - deadZone[2]) + deadZone[0]) / width;
    }
    static nominalToTrueRelativeY(nominalRelY, height, deadZone) {
      return (nominalRelY * (height - deadZone[1] - deadZone[3]) + deadZone[1]) / height;
    }
    static nominalToTrueRelativeXY(nominal, size2, deadZone, out) {
      return Vec2Math.set(MapSystemUtils.nominalToTrueRelativeX(nominal[0], size2[0], deadZone), MapSystemUtils.nominalToTrueRelativeY(nominal[1], size2[1], deadZone), out);
    }
  };
  var MapSystemWaypointsRenderer = class extends MapWaypointRenderer {
    constructor(textManager) {
      super(textManager, (entry, roleDefinitions) => {
        var _a;
        for (let i = 0; i < this.rolePriorityOrder.length; i++) {
          const role = this.rolePriorityOrder[i];
          if (entry.isAllRoles(role) && ((_a = roleDefinitions.get(role)) === null || _a === void 0 ? void 0 : _a.visibilityHandler(entry.waypoint))) {
            return role;
          }
        }
        return 0;
      });
      this.rolePriorityOrder = [];
      this.rolesByGroup = /* @__PURE__ */ new Map();
      this.roleIdMap = /* @__PURE__ */ new Map();
      this.currentBit = 1;
      this.onRolesAdded = new SubEvent();
    }
    addRenderRole(arg1, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      if (typeof arg1 === "number") {
        return false;
      }
      this.roleIdMap.set(arg1, this.currentBit);
      super.addRenderRole(this.currentBit, def);
      this.rolePriorityOrder.push(this.currentBit);
      let roleGroup = this.rolesByGroup.get(group);
      if (roleGroup === void 0) {
        roleGroup = [];
        this.rolesByGroup.set(group, roleGroup);
      }
      roleGroup.push(arg1);
      this.currentBit *= 2;
      this.onRolesAdded.notify(this);
      return true;
    }
    insertRenderRole(name69, insertBefore, def, group = MapSystemWaypointsRenderer.DefaultGroup) {
      const role = this.currentBit;
      this.addRenderRole(name69, def, group);
      const roleToInsertBefore = this.roleIdMap.get(insertBefore);
      if (roleToInsertBefore !== void 0) {
        const indexToInsertBefore = this.rolePriorityOrder.indexOf(roleToInsertBefore);
        if (indexToInsertBefore >= 0 && indexToInsertBefore < this.rolePriorityOrder.length - 1) {
          this.rolePriorityOrder.pop();
          this.rolePriorityOrder.splice(indexToInsertBefore, 0, role);
        }
      }
      return true;
    }
    getRoleFromName(name69) {
      return this.roleIdMap.get(name69);
    }
    getRoleNamesByGroup(group) {
      const roleNames = this.rolesByGroup.get(group);
      if (roleNames !== void 0) {
        return roleNames;
      }
      return [];
    }
  };
  MapSystemWaypointsRenderer.DefaultGroup = "DEFAULT_GROUP";
  var MapSystemIconFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.iconFactories = /* @__PURE__ */ new Map();
      this.defaultIconFactories = /* @__PURE__ */ new Map();
    }
    addIconFactory(role, iconType, factory2) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      roleFactories.set(iconType, factory2);
    }
    addDefaultIconFactory(role, factory2) {
      this.defaultIconFactories.set(role, factory2);
    }
    getIcon(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let icon = roleCache.get(waypoint.uid);
      if (icon === void 0) {
        icon = this.createIcon(role, waypoint);
        roleCache.set(waypoint.uid, icon);
      }
      return icon;
    }
    createIcon(role, waypoint) {
      if (!this.iconFactories.has(role)) {
        this.iconFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.iconFactories.get(role);
      const factory2 = roleFactories.get(waypoint.type);
      if (factory2 !== void 0) {
        return factory2(waypoint);
      } else {
        const defaultFactory = this.defaultIconFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      const imageEl = document.createElement("img");
      imageEl.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFjSURBVFhHvZarTsVAEIa3qCMQCAxPgEEikDwGAkGCAIFAIHgQHgGJ4C0Q4AiBN8CQQAIJuOGfs9N0d3p62tlLv+RPd2fFNrNfLy4Lov1lMtiQayqnyJkfzg3RAvlEfpEtqZrJ6cARwhsvkGMuzAvRA0KSZ6nOBNFesHmbA1k1kXoEq8SbScZOPt2BJBlTOtDKx7whT344l4yxfFfIeTCvLGMsH7d8G9lEvqXGMcloPYJQtHvXNB/ID8a3vrSkkox9+Q5lhdf4m9DWs96MwxCdBJu8SrWD6DFYv5BqQbR8mqoyrpJPkyjjVAn78mmqybhOPk0VGcfk0xSXcUw+TVEZp8inMco4JuG4fJpiMlrk0xSR0SqfJltGq3yaLBlT5NNMlHFIQrt8mokyNnLtYPmce0dace6QFz80s4vwLxzzh+zgxr78dIhYvtK5lF3WEMtXOr2nKT4C3/5rP6nGTZJTdXDuH4TJQyPZ/x+gAAAAAElFTkSuQmCC";
      return new MapWaypointImageIcon(waypoint, 0, imageEl, Vec2Math.create(24, 24));
    }
  };
  var MapSystemLabelFactory = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
      this.labelFactories = /* @__PURE__ */ new Map();
      this.defaultLabelFactories = /* @__PURE__ */ new Map();
    }
    addLabelFactory(role, iconType, factory2) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      roleFactories.set(iconType, factory2);
    }
    addDefaultLabelFactory(role, factory2) {
      this.defaultLabelFactories.set(role, factory2);
    }
    getLabel(role, waypoint) {
      if (!this.cache.has(role)) {
        this.cache.set(role, /* @__PURE__ */ new Map());
      }
      const roleCache = this.cache.get(role);
      let label = roleCache.get(waypoint.uid);
      if (label === void 0) {
        label = this.createLabel(role, waypoint);
        roleCache.set(waypoint.uid, label);
      }
      return label;
    }
    createLabel(role, waypoint) {
      if (!this.labelFactories.has(role)) {
        this.labelFactories.set(role, /* @__PURE__ */ new Map());
      }
      const roleFactories = this.labelFactories.get(role);
      const factory2 = roleFactories.get(waypoint.type);
      if (factory2 !== void 0) {
        return factory2(waypoint);
      } else {
        const defaultFactory = this.defaultLabelFactories.get(role);
        if (defaultFactory !== void 0) {
          return defaultFactory(waypoint);
        }
      }
      let text = "";
      if (FacilityWaypointUtils.isFacilityWaypoint(waypoint)) {
        text = ICAO.getIdent(waypoint.facility.get().icao);
      }
      return new MapCullableLocationTextLabel(text, 0, waypoint.location, false, { fontSize: 22, font: "monospace", anchor: new Float64Array([-0.25, 0.4]) });
    }
  };
  var MapSystemBuilder = class {
    constructor(bus) {
      this.bus = bus;
      this.moduleFactories = /* @__PURE__ */ new Map();
      this.layerFactories = /* @__PURE__ */ new Map();
      this.controllerFactories = /* @__PURE__ */ new Map();
      this.contextFactories = /* @__PURE__ */ new Map();
      this.initCallbacks = /* @__PURE__ */ new Map();
      this.projectedSize = Subject.create(Vec2Math.create(100, 100));
    }
    get moduleCount() {
      return this.moduleFactories.size;
    }
    get layerCount() {
      return this.layerFactories.size;
    }
    get controllerCount() {
      return this.controllerFactories.size;
    }
    static create(bus) {
      return new MapSystemBuilder(bus);
    }
    withProjectedSize(size2) {
      this.projectedSize = "isSubscribable" in size2 ? size2 : Subject.create(size2);
      return this;
    }
    withDeadZone(deadZone) {
      this.deadZone = "isSubscribable" in deadZone ? deadZone : VecNSubject.createFromVector(new Float64Array(deadZone));
      return this;
    }
    withTargetOffset(offset) {
      this.targetOffset = offset;
      return this;
    }
    withRangeEndpoints(endpoints) {
      this.nominalRangeEndpoints = endpoints;
      return this;
    }
    withRange(range2) {
      this.range = range2.asUnit(UnitType.GA_RADIAN);
      return this;
    }
    withModule(key, factory2) {
      this.moduleFactories.set(key, { key, factory: factory2 });
      return this;
    }
    withLayer(key, factory2, order) {
      const wasDeleted = this.layerFactories.delete(key);
      this.layerFactories.set(key, { key, factory: factory2, order: order !== null && order !== void 0 ? order : this.layerFactories.size + (wasDeleted ? 1 : 0) });
      return this;
    }
    withController(key, factory2) {
      this.controllerFactories.set(key, { factory: factory2 });
      return this;
    }
    withContext(key, factory2) {
      var _a;
      if (!MapSystemBuilder.RESTRICTED_CONTEXT_KEYS.has(key)) {
        const existing = this.contextFactories.get(key);
        const order = (_a = existing === null || existing === void 0 ? void 0 : existing.order) !== null && _a !== void 0 ? _a : this.contextFactories.size;
        this.contextFactories.set(key, { key, factory: factory2, order });
      }
      return this;
    }
    withInit(key, callback) {
      this.initCallbacks.set(key, callback);
      return this;
    }
    withLayerOrder(key, order) {
      const factory2 = this.layerFactories.get(key);
      if (factory2) {
        this.layerFactories.delete(key);
        factory2.order = order;
        this.layerFactories.set(key, factory2);
      }
      return this;
    }
    withBindings(key, bindings, onDestroy) {
      return this.withController(key, (context) => new MapBindingsController(context, bindings(context), onDestroy));
    }
    withClockUpdate(updateFreq) {
      return this.withContext("updateFreq", () => typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq).withController(MapSystemKeys.ClockUpdate, (context) => new MapClockUpdateController(context));
    }
    withTargetControlModerator() {
      return this.withContext(MapSystemKeys.TargetControl, () => new ResourceModerator(void 0));
    }
    withRotationControlModerator() {
      return this.withContext(MapSystemKeys.RotationControl, () => new ResourceModerator(void 0));
    }
    withRangeControlModerator() {
      return this.withContext(MapSystemKeys.RangeControl, () => new ResourceModerator(void 0));
    }
    withFollowAirplane() {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.FollowAirplane, () => new MapFollowAirplaneModule()).withTargetControlModerator().withController(MapSystemKeys.FollowAirplane, (context) => new MapFollowAirplaneController(context));
    }
    withRotation() {
      return this.withModule(MapSystemKeys.Rotation, () => new MapRotationModule()).withRotationControlModerator().withController(MapSystemKeys.Rotation, (context) => new MapRotationController(context));
    }
    withOwnAirplaneIcon(iconSize, iconFilePath, iconAnchor, cssClass, order) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.OwnAirplaneIcon, () => new MapOwnAirplaneIconModule()).withLayer(MapSystemKeys.OwnAirplaneIcon, (context) => {
        return FSComponent.buildComponent(MapOwnAirplaneLayer, { model: context.model, mapProjection: context.projection, imageFilePath: iconFilePath, iconSize, iconAnchor, class: cssClass });
      }, order);
    }
    withOwnAirplaneIconOrientation(desiredOrientation) {
      return this.withController(MapSystemKeys.OwnAirplaneIconOrientation, (context) => new MapOwnAirplaneIconOrientationController(context, desiredOrientation));
    }
    withOwnAirplanePropBindings(properties, updateFreq) {
      return this.withController(MapSystemKeys.OwnAirplaneProps, (context) => new MapOwnAirplanePropsController(context, properties, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
    }
    withAutopilotProps(propertiesToBind, updateFreq) {
      this.withModule(MapSystemKeys.AutopilotProps, () => new MapAutopilotPropsModule());
      if (propertiesToBind !== void 0) {
        this.withController(MapSystemKeys.AutopilotProps, (context) => new MapAutopilotPropsController(context, propertiesToBind, typeof updateFreq === "number" ? Subject.create(updateFreq) : updateFreq));
      }
      return this;
    }
    withTextLayer(enableCulling, order, cssClass) {
      return this.withContext(MapSystemKeys.TextManager, () => new MapCullableTextLabelManager(enableCulling)).withLayer(MapSystemKeys.TextLayer, (context) => {
        return FSComponent.buildComponent(MapCullableTextLayer, { model: context.model, mapProjection: context.projection, manager: context.textManager, class: cssClass });
      }, order);
    }
    withBing(bingId, delay = 0, mode, order, cssClass) {
      return this.withModule(MapSystemKeys.TerrainColors, () => new MapTerrainColorsModule()).withModule(MapSystemKeys.Weather, () => new MapWxrModule()).withLayer(MapSystemKeys.Bing, (context) => {
        const terrainColors = context.model.getModule("terrainColors");
        const weather = context.model.getModule("weather");
        return FSComponent.buildComponent(MapBingLayer, { model: context.model, mapProjection: context.projection, bingId, reference: terrainColors.reference, earthColors: terrainColors.colors, earthColorsElevationRange: terrainColors.colorsElevationRange, isoLines: terrainColors.showIsoLines, wxrMode: weather.wxrMode, wxrColors: weather.weatherRadarColors, mode, delay, class: cssClass });
      }, order);
    }
    withWaypoints() {
      return this.withContext(MapSystemKeys.WaypointRenderer, (context) => new MapSystemWaypointsRenderer(context[MapSystemKeys.TextManager])).withController("waypointRendererUpdate", (context) => new MapSystemGenericController(context, {
        onAfterUpdated: (contextArg) => {
          contextArg[MapSystemKeys.WaypointRenderer].update(context.projection);
        }
      }));
    }
    withNearestWaypoints(configure, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling).withModule(MapSystemKeys.NearestWaypoints, () => new MapWaypointDisplayModule()).withWaypoints().withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory());
      let facilityWaypointCache = void 0;
      this.withContext("useTargetAsWaypointSearchCenter", (context) => {
        context[MapSystemKeys.WaypointRenderer].addRenderRole(MapSystemWaypointRoles.Normal, void 0, MapSystemWaypointRoles.Normal);
        const builder = new WaypointDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer]);
        configure(builder);
        facilityWaypointCache = builder.getWaypointCache();
        return builder.getIsCenterTarget();
      });
      const layerCount = this.layerCount;
      return this.withLayer(MapSystemKeys.NearestWaypoints, (context) => {
        return FSComponent.buildComponent(MapSystemWaypointsLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], useMapTargetAsSearchCenter: context.useTargetAsWaypointSearchCenter, waypointCache: facilityWaypointCache, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    withFlightPlan(configure, flightPlanner, planIndex, enableTextCulling = false, order, cssClass) {
      this.withTextLayer(enableTextCulling, void 0, "flight-plan-text-layer").withModule(MapSystemKeys.FlightPlan, () => new MapFlightPlanModule()).withWaypoints().withContext(MapSystemKeys.FlightPlanner, () => flightPlanner).withContext(MapSystemKeys.IconFactory, () => new MapSystemIconFactory()).withContext(MapSystemKeys.LabelFactory, () => new MapSystemLabelFactory()).withContext(MapSystemKeys.FlightPathRenderer, () => new MapSystemPlanRenderer(1)).withController(MapSystemKeys.FlightPlan, (context) => new MapFlightPlanController(context)).withInit(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        const builder = new FlightPlanDisplayBuilder(context[MapSystemKeys.IconFactory], context[MapSystemKeys.LabelFactory], context[MapSystemKeys.WaypointRenderer], context[MapSystemKeys.FlightPathRenderer], planIndex);
        context[MapSystemKeys.WaypointRenderer].insertRenderRole(MapSystemWaypointRoles.FlightPlan, MapSystemWaypointRoles.Normal, void 0, `${MapSystemWaypointRoles.FlightPlan}_${planIndex}`);
        configure(builder);
      });
      const layerCount = this.layerCount;
      return this.withLayer(`${MapSystemKeys.FlightPlan}${planIndex}`, (context) => {
        return FSComponent.buildComponent(MapSystemFlightPlanLayer, { bus: context.bus, waypointRenderer: context[MapSystemKeys.WaypointRenderer], model: context.model, mapProjection: context.projection, iconFactory: context[MapSystemKeys.IconFactory], labelFactory: context[MapSystemKeys.LabelFactory], flightPathRenderer: context[MapSystemKeys.FlightPathRenderer], planIndex, class: cssClass });
      }, order).withLayerOrder(MapSystemKeys.TextLayer, order !== null && order !== void 0 ? order : layerCount);
    }
    withAirspaces(cache, showTypes, selectRenderer, renderOrder = () => 0, options, order) {
      return this.withModule(MapSystemKeys.Airspace, () => new MapAirspaceModule(showTypes)).withContext(MapSystemKeys.AirspaceManager, () => new GenericAirspaceRenderManager(renderOrder, selectRenderer)).withLayer(MapSystemKeys.Airspace, (context) => {
        var _a, _b;
        const optionsToUse = Object.assign({}, options);
        (_a = optionsToUse.maxSearchRadius) !== null && _a !== void 0 ? _a : optionsToUse.maxSearchRadius = Subject.create(UnitType.NMILE.createNumber(10));
        (_b = optionsToUse.maxSearchItemCount) !== null && _b !== void 0 ? _b : optionsToUse.maxSearchItemCount = Subject.create(100);
        return FSComponent.buildComponent(MapAirspaceLayer, Object.assign({ model: context.model, mapProjection: context.projection, bus: context.bus, lodBoundaryCache: cache, airspaceRenderManager: context[MapSystemKeys.AirspaceManager] }, optionsToUse));
      }, order);
    }
    withTraffic(tcas, iconFactory, initCanvasStyles, offScaleOobOptions, order, cssClass) {
      return this.withModule(MapSystemKeys.OwnAirplaneProps, () => new MapOwnAirplanePropsModule()).withModule(MapSystemKeys.Traffic, () => new MapTrafficModule(tcas)).withLayer("traffic", (context) => {
        const options = offScaleOobOptions !== void 0 ? Object.assign({}, offScaleOobOptions(context)) : {};
        if (options.oobOffset !== void 0 && !("isSubscribable" in options.oobOffset)) {
          options.oobOffset = Subject.create(options.oobOffset);
        }
        return FSComponent.buildComponent(MapSystemTrafficLayer, Object.assign({ context, model: context.model, mapProjection: context.projection, iconFactory, initCanvasStyles, class: cssClass }, options));
      }, order);
    }
    with(builder, ...args) {
      return builder(this, ...args);
    }
    build(cssClass) {
      const context = this.buildContext();
      const controllers = [];
      const ref = FSComponent.createRef();
      const onAfterRender = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterMapRender(ref.instance);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterMapRender() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDeadZoneChanged = (deadZone) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onDeadZoneChanged(deadZone);
          } catch (e) {
            console.error(`MapSystem: error in controller .onDeadZoneChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onMapProjectionChanged = (mapProjection, changeFlags) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapProjectionChanged(mapProjection, changeFlags);
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapProjectionChanged() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onBeforeUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onBeforeUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onBeforeUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
        context.projection.applyQueued();
      };
      const onAfterUpdated = (time, elapsed) => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onAfterUpdated(time, elapsed);
          } catch (e) {
            console.error(`MapSystem: error in controller .onAfterUpdated() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onWake = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onWake();
          } catch (e) {
            console.error(`MapSystem: error in controller .onWake() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onSleep = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onSleep();
          } catch (e) {
            console.error(`MapSystem: error in controller .onSleep() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const onDestroy = () => {
        for (let i = 0; i < controllers.length; i++) {
          if (!controllers[i].isAlive) {
            controllers.splice(i, 1);
            i--;
          }
          try {
            controllers[i].onMapDestroyed();
          } catch (e) {
            console.error(`MapSystem: error in controller .onMapDestroyed() callback: ${e}`);
            if (e instanceof Error) {
              console.error(e.stack);
            }
          }
        }
      };
      const map = FSComponent.buildComponent(MapSystemComponent, { ref, model: context.model, projection: context.projection, bus: context.bus, projectedSize: this.projectedSize, onAfterRender, onDeadZoneChanged, onMapProjectionChanged, onBeforeUpdated, onAfterUpdated, onWake, onSleep, onDestroy, class: cssClass }, Array.from(this.layerFactories.values()).sort((a, b) => a.order - b.order).map((factory2) => {
        const node = factory2.factory(context);
        context.setLayer(factory2.key, node.instance);
        return node;
      }));
      const controllerEntries = Array.from(this.controllerFactories).map(([key, factory2]) => [key, factory2.factory(context)]);
      for (const [key, controller] of controllerEntries) {
        context.setController(key, controller);
      }
      controllers.push(...controllerEntries.map(([, controller]) => controller));
      for (const callback of this.initCallbacks.values()) {
        callback(context);
      }
      return { context, map, ref };
    }
    buildContext() {
      var _a;
      const context = new DefaultMapSystemContext(this.bus, new MapProjection(this.projectedSize.get()[0], this.projectedSize.get()[1]), this.projectedSize, (_a = this.deadZone) !== null && _a !== void 0 ? _a : VecNSubject.createFromVector(new Float64Array(4)));
      context.projection.set({
        targetProjectedOffset: this.targetOffset,
        rangeEndpoints: this.nominalRangeEndpoints !== void 0 ? MapSystemUtils.nominalToTrueRelativeXY(this.nominalRangeEndpoints, context.projectedSize.get(), context.deadZone.get(), Vec2Math.create()) : void 0,
        range: this.range
      });
      for (const factory2 of Array.from(this.contextFactories.values()).sort((a, b) => a.order - b.order)) {
        context[factory2.key] = factory2.factory(context);
      }
      for (const factory2 of this.moduleFactories.values()) {
        context.model.addModule(factory2.key, factory2.factory());
      }
      return context;
    }
  };
  MapSystemBuilder.RESTRICTED_CONTEXT_KEYS = /* @__PURE__ */ new Set([
    "bus",
    "model",
    "projection",
    "projectedSize",
    "deadZone",
    "getLayer",
    "setLayer",
    "getController",
    "setController"
  ]);
  var WarningType;
  (function(WarningType2) {
    WarningType2[WarningType2["Warning"] = 0] = "Warning";
    WarningType2[WarningType2["Caution"] = 1] = "Caution";
    WarningType2[WarningType2["Test"] = 2] = "Test";
    WarningType2[WarningType2["SoundOnly"] = 3] = "SoundOnly";
  })(WarningType || (WarningType = {}));
  var XMLCircularGaugeCursor;
  (function(XMLCircularGaugeCursor2) {
    XMLCircularGaugeCursor2[XMLCircularGaugeCursor2["Triangle"] = 1] = "Triangle";
  })(XMLCircularGaugeCursor || (XMLCircularGaugeCursor = {}));
  var XMLCircularGaugeValuePos;
  (function(XMLCircularGaugeValuePos2) {
    XMLCircularGaugeValuePos2[XMLCircularGaugeValuePos2["End"] = 1] = "End";
  })(XMLCircularGaugeValuePos || (XMLCircularGaugeValuePos = {}));
  var XMLHorizontalGaugeValuePos;
  (function(XMLHorizontalGaugeValuePos2) {
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["End"] = 1] = "End";
    XMLHorizontalGaugeValuePos2[XMLHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLHorizontalGaugeValuePos || (XMLHorizontalGaugeValuePos = {}));
  var XMLVerticalGaugeValuePos;
  (function(XMLVerticalGaugeValuePos2) {
    XMLVerticalGaugeValuePos2[XMLVerticalGaugeValuePos2["None"] = 1] = "None";
  })(XMLVerticalGaugeValuePos || (XMLVerticalGaugeValuePos = {}));
  var XMLDoubleHorizontalGaugeValuePos;
  (function(XMLDoubleHorizontalGaugeValuePos2) {
    XMLDoubleHorizontalGaugeValuePos2[XMLDoubleHorizontalGaugeValuePos2["Right"] = 2] = "Right";
  })(XMLDoubleHorizontalGaugeValuePos || (XMLDoubleHorizontalGaugeValuePos = {}));
  var XMLGaugeType;
  (function(XMLGaugeType2) {
    XMLGaugeType2["Circular"] = "Circular";
    XMLGaugeType2["Horizontal"] = "Horizontal";
    XMLGaugeType2["DoubleHorizontal"] = "DoubleHorizontal";
    XMLGaugeType2["Vertical"] = "Vertical";
    XMLGaugeType2["DoubleVertical"] = "DoubleVertical";
    XMLGaugeType2["Text"] = "Text";
    XMLGaugeType2["ColumnGroup"] = "ColumnGroup";
    XMLGaugeType2["Column"] = "Column";
    XMLGaugeType2["Cylinder"] = "Cylinder";
    XMLGaugeType2["TwinCylinder"] = "TwinCylinder";
  })(XMLGaugeType || (XMLGaugeType = {}));
  var AlertState;
  (function(AlertState2) {
    AlertState2[AlertState2["New"] = 0] = "New";
    AlertState2[AlertState2["Acked"] = 1] = "Acked";
  })(AlertState || (AlertState = {}));
  var APVerticalModes;
  (function(APVerticalModes2) {
    APVerticalModes2[APVerticalModes2["NONE"] = 0] = "NONE";
    APVerticalModes2[APVerticalModes2["PITCH"] = 1] = "PITCH";
    APVerticalModes2[APVerticalModes2["VS"] = 2] = "VS";
    APVerticalModes2[APVerticalModes2["FLC"] = 3] = "FLC";
    APVerticalModes2[APVerticalModes2["ALT"] = 4] = "ALT";
    APVerticalModes2[APVerticalModes2["PATH"] = 5] = "PATH";
    APVerticalModes2[APVerticalModes2["GP"] = 6] = "GP";
    APVerticalModes2[APVerticalModes2["GS"] = 7] = "GS";
    APVerticalModes2[APVerticalModes2["CAP"] = 8] = "CAP";
    APVerticalModes2[APVerticalModes2["TO"] = 9] = "TO";
    APVerticalModes2[APVerticalModes2["GA"] = 10] = "GA";
    APVerticalModes2[APVerticalModes2["FPA"] = 11] = "FPA";
    APVerticalModes2[APVerticalModes2["FLARE"] = 12] = "FLARE";
  })(APVerticalModes || (APVerticalModes = {}));
  var APLateralModes;
  (function(APLateralModes2) {
    APLateralModes2[APLateralModes2["NONE"] = 0] = "NONE";
    APLateralModes2[APLateralModes2["ROLL"] = 1] = "ROLL";
    APLateralModes2[APLateralModes2["LEVEL"] = 2] = "LEVEL";
    APLateralModes2[APLateralModes2["GPSS"] = 3] = "GPSS";
    APLateralModes2[APLateralModes2["HEADING"] = 4] = "HEADING";
    APLateralModes2[APLateralModes2["VOR"] = 5] = "VOR";
    APLateralModes2[APLateralModes2["LOC"] = 6] = "LOC";
    APLateralModes2[APLateralModes2["BC"] = 7] = "BC";
    APLateralModes2[APLateralModes2["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes2[APLateralModes2["NAV"] = 9] = "NAV";
    APLateralModes2[APLateralModes2["TO"] = 10] = "TO";
    APLateralModes2[APLateralModes2["GA"] = 11] = "GA";
    APLateralModes2[APLateralModes2["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes2[APLateralModes2["TRACK"] = 13] = "TRACK";
    APLateralModes2[APLateralModes2["TRACK_HOLD"] = 14] = "TRACK_HOLD";
  })(APLateralModes || (APLateralModes = {}));
  var APAltitudeModes;
  (function(APAltitudeModes2) {
    APAltitudeModes2[APAltitudeModes2["NONE"] = 0] = "NONE";
    APAltitudeModes2[APAltitudeModes2["ALTS"] = 1] = "ALTS";
    APAltitudeModes2[APAltitudeModes2["ALTV"] = 2] = "ALTV";
  })(APAltitudeModes || (APAltitudeModes = {}));
  var APStates;
  (function(APStates2) {
    APStates2[APStates2["None"] = 0] = "None";
    APStates2[APStates2["APActive"] = 1] = "APActive";
    APStates2[APStates2["YawDamper"] = 2] = "YawDamper";
    APStates2[APStates2["Heading"] = 4] = "Heading";
    APStates2[APStates2["Nav"] = 8] = "Nav";
    APStates2[APStates2["NavArmed"] = 16] = "NavArmed";
    APStates2[APStates2["Approach"] = 32] = "Approach";
    APStates2[APStates2["ApproachArmed"] = 64] = "ApproachArmed";
    APStates2[APStates2["Backcourse"] = 128] = "Backcourse";
    APStates2[APStates2["BackcourseArmed"] = 256] = "BackcourseArmed";
    APStates2[APStates2["Alt"] = 512] = "Alt";
    APStates2[APStates2["AltS"] = 1024] = "AltS";
    APStates2[APStates2["AltV"] = 2048] = "AltV";
    APStates2[APStates2["VS"] = 4096] = "VS";
    APStates2[APStates2["FLC"] = 8192] = "FLC";
    APStates2[APStates2["GP"] = 16384] = "GP";
    APStates2[APStates2["GPArmed"] = 32768] = "GPArmed";
    APStates2[APStates2["GS"] = 65536] = "GS";
    APStates2[APStates2["GSArmed"] = 131072] = "GSArmed";
    APStates2[APStates2["Path"] = 262144] = "Path";
    APStates2[APStates2["PathArmed"] = 524288] = "PathArmed";
    APStates2[APStates2["PathInvalid"] = 1048576] = "PathInvalid";
    APStates2[APStates2["Pitch"] = 2097152] = "Pitch";
    APStates2[APStates2["Roll"] = 4194304] = "Roll";
    APStates2[APStates2["VNAV"] = 8388608] = "VNAV";
    APStates2[APStates2["ATSpeed"] = 16777216] = "ATSpeed";
    APStates2[APStates2["ATMach"] = 33554432] = "ATMach";
    APStates2[APStates2["ATArmed"] = 67108864] = "ATArmed";
    APStates2[APStates2["FD"] = 134217728] = "FD";
  })(APStates || (APStates = {}));
  var DirectorState;
  (function(DirectorState2) {
    DirectorState2["Inactive"] = "Inactive";
    DirectorState2["Armed"] = "Armed";
    DirectorState2["Active"] = "Active";
  })(DirectorState || (DirectorState = {}));
  var EmptyDirector = class {
    constructor() {
      this.onActivate = () => {
      };
      this.onArm = () => {
      };
      this.state = DirectorState.Inactive;
    }
    activate() {
    }
    deactivate() {
    }
    update() {
    }
    arm() {
    }
  };
  EmptyDirector.instance = new EmptyDirector();
  var VNavState;
  (function(VNavState2) {
    VNavState2[VNavState2["Disabled"] = 0] = "Disabled";
    VNavState2[VNavState2["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    VNavState2[VNavState2["Enabled_Active"] = 2] = "Enabled_Active";
  })(VNavState || (VNavState = {}));
  var VNavPathMode;
  (function(VNavPathMode2) {
    VNavPathMode2[VNavPathMode2["None"] = 0] = "None";
    VNavPathMode2[VNavPathMode2["PathArmed"] = 1] = "PathArmed";
    VNavPathMode2[VNavPathMode2["PathActive"] = 2] = "PathActive";
    VNavPathMode2[VNavPathMode2["PathInvalid"] = 3] = "PathInvalid";
  })(VNavPathMode || (VNavPathMode = {}));
  var ApproachGuidanceMode;
  (function(ApproachGuidanceMode2) {
    ApproachGuidanceMode2[ApproachGuidanceMode2["None"] = 0] = "None";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSArmed"] = 1] = "GSArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GSActive"] = 2] = "GSActive";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPArmed"] = 3] = "GPArmed";
    ApproachGuidanceMode2[ApproachGuidanceMode2["GPActive"] = 4] = "GPActive";
  })(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
  var VNavAltCaptureType;
  (function(VNavAltCaptureType2) {
    VNavAltCaptureType2[VNavAltCaptureType2["None"] = 0] = "None";
    VNavAltCaptureType2[VNavAltCaptureType2["Selected"] = 1] = "Selected";
    VNavAltCaptureType2[VNavAltCaptureType2["VNAV"] = 2] = "VNAV";
  })(VNavAltCaptureType || (VNavAltCaptureType = {}));
  var VNavAvailability;
  (function(VNavAvailability2) {
    VNavAvailability2["Available"] = "Available";
    VNavAvailability2["InvalidLegs"] = "InvalidLegs";
  })(VNavAvailability || (VNavAvailability = {}));
  var VNavUtils = class {
    static isUserConstraint(lateralLeg) {
      if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1 || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
        return true;
      }
      return false;
    }
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
      const delta = targetAltitude - currentAltitude;
      const minutesToConstraint = distance / groundSpeed * 60;
      return delta / minutesToConstraint;
    }
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
      return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    static getFpaFromVerticalSpeed(vs, groundspeed) {
      return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    static getFpa(distance, altitude) {
      return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    static altitudeForDistance(fpa, distance) {
      return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    static distanceForAltitude(fpa, altitude) {
      return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    static getMissedApproachLegIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags2.MAP)) {
            return l;
          }
        }
      }
      return Math.max(0, plan.length - 1);
    }
    static getFafIndex(plan) {
      if (plan.length > 0) {
        for (let l = plan.length - 1; l > 0; l--) {
          const planLeg = plan.tryGetLeg(l);
          if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags2.FAF)) {
            return l;
          }
        }
      }
      return void 0;
    }
    static getFafIndexReverse(lateralPlan, iterator) {
      let fafIndex = -1;
      iterator.iterateReverse(lateralPlan, (cursor) => {
        if (fafIndex === -1 && cursor.legDefinition && cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags2.FAF) {
          fafIndex = cursor.legIndex + cursor.segment.offset;
        }
      });
      fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
      return fafIndex;
    }
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
        if (verticalPlan.constraints[c].index >= globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        if (verticalPlan.constraints[c].index < globalLegIndex) {
          return c;
        }
      }
      return -1;
    }
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
      return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    static getIsPathEnd(verticalPlan, globalLegIndex) {
      const constraintIndex = verticalPlan.constraints.findIndex((c) => c.index === globalLegIndex);
      if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
        return true;
      }
      return false;
    }
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
      var _a, _b;
      return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    static getConstraintDistanceFromConstraint(constraint) {
      let distance = 0;
      for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
        distance += constraint.legs[legIndex].distance;
      }
      return distance;
    }
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
      let distance = 0;
      const startGlobalIndex = previousConstraint !== void 0 ? previousConstraint.index + 1 : 0;
      for (let i = startGlobalIndex; i <= constraint.index; i++) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
        distance += verticalLeg.distance;
      }
      return distance;
    }
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
      if (activeLegIndex > constraint.index) {
        return 0;
      }
      let distance = 0;
      let index = activeLegIndex;
      for (const leg of lateralPlan.legs(false, activeLegIndex)) {
        if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
          return Number.POSITIVE_INFINITY;
        } else if (leg.calculated !== void 0) {
          distance += leg.calculated.distanceWithTransitions;
        }
        if (++index > constraint.index) {
          break;
        }
      }
      distance -= distanceAlongLeg;
      return distance;
    }
    static getConstraintDetails(constraint, out) {
      if (constraint.maxAltitude === constraint.minAltitude) {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      } else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
        switch (constraint.type) {
          case "climb":
          case "missed":
            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            }
            break;
          default:
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
              out.type = AltitudeRestrictionType.AtOrAbove;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
            } else {
              out.type = AltitudeRestrictionType.AtOrBelow;
              out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
            }
        }
      } else {
        out.type = AltitudeRestrictionType.At;
        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
      }
      return out;
    }
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
      if (verticalPlan.constraints.length > 0) {
        if (selectedGlobalLegIndex < activeLegIndex) {
          return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
        }
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
          const constraint = verticalPlan.constraints[c];
          if (constraint.index === selectedGlobalLegIndex || c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index) {
            return constraint;
          } else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
            return verticalPlan.constraints[c + 1];
          }
        }
      }
      return void 0;
    }
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if ((constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.minAltitude : void 0;
    }
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint) {
        if (currentConstraint.type === "climb" && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return currentConstraint;
        } else if (currentConstraint.type === "climb" && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
          const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== void 0 ? VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
          for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === "climb" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
              return constraint;
            }
          }
        }
      }
      return void 0;
    }
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
      const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
      for (let c = currentConstraintIndex; c >= 0; c--) {
        const constraint = verticalPlan.constraints[c];
        if (constraint.type === "missed" && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
          return constraint;
        }
      }
      return void 0;
    }
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
      const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
      return constraint !== void 0 ? constraint.maxAltitude : void 0;
    }
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint.targetAltitude;
      }
      const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
      return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    static getFafAltitude(verticalPlan) {
      if (verticalPlan.fafLegIndex !== void 0) {
        return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
      }
      return void 0;
    }
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
      var _a;
      out.todLegIndex = -1;
      out.bodLegIndex = -1;
      out.todLegDistance = 0;
      out.distanceFromTod = 0;
      out.distanceFromBod = 0;
      out.currentConstraintLegIndex = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (!activeConstraint || (activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== void 0 && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex) {
        return out;
      }
      out.currentConstraintLegIndex = activeConstraint.index;
      const altitude = currentAltitude - currentVS / 20;
      let bodConstraintIndex, bodConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
          bodConstraintIndex = i;
          bodConstraint = constraint;
          break;
        }
      }
      if (!bodConstraint) {
        return out;
      }
      out.bodLegIndex = bodConstraint.index;
      let todConstraintIndex = bodConstraintIndex;
      for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const prevConstraint = verticalPlan.constraints[i + 1];
        if (!prevConstraint || prevConstraint.index < activeLegIndex || prevConstraint.type === "climb" || prevConstraint.type === "missed" || prevConstraint.targetAltitude > altitude || prevConstraint.fpa <= 0 || prevConstraint.isPathEnd) {
          todConstraintIndex = i;
          break;
        }
      }
      const todConstraint = verticalPlan.constraints[todConstraintIndex];
      let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
      let constraintIndex = todConstraintIndex;
      let todLegIndex = todConstraint.index;
      let todLegDistance = 0;
      let todLeg = todConstraint.legs[0];
      while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
        const constraint = verticalPlan.constraints[constraintIndex];
        for (let i = 0; i < constraint.legs.length; i++) {
          if (!constraint.legs[i].isEligible) {
            constraintIndex = verticalPlan.constraints.length;
            break;
          }
          todLeg = constraint.legs[i];
          distance -= todLeg.distance;
          if (distance <= 0) {
            todLegIndex = constraint.index - i;
            todLegDistance = todLeg.distance + distance;
            break;
          }
        }
        constraintIndex++;
      }
      if (distance > 0) {
        todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
        todLegDistance = todLeg.distance;
      }
      out.todLegIndex = todLegIndex;
      out.todLegDistance = todLegDistance;
      let globalLegIndex = bodConstraint.index;
      let distanceToBOD = 0, distanceToTOD = 0;
      let hasReachedTOD = false;
      let isDone = false;
      for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
        const constraint = verticalPlan.constraints[i];
        for (let j = 0; j < constraint.legs.length; j++) {
          const leg = constraint.legs[j];
          if (globalLegIndex === todLegIndex) {
            distanceToTOD -= todLegDistance;
            hasReachedTOD = true;
          }
          if (globalLegIndex > activeLegIndex) {
            distanceToBOD += leg.distance;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance;
            }
          } else if (globalLegIndex === activeLegIndex) {
            distanceToBOD += leg.distance - distanceAlongLeg;
            if (hasReachedTOD) {
              distanceToTOD += leg.distance - distanceAlongLeg;
              isDone = true;
            } else {
              distanceToTOD -= distanceAlongLeg;
            }
          } else {
            if (hasReachedTOD) {
              isDone = true;
            } else {
              distanceToTOD -= leg.distance;
            }
          }
          if (isDone) {
            break;
          } else {
            globalLegIndex--;
          }
        }
        if (isDone) {
          break;
        }
      }
      out.distanceFromBod = distanceToBOD;
      out.distanceFromTod = distanceToTOD;
      return out;
    }
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
      var _a, _b;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
      const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
      if (!activeConstraint || activeConstraint.type !== "climb" && activeConstraint.type !== "missed") {
        return out;
      }
      let tocConstraintIndex, tocConstraint;
      for (let i = activeConstraintIndex; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (isFinite(constraint.maxAltitude)) {
          tocConstraintIndex = i;
          tocConstraint = constraint;
          break;
        }
      }
      if (!tocConstraint) {
        return out;
      }
      out.tocConstraintIndex = tocConstraintIndex;
      out.tocAltitude = tocConstraint.maxAltitude;
      const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
      let tocLegIndex;
      let currentConstraintIndex = activeConstraintIndex;
      let currentConstraint;
      let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
      let currentLeg = activeLeg;
      const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
      if (distanceRemaining > activeLegDistanceRemaining) {
        distanceRemaining -= activeLegDistanceRemaining;
        if (currentConstraintLegIndex <= 0) {
          --currentConstraintIndex;
        } else {
          currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
        }
        while (currentConstraintIndex >= tocConstraintIndex) {
          currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          currentLeg = currentConstraint.legs[currentConstraintLegIndex];
          if (currentLeg !== void 0) {
            if (distanceRemaining > currentLeg.distance) {
              out.distanceFromToc += currentLeg.distance;
              distanceRemaining -= currentLeg.distance;
            } else {
              out.distanceFromToc += distanceRemaining;
              tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
              distanceRemaining -= currentLeg.distance;
              break;
            }
          }
          if (currentConstraintLegIndex <= 0) {
            --currentConstraintIndex;
          } else {
            currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
          }
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = tocConstraint.index;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      let lastClimbConstraintIndex = tocConstraintIndex;
      let bocConstraintIndex, bocConstraint;
      for (let i = tocConstraintIndex - 1; i >= 0; i--) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.type !== "climb" && constraint.type !== "missed") {
          break;
        }
        if (constraint.maxAltitude > tocConstraint.maxAltitude) {
          bocConstraintIndex = i;
          bocConstraint = constraint;
          break;
        }
        lastClimbConstraintIndex = i;
      }
      let bocDistanceStopConstraintIndex = void 0;
      if (bocConstraint) {
        out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
        bocDistanceStopConstraintIndex = bocConstraintIndex;
      } else {
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
          out.bocLegIndex = lastClimbConstraint.index + 1;
          bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
        }
      }
      if (bocDistanceStopConstraintIndex !== void 0) {
        let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
          distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
        }
        out.distanceFromBoc = distanceToEndOfActiveConstraint;
        for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
          out.distanceFromBoc += verticalPlan.constraints[i].distance;
        }
      }
      return out;
    }
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      out.bocLegIndex = -1;
      out.tocLegIndex = -1;
      out.tocLegDistance = 0;
      out.distanceFromBoc = 0;
      out.distanceFromToc = 0;
      out.tocConstraintIndex = -1;
      out.tocAltitude = -1;
      const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
      const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
      const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
      const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
      if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
        return out;
      }
      const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
      const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
      if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
        const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
        out.bocLegIndex = lastClimbConstraint.index + 1;
        out.distanceFromBoc = activeLegDistanceRemaining + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
      }
      const deltaAltitude = cruiseAltitude - currentAltitude;
      const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
      let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
      let tocLegIndex;
      const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
      if (distanceRemaining > activeLegDistanceRemaining) {
        let legIndex = activeLegIndex + 1;
        for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
          const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
          if (distanceRemaining > legDistance) {
            out.distanceFromToc += legDistance;
            distanceRemaining -= legDistance;
          } else {
            out.distanceFromToc += distanceRemaining;
            tocLegIndex = legIndex;
            distanceRemaining -= legDistance;
            break;
          }
          legIndex++;
        }
      } else {
        out.distanceFromToc = distanceRemaining;
        tocLegIndex = activeLegIndex;
        distanceRemaining -= activeLegDistanceRemaining;
      }
      if (tocLegIndex === void 0) {
        out.tocLegIndex = lastLegIndex;
        out.tocLegDistance = 0;
      } else {
        out.tocLegIndex = tocLegIndex;
        out.tocLegDistance = -distanceRemaining;
      }
      out.tocAltitude = cruiseAltitude;
      return out;
    }
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset] !== void 0;
        }
      }
      return false;
    }
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
      for (let i = 0; i < verticalPlan.segments.length; i++) {
        const segment = verticalPlan.segments[i];
        if (segment !== void 0 && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
          return segment.legs[globalLegIndex - segment.offset];
        }
      }
      throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
      const segment = verticalPlan.segments[segmentIndex];
      const leg = segment.legs[legIndex];
      if (segment && leg) {
        return leg;
      } else {
        throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
      }
    }
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
      return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    static getVerticalSegmentsFromPlan(verticalPlan) {
      return verticalPlan.segments;
    }
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
      if (lateralLeg.leg !== void 0) {
        switch (lateralLeg.leg.type) {
          case LegType2.HA:
          case LegType2.HF:
          case LegType2.HM:
          case LegType2.PI:
            return true;
        }
      }
      return false;
    }
    static createConstraint(index, minAltitude, maxAltitude, name69, type = "descent") {
      return {
        index,
        minAltitude,
        maxAltitude,
        targetAltitude: 0,
        name: name69,
        isTarget: false,
        isPathEnd: false,
        distance: 0,
        fpa: 0,
        legs: [],
        type,
        isBeyondFaf: false
      };
    }
    static createLeg(segmentIndex, legIndex, name69, distance = 0) {
      return {
        segmentIndex,
        legIndex,
        fpa: 0,
        altitude: 0,
        isUserDefined: false,
        isDirectToTarget: false,
        distance,
        isEligible: true,
        isBod: false,
        isAdvisory: true,
        name: name69
      };
    }
    static getFirstClimbConstraintIndex(verticalPlan) {
      for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    static getLastClimbConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        if (verticalPlan.constraints[i].type === "climb") {
          return i;
        }
      }
      return -1;
    }
    static getFirstDescentConstraintIndex(verticalPlan) {
      let index = -1;
      for (let c = 0; c < verticalPlan.constraints.length; c++) {
        const type = verticalPlan.constraints[c].type;
        if (type === "descent" || type === "manual") {
          index = c;
        }
        if (type === "direct") {
          return c;
        }
      }
      return index;
    }
    static getLastDescentConstraintIndex(verticalPlan) {
      for (let i = 0; i < verticalPlan.constraints.length; i++) {
        const type = verticalPlan.constraints[i].type;
        if (type === "descent" || type === "direct" || type === "manual") {
          return i;
        }
      }
      return -1;
    }
    static speedConstraintEquals(a, b) {
      return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    static altitudeConstraintDetailsEquals(a, b) {
      return a.type === b.type && a.altitude === b.altitude;
    }
    static speedConstraintDetailsEquals(a, b) {
      return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint) && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    static getPathErrorDistance(groundSpeed) {
      if (groundSpeed <= 190) {
        return 100;
      } else if (groundSpeed >= 210) {
        return 250;
      } else {
        return 100 + (groundSpeed - 190) / 20 * 150;
      }
    }
  };
  var LNavTransitionMode;
  (function(LNavTransitionMode2) {
    LNavTransitionMode2[LNavTransitionMode2["None"] = 0] = "None";
    LNavTransitionMode2[LNavTransitionMode2["Ingress"] = 1] = "Ingress";
    LNavTransitionMode2[LNavTransitionMode2["Egress"] = 2] = "Egress";
    LNavTransitionMode2[LNavTransitionMode2["Unsuspend"] = 3] = "Unsuspend";
  })(LNavTransitionMode || (LNavTransitionMode = {}));
  var LNavVars;
  (function(LNavVars2) {
    LNavVars2["DTK"] = "L:WTAP_LNav_DTK";
    LNavVars2["XTK"] = "L:WTAP_LNav_XTK";
    LNavVars2["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    LNavVars2["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    LNavVars2["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    LNavVars2["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    LNavVars2["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    LNavVars2["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    LNavVars2["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    LNavVars2["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    LNavVars2["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    LNavVars2["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    LNavVars2["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    LNavVars2["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
  })(LNavVars || (LNavVars = {}));
  var LNavSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(LNavSimVarPublisher.simvars, bus);
    }
  };
  LNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnav_dtk", { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ["lnav_xtk", { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ["lnav_is_tracking", { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ["lnav_tracked_leg_index", { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ["lnav_transition_mode", { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ["lnav_tracked_vector_index", { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ["lnav_course_to_steer", { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ["lnav_is_suspended", { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ["lnav_leg_distance_along", { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_leg_distance_remaining", { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_distance_along", { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ["lnav_vector_distance_remaining", { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ["lnav_vector_anticipation_distance", { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ["lnav_along_track_speed", { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
  ]);
  var LNavUtils = class {
    static getVectorsForTransitionMode(calc, mode, isSuspended) {
      switch (mode) {
        case LNavTransitionMode.None:
          return isSuspended ? calc.flightPath : calc.ingressToEgress;
        case LNavTransitionMode.Ingress:
          return calc.ingress;
        case LNavTransitionMode.Egress:
          return calc.egress;
        case LNavTransitionMode.Unsuspend:
          return calc.flightPath;
      }
    }
    static lnavTrackingStateEquals(a, b) {
      return a.isTracking === b.isTracking && a.globalLegIndex === b.globalLegIndex && a.transitionMode === b.transitionMode && a.vectorIndex === b.vectorIndex && a.isSuspended === b.isSuspended;
    }
  };
  var VNavVars;
  (function(VNavVars2) {
    VNavVars2["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    VNavVars2["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    VNavVars2["PathMode"] = "L:WTAP_VNav_Path_Mode";
    VNavVars2["VNAVState"] = "L:WTAP_VNav_State";
    VNavVars2["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    VNavVars2["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    VNavVars2["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    VNavVars2["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    VNavVars2["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    VNavVars2["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    VNavVars2["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    VNavVars2["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    VNavVars2["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    VNavVars2["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    VNavVars2["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    VNavVars2["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    VNavVars2["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    VNavVars2["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    VNavVars2["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    VNavVars2["FPA"] = "L:WTAP_VNav_FPA";
    VNavVars2["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    VNavVars2["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    VNavVars2["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    VNavVars2["GPDistance"] = "L:WTAP_GP_Distance";
    VNavVars2["GPFpa"] = "L:WTAP_GP_FPA";
    VNavVars2["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    VNavVars2["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
  })(VNavVars || (VNavVars = {}));
  var VNavSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(VNavSimVarPublisher.simvars, bus);
    }
    publishEvent(event, value) {
      this.publish(event, value, true);
    }
  };
  VNavSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["vnav_vertical_deviation", { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ["vnav_target_altitude", { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ["vnav_path_mode", { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ["vnav_path_available", { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ["vnav_state", { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ["vnav_altitude_capture_type", { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ["vnav_tod_distance", { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_leg_distance", { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_bod_distance", { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ["vnav_tod_global_leg_index", { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ["vnav_bod_global_leg_index", { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ["vnav_toc_distance", { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_leg_distance", { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ["vnav_boc_distance", { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ["vnav_toc_global_leg_index", { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_boc_global_leg_index", { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_global_leg_index", { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ["vnav_constraint_altitude", { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_next_constraint_altitude", { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ["vnav_fpa", { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ["vnav_required_vs", { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ["gp_approach_mode", { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ["gp_vertical_deviation", { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ["gp_distance", { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ["gp_fpa", { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ["gp_required_vs", { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ["gp_service_level", { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
  ]);
  var APHdgDirector = class {
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.toGaHeading = 0;
      this.bankServo = new LinearServo(APHdgDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaHeading = this.currentHeading;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaHeading = this.currentHeading;
          }
          this.setBank(this.desiredBank(this.toGaHeading));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgDirector.BANK_SERVO_RATE = 10;
  var APHdgHoldDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APHdgHoldDirector.BANK_SERVO_RATE);
      this.capturedHeading = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentHeadingSub = this.bus.getSubscriber().on("hdg_deg").withPrecision(0).handle((h) => this.currentHeading = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentHeadingSub.resume();
      this.capturedHeading = null;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentHeadingSub.pause();
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedHeading === null && Math.abs(this.currentBank) < APHdgHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedHeading = this.currentHeading;
        }
        this.setBank(this.capturedHeading !== null ? this.desiredBank(this.capturedHeading) : 0);
      }
    }
    desiredBank(targetHeading) {
      const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
      const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APHdgHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APHdgHoldDirector.BANK_SERVO_RATE = 10;
  APHdgHoldDirector.MIN_BANK_THRESHOLD = 1;
  var APNavDirector = class {
    constructor(bus, apValues, mode, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APNavDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      this.isNavLock = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.disableArming = (_b = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _b !== void 0 ? _b : false;
      this.forceNavSource = options === null || options === void 0 ? void 0 : options.forceNavSource;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        this.setNavLock(true);
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.setNavLock(false);
    }
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.disableArming || this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    canArm() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (this.mode === APLateralModes.LOC && typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      if (this.mode === APLateralModes.VOR && typeIsCorrect) {
        const indexIsCorrect = index == ((_f = this.cdi) === null || _f === void 0 ? void 0 : _f.source.index) && !((_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) && index == ((_h = this.obs) === null || _h === void 0 ? void 0 : _h.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(false);
          return true;
        }
      }
      if (this.mode === APLateralModes.LOC && this.apValues.navToNavLocArm && this.apValues.navToNavLocArm()) {
        this.isApproachMode.set(true);
        return true;
      }
      this.isApproachMode.set(false);
      return false;
    }
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index) || !((_f = this.loc) === null || _f === void 0 ? void 0 : _f.isValid) && index == ((_g = this.obs) === null || _g === void 0 ? void 0 : _g.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && (((_h = this.obs) === null || _h === void 0 ? void 0 : _h.heading) || ((_j = this.loc) === null || _j === void 0 ? void 0 : _j.course))) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? this.loc.course * Avionics.Utils.RAD2DEG : (_k = this.obs) === null || _k === void 0 ? void 0 : _k.heading;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_m = (_l = this.loc) === null || _l === void 0 ? void 0 : _l.isValid) !== null && _m !== void 0 ? _m : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    desiredBank() {
      var _a, _b, _c, _d, _e, _f, _g;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      const hasValidObs = this.obs !== void 0 && this.obs.heading !== null;
      let zoneOfConfusion = false;
      if (isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (!isLoc && (!hasValidDeviation || !hasValidObs)) {
        if (!this.checkForZoneOfConfusion()) {
          this.deactivate();
          return NaN;
        } else {
          zoneOfConfusion = true;
        }
      }
      if (zoneOfConfusion || this.cdi && this.cdi.deviation !== null) {
        const xtk = zoneOfConfusion ? 0 : this.cdi && this.cdi.deviation !== null ? this.getXtk(this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? this.loc.course * Avionics.Utils.RAD2DEG : (_d = this.obs) === null || _d === void 0 ? void 0 : _d.heading;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_f = (_e = this.cdi) === null || _e === void 0 ? void 0 : _e.deviation) !== null && _f !== void 0 ? _f : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_g = this.magVar) !== null && _g !== void 0 ? _g : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils2.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    monitorEvents() {
      const sub2 = this.bus.getSubscriber();
      if (this.forceNavSource) {
        this.navSource = {
          index: this.forceNavSource,
          type: NavSourceType.Nav
        };
        sub2.on(`nav_radio_cdi_${this.forceNavSource}`).handle((cdi) => this.cdi = cdi);
        sub2.on(`nav_radio_obs_${this.forceNavSource}`).handle((obs) => this.obs = obs);
        sub2.on(`nav_radio_localizer_${this.forceNavSource}`).handle((loc) => this.loc = loc);
        sub2.on(`nav_radio_nav_location_${this.forceNavSource}`).handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub2.on(`nav_radio_magvar_${this.forceNavSource}`).handle((magVar) => {
          this.magVar = magVar;
        });
      } else {
        sub2.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
        sub2.on("nav_radio_active_obs_setting").handle((obs) => this.obs = obs);
        sub2.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
        sub2.on("cdi_select").handle((source) => {
          this.navSource = source;
          if (this.state === DirectorState.Active) {
            this.deactivate();
          }
        });
        sub2.on("nav_radio_active_nav_location").handle((loc) => {
          this.navLocation.set(loc.lat, loc.long);
        });
        sub2.on("nav_radio_active_magvar").handle((magVar) => {
          this.magVar = magVar;
        });
      }
      sub2.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub2.on("tas").handle((s) => this.tas = s);
      sub2.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub2.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APNavDirector.BANK_SERVO_RATE = 10;
  var APRollDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.actualBank = 0;
      this.bankServo = new LinearServo(APRollDirector.BANK_SERVO_RATE);
      const minBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.minBankAngle) !== null && _a !== void 0 ? _a : 0;
      if (typeof minBankAngleOpt === "number") {
        this.minBankAngleFunc = () => minBankAngleOpt;
      } else {
        this.minBankAngleFunc = minBankAngleOpt;
      }
      const maxBankAngleOpt = options === null || options === void 0 ? void 0 : options.maxBankAngle;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
      const sub2 = this.bus.getSubscriber();
      sub2.on("roll_deg").withPrecision(1).handle((roll) => {
        this.actualBank = roll;
      });
    }
    activate() {
      this.state = DirectorState.Active;
      const maxBank2 = this.maxBankAngleFunc();
      const minBank2 = this.minBankAngleFunc();
      if (Math.abs(this.actualBank) < minBank2) {
        this.desiredBank = 0;
      } else {
        this.desiredBank = MathUtils2.clamp(this.actualBank, -maxBank2, maxBank2);
      }
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      SimVar.SetSimVarValue("AUTOPILOT BANK HOLD", "Bool", false);
    }
    update() {
      if (this.state === DirectorState.Active) {
        const maxBank2 = this.maxBankAngleFunc();
        const minBank2 = this.minBankAngleFunc();
        if (Math.abs(this.actualBank) < minBank2) {
          this.desiredBank = 0;
        } else {
          this.desiredBank = MathUtils2.clamp(this.actualBank, -maxBank2, maxBank2);
        }
        this.setBank(this.desiredBank);
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APRollDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APRollDirector.BANK_SERVO_RATE = 10;
  var APTrkDirector = class {
    constructor(bus, apValues, options) {
      var _a, _b;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.toGaTrack = 0;
      this.bankServo = new LinearServo(APTrkDirector.BANK_SERVO_RATE);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.isToGaMode = (_b = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _b !== void 0 ? _b : false;
      this.state = DirectorState.Inactive;
      const ahrs = this.bus.getSubscriber();
      ahrs.on("track_deg_magnetic").withPrecision(0).handle((h) => {
        this.currentTrack = h;
      });
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      } else {
        this.toGaTrack = this.currentTrack;
      }
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    async deactivate() {
      if (!this.isToGaMode) {
        await SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      }
      this.state = DirectorState.Inactive;
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.isToGaMode) {
          if (Simplane.getIsGrounded()) {
            this.toGaTrack = this.currentTrack;
          }
          this.setBank(this.desiredBank(this.toGaTrack));
        } else {
          this.setBank(this.desiredBank(this.apValues.selectedHeading.get()));
        }
      }
    }
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkDirector.BANK_SERVO_RATE = 10;
  var APTrkHoldDirector = class {
    constructor(bus, apValues, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.currentBankRef = 0;
      this.currentTrack = 0;
      this.currentBank = 0;
      this.bankServo = new LinearServo(APTrkHoldDirector.BANK_SERVO_RATE);
      this.capturedTrack = null;
      this.state = DirectorState.Inactive;
      this.currentBankSub = this.bus.getSubscriber().on("roll_deg").withPrecision(1).handle((bank) => this.currentBank = bank);
      this.currentTrackSub = this.bus.getSubscriber().on("track_deg_magnetic").withPrecision(0).handle((h) => this.currentTrack = h);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.currentBankSub.resume();
      this.currentTrackSub.resume();
      this.capturedTrack = null;
      this.currentBankRef = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT HEADING LOCK", "Bool", false);
      this.currentBankSub.pause();
      this.currentTrackSub.pause();
    }
    update() {
      if (this.state === DirectorState.Active) {
        if (this.capturedTrack === null && Math.abs(this.currentBank) < APTrkHoldDirector.MIN_BANK_THRESHOLD) {
          this.capturedTrack = this.currentTrack;
        }
        this.setBank(this.capturedTrack !== null ? this.desiredBank(this.capturedTrack) : 0);
      }
    }
    desiredBank(targetTrack) {
      const turnDirection = NavMath.getTurnDirection(this.currentTrack, targetTrack);
      const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, targetTrack));
      let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APTrkHoldDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APTrkHoldDirector.BANK_SERVO_RATE = 10;
  APTrkHoldDirector.MIN_BANK_THRESHOLD = 1;
  var ArcTurnController = class {
    constructor() {
      this.bankController = new PidController(1.5, 0, 0, 15, -15);
      this.precessionController = new PidController(0.025, 0, 0, 300, -300);
      this.filter = new ExpSmoother(500);
    }
    getOutput(radiusError) {
      var _a;
      const currentTime = new Date().appTime();
      let bankAngle = 0;
      if (this.previousRadiusError !== void 0 && this.previousTime !== void 0) {
        const dTime = currentTime - this.previousTime;
        const input = (radiusError - this.previousRadiusError) / dTime * 1e3;
        const precessionRate = isNaN((_a = this.filter.last()) !== null && _a !== void 0 ? _a : NaN) ? this.filter.reset(input) : this.filter.next(input, dTime);
        const targetPrecessionRate = -this.precessionController.getOutput(dTime, radiusError);
        const precessionError = targetPrecessionRate - precessionRate;
        bankAngle = this.bankController.getOutput(dTime, precessionError);
      }
      this.previousTime = currentTime;
      this.previousRadiusError = radiusError;
      return -bankAngle;
    }
    reset() {
      this.previousTime = void 0;
      this.previousRadiusError = void 0;
      this.precessionController.reset();
      this.bankController.reset();
      this.filter.reset();
    }
  };
  var LNavDirector = class {
    constructor(bus, apValues, flightPlanner, obsDirector, options) {
      var _a, _b, _c;
      this.bus = bus;
      this.apValues = apValues;
      this.flightPlanner = flightPlanner;
      this.obsDirector = obsDirector;
      this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
      this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
      this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
      this.publisher = this.bus.getPublisher();
      this.aircraftState = {
        tas: 0,
        gs: 0,
        track: 0,
        magvar: 0,
        windSpeed: 0,
        windDirection: 0,
        planePos: new GeoPoint(0, 0),
        hdgTrue: 0,
        altAgl: 0,
        bank: 0
      };
      this.currentLeg = void 0;
      this.currentVector = void 0;
      this.dtk = 0;
      this.xtk = 0;
      this.bearingToVectorEnd = 0;
      this.courseToSteer = 0;
      this.alongVectorDistance = 0;
      this.vectorDistanceRemaining = 0;
      this.vectorAnticipationDistance = 0;
      this.alongTrackSpeed = 0;
      this.anticipationVector = void 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      this.inhibitNextSequence = false;
      this.currentBankRef = 0;
      this.bankServo = new LinearServo(LNavDirector.BANK_SERVO_RATE);
      this.currentState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.anticipationState = {
        globalLegIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        isSuspended: false,
        inhibitedSuspendLegIndex: -1,
        resetVectorsOnSuspendEnd: false,
        isMissedApproachActive: false
      };
      this.currentBankAngleState = {
        arcController: new ArcTurnController(),
        isInterceptingFromArmedState: false,
        trackAtActivation: 0,
        desiredBankAngle: 0
      };
      this.lnavData = ObjectSubject.create({
        dtk: 0,
        xtk: 0,
        trackingState: {
          isTracking: false,
          globalLegIndex: 0,
          transitionMode: LNavTransitionMode.None,
          vectorIndex: 0,
          isSuspended: false
        },
        isTracking: false,
        legIndex: 0,
        transitionMode: LNavTransitionMode.None,
        vectorIndex: 0,
        courseToSteer: 0,
        isSuspended: false,
        alongLegDistance: 0,
        legDistanceRemaining: 0,
        alongVectorDistance: 0,
        vectorDistanceRemaining: 0,
        vectorAnticipationDistance: 0,
        alongTrackSpeed: 0
      });
      this.isObsDirectorTracking = false;
      this.canArm = false;
      this.awaitCalculateId = 0;
      this.isAwaitingCalculate = false;
      this.isNavLock = Subject.create(false);
      this.lnavDataHandler = (obj, key, value) => {
        switch (key) {
          case "dtk":
            SimVar.SetSimVarValue(LNavVars.DTK, SimVarValueType.Degree, value);
            break;
          case "xtk":
            SimVar.SetSimVarValue(LNavVars.XTK, SimVarValueType.NM, value);
            break;
          case "isTracking":
            SimVar.SetSimVarValue(LNavVars.IsTracking, SimVarValueType.Bool, value);
            break;
          case "legIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number, value);
            break;
          case "transitionMode":
            SimVar.SetSimVarValue(LNavVars.TransitionMode, SimVarValueType.Number, value);
            break;
          case "vectorIndex":
            SimVar.SetSimVarValue(LNavVars.TrackedVectorIndex, SimVarValueType.Number, value);
            break;
          case "courseToSteer":
            SimVar.SetSimVarValue(LNavVars.CourseToSteer, SimVarValueType.Degree, value);
            break;
          case "isSuspended":
            SimVar.SetSimVarValue(LNavVars.IsSuspended, SimVarValueType.Bool, value);
            break;
          case "alongLegDistance":
            SimVar.SetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM, value);
            break;
          case "legDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "alongVectorDistance":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceAlong, SimVarValueType.NM, value);
            break;
          case "vectorDistanceRemaining":
            SimVar.SetSimVarValue(LNavVars.VectorDistanceRemaining, SimVarValueType.NM, value);
            break;
          case "vectorAnticipationDistance":
            SimVar.SetSimVarValue(LNavVars.VectorAnticipationDistance, SimVarValueType.NM, value);
            break;
          case "alongTrackSpeed":
            SimVar.SetSimVarValue(LNavVars.AlongTrackSpeed, SimVarValueType.Knots, value);
            break;
          case "trackingState":
            this.publisher.pub("lnav_tracking_state", value, true, true);
            break;
        }
      };
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.hasVectorAnticipation = (_b = options === null || options === void 0 ? void 0 : options.hasVectorAnticipation) !== null && _b !== void 0 ? _b : false;
      this.minimumActivationAltitude = options === null || options === void 0 ? void 0 : options.minimumActivationAltitude;
      this.disableArming = (_c = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _c !== void 0 ? _c : false;
      const sub2 = bus.getSubscriber();
      this.lnavData.sub(this.lnavDataHandler, true);
      sub2.on("ambient_wind_velocity").handle((w) => this.aircraftState.windSpeed = w);
      sub2.on("ambient_wind_direction").handle((wd) => this.aircraftState.windDirection = wd);
      sub2.on("tas").handle((tas) => this.aircraftState.tas = tas);
      sub2.on("hdg_deg_true").handle((hdg) => this.aircraftState.hdgTrue = hdg);
      sub2.on("ground_speed").handle((gs) => this.aircraftState.gs = gs);
      sub2.on("radio_alt").handle((alt) => this.aircraftState.altAgl = alt);
      sub2.on("roll_deg").handle((roll) => this.aircraftState.bank = roll);
      const nav = this.bus.getSubscriber();
      nav.on("cdi_select").handle((src) => {
        if (this.state !== DirectorState.Inactive && src.type !== NavSourceType.Gps) {
          this.deactivate();
        }
      });
      sub2.on("suspend_sequencing").handle((suspend) => {
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
        if (flightPlan) {
          if (suspend) {
            this.currentState.inhibitedSuspendLegIndex = -1;
          }
          this.trySetSuspended(flightPlan, this.currentState, suspend, this.currentState, false, false);
        }
      });
      sub2.on("activate_missed_approach").handle((v) => {
        this.currentState.isMissedApproachActive = v;
      });
      sub2.on("lnav_inhibit_next_sequence").handle((inhibit) => {
        this.inhibitNextSequence = inhibit;
        if (inhibit) {
          this.currentState.inhibitedSuspendLegIndex = -1;
        }
      });
      sub2.on("fplActiveLegChange").handle((e) => {
        if (e.planIndex === this.flightPlanner.activePlanIndex && e.type === ActiveLegType.Lateral) {
          this.currentState.inhibitedSuspendLegIndex = -1;
          this.resetVectors();
        }
      });
      sub2.on("fplIndexChanged").handle(() => {
        this.resetVectors();
      });
      sub2.on("fplCopied").handle((e) => {
        if (e.targetPlanIndex === this.flightPlanner.activePlanIndex) {
          this.resetVectors();
        }
      });
      sub2.on("gps-position").handle((lla) => {
        this.aircraftState.planePos.set(lla.lat, lla.long);
      });
      sub2.on("track_deg_true").handle((t) => this.aircraftState.track = t);
      sub2.on("magvar").handle((m) => this.aircraftState.magvar = m);
      this.isNavLock.sub((newState) => {
        if (SimVar.GetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool") !== newState) {
          SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", newState);
        }
      });
      this.state = DirectorState.Inactive;
    }
    resetVectors() {
      this.currentState.vectorIndex = 0;
      this.currentState.transitionMode = LNavTransitionMode.Ingress;
      this.inhibitNextSequence = false;
      this.awaitCalculate();
    }
    activate() {
      this.currentBankAngleState.isInterceptingFromArmedState = !this.disableArming;
      this.currentBankAngleState.trackAtActivation = this.aircraftState.track;
      this.state = DirectorState.Active;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      this.setNavLock(true);
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive) {
        this.currentBankAngleState.isInterceptingFromArmedState = false;
        if (this.canArm) {
          this.state = DirectorState.Armed;
          if (this.onArm !== void 0) {
            this.onArm();
          }
          this.setNavLock(true);
        }
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      if (this.obsDirector && this.obsDirector.state !== DirectorState.Inactive) {
        this.obsDirector.deactivate();
      }
      this.currentBankAngleState.isInterceptingFromArmedState = false;
      this.setNavLock(false);
    }
    setNavLock(newState) {
      this.isNavLock.set(newState);
    }
    update() {
      var _a;
      let clearInhibitNextSequence = false;
      const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : void 0;
      this.currentState.globalLegIndex = flightPlan ? flightPlan.activeLateralLeg : 0;
      let isTracking = !!flightPlan && this.currentState.globalLegIndex <= flightPlan.length - 1;
      if (flightPlan && isTracking) {
        if (this.isAwaitingCalculate) {
          return;
        }
        this.currentLeg = flightPlan.getLeg(this.currentState.globalLegIndex);
        clearInhibitNextSequence = !!this.currentLeg.calculated;
        this.calculateTracking(flightPlan);
        if (this.isAwaitingCalculate) {
          return;
        }
        if (this.hasVectorAnticipation) {
          this.updateVectorAnticipation(flightPlan);
        }
        isTracking = this.currentState.globalLegIndex < flightPlan.length && this.currentVector !== void 0 && this.currentVector.radius > LNavDirector.ANGULAR_TOLERANCE && this.currentVector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
        if (isTracking) {
          const calcs = this.currentLeg.calculated;
          if (this.obsDirector) {
            this.obsDirector.setLeg(this.currentState.globalLegIndex, this.currentLeg);
            if (this.obsDirector.obsActive) {
              this.currentState.isSuspended = true;
              this.currentState.inhibitedSuspendLegIndex = this.currentState.globalLegIndex;
              if (!this.isObsDirectorTracking) {
                this.lnavData.unsub(this.lnavDataHandler);
                this.isObsDirectorTracking = true;
                this.obsDirector.startTracking();
              }
              if (this.state === DirectorState.Active && this.obsDirector.state !== DirectorState.Active) {
                this.obsDirector.activate();
                this.setNavLock(true);
              }
              if (this.state === DirectorState.Armed && this.obsDirector.canActivate()) {
                this.obsDirector.activate();
                this.state = DirectorState.Active;
                if (this.onActivate !== void 0) {
                  this.onActivate();
                }
                this.setNavLock(true);
              }
              this.obsDirector.update();
              return;
            }
          }
          isTracking = calcs !== void 0;
          if (this.state !== DirectorState.Inactive) {
            this.navigateFlightPath();
          }
        }
      } else {
        this.currentState.isSuspended = false;
        clearInhibitNextSequence = true;
      }
      if (this.isObsDirectorTracking) {
        this.currentState.isSuspended = false;
      }
      this.canArm = isTracking;
      this.lnavData.set("isTracking", isTracking);
      this.lnavData.set("isSuspended", this.currentState.isSuspended);
      if (isTracking) {
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking !== isTracking || trackingState.globalLegIndex !== this.currentState.globalLegIndex || trackingState.transitionMode !== this.currentState.transitionMode || trackingState.vectorIndex !== this.currentState.vectorIndex || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking,
            globalLegIndex: this.currentState.globalLegIndex,
            transitionMode: this.currentState.transitionMode,
            vectorIndex: this.currentState.vectorIndex,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", this.dtk);
        this.lnavData.set("xtk", this.xtk);
        this.lnavData.set("legIndex", this.currentState.globalLegIndex);
        this.lnavData.set("vectorIndex", this.currentState.vectorIndex);
        this.lnavData.set("transitionMode", this.currentState.transitionMode);
        this.lnavData.set("courseToSteer", this.courseToSteer);
        this.lnavData.set("alongVectorDistance", this.alongVectorDistance);
        this.lnavData.set("vectorDistanceRemaining", this.vectorDistanceRemaining);
        this.lnavData.set("vectorAnticipationDistance", this.vectorAnticipationDistance);
        this.lnavData.set("alongTrackSpeed", this.alongTrackSpeed);
        this.lnavData.set("alongLegDistance", this.getAlongLegDistance(flightPlan, this.currentState, this.alongVectorDistance));
        this.lnavData.set("legDistanceRemaining", this.getLegDistanceRemaining(flightPlan, this.currentState, this.vectorDistanceRemaining));
      } else {
        this.currentLeg = void 0;
        this.currentVector = void 0;
        const trackingState = this.lnavData.get().trackingState;
        if (trackingState.isTracking || trackingState.globalLegIndex !== 0 || trackingState.transitionMode !== LNavTransitionMode.None || trackingState.vectorIndex !== 0 || trackingState.isSuspended !== this.currentState.isSuspended) {
          this.lnavData.set("trackingState", {
            isTracking: false,
            globalLegIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            isSuspended: this.currentState.isSuspended
          });
        }
        this.lnavData.set("dtk", 0);
        this.lnavData.set("xtk", 0);
        this.lnavData.set("legIndex", 0);
        this.lnavData.set("vectorIndex", 0);
        this.lnavData.set("transitionMode", LNavTransitionMode.None);
        this.lnavData.set("courseToSteer", 0);
        this.lnavData.set("alongLegDistance", 0);
        this.lnavData.set("vectorDistanceRemaining", 0);
        this.lnavData.set("alongVectorDistance", 0);
        this.lnavData.set("legDistanceRemaining", 0);
        this.lnavData.set("vectorAnticipationDistance", 0);
        this.lnavData.set("alongTrackSpeed", 0);
      }
      if (this.isObsDirectorTracking) {
        (_a = this.obsDirector) === null || _a === void 0 ? void 0 : _a.stopTracking();
        this.lnavData.sub(this.lnavDataHandler, true);
        this.isObsDirectorTracking = false;
      }
      if (this.state === DirectorState.Armed) {
        this.tryActivate();
      }
      this.inhibitNextSequence && (this.inhibitNextSequence = !clearInhibitNextSequence);
    }
    navigateFlightPath() {
      let bankAngle;
      if (this.anticipationVector && this.vectorAnticipationDistance > 0 && this.vectorDistanceRemaining <= this.vectorAnticipationDistance && Math.abs(this.xtk) < UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)) {
        this.updateBankAngle(this.anticipationVector, this.anticipationDtk, this.anticipationXtk, this.anticipationBearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (bankAngle === void 0) {
        if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
          return;
        }
        this.updateBankAngle(this.currentVector, this.dtk, this.xtk, this.bearingToVectorEnd, this.currentBankAngleState);
        bankAngle = this.currentBankAngleState.desiredBankAngle;
      }
      if (this.state === DirectorState.Active) {
        this.setBank(bankAngle);
      }
    }
    updateBankAngle(vector, dtk, xtk, bearingToVectorEnd, bankAngleState) {
      let absInterceptAngle;
      let naturalAbsInterceptAngle = 0;
      if (this.lateralInterceptCurve !== void 0) {
        naturalAbsInterceptAngle = this.lateralInterceptCurve(dtk, xtk, this.aircraftState.tas);
      } else {
        naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
        if (naturalAbsInterceptAngle <= 2.5) {
          naturalAbsInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
        }
      }
      if (bankAngleState.isInterceptingFromArmedState) {
        absInterceptAngle = Math.abs(NavMath.diffAngle(bankAngleState.trackAtActivation, dtk));
        if (absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5 || absInterceptAngle < Math.abs(NavMath.diffAngle(dtk, bearingToVectorEnd))) {
          absInterceptAngle = naturalAbsInterceptAngle;
          bankAngleState.isInterceptingFromArmedState = false;
        }
      } else {
        absInterceptAngle = naturalAbsInterceptAngle;
      }
      const interceptAngle = xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
      const courseToSteer = NavMath.normalizeHeading(dtk + interceptAngle);
      bankAngleState.desiredBankAngle = this.desiredBank(courseToSteer);
      if (vector !== void 0 && !FlightPathUtils.isVectorGreatCircle(vector)) {
        this.adjustBankAngleForArc(vector, bankAngleState);
      }
      return bankAngleState;
    }
    desiredBank(desiredTrack) {
      const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
      const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
      let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
      baseBank *= turnDirection === "left" ? 1 : -1;
      return baseBank;
    }
    adjustBankAngleForArc(vector, bankAngleState) {
      const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
      const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
      const radius = UnitType.GA_RADIAN.convertTo(FlightPathUtils.getTurnRadiusFromCircle(circle), UnitType.METER);
      const relativeWindHeading = NavMath.normalizeHeading(this.aircraftState.windDirection - this.aircraftState.hdgTrue);
      const headwind = this.aircraftState.windSpeed * Math.cos(relativeWindHeading * Avionics.Utils.DEG2RAD);
      const distance = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.METER);
      const bankAdjustment = bankAngleState.arcController.getOutput(distance);
      const turnBankAngle = NavMath.bankAngle(this.aircraftState.tas - headwind, radius) * (turnDirection === "left" ? 1 : -1);
      const turnRadius = NavMath.turnRadius(this.aircraftState.tas - headwind, 25);
      const bankBlendFactor = Math.max(1 - Math.abs(UnitType.NMILE.convertTo(this.xtk, UnitType.METER)) / turnRadius, 0);
      const maxBank2 = this.maxBankAngleFunc();
      bankAngleState.desiredBankAngle = MathUtils2.clamp(bankAngleState.desiredBankAngle * (1 - bankBlendFactor) + turnBankAngle * bankBlendFactor + bankAdjustment, -maxBank2, maxBank2);
      return bankAngleState;
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = LNavDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    calculateTracking(plan) {
      var _a, _b;
      let didAdvance;
      do {
        didAdvance = false;
        if (!this.currentLeg) {
          break;
        }
        if (this.currentLeg.leg.type === LegType2.IF && this.currentState.globalLegIndex === 0 && plan.length > 1) {
          this.currentLeg = plan.getLeg(++this.currentState.globalLegIndex);
          plan.setCalculatingLeg(this.currentState.globalLegIndex);
          plan.setLateralLeg(this.currentState.globalLegIndex);
          continue;
        }
        const transitionMode = this.currentState.transitionMode;
        const legIndex = this.currentState.globalLegIndex;
        const vectorIndex = this.currentState.vectorIndex;
        const isSuspended = this.currentState.isSuspended;
        const calcs = this.currentLeg.calculated;
        if (calcs) {
          const vectors = LNavUtils.getVectorsForTransitionMode(calcs, this.currentState.transitionMode, this.currentState.isSuspended);
          const vector = vectors[this.currentState.vectorIndex];
          const isVectorValid2 = vector && vector.radius > LNavDirector.ANGULAR_TOLERANCE && vector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
          const isUnsuspendInvalid = this.currentState.transitionMode === LNavTransitionMode.Unsuspend && (calcs.ingress.length === 0 || calcs.flightPath[calcs.ingressJoinIndex] === void 0);
          if (isVectorValid2 && !isUnsuspendInvalid) {
            const planePos = this.aircraftState.planePos;
            const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
            let endLat, endLon;
            let end;
            let vectorDistanceNM;
            if (transitionMode === LNavTransitionMode.Unsuspend && vectorIndex === calcs.ingressJoinIndex && calcs.ingress.length > 0) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              endLat = lastIngressVector.endLat;
              endLon = lastIngressVector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.NMILE);
            } else {
              endLat = vector.endLat;
              endLon = vector.endLon;
              end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
              vectorDistanceNM = UnitType.METER.convertTo(vector.distance, UnitType.NMILE);
            }
            this.xtk = UnitType.GA_RADIAN.convertTo(circle.distance(planePos), UnitType.NMILE);
            this.dtk = circle.bearingAt(planePos, Math.PI);
            this.bearingToVectorEnd = planePos.bearingTo(endLat, endLon);
            const alongTrackSpeed = FlightPathUtils.projectVelocityToCircle(this.aircraftState.gs, planePos, this.aircraftState.track, circle);
            this.alongTrackSpeed = isNaN(alongTrackSpeed) ? this.aircraftState.gs : alongTrackSpeed;
            const normDist = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, planePos);
            this.alongVectorDistance = normDist * vectorDistanceNM;
            this.vectorDistanceRemaining = (1 - normDist) * vectorDistanceNM;
            if (normDist > 1) {
              this.advanceToNextVector(plan, this.currentState, true, this.currentState);
            }
          } else {
            this.alongVectorDistance = 0;
            this.vectorDistanceRemaining = 0;
            this.vectorAnticipationDistance = 0;
            this.advanceToNextVector(plan, this.currentState, true, this.currentState);
          }
          didAdvance = transitionMode !== this.currentState.transitionMode || legIndex !== this.currentState.globalLegIndex || vectorIndex !== this.currentState.vectorIndex || isSuspended !== this.currentState.isSuspended;
          if (legIndex !== this.currentState.globalLegIndex) {
            this.currentLeg = (_a = plan.tryGetLeg(this.currentState.globalLegIndex)) !== null && _a !== void 0 ? _a : void 0;
            plan.setCalculatingLeg(this.currentState.globalLegIndex);
            plan.setLateralLeg(this.currentState.globalLegIndex);
          }
        }
      } while (!this.isAwaitingCalculate && didAdvance && this.currentState.globalLegIndex <= plan.length - 1);
      if (this.currentState.transitionMode === LNavTransitionMode.Egress && this.currentState.globalLegIndex + 1 < plan.length && plan.activeCalculatingLeg !== this.currentState.globalLegIndex + 1) {
        plan.setCalculatingLeg(this.currentState.globalLegIndex + 1);
      }
      this.currentVector = ((_b = this.currentLeg) === null || _b === void 0 ? void 0 : _b.calculated) ? LNavUtils.getVectorsForTransitionMode(this.currentLeg.calculated, this.currentState.transitionMode, this.currentState.isSuspended)[this.currentState.vectorIndex] : void 0;
    }
    updateVectorAnticipation(plan) {
      var _a;
      this.anticipationVector = void 0;
      this.vectorAnticipationDistance = 0;
      this.anticipationDtk = 0;
      this.anticipationXtk = 0;
      this.anticipationBearingToVectorEnd = 0;
      if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        return;
      }
      this.advanceToNextVector(plan, this.currentState, false, this.anticipationState);
      const anticipationCalcs = (_a = plan.tryGetLeg(this.anticipationState.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!anticipationCalcs) {
        return;
      }
      const anticipationVectors = LNavUtils.getVectorsForTransitionMode(anticipationCalcs, this.anticipationState.transitionMode, this.anticipationState.isSuspended);
      this.anticipationVector = anticipationVectors[this.anticipationState.vectorIndex];
      if (!this.anticipationVector || this.anticipationVector === this.currentVector || this.anticipationVector.radius === 0 || this.anticipationVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        this.anticipationVector = void 0;
        return;
      }
      const circle = FlightPathUtils.setGeoCircleFromVector(this.anticipationVector, this.geoCircleCache[0]);
      this.anticipationXtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.NMILE);
      this.anticipationDtk = circle.bearingAt(this.aircraftState.planePos, Math.PI);
      this.anticipationBearingToVectorEnd = this.aircraftState.planePos.bearingTo(this.anticipationVector.endLat, this.anticipationVector.endLon);
      const maxBankAngle = this.maxBankAngleFunc();
      const currentVectorIdealBankAngle = MathUtils2.clamp(LNavDirector.getVectorIdealBankAngle(this.currentVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const anticipationIdealBankAngle = MathUtils2.clamp(LNavDirector.getVectorIdealBankAngle(this.anticipationVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
      const deltaBank = Math.abs(currentVectorIdealBankAngle - anticipationIdealBankAngle);
      const rollTimeSeconds = deltaBank / LNavDirector.VECTOR_ANTICIPATION_BANK_RATE;
      this.vectorAnticipationDistance = Math.min(
        rollTimeSeconds / 3600 * this.alongTrackSpeed,
        UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)
      );
    }
    applyEndOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      const inhibitNextSequence = this.inhibitNextSequence && leg.leg.type !== LegType2.ThruDiscontinuity;
      if (leg.leg.type === LegType2.FM || leg.leg.type === LegType2.VM || leg.leg.type === LegType2.Discontinuity) {
        return this.trySetSuspended(plan, state, true, out, true, false);
      } else if (inhibitNextSequence) {
        return this.trySetSuspended(plan, state, true, out, false, true);
      } else if (state.globalLegIndex < plan.length - 1) {
        const nextLeg = plan.getLeg(state.globalLegIndex + 1);
        if (!state.isMissedApproachActive && (leg.leg.fixTypeFlags === FixTypeFlags2.MAP || !BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach) && BitFlags.isAll(nextLeg.flags, LegDefinitionFlags.MissedApproach))) {
          return this.trySetSuspended(plan, state, true, out, true, false);
        }
      }
      return out;
    }
    applyStartOfLegSuspends(plan, state, out) {
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      const leg = plan.getLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      if (leg.leg.type === LegType2.HM || state.globalLegIndex === plan.length - 1) {
        return this.trySetSuspended(plan, state, true, out, false, false);
      }
      return out;
    }
    advanceToNextVector(plan, state, awaitCalculateOnNextLeg, out) {
      var _a, _b, _c, _d, _e, _f;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      let leg = plan.tryGetLeg(state.globalLegIndex);
      if (!leg) {
        return out;
      }
      let legIndex = state.globalLegIndex;
      let transitionMode = state.transitionMode;
      let isSuspended = state.isSuspended;
      let vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
      let vectorIndex = state.vectorIndex + 1;
      let vectorEndIndex = (_a = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _a !== void 0 ? _a : 0;
      let didAdvance = false;
      let isDone = false;
      if (transitionMode === LNavTransitionMode.Unsuspend && leg.calculated) {
        if (leg.calculated.ingressJoinIndex < 0) {
          vectorEndIndex = 0;
        } else {
          const ingress = leg.calculated.ingress;
          const ingressJoinVector = leg.calculated.flightPath[leg.calculated.ingressJoinIndex];
          if (ingress.length > 0 && ingressJoinVector && GeoPoint.equals(ingress[ingress.length - 1].endLat, ingress[ingress.length - 1].endLon, ingressJoinVector.startLat, ingressJoinVector.startLon)) {
            vectorEndIndex = leg.calculated.ingressJoinIndex;
          } else {
            vectorEndIndex = leg.calculated.ingressJoinIndex + 1;
          }
        }
      }
      while (!vectors || vectorIndex >= vectorEndIndex || vectors[vectorIndex].radius === 0 || vectors[vectorIndex].distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
        switch (transitionMode) {
          case LNavTransitionMode.Ingress:
            transitionMode = LNavTransitionMode.None;
            vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
            vectorIndex = Math.max(0, isSuspended ? (_c = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.ingressJoinIndex) !== null && _c !== void 0 ? _c : 0 : 0);
            didAdvance = true;
            break;
          case LNavTransitionMode.Unsuspend:
            transitionMode = LNavTransitionMode.None;
            vectors = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.ingressToEgress;
            vectorIndex = 0;
            didAdvance = true;
            break;
          case LNavTransitionMode.None:
            if (!isSuspended) {
              transitionMode = LNavTransitionMode.Egress;
              vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : void 0;
              vectorIndex = 0;
              didAdvance = true;
            } else if (leg.leg.type === LegType2.HM) {
              vectors = (_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath;
              vectorIndex = 0;
              didAdvance = true;
            } else {
              if (!didAdvance && vectors) {
                vectorIndex = Math.max(0, vectors.length - 1);
              }
              isDone = true;
            }
            break;
          case LNavTransitionMode.Egress:
            out.globalLegIndex = legIndex;
            out.transitionMode = transitionMode;
            out.vectorIndex = vectorIndex;
            out.isSuspended = isSuspended;
            this.advanceToNextLeg(plan, out, out);
            if (awaitCalculateOnNextLeg || out.globalLegIndex === legIndex) {
              return out;
            }
            leg = plan.tryGetLeg(out.globalLegIndex);
            if (!(leg === null || leg === void 0 ? void 0 : leg.calculated)) {
              return out;
            } else {
              legIndex = out.globalLegIndex;
              transitionMode = out.transitionMode;
              vectors = LNavUtils.getVectorsForTransitionMode(leg.calculated, out.transitionMode, out.isSuspended);
              vectorIndex = out.vectorIndex;
              isSuspended = out.isSuspended;
              didAdvance = false;
            }
        }
        if (isDone) {
          break;
        }
        vectorEndIndex = (_f = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _f !== void 0 ? _f : 0;
      }
      out.globalLegIndex = legIndex;
      out.transitionMode = transitionMode;
      out.vectorIndex = vectorIndex;
      out.isSuspended = isSuspended;
      return out;
    }
    advanceToNextLeg(plan, state, out) {
      var _a, _b, _c;
      this.applyEndOfLegSuspends(plan, state, out);
      if (!out.isSuspended) {
        if (out.globalLegIndex + 1 >= plan.length) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = Math.max(0, ((_c = (_b = (_a = plan.tryGetLeg(out.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) !== null && _c !== void 0 ? _c : 0) - 1);
          return out;
        }
        out.globalLegIndex++;
        out.transitionMode = LNavTransitionMode.Ingress;
        out.vectorIndex = 0;
        out.inhibitedSuspendLegIndex = -1;
        this.applyStartOfLegSuspends(plan, out, out);
      }
      return out;
    }
    trySetSuspended(plan, state, suspend, out, inhibitResuspend = false, resetVectorsOnSuspendEnd = false) {
      var _a;
      if (state !== out) {
        LNavDirector.copyStateInfo(state, out);
      }
      if (suspend && state.globalLegIndex === state.inhibitedSuspendLegIndex) {
        return out;
      }
      if (suspend) {
        out.inhibitedSuspendLegIndex = inhibitResuspend ? state.globalLegIndex : -1;
        out.resetVectorsOnSuspendEnd = resetVectorsOnSuspendEnd;
      }
      if (state.isSuspended !== suspend) {
        out.isSuspended = suspend;
        if (!suspend && state.resetVectorsOnSuspendEnd) {
          out.transitionMode = LNavTransitionMode.None;
          out.vectorIndex = 0;
          out.resetVectorsOnSuspendEnd = false;
        } else {
          const leg = plan.tryGetLeg(state.globalLegIndex);
          const legCalc = leg === null || leg === void 0 ? void 0 : leg.calculated;
          const ingressJoinVector = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath[legCalc.ingressJoinIndex];
          if (legCalc && state.transitionMode === LNavTransitionMode.None && legCalc.ingressJoinIndex >= 0 && ingressJoinVector && legCalc.ingress.length > 0) {
            const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
            let vectors;
            let offset;
            if (suspend) {
              vectors = legCalc.flightPath;
              if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                offset = legCalc.ingressJoinIndex + 1;
              } else {
                offset = legCalc.ingressJoinIndex;
              }
            } else {
              let pastIngressJoin = state.vectorIndex > legCalc.ingressJoinIndex;
              if (!pastIngressJoin && state.vectorIndex === legCalc.ingressJoinIndex && legCalc.flightPath[legCalc.ingressJoinIndex]) {
                const vector = legCalc.flightPath[legCalc.ingressJoinIndex];
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                const end = GeoPoint.sphericalToCartesian(ingressJoinVector.endLat, ingressJoinVector.endLon, this.vec3Cache[1]);
                pastIngressJoin = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.aircraftState.planePos) >= 1;
              }
              if (pastIngressJoin) {
                vectors = legCalc.ingressToEgress;
                if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                  offset = -(legCalc.ingressJoinIndex + 1);
                } else {
                  offset = -legCalc.ingressJoinIndex;
                }
              } else {
                vectors = legCalc.flightPath;
                offset = 0;
                out.transitionMode = LNavTransitionMode.Unsuspend;
              }
            }
            out.vectorIndex = Math.max(0, Math.min(state.vectorIndex + offset, vectors.length - 1));
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Unsuspend) {
            out.transitionMode = LNavTransitionMode.None;
          }
          if (suspend && state.transitionMode === LNavTransitionMode.Egress) {
            out.transitionMode = LNavTransitionMode.None;
            out.vectorIndex = Math.max(0, ((_a = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath.length) !== null && _a !== void 0 ? _a : 1) - 1);
          }
        }
      }
      return out;
    }
    tryActivate() {
      if (this.disableArming) {
        this.activate();
        return;
      }
      if (this.minimumActivationAltitude === void 0 || this.aircraftState.altAgl >= this.minimumActivationAltitude) {
        const headingDiff = NavMath.diffAngle(this.aircraftState.track, this.dtk);
        if (Math.abs(this.xtk) < 0.6 && Math.abs(headingDiff) < 110) {
          this.activate();
        }
      }
    }
    async awaitCalculate() {
      if (!this.flightPlanner.hasActiveFlightPlan()) {
        return;
      }
      this.isAwaitingCalculate = true;
      const id = ++this.awaitCalculateId;
      const plan = this.flightPlanner.getActiveFlightPlan();
      try {
        await plan.calculate();
      } catch (_a) {
      }
      if (id !== this.awaitCalculateId) {
        return;
      }
      this.isAwaitingCalculate = false;
    }
    getAlongLegDistance(plan, state, alongVectorDistance) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, false);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let distanceAlong = 0;
      for (let i = state.vectorIndex - 1; i >= 0; i--) {
        distanceAlong += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Egress:
          vectors = calcs.ingressToEgress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          vectors = calcs.ingress;
          for (let i = vectors.length - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
          }
      }
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex; i < calcs.ingressJoinIndex; i++) {
            distanceAlong -= vectors[i].distance;
          }
          if (state.vectorIndex <= calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceAlong -= UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
        }
      }
      return UnitType.METER.convertTo(distanceAlong, UnitType.NMILE) + alongVectorDistance;
    }
    getLegDistanceRemaining(plan, state, vectorDistanceRemaining) {
      var _a;
      const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
      if (!calcs) {
        return 0;
      }
      let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, state.isSuspended);
      const vector = vectors[state.vectorIndex];
      if (!vector) {
        return 0;
      }
      let vectorIndex = state.vectorIndex;
      let distanceRemaining = 0;
      if (state.transitionMode === LNavTransitionMode.Unsuspend) {
        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
        const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
        if (ingressJoinVector && lastIngressVector) {
          for (let i = state.vectorIndex + 1; i < calcs.ingressJoinIndex; i++) {
            distanceRemaining += vectors[i].distance;
          }
          if (state.vectorIndex < calcs.ingressJoinIndex) {
            const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
            const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
            const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
            distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
          }
          vectorIndex = -1;
        }
        vectors = calcs.ingressToEgress;
      }
      for (let i = vectorIndex + 1; i < vectors.length; i++) {
        distanceRemaining += vectors[i].distance;
      }
      switch (state.transitionMode) {
        case LNavTransitionMode.Ingress:
          vectors = LNavUtils.getVectorsForTransitionMode(calcs, LNavTransitionMode.None, state.isSuspended);
          for (let i = Math.max(0, state.isSuspended ? calcs.ingressJoinIndex : 0); i < vectors.length; i++) {
            const currentVector = vectors[i];
            if (state.isSuspended && i === calcs.ingressJoinIndex) {
              const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
              if (lastIngressVector) {
                const circle = FlightPathUtils.setGeoCircleFromVector(currentVector, this.geoCircleCache[0]);
                distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(this.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon), this.geoPointCache[1].set(currentVector.endLat, currentVector.endLon), Math.PI), UnitType.METER);
                continue;
              }
            }
            distanceRemaining += currentVector.distance;
          }
        case LNavTransitionMode.None:
        case LNavTransitionMode.Unsuspend:
          if (!state.isSuspended) {
            vectors = calcs.egress;
            for (let i = 0; i < vectors.length; i++) {
              distanceRemaining += vectors[i].distance;
            }
          }
      }
      return UnitType.METER.convertTo(distanceRemaining, UnitType.NMILE) + vectorDistanceRemaining;
    }
    static copyStateInfo(source, target) {
      target.globalLegIndex = source.globalLegIndex;
      target.transitionMode = source.transitionMode;
      target.vectorIndex = source.vectorIndex;
      target.isSuspended = source.isSuspended;
      target.inhibitedSuspendLegIndex = source.inhibitedSuspendLegIndex;
      target.resetVectorsOnSuspendEnd = source.resetVectorsOnSuspendEnd;
      target.isMissedApproachActive = source.isMissedApproachActive;
      return target;
    }
    static getVectorIdealBankAngle(vector, groundSpeed) {
      if (FlightPathUtils.isVectorGreatCircle(vector)) {
        return 0;
      }
      if (vector.radius < MathUtils2.HALF_PI) {
        return NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(vector.radius, UnitType.METER));
      } else {
        return -NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(Math.PI - vector.radius, UnitType.METER));
      }
    }
  };
  LNavDirector.ANGULAR_TOLERANCE = GeoCircle.ANGULAR_TOLERANCE;
  LNavDirector.ANGULAR_TOLERANCE_METERS = UnitType.GA_RADIAN.convertTo(GeoCircle.ANGULAR_TOLERANCE, UnitType.METER);
  LNavDirector.BANK_SERVO_RATE = 10;
  LNavDirector.VECTOR_ANTICIPATION_BANK_RATE = 5;
  var APBackCourseDirector = class {
    constructor(bus, apValues, mode, options) {
      var _a;
      this.bus = bus;
      this.apValues = apValues;
      this.mode = mode;
      this.bankServo = new LinearServo(APBackCourseDirector.BANK_SERVO_RATE);
      this.currentBankRef = 0;
      this.currentHeading = 0;
      this.currentTrack = 0;
      this.ppos = new GeoPoint(0, 0);
      this.navLocation = new GeoPoint(NaN, NaN);
      this.tas = 0;
      this.isApproachMode = Subject.create(false);
      const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : void 0;
      switch (typeof maxBankAngleOpt) {
        case "number":
          this.maxBankAngleFunc = () => maxBankAngleOpt;
          break;
        case "function":
          this.maxBankAngleFunc = maxBankAngleOpt;
          break;
        default:
          this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
      }
      this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
      this.state = DirectorState.Inactive;
      this.monitorEvents();
    }
    activate() {
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      this.state = DirectorState.Active;
      this.bankServo.reset();
    }
    arm() {
      if (this.state === DirectorState.Inactive && this.canArm()) {
        this.state = DirectorState.Armed;
        if (this.onArm !== void 0) {
          this.onArm();
        }
        SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", true);
        SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", true);
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      SimVar.SetSimVarValue("AUTOPILOT NAV1 LOCK", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT BACKCOURSE HOLD", "Bool", false);
      SimVar.SetSimVarValue("AUTOPILOT APPROACH ACTIVE", "Bool", false);
    }
    update() {
      if (!this.canArm()) {
        this.deactivate();
      }
      if (this.state === DirectorState.Armed) {
        if (this.canActivate()) {
          this.activate();
        }
      }
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank());
      }
    }
    canArm() {
      var _a, _b, _c, _d, _e;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      if (typeIsCorrect) {
        const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && ((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index);
        if (indexIsCorrect) {
          this.isApproachMode.set(true);
          return true;
        }
      }
      this.isApproachMode.set(false);
      return false;
    }
    canActivate() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      const typeIsCorrect = ((_a = this.navSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Nav;
      const index = (_b = this.navSource) === null || _b === void 0 ? void 0 : _b.index;
      const indexIsCorrect = index == ((_c = this.cdi) === null || _c === void 0 ? void 0 : _c.source.index) && (((_d = this.loc) === null || _d === void 0 ? void 0 : _d.isValid) && index == ((_e = this.loc) === null || _e === void 0 ? void 0 : _e.source.index));
      if (typeIsCorrect && indexIsCorrect && this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127 && ((_f = this.loc) === null || _f === void 0 ? void 0 : _f.course)) {
        const dtk = this.loc && this.loc.isValid && this.loc.course ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (dtk === null || dtk === void 0) {
          return false;
        }
        const headingDiff = NavMath.diffAngle(this.currentHeading, dtk);
        const isLoc = (_h = (_g = this.loc) === null || _g === void 0 ? void 0 : _g.isValid) !== null && _h !== void 0 ? _h : false;
        const sensitivity = isLoc ? 1 : 0.6;
        if (Math.abs(this.cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
          return true;
        }
      }
      return false;
    }
    desiredBank() {
      var _a, _b, _c, _d, _e, _f;
      const isLoc = (_b = (_a = this.loc) === null || _a === void 0 ? void 0 : _a.isValid) !== null && _b !== void 0 ? _b : false;
      const hasValidDeviation = this.cdi !== void 0 && this.cdi.deviation !== null && Math.abs(this.cdi.deviation) < 127;
      if (!isLoc || isLoc && !hasValidDeviation) {
        this.deactivate();
        return NaN;
      }
      if (this.cdi && this.cdi.deviation !== null) {
        const xtk = this.cdi && this.cdi.deviation !== null ? this.getXtk(-this.cdi.deviation, isLoc) : 0;
        const courseMag = isLoc && ((_c = this.loc) === null || _c === void 0 ? void 0 : _c.course) !== void 0 ? NavMath.normalizeHeading(this.loc.course * Avionics.Utils.RAD2DEG + 180) : null;
        if (courseMag === null || courseMag === void 0) {
          this.deactivate();
          return NaN;
        }
        let absInterceptAngle = 0;
        if (this.lateralInterceptCurve !== void 0) {
          absInterceptAngle = this.lateralInterceptCurve(this.getNavDistance(), ((_e = -((_d = this.cdi) === null || _d === void 0 ? void 0 : _d.deviation)) !== null && _e !== void 0 ? _e : 0) / 127, this.tas, isLoc);
        } else {
          absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + Math.abs(xtk) * 50, 45);
          if (absInterceptAngle <= 2.5) {
            absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
          }
        }
        const interceptAngle = xtk > 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, (_f = this.magVar) !== null && _f !== void 0 ? _f : 0) + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.currentTrack, desiredTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(this.currentTrack, desiredTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= turnDirection === "left" ? 1 : -1;
        return baseBank;
      }
      this.deactivate();
      return NaN;
    }
    getXtk(deviation, isLoc) {
      const scale = isLoc ? 1 : 2;
      const factor = isLoc ? 0.35 : 1;
      return MathUtils2.clamp(this.getNavDistance() * Math.sin(UnitType.DEGREE.convertTo(12, UnitType.RADIAN) * (factor * deviation / 127)), -scale, scale);
    }
    getNavDistance() {
      if (!isNaN(this.navLocation.lat)) {
        return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(this.ppos), UnitType.NMILE);
      } else {
        return 5;
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APBackCourseDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
    checkForZoneOfConfusion() {
      if (this.getNavDistance() < 2 && this.cdi !== void 0 && this.cdi.deviation !== null) {
        return true;
      }
      return false;
    }
    monitorEvents() {
      const sub2 = this.bus.getSubscriber();
      sub2.on("nav_radio_active_cdi_deviation").handle((cdi) => this.cdi = cdi);
      sub2.on("nav_radio_active_localizer").handle((loc) => this.loc = loc);
      sub2.on("cdi_select").handle((source) => {
        this.navSource = source;
        if (this.state === DirectorState.Active) {
          this.deactivate();
        }
      });
      sub2.on("nav_radio_active_nav_location").handle((loc) => {
        this.navLocation.set(loc.lat, loc.long);
      });
      sub2.on("nav_radio_active_magvar").handle((magVar) => {
        this.magVar = magVar;
      });
      sub2.on("hdg_deg").withPrecision(0).handle((h) => {
        this.currentHeading = h;
      });
      sub2.on("tas").handle((s) => this.tas = s);
      sub2.on("gps-position").atFrequency(1).handle((lla) => {
        this.ppos.set(lla.lat, lla.long);
      });
      sub2.on("track_deg_true").handle((t) => {
        this.currentTrack = t;
      });
    }
  };
  APBackCourseDirector.BANK_SERVO_RATE = 10;
  var APLvlDirector = class {
    constructor(bus, isToGaMode = false) {
      this.bus = bus;
      this.isToGaMode = isToGaMode;
      this.currentBankRef = 0;
      this.desiredBank = 0;
      this.bankServo = new LinearServo(APLvlDirector.BANK_SERVO_RATE);
      this.state = DirectorState.Inactive;
    }
    activate() {
      this.state = DirectorState.Active;
      this.desiredBank = 0;
      if (this.onActivate !== void 0) {
        this.onActivate();
      }
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", true);
      }
      this.bankServo.reset();
    }
    arm() {
      if (this.state == DirectorState.Inactive) {
        this.activate();
      }
    }
    deactivate() {
      this.state = DirectorState.Inactive;
      this.desiredBank = 0;
      if (!this.isToGaMode) {
        SimVar.SetSimVarValue("AUTOPILOT WING LEVELER", "Bool", false);
      }
    }
    update() {
      if (this.state === DirectorState.Active) {
        this.setBank(this.desiredBank);
      }
    }
    setBank(bankAngle) {
      if (isFinite(bankAngle)) {
        this.bankServo.rate = APLvlDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue("E:SIMULATION RATE", SimVarValueType.Number);
        this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        SimVar.SetSimVarValue("AUTOPILOT BANK HOLD REF", "degrees", this.currentBankRef);
      }
    }
  };
  APLvlDirector.BANK_SERVO_RATE = 10;
  var SmoothingPathCalculator = class {
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      this.bus = bus;
      this.flightPlanner = flightPlanner;
      this.primaryPlanIndex = primaryPlanIndex;
      this.verticalFlightPlans = [];
      this.planBuilt = new SubEvent();
      this.vnavCalculated = new SubEvent();
      this.legAltitudes = [0, 0];
      this.applyPathValuesResult = [void 0, 0];
      this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
      this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
      this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
      this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
      this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
      this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
      this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : () => true;
      this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
      this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
      const fpl = this.bus.getSubscriber();
      fpl.on("fplCreated").handle((e) => this.createVerticalPlan(e.planIndex));
      fpl.on("fplCopied").handle((e) => this.onPlanChanged(e.targetPlanIndex));
      fpl.on("fplLoaded").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplLegChange").handle((e) => this.onPlanChanged(e.planIndex, e));
      fpl.on("fplSegmentChange").handle((e) => this.onPlanChanged(e.planIndex, void 0, e));
      fpl.on("fplIndexChanged").handle((e) => this.onPlanChanged(e.planIndex));
      fpl.on("fplCalculated").handle((e) => this.onPlanCalculated(e));
      bus.getSubscriber().on("vnav_set_default_fpa").handle(this.setDefaultFpa.bind(this));
      bus.getSubscriber().on("vnav_set_vnav_direct_to").handle((data) => {
        if (data.globalLegIndex < 0) {
          this.cancelVerticalDirect(data.planIndex);
        } else {
          this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
        }
      });
    }
    getVerticalFlightPlan(planIndex) {
      var _a;
      var _b;
      return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : _b[planIndex] = this.createVerticalPlan(planIndex);
    }
    createVerticalPlan(planIndex) {
      const verticalFlightPlan = {
        planIndex,
        length: 0,
        constraints: [],
        segments: [],
        destLegIndex: void 0,
        fafLegIndex: void 0,
        firstDescentConstraintLegIndex: void 0,
        lastDescentConstraintLegIndex: void 0,
        missedApproachStartIndex: void 0,
        currentAlongLegDistance: void 0,
        verticalDirectIndex: void 0,
        verticalDirectFpa: void 0,
        planChanged: true
      };
      this.verticalFlightPlans[planIndex] = verticalFlightPlan;
      return verticalFlightPlan;
    }
    requestPathCompute(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== void 0) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        this.computePathAndNotify(lateralPlan, verticalPlan);
        return true;
      }
      return false;
    }
    getTargetConstraintIndex(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
          const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
          if (priorConstraint && priorConstraint.type !== "climb" && priorConstraint.type !== "missed") {
            return priorConstraintIndex;
          } else {
            return -1;
          }
        }
        let i = verticalPlan.constraints.length - 1;
        while (i >= 0) {
          const constraint = verticalPlan.constraints[i];
          if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== "climb" && constraint.type !== "missed") {
            return i;
          }
          i--;
        }
      } else {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraintIndex >= 0) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isMissed = currentConstraint.type === "missed";
          for (let i = currentConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === "climb" || isMissed && constraint.type === "missed") {
              if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return i;
              }
            } else {
              return -1;
            }
          }
        }
      }
      return -1;
    }
    getTargetConstraint(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    getTargetAltitude(planIndex, globalLegIndex) {
      var _a, _b;
      if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
        return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
      } else {
        return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
      }
    }
    getFlightPhase(planIndex) {
      if (this.flightPlanner.hasFlightPlan(planIndex)) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
        if (globalLegIndex > -1) {
          const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
          switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
            case "climb":
            case "missed":
              return VerticalFlightPhase.Climb;
          }
        }
      }
      return VerticalFlightPhase.Descent;
    }
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return void 0;
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
      } else {
        return currentConstraint.targetAltitude;
      }
    }
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint === void 0) {
        return { type: AltitudeRestrictionType.Unused, altitude: 0 };
      }
      const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint.type !== "climb" && currentConstraint.type !== "missed" && currentConstraint.nextVnavEligibleLegIndex !== void 0 && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
        if (priorConstraint) {
          return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        } else {
          return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
      } else {
        return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
      }
    }
    getNextConstraintAltitude(planIndex, globalLegIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
      if (currentConstraint !== void 0) {
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
          if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
            return currentConstraint.maxAltitude;
          } else {
            return currentConstraint.minAltitude;
          }
        } else {
          if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
            return currentConstraint.minAltitude;
          } else {
            return currentConstraint.maxAltitude;
          }
        }
      }
      return void 0;
    }
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
      if (currentConstraint) {
        const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
        if (currentConstraintIndex > -1) {
          if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "climb" || constraint.type === "missed") {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          } else {
            for (let i = currentConstraintIndex; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
                if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                  return constraint;
                }
              } else {
                return void 0;
              }
            }
          }
        }
      }
      return void 0;
    }
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
      if (constraintGlobalLegIndex < 0) {
        return;
      }
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
      verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    cancelVerticalDirect(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex === void 0) {
        return;
      }
      verticalPlan.verticalDirectIndex = void 0;
      verticalPlan.verticalDirectFpa = void 0;
      const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
      this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
      if (verticalPlan.constraints.length > 0) {
        if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
          verticalPlan.planChanged = true;
        }
      }
    }
    setDefaultFpa(fpa) {
      const newFpa = Math.max(0, fpa);
      if (newFpa !== this.flightPathAngle) {
        this.flightPathAngle = newFpa;
        for (let i = 0; i < this.verticalFlightPlans.length; i++) {
          const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : void 0;
          const verticalPlan = this.verticalFlightPlans[i];
          if (lateralPlan && verticalPlan) {
            if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
              verticalPlan.planChanged = true;
              this.notifyCalculated(i);
            }
          }
        }
      }
    }
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
      const plan = this.flightPlanner.getFlightPlan(planIndex);
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.verticalDirectIndex !== void 0) {
        if (legChangeEvent !== void 0) {
          const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
          if (globalIndex <= verticalPlan.verticalDirectIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        } else if (segmentChangeEvent !== void 0) {
          const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
          if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
            verticalPlan.verticalDirectIndex = void 0;
          }
        }
      }
      verticalPlan.planChanged = true;
      verticalPlan.currentAlongLegDistance = void 0;
    }
    onPlanCalculated(event) {
      const lateralPlan = this.flightPlanner.getFlightPlan(event.planIndex);
      const verticalPlan = this.getVerticalFlightPlan(event.planIndex);
      if (verticalPlan.planChanged) {
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      } else {
        if (verticalPlan.constraints.length > 0) {
          if (!this.computePathAndNotify(lateralPlan, verticalPlan)) {
            verticalPlan.planChanged = true;
          }
        } else {
          this.notifyCalculated(event.planIndex);
        }
      }
    }
    notifyBuilt(planIndex) {
      this.planBuilt.notify(this, planIndex);
    }
    notifyCalculated(planIndex) {
      this.vnavCalculated.notify(this, planIndex);
    }
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
      this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
      this.notifyBuilt(verticalPlan.planIndex);
    }
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
      this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
      SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
      verticalPlan.planChanged = false;
    }
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
      var _a, _b, _c, _d, _e, _f, _g;
      verticalPlan.constraints.length = 0;
      verticalPlan.segments.length = 0;
      verticalPlan.destLegIndex = void 0;
      verticalPlan.firstDescentConstraintLegIndex = void 0;
      verticalPlan.lastDescentConstraintLegIndex = void 0;
      verticalPlan.missedApproachStartIndex = void 0;
      verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
      const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
      let firstApproachGlobalLegIndex;
      for (const segment of lateralPlan.segments()) {
        verticalPlan.segments[segment.segmentIndex] = {
          offset: segment.offset,
          legs: []
        };
        if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === void 0) {
          firstApproachGlobalLegIndex = segment.offset;
        }
        for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
          const globalLegIndex = segment.offset + segmentLegIndex;
          const lateralLeg = segment.legs[segmentLegIndex];
          const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : "", (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : void 0);
          if (verticalPlan.missedApproachStartIndex === void 0 && segment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            verticalPlan.missedApproachStartIndex = globalLegIndex;
          }
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
          verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
          const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== void 0 && globalLegIndex < verticalPlan.verticalDirectIndex;
          const legPrecedesDirectTo = directToTargetLegIndex !== void 0 && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
          if (constraintAltitudes !== void 0 && !legPrecedesVerticalDirectIndex && !legPrecedesDirectTo && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
            verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
            const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.unshift(verticalConstraint);
          }
          verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
        }
      }
      verticalPlan.length = lateralPlan.length;
      if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== void 0) {
        const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
        if (firstApproachConstraint && firstApproachConstraint.type !== "climb" && firstApproachConstraint.type !== "missed") {
          SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
        }
      }
      verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
      verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name69) {
      var _a;
      const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name69, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? "missed" : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? "descent" : "climb");
      constraint.isBeyondFaf = verticalPlan.fafLegIndex === void 0 ? false : globalLegIndex > verticalPlan.fafLegIndex;
      if (verticalPlan.verticalDirectIndex === globalLegIndex) {
        constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
        constraint.type = "direct";
      }
      const userFpa = lateralLeg.verticalData.fpa;
      if (userFpa !== void 0 && constraint.type !== "climb" && constraint.type !== "missed") {
        constraint.fpa = userFpa;
        constraint.type = "manual";
      }
      return constraint;
    }
    computePathAndNotify(lateralPlan, verticalPlan) {
      if (this.computePath(lateralPlan, verticalPlan)) {
        this.notifyCalculated(lateralPlan.planIndex);
        return true;
      } else {
        return false;
      }
    }
    computePath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return false;
      }
      this.computeDescentPath(lateralPlan, verticalPlan);
      return true;
    }
    computeDescentPath(lateralPlan, verticalPlan) {
      if (verticalPlan.constraints.length < 1) {
        return;
      }
      this.fillLegDistances(lateralPlan, verticalPlan);
      this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
      this.findAndRemoveInvalidConstraints(verticalPlan);
      this.populateConstraints(verticalPlan);
      if (this.computeFlightPathAngles(verticalPlan)) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
          const constraint = verticalPlan.constraints[constraintIndex];
          if (constraint.type === "descent" || constraint.type === "direct" || constraint.type === "manual") {
            let altitude = constraint.targetAltitude;
            let constraintIsBod = true;
            if (constraintIndex > 0) {
              const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
              if (nextConstraint !== void 0 && nextConstraint.type !== "climb") {
                const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                if (nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25 || constraint.fpa === 0) {
                  constraintIsBod = false;
                }
              }
            }
            if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
              constraint.isPathEnd = true;
              constraint.isTarget = true;
              constraintIsBod = true;
            }
            for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
              const leg = constraint.legs[legIndex];
              leg.fpa = constraint.fpa;
              leg.altitude = altitude;
              altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
              if (legIndex === 0) {
                leg.isAdvisory = false;
              } else {
                leg.isAdvisory = true;
              }
              if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                leg.isBod = true;
              } else {
                leg.isBod = false;
              }
            }
          }
        }
      }
    }
    fillLegDistances(lateralPlan, verticalPlan) {
      var _a, _b, _c;
      if (lateralPlan.length > 0) {
        for (const segment of lateralPlan.segments()) {
          if (segment) {
            const vnavSegment = verticalPlan.segments[segment.segmentIndex];
            for (let l = 0; l < segment.legs.length; l++) {
              const leg = segment.legs[l];
              if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
              } else if (leg && leg.calculated && leg.calculated.endLat !== void 0 && leg.calculated.endLon !== void 0) {
                let prevLeg;
                for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                  if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== void 0 && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== void 0) {
                    prevLeg = checkLeg;
                    break;
                  }
                }
                if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                  vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                }
              } else {
                vnavSegment.legs[l].distance = 0;
              }
            }
          }
        }
      }
    }
    findAndRemoveInvalidConstraints(verticalPlan) {
      var _a, _b, _c;
      let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? firstDescentConstraintIndex : verticalPlan.constraints.length - 1;
      let phase = "climb";
      let priorMinAltitude = -Infinity;
      let priorMaxAltitude = Infinity;
      let distanceFromPriorMinAltitude = 0;
      let requiredFpa = 0;
      for (let i = startIndex; i >= 0; i--) {
        const currentConstraint = verticalPlan.constraints[i];
        const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
        let currentPhase;
        switch (currentConstraint.type) {
          case "climb":
          case "missed":
            currentPhase = currentConstraint.type;
            break;
          default:
            currentPhase = "descent";
        }
        if (currentPhase !== phase) {
          phase = currentPhase;
          priorMinAltitude = -Infinity;
          priorMaxAltitude = Infinity;
          distanceFromPriorMinAltitude = currentConstraintDistance;
        } else {
          distanceFromPriorMinAltitude += currentConstraintDistance;
        }
        let isDescentConstraint;
        let shouldInvalidate;
        switch (phase) {
          case "climb":
          case "missed":
            isDescentConstraint = false;
            shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
            break;
          default:
            isDescentConstraint = true;
            if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
              requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
            } else {
              requiredFpa = 0;
            }
            shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
        }
        const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
        if (shouldInvalidate) {
          constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
          verticalPlan.constraints.splice(i, 1);
          distanceFromPriorMinAltitude -= currentConstraintDistance;
          if (isDescentConstraint && i === firstDescentConstraintIndex) {
            firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
            verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
          }
        } else {
          constraintLeg.invalidConstraintAltitude = void 0;
          if (isFinite(currentConstraint.minAltitude)) {
            priorMinAltitude = currentConstraint.minAltitude;
            distanceFromPriorMinAltitude = 0;
          }
          if (isFinite(currentConstraint.maxAltitude)) {
            priorMaxAltitude = currentConstraint.maxAltitude;
          }
        }
      }
      verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
      var _a;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === "direct" ? verticalPlan.firstDescentConstraintLegIndex + 1 : 0;
      let globalLegIndex = startIndex;
      for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
        const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        if (verticalLeg.invalidConstraintAltitude !== void 0) {
          const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
          const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
          if (constraintAltitudes !== void 0) {
            const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
            verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
            if (proposedConstraint.type === "descent" || proposedConstraint.type === "manual" || proposedConstraint.type === "direct" || proposedConstraint.type === "dest") {
              if (verticalPlan.firstDescentConstraintLegIndex === void 0 || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
              }
              if (verticalPlan.lastDescentConstraintLegIndex === void 0 || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
              }
            }
          }
        }
        globalLegIndex++;
      }
    }
    populateConstraints(verticalPlan) {
      for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
        const constraint = verticalPlan.constraints[constraintIndex];
        const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
        constraint.legs.length = 0;
        constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
        let eligibleLegIndex;
        let ineligibleLegIndex;
        for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== void 0 ? previousConstraint.index : -1); globalLegIndex--) {
          const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
          constraint.legs.push(verticalLeg);
          if (ineligibleLegIndex === void 0 && verticalLeg.isEligible) {
            eligibleLegIndex = globalLegIndex;
          }
          if (ineligibleLegIndex === void 0 && !verticalLeg.isEligible) {
            ineligibleLegIndex = globalLegIndex;
          }
        }
        if (ineligibleLegIndex !== void 0 && eligibleLegIndex !== void 0) {
          constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
        }
      }
    }
    computeFlightPathAngles(verticalPlan) {
      let currentTargetConstraint;
      let currentPathSegmentDistance = 0;
      let currentPathSegmentMinFpa = this.minFlightPathAngle;
      let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
      let currentTargetConstraintHasFixedFpa = false;
      const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
      const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === void 0 ? -1 : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
      if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
        return false;
      }
      for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
        const constraint = verticalPlan.constraints[targetConstraintIndex];
        if (constraint.type === "climb" || constraint.type === "missed") {
          continue;
        }
        if (!currentTargetConstraint) {
          if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
            currentTargetConstraint = constraint;
            currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
            currentTargetConstraint.isTarget = true;
          } else {
            continue;
          }
        }
        currentPathSegmentMinFpa = this.minFlightPathAngle;
        currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        currentPathSegmentDistance = currentTargetConstraint.distance;
        const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
        if (currentTargetConstraintIsFirstDescentConstraint) {
          if (currentTargetConstraint.type === "descent") {
            currentTargetConstraint.fpa = this.flightPathAngle;
          }
          return true;
        }
        if (currentTargetConstraint.type === "manual") {
          currentPathSegmentMinFpa = currentTargetConstraint.fpa;
          currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
          currentTargetConstraintHasFixedFpa = true;
        } else {
          currentTargetConstraintHasFixedFpa = false;
        }
        let pathSegmentIsFlat = false;
        for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
          const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
          const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
          const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
          const isCurrentConstraintClimb = currentConstraint.type === "climb" || currentConstraint.type === "missed";
          const isCurrentConstraintManual = currentConstraint.type === "manual";
          const isCurrentConstraintDirect = currentConstraint.type === "direct";
          if (isCurrentConstraintClimb) {
            if (currentConstraintIndex - 1 > targetConstraintIndex) {
              currentTargetConstraint.fpa = MathUtils2.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
              const maxAltitude2 = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
              const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude2, false);
              if (terminatedIndex < currentConstraintIndex) {
                targetConstraintIndex = terminatedIndex - 1;
                currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                break;
              }
            } else {
              currentTargetConstraint.fpa = this.flightPathAngle;
            }
            targetConstraintIndex = currentConstraintIndex;
            currentTargetConstraint = void 0;
            break;
          }
          const minAltitude = currentConstraint.minAltitude;
          const maxAltitude = currentConstraint.maxAltitude;
          if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
            const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
            const newTargetConstraintIndex = currentConstraintIndex - 1;
            SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
            targetConstraintIndex = newTargetConstraintIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            currentTargetConstraint.targetAltitude = flatSegmentAltitude;
            currentTargetConstraint.isTarget = true;
            break;
          } else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
            pathSegmentIsFlat = true;
            currentTargetConstraint.fpa = 0;
            if (isCurrentConstraintFirstDescent) {
              const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
              SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, flatSegmentAltitude, this.applyPathValuesResult);
              targetConstraintIndex = currentConstraintIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
              currentTargetConstraint.targetAltitude = flatSegmentAltitude;
              currentTargetConstraint.isTarget = true;
              break;
            }
            continue;
          }
          const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
          const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
          const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
          if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
            if (isFpaOutOfBounds) {
              if (minFpa > currentPathSegmentMaxFpa) {
                currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
              } else {
                currentTargetConstraint.fpa = currentPathSegmentMinFpa;
              }
            } else {
              currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
              currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
              currentTargetConstraint.fpa = MathUtils2.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            }
            const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
            targetConstraintIndex = terminatedIndex - 1;
            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
            break;
          } else if (isCurrentConstraintFirstDescent) {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentTargetConstraint.fpa = MathUtils2.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
            const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
            if (terminatedIndex < currentConstraintIndex + 1) {
              targetConstraintIndex = terminatedIndex - 1;
              currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
              break;
            } else {
              return true;
            }
          } else {
            currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
            currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
            currentPathSegmentDistance += currentConstraint.distance;
          }
        }
      }
      return true;
    }
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
      const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
      if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== void 0) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
        const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
        const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
        newTargetConstraint.isTarget = true;
        newTargetConstraint.targetAltitude = MathUtils2.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
      }
      return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    getFirstDescentConstraintAltitude(planIndex) {
      const verticalPlan = this.getVerticalFlightPlan(planIndex);
      if (verticalPlan.constraints.length > 0) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
          const constraint = verticalPlan.constraints[i];
          if (constraint.type !== "climb") {
            return constraint.targetAltitude;
          }
        }
      }
      return void 0;
    }
    static getConstraintAltitudes(leg, out) {
      if (leg.verticalData !== void 0) {
        switch (leg.verticalData.altDesc) {
          case AltitudeRestrictionType.At:
            out[0] = leg.verticalData.altitude1;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.AtOrAbove:
            out[0] = leg.verticalData.altitude1;
            out[1] = Number.POSITIVE_INFINITY;
            return out;
          case AltitudeRestrictionType.AtOrBelow:
            out[0] = Number.NEGATIVE_INFINITY;
            out[1] = leg.verticalData.altitude1;
            return out;
          case AltitudeRestrictionType.Between:
            out[0] = leg.verticalData.altitude2;
            out[1] = leg.verticalData.altitude1;
            return out;
        }
      }
      return void 0;
    }
    static forceAtConstraint(constraint) {
      if (constraint.minAltitude !== constraint.maxAltitude) {
        if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
          constraint.maxAltitude = constraint.minAltitude;
        } else {
          constraint.minAltitude = constraint.maxAltitude;
        }
      }
    }
    static getDirectToTargetLegIndex(lateralPlan) {
      const directToData = lateralPlan.directToData;
      if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
        const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
        if (segment !== null) {
          return segment.offset + directToData.segmentLegIndex;
        }
      }
      return void 0;
    }
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
      if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
        const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
        if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
          const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
          directVerticalLeg.isDirectToTarget = true;
          const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
          if (segment !== void 0) {
            const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
              const constraint = verticalPlan.constraints[i];
              if (constraint.type !== "climb" && constraint.type !== "missed" && constraint.index >= globalLegIndex) {
                verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                return;
              }
            }
            verticalPlan.firstDescentConstraintLegIndex = void 0;
          }
        }
      }
    }
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
      if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
        return true;
      }
      return false;
    }
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
      const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
      const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
      if (currentMinWithPrecision > priorMaxWithPrecision) {
        return true;
      }
      return false;
    }
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
      if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
        const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
        const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
        if (minFpaTempValue > maxFpa) {
          return true;
        }
      }
      return false;
    }
    static isLegVnavEligible(lateralLeg) {
      switch (lateralLeg.leg.type) {
        case LegType2.VM:
        case LegType2.FM:
        case LegType2.Discontinuity:
        case LegType2.ThruDiscontinuity:
          return false;
        default:
          return true;
      }
    }
    static invalidateClimbConstraint() {
      return false;
    }
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
      return isFinite(constraint.minAltitude) && MathUtils2.round(constraint.minAltitude, 10) > MathUtils2.round(priorMaxAltitude, 10) || requiredFpa > maxFpa;
    }
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
      for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
        const constraint = verticalPlan.constraints[i];
        if (constraint.maxAltitude < Infinity) {
          return constraint.maxAltitude;
        }
        if (i === firstDescentConstraintIndex && constraint.type === "direct") {
          if (constraint.minAltitude > -Infinity) {
            return constraint.minAltitude;
          }
        }
      }
      return Infinity;
    }
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
      const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
      let distance = currentTargetConstraint.distance;
      for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
        const smoothedConstraint = verticalPlan.constraints[i];
        const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
        if (targetAltitude < maxAltitude) {
          smoothedConstraint.fpa = currentTargetConstraint.fpa;
          smoothedConstraint.targetAltitude = targetAltitude;
          distance += smoothedConstraint.distance;
        } else {
          out[0] = i;
          out[1] = distance;
          return out;
        }
      }
      out[0] = void 0;
      out[1] = distance;
      return out;
    }
  };
  SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
  SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
  SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
  SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;
  var LNavDataVars;
  (function(LNavDataVars2) {
    LNavDataVars2["DTKTrue"] = "L:WT_LNavData_DTK_True";
    LNavDataVars2["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    LNavDataVars2["XTK"] = "L:WT_LNavData_XTK";
    LNavDataVars2["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    LNavDataVars2["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    LNavDataVars2["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    LNavDataVars2["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    LNavDataVars2["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
  })(LNavDataVars || (LNavDataVars = {}));
  var LNavDataSimVarPublisher = class extends SimVarPublisher {
    constructor(bus) {
      super(LNavDataSimVarPublisher.simvars, bus);
    }
  };
  LNavDataSimVarPublisher.simvars = /* @__PURE__ */ new Map([
    ["lnavdata_dtk_true", { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ["lnavdata_dtk_mag", { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_xtk", { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ["lnavdata_cdi_scale", { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ["lnavdata_waypoint_bearing_true", { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_bearing_mag", { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ["lnavdata_waypoint_distance", { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ["lnavdata_destination_distance", { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
  ]);
  var AltitudeSelectManager = class {
    constructor(bus, settingsManager, options, stops) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.stops = new SortedArray((a, b) => a - b);
      this.isEnabled = true;
      this.isInitialized = false;
      this.isPaused = false;
      this.isLocked = false;
      this.lockDebounceTimer = new DebounceTimer();
      this.consecIncrSmallCount = 0;
      this.lastIncrSmallDirection = 1;
      this.lastIncrSmallInputTime = 0;
      this.selectedAltitudeChangedHandler = () => {
        setTimeout(() => {
          this.isLocked = false;
          this.lockDebounceTimer.clear();
        });
      };
      this.altitudeHoldSlotIndex = (_a = options.altitudeHoldSlotIndex) !== null && _a !== void 0 ? _a : 1;
      this.altitudeHoldSlotSimVar = `AUTOPILOT ALTITUDE LOCK VAR:${this.altitudeHoldSlotIndex}`;
      this.minValue = Math.round(options.minValue.asUnit(UnitType.FOOT));
      this.maxValue = Math.round(options.maxValue.asUnit(UnitType.FOOT));
      this.minValueMetric = Math.round(((_b = options.minValueMetric) !== null && _b !== void 0 ? _b : options.minValue).asUnit(UnitType.METER));
      this.maxValueMetric = Math.round(((_c = options.maxValueMetric) !== null && _c !== void 0 ? _c : options.maxValue).asUnit(UnitType.METER));
      this.inputIncrLargeThreshold = options.inputIncrLargeThreshold;
      this.incrSmall = Math.round(options.incrSmall.asUnit(UnitType.FOOT));
      this.incrLarge = Math.round(options.incrLarge.asUnit(UnitType.FOOT));
      this.incrSmallMetric = Math.round(((_d = options.incrSmallMetric) !== null && _d !== void 0 ? _d : options.incrSmall).asUnit(UnitType.METER));
      this.incrLargeMetric = Math.round(((_e = options.incrLargeMetric) !== null && _e !== void 0 ? _e : options.incrLarge).asUnit(UnitType.METER));
      this.lockAltToStepOnIncr = (_f = options.lockAltToStepOnIncr) !== null && _f !== void 0 ? _f : true;
      this.lockAltToStepOnIncrMetric = (_g = options.lockAltToStepOnIncrMetric) !== null && _g !== void 0 ? _g : this.lockAltToStepOnIncr;
      this.accelInputCountThreshold = (_h = options.accelInputCountThreshold) !== null && _h !== void 0 ? _h : 0;
      this.accelResetOnDirectionChange = (_j = options.accelResetOnDirectionChange) !== null && _j !== void 0 ? _j : false;
      this.initToIndicatedAlt = (_k = options.initToIndicatedAlt) !== null && _k !== void 0 ? _k : false;
      this.transformSetToIncDec = (_l = options.transformSetToIncDec) !== null && _l !== void 0 ? _l : true;
      this.altimeterMetricSetting = options.supportMetric ? settingsManager.getSetting("altMetric") : void 0;
      if (stops !== void 0) {
        if ("isSubscribableSet" in stops) {
          stops.sub((set, type, key) => {
            if (type === SubscribableSetEventType.Added) {
              this.stops.insert(key);
            } else {
              this.stops.remove(key);
            }
          }, true);
        } else {
          this.stops.insertAll(new Set(stops));
        }
      }
      this.isInitialized = !((_m = options.initOnInput) !== null && _m !== void 0 ? _m : false);
      KeyEventManager.getManager(bus).then((manager) => {
        this.keyEventManager = manager;
        manager.interceptKey("AP_ALT_VAR_SET_ENGLISH", false);
        manager.interceptKey("AP_ALT_VAR_SET_METRIC", false);
        manager.interceptKey("AP_ALT_VAR_INC", false);
        manager.interceptKey("AP_ALT_VAR_DEC", false);
        const sub2 = this.bus.getSubscriber();
        if (this.transformSetToIncDec) {
          sub2.on(`ap_altitude_selected_${this.altitudeHoldSlotIndex}`).whenChanged().handle(this.selectedAltitudeChangedHandler);
        }
        sub2.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        this.publisher.pub("alt_select_is_initialized", !this.isEnabled || this.isInitialized, true);
      });
    }
    setEnabled(isEnabled) {
      this.isEnabled = isEnabled;
      this.publisher.pub("alt_select_is_initialized", !isEnabled || this.isInitialized, true);
    }
    resume() {
      this.isPaused = false;
    }
    pause() {
      this.isPaused = true;
    }
    reset(altitude, resetInitialized = false) {
      if (!this.isEnabled) {
        return;
      }
      SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, altitude);
      if (resetInitialized) {
        this.isInitialized = false;
        this.publisher.pub("alt_select_is_initialized", false, true);
      }
    }
    onKeyIntercepted({ key, value0: value, value1: index }) {
      switch (key) {
        case "AP_ALT_VAR_INC":
        case "AP_ALT_VAR_DEC":
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          break;
        default:
          return;
      }
      index !== null && index !== void 0 ? index : index = 1;
      index = Math.max(1, index);
      if (!this.isEnabled || index !== this.altitudeHoldSlotIndex) {
        this.passThroughKeyEvent(key, index, value);
        return;
      }
      if (!this.isPaused && !this.isLocked) {
        this.handleKeyEvent(key, value);
      }
    }
    handleKeyEvent(key, value) {
      const currentValue = SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet);
      let startValue = currentValue;
      if (!this.isInitialized) {
        if (this.initToIndicatedAlt) {
          startValue = SimVar.GetSimVarValue("INDICATED ALTITUDE", SimVarValueType.Feet);
        } else {
          startValue = 0;
        }
        this.publisher.pub("alt_select_is_initialized", true, true);
        this.isInitialized = true;
      }
      let direction = 0;
      let useLargeIncrement = false;
      let setAltitude = void 0;
      switch (key) {
        case "AP_ALT_VAR_INC":
          direction = 1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_DEC":
          direction = -1;
          useLargeIncrement = value !== void 0 && value > this.inputIncrLargeThreshold;
          break;
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC": {
          if (value !== void 0 && value !== currentValue) {
            if (this.transformSetToIncDec) {
              const delta = value - currentValue;
              direction = delta < 0 ? -1 : 1;
              useLargeIncrement = Math.abs(delta) > this.inputIncrLargeThreshold;
            } else {
              setAltitude = value;
            }
          }
          break;
        }
      }
      if (setAltitude !== void 0) {
        this.setSelectedAltitude(setAltitude);
        return;
      }
      if (this.accelInputCountThreshold > 0) {
        const time = Date.now();
        let isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (useLargeIncrement || direction === 0 || this.consecIncrSmallCount > 0 && time - this.lastIncrSmallInputTime > AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD || (isAccelActive ? this.accelResetOnDirectionChange : this.consecIncrSmallCount > 0) && this.lastIncrSmallDirection !== direction) {
          this.consecIncrSmallCount = 0;
        }
        if (!useLargeIncrement) {
          this.consecIncrSmallCount++;
          this.lastIncrSmallDirection = direction;
          this.lastIncrSmallInputTime = time;
        }
        isAccelActive = this.consecIncrSmallCount >= this.accelInputCountThreshold;
        if (isAccelActive) {
          useLargeIncrement = true;
        }
      }
      if (direction !== 0) {
        this.changeSelectedAltitude(startValue, direction, useLargeIncrement);
      }
    }
    setSelectedAltitude(altitudeFeet) {
      var _a, _b;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min2, max2, unit;
      if (isMetric) {
        min2 = this.minValueMetric;
        max2 = this.maxValueMetric;
        unit = UnitType.METER;
      } else {
        min2 = this.minValue;
        max2 = this.maxValue;
        unit = UnitType.FOOT;
      }
      const valueToSet = UnitType.FOOT.convertFrom(MathUtils2.clamp(UnitType.FOOT.convertTo(altitudeFeet, unit), min2, max2), unit);
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
      }
    }
    changeSelectedAltitude(startValue, direction, useLargeIncrement = false) {
      var _a, _b;
      const roundFunc = direction === 1 ? Math.floor : Math.ceil;
      const isMetric = (_b = (_a = this.altimeterMetricSetting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : false;
      let min2, max2, incrSmall, incrLarge, units, lockAlt;
      if (isMetric) {
        min2 = this.minValueMetric;
        max2 = this.maxValueMetric;
        incrSmall = this.incrSmallMetric;
        incrLarge = this.incrLargeMetric;
        units = UnitType.METER;
        lockAlt = this.lockAltToStepOnIncrMetric;
      } else {
        min2 = this.minValue;
        max2 = this.maxValue;
        incrSmall = this.incrSmall;
        incrLarge = this.incrLarge;
        units = UnitType.FOOT;
        lockAlt = this.lockAltToStepOnIncr;
      }
      const startValueConverted = Math.round(UnitType.FOOT.convertTo(startValue, units));
      useLargeIncrement && (useLargeIncrement = !lockAlt || startValueConverted % incrSmall === 0);
      let valueToSet = UnitType.FOOT.convertFrom(Utils.Clamp((lockAlt ? roundFunc(startValueConverted / incrSmall) * incrSmall : startValueConverted) + direction * (useLargeIncrement ? incrLarge : incrSmall), min2, max2), units);
      if (this.stops.length > 0) {
        let nextStopIndex = this.stops.matchIndex(startValue);
        if (direction === 1) {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 1;
          } else {
            nextStopIndex++;
          }
        } else {
          if (nextStopIndex < 0) {
            nextStopIndex = -nextStopIndex - 2;
          } else {
            nextStopIndex--;
          }
        }
        const nextStop = this.stops.peek(nextStopIndex);
        if (nextStop !== void 0 && Math.abs(valueToSet - startValue) > Math.abs(nextStop - startValue)) {
          valueToSet = nextStop;
        }
      }
      if (valueToSet !== SimVar.GetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet)) {
        SimVar.SetSimVarValue(this.altitudeHoldSlotSimVar, SimVarValueType.Feet, valueToSet);
        if (this.transformSetToIncDec) {
          this.isLocked = true;
          this.lockDebounceTimer.schedule(() => {
            this.isLocked = false;
          }, 250);
        }
      }
    }
    passThroughKeyEvent(key, index, value) {
      index = Math.max(1, index);
      const currentValue = SimVar.GetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet);
      let valueToSet = currentValue;
      switch (key) {
        case "AP_ALT_VAR_SET_ENGLISH":
        case "AP_ALT_VAR_SET_METRIC":
          if (value !== void 0) {
            valueToSet = value;
          }
          break;
        case "AP_ALT_VAR_INC":
          valueToSet += value === 0 || value === void 0 ? 100 : value;
          break;
        case "AP_ALT_VAR_DEC":
          valueToSet -= value === 0 || value === void 0 ? 100 : value;
          break;
      }
      SimVar.SetSimVarValue(`AUTOPILOT ALTITUDE LOCK VAR:${index}`, SimVarValueType.Feet, valueToSet);
    }
  };
  AltitudeSelectManager.CONSECUTIVE_INPUT_PERIOD = 300;
  var APModeType;
  (function(APModeType2) {
    APModeType2[APModeType2["LATERAL"] = 0] = "LATERAL";
    APModeType2[APModeType2["VERTICAL"] = 1] = "VERTICAL";
    APModeType2[APModeType2["APPROACH"] = 2] = "APPROACH";
  })(APModeType || (APModeType = {}));
  var AutothrottleTargetMode;
  (function(AutothrottleTargetMode2) {
    AutothrottleTargetMode2["None"] = "None";
    AutothrottleTargetMode2["Speed"] = "Speed";
    AutothrottleTargetMode2["Power"] = "Power";
    AutothrottleTargetMode2["ThrottlePos"] = "ThrottlePos";
  })(AutothrottleTargetMode || (AutothrottleTargetMode = {}));
  var AbstractAutothrottle = class {
    constructor(bus, airspeedIndex, throttleInfos, options, throttleLeverManager) {
      var _a, _b, _c, _d, _e, _f;
      this.bus = bus;
      this.publisher = this.bus.getPublisher();
      this.isOverspeedProtActive = Subject.create(false);
      this.isUnderspeedProtActive = Subject.create(false);
      this.isOverpowerProtActive = Subject.create(false);
      this.targetMode = Subject.create(AutothrottleTargetMode.None);
      this.selectedSpeedIsMach = Subject.create(false);
      this.selectedIas = Subject.create(0);
      this.selectedMach = Subject.create(0);
      this.selectedPower = Subject.create(0);
      this.selectedThrottlePos = Subject.create(0);
      this.maxIas = Subject.create(0);
      this.minIas = Subject.create(0);
      this.maxMach = Subject.create(0);
      this.minMach = Subject.create(0);
      this.maxPower = Subject.create(0);
      this.maxThrottlePos = Subject.create(1);
      this.minThrottlePos = Subject.create(0);
      this.lastSmoothedIas = void 0;
      this.realTime = ConsumerSubject.create(this.bus.getSubscriber().on("realTime"), 0);
      this.updateTimer = null;
      this.lastUpdateTime = 0;
      this.updateHandler = this.update.bind(this);
      this.speedCommand = {
        selectedSpeedPowerTarget: void 0,
        overspeedProtPowerTarget: void 0,
        underspeedProtPowerTarget: void 0,
        isOverspeed: false,
        isUnderspeed: false
      };
      this.powerCommand = {
        speed: void 0,
        targetPos: void 0,
        isOverspeedProtEngaged: false,
        isUnderspeedProtEngaged: false,
        isOverpowerProtEngaged: false
      };
      this.isAlive = true;
      this.airspeedIndex = SubscribableUtils.toSubscribable(airspeedIndex, true);
      this.airspeedIndex.sub((index) => {
        this.airspeedSimVar = `AIRSPEED INDICATED:${index}`;
      }, true);
      this.powerLookahead = SubscribableUtils.toSubscribable(options.powerLookahead, true);
      this.throttles = throttleInfos.map((info) => {
        return this.createThrottle(bus, info, options.servoSpeed, options.powerSmoothingConstant, this.powerLookahead, throttleLeverManager);
      });
      this.machToKiasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.iasLookahead = SubscribableUtils.toSubscribable(options.speedLookahead, true);
      this.iasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lookaheadIasSmoother = new ExpSmoother(options.speedSmoothingConstant);
      this.lastIasLookahead = this.iasLookahead.get();
      this.selectedSpeedPid = AbstractAutothrottle.createPidFromParams(options.speedTargetPid);
      this.overspeedPid = AbstractAutothrottle.createPidFromParams((_a = options.overspeedPid) !== null && _a !== void 0 ? _a : options.speedTargetPid);
      this.underspeedPid = AbstractAutothrottle.createPidFromParams((_b = options.underspeedPid) !== null && _b !== void 0 ? _b : options.speedTargetPid);
      this.selectedPowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid)
      };
      this.overpowerPids = {
        [1]: AbstractAutothrottle.createPidFromParams((_c = options.overpowerPid) !== null && _c !== void 0 ? _c : options.powerTargetPid),
        [2]: AbstractAutothrottle.createPidFromParams((_d = options.overpowerPid) !== null && _d !== void 0 ? _d : options.powerTargetPid),
        [3]: AbstractAutothrottle.createPidFromParams((_e = options.overpowerPid) !== null && _e !== void 0 ? _e : options.powerTargetPid),
        [4]: AbstractAutothrottle.createPidFromParams((_f = options.overpowerPid) !== null && _f !== void 0 ? _f : options.powerTargetPid)
      };
      this.selectedSpeedPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.overspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.underspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
      this.hysteresis = Math.max(0, options.hysteresis);
      this.hysteresisRecord = {
        [1]: 0,
        [2]: 0,
        [3]: 0,
        [4]: 0
      };
      this.publisher.pub("at_master_is_active", false, true, true);
      this.isOverspeedProtActive.sub((val) => this.publisher.pub("at_overspeed_prot_is_active", val, true, true), true);
      this.isUnderspeedProtActive.sub((val) => this.publisher.pub("at_underspeed_prot_is_active", val, true, true), true);
      this.isOverpowerProtActive.sub((val) => this.publisher.pub("at_overpower_prot_is_active", val, true, true), true);
      this.targetMode.sub((val) => this.publisher.pub("at_target_mode", val, true, true), true);
      this.selectedIas.sub((val) => this.publisher.pub("at_selected_ias", val, true, true), true);
      this.selectedMach.sub((val) => this.publisher.pub("at_selected_mach", val, true, true), true);
      this.selectedSpeedIsMach.sub((val) => this.publisher.pub("at_selected_speed_is_mach", val, true, true), true);
      this.selectedPower.sub((val) => this.publisher.pub("at_selected_power", val, true, true), true);
      this.selectedThrottlePos.sub((val) => this.publisher.pub("at_selected_throttle_pos", val, true, true), true);
      this.maxIas.sub((val) => this.publisher.pub("at_max_ias", val, true, true), true);
      this.maxMach.sub((val) => this.publisher.pub("at_max_mach", val, true, true), true);
      this.minIas.sub((val) => this.publisher.pub("at_min_ias", val, true, true), true);
      this.minMach.sub((val) => this.publisher.pub("at_min_mach", val, true, true), true);
      this.maxPower.sub((val) => this.publisher.pub("at_max_power", val, true, true), true);
      this.maxThrottlePos.sub((val) => this.publisher.pub("at_max_throttle_pos", val, true, true), true);
      this.minThrottlePos.sub((val) => this.publisher.pub("at_min_throttle_pos", val, true, true), true);
    }
    setOverspeedProtActive(val) {
      this.isOverspeedProtActive.set(val);
    }
    setUnderspeedProtActive(val) {
      this.isUnderspeedProtActive.set(val);
    }
    setOverpowerProtActive(val) {
      this.isOverpowerProtActive.set(val);
    }
    setTargetMode(mode) {
      this.targetMode.set(mode);
    }
    setSelectedSpeedIsMach(val) {
      this.selectedSpeedIsMach.set(val);
    }
    setSelectedIas(ias) {
      this.selectedIas.set(ias);
    }
    setSelectedMach(mach) {
      this.selectedMach.set(mach);
    }
    setSelectedPower(power) {
      this.selectedPower.set(power);
    }
    setSelectedThrottlePos(pos) {
      this.selectedThrottlePos.set(pos);
    }
    setMaxIas(ias) {
      this.maxIas.set(ias);
    }
    setMinIas(ias) {
      this.minIas.set(ias);
    }
    setMaxMach(mach) {
      this.maxMach.set(mach);
    }
    setMinMach(mach) {
      this.minMach.set(mach);
    }
    setMaxPower(power) {
      this.maxPower.set(power);
    }
    setMaxThrottlePos(pos) {
      this.maxThrottlePos.set(pos);
    }
    setMinThrottlePos(pos) {
      this.minThrottlePos.set(pos);
    }
    setServoActive(index, active) {
      const throttle = this.throttles.find((query) => query.index === index);
      if (throttle !== void 0) {
        throttle.isServoActive = active;
      }
    }
    start(frequency) {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot start a dead autothrottle");
      }
      this.stop();
      this.publisher.pub("at_master_is_active", true, true, true);
      this.updateTimer = setInterval(this.updateHandler, 1e3 / frequency);
    }
    stop() {
      if (!this.isAlive) {
        throw new Error("AbstractAutothrottle: cannot stop a dead autothrottle");
      }
      if (this.updateTimer === null) {
        return;
      }
      clearInterval(this.updateTimer);
      this.updateTimer = null;
      this.machToKiasSmoother.reset();
      this.iasSmoother.reset();
      this.lookaheadIasSmoother.reset();
      this.lastSmoothedIas = void 0;
      this.selectedSpeedPid.reset();
      this.overspeedPid.reset();
      this.underspeedPid.reset();
      this.selectedSpeedPowerTargetSmoother.reset();
      this.overspeedProtPowerTargetSmoother.reset();
      this.underspeedProtPowerTargetSmoother.reset();
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].resetPowerSmoothing();
      }
      for (const index of AbstractAutothrottle.ALL_THROTTLE_INDEXES) {
        this.selectedPowerPids[index].reset();
        this.overpowerPids[index].reset();
        this.hysteresisRecord[index] = 0;
      }
      this.publisher.pub("at_master_is_active", false, true, true);
    }
    update() {
      const realTime = Date.now();
      const dt = (realTime - this.lastUpdateTime) / 1e3;
      if (dt <= 0) {
        return;
      }
      this.lastUpdateTime = realTime;
      if (realTime - this.realTime.get() >= 1e3) {
        return;
      }
      for (let i = 0; i < this.throttles.length; i++) {
        this.throttles[i].update(dt);
      }
      const targetMode = this.targetMode.get();
      const speedCommand = this.calculateSpeedTargetPower(dt, this.speedCommand);
      const isOverpowerProtActive = this.isOverpowerProtActive.get();
      const isPowerTargetActive = targetMode === AutothrottleTargetMode.Power;
      const isThrottlePosTargetActive = targetMode === AutothrottleTargetMode.ThrottlePos;
      const minThrottlePos = this.minThrottlePos.get();
      const maxThrottlePos = this.maxThrottlePos.get();
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          const powerCommand = this.calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, this.powerCommand);
          let targetPos = powerCommand.targetPos;
          let speed = powerCommand.speed;
          const isThrottlePosOob = throttle.normPosition < minThrottlePos || throttle.normPosition > maxThrottlePos;
          const isTargetPosOob = targetPos !== void 0 && (targetPos < minThrottlePos || targetPos > maxThrottlePos);
          if (isTargetPosOob) {
            targetPos = MathUtils2.clamp(targetPos, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          } else if (isThrottlePosOob && targetPos === void 0) {
            targetPos = MathUtils2.clamp(throttle.normPosition, minThrottlePos, maxThrottlePos);
            speed = targetPos - throttle.normPosition;
          }
          if (targetPos !== void 0 && speed !== void 0) {
            const lastCommandedSpeed = this.hysteresisRecord[throttle.index];
            if (isThrottlePosOob || lastCommandedSpeed === 0 || Math.sign(lastCommandedSpeed) === Math.sign(speed) || Math.abs(speed) > this.hysteresis) {
              throttle.drive(targetPos, dt);
              this.hysteresisRecord[throttle.index] = speed;
            }
          } else {
            this.hysteresisRecord[throttle.index] = 0;
          }
        } else {
          this.selectedPowerPids[throttle.index].reset();
          this.overpowerPids[throttle.index].reset();
          this.hysteresisRecord[throttle.index] = 0;
        }
      }
    }
    calculateSpeedTargetPower(dt, out) {
      out.selectedSpeedPowerTarget = void 0;
      out.overspeedProtPowerTarget = void 0;
      out.underspeedProtPowerTarget = void 0;
      out.isOverspeed = false;
      out.isUnderspeed = false;
      const ias = SimVar.GetSimVarValue(this.airspeedSimVar, SimVarValueType.Knots);
      const mach = SimVar.GetSimVarValue("AIRSPEED MACH", SimVarValueType.Number);
      const currentMachToKias = ias > 1 && mach > 0 ? ias / mach : Simplane.getMachToKias(1);
      const machToKias = this.machToKiasSmoother.next(isFinite(currentMachToKias) ? currentMachToKias : 1, dt);
      const lookahead = Math.max(0, this.iasLookahead.get());
      const smoothedIas = this.iasSmoother.next(ias, dt);
      if (lookahead !== this.lastIasLookahead) {
        this.lookaheadIasSmoother.reset();
        this.lastIasLookahead = lookahead;
      }
      let effectiveIas;
      if (lookahead > 0 && this.lastSmoothedIas !== void 0) {
        const delta = smoothedIas - this.lastSmoothedIas;
        const last = this.lookaheadIasSmoother.last();
        effectiveIas = last === null || isFinite(last) ? this.lookaheadIasSmoother.next(ias + delta * lookahead / dt, dt) : this.lookaheadIasSmoother.reset(ias + delta * lookahead / dt);
      } else {
        effectiveIas = smoothedIas;
      }
      this.lastSmoothedIas = smoothedIas;
      const isTargetSpeed = this.targetMode.get() === AutothrottleTargetMode.Speed;
      const isOverspeedProtActive = this.isOverspeedProtActive.get();
      const isUnderspeedProtActive = this.isUnderspeedProtActive.get();
      let overspeedProtDelta;
      let underspeedProtDelta;
      let selectedSpeedDelta;
      if (isOverspeedProtActive) {
        const maxIas = Math.min(this.maxMach.get() * machToKias, this.maxIas.get());
        overspeedProtDelta = this.overspeedPid.getOutput(dt, maxIas - effectiveIas);
        out.isOverspeed = effectiveIas > maxIas;
      } else {
        this.overspeedPid.reset();
      }
      if (isUnderspeedProtActive) {
        const minIas = Math.max(this.minMach.get() * machToKias, this.minIas.get());
        underspeedProtDelta = this.underspeedPid.getOutput(dt, minIas - effectiveIas);
        out.isUnderspeed = effectiveIas < minIas;
      } else {
        this.underspeedPid.reset();
      }
      if (isTargetSpeed) {
        const targetIas = this.selectedSpeedIsMach.get() ? this.selectedMach.get() * machToKias : this.selectedIas.get();
        selectedSpeedDelta = this.selectedSpeedPid.getOutput(dt, targetIas - effectiveIas);
      } else {
        this.selectedSpeedPid.reset();
      }
      let throttlePowerSum = 0;
      let throttlePowerCount = 0;
      for (let i = 0; i < this.throttles.length; i++) {
        const throttle = this.throttles[i];
        if (throttle.isServoActive) {
          throttlePowerSum += throttle.effectivePower;
          throttlePowerCount++;
        }
      }
      if (throttlePowerCount === 0) {
        this.overspeedProtPowerTargetSmoother.reset();
        this.underspeedProtPowerTargetSmoother.reset();
        this.selectedSpeedPowerTargetSmoother.reset();
        return out;
      }
      if (selectedSpeedDelta !== void 0) {
        out.selectedSpeedPowerTarget = this.selectedSpeedPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + selectedSpeedDelta, dt);
      } else {
        this.selectedSpeedPowerTargetSmoother.reset();
      }
      if (overspeedProtDelta !== void 0) {
        out.overspeedProtPowerTarget = this.overspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + overspeedProtDelta, dt);
      } else {
        this.overspeedProtPowerTargetSmoother.reset();
      }
      if (underspeedProtDelta !== void 0) {
        out.underspeedProtPowerTarget = this.underspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + underspeedProtDelta, dt);
      } else {
        this.underspeedProtPowerTargetSmoother.reset();
      }
      return out;
    }
    calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, out) {
      out.speed = void 0;
      out.targetPos = void 0;
      out.isOverspeedProtEngaged = false;
      out.isUnderspeedProtEngaged = false;
      out.isOverpowerProtEngaged = false;
      const targetPid = this.selectedPowerPids[throttle.index];
      const overpowerPid = this.overpowerPids[throttle.index];
      const power = throttle.power;
      const effectivePower = throttle.effectivePower;
      let overpowerProtDelta;
      let isOverpower = false;
      if (isOverpowerProtActive) {
        const maxPower = this.maxPower.get();
        overpowerProtDelta = overpowerPid.getOutput(dt, maxPower - effectivePower);
        isOverpower = power > maxPower;
      } else {
        overpowerPid.reset();
      }
      let targetDelta;
      let delta;
      let isUsingOverspeedProtCommand = false;
      let isUsingUnderspeedProtCommand = false;
      let isUsingOverpowerProtCommand = false;
      let powerTarget;
      if (isPowerTargetActive) {
        powerTarget = this.selectedPower.get();
      } else {
        powerTarget = speedCommand.selectedSpeedPowerTarget;
      }
      if (powerTarget === void 0) {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isOverspeed && speedCommand.overspeedProtPowerTarget < effectivePower)) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && (isThrottlePosTargetActive || speedCommand.isUnderspeed && speedCommand.underspeedProtPowerTarget > effectivePower)) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      } else {
        if (speedCommand.overspeedProtPowerTarget !== void 0 && speedCommand.overspeedProtPowerTarget < powerTarget) {
          powerTarget = speedCommand.overspeedProtPowerTarget;
          isUsingOverspeedProtCommand = true;
        } else if (speedCommand.underspeedProtPowerTarget !== void 0 && speedCommand.underspeedProtPowerTarget > powerTarget) {
          powerTarget = speedCommand.underspeedProtPowerTarget;
          isUsingUnderspeedProtCommand = true;
        }
      }
      if (powerTarget !== void 0) {
        targetDelta = targetPid.getOutput(dt, powerTarget - effectivePower);
      } else {
        targetPid.reset();
      }
      if (targetDelta === void 0) {
        if (overpowerProtDelta !== void 0 && (isThrottlePosTargetActive || isOverpower && overpowerProtDelta < 0)) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        }
      } else {
        if (overpowerProtDelta !== void 0 && overpowerProtDelta < targetDelta) {
          delta = overpowerProtDelta;
          isUsingOverpowerProtCommand = true;
        } else {
          delta = targetDelta;
        }
      }
      if (isThrottlePosTargetActive) {
        const selectedTarget = this.selectedThrottlePos.get();
        const selectedTargetDelta = MathUtils2.clamp((selectedTarget - throttle.normPosition) / dt, -throttle.servoSpeed, throttle.servoSpeed);
        if (delta === void 0 || (isUsingOverspeedProtCommand || isUsingOverpowerProtCommand) && selectedTargetDelta < delta || isUsingUnderspeedProtCommand && selectedTargetDelta > delta) {
          delta = selectedTargetDelta;
          isUsingOverspeedProtCommand = false;
          isUsingUnderspeedProtCommand = false;
          isUsingOverpowerProtCommand = false;
        }
      }
      if (delta === void 0) {
        return out;
      }
      out.speed = delta;
      out.targetPos = throttle.normPosition + delta * dt;
      out.isOverspeedProtEngaged = isUsingOverspeedProtCommand;
      out.isUnderspeedProtEngaged = isUsingUnderspeedProtCommand;
      out.isOverpowerProtEngaged = isUsingOverpowerProtCommand;
      return out;
    }
    destroy() {
      this.isAlive = false;
      this.stop();
      this.realTime.destroy();
      this.throttles.forEach((throttle) => {
        throttle.destroy();
      });
    }
    static createPidFromParams(params) {
      return new PidController(params.kP, params.kI, params.kD, params.maxOut, params.minOut, params.maxI, params.minI);
    }
  };
  AbstractAutothrottle.ALL_THROTTLE_INDEXES = [1, 2, 3, 4];
  var AutothrottleThrottle = class {
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerLookahead, throttleLeverManager) {
      this.servoSpeed = servoSpeed;
      this.powerLookahead = powerLookahead;
      this._position = 0;
      this._power = 0;
      this._effectivePower = 0;
      this._isServoActive = Subject.create(false);
      this.lastPowerLookahead = this.powerLookahead.get();
      this.lastSmoothedPower = void 0;
      this.initKeyManager(bus);
      ({ index: this.index, idlePosition: this.idlePosition, maxThrustPosition: this.maxThrustPosition } = info);
      if (info.isVirtual) {
        this.virtualPos = ConsumerSubject.create(bus.getSubscriber().on(`v_throttle_lever_pos_${this.index}`), 0), this.getPosition = () => {
          return this.virtualPos.get();
        };
      } else {
        this.throttlePosSimVar = `GENERAL ENG THROTTLE LEVER POSITION:${this.index}`;
        this.getPosition = () => {
          return SimVar.GetSimVarValue(this.throttlePosSimVar, SimVarValueType.Percent) / 100;
        };
      }
      this.normRange = this.maxThrustPosition - this.idlePosition;
      this.throttleSetKVar = `THROTTLE${this.index}_SET`;
      this.throttleLeverManager = info.isVirtual ? throttleLeverManager : void 0;
      const isServoActiveTopic = `at_servo_${this.index}_is_active`;
      this._isServoActive.sub((val) => {
        bus.getPublisher().pub(isServoActiveTopic, val, true, true);
      });
      this.powerSmoother = new ExpSmoother(powerSmoothingConstant);
      this.lookaheadPowerSmoother = new ExpSmoother(powerSmoothingConstant);
    }
    get position() {
      return this._position;
    }
    get normPosition() {
      return (this._position - this.idlePosition) / this.normRange;
    }
    get power() {
      return this._power;
    }
    get effectivePower() {
      return this._effectivePower;
    }
    get isServoActive() {
      return this._isServoActive.get();
    }
    set isServoActive(val) {
      this._isServoActive.set(val);
    }
    async initKeyManager(bus) {
      this.keyEventManager = await KeyEventManager.getManager(bus);
    }
    update(dt) {
      this._position = this.getPosition();
      this._power = this.getPower();
      const lookahead = Math.max(0, this.powerLookahead.get());
      const smoothedPower = this.powerSmoother.next(this._power, dt);
      if (lookahead !== this.lastPowerLookahead) {
        this.lookaheadPowerSmoother.reset();
        this.lastPowerLookahead = lookahead;
      }
      if (lookahead > 0 && this.lastSmoothedPower !== void 0) {
        const delta = smoothedPower - this.lastSmoothedPower;
        this._effectivePower = this.lookaheadPowerSmoother.next(this._power + delta * lookahead / dt, dt);
      } else {
        this._effectivePower = smoothedPower;
      }
      this.lastSmoothedPower = smoothedPower;
    }
    drive(targetNormPos, dt) {
      var _a;
      const current = this.normPosition;
      const delta = targetNormPos - current;
      if (delta === 0) {
        return;
      }
      const deltaSign = Math.sign(delta);
      const toDrive = Math.min(dt * this.servoSpeed, (targetNormPos - current) * deltaSign) * deltaSign;
      const finalPos = this.idlePosition + (current + toDrive) * this.normRange;
      if (Math.abs(finalPos - this._position) < 0.5 / AutothrottleThrottle.RAW_AXIS_MAX) {
        return;
      }
      if (this.throttleLeverManager !== void 0) {
        this.throttleLeverManager.setThrottleLeverPosRaw(this.index, finalPos * AutothrottleThrottle.RAW_AXIS_MAX);
      } else {
        (_a = this.keyEventManager) === null || _a === void 0 ? void 0 : _a.triggerKey(this.throttleSetKVar, false, Math.round(finalPos * AutothrottleThrottle.RAW_AXIS_MAX));
      }
    }
    resetPowerSmoothing() {
      this.powerSmoother.reset();
      this.lookaheadPowerSmoother.reset();
      this.lastSmoothedPower = void 0;
    }
    destroy() {
      var _a;
      (_a = this.virtualPos) === null || _a === void 0 ? void 0 : _a.destroy();
    }
  };
  AutothrottleThrottle.RAW_AXIS_MAX = 16384;
  var CasAlertTransporter = class {
    constructor(bus, uuid, priority, suffix) {
      this.bus = bus;
      this.uuid = uuid;
      this.priority = priority;
      this.suffix = suffix;
      this.currentValue = false;
      this.subs = [];
      this.updateEntries = [];
      this.isAlive = true;
      this.isPaused = false;
    }
    set(active) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot change an alert with a dead transporter");
      }
      if (this.currentValue !== active) {
        if (active) {
          this.bus.getPublisher().pub("cas_activate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        } else {
          this.bus.getPublisher().pub("cas_deactivate_alert", { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
        }
        this.currentValue = active;
      }
    }
    bind(toWatch, predicate) {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      this.subs.push(toWatch.sub((v) => this.set(predicate(v)), true, this.isPaused));
      return this;
    }
    bindUpdate(predicate) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: false,
        func: (deltaTime) => this.set(predicate(deltaTime))
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    bindStateUpdate(predicate, state) {
      var _a;
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot bind an alert state using a dead transporter");
      }
      const entry = {
        isPaused: this.isPaused,
        hasState: true,
        func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
        state
      };
      this.updateEntries.push(entry);
      this.initUpdateFuncs();
      (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
      return this;
    }
    resume() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot resume a dead transporter");
      }
      if (!this.isPaused) {
        return this;
      }
      this.isPaused = false;
      this.subs.forEach((sub2) => {
        sub2.resume(true);
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = false;
      });
      return this;
    }
    pause() {
      if (!this.isAlive) {
        throw new Error("CasAlertTransporter: cannot pause a dead transporter");
      }
      if (this.isPaused) {
        return this;
      }
      this.isPaused = true;
      this.subs.forEach((sub2) => {
        sub2.pause();
      });
      if (CasAlertTransporter.updateEntries) {
        this.updateEntries.forEach((entry) => {
          const index = CasAlertTransporter.updateEntries.indexOf(entry);
          if (index >= 0) {
            CasAlertTransporter.updateEntries.splice(index, 1);
          }
        });
      }
      return this;
    }
    destroy() {
      this.isAlive = false;
      this.subs.forEach((sub2) => {
        sub2.destroy();
      });
      this.updateEntries.forEach((entry) => {
        entry.isPaused = true;
      });
    }
    static create(bus, uuid, priority, suffix) {
      return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    initUpdateFuncs() {
      if (CasAlertTransporter.updateEntries === void 0) {
        CasAlertTransporter.updateEntries = [];
        this.bus.getSubscriber().on("simTime").handle((timestamp) => {
          if (CasAlertTransporter.previousTimestamp === -1) {
            CasAlertTransporter.previousTimestamp = timestamp;
          }
          const deltaTime = MathUtils2.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 1e4);
          if (CasAlertTransporter.updateEntries !== void 0) {
            for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
              const entry = CasAlertTransporter.updateEntries[i];
              if (entry.isPaused) {
                continue;
              }
              if (entry.hasState) {
                entry.func(deltaTime, entry.state);
              } else {
                entry.func(deltaTime);
              }
            }
          }
          CasAlertTransporter.previousTimestamp = timestamp;
        });
      }
    }
  };
  CasAlertTransporter.previousTimestamp = -1;
  var ThrottleLeverManager = class {
    constructor(bus, onInitCallback, throttleLeverHandler) {
      this.bus = bus;
      this.throttleLeverHandler = throttleLeverHandler;
      this.publisher = this.bus.getPublisher();
      this.throttleLevers = ArrayUtils.create(ThrottleLeverManager.THROTTLE_COUNT, (index) => {
        return {
          index: index + 1,
          topic: `v_throttle_lever_pos_${index + 1}`,
          rawPosition: 0
        };
      });
      const sub2 = bus.getSubscriber();
      const virtualPositions = this.throttleLevers.map((lever) => {
        return ConsumerValue.create(sub2.on(lever.topic), NaN);
      });
      KeyEventManager.getManager(bus).then((manager) => {
        for (let i = 0; i < this.throttleLevers.length; i++) {
          const lever = this.throttleLevers[i];
          const virtualPosition = virtualPositions[i].get();
          const initialPosition = isNaN(virtualPosition) ? MathUtils2.clamp(SimVar.GetSimVarValue(`GENERAL ENG THROTTLE LEVER POSITION:${lever.index}`, "Percent") / 100, 0, 1) : virtualPosition;
          virtualPositions[i].destroy();
          this.setRawThrottleLeverPosition(initialPosition * ThrottleLeverManager.RAW_MAX, i + 1);
        }
        this.keyEventManager = manager;
        manager.interceptKey("AXIS_THROTTLE_SET", false);
        manager.interceptKey("AXIS_THROTTLE1_SET", false);
        manager.interceptKey("AXIS_THROTTLE2_SET", false);
        manager.interceptKey("AXIS_THROTTLE3_SET", false);
        manager.interceptKey("AXIS_THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE1_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE2_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE3_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE4_AXIS_SET_EX1", false);
        manager.interceptKey("THROTTLE_SET", false);
        manager.interceptKey("THROTTLE1_SET", false);
        manager.interceptKey("THROTTLE2_SET", false);
        manager.interceptKey("THROTTLE3_SET", false);
        manager.interceptKey("THROTTLE4_SET", false);
        manager.interceptKey("THROTTLE_FULL", false);
        manager.interceptKey("THROTTLE1_FULL", false);
        manager.interceptKey("THROTTLE2_FULL", false);
        manager.interceptKey("THROTTLE3_FULL", false);
        manager.interceptKey("THROTTLE4_FULL", false);
        manager.interceptKey("THROTTLE_INCR", false);
        manager.interceptKey("THROTTLE1_INCR", false);
        manager.interceptKey("THROTTLE2_INCR", false);
        manager.interceptKey("THROTTLE3_INCR", false);
        manager.interceptKey("THROTTLE4_INCR", false);
        manager.interceptKey("THROTTLE_DECR", false);
        manager.interceptKey("THROTTLE1_DECR", false);
        manager.interceptKey("THROTTLE2_DECR", false);
        manager.interceptKey("THROTTLE3_DECR", false);
        manager.interceptKey("THROTTLE4_DECR", false);
        manager.interceptKey("THROTTLE_CUT", false);
        manager.interceptKey("THROTTLE1_CUT", false);
        manager.interceptKey("THROTTLE2_CUT", false);
        manager.interceptKey("THROTTLE3_CUT", false);
        manager.interceptKey("THROTTLE4_CUT", false);
        manager.interceptKey("INCREASE_THROTTLE", false);
        manager.interceptKey("DECREASE_THROTTLE", false);
        manager.interceptKey("THROTTLE_10", false);
        manager.interceptKey("THROTTLE_20", false);
        manager.interceptKey("THROTTLE_30", false);
        manager.interceptKey("THROTTLE_40", false);
        manager.interceptKey("THROTTLE_50", false);
        manager.interceptKey("THROTTLE_60", false);
        manager.interceptKey("THROTTLE_70", false);
        manager.interceptKey("THROTTLE_80", false);
        manager.interceptKey("THROTTLE_90", false);
        sub2.on("key_intercept").handle(this.onKeyIntercepted.bind(this));
        onInitCallback && onInitCallback();
      });
    }
    setThrottleLeverPos(index, pos) {
      return this.setThrottleLeverPosRaw(index, pos * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    changeThrottleLeverPos(index, delta) {
      return this.changeThrottleLeverPosRaw(index, delta * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    setThrottleLeverPosRaw(index, pos) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.setRawThrottleLeverPosition(pos, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    changeThrottleLeverPosRaw(index, delta) {
      if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
        throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
      }
      this.changeRawThrottleLeverPosition(delta, index);
      return this.throttleLevers[index - 1].rawPosition;
    }
    onKeyIntercepted({ key, value0 }) {
      switch (key) {
        case "AXIS_THROTTLE_SET":
        case "THROTTLE_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, void 0, key);
          }
          break;
        case "AXIS_THROTTLE1_SET":
        case "THROTTLE1_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 1, key);
          }
          break;
        case "AXIS_THROTTLE2_SET":
        case "THROTTLE2_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 2, key);
          }
          break;
        case "AXIS_THROTTLE3_SET":
        case "THROTTLE3_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 3, key);
          }
          break;
        case "AXIS_THROTTLE4_SET":
        case "THROTTLE4_AXIS_SET_EX1":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 4, key);
          }
          break;
        case "THROTTLE_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, void 0, key);
          }
          break;
        case "THROTTLE1_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 1, key);
          }
          break;
        case "THROTTLE2_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 2, key);
          }
          break;
        case "THROTTLE3_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 3, key);
          }
          break;
        case "THROTTLE4_SET":
          if (value0 !== void 0) {
            this.setRawThrottleLeverPosition(value0, 4, key);
          }
          break;
        case "THROTTLE_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, void 0, key);
          break;
        case "THROTTLE1_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 1, key);
          break;
        case "THROTTLE2_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 2, key);
          break;
        case "THROTTLE3_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 3, key);
          break;
        case "THROTTLE4_FULL":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 4, key);
          break;
        case "THROTTLE_CUT":
          this.setRawThrottleLeverPosition(0, void 0, key);
          break;
        case "THROTTLE1_CUT":
          this.setRawThrottleLeverPosition(0, 1, key);
          break;
        case "THROTTLE2_CUT":
          this.setRawThrottleLeverPosition(0, 2, key);
          break;
        case "THROTTLE3_CUT":
          this.setRawThrottleLeverPosition(0, 3, key);
          break;
        case "THROTTLE4_CUT":
          this.setRawThrottleLeverPosition(0, 4, key);
          break;
        case "THROTTLE_INCR":
        case "INCREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_INCR":
          this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_DECR":
        case "DECREASE_THROTTLE":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, void 0, key);
          break;
        case "THROTTLE1_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 1, key);
          break;
        case "THROTTLE2_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 2, key);
          break;
        case "THROTTLE3_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 3, key);
          break;
        case "THROTTLE4_DECR":
          this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 4, key);
          break;
        case "THROTTLE_10":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.1, void 0, key);
          break;
        case "THROTTLE_20":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.2, void 0, key);
          break;
        case "THROTTLE_30":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.3, void 0, key);
          break;
        case "THROTTLE_40":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.4, void 0, key);
          break;
        case "THROTTLE_50":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.5, void 0, key);
          break;
        case "THROTTLE_60":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.6, void 0, key);
          break;
        case "THROTTLE_70":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.7, void 0, key);
          break;
        case "THROTTLE_80":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.8, void 0, key);
          break;
        case "THROTTLE_90":
          this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.9, void 0, key);
          break;
      }
    }
    setRawThrottleLeverPosition(rawPosition, index, keyEvent) {
      rawPosition = MathUtils2.clamp(Math.round(rawPosition), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        const lever = this.throttleLevers[i - 1];
        if (this.throttleLeverHandler) {
          rawPosition = MathUtils2.clamp(Math.round(this.throttleLeverHandler(lever.index, lever.rawPosition / ThrottleLeverManager.RAW_MAX, rawPosition / ThrottleLeverManager.RAW_MAX, keyEvent) * ThrottleLeverManager.RAW_MAX), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
        }
        if (rawPosition !== lever.rawPosition) {
          lever.rawPosition = rawPosition;
          this.publishThrottleLeverPosition(lever);
        }
      }
    }
    changeRawThrottleLeverPosition(delta, index, keyEvent) {
      const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
      for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
        this.setRawThrottleLeverPosition(this.throttleLevers[i - 1].rawPosition + delta, i, keyEvent);
      }
    }
    publishThrottleLeverPosition(lever) {
      this.publisher.pub(lever.topic, lever.rawPosition / ThrottleLeverManager.RAW_MAX, true, true);
    }
  };
  ThrottleLeverManager.THROTTLE_COUNT = 4;
  ThrottleLeverManager.RAW_MAX = 16384;
  ThrottleLeverManager.RAW_STEP = 256;
  var Binding = class {
    constructor(input, valueHandler) {
      this.input = input;
      this.valueHandler = valueHandler;
      this.canInitialNotify = false;
      if ("isConsumer" in this.input) {
        this.sub = this.input.handle((data) => this.valueHandler(data));
      } else {
        this.canInitialNotify = true;
        this.sub = this.input.sub((data) => this.valueHandler(data), this.canInitialNotify, true);
      }
    }
    get isPaused() {
      return this.sub.isPaused;
    }
    get isAlive() {
      return this.sub.isAlive;
    }
    pause() {
      this.sub.pause();
      return this;
    }
    resume() {
      this.sub.resume(true);
      return this;
    }
    destroy() {
      this.sub.destroy();
    }
  };
  var FmcComponent = class {
    constructor(page, options) {
      this.page = page;
      this.options = options;
    }
    invalidate() {
      this.page.invalidate();
    }
    async handleSelectKey(event) {
      var _a, _b;
      if (this.options.disabled) {
        return false;
      }
      if (event.isDelete) {
        if (this.options.onDelete) {
          const result = await this.options.onDelete();
          if (result === true || typeof result === "string") {
            if ((_a = this.options.clearScratchpadOnSelectedHandled) !== null && _a !== void 0 ? _a : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        }
      }
      if (this.options.onSelected) {
        try {
          const result = await this.options.onSelected(event.scratchpadContents);
          if (result === true || typeof result === "string") {
            if ((_b = this.options.clearScratchpadOnSelectedHandled) !== null && _b !== void 0 ? _b : true) {
              this.page.screen.clearScratchpad();
            }
            return result;
          }
        } catch (error) {
          return Promise.reject(error);
        }
      }
      return this.onHandleSelectKey(event);
    }
    getOptions() {
      return this.options;
    }
  };
  var FmcPageLifecyclePolicy;
  (function(FmcPageLifecyclePolicy2) {
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Singleton"] = 0] = "Singleton";
    FmcPageLifecyclePolicy2[FmcPageLifecyclePolicy2["Transient"] = 1] = "Transient";
  })(FmcPageLifecyclePolicy || (FmcPageLifecyclePolicy = {}));
  var AbstractFmcPage = class {
    constructor(bus, screen) {
      this.bus = bus;
      this.screen = screen;
      this.memorizedComponents = [];
      this.bindings = [];
      this.params = /* @__PURE__ */ new Map();
      this.isDirty = false;
      this.clockHandler = (d) => {
        if (this.isDirty) {
          this.isDirty = false;
          this.initialRender();
        }
      };
      this.isInitialized = false;
      this.currentOutput = [];
      this.screen = screen;
      this.clockConsumer = this.bus.getSubscriber().on("realTime").atFrequency(10, false);
    }
    init() {
      this.onInit();
      this.addBinding(new Binding(this.screen.currentSubpageIndex, () => this.invalidate()));
    }
    onInit() {
    }
    pause() {
      for (const binding of this.bindings) {
        binding.pause();
      }
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      this.onPause();
    }
    onPause() {
    }
    resume() {
      for (const binding of this.bindings) {
        binding.resume(true);
      }
      this.onResume();
      this.isDirty = true;
      this.clockConsumer.handle(this.clockHandler);
    }
    onResume() {
    }
    onPageButtonPressed() {
    }
    destroy() {
      this.isDirty = false;
      this.clockConsumer.off(this.clockHandler);
      for (const binding of this.bindings) {
        binding.destroy();
      }
      this.onDestroy();
    }
    onDestroy() {
    }
    invalidate() {
      this.isDirty = true;
    }
    initialRender() {
      if (!this.isInitialized) {
        return;
      }
      const templates = this.render();
      this.screen.currentSubpageCount.set(templates.length);
      const template = templates[this.screen.currentSubpageIndex.get() - 1];
      const render2 = [];
      this.memorizedComponents.length = 0;
      for (let i = 0; i < template.length; i++) {
        if (!render2[i]) {
          render2[i] = [];
        }
        const row = template[i];
        const renderRow = render2[i];
        for (let j = 0; j < row.length; j++) {
          const col = row[j];
          if (col instanceof FmcComponent) {
            if (!this.memorizedComponents[i]) {
              this.memorizedComponents[i] = [null, null, null];
            }
            this.memorizedComponents[i][j] = col;
            const componentRender = col.render();
            if (Array.isArray(componentRender)) {
              for (let k = 0; k < componentRender.length; k++) {
                const componentRenderRow = componentRender[k];
                for (let l = 0; l < componentRenderRow.length; l++) {
                  if (!render2[i + k]) {
                    render2[i + k] = [];
                  }
                  render2[i + k][l] = componentRenderRow[l];
                }
              }
            } else {
              renderRow[row.indexOf(col)] = componentRender;
            }
          } else {
            renderRow[j] = col;
          }
        }
      }
      this.currentOutput = render2;
      this.renderCallback(this.currentOutput, template, 0);
    }
    addBinding(binding) {
      this.bindings.push(binding);
    }
    async handleLineSelectKey(event) {
      var _a;
      const componentAtSk = (_a = this.memorizedComponents[event.row]) === null || _a === void 0 ? void 0 : _a[event.col];
      if (componentAtSk) {
        const selectKeyHandled = await componentAtSk.handleSelectKey(event);
        if (selectKeyHandled !== false) {
          return selectKeyHandled;
        }
      }
      const handledByPage = await this.onHandleSelectKey(event);
      if (!handledByPage) {
        return Promise.reject("KEY NOT ACTIVE");
      }
      return handledByPage;
    }
    async onHandleSelectKey(event) {
      return false;
    }
    async handleScrolling(event) {
      return this.onHandleScrolling(event);
    }
    async onHandleScrolling(event) {
      return false;
    }
  };
  AbstractFmcPage.lifecyclePolicy = FmcPageLifecyclePolicy.Singleton;
  var ImageCache = class {
    static addToCache(key, url) {
      if (this.cache[key] === void 0) {
        const img = new Image();
        img.src = url;
        this.cache[key] = img;
      }
    }
    static get(key) {
      return this.cache[key];
    }
  };
  ImageCache.cache = {};
  var DmsFormatter2 = class {
    static create(format4, unit, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format4, precision, unit);
      return (angle) => {
        if (isNaN(angle)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle, unit), "");
      };
    }
    static createForNumberUnit(format4, precision, nanString = "NaN") {
      const builder = DmsFormatter2.createBuilder(format4, precision.number, precision.unit);
      return (angle) => {
        if (angle.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(angle.number, angle.unit), "");
      };
    }
    static createBuilder(format4, precision, precisionUnit) {
      const split = format4.split(DmsFormatter2.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DmsFormatter2.FORMAT_REGEXP)) {
          return DmsFormatter2.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DmsFormatter2.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          posStringMatch,
          negStringMatch
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DmsFormatter2.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        unitMatch,
        leftOptionalMatch,
        rightMatch,
        rightForcedMatch,
        rightOptionalMatch
      ] = numericMatch;
      const unitInfo = DmsFormatter2.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (angle, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
      } : (angle, unit, epsilon) => {
        return (MathUtils2.round(unitInfo.unit.convertFrom(Math.abs(angle), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (angle, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(angle), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (angle, unit) => {
          const converted = convertFunc(angle, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (angle, unit) => {
          return formatLeftFunc(convertFunc(angle, unit, epsilon));
        };
      }
    }
  };
  DmsFormatter2.FORMAT_REGEXP = /({[^{}]*})/;
  DmsFormatter2.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DmsFormatter2.NUM_FRAGMENT_REGEXP = /^(([DMSdms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DmsFormatter2.NUM_FRAGMENT_UNIT_INFO = {
    ["d"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["m"]: { unit: UnitType.ARC_MIN, mod: 60 },
    ["s"]: { unit: UnitType.ARC_SEC, mod: 60 },
    ["D"]: { unit: UnitType.DEGREE, mod: Infinity },
    ["M"]: { unit: UnitType.ARC_MIN, mod: Infinity },
    ["S"]: { unit: UnitType.ARC_SEC, mod: Infinity }
  };
  var DurationFormatter = class {
    static create(format4, unit, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format4, precision, unit);
      return (duration) => {
        if (isNaN(duration)) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration, unit), "");
      };
    }
    static createForNumberUnit(format4, precision, nanString = "NaN") {
      const builder = DurationFormatter.createBuilder(format4, precision.number, precision.unit);
      return (duration) => {
        if (duration.isNaN()) {
          return nanString;
        }
        return builder.reduce((string, part) => string + part(duration.number, duration.unit), "");
      };
    }
    static createBuilder(format4, precision, precisionUnit) {
      const split = format4.split(DurationFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DurationFormatter.FORMAT_REGEXP)) {
          return DurationFormatter.parseFragment(string.substring(1, string.length - 1), precision, precisionUnit);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, precision, precisionUnit) {
      var _a, _b;
      const signMatch = fragment.match(DurationFormatter.SIGN_FRAGMENT_REGEX);
      if (signMatch) {
        const [
          ,
          posCharMatch,
          posStringMatch,
          negStringMatch
        ] = signMatch;
        const posSign = posCharMatch === "+" ? posStringMatch !== null && posStringMatch !== void 0 ? posStringMatch : "+" : "";
        const negSign = negStringMatch !== null && negStringMatch !== void 0 ? negStringMatch : "-";
        return (angle) => {
          return angle < 0 ? negSign : posSign;
        };
      }
      const numericMatch = fragment.match(DurationFormatter.NUM_FRAGMENT_REGEXP);
      if (!numericMatch) {
        return () => "";
      }
      const [
        ,
        leftMatch,
        unitMatch,
        leftOptionalMatch,
        rightMatch,
        rightForcedMatch,
        rightOptionalMatch
      ] = numericMatch;
      const unitInfo = DurationFormatter.NUM_FRAGMENT_UNIT_INFO[unitMatch];
      const pad = leftMatch.length;
      const dropZero = !!leftOptionalMatch;
      const step = precisionUnit.convertTo(precision, unitInfo.unit);
      const convertFunc = step <= 0 ? (duration, unit) => {
        return unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
      } : (duration, unit, epsilon) => {
        return (MathUtils2.round(unitInfo.unit.convertFrom(Math.abs(duration), unit), step) + epsilon) % unitInfo.mod;
      };
      const formatLeftFunc = dropZero ? (input) => {
        const rounded = Math.floor(input);
        return rounded === 0 ? "" : rounded.toString().padStart(pad, "0");
      } : (input) => Math.floor(input).toString().padStart(pad, "0");
      if (rightMatch) {
        if (rightMatch.length === 1) {
          return (duration, unit) => {
            const converted = unitInfo.unit.convertFrom(Math.abs(duration), unit) % unitInfo.mod;
            const decimal = converted % 1;
            return `${formatLeftFunc(converted)}${decimal.toString().substring(1)}`;
          };
        }
        const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
        const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
        const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
        const factor = Math.pow(10, totalDecimalPlaces);
        const epsilon = Math.min(step / 2, 1 / (2 * factor));
        return (duration, unit) => {
          const converted = convertFunc(duration, unit, epsilon);
          const decimal = converted % 1;
          const decimalRounded = Math.floor(decimal * factor) / factor;
          return `${formatLeftFunc(converted)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, "0")}`;
        };
      } else {
        const epsilon = Math.min(step / 2, 0.5);
        return (duration, unit) => {
          return formatLeftFunc(convertFunc(duration, unit, epsilon));
        };
      }
    }
  };
  DurationFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DurationFormatter.SIGN_FRAGMENT_REGEX = /^(?:(\+)(?:\[(.*)\])?)?-(?:\[(.*)\])?$/;
  DurationFormatter.NUM_FRAGMENT_REGEXP = /^(([HMShms])+)(\?)?(?:(\.(\2*)(?:\((\2+)\))?)?)$/;
  DurationFormatter.NUM_FRAGMENT_UNIT_INFO = {
    ["h"]: { unit: UnitType.HOUR, mod: Infinity },
    ["m"]: { unit: UnitType.MINUTE, mod: 60 },
    ["s"]: { unit: UnitType.SECOND, mod: 60 },
    ["H"]: { unit: UnitType.HOUR, mod: Infinity },
    ["M"]: { unit: UnitType.MINUTE, mod: Infinity },
    ["S"]: { unit: UnitType.SECOND, mod: Infinity }
  };
  DurationFormatter.NUM_FRAGMENT_ROUND_FUNCS = {
    ["+"]: Math.ceil,
    ["-"]: Math.floor,
    ["~"]: Math.round
  };
  var DateTimeFormatter = class {
    static create(format4, options) {
      const optsToUse = Object.assign({}, DateTimeFormatter.DEFAULT_OPTIONS, options);
      const builder = DateTimeFormatter.createBuilder(format4, optsToUse);
      const date = new Date();
      return (time) => {
        if (isNaN(time)) {
          return optsToUse.nanString;
        }
        date.setTime(time);
        return builder.reduce((string, part) => string + part(date), "");
      };
    }
    static createBuilder(format4, options) {
      const split = format4.split(DateTimeFormatter.FORMAT_REGEXP);
      return split.map((string) => {
        if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
          return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
        } else {
          return () => string;
        }
      });
    }
    static parseFragment(fragment, options) {
      const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
      if (match) {
        if (match[1]) {
          return DateTimeFormatter.parseNumFragment(match);
        } else if (match[4]) {
          return DateTimeFormatter.parseYearFragment(match);
        } else if (match[5]) {
          return DateTimeFormatter.parseMonthFragment(match, options);
        } else if (match[6]) {
          return DateTimeFormatter.parseDayFragment(match, options);
        } else if (match[7]) {
          return DateTimeFormatter.parseAMPMFragment(match);
        }
      }
      return () => "";
    }
    static parseNumFragment(match) {
      const numGetter = DateTimeFormatter.NUM_GETTERS[match[3]];
      const pad = match[2].length;
      return (date) => {
        return numGetter(date).toString().padStart(pad, "0");
      };
    }
    static parseYearFragment(match) {
      if (match[4].length === 2) {
        return (date) => (date.getUTCFullYear() % 100).toString();
      } else {
        return (date) => date.getUTCFullYear().toString();
      }
    }
    static parseMonthFragment(match, options) {
      const isUpperCase = match[5][0] === "M";
      if (match[5].length === 3) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => text[date.getUTCMonth()];
      } else if (match[5].length === 4) {
        const text = isUpperCase ? options.monthNamesShort.map((str) => str.toUpperCase()) : options.monthNamesShort;
        return (date) => {
          const month = date.getUTCMonth();
          return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.monthNames.map((str) => str.toUpperCase()) : options.monthNames;
        return (date) => text[date.getUTCMonth()];
      }
    }
    static parseDayFragment(match, options) {
      const isUpperCase = match[6][0] === "D";
      if (match[6] === "dy") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => text[date.getUTCDay()];
      } else if (match[6] === "dy.") {
        const text = isUpperCase ? options.dayNamesShort.map((str) => str.toUpperCase()) : options.dayNamesShort;
        return (date) => {
          const day = date.getUTCDay();
          return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? "" : "."}`;
        };
      } else {
        const text = isUpperCase ? options.dayNames.map((str) => str.toUpperCase()) : options.dayNames;
        return (date) => text[date.getUTCDay()];
      }
    }
    static parseAMPMFragment(match) {
      const isUpperCase = match[7][0] === "A";
      const usePeriod = match[7].length > 2;
      let text = usePeriod ? ["a.m.", "p.m."] : ["am", "pm"];
      if (isUpperCase) {
        text = text.map((str) => str.toUpperCase());
      }
      return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
  };
  DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
  DateTimeFormatter.FRAGMENT_REGEXP = /^(?:((([MdwHhms])+))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
  DateTimeFormatter.NUM_GETTERS = {
    ["s"]: (date) => date.getUTCSeconds(),
    ["m"]: (date) => date.getUTCMinutes(),
    ["h"]: (date) => date.getUTCHours() % 12,
    ["H"]: (date) => date.getUTCHours(),
    ["w"]: (date) => date.getUTCDay() + 1,
    ["d"]: (date) => date.getUTCDate(),
    ["M"]: (date) => date.getUTCMonth() + 1
  };
  DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    nanString: "NaN"
  };
  var UserSettingSaveManager = class {
    constructor(settings, bus) {
      this.autoSaveKeys = /* @__PURE__ */ new Set();
      this.isAlive = true;
      const subscriber = bus.getSubscriber();
      this.entries = Array.from(settings, (setting) => {
        const autoSaveDataStoreKeys = [];
        return {
          setting,
          subscription: subscriber.on(setting.definition.name).whenChanged().handle(this.onSettingChanged.bind(this, autoSaveDataStoreKeys), true),
          autoSaveDataStoreKeys
        };
      });
    }
    onSettingChanged(autoSaveDataStoreKeys, value) {
      const len = autoSaveDataStoreKeys.length;
      for (let i = 0; i < len; i++) {
        DataStore.set(autoSaveDataStoreKeys[i], value);
      }
    }
    load(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot load using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        const storedValue = DataStore.get(dataStoreKey);
        if (storedValue !== void 0) {
          entry.setting.value = storedValue;
        }
      }
    }
    save(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot save using a destroyed manager.");
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        const dataStoreKey = UserSettingSaveManager.getDataStoreKey(entry.setting, key);
        DataStore.set(dataStoreKey, entry.setting.value);
      }
    }
    startAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot start autosave using a destroyed manager.");
      }
      if (this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.push(UserSettingSaveManager.getDataStoreKey(entry.setting, key));
        if (entry.autoSaveDataStoreKeys.length === 1) {
          entry.subscription.resume();
        }
      }
    }
    stopAutoSave(key) {
      if (!this.isAlive) {
        throw new Error("UserSettingSaveManager: cannot stop autosave using a destroyed manager.");
      }
      if (!this.autoSaveKeys.has(key)) {
        return;
      }
      for (let i = 0; i < this.entries.length; i++) {
        const entry = this.entries[i];
        entry.autoSaveDataStoreKeys.splice(entry.autoSaveDataStoreKeys.indexOf(UserSettingSaveManager.getDataStoreKey(entry.setting, key)), 1);
        if (entry.autoSaveDataStoreKeys.length === 0) {
          entry.subscription.pause();
        }
      }
    }
    destroy() {
      const len = this.entries.length;
      for (let i = 0; i < len; i++) {
        this.entries[i].subscription.destroy();
      }
      this.entries.length = 0;
      this.isAlive = false;
    }
    static getDataStoreKey(setting, saveKey) {
      return `${UserSettingSaveManager.DATASTORE_PREFIX}.${saveKey}.${setting.definition.name}`;
    }
  };
  UserSettingSaveManager.DATASTORE_PREFIX = "persistent-setting";
  var AvionicsSystemState;
  (function(AvionicsSystemState2) {
    AvionicsSystemState2["Off"] = "Off";
    AvionicsSystemState2["Initializing"] = "Initializing";
    AvionicsSystemState2["On"] = "On";
    AvionicsSystemState2["Failed"] = "Failed";
  })(AvionicsSystemState || (AvionicsSystemState = {}));
  var FsBaseInstrument = class extends BaseInstrument {
    connectedCallback() {
      super.connectedCallback();
      this.fsInstrument = this.constructInstrument();
    }
    Update() {
      super.Update();
      if (this.fsInstrument) {
        this.fsInstrument.Update();
      }
    }
    onInteractionEvent(_args) {
      if (this.fsInstrument) {
        this.fsInstrument.onInteractionEvent(_args);
      }
    }
    onGameStateChanged(oldState, newState) {
      super.onGameStateChanged(oldState, newState);
      if (this.fsInstrument) {
        this.fsInstrument.onGameStateChanged(oldState, newState);
      }
    }
    onFlightStart() {
      super.onFlightStart();
      if (this.fsInstrument) {
        this.fsInstrument.onFlightStart();
      }
    }
    onSoundEnd(soundEventId) {
      super.onSoundEnd(soundEventId);
      if (this.fsInstrument) {
        this.fsInstrument.onSoundEnd(soundEventId);
      }
    }
    get isInteractive() {
      return false;
    }
  };

  // src/systems/fmgc/src/guidance/lnav/PseudoWaypoints.ts
  var CHECKPOINTS_TO_PUT_IN_MCDU = /* @__PURE__ */ new Set([
    "TopOfClimb" /* TopOfClimb */,
    "CrossingClimbSpeedLimit" /* CrossingClimbSpeedLimit */,
    "StepClimb" /* StepClimb */,
    "StepDescent" /* StepDescent */,
    "TopOfDescent" /* TopOfDescent */,
    "CrossingDescentSpeedLimit" /* CrossingDescentSpeedLimit */,
    "Decel" /* Decel */,
    "Flaps1" /* Flaps1 */,
    "Flaps2" /* Flaps2 */
  ]);
  var CHECKPOINTS_TO_DRAW_ON_ND = /* @__PURE__ */ new Set([
    "TopOfClimb" /* TopOfClimb */,
    "LevelOffForClimbConstraint" /* LevelOffForClimbConstraint */,
    "ContinueClimb" /* ContinueClimb */,
    "FcuAltitudeClimb" /* CrossingFcuAltitudeClimb */,
    "TopOfDescent" /* TopOfDescent */,
    "FcuAltitudeDescent" /* CrossingFcuAltitudeDescent */,
    "ContinueDescent" /* ContinueDescent */,
    "ContinueDescentArmed" /* ContinueDescentArmed */,
    "LevelOffForDescentConstraint" /* LevelOffForDescentConstraint */,
    "InterceptDescentProfileManaged" /* InterceptDescentProfileManaged */,
    "InterceptDescentProfileSelected" /* InterceptDescentProfileSelected */,
    "Decel" /* Decel */,
    "Flaps1" /* Flaps1 */,
    "Flaps2" /* Flaps2 */
  ]);
  var CHECKPOINT_REASONS_BEFORE_FCU_ALT_FOR_PWP = [
    "LevelOffForClimbConstraint" /* LevelOffForClimbConstraint */,
    "ContinueClimb" /* ContinueClimb */,
    "CrossingClimbSpeedLimit" /* CrossingClimbSpeedLimit */,
    "FcuAltitudeClimb" /* CrossingFcuAltitudeClimb */
  ];
  var CDA_CHECKPOINT_FOR_PWP = /* @__PURE__ */ new Set([
    "Flaps1" /* Flaps1 */,
    "Flaps2" /* Flaps2 */
  ]);

  // src/systems/shared/src/simvar.ts
  var SimVarString = class {
    static pack(value, maxLength) {
      let word = -1;
      const ret = [];
      for (let i = 0; i < Math.min(maxLength, value.length); i++) {
        const char = i % 8;
        if (char === 0) {
          word++;
          ret[word] = 0;
        }
        let code = value.charCodeAt(i) - 31;
        if (code < 1 || code > 63 || !Number.isFinite(code)) {
          code = 0;
        }
        ret[word] += 2 ** (char * 6) * code;
      }
      if (maxLength && ret.length < Math.ceil(maxLength / 8)) {
        ret.push(...new Array(Math.ceil(maxLength / 8) - ret.length).fill(0));
      }
      return ret;
    }
    static unpack(values) {
      let ret = "";
      for (let i = 0; i < values.length * 8; i++) {
        const word = Math.floor(i / 8);
        const char = i % 8;
        const code = Math.floor(values[word] / 2 ** (char * 6)) & 63;
        if (code > 0) {
          ret += String.fromCharCode(code + 31);
        }
      }
      return ret;
    }
  };

  // src/systems/shared/src/popup.ts
  var PopUpDialog = class {
    constructor() {
      __publicField(this, "params");
      __publicField(this, "popupListener");
      const title = "A32NX POPUP";
      const time = new Date().getTime();
      this.popupListener = void 0;
      this.params = {
        __Type: "SNotificationParams",
        buttons: [new NotificationButton("TT:MENU.YES", `A32NX_POP_${title}_${time}_YES`), new NotificationButton("TT:MENU.NO", `A32NX_POP_${title}_${time}_NO`)],
        style: "normal",
        displayGlobalPopup: true,
        contentData: "Default Message",
        contentUrl: "",
        contentTemplate: "",
        id: `${title}_${time}`,
        title,
        time
      };
    }
    _showPopUp(params = {}) {
      Coherent.trigger("SHOW_POP_UP", params);
    }
    showPopUp(title, message, style, callbackYes, callbackNo) {
      if (title) {
        this.params.title = title;
      }
      if (message) {
        this.params.contentData = message;
      }
      if (style) {
        this.params.style = style;
      }
      if (callbackYes) {
        const yes = typeof callbackYes === "function" ? callbackYes : () => callbackYes;
        Coherent.on(`A32NX_POP_${this.params.id}_YES`, () => {
          Coherent.off(`A32NX_POP_${this.params.id}_YES`, null, null);
          yes();
        });
      }
      if (callbackNo) {
        const no = typeof callbackNo === "function" ? callbackNo : () => callbackNo;
        Coherent.on(`A32NX_POP_${this.params.id}_NO`, () => {
          Coherent.off(`A32NX_POP_${this.params.id}_NO`, null, null);
          no();
        });
      }
      if (!this.popupListener) {
        this.popupListener = RegisterViewListener("JS_LISTENER_POPUP", this._showPopUp.bind(null, this.params));
      } else {
        this._showPopUp(this.params);
      }
    }
    showInformation(title, message, style, callback) {
      if (title) {
        this.params.title = title;
      }
      if (message) {
        this.params.contentData = message;
      }
      if (style) {
        this.params.style = style;
      }
      if (callback) {
        const yes = typeof callback === "function" ? callback : () => callback;
        Coherent.on(`A32NX_POP_${this.params.id}_YES`, () => {
          Coherent.off(`A32NX_POP_${this.params.id}_YES`, null, null);
          yes();
        });
      }
      this.params.buttons = [new NotificationButton("TT:MENU.OK", `A32NX_POP_${this.params.id}_YES`)];
      if (!this.popupListener) {
        this.popupListener = RegisterViewListener("JS_LISTENER_POPUP", this._showPopUp.bind(null, this.params));
      } else {
        this._showPopUp(this.params);
      }
    }
  };

  // src/systems/fmgc/src/navigation/NearbyFacilities.ts
  var _NearbyFacilities = class {
    constructor() {
      __publicField(this, "nearbyAirports", /* @__PURE__ */ new Map());
      __publicField(this, "nearbyNdbNavaids", /* @__PURE__ */ new Map());
      __publicField(this, "nearbyVhfNavaids", /* @__PURE__ */ new Map());
      __publicField(this, "nearbyWaypoints", /* @__PURE__ */ new Map());
      __publicField(this, "version", 0);
      __publicField(this, "listener");
      __publicField(this, "initDone", false);
      __publicField(this, "airportSessionId");
      __publicField(this, "ndbSessionId");
      __publicField(this, "vorSessionId");
      __publicField(this, "waypointSessionId");
      __publicField(this, "ppos", { lat: 0, long: 0 });
      __publicField(this, "pposValid", false);
      __publicField(this, "throttler", new A32NX_Util.UpdateThrottler(1e4));
      __publicField(this, "radius", 381 * 1852);
      __publicField(this, "limit", 160);
      this.listener = RegisterViewListener("JS_LISTENER_FACILITY", async () => {
        this.listener.on("SendAirport", this.addAirport.bind(this));
        this.listener.on("SendIntersection", this.addWaypoint.bind(this));
        this.listener.on("SendNdb", this.addNdbNavaid.bind(this));
        this.listener.on("SendVor", this.addVhfNavaid.bind(this));
        this.listener.on("NearestSearchCompleted", this.onSearchCompleted.bind(this));
        this.airportSessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", 1 /* Airport */);
        this.ndbSessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", 4 /* Ndb */);
        this.vorSessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", 3 /* Vor */);
        this.waypointSessionId = await Coherent.call("START_NEAREST_SEARCH_SESSION", 2 /* Intersection */);
        this.initDone = true;
      });
    }
    static getInstance() {
      if (!_NearbyFacilities.instance) {
        _NearbyFacilities.instance = new _NearbyFacilities();
      }
      return _NearbyFacilities.instance;
    }
    getAirports() {
      return this.pposValid ? this.nearbyAirports.values() : [][Symbol.iterator]();
    }
    getNdbNavaids() {
      return this.pposValid ? this.nearbyNdbNavaids.values() : [][Symbol.iterator]();
    }
    getVhfNavaids() {
      return this.pposValid ? this.nearbyVhfNavaids.values() : [][Symbol.iterator]();
    }
    getWaypoints() {
      return this.pposValid ? this.nearbyWaypoints.values() : [][Symbol.iterator]();
    }
    init() {
    }
    async update(deltaTime) {
      if (!this.initDone || this.throttler.canUpdate(deltaTime) === -1) {
        return;
      }
      if (this.pposValid) {
        Coherent.call("SEARCH_NEAREST", this.airportSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
        Coherent.call("SEARCH_NEAREST", this.vorSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
        Coherent.call("SEARCH_NEAREST", this.ndbSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
        Coherent.call("SEARCH_NEAREST", this.waypointSessionId, this.ppos.lat, this.ppos.long, this.radius, this.limit);
      }
    }
    setPpos(ppos) {
      if (ppos === null) {
        this.pposValid = false;
      } else if (!this.pposValid || Avionics.Utils.computeDistance(ppos, this.ppos) > 5) {
        this.ppos.lat = ppos.lat;
        this.ppos.long = ppos.long;
        this.pposValid = true;
      }
    }
    onSearchCompleted(result) {
      let nearestList;
      let loadCall;
      switch (result.sessionId) {
        case this.airportSessionId:
          nearestList = this.nearbyAirports;
          loadCall = "LOAD_AIRPORTS";
          break;
        case this.ndbSessionId:
          nearestList = this.nearbyNdbNavaids;
          loadCall = "LOAD_NDBS";
          break;
        case this.vorSessionId:
          nearestList = this.nearbyVhfNavaids;
          loadCall = "LOAD_VORS";
          break;
        case this.waypointSessionId:
          nearestList = this.nearbyWaypoints;
          loadCall = "LOAD_INTERSECTIONS";
          break;
        default:
          return;
      }
      for (const icao of result.removed) {
        delete nearestList[icao];
        this.version++;
      }
      const loadIcaos = [];
      for (const icao of result.added) {
        if (nearestList.has(icao)) {
          continue;
        }
        loadIcaos.push(icao);
      }
      if (loadIcaos.length > 0) {
        Coherent.call(loadCall, loadIcaos);
      }
    }
    addAirport(airport) {
      this.nearbyAirports.set(airport.icao, airport);
      this.version++;
    }
    addWaypoint(waypoint) {
      this.nearbyWaypoints.set(waypoint.icao, waypoint);
      this.version++;
    }
    addNdbNavaid(ndb) {
      this.nearbyNdbNavaids.set(ndb.icao, ndb);
      this.version++;
    }
    addVhfNavaid(vor) {
      this.nearbyVhfNavaids.set(vor.icao, vor);
      this.version++;
    }
  };
  var NearbyFacilities = _NearbyFacilities;
  __publicField(NearbyFacilities, "instance");

  // src/systems/fmgc/src/efis/EfisSymbols.ts
  var _EfisSymbols = class {
    constructor(flightPlanManager, guidanceController, navaidTuner) {
      this.navaidTuner = navaidTuner;
      __publicField(this, "blockUpdate", false);
      __publicField(this, "flightPlanManager");
      __publicField(this, "guidanceController");
      __publicField(this, "guidanceManager");
      __publicField(this, "nearby");
      __publicField(this, "syncer", new GenericDataListenerSync());
      __publicField(this, "lastMode", { L: -1, R: -1 });
      __publicField(this, "lastRange", { L: 0, R: 0 });
      __publicField(this, "lastEfisOption", { L: 0, R: 0 });
      __publicField(this, "lastPlanCentre");
      __publicField(this, "lastPpos", { lat: 0, long: 0 });
      __publicField(this, "lastTrueHeading", -1);
      __publicField(this, "lastNearbyFacilitiesVersion");
      __publicField(this, "lastFpVersion");
      __publicField(this, "lastNavaidVersion", -1);
      __publicField(this, "lastVnavDriverVersion", -1);
      this.flightPlanManager = flightPlanManager;
      this.guidanceController = guidanceController;
      this.guidanceManager = guidanceController.guidanceManager;
      this.nearby = NearbyFacilities.getInstance();
    }
    init() {
      this.nearby.init();
    }
    async update(deltaTime) {
      var _a, _b, _c, _d;
      if (this.blockUpdate) {
        return;
      }
      const ppos = {
        lat: SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude"),
        long: SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude")
      };
      const trueHeading = SimVar.GetSimVarValue("PLANE HEADING DEGREES TRUE", "degrees");
      const pposChanged = Avionics.Utils.computeDistance(this.lastPpos, ppos) > 2;
      if (pposChanged) {
        this.lastPpos = ppos;
      }
      const trueHeadingChanged = Avionics.Utils.diffAngle(trueHeading, this.lastTrueHeading) > 2;
      if (trueHeadingChanged) {
        this.lastTrueHeading = trueHeading;
      }
      const nearbyFacilitiesChanged = this.nearby.version !== this.lastNearbyFacilitiesVersion;
      this.lastNearbyFacilitiesVersion = this.nearby.version;
      const fpChanged = this.lastFpVersion !== this.flightPlanManager.currentFlightPlanVersion;
      this.lastFpVersion = this.flightPlanManager.currentFlightPlanVersion;
      const planCentreIndex = SimVar.GetSimVarValue("L:A32NX_SELECTED_WAYPOINT", "number");
      const planCentre = (_a = this.flightPlanManager.getWaypoint(planCentreIndex)) == null ? void 0 : _a.infos.coordinates;
      const planCentreChanged = (planCentre == null ? void 0 : planCentre.lat) !== ((_b = this.lastPlanCentre) == null ? void 0 : _b.lat) || (planCentre == null ? void 0 : planCentre.long) !== ((_c = this.lastPlanCentre) == null ? void 0 : _c.long);
      this.lastPlanCentre = planCentre;
      const navaidsChanged = this.lastNavaidVersion !== this.navaidTuner.navaidVersion;
      this.lastNavaidVersion = this.navaidTuner.navaidVersion;
      const vnavPredictionsChanged = this.lastVnavDriverVersion !== this.guidanceController.vnavDriver.version;
      this.lastVnavDriverVersion = this.guidanceController.vnavDriver.version;
      const activeFp = this.flightPlanManager.getCurrentFlightPlan();
      const hasSuitableRunway = (airport) => {
        for (const runway of airport.runways) {
          switch (runway.surface) {
            case 4 /* Asphalt */:
            case 17 /* Bituminous */:
            case 0 /* Concrete */:
            case 23 /* Tarmac */:
              if (runway.length >= 1500 && runway.width >= 30) {
                return true;
              }
              break;
            default:
              break;
          }
        }
        return false;
      };
      for (const side of _EfisSymbols.sides) {
        const range2 = rangeSettings[SimVar.GetSimVarValue(`L:A32NX_EFIS_${side}_ND_RANGE`, "number")];
        const mode = SimVar.GetSimVarValue(`L:A32NX_EFIS_${side}_ND_MODE`, "number");
        const efisOption = SimVar.GetSimVarValue(`L:A32NX_EFIS_${side}_OPTION`, "Enum");
        const rangeChange = this.lastRange[side] !== range2;
        this.lastRange[side] = range2;
        const modeChange = this.lastMode[side] !== mode;
        this.lastMode[side] = mode;
        const efisOptionChange = this.lastEfisOption[side] !== efisOption;
        this.lastEfisOption[side] = efisOption;
        const nearbyOverlayChanged = efisOption !== 1 /* Constraints */ && efisOption !== 0 /* None */ && nearbyFacilitiesChanged;
        if (!pposChanged && !trueHeadingChanged && !rangeChange && !modeChange && !efisOptionChange && !nearbyOverlayChanged && !fpChanged && !planCentreChanged && !navaidsChanged && !vnavPredictionsChanged) {
          continue;
        }
        if (mode === 4 /* PLAN */ && !planCentre) {
          this.syncer.sendEvent(`A32NX_EFIS_${side}_SYMBOLS`, []);
          return;
        }
        const [editAhead, editBehind, editBeside] = this.calculateEditArea(range2, mode);
        const withinEditArea = (ll) => {
          const dist = Avionics.Utils.computeGreatCircleDistance(mode === 4 /* PLAN */ ? planCentre : ppos, ll);
          let bearing = Avionics.Utils.computeGreatCircleHeading(mode === 4 /* PLAN */ ? planCentre : ppos, ll);
          if (mode !== 4 /* PLAN */) {
            bearing = Avionics.Utils.clampAngle(bearing - trueHeading);
          }
          bearing = bearing * Math.PI / 180;
          const dx = dist * Math.sin(bearing);
          const dy = dist * Math.cos(bearing);
          return Math.abs(dx) < editBeside && dy > -editBehind && dy < editAhead;
        };
        const symbols = [];
        const upsertSymbol = (symbol) => {
          var _a2, _b2, _c2, _d2;
          if (DEBUG) {
            console.time(`upsert symbol ${symbol.databaseId}`);
          }
          const symbolIdx = symbols.findIndex((s) => s.databaseId === symbol.databaseId);
          if (symbolIdx !== -1) {
            const oldSymbol = symbols.splice(symbolIdx, 1)[0];
            symbol.constraints = (_a2 = symbol.constraints) != null ? _a2 : oldSymbol.constraints;
            symbol.direction = (_b2 = symbol.direction) != null ? _b2 : oldSymbol.direction;
            symbol.length = (_c2 = symbol.length) != null ? _c2 : oldSymbol.length;
            symbol.location = (_d2 = symbol.location) != null ? _d2 : oldSymbol.location;
            symbol.type |= oldSymbol.type;
            if (oldSymbol.radials) {
              if (symbol.radials) {
                symbol.radials.push(...oldSymbol.radials);
              } else {
                symbol.radials = oldSymbol.radials;
              }
            }
            if (oldSymbol.radii) {
              if (symbol.radii) {
                symbol.radii.push(...oldSymbol.radii);
              } else {
                symbol.radii = oldSymbol.radii;
              }
            }
          }
          symbols.push(symbol);
        };
        if (efisOption === 2 /* VorDmes */) {
          for (const vor of this.nearby.getVhfNavaids()) {
            if (vor.type !== 2 /* VORDME */ && vor.type !== 1 /* VOR */ && vor.type !== 3 /* DME */ && vor.type !== 5 /* VORTAC */ && vor.type !== 4 /* TACAN */) {
              continue;
            }
            const ll = { lat: vor.lat, long: vor.lon };
            if (withinEditArea(ll)) {
              upsertSymbol({
                databaseId: vor.icao,
                ident: vor.icao.substring(7, 12),
                location: ll,
                type: this.vorDmeTypeFlag(vor.type) | 256 /* EfisOption */
              });
            }
          }
        } else if (efisOption === 4 /* Ndbs */) {
          for (const ndb of this.nearby.getNdbNavaids()) {
            const ll = { lat: ndb.lat, long: ndb.lon };
            if (withinEditArea(ll)) {
              upsertSymbol({
                databaseId: ndb.icao,
                ident: ndb.icao.substring(7, 12),
                location: ll,
                type: 4 /* Ndb */ | 256 /* EfisOption */
              });
            }
          }
        } else if (efisOption === 5 /* Airports */) {
          for (const ap of this.nearby.getAirports()) {
            const ll = { lat: ap.lat, long: ap.lon };
            if (withinEditArea(ll) && hasSuitableRunway(ap)) {
              upsertSymbol({
                databaseId: ap.icao,
                ident: ap.icao.substring(7, 12),
                location: ll,
                type: 16 /* Airport */ | 256 /* EfisOption */
              });
            }
          }
        } else if (efisOption === 3 /* Waypoints */) {
          for (const wp of this.nearby.getWaypoints()) {
            const ll = { lat: wp.lat, long: wp.lon };
            if (withinEditArea(ll)) {
              upsertSymbol({
                databaseId: wp.icao,
                ident: wp.icao.substring(7, 12),
                location: ll,
                type: 8 /* Waypoint */ | 256 /* EfisOption */
              });
            }
          }
        }
        for (let i = 0; i < 4; i++) {
          const fixInfo = this.flightPlanManager.getFixInfo(i);
          const refFix = fixInfo == null ? void 0 : fixInfo.getRefFix();
          if (refFix !== void 0) {
            upsertSymbol({
              databaseId: refFix.icao,
              ident: refFix.ident,
              location: refFix.infos.coordinates,
              type: 2048 /* FixInfo */,
              radials: fixInfo.getRadialTrueBearings(),
              radii: [fixInfo.getRadiusValue()]
            });
          }
        }
        const formatConstraintAlt = (alt, descent, prefix = "") => {
          var _a2, _b2;
          const transAlt = (_a2 = activeFp == null ? void 0 : activeFp.originTransitionAltitudePilot) != null ? _a2 : activeFp == null ? void 0 : activeFp.originTransitionAltitudeDb;
          const transFl = (_b2 = activeFp == null ? void 0 : activeFp.destinationTransitionLevelPilot) != null ? _b2 : activeFp == null ? void 0 : activeFp.destinationTransitionLevelDb;
          if (descent) {
            const fl = Math.round(alt / 100);
            if (transFl && fl >= transFl) {
              return `${prefix}FL${fl}`;
            }
          } else if (transAlt && alt >= transAlt) {
            return `${prefix}FL${Math.round(alt / 100)}`;
          }
          return `${prefix}${Math.round(alt)}`;
        };
        const formatConstraintSpeed = (speed, prefix = "") => `${prefix}${Math.floor(speed)}KT`;
        for (const [index, leg] of this.guidanceController.activeGeometry.legs.entries()) {
          if (!leg.isNull && leg.terminationWaypoint && leg.displayedOnMap) {
            if (!(leg.terminationWaypoint instanceof WayPoint)) {
              const isActive = index === this.guidanceController.activeLegIndex;
              let type = 4096 /* FlightPlan */;
              if (isActive) {
                type |= 128 /* ActiveLegTermination */;
              }
              const ident = leg.ident;
              const cutIdent = leg.ident.substring(0, 4).padEnd(5, " ");
              const id = (Math.random() * 1e7).toString().substring(0, 5);
              upsertSymbol({
                databaseId: `X${id}${cutIdent}`,
                ident,
                type,
                location: leg.terminationWaypoint
              });
            }
          }
        }
        const isInLatAutoControl = this.guidanceController.vnavDriver.isLatAutoControlActive();
        const waypointPredictions = (_d = this.guidanceController.vnavDriver.mcduProfile) == null ? void 0 : _d.waypointPredictions;
        const isSelectedVerticalModeActive = this.guidanceController.vnavDriver.isSelectedVerticalModeActive();
        const flightPhase = getFlightPhaseManager().phase;
        {
          for (let i = activeFp.length - 1; i >= activeFp.activeWaypointIndex - 1 && i >= 0; i--) {
            const wp = activeFp.getWaypoint(i);
            if (!wp) {
              continue;
            }
            const isFromWp = i < activeFp.activeWaypointIndex;
            const legType = wp.additionalData.legType;
            if (_EfisSymbols.LEG_MANAGED_TYPES.includes(legType)) {
              continue;
            }
            if (wp.type === "A") {
              continue;
            }
            if (range2 >= 160) {
              const segment = activeFp.findSegmentByWaypointIndex(i);
              if (segment.type === 1 /* Departure */) {
                if (!activeFp.isLastWaypointInSegment(i)) {
                  continue;
                }
              } else if (segment.type !== 2 /* Enroute */) {
                continue;
              }
            }
            if (!withinEditArea(wp.infos.coordinates)) {
              continue;
            }
            let type = 4096 /* FlightPlan */;
            const constraints = [];
            let direction;
            const isCourseReversal = wp.additionalData.legType === 12 /* HA */ || wp.additionalData.legType === 13 /* HF */ || wp.additionalData.legType === 14 /* HM */ || wp.additionalData.legType === 16 /* PI */;
            if (i === activeFp.activeWaypointIndex) {
              type |= 128 /* ActiveLegTermination */;
            } else if (isCourseReversal && i > activeFp.activeWaypointIndex + 1 && range2 <= 80 && !LnavConfig.DEBUG_FORCE_INCLUDE_COURSE_REVERSAL_VECTORS) {
              if (wp.turnDirection === 1 /* Left */) {
                type |= 131072 /* CourseReversalLeft */;
              } else {
                type |= 262144 /* CourseReversalRight */;
              }
              direction = wp.additionalData.course;
            }
            if (isInLatAutoControl && !isFromWp && wp.legAltitudeDescription > 0 && wp.legAltitudeDescription < 6) {
              if (!isSelectedVerticalModeActive && shouldShowConstraintCircleInPhase(flightPhase, wp)) {
                type |= 1024 /* Constraint */;
                const predictionAtWaypoint = waypointPredictions.get(i);
                if (predictionAtWaypoint == null ? void 0 : predictionAtWaypoint.isAltitudeConstraintMet) {
                  type |= -2147483648 /* MagentaColor */;
                } else if (predictionAtWaypoint) {
                  type |= 1073741824 /* AmberColor */;
                }
              } else if (i === activeFp.activeWaypointIndex) {
                type |= 1024 /* Constraint */;
              }
            }
            if (efisOption === 1 /* Constraints */ && !isFromWp) {
              const descent = wp.constraintType === 2 /* DES */;
              switch (wp.legAltitudeDescription) {
                case 1:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent));
                  break;
                case 2:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent, "+"));
                  break;
                case 3:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent, "-"));
                  break;
                case 4:
                  constraints.push(formatConstraintAlt(wp.legAltitude1, descent, "-"));
                  constraints.push(formatConstraintAlt(wp.legAltitude2, descent, "+"));
                  break;
                default:
                  break;
              }
              if (wp.speedConstraint > 0) {
                constraints.push(formatConstraintSpeed(wp.speedConstraint));
              }
            }
            upsertSymbol({
              databaseId: wp.icao,
              ident: wp.ident,
              location: wp.infos.coordinates,
              type,
              constraints: constraints.length > 0 ? constraints : void 0,
              direction
            });
          }
        }
        let constraintPredictions = 0;
        const constraintFlags = 1024 /* Constraint */ | -2147483648 /* MagentaColor */ | 1073741824 /* AmberColor */;
        for (let i = symbols.length - 1; i >= 0; i--) {
          if ((symbols[i].type & constraintFlags) === 0) {
            continue;
          }
          if (constraintPredictions >= 2) {
            symbols[i].type &= ~constraintFlags;
          } else {
            constraintPredictions++;
          }
        }
        const airports = [
          [activeFp.originAirfield, activeFp.getOriginRunway()],
          [activeFp.destinationAirfield, activeFp.getDestinationRunway()]
        ];
        for (const [airport, runway] of airports) {
          if (!airport) {
            continue;
          }
          if (runway) {
            if (withinEditArea(runway.beginningCoordinates)) {
              upsertSymbol({
                databaseId: airport.icao,
                ident: `${airport.ident}${Avionics.Utils.formatRunway(runway.designation)}`,
                location: runway.beginningCoordinates,
                direction: runway.direction,
                length: runway.length / 1852,
                type: 32 /* Runway */
              });
            }
          } else if (withinEditArea(airport.infos.coordinates)) {
            upsertSymbol({
              databaseId: airport.icao,
              ident: airport.ident,
              location: airport.infos.coordinates,
              type: 16 /* Airport */
            });
          }
        }
        for (const pwp of this.guidanceController.currentPseudoWaypoints.filter((it) => it && it.displayedOnNd)) {
          upsertSymbol({
            databaseId: `W      ${pwp.ident}`,
            ident: pwp.ident,
            location: pwp.efisSymbolLla,
            type: pwp.efisSymbolFlag,
            distanceFromAirplane: pwp.distanceFromStart
          });
        }
        for (const ndb of this.navaidTuner.tunedNdbs) {
          upsertSymbol({
            databaseId: ndb.icao,
            ident: WayPoint.formatIdentFromIcao(ndb.icao),
            location: { lat: ndb.lat, long: ndb.lon },
            type: 4 /* Ndb */ | 64 /* Tuned */
          });
        }
        for (const vor of this.navaidTuner.tunedVors) {
          upsertSymbol({
            databaseId: vor.icao,
            ident: WayPoint.formatIdentFromIcao(vor.icao),
            location: { lat: vor.lat, long: vor.lon },
            type: this.vorDmeTypeFlag(vor.type) | 64 /* Tuned */
          });
        }
        const wordsPerSymbol = 6;
        const maxSymbols = 640 / wordsPerSymbol;
        if (symbols.length > maxSymbols) {
          symbols.splice(0, symbols.length - maxSymbols);
          this.guidanceController.efisStateForSide[side].dataLimitReached = true;
        } else {
          this.guidanceController.efisStateForSide[side].dataLimitReached = false;
        }
        this.syncer.sendEvent(`A32NX_EFIS_${side}_SYMBOLS`, symbols);
        this.blockUpdate = true;
        setTimeout(() => {
          this.blockUpdate = false;
        }, 200);
      }
    }
    vorDmeTypeFlag(type) {
      switch (type) {
        case 2 /* VORDME */:
        case 5 /* VORTAC */:
          return 2 /* VorDme */;
        case 1 /* VOR */:
          return 1 /* Vor */;
        case 3 /* DME */:
        case 4 /* TACAN */:
          return 512 /* Dme */;
        default:
          return 0;
      }
    }
    calculateEditArea(range2, mode) {
      switch (mode) {
        case 3 /* ARC */:
          if (range2 <= 10) {
            return [10.5, 3.5, 8.3];
          }
          if (range2 <= 20) {
            return [20.5, 7, 16.6];
          }
          if (range2 <= 40) {
            return [40.5, 14, 33.2];
          }
          if (range2 <= 80) {
            return [80.5, 28, 66.4];
          }
          if (range2 <= 160) {
            return [160.5, 56, 132.8];
          }
          return [320.5, 112, 265.6];
        case 2 /* ROSE_NAV */:
          if (range2 <= 10) {
            return [7.6, 7.1, 7.1];
          }
          if (range2 <= 20) {
            return [14.7, 14.2, 14.2];
          }
          if (range2 <= 40) {
            return [28.9, 28.4, 28.4];
          }
          if (range2 <= 80) {
            return [57.3, 56.8, 56.8];
          }
          if (range2 <= 160) {
            return [114.1, 113.6, 113.6];
          }
          return [227.7, 227.2, 227.2];
        case 4 /* PLAN */:
          if (range2 <= 10) {
            return [7, 7, 7];
          }
          if (range2 <= 20) {
            return [14, 14, 14];
          }
          if (range2 <= 40) {
            return [28, 28, 28];
          }
          if (range2 <= 80) {
            return [56, 56, 56];
          }
          if (range2 <= 160) {
            return [112, 112, 112];
          }
          return [224, 224, 224];
        default:
          return [0, 0, 0];
      }
    }
  };
  var EfisSymbols = _EfisSymbols;
  __publicField(EfisSymbols, "LEG_MANAGED_TYPES", [2 /* CA */, 6 /* CR */, 5 /* CI */, 11 /* FM */, 16 /* PI */, 19 /* VA */, 21 /* VI */, 22 /* VM */]);
  __publicField(EfisSymbols, "sides", ["L", "R"]);
  var shouldShowConstraintCircleInPhase = (phase, waypoint) => (phase === 1 /* Takeoff */ || phase === 2 /* Climb */) && waypoint.additionalData.constraintType === 1 /* CLB */ || (phase === 3 /* Cruise */ || phase === 4 /* Descent */ || phase === 5 /* Approach */) && waypoint.additionalData.constraintType === 2 /* DES */;

  // src/systems/fmgc/src/components/FcuSync.ts
  var FcuSync = class {
    constructor() {
      __publicField(this, "trueRef", false);
    }
    init() {
    }
    update(_deltaTime) {
      const irMaint = Arinc429Word.fromSimVarValue("L:A32NX_ADIRS_IR_1_MAINT_WORD");
      const trueRefPb = SimVar.GetSimVarValue("L:A32NX_PUSH_TRUE_REF", "bool");
      const trueRef = (irMaint.getBitValueOr(15, false) || trueRefPb) && !irMaint.getBitValueOr(2, false);
      if (trueRef !== this.trueRef) {
        this.trueRef = trueRef;
        SimVar.SetSimVarValue("L:A32NX_FMGC_TRUE_REF", "boolean", trueRef);
        const activeMode = SimVar.GetSimVarValue("L:A32NX_FMA_LATERAL_MODE", "number");
        if (activeMode === 10 /* HDG */ || activeMode === 11 /* TRACK */) {
          SimVar.SetSimVarValue("L:A32NX_FM_HEADING_SYNC", "boolean", true);
        }
      }
    }
  };

  // src/systems/fmgc/src/components/ReadySignal.ts
  var ReadySignal = class {
    constructor() {
      __publicField(this, "baseInstrument", null);
      __publicField(this, "updateThrottler", new A32NX_Util.UpdateThrottler(1e3));
    }
    init(baseInstrument, _flightPlanManager) {
      this.baseInstrument = baseInstrument;
    }
    update(deltaTime) {
      if (this.updateThrottler.canUpdate(deltaTime) !== -1 && this.baseInstrument.getGameState() === GameState.ingame && SimVar.GetSimVarValue("L:A32NX_IS_READY", "number") !== 1) {
        SimVar.SetSimVarValue("L:A32NX_IS_READY", "number", 1);
      }
    }
  };

  // src/systems/fmgc/src/components/EfisLabels.ts
  var EfisLabels = class {
    constructor() {
      __publicField(this, "lastTransitionAltitude");
      __publicField(this, "lastTransitionLevel");
      __publicField(this, "flightPlanManager");
    }
    init(_baseInstrument, flightPlanManager) {
      this.flightPlanManager = flightPlanManager;
    }
    update(_deltaTime) {
      const transitionAltitude = this.flightPlanManager.originTransitionAltitude;
      const transitionLevel = this.flightPlanManager.destinationTransitionLevel;
      if (transitionAltitude !== this.lastTransitionAltitude) {
        SimVar.SetSimVarValue("L:AIRLINER_TRANS_ALT", "Number", transitionAltitude != null ? transitionAltitude : 0);
        this.lastTransitionAltitude = transitionAltitude;
      }
      if (transitionLevel !== this.lastTransitionLevel) {
        SimVar.SetSimVarValue("L:AIRLINER_APPR_TRANS_ALT", "Number", (transitionLevel != null ? transitionLevel : 0) * 100);
        this.lastTransitionLevel = transitionLevel;
      }
    }
  };

  // src/systems/shared/src/FmMessages.ts
  var FMMessageTriggers = {
    SEND_TO_MCDU: "A32NX_FMGC_SEND_MESSAGE_TO_MCDU",
    RECALL_FROM_MCDU_WITH_ID: "A32NX_FMGC_RECALL_MESSAGE_FROM_MCDU_WITH_ID",
    POP_FROM_STACK: "A32NX_FMGC_POP_MESSAGE"
  };
  var FMMessageTypes = {
    SelectTrueRef: {
      id: 1,
      ndFlag: 1 /* SelectTrueRef */,
      text: "SELECT TRUE REF",
      color: "Amber",
      ndPriority: 1,
      clearable: true
    },
    CheckNorthRef: {
      id: 2,
      ndFlag: 2 /* CheckNorthRef */,
      text: "CHECK NORTH REF",
      color: "Amber",
      ndPriority: 1,
      clearable: true
    },
    NavAccuracyDowngrade: {
      id: 3,
      ndFlag: 4 /* NavAccuracyDowngrade */,
      text: "NAV ACCUR DOWNGRAD",
      color: "Amber",
      ndPriority: 1,
      clearable: true
    },
    NavAccuracyUpgradeNoGps: {
      id: 4,
      ndFlag: 8 /* NavAccuracyUpgradeNoGps */,
      text: "NAV ACCUR UPGRAD",
      color: "Amber",
      ndPriority: 1,
      clearable: true
    },
    SpecifiedVorDmeUnavailble: {
      id: 5,
      ndFlag: 16 /* SpecifiedVorDmeUnavailble */,
      text: "SPECIF VOR/D UNAVAIL",
      color: "Amber",
      ndPriority: 1,
      clearable: true
    },
    NavAccuracyUpgradeGps: {
      id: 6,
      ndFlag: 32 /* NavAccuracyUpgradeGps */,
      text: "NAV ACCUR UPGRAD",
      color: "White",
      ndPriority: 1,
      clearable: true
    },
    GpsPrimary: {
      id: 7,
      ndFlag: 64 /* GpsPrimary */,
      text: "GPS PRIMARY",
      color: "White",
      ndPriority: 1,
      clearable: true
    },
    MapPartlyDisplayed: {
      id: 8,
      ndFlag: 128 /* MapPartlyDisplayed */,
      efisText: "MAP PARTLY DISPLAYED",
      color: "Amber",
      ndPriority: 2
    },
    SetOffsideRangeMode: {
      id: 9,
      ndFlag: 256 /* SetOffsideRangeMode */,
      text: "SET OFFSIDE RNG/MODE",
      color: "Amber",
      ndPriority: 3
    },
    OffsideFmControl: {
      id: 10,
      ndFlag: 512 /* OffsideFmControl */,
      text: "OFFSIDE FM CONTROL",
      color: "Amber",
      ndPriority: 4
    },
    OffsideFmWxrControl: {
      id: 11,
      ndFlag: 1024 /* OffsideFmWxrControl */,
      text: "OFFSIDE FM/WXR CONTROL",
      color: "Amber",
      ndPriority: 5
    },
    OffsideWxrControl: {
      id: 12,
      ndFlag: 2048 /* OffsideWxrControl */,
      text: "OFFSIDE WXR CONTROL",
      color: "Amber",
      ndPriority: 6
    },
    GpsPrimaryLost: {
      id: 13,
      ndFlag: 4096 /* GpsPrimaryLost */,
      text: "GPS PRIMARY LOST",
      color: "Amber",
      ndPriority: 7
    },
    RtaMissed: {
      id: 14,
      ndFlag: 8192 /* RtaMissed */,
      text: "RTA MISSED",
      color: "Amber",
      ndPriority: 8
    },
    BackupNav: {
      id: 15,
      ndFlag: 16384 /* BackupNav */,
      text: "BACK UP NAV",
      color: "Amber",
      ndPriority: 9
    },
    TurnAreaExceedance: {
      id: 16,
      text: "TURN AREA EXCEEDANCE",
      color: "Amber"
    },
    TuneNavaid: {
      id: 17,
      text: "TUNE BBB FFF.FF",
      color: "Amber"
    },
    SpecifiedNdbUnavailble: {
      id: 18,
      text: "SPECIF NDB UNAVAIL",
      color: "Amber"
    },
    RwyLsMismatch: {
      id: 19,
      text: "RWY/LS MISMATCH",
      color: "Amber"
    },
    TdReached: {
      id: 17,
      text: "T/D REACHED",
      color: "White",
      clearable: true
    },
    StepAhead: {
      id: 18,
      text: "STEP AHEAD",
      color: "White",
      clearable: true
    },
    StepDeleted: {
      id: 19,
      text: "STEP DELETED",
      color: "White",
      clearable: true
    }
  };

  // src/systems/fmgc/src/components/fms-messages/RwyLsMismatch.ts
  var RwyLsMismatch = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.RwyLsMismatch);
      __publicField(this, "trigRising", new Trigger(true));
      __publicField(this, "trigFalling", new Trigger(true));
      __publicField(this, "navaidTuner");
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getRwyLsMismatchMessage();
      this.trigRising.input = message;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !message;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return 1 /* SEND */;
      }
      if (this.trigFalling.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };
  var RwyLsMismatchLeft = class extends RwyLsMismatch {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "L");
    }
  };
  var RwyLsMismatchRight = class extends RwyLsMismatch {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "R");
    }
  };

  // src/systems/fmgc/src/components/fms-messages/SpecifiedNdbUnavailable.ts
  var SpecifiedNdbUnavailable = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.SpecifiedNdbUnavailble);
      __publicField(this, "trigRising", new Trigger(true));
      __publicField(this, "trigFalling", new Trigger(true));
      __publicField(this, "navaidTuner");
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getSpecifiedNdbMessage();
      this.trigRising.input = message;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !message;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return 1 /* SEND */;
      }
      if (this.trigFalling.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };
  var SpecifiedNdbUnavailableLeft = class extends SpecifiedNdbUnavailable {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "L");
    }
  };
  var SpecifiedNdbUnavailableRight = class extends SpecifiedNdbUnavailable {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "R");
    }
  };

  // src/systems/fmgc/src/components/fms-messages/SpecifiedVorUnavailable.ts
  var SpecifiedVorUnavailable = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.SpecifiedVorDmeUnavailble);
      __publicField(this, "trigRising", new Trigger(true));
      __publicField(this, "trigFalling", new Trigger(true));
      __publicField(this, "navaidTuner");
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getSpecifiedVorMessage();
      this.trigRising.input = message;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !message;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return 1 /* SEND */;
      }
      if (this.trigFalling.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };
  var SpecifiedVorUnavailableLeft = class extends SpecifiedVorUnavailable {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "L");
    }
  };
  var SpecifiedVorUnavailableRight = class extends SpecifiedVorUnavailable {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "R");
    }
  };

  // src/systems/fmgc/src/components/fms-messages/TuneNavaid.ts
  var TuneNavaid = class {
    constructor() {
      __publicField(this, "message", __spreadValues({}, FMMessageTypes.TuneNavaid));
      __publicField(this, "trigRising", new Trigger(true));
      __publicField(this, "trigFalling", new Trigger(true));
      __publicField(this, "navaidTuner");
    }
    init(baseInstrument) {
      this.navaidTuner = baseInstrument.navigation.getNavaidTuner();
    }
    process(deltaTime) {
      const message = this.navaidTuner.getTuneNavaidMessage();
      this.trigRising.input = message !== null;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = message === null;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        const [freqeuncy, ident] = message;
        const baseMessage = FMMessageTypes.TuneNavaid.text;
        this.message.text = baseMessage.replace("BBB", ident).replace("FFF.FF", freqeuncy.toFixed(2));
        return 1 /* SEND */;
      }
      if (this.trigFalling.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };
  var TuneNavaidLeft = class extends TuneNavaid {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "L");
    }
  };
  var TuneNavaidRight = class extends TuneNavaid {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "R");
    }
  };

  // src/systems/fmgc/src/components/fms-messages/TurnAreaExceedance.ts
  var TurnAreaExceedance = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.TurnAreaExceedance);
      __publicField(this, "trigRising", new Trigger(true));
      __publicField(this, "trigFalling", new Trigger(true));
      __publicField(this, "guidanceController");
      __publicField(this, "navigation");
    }
    init(baseInstrument) {
      this.guidanceController = baseInstrument.guidanceController;
      this.navigation = baseInstrument.navigation;
    }
    process(deltaTime) {
      var _a;
      const gs = this.navigation.groundSpeed;
      const dtg = (_a = this.guidanceController.activeLegDtg) != null ? _a : Infinity;
      const ttg = gs > 10 ? 3600 * dtg / gs : Infinity;
      const nextLeg = this.guidanceController.activeGeometry.legs.get(this.guidanceController.activeLegIndex + 1);
      const turnAreaExceeded = ttg <= 90 && nextLeg instanceof PILeg && nextLeg.turnAreaExceeded;
      this.trigRising.input = turnAreaExceeded;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = !turnAreaExceeded;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return 1 /* SEND */;
      }
      if (this.trigFalling.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };
  var TurnAreaExceedanceLeft = class extends TurnAreaExceedance {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "L");
    }
  };
  var TurnAreaExceedanceRight = class extends TurnAreaExceedance {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "R");
    }
  };

  // src/systems/fmgc/src/components/fms-messages/TdReached.ts
  var TdReached = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.TdReached);
      __publicField(this, "lastState", false);
    }
    process(_) {
      const newState = SimVar.GetSimVarValue("L:A32NX_PFD_MSG_TD_REACHED", "Bool") === 1;
      if (newState !== this.lastState) {
        this.lastState = newState;
        return newState ? 1 /* SEND */ : 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };

  // src/systems/fmgc/src/components/fms-messages/StepAhead.ts
  var StepAhead = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.StepAhead);
      __publicField(this, "guidanceController");
      __publicField(this, "lastState", false);
    }
    init(baseInstrument) {
      this.guidanceController = baseInstrument.guidanceController;
    }
    process(_) {
      var _a;
      const fpm = this.guidanceController.flightPlanManager;
      const distanceToEnd = this.guidanceController.vnavDriver.distanceToEnd;
      if (!((_a = this.guidanceController.vnavDriver.mcduProfile) == null ? void 0 : _a.isReadyToDisplay) || distanceToEnd <= 0) {
        return 0 /* NO_ACTION */;
      }
      let newState = false;
      for (let i = fpm.getActiveWaypointIndex(); i < fpm.getWaypointsCount(0 /* Active */); i++) {
        const waypoint = fpm.getWaypoint(i, 0 /* Active */);
        if (!waypoint || !waypoint.additionalData.cruiseStep || waypoint.additionalData.cruiseStep.isIgnored) {
          continue;
        }
        if (distanceToEnd - waypoint.additionalData.distanceToEnd < 20) {
          newState = true;
        }
      }
      if (newState !== this.lastState) {
        this.lastState = newState;
        return newState ? 1 /* SEND */ : 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };

  // src/systems/fmgc/src/components/fms-messages/StepDeleted.ts
  var StepDeleted = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.StepDeleted);
    }
    process(_) {
      const newState = SimVar.GetSimVarValue("L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED", "Bool") === 1;
      if (newState) {
        SimVar.SetSimVarValue("L:A32NX_FM_VNAV_TRIGGER_STEP_DELETED", "boolean", false);
        return 1 /* SEND */;
      }
      return 0 /* NO_ACTION */;
    }
  };

  // src/systems/fmgc/src/components/fms-messages/GpsPrimary.ts
  var GpsPrimary = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.GpsPrimary);
      __publicField(this, "lastState", false);
    }
    process(_) {
      const newState = SimVar.GetSimVarValue("L:A32NX_ADIRS_USES_GPS_AS_PRIMARY", "Bool") === 1;
      if (newState !== this.lastState) {
        this.lastState = newState;
        return newState ? 1 /* SEND */ : 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };

  // src/systems/fmgc/src/components/fms-messages/GpsPrimaryLost.ts
  var GpsPrimaryLost = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.GpsPrimaryLost);
      __publicField(this, "confLost", new ConfirmationNode(1e3));
      __publicField(this, "trigLost", new Trigger(true));
      __publicField(this, "confRegained", new ConfirmationNode(1e3));
      __publicField(this, "trigRegained", new Trigger(true));
    }
    process(deltaTime) {
      const lostNow = SimVar.GetSimVarValue("L:A32NX_ADIRS_USES_GPS_AS_PRIMARY", "Bool") === 0;
      this.confLost.input = lostNow;
      this.confLost.update(deltaTime);
      this.trigLost.input = this.confLost.output;
      this.trigLost.update(deltaTime);
      this.confRegained.input = !lostNow;
      this.confRegained.update(deltaTime);
      this.trigRegained.input = this.confRegained.output;
      this.trigRegained.update(deltaTime);
      if (this.trigLost.output) {
        return 1 /* SEND */;
      }
      if (this.trigRegained.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };

  // src/systems/fmgc/src/components/fms-messages/MapPartlyDisplayed.ts
  var MapPartlyDisplayed = class {
    constructor() {
      __publicField(this, "message", FMMessageTypes.MapPartlyDisplayed);
      __publicField(this, "trigRising", new Trigger(true));
      __publicField(this, "trigFalling", new Trigger(true));
    }
    process(deltaTime) {
      const partlyDisplayed = SimVar.GetSimVarValue(`L:A32NX_EFIS_${this.efisSide}_MAP_PARTLY_DISPLAYED`, "boolean");
      this.trigRising.input = partlyDisplayed === 1;
      this.trigRising.update(deltaTime);
      this.trigFalling.input = partlyDisplayed === 0;
      this.trigFalling.update(deltaTime);
      if (this.trigRising.output) {
        return 1 /* SEND */;
      }
      if (this.trigFalling.output) {
        return 2 /* RECALL */;
      }
      return 0 /* NO_ACTION */;
    }
  };
  var MapPartlyDisplayedLeft = class extends MapPartlyDisplayed {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "L");
    }
  };
  var MapPartlyDisplayedRight = class extends MapPartlyDisplayed {
    constructor() {
      super(...arguments);
      __publicField(this, "efisSide", "R");
    }
  };

  // src/systems/fmgc/src/components/fms-messages/FmsMessages.ts
  var FmsMessages = class {
    constructor() {
      __publicField(this, "listener", RegisterViewListener("JS_LISTENER_SIMVARS", null, true));
      __publicField(this, "baseInstrument");
      __publicField(this, "ndMessageFlags", {
        L: 0,
        R: 0
      });
      __publicField(this, "messageSelectors", [
        new GpsPrimary(),
        new GpsPrimaryLost(),
        new MapPartlyDisplayedLeft(),
        new MapPartlyDisplayedRight(),
        new TurnAreaExceedanceLeft(),
        new TurnAreaExceedanceRight(),
        new TuneNavaidLeft(),
        new TuneNavaidRight(),
        new SpecifiedVorUnavailableLeft(),
        new SpecifiedVorUnavailableRight(),
        new SpecifiedNdbUnavailableLeft(),
        new SpecifiedNdbUnavailableRight(),
        new RwyLsMismatchLeft(),
        new RwyLsMismatchRight(),
        new TdReached(),
        new StepAhead(),
        new StepDeleted()
      ]);
    }
    init(baseInstrument, _flightPlanManager) {
      this.baseInstrument = baseInstrument;
      for (const selector of this.messageSelectors) {
        if (selector.init) {
          selector.init(this.baseInstrument);
        }
      }
    }
    update(deltaTime) {
      let didMutateNd = false;
      for (const selector of this.messageSelectors) {
        const newState = selector.process(deltaTime);
        const message = selector.message;
        switch (newState) {
          case FMMessageUpdate.SEND:
            if (message.text) {
              this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
            }
            if (message.ndFlag > 0) {
              if (selector.efisSide) {
                this.ndMessageFlags[selector.efisSide] |= message.ndFlag;
              } else {
                for (const side in this.ndMessageFlags) {
                  if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
                    this.ndMessageFlags[side] |= message.ndFlag;
                  }
                }
              }
              didMutateNd = true;
            }
            break;
          case FMMessageUpdate.RECALL:
            if (message.text) {
              this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text);
            }
            if (message.ndFlag > 0) {
              if (selector.efisSide) {
                this.ndMessageFlags[selector.efisSide] &= ~message.ndFlag;
              } else {
                for (const side in this.ndMessageFlags) {
                  if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
                    this.ndMessageFlags[side] &= ~message.ndFlag;
                  }
                }
              }
              didMutateNd = true;
            }
            break;
          case FMMessageUpdate.NO_ACTION:
            break;
          default:
            throw new Error("Invalid FM message update state");
        }
      }
      if (didMutateNd) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            SimVar.SetSimVarValue(`L:A32NX_EFIS_${side}_ND_FM_MESSAGE_FLAGS`, "number", this.ndMessageFlags[side]);
          }
        }
      }
    }
    send(messageClass) {
      const message = this.messageSelectors.find((it) => it instanceof messageClass).message;
      this.listener.triggerToAllSubscribers(FMMessageTriggers.SEND_TO_MCDU, message);
      if (message.ndFlag) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            this.ndMessageFlags[side] |= message.ndFlag;
            SimVar.SetSimVarValue(`L:A32NX_EFIS_${side}_ND_FM_MESSAGE_FLAGS`, "number", this.ndMessageFlags[side]);
          }
        }
      }
    }
    recall(messageClass) {
      const message = this.messageSelectors.find((it) => it instanceof messageClass).message;
      this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text);
      if (message.ndFlag) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            this.ndMessageFlags[side] &= ~message.ndFlag;
            SimVar.SetSimVarValue(`L:A32NX_EFIS_${side}_ND_FM_MESSAGE_FLAGS`, "number", this.ndMessageFlags[side]);
          }
        }
      }
    }
    recallId(id) {
      const message = this.messageSelectors.find((it) => it.message.id === id).message;
      this.listener.triggerToAllSubscribers(FMMessageTriggers.RECALL_FROM_MCDU_WITH_ID, message.text);
      if (message.ndFlag) {
        for (const side in this.ndMessageFlags) {
          if (Object.prototype.hasOwnProperty.call(this.ndMessageFlags, side)) {
            this.ndMessageFlags[side] &= ~message.ndFlag;
            SimVar.SetSimVarValue(`L:A32NX_EFIS_${side}_ND_FM_MESSAGE_FLAGS`, "number", this.ndMessageFlags[side]);
          }
        }
      }
    }
  };
  var FMMessageUpdate = /* @__PURE__ */ ((FMMessageUpdate2) => {
    FMMessageUpdate2[FMMessageUpdate2["NO_ACTION"] = 0] = "NO_ACTION";
    FMMessageUpdate2[FMMessageUpdate2["SEND"] = 1] = "SEND";
    FMMessageUpdate2[FMMessageUpdate2["RECALL"] = 2] = "RECALL";
    return FMMessageUpdate2;
  })(FMMessageUpdate || {});

  // src/systems/fmgc/src/components/index.ts
  var fmsMessages = new FmsMessages();
  var components = [
    fmsMessages,
    new EfisLabels(),
    new ReadySignal(),
    new FcuSync()
  ];

  // src/systems/fmgc/src/navigation/LandingSystemSelectionManager.ts
  var _LandingSystemSelectionManager = class {
    constructor(navigationProvider, fpm, facLoader) {
      this.navigationProvider = navigationProvider;
      this.fpm = fpm;
      this.facLoader = facLoader;
      __publicField(this, "ppos", { lat: 0, long: 0 });
      __publicField(this, "pposValid", false);
      __publicField(this, "flightPlanVersion", -1);
      __publicField(this, "_selectedIls", null);
      __publicField(this, "_selectedLocCourse", null);
      __publicField(this, "_selectedApproachBackcourse", false);
      __publicField(this, "_selectedGsSlope", null);
      __publicField(this, "flightPhaseManager");
      __publicField(this, "autotuneUpdateThrottler", new A32NX_Util.UpdateThrottler(3e4));
      __publicField(this, "inProcess", false);
      this.flightPhaseManager = getFlightPhaseManager();
    }
    async update(deltaTime) {
      const forceUpdate = this.fpm.currentFlightPlanVersion !== this.flightPlanVersion;
      this.flightPlanVersion = this.fpm.currentFlightPlanVersion;
      if (this.autotuneUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
        if (this.inProcess) {
          return;
        }
        this.inProcess = true;
        try {
          this.updatePpos();
          const phase = this.flightPhaseManager.phase;
          if (phase <= 1 /* Takeoff */) {
            await this.selectDepartureIls();
          } else if (phase >= 4 /* Descent */) {
            await this.selectApproachIls();
          } else if (this.pposValid) {
            const destination = this.fpm.getDestination(0 /* Active */);
            if (destination && distanceTo(this.ppos, destination.infos.coordinates) <= _LandingSystemSelectionManager.DESTINATION_TUNING_DISTANCE) {
              await this.selectApproachIls();
            }
          }
        } catch (e) {
          console.error("Failed to select ILS", e);
          this.resetSelectedIls();
        } finally {
          this.inProcess = false;
        }
      }
    }
    updatePpos() {
      const ppos = this.navigationProvider.getPpos();
      if (ppos === null) {
        this.pposValid = false;
      } else {
        this.ppos.lat = ppos.lat;
        this.ppos.long = ppos.long;
        this.pposValid = true;
      }
    }
    async selectDepartureIls() {
      const airport = this.fpm.getPersistentOrigin(0 /* Active */);
      const runway = this.fpm.getOriginRunway(0 /* Active */);
      if (await this.setIlsFromRunway(runway)) {
        return true;
      }
      if (await this.setIlsForRunwayFromApproaches(airport, runway)) {
        return true;
      }
      this.resetSelectedIls();
      return false;
    }
    async selectApproachIls() {
      const airport = this.fpm.getDestination(0 /* Active */);
      const approach = this.fpm.getApproach(0 /* Active */);
      if (this.isTunableApproach(approach == null ? void 0 : approach.approachType) && this.setIlsFromApproach(airport, approach, true)) {
        return true;
      }
      this.resetSelectedIls();
      return false;
    }
    async setIlsFromRunway(runway, icao, checkBothEnds = false) {
      var _a;
      if (!runway) {
        return false;
      }
      const frequencies = [runway.primaryILSFrequency];
      if (checkBothEnds) {
        frequencies.push(runway.secondaryILSFrequency);
      }
      for (const frequency of frequencies) {
        if (frequency.freqMHz > 0 && (!icao || frequency.icao === icao)) {
          if (frequency.icao === ((_a = this._selectedIls) == null ? void 0 : _a.icao)) {
            return true;
          }
          const loc = await this.facLoader.getFacilityRaw(frequency.icao, 1500, true);
          if (!loc) {
            return false;
          }
          this._selectedIls = loc;
          this._selectedLocCourse = frequency.localizerCourse;
          this._selectedGsSlope = frequency.hasGlideslope ? -frequency.glideslopeAngle : null;
          return true;
        }
      }
      return false;
    }
    async setIlsForRunwayFromApproaches(airport, runway) {
      if (airport && airport.infos && airport.infos.icao.charAt(0) === "A" && runway) {
        const approaches = airport.infos.approaches;
        for (const approach of approaches) {
          if (approach.approachType === ApproachType.APPROACH_TYPE_ILS && approach.runwayNumber === runway.number && approach.runwayDesignator === runway.designator && approach.finalLegs.length > 0) {
            return this.setIlsFromApproach(airport, approach);
          }
        }
      }
      return false;
    }
    async setIlsFromApproach(airport, approach, checkRunwayFrequencies = false) {
      var _a, _b;
      const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
      if (((_a = finalLeg == null ? void 0 : finalLeg.originIcao.trim()) != null ? _a : "").length === 0) {
        return false;
      }
      if (finalLeg.originIcao === ((_b = this._selectedIls) == null ? void 0 : _b.icao)) {
        return true;
      }
      if (checkRunwayFrequencies) {
        const runway = airport.infos.oneWayRunways.find((r) => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
        if (runway && await this.setIlsFromRunway(runway, finalLeg.originIcao, true)) {
          return true;
        }
      }
      const loc = await this.facLoader.getFacilityRaw(finalLeg.originIcao, 1500, true);
      if (!loc) {
        return false;
      }
      this._selectedIls = loc;
      const courseSlope = await this.getIlsCourseSlopeFromApproach(airport, approach, loc);
      if (courseSlope !== null) {
        this._selectedApproachBackcourse = courseSlope.backcourse;
        this._selectedLocCourse = courseSlope.course;
        this._selectedGsSlope = courseSlope.slope;
      } else {
        this._selectedApproachBackcourse = false;
        this._selectedLocCourse = null;
        this._selectedGsSlope = null;
      }
      return true;
    }
    async getIlsCourseSlopeFromApproach(airport, approach, ils) {
      const runway = airport.infos.oneWayRunways.find((r) => r.number === approach.runwayNumber && r.designator === approach.runwayDesignator);
      if (runway) {
        const frequencies = [runway.primaryILSFrequency, runway.secondaryILSFrequency];
        for (const frequency of frequencies) {
          if (frequency.freqMHz > 0 && frequency.icao === ils.icao) {
            _LandingSystemSelectionManager.courseSlopeCache.backcourse = approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE;
            _LandingSystemSelectionManager.courseSlopeCache.course = frequency.localizerCourse;
            _LandingSystemSelectionManager.courseSlopeCache.slope = frequency.hasGlideslope ? -frequency.glideslopeAngle : null;
            return _LandingSystemSelectionManager.courseSlopeCache;
          }
        }
      }
      const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
      if (!finalLeg) {
        return null;
      }
      let finalLegCourse = finalLeg.trueDegrees ? A32NX_Util.trueToMagnetic(finalLeg.course, -ils.magneticVariation) : finalLeg.course;
      if (finalLeg.type === 18 /* TF */) {
        const previousLeg = approach.finalLegs[approach.finalLegs.length - 2];
        if (!previousLeg || !previousLeg.fixIcao.trim() || !finalLeg.fixIcao.trim()) {
          return null;
        }
        const finalWp = await this.facLoader.getFacility(finalLeg.fixIcao);
        const previousWp = await this.facLoader.getFacility(previousLeg.fixIcao);
        if (!finalWp || !previousWp) {
          return null;
        }
        finalLegCourse = A32NX_Util.trueToMagnetic(bearingTo(
          previousWp.infos.coordinates,
          finalWp.infos.coordinates
        ), -ils.magneticVariation);
      }
      const ilsApproachExists = airport.infos.approaches.find(
        (a) => a.approachType === ApproachType.APPROACH_TYPE_ILS && a.runwayNumber === approach.runwayNumber && a.runwayDesignator === approach.runwayDesignator
      ) !== void 0;
      _LandingSystemSelectionManager.courseSlopeCache.backcourse = approach.approachType === ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE;
      _LandingSystemSelectionManager.courseSlopeCache.course = _LandingSystemSelectionManager.courseSlopeCache.backcourse ? finalLegCourse + 180 : finalLegCourse;
      _LandingSystemSelectionManager.courseSlopeCache.slope = finalLeg.verticalAngle && ilsApproachExists ? finalLeg.verticalAngle - 360 : null;
      return _LandingSystemSelectionManager.courseSlopeCache;
    }
    resetSelectedIls() {
      this._selectedIls = null;
      this._selectedLocCourse = null;
      this._selectedApproachBackcourse = false;
      this._selectedGsSlope = null;
    }
    isTunableApproach(approachType) {
      switch (approachType) {
        case ApproachType.APPROACH_TYPE_ILS:
        case ApproachType.APPROACH_TYPE_LOCALIZER:
        case ApproachType.APPROACH_TYPE_LDA:
        case ApproachType.APPROACH_TYPE_SDF:
          return true;
        default:
          return false;
      }
    }
    async tryGetCourseSlopeForIlsFromAirport(ils, airport) {
      for (const approach of airport.infos.approaches) {
        if (approach.approachType !== ApproachType.APPROACH_TYPE_ILS) {
          continue;
        }
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        if (!finalLeg) {
          continue;
        }
        if (finalLeg.originIcao === ils.icao) {
          const data = await this.getIlsCourseSlopeFromApproach(airport, approach, ils);
          if (data !== null) {
            return [data.course, data.slope];
          }
        }
      }
      return null;
    }
    async tryGetCourseSlopeForIls(ils) {
      const flightPlan = this.fpm.activeFlightPlan;
      if (flightPlan.destinationAirfield) {
        const ret = await this.tryGetCourseSlopeForIlsFromAirport(ils, flightPlan.destinationAirfield);
        if (ret !== null) {
          return ret;
        }
      }
      if (flightPlan.originAirfield) {
        const ret = await this.tryGetCourseSlopeForIlsFromAirport(ils, flightPlan.originAirfield);
        if (ret !== null) {
          return ret;
        }
      }
      const airportIdent = ils.icao.slice(3, 7).trim();
      if (airportIdent.length === 4) {
        const airport = await this.facLoader.getFacility(`A      ${airportIdent}`);
        if (airport) {
          const ret = await this.tryGetCourseSlopeForIlsFromAirport(ils, airport);
          if (ret !== null) {
            return ret;
          }
        }
      }
      return [null, null];
    }
    get selectedIls() {
      return this._selectedIls;
    }
    get selectedLocCourse() {
      return this._selectedLocCourse !== null ? Math.round(this._selectedLocCourse % 360) : null;
    }
    get selectedApprBackcourse() {
      return this._selectedApproachBackcourse;
    }
    get selectedGsSlope() {
      return this._selectedGsSlope;
    }
    resetState() {
      this.resetSelectedIls();
    }
  };
  var LandingSystemSelectionManager = _LandingSystemSelectionManager;
  __publicField(LandingSystemSelectionManager, "DESTINATION_TUNING_DISTANCE", 300);
  __publicField(LandingSystemSelectionManager, "courseSlopeCache", {
    course: null,
    backcourse: false,
    slope: null
  });

  // src/systems/shared/src/array.ts
  function arrayFlat(arr, depth = 1) {
    return depth > 0 ? arr.reduce((acc, cur) => {
      if (Array.isArray(cur)) {
        acc.push(...arrayFlat(cur, depth - 1));
      } else {
        acc.push(cur);
      }
      return acc;
    }, []) : arr.slice();
  }

  // src/systems/fmgc/src/navigation/NavaidSelectionManager.ts
  var _NavaidSelectionManager = class {
    constructor(navigationProvider, fpm) {
      this.navigationProvider = navigationProvider;
      this.fpm = fpm;
      __publicField(this, "nearbyFacilities", NearbyFacilities.getInstance());
      __publicField(this, "candidateUpdateThrottler", new A32NX_Util.UpdateThrottler(180));
      __publicField(this, "dmePairUpdateThrottler", new A32NX_Util.UpdateThrottler(10));
      __publicField(this, "autotuneUpdateThrottler", new A32NX_Util.UpdateThrottler(1));
      __publicField(this, "ppos", { lat: 0, long: 0 });
      __publicField(this, "epe", Infinity);
      __publicField(this, "pposValid", false);
      __publicField(this, "altitude", 0);
      __publicField(this, "horizonDistance", 40);
      __publicField(this, "coneOfConfusionDistance", 0);
      __publicField(this, "candidateList", []);
      __publicField(this, "vorCandidateList", []);
      __publicField(this, "blackList", /* @__PURE__ */ new Map());
      __publicField(this, "selectedDisplayVor", null);
      __publicField(this, "selectedDisplayVorReason", 0 /* None */);
      __publicField(this, "selectedDmePair", null);
      __publicField(this, "selectedNdb", null);
      __publicField(this, "deselectedFacilities", /* @__PURE__ */ new Set());
      __publicField(this, "specifiedVorDeselected", false);
      __publicField(this, "specifiedNdbDeselected", false);
      __publicField(this, "filteredHeight", null);
    }
    update(deltaTime, forceUpdate = false) {
      this.updatePpos();
      this.updateAltitude();
      if (this.pposValid) {
        if (this.candidateUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
          this.updateCandidateList();
        }
        try {
          if (this.dmePairUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
            this.selectDmePair();
          }
        } catch (e) {
          console.error("Error in DME pair selection", e);
        }
        try {
          if (this.autotuneUpdateThrottler.canUpdate(deltaTime, forceUpdate) > -1) {
            this.selectDisplayVor();
            this.selectDisplayNdb();
          }
        } catch (e) {
          console.error("Error in display VOR selection", e);
        }
      }
    }
    updatePpos() {
      const ppos = this.navigationProvider.getPpos();
      if (ppos === null) {
        this.pposValid = false;
        this.selectedDisplayVor = null;
        this.selectedDmePair = null;
      } else {
        this.ppos.lat = ppos.lat;
        this.ppos.long = ppos.long;
        this.pposValid = true;
      }
      this.epe = this.navigationProvider.getEpe();
    }
    updateAltitude() {
      var _a;
      const baroAltitude = (_a = this.navigationProvider.getBaroCorrectedAltitude()) != null ? _a : this.navigationProvider.getPressureAltitude();
      if (baroAltitude !== null) {
        const height = SimVar.GetSimVarValue("PLANE ALT ABOVE GROUND", "feet");
        if (this.filteredHeight === null) {
          this.filteredHeight = height;
        } else {
          this.filteredHeight = 0.01 * height + 0.99 * this.filteredHeight;
        }
        this.altitude = this.filteredHeight;
        const planeAltNm = this.altitude / 6076.12;
        this.horizonDistance = Math.sqrt(planeAltNm * (2 * EARTH_RADIUS + planeAltNm));
        this.coneOfConfusionDistance = planeAltNm * Math.tan(Math.PI / 6);
      }
    }
    updateCandidateList() {
      this.candidateList.length = 0;
      this.vorCandidateList.length = 0;
      const frequencies = /* @__PURE__ */ new Set();
      const duplicateFrequencies = /* @__PURE__ */ new Set();
      for (const facility of this.nearbyFacilities.getVhfNavaids()) {
        if (!this.isSuitableType(facility)) {
          continue;
        }
        const distance = distanceTo(this.ppos, { lat: facility.lat, long: facility.lon });
        if (this.isInLineOfSight(distance)) {
          if (frequencies.has(facility.freqBCD16)) {
            duplicateFrequencies.add(facility.freqBCD16);
          }
          frequencies.add(facility.freqBCD16);
        }
        const candidate = __spreadValues({ distance }, facility);
        if (this.isEligibleCandidate(facility, distance)) {
          this.candidateList.push(candidate);
        }
        if (this.isEligibleDisplayVor(facility, distance)) {
          this.vorCandidateList.push(candidate);
        }
      }
      for (let i = this.candidateList.length - 1; i >= 0; i--) {
        const facility = this.candidateList[i];
        if (duplicateFrequencies.has(facility.freqBCD16)) {
          this.candidateList.splice(i, 1);
        }
      }
      this.candidateList.sort((a, b) => a.distance - b.distance);
      this.vorCandidateList.sort((a, b) => a.distance - b.distance);
      this.vorCandidateList.length = Math.min(this.vorCandidateList.length, 7);
    }
    isEligibleCandidate(facility, distance) {
      return !this.isBlackListed(facility) && !this.isDeselected(facility) && this.isInLineOfSight(distance) && this.isWithinFom(facility, distance) && !this.isWithinConeOfConfusion(facility, distance) && this.isWithinGroundRange(distance);
    }
    isEligibleDisplayVor(facility, distance) {
      return this.isVor(facility) && this.isWithinFom(facility, distance) && !this.isDeselected(facility);
    }
    isVor(facility) {
      return this.typeIsVor(facility.type);
    }
    typeIsVor(type) {
      return type === 1 /* VOR */ || type === 2 /* VORDME */ || type === 5 /* VORTAC */;
    }
    isVorDme(facility) {
      return facility.type === 2 /* VORDME */ || facility.type === 5 /* VORTAC */;
    }
    isBlackListed(facility) {
      return this.blackList.has(facility.icao);
    }
    isDeselected(facility) {
      return this.deselectedFacilities.has(facility.icao);
    }
    isInLineOfSight(distance) {
      return distance <= Math.max(10, 7 / 6 * this.horizonDistance);
    }
    isWithinFom(facility, distance) {
      if (distance === void 0) {
        distance = distanceTo(this.ppos, { lat: facility.lat, long: facility.lon });
      }
      switch (facility.vorClass) {
        case 3 /* HighAlttitude */:
        case 0 /* Unknown */:
          return distance <= 130;
        case 2 /* LowAltitude */:
          return distance <= 70 && this.altitude < 18e3;
        case 1 /* Terminal */:
          return distance <= 40 && this.altitude < 12e3;
        default:
          return false;
      }
    }
    isWithinConeOfConfusion(facility, distance) {
      return distance < this.coneOfConfusionDistance;
    }
    isWithinGroundRange(distance) {
      return distance >= Math.min(9, Math.max(1, this.epe));
    }
    isSuitableType(facility) {
      return facility.vorClass !== 5 /* VOT */ && facility.type !== 4 /* TACAN */ && facility.type !== 6 /* ILS */;
    }
    selectDmePair() {
      let findNewPair = this.selectedDmePair === null;
      let geometryCheck = false;
      if (this.selectedDmePair !== null) {
        const angle = this.calcDmePairAngle(this.selectedDmePair[0], this.selectedDmePair[1]);
        geometryCheck = angle < 70 || angle > 110;
        findNewPair = findNewPair || (!this.candidateList.some((v) => v.icao === this.selectedDmePair[0].icao) || !this.candidateList.some((v) => v.icao === this.selectedDmePair[1].icao));
      }
      if (findNewPair || geometryCheck) {
        const pairs = arrayFlat(this.candidateList.map((a, i) => this.candidateList.slice(i + 1).map((b) => [a, b])));
        let bestAngleDiff = Infinity;
        let bestPair = null;
        for (const [a, b] of pairs) {
          const angle = this.calcDmePairAngle(a, b);
          const validPair = angle > 30 && angle < 150;
          if (validPair) {
            if (this.altitude < 12e3) {
              this.selectedDmePair = [a, b];
              return;
            }
            const angleDiff = Math.abs(diffAngle(90, angle));
            if (angleDiff < bestAngleDiff) {
              bestPair = [a, b];
              bestAngleDiff = angleDiff;
            }
          }
        }
        if (geometryCheck) {
          const currentPairAngleDiff = Math.abs(diffAngle(90, this.calcDmePairAngle(this.selectedDmePair[0], this.selectedDmePair[1])));
          if (currentPairAngleDiff - bestAngleDiff >= 10) {
            this.selectedDmePair = bestPair;
          }
        } else {
          this.selectedDmePair = bestPair;
        }
      }
    }
    calcDmePairAngle(a, b) {
      const bearingA = bearingTo(this.ppos, { lat: a.lat, long: a.lon });
      const bearingB = bearingTo(this.ppos, { lat: b.lat, long: b.lon });
      return Math.abs(diffAngle(bearingA, bearingB));
    }
    getSpecifiedNavaid() {
      var _a;
      if (_NavaidSelectionManager.SPECIFIED_VOR_APPROACH_TYPES.includes(this.fpm.getApproachType(0 /* Active */))) {
        const waypoints = this.fpm.getApproachWaypoints(0 /* Active */);
        const finalLeg = waypoints[waypoints.length - 2];
        const facility = ((_a = finalLeg == null ? void 0 : finalLeg.additionalData.recommendedFacility) == null ? void 0 : _a.__Type) === "JS_FacilityVOR" ? finalLeg.additionalData.recommendedFacility : null;
        if (facility !== null && this.isVor(facility)) {
          return facility;
        }
      }
      return null;
    }
    selectDisplayVor() {
      var _a;
      this.specifiedVorDeselected = false;
      if (this.fpm.isActiveApproach(0 /* Active */)) {
        const specified = this.getSpecifiedNavaid();
        if (specified !== null) {
          if (this.isDeselected(specified)) {
            this.specifiedVorDeselected = true;
          } else {
            this.setDisplayVor(specified, 4 /* Procedure */);
            return;
          }
        }
      }
      if (this.selectedDmePair === null) {
        const refNavaid = this.getReferenceNavaid();
        if (refNavaid !== null) {
          this.setDisplayVor(refNavaid, 3 /* Navigation */);
          return;
        }
        const colocated = this.getNearestColocatedNavaid();
        if (colocated !== null) {
          this.setDisplayVor(colocated, 3 /* Navigation */);
          return;
        }
      }
      const activeLegIndex = this.fpm.getActiveWaypointIndex(false, false, 0 /* Active */);
      if (activeLegIndex >= 0) {
        for (let i = activeLegIndex; i < activeLegIndex + 5; i++) {
          const leg = this.fpm.getWaypoint(i, 0 /* Active */, true);
          if (!leg) {
            break;
          }
          const facility = ((_a = leg.additionalData.facility) == null ? void 0 : _a.__Type) === "JS_FacilityVOR" ? leg.additionalData.facility : null;
          if (facility !== null && this.isVor(facility) && this.isWithinFom(facility)) {
            this.setDisplayVor(facility, 2 /* Route */);
            return;
          }
        }
      }
      if (this.vorCandidateList.length > 0 && this.displayVor !== null) {
        const currentVor = this.vorCandidateList.find((v) => v.icao === this.displayVor.icao);
        const replaceCurrentVor = !currentVor || this.selectedDisplayVorReason !== 1 /* Display */ || currentVor.distance - this.vorCandidateList[0].distance > _NavaidSelectionManager.DISPLAY_VOR_STICKINESS_THRESHOLD;
        if (replaceCurrentVor) {
          this.setDisplayVor(this.vorCandidateList[0], 1 /* Display */);
        }
      } else if (this.vorCandidateList.length > 0) {
        this.setDisplayVor(this.vorCandidateList[0], 1 /* Display */);
      } else {
        this.setDisplayVor(null, 0 /* None */);
      }
    }
    getNearestColocatedNavaid() {
      for (const candidate of this.candidateList) {
        if (this.isVorDme(candidate)) {
          return candidate;
        }
      }
      return null;
    }
    getReferenceNavaid() {
      const destRunway = this.fpm.getDestinationRunway(0 /* Active */);
      if (!destRunway) {
        return null;
      }
      const candidates = this.candidateList.filter((v) => this.isVorDme(v) && v.distance < 51);
      candidates.sort((a, b) => distanceTo(destRunway.thresholdCoordinates, { lat: a.lat, long: a.lon }) - distanceTo(destRunway.thresholdCoordinates, { lat: b.lat, long: b.lon }));
      if (candidates.length > 0 && distanceTo(destRunway.thresholdCoordinates, { lat: candidates[0].lat, long: candidates[0].lon }) < 5) {
        return candidates[0];
      }
      return null;
    }
    getSpecifiedNdb() {
      var _a;
      if (_NavaidSelectionManager.SPECIFIED_NDB_APPROACH_TYPES.includes(this.fpm.getApproachType(0 /* Active */))) {
        const waypoints = this.fpm.getApproachWaypoints(0 /* Active */);
        const finalLeg = waypoints[waypoints.length - 2];
        const facility = ((_a = finalLeg == null ? void 0 : finalLeg.additionalData.recommendedFacility) == null ? void 0 : _a.__Type) === "JS_FacilityNDB" ? finalLeg.additionalData.recommendedFacility : null;
        if (facility !== null) {
          return facility;
        }
      }
      return null;
    }
    selectDisplayNdb() {
      this.specifiedNdbDeselected = false;
      if (this.fpm.isActiveApproach(0 /* Active */)) {
        const specified = this.getSpecifiedNdb();
        if (specified !== null) {
          if (this.isDeselected(specified)) {
            this.specifiedNdbDeselected = true;
          } else {
            this.setDisplayNdb(specified);
            return;
          }
        }
      }
      this.setDisplayNdb(null);
    }
    setDisplayNdb(ndb) {
      this.selectedNdb = ndb;
    }
    setDisplayVor(vor, reason) {
      this.selectedDisplayVor = vor;
      this.selectedDisplayVorReason = reason;
    }
    get displayVor() {
      return this.selectedDisplayVor;
    }
    get displayVorReason() {
      return this.selectedDisplayVorReason;
    }
    get displayNdb() {
      return this.selectedNdb;
    }
    get displayNdbReason() {
      return this.selectedNdb !== null ? 1 /* Display */ : 0 /* None */;
    }
    get dmePair() {
      return this.selectedDmePair;
    }
    deselectNavaid(icao) {
      this.deselectedFacilities.add(icao);
      this.update(0, true);
    }
    reselectNavaid(icao) {
      this.deselectedFacilities.delete(icao);
      this.update(0, true);
    }
    get deselectedNavaids() {
      return Array.from(this.deselectedFacilities);
    }
    get isSpecifiedVorDeselected() {
      return this.specifiedVorDeselected;
    }
    get isSpecifiedNdbDeselected() {
      return this.specifiedNdbDeselected;
    }
    resetState() {
      this.candidateList.length = 0;
      this.vorCandidateList.length = 0;
      this.blackList.clear();
      this.selectedDisplayVor = null;
      this.selectedDisplayVorReason = 0 /* None */;
      this.selectedDmePair = null;
      this.selectedNdb = null;
      this.deselectedFacilities.clear();
      this.specifiedVorDeselected = false;
      this.specifiedNdbDeselected = false;
    }
  };
  var NavaidSelectionManager = _NavaidSelectionManager;
  __publicField(NavaidSelectionManager, "DISPLAY_VOR_STICKINESS_THRESHOLD", 2);
  __publicField(NavaidSelectionManager, "SPECIFIED_VOR_APPROACH_TYPES", [ApproachType.APPROACH_TYPE_RNAV, ApproachType.APPROACH_TYPE_VOR, ApproachType.APPROACH_TYPE_VORDME]);
  __publicField(NavaidSelectionManager, "SPECIFIED_NDB_APPROACH_TYPES", [ApproachType.APPROACH_TYPE_NDB, ApproachType.APPROACH_TYPE_NDBDME]);

  // src/systems/fmgc/src/navigation/NavRadioUtils.ts
  var NavRadioUtils = class {
    static vhfFrequenciesAreEqual(a, b) {
      return Math.abs((a != null ? a : 0) - (b != null ? b : 0)) < 0.01;
    }
  };

  // src/systems/fmgc/src/navigation/NavaidTuner.ts
  var _NavaidTuner = class {
    constructor(navigationProvider, navaidSelectionManager, landingSystemSelectionManager) {
      this.navigationProvider = navigationProvider;
      this.navaidSelectionManager = navaidSelectionManager;
      this.landingSystemSelectionManager = landingSystemSelectionManager;
      __publicField(this, "vorTuningStatus", [
        {
          frequency: null,
          ident: null,
          manual: false,
          course: null,
          dmeOnly: false
        },
        {
          frequency: null,
          ident: null,
          manual: false,
          course: null,
          dmeOnly: false
        }
      ]);
      __publicField(this, "mmrTuningStatus", [
        {
          databaseCourse: null,
          databaseBackcourse: false,
          frequency: null,
          course: null,
          courseManual: false,
          ident: null,
          manual: false,
          backcourse: false,
          slope: null
        },
        {
          databaseCourse: null,
          databaseBackcourse: false,
          frequency: null,
          course: null,
          courseManual: false,
          ident: null,
          manual: false,
          backcourse: false,
          slope: null
        }
      ]);
      __publicField(this, "adfTuningStatus", [
        {
          frequency: null,
          ident: null,
          manual: false,
          bfo: false
        },
        {
          frequency: null,
          ident: null,
          manual: false,
          bfo: false
        }
      ]);
      __publicField(this, "lastVorFrequencies", [null, null]);
      __publicField(this, "lastVorCourses", [null, null]);
      __publicField(this, "lastMmrFrequencies", [null, null]);
      __publicField(this, "lastMmrCourses", [null, null]);
      __publicField(this, "lastAdfFrequencies", [null, null]);
      __publicField(this, "navaidVersion", 0);
      __publicField(this, "rmpTuningActive", false);
      __publicField(this, "arincNavDiscrete", Arinc429Word.empty());
      __publicField(this, "lastArincNavDiscreteValueWritten", null);
      __publicField(this, "tuneNavaidMessage", null);
      __publicField(this, "rwyLsMismatchMessage", false);
      __publicField(this, "tuningLockoutTimer", -1);
      __publicField(this, "tuningActive", false);
      __publicField(this, "flightPhaseManager");
      __publicField(this, "blockEventMessageShown", false);
      __publicField(this, "tipsManager");
      this.flightPhaseManager = getFlightPhaseManager();
    }
    init() {
      this.resetAllReceivers();
      this.tipsManager = A32NX_TipsManager.instance;
      Coherent.on("keyIntercepted", this.handleKeyEvent.bind(this));
      _NavaidTuner.TUNING_EVENT_INTERCEPTS.forEach((key) => Coherent.call("INTERCEPT_KEY_EVENT", key, 1));
    }
    update(deltaTime) {
      const rmpTuningActive = SimVar.GetSimVarValue("L:A32NX_RMP_L_NAV_BUTTON_SELECTED", "bool") || SimVar.GetSimVarValue("L:A32NX_RMP_R_NAV_BUTTON_SELECTED", "bool");
      const rmpTuningDeActivated = !rmpTuningActive && this.rmpTuningActive;
      this.rmpTuningActive = rmpTuningActive;
      if (rmpTuningDeActivated) {
        this.resetAllReceivers();
        this.tuningLockoutTimer = _NavaidTuner.DELAY_AFTER_RMP_TUNING;
      }
      const tuningActive = !this.rmpTuningActive && this.tuningLockoutTimer <= 0;
      const tuningDeActivated = !tuningActive && this.tuningActive;
      this.tuningActive = tuningActive;
      if (tuningDeActivated) {
        this.resetAllReceivers();
      }
      if (this.tuningActive) {
        this.updateNavaidSelection();
        this.rwyLsMismatchMessage = this.hasRunwayLsMismatch(1) || this.hasRunwayLsMismatch(2);
      } else if (this.tuningLockoutTimer > 0) {
        this.tuningLockoutTimer -= deltaTime;
      }
      this.updateArincBus();
    }
    handleKeyEvent(key, value1, value0, value2) {
      var _a;
      if (_NavaidTuner.TUNING_EVENT_INTERCEPTS.includes(key)) {
        if (this.rmpTuningActive) {
          Coherent.call("TRIGGER_KEY_EVENT", key, true, value0 != null ? value0 : 0, value1 != null ? value1 : 0, value2 != null ? value2 : 0);
        } else if (!this.blockEventMessageShown) {
          (_a = this.tipsManager) == null ? void 0 : _a.showNavRadioTuningTip();
          this.blockEventMessageShown = true;
        }
      }
    }
    resetAllReceivers() {
      this.tuneVorFrequency(1, null);
      this.tuneVorCourse(1, null);
      this.tuneVorFrequency(2, null);
      this.tuneVorCourse(2, null);
      this.tuneMmrIlsFrequency(1, null);
      this.tuneMmrCourse(1, null);
      this.tuneMmrIlsFrequency(2, null);
      this.tuneMmrCourse(2, null);
      this.tuneAdf(1, null);
      this.tuneAdf(2, null);
    }
    updateArincBus() {
      for (const [i, vor] of this.vorTuningStatus.entries()) {
        this.arincNavDiscrete.setBitValue(11 + i, this.tuningActive && vor.manual);
      }
      for (const [i, adf] of this.adfTuningStatus.entries()) {
        this.arincNavDiscrete.setBitValue(13 + i, this.tuningActive && adf.manual);
      }
      for (const [i, mmr] of this.mmrTuningStatus.entries()) {
        this.arincNavDiscrete.setBitValue(15 + i, this.tuningActive && mmr.manual);
      }
      const ssm = this.tuningActive ? 3 /* NormalOperation */ : 1 /* NoComputedData */;
      if (ssm !== this.arincNavDiscrete.ssm || this.lastArincNavDiscreteValueWritten !== this.arincNavDiscrete.value) {
        this.arincNavDiscrete.ssm = ssm;
        this.writeNavDiscreteToBus();
      }
    }
    writeNavDiscreteToBus() {
      Arinc429Word.toSimVarValue("L:A32NX_FM1_NAV_DISCRETE", this.arincNavDiscrete.value, this.arincNavDiscrete.ssm);
      this.lastArincNavDiscreteValueWritten = this.arincNavDiscrete.value;
    }
    updateNavaidSelection() {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      let tuneNavaidMessage = null;
      for (const [i, vor] of this.vorTuningStatus.entries()) {
        const autoFacility = (_a = this.navaidSelectionManager.displayVor) != null ? _a : void 0;
        if (vor.manual) {
          const autoReason = this.navaidSelectionManager.displayVorReason;
          if ((autoReason === 3 /* Navigation */ || autoReason === 4 /* Procedure */) && !NavRadioUtils.vhfFrequenciesAreEqual(autoFacility == null ? void 0 : autoFacility.freqMHz, vor.frequency)) {
            tuneNavaidMessage = [autoFacility == null ? void 0 : autoFacility.freqMHz, WayPoint.formatIdentFromIcao(autoFacility == null ? void 0 : autoFacility.icao)];
          }
        } else if (((_b = vor.facility) == null ? void 0 : _b.icao) !== (autoFacility == null ? void 0 : autoFacility.icao)) {
          vor.course = null;
          vor.facility = autoFacility;
          vor.frequency = (_c = autoFacility == null ? void 0 : autoFacility.freqMHz) != null ? _c : null;
          vor.ident = (autoFacility == null ? void 0 : autoFacility.icao) ? WayPoint.formatIdentFromIcao(autoFacility.icao) : null;
          vor.dmeOnly = this.isDmeOnly(autoFacility);
        }
        this.tuneVorFrequency(i + 1, vor.frequency);
        this.tuneVorCourse(i + 1, vor.course);
      }
      for (const [i, mmr] of this.mmrTuningStatus.entries()) {
        const autoFacility = (_d = this.landingSystemSelectionManager.selectedIls) != null ? _d : void 0;
        const autoCourse = this.landingSystemSelectionManager.selectedLocCourse;
        if (!mmr.manual && ((_e = mmr.facility) == null ? void 0 : _e.icao) !== (autoFacility == null ? void 0 : autoFacility.icao) && autoCourse !== null) {
          mmr.databaseCourse = autoCourse;
          mmr.databaseBackcourse = this.landingSystemSelectionManager.selectedApprBackcourse;
          mmr.course = mmr.databaseCourse;
          mmr.courseManual = false;
          mmr.frequency = (_f = autoFacility == null ? void 0 : autoFacility.freqMHz) != null ? _f : null;
          mmr.facility = autoFacility;
          mmr.ident = (autoFacility == null ? void 0 : autoFacility.icao) ? WayPoint.formatIdentFromIcao(autoFacility.icao) : null;
          mmr.backcourse = this.landingSystemSelectionManager.selectedApprBackcourse;
          mmr.slope = this.landingSystemSelectionManager.selectedGsSlope;
        }
        this.tuneMmrIlsFrequency(i + 1, mmr.frequency);
        this.tuneMmrCourse(i + 1, mmr.course);
      }
      for (const [i, adf] of this.adfTuningStatus.entries()) {
        const autoFacility = (_g = this.navaidSelectionManager.displayNdb) != null ? _g : void 0;
        if (!adf.manual && ((_h = adf.facility) == null ? void 0 : _h.icao) !== (autoFacility == null ? void 0 : autoFacility.icao)) {
          adf.facility = autoFacility;
          adf.frequency = (_i = autoFacility == null ? void 0 : autoFacility.freqMHz) != null ? _i : null;
          adf.ident = (autoFacility == null ? void 0 : autoFacility.icao) ? WayPoint.formatIdentFromIcao(autoFacility.icao) : null;
        }
        this.tuneAdf(i + 1, adf.frequency);
      }
      if (this.tuneNavaidMessage !== tuneNavaidMessage) {
        this.tuneNavaidMessage = tuneNavaidMessage;
      }
    }
    async tuneVorFrequency(index, frequency) {
      if (!NavRadioUtils.vhfFrequenciesAreEqual(this.lastVorFrequencies[index - 1], frequency)) {
        this.lastVorFrequencies[index - 1] = frequency;
        this.navaidVersion++;
        return Coherent.call("TRIGGER_KEY_EVENT", `NAV${index}_RADIO_SET_HZ`, true, (frequency != null ? frequency : 0) * 1e6, 0, 0);
      }
      return false;
    }
    async tuneVorCourse(index, course) {
      if (Math.round(this.lastVorCourses[index - 1]) !== Math.round(course)) {
        this.lastVorCourses[index - 1] = course;
        return Coherent.call("TRIGGER_KEY_EVENT", `VOR${index}_SET`, true, course != null ? course : 0, 0, 0);
      }
      return false;
    }
    async tuneMmrIlsFrequency(index, frequency) {
      if (this.isMmrTuningLocked()) {
        return false;
      }
      if (!NavRadioUtils.vhfFrequenciesAreEqual(this.lastMmrFrequencies[index - 1], frequency)) {
        this.lastMmrFrequencies[index - 1] = frequency;
        this.navaidVersion++;
        return Coherent.call("TRIGGER_KEY_EVENT", `NAV${index + 2}_RADIO_SET_HZ`, true, (frequency != null ? frequency : 0) * 1e6, 0, 0);
      }
      return false;
    }
    async tuneMmrCourse(index, course) {
      if (this.isMmrTuningLocked()) {
        return false;
      }
      if (Math.round(this.lastMmrCourses[index - 1]) !== Math.round(course)) {
        this.lastMmrCourses[index - 1] = course;
        return Coherent.call("TRIGGER_KEY_EVENT", `VOR${index + 2}_SET`, true, course != null ? course : 0, 0, 0);
      }
      return false;
    }
    async tuneAdf(index, frequency) {
      if (!NavRadioUtils.vhfFrequenciesAreEqual(this.lastAdfFrequencies[index - 1], frequency)) {
        this.lastAdfFrequencies[index - 1] = frequency;
        this.navaidVersion++;
        return Coherent.call("TRIGGER_KEY_EVENT", `ADF${index > 1 ? index : ""}_COMPLETE_SET`, true, Avionics.Utils.make_adf_bcd32((frequency != null ? frequency : 0) * 1e3), 0, 0);
      }
      return false;
    }
    hasRunwayLsMismatch(index) {
      var _a, _b;
      const mmr = this.getMmrRadioTuningStatus(index);
      const databaseFrequency = (_b = (_a = this.landingSystemSelectionManager.selectedIls) == null ? void 0 : _a.freqMHz) != null ? _b : null;
      const databaseCourse = this.landingSystemSelectionManager.selectedLocCourse;
      if (mmr.frequency !== null && databaseFrequency !== null && !NavRadioUtils.vhfFrequenciesAreEqual(databaseFrequency, mmr.frequency)) {
        return true;
      }
      if (mmr.course !== null && databaseCourse !== null && Math.abs(mmr.course - databaseCourse) > 3) {
        return true;
      }
      return false;
    }
    isDmeOnly(facility) {
      switch (facility == null ? void 0 : facility.type) {
        case 3 /* DME */:
        case 4 /* TACAN */:
          return true;
        default:
          return false;
      }
    }
    isMmrTuningLocked() {
      var _a;
      return this.flightPhaseManager.phase === 5 /* Approach */ && ((_a = this.navigationProvider.getRadioHeight()) != null ? _a : Infinity) < 700;
    }
    get tunedVors() {
      return this.vorTuningStatus.map((vorStatus) => vorStatus.facility).filter((fac) => fac !== void 0);
    }
    get tunedNdbs() {
      return this.adfTuningStatus.map((adfStatus) => adfStatus.facility).filter((fac) => fac !== void 0);
    }
    deselectNavaid(icao) {
      this.navaidSelectionManager.deselectNavaid(icao);
    }
    reselectNavaid(icao) {
      this.navaidSelectionManager.reselectNavaid(icao);
    }
    get deselectedNavaids() {
      return this.navaidSelectionManager.deselectedNavaids;
    }
    setManualVor(index, vor) {
      const vorStatus = this.vorTuningStatus[index - 1];
      if (vor === null) {
        vorStatus.manual = false;
        vorStatus.facility = void 0;
        vorStatus.course = null;
        vorStatus.ident = null;
        vorStatus.frequency = null;
      } else if (typeof vor === "number") {
        vorStatus.manual = true;
        vorStatus.facility = void 0;
        vorStatus.course = null;
        vorStatus.ident = null;
        vorStatus.frequency = vor;
      } else {
        vorStatus.manual = true;
        vorStatus.facility = vor;
        vorStatus.course = null;
        vorStatus.ident = WayPoint.formatIdentFromIcao(vor.icao);
        vorStatus.frequency = vor.freqMHz;
      }
      vorStatus.dmeOnly = this.isDmeOnly(vorStatus.facility);
    }
    setVorCourse(index, course) {
      const vorStatus = this.vorTuningStatus[index - 1];
      vorStatus.course = course;
    }
    async setManualIls(ils) {
      let dbCourse = null;
      let dbSlope = null;
      if (ils !== null && typeof ils !== "number") {
        [dbCourse, dbSlope] = await this.landingSystemSelectionManager.tryGetCourseSlopeForIls(ils);
      }
      for (const mmrStatus of this.mmrTuningStatus) {
        if (ils === null) {
          mmrStatus.databaseCourse = null;
          mmrStatus.databaseBackcourse = false;
          mmrStatus.manual = false;
          mmrStatus.facility = void 0;
          mmrStatus.course = null;
          mmrStatus.courseManual = false;
          mmrStatus.ident = null;
          mmrStatus.frequency = null;
          mmrStatus.backcourse = false;
          mmrStatus.slope = null;
        } else if (typeof ils === "number") {
          mmrStatus.databaseCourse = null;
          mmrStatus.databaseBackcourse = false;
          mmrStatus.manual = true;
          mmrStatus.facility = void 0;
          mmrStatus.course = null;
          mmrStatus.courseManual = false;
          mmrStatus.ident = null;
          mmrStatus.frequency = ils;
          mmrStatus.backcourse = false;
          mmrStatus.slope = null;
        } else {
          mmrStatus.databaseCourse = dbCourse;
          mmrStatus.databaseBackcourse = false;
          mmrStatus.manual = true;
          mmrStatus.facility = ils;
          mmrStatus.course = dbCourse;
          mmrStatus.courseManual = false;
          mmrStatus.ident = WayPoint.formatIdentFromIcao(ils.icao);
          mmrStatus.frequency = ils.freqMHz;
          mmrStatus.backcourse = false;
          mmrStatus.slope = dbSlope;
        }
      }
    }
    setIlsCourse(course, backcourse = false) {
      for (const mmrStatus of this.mmrTuningStatus) {
        mmrStatus.course = course === null ? mmrStatus.databaseCourse : course % 360;
        mmrStatus.backcourse = course === null ? mmrStatus.databaseBackcourse : backcourse;
        mmrStatus.courseManual = course !== null;
      }
    }
    setManualAdf(index, ndb) {
      const adfStatus = this.adfTuningStatus[index - 1];
      if (ndb === null) {
        adfStatus.manual = false;
        adfStatus.facility = void 0;
        adfStatus.ident = null;
        adfStatus.frequency = null;
        adfStatus.bfo = false;
      } else if (typeof ndb === "number") {
        adfStatus.manual = true;
        adfStatus.facility = void 0;
        adfStatus.ident = null;
        adfStatus.frequency = ndb;
        adfStatus.bfo = false;
      } else {
        adfStatus.manual = true;
        adfStatus.facility = ndb;
        adfStatus.ident = WayPoint.formatIdentFromIcao(ndb.icao);
        adfStatus.frequency = ndb.freqMHz;
        adfStatus.bfo = false;
      }
    }
    getVorRadioTuningStatus(index) {
      return this.vorTuningStatus[index - 1];
    }
    getMmrRadioTuningStatus(index) {
      return this.mmrTuningStatus[index - 1];
    }
    getAdfRadioTuningStatus(index) {
      return this.adfTuningStatus[index - 1];
    }
    getTuneNavaidMessage() {
      return this.tuneNavaidMessage;
    }
    getRwyLsMismatchMessage() {
      return this.rwyLsMismatchMessage;
    }
    getSpecifiedVorMessage() {
      return this.navaidSelectionManager.isSpecifiedVorDeselected;
    }
    getSpecifiedNdbMessage() {
      return this.navaidSelectionManager.isSpecifiedNdbDeselected;
    }
    isFmTuningActive() {
      return this.tuningActive;
    }
    resetState() {
      for (let i = 1; i <= 2; i++) {
        const n = i;
        this.setManualAdf(n, null);
        this.setManualVor(n, null);
        this.setVorCourse(n, null);
      }
      this.setManualIls(null);
      this.setIlsCourse(null);
      this.tuningLockoutTimer = _NavaidTuner.DELAY_AFTER_RMP_TUNING;
    }
  };
  var NavaidTuner = _NavaidTuner;
  __publicField(NavaidTuner, "DELAY_AFTER_RMP_TUNING", 1e3);
  __publicField(NavaidTuner, "TUNING_EVENT_INTERCEPTS", [
    "ADF_1_DEC",
    "ADF2_1_DEC",
    "ADF_10_DEC",
    "ADF2_10_DEC",
    "ADF_100_DEC",
    "ADF2_100_DEC",
    "ADF_1_INC",
    "ADF2_1_INC",
    "ADF_10_INC",
    "ADF2_10_INC",
    "ADF_100_INC",
    "ADF2_100_INC",
    "ADF_ACTIVE_SET",
    "ADF2_ACTIVE_SET",
    "ADF_COMPLETE_SET",
    "ADF2_COMPLETE_SET",
    "ADF_EXTENDED_SET",
    "ADF2_EXTENDED_SET",
    "ADF_FRACT_DEC_CARRY",
    "ADF2_FRACT_DEC_CARRY",
    "ADF_FRACT_INC_CARRY",
    "ADF2_FRACT_INC_CARRY",
    "ADF_HIGHRANGE_SET",
    "ADF2_HIGHRANGE_SET",
    "ADF_LOWRANGE_SET",
    "ADF2_LOWRANGE_SET",
    "ADF1_RADIO_SWAP",
    "ADF2_RADIO_SWAP",
    "ADF1_RADIO_TENTHS_DEC",
    "ADF2_RADIO_TENTHS_DEC",
    "ADF1_RADIO_TENTHS_INC",
    "ADF2_RADIO_TENTHS_INC",
    "ADF_SET",
    "ADF2_SET",
    "ADF1_WHOLE_DEC",
    "ADF2_WHOLE_DEC",
    "ADF1_WHOLE_INC",
    "ADF2_WHOLE_INC",
    "NAV1_RADIO_FRACT_DEC",
    "NAV2_RADIO_FRACT_DEC",
    "NAV3_RADIO_FRACT_DEC",
    "NAV4_RADIO_FRACT_DEC",
    "NAV1_RADIO_FRACT_DEC_CARRY",
    "NAV2_RADIO_FRACT_DEC_CARRY",
    "NAV3_RADIO_FRACT_DEC_CARRY",
    "NAV4_RADIO_FRACT_DEC_CARRY",
    "NAV1_RADIO_FRACT_INC",
    "NAV2_RADIO_FRACT_INC",
    "NAV3_RADIO_FRACT_INC",
    "NAV4_RADIO_FRACT_INC",
    "NAV1_RADIO_FRACT_INC_CARRY",
    "NAV2_RADIO_FRACT_INC_CARRY",
    "NAV3_RADIO_FRACT_INC_CARRY",
    "NAV4_RADIO_FRACT_INC_CARRY",
    "NAV1_RADIO_SET",
    "NAV2_RADIO_SET",
    "NAV3_RADIO_SET",
    "NAV4_RADIO_SET",
    "NAV1_RADIO_SET_HZ",
    "NAV2_RADIO_SET_HZ",
    "NAV3_RADIO_SET_HZ",
    "NAV4_RADIO_SET_HZ",
    "NAV1_RADIO_SWAP",
    "NAV2_RADIO_SWAP",
    "NAV3_RADIO_SWAP",
    "NAV4_RADIO_SWAP",
    "NAV1_RADIO_WHOLE_DEC",
    "NAV2_RADIO_WHOLE_DEC",
    "NAV3_RADIO_WHOLE_DEC",
    "NAV4_RADIO_WHOLE_DEC",
    "NAV1_RADIO_WHOLE_INC",
    "NAV2_RADIO_WHOLE_INC",
    "NAV3_RADIO_WHOLE_INC",
    "NAV4_RADIO_WHOLE_INC",
    "TACAN1_ACTIVE_CHANNEL_SET",
    "TACAN2_ACTIVE_CHANNEL_SET",
    "TACAN1_ACTIVE_MODE_SET",
    "TACAN2_ACTIVE_MODE_SET",
    "TACAN1_SWAP",
    "TACAN2_SWAP",
    "TACAN1_SET",
    "TACAN2_SET",
    "TACAN1_OBI_DEC",
    "TACAN2_OBI_DEC",
    "TACAN1_OBI_INC",
    "TACAN2_OBI_INC",
    "TACAN1_OBI_FAST_DEC",
    "TACAN2_OBI_FAST_DEC",
    "TACAN1_OBI_FAST_INC",
    "TACAN2_OBI_FAST_INC",
    "VOR1_OBI_DEC",
    "VOR2_OBI_DEC",
    "VOR3_OBI_DEC",
    "VOR4_OBI_DEC",
    "VOR1_OBI_FAST_DEC",
    "VOR2_OBI_FAST_DEC",
    "VOR3_OBI_FAST_DEC",
    "VOR4_OBI_FAST_DEC",
    "VOR1_OBI_FAST_INC",
    "VOR2_OBI_FAST_INC",
    "VOR3_OBI_FAST_INC",
    "VOR4_OBI_FAST_INC",
    "VOR1_OBI_INC",
    "VOR2_OBI_INC",
    "VOR3_OBI_INC",
    "VOR4_OBI_INC",
    "VOR1_SET",
    "VOR2_SET",
    "VOR3_SET",
    "VOR4_SET"
  ]);

  // src/systems/fmgc/src/navigation/RequiredPerformance.ts
  var rnpDefaults = {
    [1 /* Takeoff */]: 1,
    [0 /* Terminal */]: 1,
    [2 /* Enroute */]: 2,
    [3 /* Oceanic */]: 2,
    [4 /* VorApproach */]: 0.5,
    [5 /* GpsApproach */]: 0.3,
    [6 /* PrecisionApproach */]: 0.5,
    [7 /* NonPrecisionApproach */]: 0.5
  };
  var RequiredPerformance = class {
    constructor(flightPlanManager) {
      this.flightPlanManager = flightPlanManager;
      __publicField(this, "activeRnp");
      __publicField(this, "requestLDev", false);
      __publicField(this, "manualRnp", false);
    }
    update(_deltaTime) {
      this.updateAutoRnp();
      this.updateLDev();
    }
    setPilotRnp(rnp) {
      this.manualRnp = true;
      this.setActiveRnp(rnp);
    }
    clearPilotRnp() {
      this.manualRnp = false;
      this.updateAutoRnp();
    }
    updateAutoRnp() {
      if (this.manualRnp) {
        return;
      }
      const plan = this.flightPlanManager.activeFlightPlan;
      if (plan && plan.activeWaypoint) {
        const legRnp = plan.activeWaypoint.additionalData.rnp;
        if (legRnp !== void 0) {
          if (legRnp !== this.activeRnp) {
            this.setActiveRnp(legRnp);
          }
          return;
        }
      }
      const area = this.flightPlanManager.activeArea;
      const rnp = rnpDefaults[area];
      if (rnp !== this.activeRnp) {
        this.setActiveRnp(rnp);
      }
    }
    setActiveRnp(rnp) {
      this.activeRnp = rnp;
      SimVar.SetSimVarValue("L:A32NX_FMGC_L_RNP", "number", rnp != null ? rnp : 0);
      SimVar.SetSimVarValue("L:A32NX_FMGC_R_RNP", "number", rnp != null ? rnp : 0);
    }
    updateLDev() {
      const area = this.flightPlanManager.activeArea;
      const ldev = area !== 2 /* Enroute */ && area !== 3 /* Oceanic */ && this.activeRnp < 0.305;
      if (ldev !== this.requestLDev) {
        this.requestLDev = ldev;
        SimVar.SetSimVarValue("L:A32NX_FMGC_L_LDEV_REQUEST", "bool", this.requestLDev);
        SimVar.SetSimVarValue("L:A32NX_FMGC_R_LDEV_REQUEST", "bool", this.requestLDev);
      }
    }
  };

  // src/systems/fmgc/src/navigation/Navigation.ts
  var _Navigation = class {
    constructor(flightPlanManager, facLoader) {
      this.flightPlanManager = flightPlanManager;
      this.facLoader = facLoader;
      __publicField(this, "requiredPerformance");
      __publicField(this, "currentPerformance");
      __publicField(this, "accuracyHigh", false);
      __publicField(this, "ppos", { lat: 0, long: 0 });
      __publicField(this, "groundSpeed", 0);
      __publicField(this, "radioHeight", null);
      __publicField(this, "baroAltitude", null);
      __publicField(this, "pressureAltitude", null);
      __publicField(this, "navaidSelectionManager");
      __publicField(this, "landingSystemSelectionManager");
      __publicField(this, "navaidTuner");
      __publicField(this, "selectedNavaids", Array.from({ length: 4 }, () => ({
        type: 0 /* None */,
        mode: 0 /* Auto */,
        ident: "",
        frequency: 0,
        facility: null
      })));
      this.requiredPerformance = new RequiredPerformance(this.flightPlanManager);
      this.navaidSelectionManager = new NavaidSelectionManager(this, this.flightPlanManager);
      this.landingSystemSelectionManager = new LandingSystemSelectionManager(this, this.flightPlanManager, this.facLoader);
      this.navaidTuner = new NavaidTuner(this, this.navaidSelectionManager, this.landingSystemSelectionManager);
    }
    init() {
      this.navaidTuner.init();
    }
    update(deltaTime) {
      this.requiredPerformance.update(deltaTime);
      this.updateCurrentPerformance();
      this.updatePosition();
      this.updateRadioHeight();
      this.updateBaroAltitude();
      this.updatePressureAltitude();
      NearbyFacilities.getInstance().update(deltaTime);
      this.navaidSelectionManager.update(deltaTime);
      this.landingSystemSelectionManager.update(deltaTime);
      this.navaidTuner.update(deltaTime);
    }
    resetState() {
      this.navaidSelectionManager.resetState();
      this.landingSystemSelectionManager.resetState();
      this.navaidTuner.resetState();
    }
    getAdiruValue(simVars) {
      for (const adiru of _Navigation.adiruOrder) {
        const simVar = simVars[adiru - 1];
        _Navigation.arincWordCache.setFromSimVar(simVar);
        if (_Navigation.arincWordCache.isNormalOperation()) {
          return _Navigation.arincWordCache.value;
        }
      }
      return null;
    }
    updateCurrentPerformance() {
      const gs = SimVar.GetSimVarValue("GPS GROUND SPEED", "knots");
      const estimate = 0.03 + Math.random() * 0.02 + gs * 15e-5;
      this.currentPerformance = this.currentPerformance === void 0 ? estimate : this.currentPerformance * 0.9 + estimate * 0.1;
      const accuracyHigh = this.currentPerformance <= this.requiredPerformance.activeRnp;
      if (accuracyHigh !== this.accuracyHigh) {
        this.accuracyHigh = accuracyHigh;
        SimVar.SetSimVarValue("L:A32NX_FMGC_L_NAV_ACCURACY_HIGH", "bool", this.accuracyHigh);
        SimVar.SetSimVarValue("L:A32NX_FMGC_R_NAV_ACCURACY_HIGH", "bool", this.accuracyHigh);
      }
    }
    updateRadioHeight() {
      for (const simVar of _Navigation.radioAltimeterVars) {
        _Navigation.arincWordCache.setFromSimVar(simVar);
        if (_Navigation.arincWordCache.isNormalOperation()) {
          this.radioHeight = _Navigation.arincWordCache.value;
          return;
        }
      }
      this.radioHeight = null;
    }
    updateBaroAltitude() {
      this.baroAltitude = this.getAdiruValue(_Navigation.baroAltitudeVars);
    }
    updatePressureAltitude() {
      this.pressureAltitude = this.getAdiruValue(_Navigation.pressureAltitudeVars);
    }
    updatePosition() {
      this.ppos.lat = SimVar.GetSimVarValue("PLANE LATITUDE", "degree latitude");
      this.ppos.long = SimVar.GetSimVarValue("PLANE LONGITUDE", "degree longitude");
      this.groundSpeed = SimVar.GetSimVarValue("GPS GROUND SPEED", "knots");
      NearbyFacilities.getInstance().setPpos(this.ppos);
    }
    getBaroCorrectedAltitude() {
      return this.baroAltitude;
    }
    getEpe() {
      var _a;
      return (_a = this.currentPerformance) != null ? _a : Infinity;
    }
    getPpos() {
      return this.ppos;
    }
    getPressureAltitude() {
      return this.pressureAltitude;
    }
    getRadioHeight() {
      return this.radioHeight;
    }
    getNavaidTuner() {
      return this.navaidTuner;
    }
    resetSelectedNavaid(i) {
      const selected = this.selectedNavaids[i];
      selected.type = 0 /* None */;
      selected.mode = 0 /* Auto */;
      selected.ident = "";
      selected.frequency = 0;
      selected.facility = null;
    }
    getSelectedNavaids(cdu = 1) {
      var _a, _b;
      if (this.navaidTuner.isFmTuningActive()) {
        const vorStatus = this.navaidTuner.getVorRadioTuningStatus(cdu);
        if (vorStatus.frequency !== null) {
          const selected = this.selectedNavaids[0];
          selected.type = this.getSelectedNavaidType(vorStatus.facility);
          selected.mode = vorStatus.manual ? 1 /* Manual */ : 0 /* Auto */;
          selected.ident = vorStatus.ident;
          selected.frequency = vorStatus.frequency;
          selected.facility = (_a = vorStatus.facility) != null ? _a : null;
        } else {
          this.resetSelectedNavaid(0);
        }
        const dmePair = this.navaidSelectionManager.dmePair;
        if (dmePair !== null) {
          for (const [i, dme] of dmePair.entries()) {
            const selected = this.selectedNavaids[i + 1];
            selected.type = this.getSelectedNavaidType(dme);
            selected.mode = 0 /* Auto */;
            selected.ident = WayPoint.formatIdentFromIcao(dme.icao);
            selected.frequency = dme.freqMHz;
            selected.facility = dme;
          }
        } else if (this.navaidSelectionManager.displayVorReason === 3 /* Navigation */) {
          const navaid = this.navaidSelectionManager.displayVor;
          const selected = this.selectedNavaids[1];
          selected.type = this.getSelectedNavaidType(navaid);
          selected.mode = 0 /* Auto */;
          selected.ident = WayPoint.formatIdentFromIcao(navaid.icao);
          selected.frequency = navaid.freqMHz;
          selected.facility = navaid;
          this.resetSelectedNavaid(2);
        } else {
          this.resetSelectedNavaid(1);
          this.resetSelectedNavaid(2);
        }
        const mmrStatus = this.navaidTuner.getMmrRadioTuningStatus(1);
        if (mmrStatus.frequency !== null) {
          const selected = this.selectedNavaids[3];
          selected.type = this.getSelectedNavaidType(mmrStatus.facility);
          selected.mode = mmrStatus.manual ? 1 /* Manual */ : 0 /* Auto */;
          selected.ident = mmrStatus.ident;
          selected.frequency = mmrStatus.frequency;
          selected.facility = (_b = mmrStatus.facility) != null ? _b : null;
        } else {
          this.resetSelectedNavaid(3);
        }
      } else {
        for (let i = 0; i < 4; i++) {
          this.resetSelectedNavaid(i);
          if (i === 1 || i === 2) {
            continue;
          }
          const selected = this.selectedNavaids[i];
          selected.type = i === 3 ? 6 /* Ils */ : 0 /* None */;
          selected.mode = 2 /* Rmp */;
          selected.frequency = SimVar.GetSimVarValue(`NAV ACTIVE FREQUENCY:${i === 0 ? cdu : cdu + 2}`, "mhz");
        }
      }
      return this.selectedNavaids;
    }
    getSelectedNavaidType(facility) {
      if (!facility) {
        return 0 /* None */;
      }
      switch (facility.type) {
        case 3 /* DME */:
          return 1 /* Dme */;
        case 1 /* VOR */:
          return 2 /* Vor */;
        case 2 /* VORDME */:
          return 3 /* VorDme */;
        case 5 /* VORTAC */:
          return 4 /* VorTac */;
        case 4 /* TACAN */:
          return 5 /* Tacan */;
        case 6 /* ILS */:
          return 6 /* Ils */;
        default:
          return 0 /* None */;
      }
    }
  };
  var Navigation = _Navigation;
  __publicField(Navigation, "adiruOrder", [1, 3, 2]);
  __publicField(Navigation, "arincWordCache", Arinc429Register.empty());
  __publicField(Navigation, "radioAltimeterVars", Array.from({ length: 2 }, (_, i) => `L:A32NX_RA_${i + 1}_RADIO_ALTITUDE`));
  __publicField(Navigation, "baroAltitudeVars", Array.from({ length: 3 }, (_, i) => `L:A32NX_ADIRS_ADR_${i + 1}_BARO_CORRECTED_ALTITUDE_1`));
  __publicField(Navigation, "pressureAltitudeVars", Array.from({ length: 3 }, (_, i) => `L:A32NX_ADIRS_ADR_${i + 1}_ALTITUDE`));

  // src/systems/instruments/src/Common/flightplan.tsx
  var FlightPlanContext = import_react5.default.createContext(void 0);
  var FlightPlanProvider = ({ children }) => {
    const [flightPlanManager] = (0, import_react5.useState)(() => new FlightPlanManager(getRootElement()));
    return /* @__PURE__ */ import_react5.default.createElement(FlightPlanContext.Provider, { value: { flightPlanManager } }, children);
  };

  // src/systems/instruments/src/Common/arinc429.tsx
  var useArinc429Var = (name69, maxStaleness = 0) => {
    const [value] = useSimVar(name69, "number", maxStaleness);
    return new Arinc429Word(value);
  };

  // src/systems/instruments/src/ND/elements/TerrainMapThresholds.tsx
  var import_react6 = __toESM(require_react());
  var TerrainMapThresholds = ({ side }) => {
    const [minElevation] = useSimVar(`L:A32NX_EGPWC_ND_${side}_TERRAIN_MIN_ELEVATION`, "number", 200);
    const [minElevationMode] = useSimVar(`L:A32NX_EGPWC_ND_${side}_TERRAIN_MIN_ELEVATION_MODE`, "number", 200);
    const [maxElevation] = useSimVar(`L:A32NX_EGPWC_ND_${side}_TERRAIN_MAX_ELEVATION`, "number", 200);
    const [maxElevationMode] = useSimVar(`L:A32NX_EGPWC_ND_${side}_TERRAIN_MAX_ELEVATION_MODE`, "number", 200);
    if (minElevation < 0 && maxElevation < 0)
      return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null);
    let lowerBorderColor = "";
    let upperBorderColor = "";
    let lowerBorder = "";
    let upperBorder = "";
    if (minElevation >= 0) {
      lowerBorder = String(Math.floor(minElevation / 100)).padStart(3, "0");
    }
    switch (minElevationMode) {
      case 2 /* Caution */:
        lowerBorderColor = "rgb(255, 0, 0)";
        break;
      case 1 /* Warning */:
        lowerBorderColor = "rgb(255, 255, 0)";
        break;
      default:
        lowerBorderColor = "rgb(0, 255, 0)";
        break;
    }
    if (maxElevation !== 0) {
      upperBorder = String(Math.round(maxElevation / 100 + 0.5)).padStart(3, "0");
    } else {
      upperBorder = "000";
    }
    switch (maxElevationMode) {
      case 2 /* Caution */:
        upperBorderColor = "rgb(255, 0, 0)";
        break;
      case 1 /* Warning */:
        upperBorderColor = "rgb(255, 255, 0)";
        break;
      default:
        upperBorderColor = "rgb(0, 255, 0)";
        break;
    }
    return /* @__PURE__ */ import_react6.default.createElement(import_react6.default.Fragment, null, /* @__PURE__ */ import_react6.default.createElement("text", { x: 688, y: 612, fontSize: 23, fill: "rgb(0,255,255)" }, "TERR"), /* @__PURE__ */ import_react6.default.createElement("text", { x: 709, y: 639, fontSize: 22, fill: upperBorderColor }, upperBorder), /* @__PURE__ */ import_react6.default.createElement("rect", { x: 700, y: 619, width: 54, height: 24, strokeWidth: 3, stroke: "rgb(255,255,0)", fillOpacity: 0 }), /* @__PURE__ */ import_react6.default.createElement("text", { x: 709, y: 663, fontSize: 22, fill: lowerBorderColor }, lowerBorder), /* @__PURE__ */ import_react6.default.createElement("rect", { x: 700, y: 643, width: 54, height: 24, strokeWidth: 3, stroke: "rgb(255,255,0)", fillOpacity: 0 }));
  };

  // src/systems/instruments/src/Common/index.tsx
  var import_react_dom = __toESM(require_react_dom());

  // ../node_modules/@sentry/browser/node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter: __awaiter2,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet
  } = import_tslib.default;

  // ../node_modules/@sentry/types/esm/severity.js
  var Severity;
  (function(Severity2) {
    Severity2["Fatal"] = "fatal";
    Severity2["Error"] = "error";
    Severity2["Warning"] = "warning";
    Severity2["Log"] = "log";
    Severity2["Info"] = "info";
    Severity2["Debug"] = "debug";
    Severity2["Critical"] = "critical";
  })(Severity || (Severity = {}));

  // ../node_modules/@sentry/minimal/node_modules/tslib/modules/index.js
  var import_tslib2 = __toESM(require_tslib2(), 1);
  var {
    __extends: __extends2,
    __assign: __assign2,
    __rest: __rest2,
    __decorate: __decorate2,
    __param: __param2,
    __metadata: __metadata2,
    __awaiter: __awaiter3,
    __generator: __generator2,
    __exportStar: __exportStar2,
    __createBinding: __createBinding2,
    __values: __values2,
    __read: __read2,
    __spread: __spread2,
    __spreadArrays: __spreadArrays2,
    __await: __await2,
    __asyncGenerator: __asyncGenerator2,
    __asyncDelegator: __asyncDelegator2,
    __asyncValues: __asyncValues2,
    __makeTemplateObject: __makeTemplateObject2,
    __importStar: __importStar2,
    __importDefault: __importDefault2,
    __classPrivateFieldGet: __classPrivateFieldGet2,
    __classPrivateFieldSet: __classPrivateFieldSet2
  } = import_tslib2.default;

  // ../node_modules/@sentry/hub/node_modules/tslib/modules/index.js
  var import_tslib3 = __toESM(require_tslib3(), 1);
  var {
    __extends: __extends3,
    __assign: __assign3,
    __rest: __rest3,
    __decorate: __decorate3,
    __param: __param3,
    __metadata: __metadata3,
    __awaiter: __awaiter4,
    __generator: __generator3,
    __exportStar: __exportStar3,
    __createBinding: __createBinding3,
    __values: __values3,
    __read: __read3,
    __spread: __spread3,
    __spreadArrays: __spreadArrays3,
    __await: __await3,
    __asyncGenerator: __asyncGenerator3,
    __asyncDelegator: __asyncDelegator3,
    __asyncValues: __asyncValues3,
    __makeTemplateObject: __makeTemplateObject3,
    __importStar: __importStar3,
    __importDefault: __importDefault3,
    __classPrivateFieldGet: __classPrivateFieldGet3,
    __classPrivateFieldSet: __classPrivateFieldSet3
  } = import_tslib3.default;

  // ../node_modules/@sentry/utils/esm/async.js
  function forget(promise) {
    void promise.then(null, function(e) {
      console.error(e);
    });
  }

  // ../node_modules/@sentry/utils/esm/env.js
  function isBrowserBundle() {
    return typeof __SENTRY_BROWSER_BUNDLE__ !== "undefined" && !!__SENTRY_BROWSER_BUNDLE__;
  }

  // ../node_modules/@sentry/utils/esm/node.js
  function isNodeEnv() {
    return !isBrowserBundle() && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  }
  function dynamicRequire(mod4, request) {
    return mod4.require(request);
  }
  function loadModule(moduleName) {
    var mod4;
    try {
      mod4 = dynamicRequire(module, moduleName);
    } catch (e) {
    }
    try {
      var cwd = dynamicRequire(module, "process").cwd;
      mod4 = dynamicRequire(module, cwd() + "/node_modules/" + moduleName);
    } catch (e) {
    }
    return mod4;
  }

  // ../node_modules/@sentry/utils/esm/global.js
  var fallbackGlobalObject = {};
  function getGlobalObject() {
    return isNodeEnv() ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : fallbackGlobalObject;
  }
  function getGlobalSingleton(name69, creator, obj) {
    var global12 = obj || getGlobalObject();
    var __SENTRY__ = global12.__SENTRY__ = global12.__SENTRY__ || {};
    var singleton = __SENTRY__[name69] || (__SENTRY__[name69] = creator());
    return singleton;
  }

  // ../node_modules/@sentry/utils/esm/is.js
  var objectToString = Object.prototype.toString;
  function isError(wat) {
    switch (objectToString.call(wat)) {
      case "[object Error]":
      case "[object Exception]":
      case "[object DOMException]":
        return true;
      default:
        return isInstanceOf(wat, Error);
    }
  }
  function isBuiltin(wat, ty) {
    return objectToString.call(wat) === "[object " + ty + "]";
  }
  function isErrorEvent(wat) {
    return isBuiltin(wat, "ErrorEvent");
  }
  function isDOMError(wat) {
    return isBuiltin(wat, "DOMError");
  }
  function isDOMException(wat) {
    return isBuiltin(wat, "DOMException");
  }
  function isString2(wat) {
    return isBuiltin(wat, "String");
  }
  function isPrimitive(wat) {
    return wat === null || typeof wat !== "object" && typeof wat !== "function";
  }
  function isPlainObject2(wat) {
    return isBuiltin(wat, "Object");
  }
  function isEvent(wat) {
    return typeof Event !== "undefined" && isInstanceOf(wat, Event);
  }
  function isElement(wat) {
    return typeof Element !== "undefined" && isInstanceOf(wat, Element);
  }
  function isRegExp2(wat) {
    return isBuiltin(wat, "RegExp");
  }
  function isThenable(wat) {
    return Boolean(wat && wat.then && typeof wat.then === "function");
  }
  function isSyntheticEvent(wat) {
    return isPlainObject2(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
  }
  function isNaN2(wat) {
    return typeof wat === "number" && wat !== wat;
  }
  function isInstanceOf(wat, base) {
    try {
      return wat instanceof base;
    } catch (_e) {
      return false;
    }
  }

  // ../node_modules/@sentry/utils/esm/browser.js
  function htmlTreeAsString(elem, keyAttrs) {
    try {
      var currentElem = elem;
      var MAX_TRAVERSE_HEIGHT = 5;
      var MAX_OUTPUT_LEN = 80;
      var out = [];
      var height = 0;
      var len = 0;
      var separator = " > ";
      var sepLength = separator.length;
      var nextStr = void 0;
      while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
        nextStr = _htmlElementAsString(currentElem, keyAttrs);
        if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN) {
          break;
        }
        out.push(nextStr);
        len += nextStr.length;
        currentElem = currentElem.parentNode;
      }
      return out.reverse().join(separator);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function _htmlElementAsString(el, keyAttrs) {
    var elem = el;
    var out = [];
    var className;
    var classes;
    var key;
    var attr;
    var i;
    if (!elem || !elem.tagName) {
      return "";
    }
    out.push(elem.tagName.toLowerCase());
    var keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter(function(keyAttr) {
      return elem.getAttribute(keyAttr);
    }).map(function(keyAttr) {
      return [keyAttr, elem.getAttribute(keyAttr)];
    }) : null;
    if (keyAttrPairs && keyAttrPairs.length) {
      keyAttrPairs.forEach(function(keyAttrPair) {
        out.push("[" + keyAttrPair[0] + '="' + keyAttrPair[1] + '"]');
      });
    } else {
      if (elem.id) {
        out.push("#" + elem.id);
      }
      className = elem.className;
      if (className && isString2(className)) {
        classes = className.split(/\s+/);
        for (i = 0; i < classes.length; i++) {
          out.push("." + classes[i]);
        }
      }
    }
    var allowedAttrs = ["type", "name", "title", "alt"];
    for (i = 0; i < allowedAttrs.length; i++) {
      key = allowedAttrs[i];
      attr = elem.getAttribute(key);
      if (attr) {
        out.push("[" + key + '="' + attr + '"]');
      }
    }
    return out.join("");
  }
  function getLocationHref() {
    var global12 = getGlobalObject();
    try {
      return global12.document.location.href;
    } catch (oO) {
      return "";
    }
  }

  // ../node_modules/@sentry/utils/node_modules/tslib/modules/index.js
  var import_tslib4 = __toESM(require_tslib4(), 1);
  var {
    __extends: __extends4,
    __assign: __assign4,
    __rest: __rest4,
    __decorate: __decorate4,
    __param: __param4,
    __metadata: __metadata4,
    __awaiter: __awaiter5,
    __generator: __generator4,
    __exportStar: __exportStar4,
    __createBinding: __createBinding4,
    __values: __values4,
    __read: __read4,
    __spread: __spread4,
    __spreadArrays: __spreadArrays4,
    __await: __await4,
    __asyncGenerator: __asyncGenerator4,
    __asyncDelegator: __asyncDelegator4,
    __asyncValues: __asyncValues4,
    __makeTemplateObject: __makeTemplateObject4,
    __importStar: __importStar4,
    __importDefault: __importDefault4,
    __classPrivateFieldGet: __classPrivateFieldGet4,
    __classPrivateFieldSet: __classPrivateFieldSet4
  } = import_tslib4.default;

  // ../node_modules/@sentry/utils/esm/polyfill.js
  var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }

  // ../node_modules/@sentry/utils/esm/error.js
  var SentryError = function(_super) {
    __extends4(SentryError2, _super);
    function SentryError2(message) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.name = _newTarget.prototype.constructor.name;
      setPrototypeOf(_this, _newTarget.prototype);
      return _this;
    }
    return SentryError2;
  }(Error);

  // ../node_modules/@sentry/utils/esm/flags.js
  var IS_DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/utils/esm/dsn.js
  var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
  function isValidProtocol(protocol) {
    return protocol === "http" || protocol === "https";
  }
  function dsnToString(dsn, withPassword) {
    if (withPassword === void 0) {
      withPassword = false;
    }
    var host = dsn.host, path = dsn.path, pass = dsn.pass, port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol, publicKey = dsn.publicKey;
    return protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : "") + ("@" + host + (port ? ":" + port : "") + "/" + (path ? path + "/" : path) + projectId);
  }
  function dsnFromString(str) {
    var match = DSN_REGEX.exec(str);
    if (!match) {
      throw new SentryError("Invalid Sentry Dsn: " + str);
    }
    var _a = __read4(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? "" : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? "" : _c, lastPath = _a[5];
    var path = "";
    var projectId = lastPath;
    var split = projectId.split("/");
    if (split.length > 1) {
      path = split.slice(0, -1).join("/");
      projectId = split.pop();
    }
    if (projectId) {
      var projectMatch = projectId.match(/^\d+/);
      if (projectMatch) {
        projectId = projectMatch[0];
      }
    }
    return dsnFromComponents({ host, pass, path, projectId, port, protocol, publicKey });
  }
  function dsnFromComponents(components2) {
    if ("user" in components2 && !("publicKey" in components2)) {
      components2.publicKey = components2.user;
    }
    return {
      user: components2.publicKey || "",
      protocol: components2.protocol,
      publicKey: components2.publicKey || "",
      pass: components2.pass || "",
      host: components2.host,
      port: components2.port || "",
      path: components2.path || "",
      projectId: components2.projectId
    };
  }
  function validateDsn(dsn) {
    if (!IS_DEBUG_BUILD) {
      return;
    }
    var port = dsn.port, projectId = dsn.projectId, protocol = dsn.protocol;
    var requiredComponents = ["protocol", "publicKey", "host", "projectId"];
    requiredComponents.forEach(function(component) {
      if (!dsn[component]) {
        throw new SentryError("Invalid Sentry Dsn: " + component + " missing");
      }
    });
    if (!projectId.match(/^\d+$/)) {
      throw new SentryError("Invalid Sentry Dsn: Invalid projectId " + projectId);
    }
    if (!isValidProtocol(protocol)) {
      throw new SentryError("Invalid Sentry Dsn: Invalid protocol " + protocol);
    }
    if (port && isNaN(parseInt(port, 10))) {
      throw new SentryError("Invalid Sentry Dsn: Invalid port " + port);
    }
    return true;
  }
  function makeDsn(from) {
    var components2 = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
    validateDsn(components2);
    return components2;
  }

  // ../node_modules/@sentry/utils/esm/enums.js
  var SeverityLevels = ["fatal", "error", "warning", "log", "info", "debug", "critical"];

  // ../node_modules/@sentry/utils/esm/logger.js
  var global2 = getGlobalObject();
  var PREFIX = "Sentry Logger ";
  var CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert"];
  function consoleSandbox(callback) {
    var global12 = getGlobalObject();
    if (!("console" in global12)) {
      return callback();
    }
    var originalConsole = global12.console;
    var wrappedLevels = {};
    CONSOLE_LEVELS.forEach(function(level) {
      var originalWrappedFunc = originalConsole[level] && originalConsole[level].__sentry_original__;
      if (level in global12.console && originalWrappedFunc) {
        wrappedLevels[level] = originalConsole[level];
        originalConsole[level] = originalWrappedFunc;
      }
    });
    try {
      return callback();
    } finally {
      Object.keys(wrappedLevels).forEach(function(level) {
        originalConsole[level] = wrappedLevels[level];
      });
    }
  }
  function makeLogger() {
    var enabled = false;
    var logger2 = {
      enable: function() {
        enabled = true;
      },
      disable: function() {
        enabled = false;
      }
    };
    if (IS_DEBUG_BUILD) {
      CONSOLE_LEVELS.forEach(function(name69) {
        logger2[name69] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (enabled) {
            consoleSandbox(function() {
              var _a;
              (_a = global2.console)[name69].apply(_a, __spread4([PREFIX + "[" + name69 + "]:"], args));
            });
          }
        };
      });
    } else {
      CONSOLE_LEVELS.forEach(function(name69) {
        logger2[name69] = function() {
          return void 0;
        };
      });
    }
    return logger2;
  }
  var logger;
  if (IS_DEBUG_BUILD) {
    logger = getGlobalSingleton("logger", makeLogger);
  } else {
    logger = makeLogger();
  }

  // ../node_modules/@sentry/utils/esm/string.js
  function truncate2(str, max2) {
    if (max2 === void 0) {
      max2 = 0;
    }
    if (typeof str !== "string" || max2 === 0) {
      return str;
    }
    return str.length <= max2 ? str : str.substr(0, max2) + "...";
  }
  function safeJoin(input, delimiter) {
    if (!Array.isArray(input)) {
      return "";
    }
    var output = [];
    for (var i = 0; i < input.length; i++) {
      var value = input[i];
      try {
        output.push(String(value));
      } catch (e) {
        output.push("[value cannot be serialized]");
      }
    }
    return output.join(delimiter);
  }
  function isMatchingPattern(value, pattern) {
    if (!isString2(value)) {
      return false;
    }
    if (isRegExp2(pattern)) {
      return pattern.test(value);
    }
    if (typeof pattern === "string") {
      return value.indexOf(pattern) !== -1;
    }
    return false;
  }

  // ../node_modules/@sentry/utils/esm/object.js
  function fill(source, name69, replacementFactory) {
    if (!(name69 in source)) {
      return;
    }
    var original = source[name69];
    var wrapped = replacementFactory(original);
    if (typeof wrapped === "function") {
      try {
        markFunctionWrapped(wrapped, original);
      } catch (_Oo) {
      }
    }
    source[name69] = wrapped;
  }
  function addNonEnumerableProperty(obj, name69, value) {
    Object.defineProperty(obj, name69, {
      value,
      writable: true,
      configurable: true
    });
  }
  function markFunctionWrapped(wrapped, original) {
    var proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  }
  function getOriginalFunction(func) {
    return func.__sentry_original__;
  }
  function urlEncode(object) {
    return Object.keys(object).map(function(key) {
      return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]);
    }).join("&");
  }
  function convertToPlainObject(value) {
    var newObj = value;
    if (isError(value)) {
      newObj = __assign4({ message: value.message, name: value.name, stack: value.stack }, getOwnProperties(value));
    } else if (isEvent(value)) {
      var event_1 = value;
      newObj = __assign4({ type: event_1.type, target: serializeEventTarget(event_1.target), currentTarget: serializeEventTarget(event_1.currentTarget) }, getOwnProperties(event_1));
      if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
        newObj.detail = event_1.detail;
      }
    }
    return newObj;
  }
  function serializeEventTarget(target) {
    try {
      return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
    } catch (_oO) {
      return "<unknown>";
    }
  }
  function getOwnProperties(obj) {
    var extractedProps = {};
    for (var property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  }
  function extractExceptionKeysForMessage(exception, maxLength) {
    if (maxLength === void 0) {
      maxLength = 40;
    }
    var keys = Object.keys(convertToPlainObject(exception));
    keys.sort();
    if (!keys.length) {
      return "[object has no keys]";
    }
    if (keys[0].length >= maxLength) {
      return truncate2(keys[0], maxLength);
    }
    for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
      var serialized = keys.slice(0, includedKeys).join(", ");
      if (serialized.length > maxLength) {
        continue;
      }
      if (includedKeys === keys.length) {
        return serialized;
      }
      return truncate2(serialized, maxLength);
    }
    return "";
  }
  function dropUndefinedKeys(val) {
    var e_1, _a;
    if (isPlainObject2(val)) {
      var rv = {};
      try {
        for (var _b = __values4(Object.keys(val)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          if (typeof val[key] !== "undefined") {
            rv[key] = dropUndefinedKeys(val[key]);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return rv;
    }
    if (Array.isArray(val)) {
      return val.map(dropUndefinedKeys);
    }
    return val;
  }

  // ../node_modules/@sentry/utils/esm/stacktrace.js
  var STACKTRACE_LIMIT = 50;
  function createStackParser() {
    var parsers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      parsers[_i] = arguments[_i];
    }
    var sortedParsers = parsers.sort(function(a, b) {
      return a[0] - b[0];
    }).map(function(p) {
      return p[1];
    });
    return function(stack, skipFirst) {
      var e_1, _a, e_2, _b;
      if (skipFirst === void 0) {
        skipFirst = 0;
      }
      var frames = [];
      try {
        for (var _c = __values4(stack.split("\n").slice(skipFirst)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var line = _d.value;
          try {
            for (var sortedParsers_1 = (e_2 = void 0, __values4(sortedParsers)), sortedParsers_1_1 = sortedParsers_1.next(); !sortedParsers_1_1.done; sortedParsers_1_1 = sortedParsers_1.next()) {
              var parser = sortedParsers_1_1.value;
              var frame = parser(line);
              if (frame) {
                frames.push(frame);
                break;
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (sortedParsers_1_1 && !sortedParsers_1_1.done && (_b = sortedParsers_1.return))
                _b.call(sortedParsers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return stripSentryFramesAndReverse(frames);
    };
  }
  function stripSentryFramesAndReverse(stack) {
    if (!stack.length) {
      return [];
    }
    var localStack = stack;
    var firstFrameFunction = localStack[0].function || "";
    var lastFrameFunction = localStack[localStack.length - 1].function || "";
    if (firstFrameFunction.indexOf("captureMessage") !== -1 || firstFrameFunction.indexOf("captureException") !== -1) {
      localStack = localStack.slice(1);
    }
    if (lastFrameFunction.indexOf("sentryWrapped") !== -1) {
      localStack = localStack.slice(0, -1);
    }
    return localStack.slice(0, STACKTRACE_LIMIT).map(function(frame) {
      return __assign4(__assign4({}, frame), { filename: frame.filename || localStack[0].filename, function: frame.function || "?" });
    }).reverse();
  }
  var defaultFunctionName = "<anonymous>";
  function getFunctionName(fn) {
    try {
      if (!fn || typeof fn !== "function") {
        return defaultFunctionName;
      }
      return fn.name || defaultFunctionName;
    } catch (e) {
      return defaultFunctionName;
    }
  }

  // ../node_modules/@sentry/utils/esm/supports.js
  function supportsFetch() {
    if (!("fetch" in getGlobalObject())) {
      return false;
    }
    try {
      new Headers();
      new Request("");
      new Response();
      return true;
    } catch (e) {
      return false;
    }
  }
  function isNativeFetch(func) {
    return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
  }
  function supportsNativeFetch() {
    if (!supportsFetch()) {
      return false;
    }
    var global12 = getGlobalObject();
    if (isNativeFetch(global12.fetch)) {
      return true;
    }
    var result = false;
    var doc = global12.document;
    if (doc && typeof doc.createElement === "function") {
      try {
        var sandbox = doc.createElement("iframe");
        sandbox.hidden = true;
        doc.head.appendChild(sandbox);
        if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
          result = isNativeFetch(sandbox.contentWindow.fetch);
        }
        doc.head.removeChild(sandbox);
      } catch (err) {
        IS_DEBUG_BUILD && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
      }
    }
    return result;
  }
  function supportsReferrerPolicy() {
    if (!supportsFetch()) {
      return false;
    }
    try {
      new Request("_", {
        referrerPolicy: "origin"
      });
      return true;
    } catch (e) {
      return false;
    }
  }
  function supportsHistory() {
    var global12 = getGlobalObject();
    var chrome2 = global12.chrome;
    var isChromePackagedApp = chrome2 && chrome2.app && chrome2.app.runtime;
    var hasHistoryApi = "history" in global12 && !!global12.history.pushState && !!global12.history.replaceState;
    return !isChromePackagedApp && hasHistoryApi;
  }

  // ../node_modules/@sentry/utils/esm/instrument.js
  var global3 = getGlobalObject();
  var handlers = {};
  var instrumented = {};
  function instrument(type) {
    if (instrumented[type]) {
      return;
    }
    instrumented[type] = true;
    switch (type) {
      case "console":
        instrumentConsole();
        break;
      case "dom":
        instrumentDOM();
        break;
      case "xhr":
        instrumentXHR();
        break;
      case "fetch":
        instrumentFetch();
        break;
      case "history":
        instrumentHistory();
        break;
      case "error":
        instrumentError();
        break;
      case "unhandledrejection":
        instrumentUnhandledRejection();
        break;
      default:
        IS_DEBUG_BUILD && logger.warn("unknown instrumentation type:", type);
        return;
    }
  }
  function addInstrumentationHandler(type, callback) {
    handlers[type] = handlers[type] || [];
    handlers[type].push(callback);
    instrument(type);
  }
  function triggerHandlers(type, data) {
    var e_1, _a;
    if (!type || !handlers[type]) {
      return;
    }
    try {
      for (var _b = __values4(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
        var handler = _c.value;
        try {
          handler(data);
        } catch (e) {
          IS_DEBUG_BUILD && logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError:", e);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  function instrumentConsole() {
    if (!("console" in global3)) {
      return;
    }
    CONSOLE_LEVELS.forEach(function(level) {
      if (!(level in global3.console)) {
        return;
      }
      fill(global3.console, level, function(originalConsoleMethod) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          triggerHandlers("console", { args, level });
          if (originalConsoleMethod) {
            originalConsoleMethod.apply(global3.console, args);
          }
        };
      });
    });
  }
  function instrumentFetch() {
    if (!supportsNativeFetch()) {
      return;
    }
    fill(global3, "fetch", function(originalFetch) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var handlerData = {
          args,
          fetchData: {
            method: getFetchMethod(args),
            url: getFetchUrl(args)
          },
          startTimestamp: Date.now()
        };
        triggerHandlers("fetch", __assign4({}, handlerData));
        return originalFetch.apply(global3, args).then(function(response) {
          triggerHandlers("fetch", __assign4(__assign4({}, handlerData), { endTimestamp: Date.now(), response }));
          return response;
        }, function(error) {
          triggerHandlers("fetch", __assign4(__assign4({}, handlerData), { endTimestamp: Date.now(), error }));
          throw error;
        });
      };
    });
  }
  function getFetchMethod(fetchArgs) {
    if (fetchArgs === void 0) {
      fetchArgs = [];
    }
    if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
      return String(fetchArgs[0].method).toUpperCase();
    }
    if (fetchArgs[1] && fetchArgs[1].method) {
      return String(fetchArgs[1].method).toUpperCase();
    }
    return "GET";
  }
  function getFetchUrl(fetchArgs) {
    if (fetchArgs === void 0) {
      fetchArgs = [];
    }
    if (typeof fetchArgs[0] === "string") {
      return fetchArgs[0];
    }
    if ("Request" in global3 && isInstanceOf(fetchArgs[0], Request)) {
      return fetchArgs[0].url;
    }
    return String(fetchArgs[0]);
  }
  function instrumentXHR() {
    if (!("XMLHttpRequest" in global3)) {
      return;
    }
    var xhrproto = XMLHttpRequest.prototype;
    fill(xhrproto, "open", function(originalOpen) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var xhr = this;
        var url = args[1];
        var xhrInfo = xhr.__sentry_xhr__ = {
          method: isString2(args[0]) ? args[0].toUpperCase() : args[0],
          url: args[1]
        };
        if (isString2(url) && xhrInfo.method === "POST" && url.match(/sentry_key/)) {
          xhr.__sentry_own_request__ = true;
        }
        var onreadystatechangeHandler = function() {
          if (xhr.readyState === 4) {
            try {
              xhrInfo.status_code = xhr.status;
            } catch (e) {
            }
            triggerHandlers("xhr", {
              args,
              endTimestamp: Date.now(),
              startTimestamp: Date.now(),
              xhr
            });
          }
        };
        if ("onreadystatechange" in xhr && typeof xhr.onreadystatechange === "function") {
          fill(xhr, "onreadystatechange", function(original) {
            return function() {
              var readyStateArgs = [];
              for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                readyStateArgs[_i2] = arguments[_i2];
              }
              onreadystatechangeHandler();
              return original.apply(xhr, readyStateArgs);
            };
          });
        } else {
          xhr.addEventListener("readystatechange", onreadystatechangeHandler);
        }
        return originalOpen.apply(xhr, args);
      };
    });
    fill(xhrproto, "send", function(originalSend) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.__sentry_xhr__ && args[0] !== void 0) {
          this.__sentry_xhr__.body = args[0];
        }
        triggerHandlers("xhr", {
          args,
          startTimestamp: Date.now(),
          xhr: this
        });
        return originalSend.apply(this, args);
      };
    });
  }
  var lastHref;
  function instrumentHistory() {
    if (!supportsHistory()) {
      return;
    }
    var oldOnPopState = global3.onpopstate;
    global3.onpopstate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var to = global3.location.href;
      var from = lastHref;
      lastHref = to;
      triggerHandlers("history", {
        from,
        to
      });
      if (oldOnPopState) {
        try {
          return oldOnPopState.apply(this, args);
        } catch (_oO) {
        }
      }
    };
    function historyReplacementFunction(originalHistoryFunction) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var url = args.length > 2 ? args[2] : void 0;
        if (url) {
          var from = lastHref;
          var to = String(url);
          lastHref = to;
          triggerHandlers("history", {
            from,
            to
          });
        }
        return originalHistoryFunction.apply(this, args);
      };
    }
    fill(global3.history, "pushState", historyReplacementFunction);
    fill(global3.history, "replaceState", historyReplacementFunction);
  }
  var debounceDuration = 1e3;
  var debounceTimerID;
  var lastCapturedEvent;
  function shouldShortcircuitPreviousDebounce(previous, current) {
    if (!previous) {
      return true;
    }
    if (previous.type !== current.type) {
      return true;
    }
    try {
      if (previous.target !== current.target) {
        return true;
      }
    } catch (e) {
    }
    return false;
  }
  function shouldSkipDOMEvent(event) {
    if (event.type !== "keypress") {
      return false;
    }
    try {
      var target = event.target;
      if (!target || !target.tagName) {
        return true;
      }
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return false;
      }
    } catch (e) {
    }
    return true;
  }
  function makeDOMEventHandler(handler, globalListener) {
    if (globalListener === void 0) {
      globalListener = false;
    }
    return function(event) {
      if (!event || lastCapturedEvent === event) {
        return;
      }
      if (shouldSkipDOMEvent(event)) {
        return;
      }
      var name69 = event.type === "keypress" ? "input" : event.type;
      if (debounceTimerID === void 0) {
        handler({
          event,
          name: name69,
          global: globalListener
        });
        lastCapturedEvent = event;
      } else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
        handler({
          event,
          name: name69,
          global: globalListener
        });
        lastCapturedEvent = event;
      }
      clearTimeout(debounceTimerID);
      debounceTimerID = global3.setTimeout(function() {
        debounceTimerID = void 0;
      }, debounceDuration);
    };
  }
  function instrumentDOM() {
    if (!("document" in global3)) {
      return;
    }
    var triggerDOMHandler = triggerHandlers.bind(null, "dom");
    var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
    global3.document.addEventListener("click", globalDOMEventHandler, false);
    global3.document.addEventListener("keypress", globalDOMEventHandler, false);
    ["EventTarget", "Node"].forEach(function(target) {
      var proto = global3[target] && global3[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto, "addEventListener", function(originalAddEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              var el = this;
              var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers_1[type] = handlers_1[type] || { refCount: 0 };
              if (!handlerForType.handler) {
                var handler = makeDOMEventHandler(triggerDOMHandler);
                handlerForType.handler = handler;
                originalAddEventListener.call(this, type, handler, options);
              }
              handlerForType.refCount += 1;
            } catch (e) {
            }
          }
          return originalAddEventListener.call(this, type, listener, options);
        };
      });
      fill(proto, "removeEventListener", function(originalRemoveEventListener) {
        return function(type, listener, options) {
          if (type === "click" || type == "keypress") {
            try {
              var el = this;
              var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
              var handlerForType = handlers_2[type];
              if (handlerForType) {
                handlerForType.refCount -= 1;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                  handlerForType.handler = void 0;
                  delete handlers_2[type];
                }
                if (Object.keys(handlers_2).length === 0) {
                  delete el.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options);
        };
      });
    });
  }
  var _oldOnErrorHandler = null;
  function instrumentError() {
    _oldOnErrorHandler = global3.onerror;
    global3.onerror = function(msg, url, line, column2, error) {
      triggerHandlers("error", {
        column: column2,
        error,
        line,
        msg,
        url
      });
      if (_oldOnErrorHandler) {
        return _oldOnErrorHandler.apply(this, arguments);
      }
      return false;
    };
  }
  var _oldOnUnhandledRejectionHandler = null;
  function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = global3.onunhandledrejection;
    global3.onunhandledrejection = function(e) {
      triggerHandlers("unhandledrejection", e);
      if (_oldOnUnhandledRejectionHandler) {
        return _oldOnUnhandledRejectionHandler.apply(this, arguments);
      }
      return true;
    };
  }

  // ../node_modules/@sentry/utils/esm/memo.js
  function memoBuilder() {
    var hasWeakSet = typeof WeakSet === "function";
    var inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
    function memoize(obj) {
      if (hasWeakSet) {
        if (inner.has(obj)) {
          return true;
        }
        inner.add(obj);
        return false;
      }
      for (var i = 0; i < inner.length; i++) {
        var value = inner[i];
        if (value === obj) {
          return true;
        }
      }
      inner.push(obj);
      return false;
    }
    function unmemoize(obj) {
      if (hasWeakSet) {
        inner.delete(obj);
      } else {
        for (var i = 0; i < inner.length; i++) {
          if (inner[i] === obj) {
            inner.splice(i, 1);
            break;
          }
        }
      }
    }
    return [memoize, unmemoize];
  }

  // ../node_modules/@sentry/utils/esm/misc.js
  function uuid4() {
    var global12 = getGlobalObject();
    var crypto2 = global12.crypto || global12.msCrypto;
    if (!(crypto2 === void 0) && crypto2.getRandomValues) {
      var arr = new Uint16Array(8);
      crypto2.getRandomValues(arr);
      arr[3] = arr[3] & 4095 | 16384;
      arr[4] = arr[4] & 16383 | 32768;
      var pad = function(num) {
        var v = num.toString(16);
        while (v.length < 4) {
          v = "0" + v;
        }
        return v;
      };
      return pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]);
    }
    return "xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = Math.random() * 16 | 0;
      var v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  function parseUrl(url) {
    if (!url) {
      return {};
    }
    var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!match) {
      return {};
    }
    var query = match[6] || "";
    var fragment = match[8] || "";
    return {
      host: match[4],
      path: match[5],
      protocol: match[2],
      relative: match[5] + query + fragment
    };
  }
  function getFirstException(event) {
    return event.exception && event.exception.values ? event.exception.values[0] : void 0;
  }
  function getEventDescription(event) {
    var message = event.message, eventId = event.event_id;
    if (message) {
      return message;
    }
    var firstException = getFirstException(event);
    if (firstException) {
      if (firstException.type && firstException.value) {
        return firstException.type + ": " + firstException.value;
      }
      return firstException.type || firstException.value || eventId || "<unknown>";
    }
    return eventId || "<unknown>";
  }
  function addExceptionTypeValue(event, value, type) {
    var exception = event.exception = event.exception || {};
    var values = exception.values = exception.values || [];
    var firstException = values[0] = values[0] || {};
    if (!firstException.value) {
      firstException.value = value || "";
    }
    if (!firstException.type) {
      firstException.type = type || "Error";
    }
  }
  function addExceptionMechanism(event, newMechanism) {
    var firstException = getFirstException(event);
    if (!firstException) {
      return;
    }
    var defaultMechanism = { type: "generic", handled: true };
    var currentMechanism = firstException.mechanism;
    firstException.mechanism = __assign4(__assign4(__assign4({}, defaultMechanism), currentMechanism), newMechanism);
    if (newMechanism && "data" in newMechanism) {
      var mergedData = __assign4(__assign4({}, currentMechanism && currentMechanism.data), newMechanism.data);
      firstException.mechanism.data = mergedData;
    }
  }
  function checkOrSetAlreadyCaught(exception) {
    if (exception && exception.__sentry_captured__) {
      return true;
    }
    try {
      addNonEnumerableProperty(exception, "__sentry_captured__", true);
    } catch (err) {
    }
    return false;
  }

  // ../node_modules/@sentry/utils/esm/normalize.js
  function normalize(input, depth, maxProperties) {
    if (depth === void 0) {
      depth = Infinity;
    }
    if (maxProperties === void 0) {
      maxProperties = Infinity;
    }
    try {
      return visit("", input, depth, maxProperties);
    } catch (err) {
      return { ERROR: "**non-serializable** (" + err + ")" };
    }
  }
  function normalizeToSize(object, depth, maxSize) {
    if (depth === void 0) {
      depth = 3;
    }
    if (maxSize === void 0) {
      maxSize = 100 * 1024;
    }
    var normalized = normalize(object, depth);
    if (jsonSize(normalized) > maxSize) {
      return normalizeToSize(object, depth - 1, maxSize);
    }
    return normalized;
  }
  function visit(key, value, depth, maxProperties, memo9) {
    if (depth === void 0) {
      depth = Infinity;
    }
    if (maxProperties === void 0) {
      maxProperties = Infinity;
    }
    if (memo9 === void 0) {
      memo9 = memoBuilder();
    }
    var _a = __read4(memo9, 2), memoize = _a[0], unmemoize = _a[1];
    var valueWithToJSON = value;
    if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
      try {
        return valueWithToJSON.toJSON();
      } catch (err) {
      }
    }
    if (value === null || ["number", "boolean", "string"].includes(typeof value) && !isNaN2(value)) {
      return value;
    }
    var stringified = stringifyValue(key, value);
    if (!stringified.startsWith("[object ")) {
      return stringified;
    }
    if (depth === 0) {
      return stringified.replace("object ", "");
    }
    if (memoize(value)) {
      return "[Circular ~]";
    }
    var normalized = Array.isArray(value) ? [] : {};
    var numAdded = 0;
    var visitable = isError(value) || isEvent(value) ? convertToPlainObject(value) : value;
    for (var visitKey in visitable) {
      if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
        continue;
      }
      if (numAdded >= maxProperties) {
        normalized[visitKey] = "[MaxProperties ~]";
        break;
      }
      var visitValue = visitable[visitKey];
      normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo9);
      numAdded += 1;
    }
    unmemoize(value);
    return normalized;
  }
  function stringifyValue(key, value) {
    try {
      if (key === "domain" && value && typeof value === "object" && value._events) {
        return "[Domain]";
      }
      if (key === "domainEmitter") {
        return "[DomainEmitter]";
      }
      if (typeof global !== "undefined" && value === global) {
        return "[Global]";
      }
      if (typeof window !== "undefined" && value === window) {
        return "[Window]";
      }
      if (typeof document !== "undefined" && value === document) {
        return "[Document]";
      }
      if (isSyntheticEvent(value)) {
        return "[SyntheticEvent]";
      }
      if (typeof value === "number" && value !== value) {
        return "[NaN]";
      }
      if (value === void 0) {
        return "[undefined]";
      }
      if (typeof value === "function") {
        return "[Function: " + getFunctionName(value) + "]";
      }
      if (typeof value === "symbol") {
        return "[" + String(value) + "]";
      }
      if (typeof value === "bigint") {
        return "[BigInt: " + String(value) + "]";
      }
      return "[object " + Object.getPrototypeOf(value).constructor.name + "]";
    } catch (err) {
      return "**non-serializable** (" + err + ")";
    }
  }
  function utf8Length(value) {
    return ~-encodeURI(value).split(/%..|./).length;
  }
  function jsonSize(value) {
    return utf8Length(JSON.stringify(value));
  }

  // ../node_modules/@sentry/utils/esm/syncpromise.js
  function resolvedSyncPromise(value) {
    return new SyncPromise(function(resolve) {
      resolve(value);
    });
  }
  function rejectedSyncPromise(reason) {
    return new SyncPromise(function(_, reject) {
      reject(reason);
    });
  }
  var SyncPromise = function() {
    function SyncPromise2(executor) {
      var _this = this;
      this._state = 0;
      this._handlers = [];
      this._resolve = function(value) {
        _this._setResult(1, value);
      };
      this._reject = function(reason) {
        _this._setResult(2, reason);
      };
      this._setResult = function(state, value) {
        if (_this._state !== 0) {
          return;
        }
        if (isThenable(value)) {
          void value.then(_this._resolve, _this._reject);
          return;
        }
        _this._state = state;
        _this._value = value;
        _this._executeHandlers();
      };
      this._executeHandlers = function() {
        if (_this._state === 0) {
          return;
        }
        var cachedHandlers = _this._handlers.slice();
        _this._handlers = [];
        cachedHandlers.forEach(function(handler) {
          if (handler[0]) {
            return;
          }
          if (_this._state === 1) {
            handler[1](_this._value);
          }
          if (_this._state === 2) {
            handler[2](_this._value);
          }
          handler[0] = true;
        });
      };
      try {
        executor(this._resolve, this._reject);
      } catch (e) {
        this._reject(e);
      }
    }
    SyncPromise2.prototype.then = function(onfulfilled, onrejected) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        _this._handlers.push([
          false,
          function(result) {
            if (!onfulfilled) {
              resolve(result);
            } else {
              try {
                resolve(onfulfilled(result));
              } catch (e) {
                reject(e);
              }
            }
          },
          function(reason) {
            if (!onrejected) {
              reject(reason);
            } else {
              try {
                resolve(onrejected(reason));
              } catch (e) {
                reject(e);
              }
            }
          }
        ]);
        _this._executeHandlers();
      });
    };
    SyncPromise2.prototype.catch = function(onrejected) {
      return this.then(function(val) {
        return val;
      }, onrejected);
    };
    SyncPromise2.prototype.finally = function(onfinally) {
      var _this = this;
      return new SyncPromise2(function(resolve, reject) {
        var val;
        var isRejected;
        return _this.then(function(value) {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        }, function(reason) {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }).then(function() {
          if (isRejected) {
            reject(val);
            return;
          }
          resolve(val);
        });
      });
    };
    return SyncPromise2;
  }();

  // ../node_modules/@sentry/utils/esm/promisebuffer.js
  function makePromiseBuffer(limit) {
    var buffer = [];
    function isReady2() {
      return limit === void 0 || buffer.length < limit;
    }
    function remove(task) {
      return buffer.splice(buffer.indexOf(task), 1)[0];
    }
    function add3(taskProducer) {
      if (!isReady2()) {
        return rejectedSyncPromise(new SentryError("Not adding Promise due to buffer limit reached."));
      }
      var task = taskProducer();
      if (buffer.indexOf(task) === -1) {
        buffer.push(task);
      }
      void task.then(function() {
        return remove(task);
      }).then(null, function() {
        return remove(task).then(null, function() {
        });
      });
      return task;
    }
    function drain(timeout) {
      return new SyncPromise(function(resolve, reject) {
        var counter = buffer.length;
        if (!counter) {
          return resolve(true);
        }
        var capturedSetTimeout = setTimeout(function() {
          if (timeout && timeout > 0) {
            resolve(false);
          }
        }, timeout);
        buffer.forEach(function(item) {
          void resolvedSyncPromise(item).then(function() {
            if (!--counter) {
              clearTimeout(capturedSetTimeout);
              resolve(true);
            }
          }, reject);
        });
      });
    }
    return {
      $: buffer,
      add: add3,
      drain
    };
  }

  // ../node_modules/@sentry/utils/esm/severity.js
  function isSupportedSeverity(level) {
    return SeverityLevels.indexOf(level) !== -1;
  }
  function severityFromString(level) {
    if (level === "warn")
      return Severity.Warning;
    if (isSupportedSeverity(level)) {
      return level;
    }
    return Severity.Log;
  }

  // ../node_modules/@sentry/utils/esm/status.js
  function eventStatusFromHttpCode(code) {
    if (code >= 200 && code < 300) {
      return "success";
    }
    if (code === 429) {
      return "rate_limit";
    }
    if (code >= 400 && code < 500) {
      return "invalid";
    }
    if (code >= 500) {
      return "failed";
    }
    return "unknown";
  }

  // ../node_modules/@sentry/utils/esm/time.js
  var dateTimestampSource = {
    nowSeconds: function() {
      return Date.now() / 1e3;
    }
  };
  function getBrowserPerformance() {
    var performance2 = getGlobalObject().performance;
    if (!performance2 || !performance2.now) {
      return void 0;
    }
    var timeOrigin = Date.now() - performance2.now();
    return {
      now: function() {
        return performance2.now();
      },
      timeOrigin
    };
  }
  function getNodePerformance() {
    try {
      var perfHooks = dynamicRequire(module, "perf_hooks");
      return perfHooks.performance;
    } catch (_) {
      return void 0;
    }
  }
  var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
  var timestampSource = platformPerformance === void 0 ? dateTimestampSource : {
    nowSeconds: function() {
      return (platformPerformance.timeOrigin + platformPerformance.now()) / 1e3;
    }
  };
  var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
  var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
  var timestampWithMs = timestampInSeconds;
  var _browserPerformanceTimeOriginMode;
  var browserPerformanceTimeOrigin = function() {
    var performance2 = getGlobalObject().performance;
    if (!performance2 || !performance2.now) {
      _browserPerformanceTimeOriginMode = "none";
      return void 0;
    }
    var threshold = 3600 * 1e3;
    var performanceNow = performance2.now();
    var dateNow = Date.now();
    var timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
    var timeOriginIsReliable = timeOriginDelta < threshold;
    var navigationStart = performance2.timing && performance2.timing.navigationStart;
    var hasNavigationStart = typeof navigationStart === "number";
    var navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
    var navigationStartIsReliable = navigationStartDelta < threshold;
    if (timeOriginIsReliable || navigationStartIsReliable) {
      if (timeOriginDelta <= navigationStartDelta) {
        _browserPerformanceTimeOriginMode = "timeOrigin";
        return performance2.timeOrigin;
      } else {
        _browserPerformanceTimeOriginMode = "navigationStart";
        return navigationStart;
      }
    }
    _browserPerformanceTimeOriginMode = "dateNow";
    return dateNow;
  }();

  // ../node_modules/@sentry/utils/esm/tracing.js
  var TRACEPARENT_REGEXP = new RegExp("^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$");
  function extractTraceparentData(traceparent) {
    var matches = traceparent.match(TRACEPARENT_REGEXP);
    if (matches) {
      var parentSampled = void 0;
      if (matches[3] === "1") {
        parentSampled = true;
      } else if (matches[3] === "0") {
        parentSampled = false;
      }
      return {
        traceId: matches[1],
        parentSampled,
        parentSpanId: matches[2]
      };
    }
    return void 0;
  }

  // ../node_modules/@sentry/utils/esm/envelope.js
  function createEnvelope(headers, items) {
    if (items === void 0) {
      items = [];
    }
    return [headers, items];
  }
  function getEnvelopeType(envelope) {
    var _a = __read4(envelope, 2), _b = __read4(_a[1], 1), _c = __read4(_b[0], 1), firstItemHeader = _c[0];
    return firstItemHeader.type;
  }
  function serializeEnvelope(envelope) {
    var _a = __read4(envelope, 2), headers = _a[0], items = _a[1];
    var serializedHeaders = JSON.stringify(headers);
    return items.reduce(function(acc, item) {
      var _a2 = __read4(item, 2), itemHeaders = _a2[0], payload = _a2[1];
      var serializedPayload = isPrimitive(payload) ? String(payload) : JSON.stringify(payload);
      return acc + "\n" + JSON.stringify(itemHeaders) + "\n" + serializedPayload;
    }, serializedHeaders);
  }

  // ../node_modules/@sentry/utils/esm/clientreport.js
  function createClientReportEnvelope(discarded_events, dsn, timestamp) {
    var clientReportItem = [
      { type: "client_report" },
      {
        timestamp: timestamp || dateTimestampInSeconds(),
        discarded_events
      }
    ];
    return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
  }

  // ../node_modules/@sentry/utils/esm/ratelimit.js
  var DEFAULT_RETRY_AFTER = 60 * 1e3;
  function parseRetryAfterHeader(header, now) {
    if (now === void 0) {
      now = Date.now();
    }
    var headerDelay = parseInt("" + header, 10);
    if (!isNaN(headerDelay)) {
      return headerDelay * 1e3;
    }
    var headerDate = Date.parse("" + header);
    if (!isNaN(headerDate)) {
      return headerDate - now;
    }
    return DEFAULT_RETRY_AFTER;
  }
  function disabledUntil(limits, category) {
    return limits[category] || limits.all || 0;
  }
  function isRateLimited(limits, category, now) {
    if (now === void 0) {
      now = Date.now();
    }
    return disabledUntil(limits, category) > now;
  }
  function updateRateLimits(limits, headers, now) {
    var e_1, _a, e_2, _b;
    if (now === void 0) {
      now = Date.now();
    }
    var updatedRateLimits = __assign4({}, limits);
    var rateLimitHeader = headers["x-sentry-rate-limits"];
    var retryAfterHeader = headers["retry-after"];
    if (rateLimitHeader) {
      try {
        for (var _c = __values4(rateLimitHeader.trim().split(",")), _d = _c.next(); !_d.done; _d = _c.next()) {
          var limit = _d.value;
          var parameters = limit.split(":", 2);
          var headerDelay = parseInt(parameters[0], 10);
          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
          if (!parameters[1]) {
            updatedRateLimits.all = now + delay;
          } else {
            try {
              for (var _e = (e_2 = void 0, __values4(parameters[1].split(";"))), _f = _e.next(); !_f.done; _f = _e.next()) {
                var category = _f.value;
                updatedRateLimits[category] = now + delay;
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_f && !_f.done && (_b = _e.return))
                  _b.call(_e);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    } else if (retryAfterHeader) {
      updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
    }
    return updatedRateLimits;
  }

  // ../node_modules/@sentry/hub/esm/scope.js
  var MAX_BREADCRUMBS = 100;
  var Scope = function() {
    function Scope2() {
      this._notifyingListeners = false;
      this._scopeListeners = [];
      this._eventProcessors = [];
      this._breadcrumbs = [];
      this._user = {};
      this._tags = {};
      this._extra = {};
      this._contexts = {};
      this._sdkProcessingMetadata = {};
    }
    Scope2.clone = function(scope) {
      var newScope = new Scope2();
      if (scope) {
        newScope._breadcrumbs = __spread3(scope._breadcrumbs);
        newScope._tags = __assign3({}, scope._tags);
        newScope._extra = __assign3({}, scope._extra);
        newScope._contexts = __assign3({}, scope._contexts);
        newScope._user = scope._user;
        newScope._level = scope._level;
        newScope._span = scope._span;
        newScope._session = scope._session;
        newScope._transactionName = scope._transactionName;
        newScope._fingerprint = scope._fingerprint;
        newScope._eventProcessors = __spread3(scope._eventProcessors);
        newScope._requestSession = scope._requestSession;
      }
      return newScope;
    };
    Scope2.prototype.addScopeListener = function(callback) {
      this._scopeListeners.push(callback);
    };
    Scope2.prototype.addEventProcessor = function(callback) {
      this._eventProcessors.push(callback);
      return this;
    };
    Scope2.prototype.setUser = function(user) {
      this._user = user || {};
      if (this._session) {
        this._session.update({ user });
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getUser = function() {
      return this._user;
    };
    Scope2.prototype.getRequestSession = function() {
      return this._requestSession;
    };
    Scope2.prototype.setRequestSession = function(requestSession) {
      this._requestSession = requestSession;
      return this;
    };
    Scope2.prototype.setTags = function(tags) {
      this._tags = __assign3(__assign3({}, this._tags), tags);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTag = function(key, value) {
      var _a;
      this._tags = __assign3(__assign3({}, this._tags), (_a = {}, _a[key] = value, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtras = function(extras) {
      this._extra = __assign3(__assign3({}, this._extra), extras);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setExtra = function(key, extra) {
      var _a;
      this._extra = __assign3(__assign3({}, this._extra), (_a = {}, _a[key] = extra, _a));
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setFingerprint = function(fingerprint) {
      this._fingerprint = fingerprint;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setLevel = function(level) {
      this._level = level;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransactionName = function(name69) {
      this._transactionName = name69;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setTransaction = function(name69) {
      return this.setTransactionName(name69);
    };
    Scope2.prototype.setContext = function(key, context) {
      var _a;
      if (context === null) {
        delete this._contexts[key];
      } else {
        this._contexts = __assign3(__assign3({}, this._contexts), (_a = {}, _a[key] = context, _a));
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.setSpan = function(span) {
      this._span = span;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSpan = function() {
      return this._span;
    };
    Scope2.prototype.getTransaction = function() {
      var span = this.getSpan();
      return span && span.transaction;
    };
    Scope2.prototype.setSession = function(session) {
      if (!session) {
        delete this._session;
      } else {
        this._session = session;
      }
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.getSession = function() {
      return this._session;
    };
    Scope2.prototype.update = function(captureContext) {
      if (!captureContext) {
        return this;
      }
      if (typeof captureContext === "function") {
        var updatedScope = captureContext(this);
        return updatedScope instanceof Scope2 ? updatedScope : this;
      }
      if (captureContext instanceof Scope2) {
        this._tags = __assign3(__assign3({}, this._tags), captureContext._tags);
        this._extra = __assign3(__assign3({}, this._extra), captureContext._extra);
        this._contexts = __assign3(__assign3({}, this._contexts), captureContext._contexts);
        if (captureContext._user && Object.keys(captureContext._user).length) {
          this._user = captureContext._user;
        }
        if (captureContext._level) {
          this._level = captureContext._level;
        }
        if (captureContext._fingerprint) {
          this._fingerprint = captureContext._fingerprint;
        }
        if (captureContext._requestSession) {
          this._requestSession = captureContext._requestSession;
        }
      } else if (isPlainObject2(captureContext)) {
        captureContext = captureContext;
        this._tags = __assign3(__assign3({}, this._tags), captureContext.tags);
        this._extra = __assign3(__assign3({}, this._extra), captureContext.extra);
        this._contexts = __assign3(__assign3({}, this._contexts), captureContext.contexts);
        if (captureContext.user) {
          this._user = captureContext.user;
        }
        if (captureContext.level) {
          this._level = captureContext.level;
        }
        if (captureContext.fingerprint) {
          this._fingerprint = captureContext.fingerprint;
        }
        if (captureContext.requestSession) {
          this._requestSession = captureContext.requestSession;
        }
      }
      return this;
    };
    Scope2.prototype.clear = function() {
      this._breadcrumbs = [];
      this._tags = {};
      this._extra = {};
      this._user = {};
      this._contexts = {};
      this._level = void 0;
      this._transactionName = void 0;
      this._fingerprint = void 0;
      this._requestSession = void 0;
      this._span = void 0;
      this._session = void 0;
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.addBreadcrumb = function(breadcrumb, maxBreadcrumbs) {
      var maxCrumbs = typeof maxBreadcrumbs === "number" ? Math.min(maxBreadcrumbs, MAX_BREADCRUMBS) : MAX_BREADCRUMBS;
      if (maxCrumbs <= 0) {
        return this;
      }
      var mergedBreadcrumb = __assign3({ timestamp: dateTimestampInSeconds() }, breadcrumb);
      this._breadcrumbs = __spread3(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxCrumbs);
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.clearBreadcrumbs = function() {
      this._breadcrumbs = [];
      this._notifyScopeListeners();
      return this;
    };
    Scope2.prototype.applyToEvent = function(event, hint) {
      if (this._extra && Object.keys(this._extra).length) {
        event.extra = __assign3(__assign3({}, this._extra), event.extra);
      }
      if (this._tags && Object.keys(this._tags).length) {
        event.tags = __assign3(__assign3({}, this._tags), event.tags);
      }
      if (this._user && Object.keys(this._user).length) {
        event.user = __assign3(__assign3({}, this._user), event.user);
      }
      if (this._contexts && Object.keys(this._contexts).length) {
        event.contexts = __assign3(__assign3({}, this._contexts), event.contexts);
      }
      if (this._level) {
        event.level = this._level;
      }
      if (this._transactionName) {
        event.transaction = this._transactionName;
      }
      if (this._span) {
        event.contexts = __assign3({ trace: this._span.getTraceContext() }, event.contexts);
        var transactionName = this._span.transaction && this._span.transaction.name;
        if (transactionName) {
          event.tags = __assign3({ transaction: transactionName }, event.tags);
        }
      }
      this._applyFingerprint(event);
      event.breadcrumbs = __spread3(event.breadcrumbs || [], this._breadcrumbs);
      event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : void 0;
      event.sdkProcessingMetadata = this._sdkProcessingMetadata;
      return this._notifyEventProcessors(__spread3(getGlobalEventProcessors(), this._eventProcessors), event, hint);
    };
    Scope2.prototype.setSDKProcessingMetadata = function(newData) {
      this._sdkProcessingMetadata = __assign3(__assign3({}, this._sdkProcessingMetadata), newData);
      return this;
    };
    Scope2.prototype._notifyEventProcessors = function(processors, event, hint, index) {
      var _this = this;
      if (index === void 0) {
        index = 0;
      }
      return new SyncPromise(function(resolve, reject) {
        var processor = processors[index];
        if (event === null || typeof processor !== "function") {
          resolve(event);
        } else {
          var result = processor(__assign3({}, event), hint);
          if (isThenable(result)) {
            void result.then(function(final) {
              return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve);
            }).then(null, reject);
          } else {
            void _this._notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
          }
        }
      });
    };
    Scope2.prototype._notifyScopeListeners = function() {
      var _this = this;
      if (!this._notifyingListeners) {
        this._notifyingListeners = true;
        this._scopeListeners.forEach(function(callback) {
          callback(_this);
        });
        this._notifyingListeners = false;
      }
    };
    Scope2.prototype._applyFingerprint = function(event) {
      event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
      if (this._fingerprint) {
        event.fingerprint = event.fingerprint.concat(this._fingerprint);
      }
      if (event.fingerprint && !event.fingerprint.length) {
        delete event.fingerprint;
      }
    };
    return Scope2;
  }();
  function getGlobalEventProcessors() {
    return getGlobalSingleton("globalEventProcessors", function() {
      return [];
    });
  }
  function addGlobalEventProcessor(callback) {
    getGlobalEventProcessors().push(callback);
  }

  // ../node_modules/@sentry/hub/esm/session.js
  var Session = function() {
    function Session2(context) {
      this.errors = 0;
      this.sid = uuid4();
      this.duration = 0;
      this.status = "ok";
      this.init = true;
      this.ignoreDuration = false;
      var startingTime = timestampInSeconds();
      this.timestamp = startingTime;
      this.started = startingTime;
      if (context) {
        this.update(context);
      }
    }
    Session2.prototype.update = function(context) {
      if (context === void 0) {
        context = {};
      }
      if (context.user) {
        if (!this.ipAddress && context.user.ip_address) {
          this.ipAddress = context.user.ip_address;
        }
        if (!this.did && !context.did) {
          this.did = context.user.id || context.user.email || context.user.username;
        }
      }
      this.timestamp = context.timestamp || timestampInSeconds();
      if (context.ignoreDuration) {
        this.ignoreDuration = context.ignoreDuration;
      }
      if (context.sid) {
        this.sid = context.sid.length === 32 ? context.sid : uuid4();
      }
      if (context.init !== void 0) {
        this.init = context.init;
      }
      if (!this.did && context.did) {
        this.did = "" + context.did;
      }
      if (typeof context.started === "number") {
        this.started = context.started;
      }
      if (this.ignoreDuration) {
        this.duration = void 0;
      } else if (typeof context.duration === "number") {
        this.duration = context.duration;
      } else {
        var duration = this.timestamp - this.started;
        this.duration = duration >= 0 ? duration : 0;
      }
      if (context.release) {
        this.release = context.release;
      }
      if (context.environment) {
        this.environment = context.environment;
      }
      if (!this.ipAddress && context.ipAddress) {
        this.ipAddress = context.ipAddress;
      }
      if (!this.userAgent && context.userAgent) {
        this.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        this.errors = context.errors;
      }
      if (context.status) {
        this.status = context.status;
      }
    };
    Session2.prototype.close = function(status) {
      if (status) {
        this.update({ status });
      } else if (this.status === "ok") {
        this.update({ status: "exited" });
      } else {
        this.update();
      }
    };
    Session2.prototype.toJSON = function() {
      return dropUndefinedKeys({
        sid: "" + this.sid,
        init: this.init,
        started: new Date(this.started * 1e3).toISOString(),
        timestamp: new Date(this.timestamp * 1e3).toISOString(),
        status: this.status,
        errors: this.errors,
        did: typeof this.did === "number" || typeof this.did === "string" ? "" + this.did : void 0,
        duration: this.duration,
        attrs: {
          release: this.release,
          environment: this.environment,
          ip_address: this.ipAddress,
          user_agent: this.userAgent
        }
      });
    };
    return Session2;
  }();

  // ../node_modules/@sentry/hub/esm/flags.js
  var IS_DEBUG_BUILD2 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/hub/esm/hub.js
  var API_VERSION = 4;
  var DEFAULT_BREADCRUMBS = 100;
  var Hub = function() {
    function Hub2(client, scope, _version) {
      if (scope === void 0) {
        scope = new Scope();
      }
      if (_version === void 0) {
        _version = API_VERSION;
      }
      this._version = _version;
      this._stack = [{}];
      this.getStackTop().scope = scope;
      if (client) {
        this.bindClient(client);
      }
    }
    Hub2.prototype.isOlderThan = function(version) {
      return this._version < version;
    };
    Hub2.prototype.bindClient = function(client) {
      var top = this.getStackTop();
      top.client = client;
      if (client && client.setupIntegrations) {
        client.setupIntegrations();
      }
    };
    Hub2.prototype.pushScope = function() {
      var scope = Scope.clone(this.getScope());
      this.getStack().push({
        client: this.getClient(),
        scope
      });
      return scope;
    };
    Hub2.prototype.popScope = function() {
      if (this.getStack().length <= 1)
        return false;
      return !!this.getStack().pop();
    };
    Hub2.prototype.withScope = function(callback) {
      var scope = this.pushScope();
      try {
        callback(scope);
      } finally {
        this.popScope();
      }
    };
    Hub2.prototype.getClient = function() {
      return this.getStackTop().client;
    };
    Hub2.prototype.getScope = function() {
      return this.getStackTop().scope;
    };
    Hub2.prototype.getStack = function() {
      return this._stack;
    };
    Hub2.prototype.getStackTop = function() {
      return this._stack[this._stack.length - 1];
    };
    Hub2.prototype.captureException = function(exception, hint) {
      var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error("Sentry syntheticException");
        } catch (exception2) {
          syntheticException = exception2;
        }
        finalHint = {
          originalException: exception,
          syntheticException
        };
      }
      this._invokeClient("captureException", exception, __assign3(__assign3({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureMessage = function(message, level, hint) {
      var eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : uuid4();
      var finalHint = hint;
      if (!hint) {
        var syntheticException = void 0;
        try {
          throw new Error(message);
        } catch (exception) {
          syntheticException = exception;
        }
        finalHint = {
          originalException: message,
          syntheticException
        };
      }
      this._invokeClient("captureMessage", message, level, __assign3(__assign3({}, finalHint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.captureEvent = function(event, hint) {
      var eventId = hint && hint.event_id ? hint.event_id : uuid4();
      if (event.type !== "transaction") {
        this._lastEventId = eventId;
      }
      this._invokeClient("captureEvent", event, __assign3(__assign3({}, hint), { event_id: eventId }));
      return eventId;
    };
    Hub2.prototype.lastEventId = function() {
      return this._lastEventId;
    };
    Hub2.prototype.addBreadcrumb = function(breadcrumb, hint) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope || !client)
        return;
      var _b = client.getOptions && client.getOptions() || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
      if (maxBreadcrumbs <= 0)
        return;
      var timestamp = dateTimestampInSeconds();
      var mergedBreadcrumb = __assign3({ timestamp }, breadcrumb);
      var finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(function() {
        return beforeBreadcrumb(mergedBreadcrumb, hint);
      }) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    };
    Hub2.prototype.setUser = function(user) {
      var scope = this.getScope();
      if (scope)
        scope.setUser(user);
    };
    Hub2.prototype.setTags = function(tags) {
      var scope = this.getScope();
      if (scope)
        scope.setTags(tags);
    };
    Hub2.prototype.setExtras = function(extras) {
      var scope = this.getScope();
      if (scope)
        scope.setExtras(extras);
    };
    Hub2.prototype.setTag = function(key, value) {
      var scope = this.getScope();
      if (scope)
        scope.setTag(key, value);
    };
    Hub2.prototype.setExtra = function(key, extra) {
      var scope = this.getScope();
      if (scope)
        scope.setExtra(key, extra);
    };
    Hub2.prototype.setContext = function(name69, context) {
      var scope = this.getScope();
      if (scope)
        scope.setContext(name69, context);
    };
    Hub2.prototype.configureScope = function(callback) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (scope && client) {
        callback(scope);
      }
    };
    Hub2.prototype.run = function(callback) {
      var oldHub = makeMain(this);
      try {
        callback(this);
      } finally {
        makeMain(oldHub);
      }
    };
    Hub2.prototype.getIntegration = function(integration) {
      var client = this.getClient();
      if (!client)
        return null;
      try {
        return client.getIntegration(integration);
      } catch (_oO) {
        IS_DEBUG_BUILD2 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
        return null;
      }
    };
    Hub2.prototype.startSpan = function(context) {
      return this._callExtensionMethod("startSpan", context);
    };
    Hub2.prototype.startTransaction = function(context, customSamplingContext) {
      return this._callExtensionMethod("startTransaction", context, customSamplingContext);
    };
    Hub2.prototype.traceHeaders = function() {
      return this._callExtensionMethod("traceHeaders");
    };
    Hub2.prototype.captureSession = function(endSession) {
      if (endSession === void 0) {
        endSession = false;
      }
      if (endSession) {
        return this.endSession();
      }
      this._sendSessionUpdate();
    };
    Hub2.prototype.endSession = function() {
      var layer = this.getStackTop();
      var scope = layer && layer.scope;
      var session = scope && scope.getSession();
      if (session) {
        session.close();
      }
      this._sendSessionUpdate();
      if (scope) {
        scope.setSession();
      }
    };
    Hub2.prototype.startSession = function(context) {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      var _b = client && client.getOptions() || {}, release = _b.release, environment = _b.environment;
      var global12 = getGlobalObject();
      var userAgent = (global12.navigator || {}).userAgent;
      var session = new Session(__assign3(__assign3(__assign3({
        release,
        environment
      }, scope && { user: scope.getUser() }), userAgent && { userAgent }), context));
      if (scope) {
        var currentSession = scope.getSession && scope.getSession();
        if (currentSession && currentSession.status === "ok") {
          currentSession.update({ status: "exited" });
        }
        this.endSession();
        scope.setSession(session);
      }
      return session;
    };
    Hub2.prototype._sendSessionUpdate = function() {
      var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
      if (!scope)
        return;
      var session = scope.getSession && scope.getSession();
      if (session) {
        if (client && client.captureSession) {
          client.captureSession(session);
        }
      }
    };
    Hub2.prototype._invokeClient = function(method) {
      var _a;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
      if (client && client[method]) {
        (_a = client)[method].apply(_a, __spread3(args, [scope]));
      }
    };
    Hub2.prototype._callExtensionMethod = function(method) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var carrier = getMainCarrier();
      var sentry = carrier.__SENTRY__;
      if (sentry && sentry.extensions && typeof sentry.extensions[method] === "function") {
        return sentry.extensions[method].apply(this, args);
      }
      IS_DEBUG_BUILD2 && logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
    };
    return Hub2;
  }();
  function getMainCarrier() {
    var carrier = getGlobalObject();
    carrier.__SENTRY__ = carrier.__SENTRY__ || {
      extensions: {},
      hub: void 0
    };
    return carrier;
  }
  function makeMain(hub) {
    var registry = getMainCarrier();
    var oldHub = getHubFromCarrier(registry);
    setHubOnCarrier(registry, hub);
    return oldHub;
  }
  function getCurrentHub() {
    var registry = getMainCarrier();
    if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
      setHubOnCarrier(registry, new Hub());
    }
    if (isNodeEnv()) {
      return getHubFromActiveDomain(registry);
    }
    return getHubFromCarrier(registry);
  }
  function getHubFromActiveDomain(registry) {
    try {
      var sentry = getMainCarrier().__SENTRY__;
      var activeDomain = sentry && sentry.extensions && sentry.extensions.domain && sentry.extensions.domain.active;
      if (!activeDomain) {
        return getHubFromCarrier(registry);
      }
      if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
        var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
        setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
      }
      return getHubFromCarrier(activeDomain);
    } catch (_Oo) {
      return getHubFromCarrier(registry);
    }
  }
  function hasHubOnCarrier(carrier) {
    return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
  }
  function getHubFromCarrier(carrier) {
    return getGlobalSingleton("hub", function() {
      return new Hub();
    }, carrier);
  }
  function setHubOnCarrier(carrier, hub) {
    if (!carrier)
      return false;
    var __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
    __SENTRY__.hub = hub;
    return true;
  }

  // ../node_modules/@sentry/minimal/esm/index.js
  function callOnHub(method) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var hub = getCurrentHub();
    if (hub && hub[method]) {
      return hub[method].apply(hub, __spread2(args));
    }
    throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
  }
  function captureException(exception, captureContext) {
    var syntheticException = new Error("Sentry syntheticException");
    return callOnHub("captureException", exception, {
      captureContext,
      originalException: exception,
      syntheticException
    });
  }
  function setTag(key, value) {
    callOnHub("setTag", key, value);
  }
  function withScope(callback) {
    callOnHub("withScope", callback);
  }

  // ../node_modules/@sentry/core/esm/api.js
  var SENTRY_API_VERSION = "7";
  var API = function() {
    function API2(dsn, metadata, tunnel) {
      if (metadata === void 0) {
        metadata = {};
      }
      this.dsn = dsn;
      this._dsnObject = makeDsn(dsn);
      this.metadata = metadata;
      this._tunnel = tunnel;
    }
    API2.prototype.getDsn = function() {
      return this._dsnObject;
    };
    API2.prototype.forceEnvelope = function() {
      return !!this._tunnel;
    };
    API2.prototype.getBaseApiEndpoint = function() {
      return getBaseApiEndpoint(this._dsnObject);
    };
    API2.prototype.getStoreEndpoint = function() {
      return getStoreEndpoint(this._dsnObject);
    };
    API2.prototype.getStoreEndpointWithUrlEncodedAuth = function() {
      return getStoreEndpointWithUrlEncodedAuth(this._dsnObject);
    };
    API2.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function() {
      return getEnvelopeEndpointWithUrlEncodedAuth(this._dsnObject, this._tunnel);
    };
    return API2;
  }();
  function initAPIDetails(dsn, metadata, tunnel) {
    return {
      initDsn: dsn,
      metadata: metadata || {},
      dsn: makeDsn(dsn),
      tunnel
    };
  }
  function getBaseApiEndpoint(dsn) {
    var protocol = dsn.protocol ? dsn.protocol + ":" : "";
    var port = dsn.port ? ":" + dsn.port : "";
    return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : "") + "/api/";
  }
  function _getIngestEndpoint(dsn, target) {
    return "" + getBaseApiEndpoint(dsn) + dsn.projectId + "/" + target + "/";
  }
  function _encodedAuth(dsn) {
    return urlEncode({
      sentry_key: dsn.publicKey,
      sentry_version: SENTRY_API_VERSION
    });
  }
  function getStoreEndpoint(dsn) {
    return _getIngestEndpoint(dsn, "store");
  }
  function getStoreEndpointWithUrlEncodedAuth(dsn) {
    return getStoreEndpoint(dsn) + "?" + _encodedAuth(dsn);
  }
  function _getEnvelopeEndpoint(dsn) {
    return _getIngestEndpoint(dsn, "envelope");
  }
  function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel) {
    return tunnel ? tunnel : _getEnvelopeEndpoint(dsn) + "?" + _encodedAuth(dsn);
  }
  function getReportDialogEndpoint(dsnLike, dialogOptions) {
    var dsn = makeDsn(dsnLike);
    var endpoint = getBaseApiEndpoint(dsn) + "embed/error-page/";
    var encodedOptions = "dsn=" + dsnToString(dsn);
    for (var key in dialogOptions) {
      if (key === "dsn") {
        continue;
      }
      if (key === "user") {
        if (!dialogOptions.user) {
          continue;
        }
        if (dialogOptions.user.name) {
          encodedOptions += "&name=" + encodeURIComponent(dialogOptions.user.name);
        }
        if (dialogOptions.user.email) {
          encodedOptions += "&email=" + encodeURIComponent(dialogOptions.user.email);
        }
      } else {
        encodedOptions += "&" + encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]);
      }
    }
    return endpoint + "?" + encodedOptions;
  }

  // ../node_modules/@sentry/core/node_modules/tslib/modules/index.js
  var import_tslib18 = __toESM(require_tslib5(), 1);
  var {
    __extends: __extends5,
    __assign: __assign5,
    __rest: __rest5,
    __decorate: __decorate5,
    __param: __param5,
    __metadata: __metadata5,
    __awaiter: __awaiter6,
    __generator: __generator5,
    __exportStar: __exportStar5,
    __createBinding: __createBinding5,
    __values: __values5,
    __read: __read5,
    __spread: __spread5,
    __spreadArrays: __spreadArrays5,
    __await: __await5,
    __asyncGenerator: __asyncGenerator5,
    __asyncDelegator: __asyncDelegator5,
    __asyncValues: __asyncValues5,
    __makeTemplateObject: __makeTemplateObject5,
    __importStar: __importStar5,
    __importDefault: __importDefault5,
    __classPrivateFieldGet: __classPrivateFieldGet5,
    __classPrivateFieldSet: __classPrivateFieldSet5
  } = import_tslib18.default;

  // ../node_modules/@sentry/core/esm/flags.js
  var IS_DEBUG_BUILD3 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/core/esm/integration.js
  var installedIntegrations = [];
  function filterDuplicates(integrations) {
    return integrations.reduce(function(acc, integrations2) {
      if (acc.every(function(accIntegration) {
        return integrations2.name !== accIntegration.name;
      })) {
        acc.push(integrations2);
      }
      return acc;
    }, []);
  }
  function getIntegrationsToSetup(options) {
    var defaultIntegrations2 = options.defaultIntegrations && __spread5(options.defaultIntegrations) || [];
    var userIntegrations = options.integrations;
    var integrations = __spread5(filterDuplicates(defaultIntegrations2));
    if (Array.isArray(userIntegrations)) {
      integrations = __spread5(integrations.filter(function(integrations2) {
        return userIntegrations.every(function(userIntegration) {
          return userIntegration.name !== integrations2.name;
        });
      }), filterDuplicates(userIntegrations));
    } else if (typeof userIntegrations === "function") {
      integrations = userIntegrations(integrations);
      integrations = Array.isArray(integrations) ? integrations : [integrations];
    }
    var integrationsNames = integrations.map(function(i) {
      return i.name;
    });
    var alwaysLastToRun = "Debug";
    if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
      integrations.push.apply(integrations, __spread5(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
    }
    return integrations;
  }
  function setupIntegration(integration) {
    if (installedIntegrations.indexOf(integration.name) !== -1) {
      return;
    }
    integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
    installedIntegrations.push(integration.name);
    IS_DEBUG_BUILD3 && logger.log("Integration installed: " + integration.name);
  }
  function setupIntegrations(options) {
    var integrations = {};
    getIntegrationsToSetup(options).forEach(function(integration) {
      integrations[integration.name] = integration;
      setupIntegration(integration);
    });
    addNonEnumerableProperty(integrations, "initialized", true);
    return integrations;
  }

  // ../node_modules/@sentry/core/esm/baseclient.js
  var ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
  var BaseClient = function() {
    function BaseClient2(backendClass, options) {
      this._integrations = {};
      this._numProcessing = 0;
      this._backend = new backendClass(options);
      this._options = options;
      if (options.dsn) {
        this._dsn = makeDsn(options.dsn);
      }
    }
    BaseClient2.prototype.captureException = function(exception, hint, scope) {
      var _this = this;
      if (checkOrSetAlreadyCaught(exception)) {
        IS_DEBUG_BUILD3 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      var eventId = hint && hint.event_id;
      this._process(this._getBackend().eventFromException(exception, hint).then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureMessage = function(message, level, hint, scope) {
      var _this = this;
      var eventId = hint && hint.event_id;
      var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);
      this._process(promisedEvent.then(function(event) {
        return _this._captureEvent(event, hint, scope);
      }).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureEvent = function(event, hint, scope) {
      if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
        IS_DEBUG_BUILD3 && logger.log(ALREADY_SEEN_ERROR);
        return;
      }
      var eventId = hint && hint.event_id;
      this._process(this._captureEvent(event, hint, scope).then(function(result) {
        eventId = result;
      }));
      return eventId;
    };
    BaseClient2.prototype.captureSession = function(session) {
      if (!this._isEnabled()) {
        IS_DEBUG_BUILD3 && logger.warn("SDK not enabled, will not capture session.");
        return;
      }
      if (!(typeof session.release === "string")) {
        IS_DEBUG_BUILD3 && logger.warn("Discarded session because of missing or non-string release");
      } else {
        this._sendSession(session);
        session.update({ init: false });
      }
    };
    BaseClient2.prototype.getDsn = function() {
      return this._dsn;
    };
    BaseClient2.prototype.getOptions = function() {
      return this._options;
    };
    BaseClient2.prototype.getTransport = function() {
      return this._getBackend().getTransport();
    };
    BaseClient2.prototype.flush = function(timeout) {
      var _this = this;
      return this._isClientDoneProcessing(timeout).then(function(clientFinished) {
        return _this.getTransport().close(timeout).then(function(transportFlushed) {
          return clientFinished && transportFlushed;
        });
      });
    };
    BaseClient2.prototype.close = function(timeout) {
      var _this = this;
      return this.flush(timeout).then(function(result) {
        _this.getOptions().enabled = false;
        return result;
      });
    };
    BaseClient2.prototype.setupIntegrations = function() {
      if (this._isEnabled() && !this._integrations.initialized) {
        this._integrations = setupIntegrations(this._options);
      }
    };
    BaseClient2.prototype.getIntegration = function(integration) {
      try {
        return this._integrations[integration.id] || null;
      } catch (_oO) {
        IS_DEBUG_BUILD3 && logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
        return null;
      }
    };
    BaseClient2.prototype._updateSessionFromEvent = function(session, event) {
      var e_1, _a;
      var crashed = false;
      var errored = false;
      var exceptions = event.exception && event.exception.values;
      if (exceptions) {
        errored = true;
        try {
          for (var exceptions_1 = __values5(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
            var ex = exceptions_1_1.value;
            var mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return))
              _a.call(exceptions_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      var sessionNonTerminal = session.status === "ok";
      var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
      if (shouldUpdateAndSend) {
        session.update(__assign5(__assign5({}, crashed && { status: "crashed" }), { errors: session.errors || Number(errored || crashed) }));
        this.captureSession(session);
      }
    };
    BaseClient2.prototype._sendSession = function(session) {
      this._getBackend().sendSession(session);
    };
    BaseClient2.prototype._isClientDoneProcessing = function(timeout) {
      var _this = this;
      return new SyncPromise(function(resolve) {
        var ticked = 0;
        var tick = 1;
        var interval = setInterval(function() {
          if (_this._numProcessing == 0) {
            clearInterval(interval);
            resolve(true);
          } else {
            ticked += tick;
            if (timeout && ticked >= timeout) {
              clearInterval(interval);
              resolve(false);
            }
          }
        }, tick);
      });
    };
    BaseClient2.prototype._getBackend = function() {
      return this._backend;
    };
    BaseClient2.prototype._isEnabled = function() {
      return this.getOptions().enabled !== false && this._dsn !== void 0;
    };
    BaseClient2.prototype._prepareEvent = function(event, scope, hint) {
      var _this = this;
      var _a = this.getOptions(), _b = _a.normalizeDepth, normalizeDepth = _b === void 0 ? 3 : _b, _c = _a.normalizeMaxBreadth, normalizeMaxBreadth = _c === void 0 ? 1e3 : _c;
      var prepared = __assign5(__assign5({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()), timestamp: event.timestamp || dateTimestampInSeconds() });
      this._applyClientOptions(prepared);
      this._applyIntegrationsMetadata(prepared);
      var finalScope = scope;
      if (hint && hint.captureContext) {
        finalScope = Scope.clone(finalScope).update(hint.captureContext);
      }
      var result = resolvedSyncPromise(prepared);
      if (finalScope) {
        result = finalScope.applyToEvent(prepared, hint);
      }
      return result.then(function(evt) {
        if (evt) {
          evt.sdkProcessingMetadata = __assign5(__assign5({}, evt.sdkProcessingMetadata), { normalizeDepth: normalize(normalizeDepth) + " (" + typeof normalizeDepth + ")" });
        }
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
        }
        return evt;
      });
    };
    BaseClient2.prototype._normalizeEvent = function(event, depth, maxBreadth) {
      if (!event) {
        return null;
      }
      var normalized = __assign5(__assign5(__assign5(__assign5(__assign5({}, event), event.breadcrumbs && {
        breadcrumbs: event.breadcrumbs.map(function(b) {
          return __assign5(__assign5({}, b), b.data && {
            data: normalize(b.data, depth, maxBreadth)
          });
        })
      }), event.user && {
        user: normalize(event.user, depth, maxBreadth)
      }), event.contexts && {
        contexts: normalize(event.contexts, depth, maxBreadth)
      }), event.extra && {
        extra: normalize(event.extra, depth, maxBreadth)
      });
      if (event.contexts && event.contexts.trace) {
        normalized.contexts.trace = event.contexts.trace;
      }
      normalized.sdkProcessingMetadata = __assign5(__assign5({}, normalized.sdkProcessingMetadata), { baseClientNormalized: true });
      return normalized;
    };
    BaseClient2.prototype._applyClientOptions = function(event) {
      var options = this.getOptions();
      var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : "production";
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = truncate2(event.message, maxValueLength);
      }
      var exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = truncate2(exception.value, maxValueLength);
      }
      var request = event.request;
      if (request && request.url) {
        request.url = truncate2(request.url, maxValueLength);
      }
    };
    BaseClient2.prototype._applyIntegrationsMetadata = function(event) {
      var integrationsArray = Object.keys(this._integrations);
      if (integrationsArray.length > 0) {
        event.sdk = event.sdk || {};
        event.sdk.integrations = __spread5(event.sdk.integrations || [], integrationsArray);
      }
    };
    BaseClient2.prototype._sendEvent = function(event) {
      this._getBackend().sendEvent(event);
    };
    BaseClient2.prototype._captureEvent = function(event, hint, scope) {
      return this._processEvent(event, hint, scope).then(function(finalEvent) {
        return finalEvent.event_id;
      }, function(reason) {
        IS_DEBUG_BUILD3 && logger.error(reason);
        return void 0;
      });
    };
    BaseClient2.prototype._processEvent = function(event, hint, scope) {
      var _this = this;
      var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
      var transport = this.getTransport();
      function recordLostEvent(outcome, category) {
        if (transport.recordLostEvent) {
          transport.recordLostEvent(outcome, category);
        }
      }
      if (!this._isEnabled()) {
        return rejectedSyncPromise(new SentryError("SDK not enabled, will not capture event."));
      }
      var isTransaction = event.type === "transaction";
      if (!isTransaction && typeof sampleRate === "number" && Math.random() > sampleRate) {
        recordLostEvent("sample_rate", "event");
        return rejectedSyncPromise(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
      }
      return this._prepareEvent(event, scope, hint).then(function(prepared) {
        if (prepared === null) {
          recordLostEvent("event_processor", event.type || "event");
          throw new SentryError("An event processor returned null, will not send event.");
        }
        var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
        if (isInternalException || isTransaction || !beforeSend) {
          return prepared;
        }
        var beforeSendResult = beforeSend(prepared, hint);
        return _ensureBeforeSendRv(beforeSendResult);
      }).then(function(processedEvent) {
        if (processedEvent === null) {
          recordLostEvent("before_send", event.type || "event");
          throw new SentryError("`beforeSend` returned `null`, will not send event.");
        }
        var session = scope && scope.getSession && scope.getSession();
        if (!isTransaction && session) {
          _this._updateSessionFromEvent(session, processedEvent);
        }
        _this._sendEvent(processedEvent);
        return processedEvent;
      }).then(null, function(reason) {
        if (reason instanceof SentryError) {
          throw reason;
        }
        _this.captureException(reason, {
          data: {
            __sentry__: true
          },
          originalException: reason
        });
        throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
      });
    };
    BaseClient2.prototype._process = function(promise) {
      var _this = this;
      this._numProcessing += 1;
      void promise.then(function(value) {
        _this._numProcessing -= 1;
        return value;
      }, function(reason) {
        _this._numProcessing -= 1;
        return reason;
      });
    };
    return BaseClient2;
  }();
  function _ensureBeforeSendRv(rv) {
    var nullErr = "`beforeSend` method has to return `null` or a valid event.";
    if (isThenable(rv)) {
      return rv.then(function(event) {
        if (!(isPlainObject2(event) || event === null)) {
          throw new SentryError(nullErr);
        }
        return event;
      }, function(e) {
        throw new SentryError("beforeSend rejected with " + e);
      });
    } else if (!(isPlainObject2(rv) || rv === null)) {
      throw new SentryError(nullErr);
    }
    return rv;
  }

  // ../node_modules/@sentry/core/esm/request.js
  function getSdkMetadataForEnvelopeHeader(api) {
    if (!api.metadata || !api.metadata.sdk) {
      return;
    }
    var _a = api.metadata.sdk, name69 = _a.name, version = _a.version;
    return { name: name69, version };
  }
  function enhanceEventWithSdkInfo(event, sdkInfo) {
    if (!sdkInfo) {
      return event;
    }
    event.sdk = event.sdk || {};
    event.sdk.name = event.sdk.name || sdkInfo.name;
    event.sdk.version = event.sdk.version || sdkInfo.version;
    event.sdk.integrations = __spread5(event.sdk.integrations || [], sdkInfo.integrations || []);
    event.sdk.packages = __spread5(event.sdk.packages || [], sdkInfo.packages || []);
    return event;
  }
  function createSessionEnvelope(session, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var envelopeHeaders = __assign5(__assign5({ sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
    var type = "aggregates" in session ? "sessions" : "session";
    var envelopeItem = [{ type }, session];
    var envelope = createEnvelope(envelopeHeaders, [envelopeItem]);
    return [envelope, type];
  }
  function sessionToSentryRequest(session, api) {
    var _a = __read5(createSessionEnvelope(session, api), 2), envelope = _a[0], type = _a[1];
    return {
      body: serializeEnvelope(envelope),
      type,
      url: getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel)
    };
  }
  function createEventEnvelope(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || "event";
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
      event.tags.skippedNormalization = true;
      event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
    }
    delete event.sdkProcessingMetadata;
    var envelopeHeaders = __assign5(__assign5({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
    var eventItem = [
      {
        type: eventType,
        sample_rates: [{ id: samplingMethod, rate: sampleRate }]
      },
      event
    ];
    return createEnvelope(envelopeHeaders, [eventItem]);
  }
  function eventToSentryRequest(event, api) {
    var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
    var eventType = event.type || "event";
    var useEnvelope = eventType === "transaction" || !!api.tunnel;
    var transactionSampling = (event.sdkProcessingMetadata || {}).transactionSampling;
    var _a = transactionSampling || {}, samplingMethod = _a.method, sampleRate = _a.rate;
    enhanceEventWithSdkInfo(event, api.metadata.sdk);
    event.tags = event.tags || {};
    event.extra = event.extra || {};
    if (!(event.sdkProcessingMetadata && event.sdkProcessingMetadata.baseClientNormalized)) {
      event.tags.skippedNormalization = true;
      event.extra.normalizeDepth = event.sdkProcessingMetadata ? event.sdkProcessingMetadata.normalizeDepth : "unset";
    }
    delete event.sdkProcessingMetadata;
    var body;
    try {
      body = JSON.stringify(event);
    } catch (err) {
      event.tags.JSONStringifyError = true;
      event.extra.JSONStringifyError = err;
      try {
        body = JSON.stringify(normalize(event));
      } catch (newErr) {
        var innerErr = newErr;
        body = JSON.stringify({
          message: "JSON.stringify error after renormalization",
          extra: { message: innerErr.message, stack: innerErr.stack }
        });
      }
    }
    var req = {
      body,
      type: eventType,
      url: useEnvelope ? getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel) : getStoreEndpointWithUrlEncodedAuth(api.dsn)
    };
    if (useEnvelope) {
      var envelopeHeaders = __assign5(__assign5({ event_id: event.event_id, sent_at: new Date().toISOString() }, sdkInfo && { sdk: sdkInfo }), !!api.tunnel && { dsn: dsnToString(api.dsn) });
      var eventItem = [
        {
          type: eventType,
          sample_rates: [{ id: samplingMethod, rate: sampleRate }]
        },
        req.body
      ];
      var envelope = createEnvelope(envelopeHeaders, [eventItem]);
      req.body = serializeEnvelope(envelope);
    }
    return req;
  }

  // ../node_modules/@sentry/core/esm/transports/noop.js
  var NoopTransport = function() {
    function NoopTransport2() {
    }
    NoopTransport2.prototype.sendEvent = function(_) {
      return resolvedSyncPromise({
        reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
        status: "skipped"
      });
    };
    NoopTransport2.prototype.close = function(_) {
      return resolvedSyncPromise(true);
    };
    return NoopTransport2;
  }();

  // ../node_modules/@sentry/core/esm/basebackend.js
  var BaseBackend = function() {
    function BaseBackend2(options) {
      this._options = options;
      if (!this._options.dsn) {
        IS_DEBUG_BUILD3 && logger.warn("No DSN provided, backend will not do anything.");
      }
      this._transport = this._setupTransport();
    }
    BaseBackend2.prototype.eventFromException = function(_exception, _hint) {
      throw new SentryError("Backend has to implement `eventFromException` method");
    };
    BaseBackend2.prototype.eventFromMessage = function(_message, _level, _hint) {
      throw new SentryError("Backend has to implement `eventFromMessage` method");
    };
    BaseBackend2.prototype.sendEvent = function(event) {
      if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
        var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
        var env = createEventEnvelope(event, api);
        void this._newTransport.send(env).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending event:", reason);
        });
      } else {
        void this._transport.sendEvent(event).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending event:", reason);
        });
      }
    };
    BaseBackend2.prototype.sendSession = function(session) {
      if (!this._transport.sendSession) {
        IS_DEBUG_BUILD3 && logger.warn("Dropping session because custom transport doesn't implement sendSession");
        return;
      }
      if (this._newTransport && this._options.dsn && this._options._experiments && this._options._experiments.newTransport) {
        var api = initAPIDetails(this._options.dsn, this._options._metadata, this._options.tunnel);
        var _a = __read5(createSessionEnvelope(session, api), 1), env = _a[0];
        void this._newTransport.send(env).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending session:", reason);
        });
      } else {
        void this._transport.sendSession(session).then(null, function(reason) {
          IS_DEBUG_BUILD3 && logger.error("Error while sending session:", reason);
        });
      }
    };
    BaseBackend2.prototype.getTransport = function() {
      return this._transport;
    };
    BaseBackend2.prototype._setupTransport = function() {
      return new NoopTransport();
    };
    return BaseBackend2;
  }();

  // ../node_modules/@sentry/core/esm/sdk.js
  function initAndBind(clientClass, options) {
    if (options.debug === true) {
      if (IS_DEBUG_BUILD3) {
        logger.enable();
      } else {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      }
    }
    var hub = getCurrentHub();
    var scope = hub.getScope();
    if (scope) {
      scope.update(options.initialScope);
    }
    var client = new clientClass(options);
    hub.bindClient(client);
  }

  // ../node_modules/@sentry/core/esm/transports/base.js
  var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
  function createTransport(options, makeRequest, buffer) {
    if (buffer === void 0) {
      buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);
    }
    var rateLimits = {};
    var flush2 = function(timeout) {
      return buffer.drain(timeout);
    };
    function send(envelope) {
      var envCategory = getEnvelopeType(envelope);
      var category = envCategory === "event" ? "error" : envCategory;
      var request = {
        category,
        body: serializeEnvelope(envelope)
      };
      if (isRateLimited(rateLimits, category)) {
        return rejectedSyncPromise({
          status: "rate_limit",
          reason: getRateLimitReason(rateLimits, category)
        });
      }
      var requestTask = function() {
        return makeRequest(request).then(function(_a) {
          var body = _a.body, headers = _a.headers, reason = _a.reason, statusCode = _a.statusCode;
          var status = eventStatusFromHttpCode(statusCode);
          if (headers) {
            rateLimits = updateRateLimits(rateLimits, headers);
          }
          if (status === "success") {
            return resolvedSyncPromise({ status, reason });
          }
          return rejectedSyncPromise({
            status,
            reason: reason || body || (status === "rate_limit" ? getRateLimitReason(rateLimits, category) : "Unknown transport error")
          });
        });
      };
      return buffer.add(requestTask);
    }
    return {
      send,
      flush: flush2
    };
  }
  function getRateLimitReason(rateLimits, category) {
    return "Too many " + category + " requests, backing off until: " + new Date(disabledUntil(rateLimits, category)).toISOString();
  }

  // ../node_modules/@sentry/core/esm/version.js
  var SDK_VERSION = "6.19.7";

  // ../node_modules/@sentry/core/esm/integrations/index.js
  var integrations_exports = {};
  __export(integrations_exports, {
    FunctionToString: () => FunctionToString,
    InboundFilters: () => InboundFilters
  });

  // ../node_modules/@sentry/core/esm/integrations/functiontostring.js
  var originalFunctionToString;
  var FunctionToString = function() {
    function FunctionToString2() {
      this.name = FunctionToString2.id;
    }
    FunctionToString2.prototype.setupOnce = function() {
      originalFunctionToString = Function.prototype.toString;
      Function.prototype.toString = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var context = getOriginalFunction(this) || this;
        return originalFunctionToString.apply(context, args);
      };
    };
    FunctionToString2.id = "FunctionToString";
    return FunctionToString2;
  }();

  // ../node_modules/@sentry/core/esm/integrations/inboundfilters.js
  var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
  var InboundFilters = function() {
    function InboundFilters2(_options) {
      if (_options === void 0) {
        _options = {};
      }
      this._options = _options;
      this.name = InboundFilters2.id;
    }
    InboundFilters2.prototype.setupOnce = function(addGlobalEventProcessor2, getCurrentHub2) {
      addGlobalEventProcessor2(function(event) {
        var hub = getCurrentHub2();
        if (hub) {
          var self_1 = hub.getIntegration(InboundFilters2);
          if (self_1) {
            var client = hub.getClient();
            var clientOptions = client ? client.getOptions() : {};
            var options = _mergeOptions(self_1._options, clientOptions);
            return _shouldDropEvent(event, options) ? null : event;
          }
        }
        return event;
      });
    };
    InboundFilters2.id = "InboundFilters";
    return InboundFilters2;
  }();
  function _mergeOptions(internalOptions, clientOptions) {
    if (internalOptions === void 0) {
      internalOptions = {};
    }
    if (clientOptions === void 0) {
      clientOptions = {};
    }
    return {
      allowUrls: __spread5(internalOptions.whitelistUrls || [], internalOptions.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),
      denyUrls: __spread5(internalOptions.blacklistUrls || [], internalOptions.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),
      ignoreErrors: __spread5(internalOptions.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),
      ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
    };
  }
  function _shouldDropEvent(event, options) {
    if (options.ignoreInternal && _isSentryError(event)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
      return true;
    }
    if (_isIgnoredError(event, options.ignoreErrors)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
      return true;
    }
    if (_isDeniedUrl(event, options.denyUrls)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
      return true;
    }
    if (!_isAllowedUrl(event, options.allowUrls)) {
      IS_DEBUG_BUILD3 && logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + _getEventFilterUrl(event));
      return true;
    }
    return false;
  }
  function _isIgnoredError(event, ignoreErrors) {
    if (!ignoreErrors || !ignoreErrors.length) {
      return false;
    }
    return _getPossibleEventMessages(event).some(function(message) {
      return ignoreErrors.some(function(pattern) {
        return isMatchingPattern(message, pattern);
      });
    });
  }
  function _isDeniedUrl(event, denyUrls) {
    if (!denyUrls || !denyUrls.length) {
      return false;
    }
    var url = _getEventFilterUrl(event);
    return !url ? false : denyUrls.some(function(pattern) {
      return isMatchingPattern(url, pattern);
    });
  }
  function _isAllowedUrl(event, allowUrls) {
    if (!allowUrls || !allowUrls.length) {
      return true;
    }
    var url = _getEventFilterUrl(event);
    return !url ? true : allowUrls.some(function(pattern) {
      return isMatchingPattern(url, pattern);
    });
  }
  function _getPossibleEventMessages(event) {
    if (event.message) {
      return [event.message];
    }
    if (event.exception) {
      try {
        var _a = event.exception.values && event.exception.values[0] || {}, _b = _a.type, type = _b === void 0 ? "" : _b, _c = _a.value, value = _c === void 0 ? "" : _c;
        return ["" + value, type + ": " + value];
      } catch (oO) {
        IS_DEBUG_BUILD3 && logger.error("Cannot extract message for event " + getEventDescription(event));
        return [];
      }
    }
    return [];
  }
  function _isSentryError(event) {
    try {
      return event.exception.values[0].type === "SentryError";
    } catch (e) {
    }
    return false;
  }
  function _getLastValidUrl(frames) {
    if (frames === void 0) {
      frames = [];
    }
    for (var i = frames.length - 1; i >= 0; i--) {
      var frame = frames[i];
      if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
        return frame.filename || null;
      }
    }
    return null;
  }
  function _getEventFilterUrl(event) {
    try {
      if (event.stacktrace) {
        return _getLastValidUrl(event.stacktrace.frames);
      }
      var frames_1;
      try {
        frames_1 = event.exception.values[0].stacktrace.frames;
      } catch (e) {
      }
      return frames_1 ? _getLastValidUrl(frames_1) : null;
    } catch (oO) {
      IS_DEBUG_BUILD3 && logger.error("Cannot extract url for event " + getEventDescription(event));
      return null;
    }
  }

  // ../node_modules/@sentry/browser/esm/stack-parsers.js
  var UNKNOWN_FUNCTION = "?";
  var OPERA10_PRIORITY = 10;
  var OPERA11_PRIORITY = 20;
  var CHROME_PRIORITY = 30;
  var WINJS_PRIORITY = 40;
  var GECKO_PRIORITY = 50;
  function createFrame(filename, func, lineno, colno) {
    var frame = {
      filename,
      function: func,
      in_app: true
    };
    if (lineno !== void 0) {
      frame.lineno = lineno;
    }
    if (colno !== void 0) {
      frame.colno = colno;
    }
    return frame;
  }
  var chromeRegex = /^\s*at (?:(.*?) ?\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var chrome = function(line) {
    var parts = chromeRegex.exec(line);
    if (parts) {
      var isEval = parts[2] && parts[2].indexOf("eval") === 0;
      if (isEval) {
        var subMatch = chromeEvalRegex.exec(parts[2]);
        if (subMatch) {
          parts[2] = subMatch[1];
          parts[3] = subMatch[2];
          parts[4] = subMatch[3];
        }
      }
      var _a = __read(extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]), 2), func = _a[0], filename = _a[1];
      return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
    }
    return;
  };
  var chromeStackParser = [CHROME_PRIORITY, chrome];
  var geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
  var geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var gecko = function(line) {
    var _a;
    var parts = geckoREgex.exec(line);
    if (parts) {
      var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
      if (isEval) {
        var subMatch = geckoEvalRegex.exec(parts[3]);
        if (subMatch) {
          parts[1] = parts[1] || "eval";
          parts[3] = subMatch[1];
          parts[4] = subMatch[2];
          parts[5] = "";
        }
      }
      var filename = parts[3];
      var func = parts[1] || UNKNOWN_FUNCTION;
      _a = __read(extractSafariExtensionDetails(func, filename), 2), func = _a[0], filename = _a[1];
      return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
    }
    return;
  };
  var geckoStackParser = [GECKO_PRIORITY, gecko];
  var winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var winjs = function(line) {
    var parts = winjsRegex.exec(line);
    return parts ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
  };
  var winjsStackParser = [WINJS_PRIORITY, winjs];
  var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
  var opera10 = function(line) {
    var parts = opera10Regex.exec(line);
    return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : void 0;
  };
  var opera10StackParser = [OPERA10_PRIORITY, opera10];
  var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i;
  var opera11 = function(line) {
    var parts = opera11Regex.exec(line);
    return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : void 0;
  };
  var opera11StackParser = [OPERA11_PRIORITY, opera11];
  var extractSafariExtensionDetails = function(func, filename) {
    var isSafariExtension = func.indexOf("safari-extension") !== -1;
    var isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
    return isSafariExtension || isSafariWebExtension ? [
      func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
      isSafariExtension ? "safari-extension:" + filename : "safari-web-extension:" + filename
    ] : [func, filename];
  };

  // ../node_modules/@sentry/browser/esm/eventbuilder.js
  function exceptionFromError(ex) {
    var frames = parseStackFrames(ex);
    var exception = {
      type: ex && ex.name,
      value: extractMessage(ex)
    };
    if (frames.length) {
      exception.stacktrace = { frames };
    }
    if (exception.type === void 0 && exception.value === "") {
      exception.value = "Unrecoverable error caught";
    }
    return exception;
  }
  function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {
    var event = {
      exception: {
        values: [
          {
            type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
            value: "Non-Error " + (isUnhandledRejection ? "promise rejection" : "exception") + " captured with keys: " + extractExceptionKeysForMessage(exception)
          }
        ]
      },
      extra: {
        __serialized__: normalizeToSize(exception)
      }
    };
    if (syntheticException) {
      var frames_1 = parseStackFrames(syntheticException);
      if (frames_1.length) {
        event.stacktrace = { frames: frames_1 };
      }
    }
    return event;
  }
  function eventFromError(ex) {
    return {
      exception: {
        values: [exceptionFromError(ex)]
      }
    };
  }
  function parseStackFrames(ex) {
    var stacktrace = ex.stacktrace || ex.stack || "";
    var popSize = getPopSize(ex);
    try {
      return createStackParser(opera10StackParser, opera11StackParser, chromeStackParser, winjsStackParser, geckoStackParser)(stacktrace, popSize);
    } catch (e) {
    }
    return [];
  }
  var reactMinifiedRegexp = /Minified React error #\d+;/i;
  function getPopSize(ex) {
    if (ex) {
      if (typeof ex.framesToPop === "number") {
        return ex.framesToPop;
      }
      if (reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }
    }
    return 0;
  }
  function extractMessage(ex) {
    var message = ex && ex.message;
    if (!message) {
      return "No error message";
    }
    if (message.error && typeof message.error.message === "string") {
      return message.error.message;
    }
    return message;
  }
  function eventFromException(exception, hint, attachStacktrace) {
    var syntheticException = hint && hint.syntheticException || void 0;
    var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);
    addExceptionMechanism(event);
    event.level = Severity.Error;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromMessage(message, level, hint, attachStacktrace) {
    if (level === void 0) {
      level = Severity.Info;
    }
    var syntheticException = hint && hint.syntheticException || void 0;
    var event = eventFromString(message, syntheticException, attachStacktrace);
    event.level = level;
    if (hint && hint.event_id) {
      event.event_id = hint.event_id;
    }
    return resolvedSyncPromise(event);
  }
  function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {
    var event;
    if (isErrorEvent(exception) && exception.error) {
      var errorEvent = exception;
      return eventFromError(errorEvent.error);
    }
    if (isDOMError(exception) || isDOMException(exception)) {
      var domException = exception;
      if ("stack" in exception) {
        event = eventFromError(exception);
      } else {
        var name_1 = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
        var message = domException.message ? name_1 + ": " + domException.message : name_1;
        event = eventFromString(message, syntheticException, attachStacktrace);
        addExceptionTypeValue(event, message);
      }
      if ("code" in domException) {
        event.tags = __assign(__assign({}, event.tags), { "DOMException.code": "" + domException.code });
      }
      return event;
    }
    if (isError(exception)) {
      return eventFromError(exception);
    }
    if (isPlainObject2(exception) || isEvent(exception)) {
      var objectException = exception;
      event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);
      addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    event = eventFromString(exception, syntheticException, attachStacktrace);
    addExceptionTypeValue(event, "" + exception, void 0);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  function eventFromString(input, syntheticException, attachStacktrace) {
    var event = {
      message: input
    };
    if (attachStacktrace && syntheticException) {
      var frames_2 = parseStackFrames(syntheticException);
      if (frames_2.length) {
        event.stacktrace = { frames: frames_2 };
      }
    }
    return event;
  }

  // ../node_modules/@sentry/browser/esm/flags.js
  var IS_DEBUG_BUILD4 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/browser/esm/transports/utils.js
  var global4 = getGlobalObject();
  var cachedFetchImpl;
  function getNativeFetchImplementation() {
    if (cachedFetchImpl) {
      return cachedFetchImpl;
    }
    if (isNativeFetch(global4.fetch)) {
      return cachedFetchImpl = global4.fetch.bind(global4);
    }
    var document2 = global4.document;
    var fetchImpl = global4.fetch;
    if (document2 && typeof document2.createElement === "function") {
      try {
        var sandbox = document2.createElement("iframe");
        sandbox.hidden = true;
        document2.head.appendChild(sandbox);
        var contentWindow = sandbox.contentWindow;
        if (contentWindow && contentWindow.fetch) {
          fetchImpl = contentWindow.fetch;
        }
        document2.head.removeChild(sandbox);
      } catch (e) {
        IS_DEBUG_BUILD4 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
      }
    }
    return cachedFetchImpl = fetchImpl.bind(global4);
  }
  function sendReport(url, body) {
    var isRealNavigator = Object.prototype.toString.call(global4 && global4.navigator) === "[object Navigator]";
    var hasSendBeacon = isRealNavigator && typeof global4.navigator.sendBeacon === "function";
    if (hasSendBeacon) {
      var sendBeacon = global4.navigator.sendBeacon.bind(global4.navigator);
      return sendBeacon(url, body);
    }
    if (supportsFetch()) {
      var fetch_1 = getNativeFetchImplementation();
      return forget(fetch_1(url, {
        body,
        method: "POST",
        credentials: "omit",
        keepalive: true
      }));
    }
  }

  // ../node_modules/@sentry/browser/esm/transports/base.js
  function requestTypeToCategory(ty) {
    var tyStr = ty;
    return tyStr === "event" ? "error" : tyStr;
  }
  var global5 = getGlobalObject();
  var BaseTransport = function() {
    function BaseTransport2(options) {
      var _this = this;
      this.options = options;
      this._buffer = makePromiseBuffer(30);
      this._rateLimits = {};
      this._outcomes = {};
      this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);
      this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);
      if (this.options.sendClientReports && global5.document) {
        global5.document.addEventListener("visibilitychange", function() {
          if (global5.document.visibilityState === "hidden") {
            _this._flushOutcomes();
          }
        });
      }
    }
    BaseTransport2.prototype.sendEvent = function(event) {
      return this._sendRequest(eventToSentryRequest(event, this._api), event);
    };
    BaseTransport2.prototype.sendSession = function(session) {
      return this._sendRequest(sessionToSentryRequest(session, this._api), session);
    };
    BaseTransport2.prototype.close = function(timeout) {
      return this._buffer.drain(timeout);
    };
    BaseTransport2.prototype.recordLostEvent = function(reason, category) {
      var _a;
      if (!this.options.sendClientReports) {
        return;
      }
      var key = requestTypeToCategory(category) + ":" + reason;
      IS_DEBUG_BUILD4 && logger.log("Adding outcome: " + key);
      this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;
    };
    BaseTransport2.prototype._flushOutcomes = function() {
      if (!this.options.sendClientReports) {
        return;
      }
      var outcomes = this._outcomes;
      this._outcomes = {};
      if (!Object.keys(outcomes).length) {
        IS_DEBUG_BUILD4 && logger.log("No outcomes to flush");
        return;
      }
      IS_DEBUG_BUILD4 && logger.log("Flushing outcomes:\n" + JSON.stringify(outcomes, null, 2));
      var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);
      var discardedEvents = Object.keys(outcomes).map(function(key) {
        var _a = __read(key.split(":"), 2), category = _a[0], reason = _a[1];
        return {
          reason,
          category,
          quantity: outcomes[key]
        };
      });
      var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));
      try {
        sendReport(url, serializeEnvelope(envelope));
      } catch (e) {
        IS_DEBUG_BUILD4 && logger.error(e);
      }
    };
    BaseTransport2.prototype._handleResponse = function(_a) {
      var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;
      var status = eventStatusFromHttpCode(response.status);
      this._rateLimits = updateRateLimits(this._rateLimits, headers);
      if (this._isRateLimited(requestType)) {
        IS_DEBUG_BUILD4 && logger.warn("Too many " + requestType + " requests, backing off until: " + this._disabledUntil(requestType));
      }
      if (status === "success") {
        resolve({ status });
        return;
      }
      reject(response);
    };
    BaseTransport2.prototype._disabledUntil = function(requestType) {
      var category = requestTypeToCategory(requestType);
      return new Date(disabledUntil(this._rateLimits, category));
    };
    BaseTransport2.prototype._isRateLimited = function(requestType) {
      var category = requestTypeToCategory(requestType);
      return isRateLimited(this._rateLimits, category);
    };
    return BaseTransport2;
  }();

  // ../node_modules/@sentry/browser/esm/transports/fetch.js
  var FetchTransport = function(_super) {
    __extends(FetchTransport2, _super);
    function FetchTransport2(options, fetchImpl) {
      if (fetchImpl === void 0) {
        fetchImpl = getNativeFetchImplementation();
      }
      var _this = _super.call(this, options) || this;
      _this._fetch = fetchImpl;
      return _this;
    }
    FetchTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
      var _this = this;
      if (this._isRateLimited(sentryRequest.type)) {
        this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
        return Promise.reject({
          event: originalPayload,
          type: sentryRequest.type,
          reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
          status: 429
        });
      }
      var options = {
        body: sentryRequest.body,
        method: "POST",
        referrerPolicy: supportsReferrerPolicy() ? "origin" : ""
      };
      if (this.options.fetchParameters !== void 0) {
        Object.assign(options, this.options.fetchParameters);
      }
      if (this.options.headers !== void 0) {
        options.headers = this.options.headers;
      }
      return this._buffer.add(function() {
        return new SyncPromise(function(resolve, reject) {
          void _this._fetch(sentryRequest.url, options).then(function(response) {
            var headers = {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            };
            _this._handleResponse({
              requestType: sentryRequest.type,
              response,
              headers,
              resolve,
              reject
            });
          }).catch(reject);
        });
      }).then(void 0, function(reason) {
        if (reason instanceof SentryError) {
          _this.recordLostEvent("queue_overflow", sentryRequest.type);
        } else {
          _this.recordLostEvent("network_error", sentryRequest.type);
        }
        throw reason;
      });
    };
    return FetchTransport2;
  }(BaseTransport);

  // ../node_modules/@sentry/browser/esm/transports/xhr.js
  var XHRTransport = function(_super) {
    __extends(XHRTransport2, _super);
    function XHRTransport2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    XHRTransport2.prototype._sendRequest = function(sentryRequest, originalPayload) {
      var _this = this;
      if (this._isRateLimited(sentryRequest.type)) {
        this.recordLostEvent("ratelimit_backoff", sentryRequest.type);
        return Promise.reject({
          event: originalPayload,
          type: sentryRequest.type,
          reason: "Transport for " + sentryRequest.type + " requests locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
          status: 429
        });
      }
      return this._buffer.add(function() {
        return new SyncPromise(function(resolve, reject) {
          var request = new XMLHttpRequest();
          request.onreadystatechange = function() {
            if (request.readyState === 4) {
              var headers = {
                "x-sentry-rate-limits": request.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": request.getResponseHeader("Retry-After")
              };
              _this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });
            }
          };
          request.open("POST", sentryRequest.url);
          for (var header in _this.options.headers) {
            if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {
              request.setRequestHeader(header, _this.options.headers[header]);
            }
          }
          request.send(sentryRequest.body);
        });
      }).then(void 0, function(reason) {
        if (reason instanceof SentryError) {
          _this.recordLostEvent("queue_overflow", sentryRequest.type);
        } else {
          _this.recordLostEvent("network_error", sentryRequest.type);
        }
        throw reason;
      });
    };
    return XHRTransport2;
  }(BaseTransport);

  // ../node_modules/@sentry/browser/esm/transports/new-fetch.js
  function makeNewFetchTransport(options, nativeFetch) {
    if (nativeFetch === void 0) {
      nativeFetch = getNativeFetchImplementation();
    }
    function makeRequest(request) {
      var requestOptions = __assign({ body: request.body, method: "POST", referrerPolicy: "origin" }, options.requestOptions);
      return nativeFetch(options.url, requestOptions).then(function(response) {
        return response.text().then(function(body) {
          return {
            body,
            headers: {
              "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
              "retry-after": response.headers.get("Retry-After")
            },
            reason: response.statusText,
            statusCode: response.status
          };
        });
      });
    }
    return createTransport({ bufferSize: options.bufferSize }, makeRequest);
  }

  // ../node_modules/@sentry/browser/esm/transports/new-xhr.js
  var XHR_READYSTATE_DONE = 4;
  function makeNewXHRTransport(options) {
    function makeRequest(request) {
      return new SyncPromise(function(resolve, _reject) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (xhr.readyState === XHR_READYSTATE_DONE) {
            var response = {
              body: xhr.response,
              headers: {
                "x-sentry-rate-limits": xhr.getResponseHeader("X-Sentry-Rate-Limits"),
                "retry-after": xhr.getResponseHeader("Retry-After")
              },
              reason: xhr.statusText,
              statusCode: xhr.status
            };
            resolve(response);
          }
        };
        xhr.open("POST", options.url);
        for (var header in options.headers) {
          if (Object.prototype.hasOwnProperty.call(options.headers, header)) {
            xhr.setRequestHeader(header, options.headers[header]);
          }
        }
        xhr.send(request.body);
      });
    }
    return createTransport({ bufferSize: options.bufferSize }, makeRequest);
  }

  // ../node_modules/@sentry/browser/esm/backend.js
  var BrowserBackend = function(_super) {
    __extends(BrowserBackend2, _super);
    function BrowserBackend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserBackend2.prototype.eventFromException = function(exception, hint) {
      return eventFromException(exception, hint, this._options.attachStacktrace);
    };
    BrowserBackend2.prototype.eventFromMessage = function(message, level, hint) {
      if (level === void 0) {
        level = Severity.Info;
      }
      return eventFromMessage(message, level, hint, this._options.attachStacktrace);
    };
    BrowserBackend2.prototype._setupTransport = function() {
      if (!this._options.dsn) {
        return _super.prototype._setupTransport.call(this);
      }
      var transportOptions = __assign(__assign({}, this._options.transportOptions), { dsn: this._options.dsn, tunnel: this._options.tunnel, sendClientReports: this._options.sendClientReports, _metadata: this._options._metadata });
      var api = initAPIDetails(transportOptions.dsn, transportOptions._metadata, transportOptions.tunnel);
      var url = getEnvelopeEndpointWithUrlEncodedAuth(api.dsn, api.tunnel);
      if (this._options.transport) {
        return new this._options.transport(transportOptions);
      }
      if (supportsFetch()) {
        var requestOptions = __assign({}, transportOptions.fetchParameters);
        this._newTransport = makeNewFetchTransport({ requestOptions, url });
        return new FetchTransport(transportOptions);
      }
      this._newTransport = makeNewXHRTransport({
        url,
        headers: transportOptions.headers
      });
      return new XHRTransport(transportOptions);
    };
    return BrowserBackend2;
  }(BaseBackend);

  // ../node_modules/@sentry/browser/esm/helpers.js
  var global6 = getGlobalObject();
  var ignoreOnError = 0;
  function shouldIgnoreOnError() {
    return ignoreOnError > 0;
  }
  function ignoreNextOnError() {
    ignoreOnError += 1;
    setTimeout(function() {
      ignoreOnError -= 1;
    });
  }
  function wrap(fn, options, before) {
    if (options === void 0) {
      options = {};
    }
    if (typeof fn !== "function") {
      return fn;
    }
    try {
      var wrapper = fn.__sentry_wrapped__;
      if (wrapper) {
        return wrapper;
      }
      if (getOriginalFunction(fn)) {
        return fn;
      }
    } catch (e) {
      return fn;
    }
    var sentryWrapped = function() {
      var args = Array.prototype.slice.call(arguments);
      try {
        if (before && typeof before === "function") {
          before.apply(this, arguments);
        }
        var wrappedArguments = args.map(function(arg) {
          return wrap(arg, options);
        });
        return fn.apply(this, wrappedArguments);
      } catch (ex) {
        ignoreNextOnError();
        withScope(function(scope) {
          scope.addEventProcessor(function(event) {
            if (options.mechanism) {
              addExceptionTypeValue(event, void 0, void 0);
              addExceptionMechanism(event, options.mechanism);
            }
            event.extra = __assign(__assign({}, event.extra), { arguments: args });
            return event;
          });
          captureException(ex);
        });
        throw ex;
      }
    };
    try {
      for (var property in fn) {
        if (Object.prototype.hasOwnProperty.call(fn, property)) {
          sentryWrapped[property] = fn[property];
        }
      }
    } catch (_oO) {
    }
    markFunctionWrapped(sentryWrapped, fn);
    addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
    try {
      var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
      if (descriptor.configurable) {
        Object.defineProperty(sentryWrapped, "name", {
          get: function() {
            return fn.name;
          }
        });
      }
    } catch (_oO) {
    }
    return sentryWrapped;
  }
  function injectReportDialog(options) {
    if (options === void 0) {
      options = {};
    }
    if (!global6.document) {
      return;
    }
    if (!options.eventId) {
      IS_DEBUG_BUILD4 && logger.error("Missing eventId option in showReportDialog call");
      return;
    }
    if (!options.dsn) {
      IS_DEBUG_BUILD4 && logger.error("Missing dsn option in showReportDialog call");
      return;
    }
    var script = global6.document.createElement("script");
    script.async = true;
    script.src = getReportDialogEndpoint(options.dsn, options);
    if (options.onLoad) {
      script.onload = options.onLoad;
    }
    var injectionPoint = global6.document.head || global6.document.body;
    if (injectionPoint) {
      injectionPoint.appendChild(script);
    }
  }

  // ../node_modules/@sentry/browser/esm/integrations/globalhandlers.js
  var GlobalHandlers = function() {
    function GlobalHandlers2(options) {
      this.name = GlobalHandlers2.id;
      this._installFunc = {
        onerror: _installGlobalOnErrorHandler,
        onunhandledrejection: _installGlobalOnUnhandledRejectionHandler
      };
      this._options = __assign({ onerror: true, onunhandledrejection: true }, options);
    }
    GlobalHandlers2.prototype.setupOnce = function() {
      Error.stackTraceLimit = 50;
      var options = this._options;
      for (var key in options) {
        var installFunc = this._installFunc[key];
        if (installFunc && options[key]) {
          globalHandlerLog(key);
          installFunc();
          this._installFunc[key] = void 0;
        }
      }
    };
    GlobalHandlers2.id = "GlobalHandlers";
    return GlobalHandlers2;
  }();
  function _installGlobalOnErrorHandler() {
    addInstrumentationHandler(
      "error",
      function(data) {
        var _a = __read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
        if (!hub.getIntegration(GlobalHandlers)) {
          return;
        }
        var msg = data.msg, url = data.url, line = data.line, column2 = data.column, error = data.error;
        if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
          return;
        }
        var event = error === void 0 && isString2(msg) ? _eventFromIncompleteOnError(msg, url, line, column2) : _enhanceEventWithInitialFrame(eventFromUnknownInput(error || msg, void 0, attachStacktrace, false), url, line, column2);
        event.level = Severity.Error;
        addMechanismAndCapture(hub, error, event, "onerror");
      }
    );
  }
  function _installGlobalOnUnhandledRejectionHandler() {
    addInstrumentationHandler(
      "unhandledrejection",
      function(e) {
        var _a = __read(getHubAndAttachStacktrace(), 2), hub = _a[0], attachStacktrace = _a[1];
        if (!hub.getIntegration(GlobalHandlers)) {
          return;
        }
        var error = e;
        try {
          if ("reason" in e) {
            error = e.reason;
          } else if ("detail" in e && "reason" in e.detail) {
            error = e.detail.reason;
          }
        } catch (_oO) {
        }
        if (shouldIgnoreOnError() || error && error.__sentry_own_request__) {
          return true;
        }
        var event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(error, void 0, attachStacktrace, true);
        event.level = Severity.Error;
        addMechanismAndCapture(hub, error, event, "onunhandledrejection");
        return;
      }
    );
  }
  function _eventFromRejectionWithPrimitive(reason) {
    return {
      exception: {
        values: [
          {
            type: "UnhandledRejection",
            value: "Non-Error promise rejection captured with value: " + String(reason)
          }
        ]
      }
    };
  }
  function _eventFromIncompleteOnError(msg, url, line, column2) {
    var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
    var message = isErrorEvent(msg) ? msg.message : msg;
    var name69 = "Error";
    var groups = message.match(ERROR_TYPES_RE);
    if (groups) {
      name69 = groups[1];
      message = groups[2];
    }
    var event = {
      exception: {
        values: [
          {
            type: name69,
            value: message
          }
        ]
      }
    };
    return _enhanceEventWithInitialFrame(event, url, line, column2);
  }
  function _enhanceEventWithInitialFrame(event, url, line, column2) {
    var e = event.exception = event.exception || {};
    var ev = e.values = e.values || [];
    var ev0 = ev[0] = ev[0] || {};
    var ev0s = ev0.stacktrace = ev0.stacktrace || {};
    var ev0sf = ev0s.frames = ev0s.frames || [];
    var colno = isNaN(parseInt(column2, 10)) ? void 0 : column2;
    var lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
    var filename = isString2(url) && url.length > 0 ? url : getLocationHref();
    if (ev0sf.length === 0) {
      ev0sf.push({
        colno,
        filename,
        function: "?",
        in_app: true,
        lineno
      });
    }
    return event;
  }
  function globalHandlerLog(type) {
    IS_DEBUG_BUILD4 && logger.log("Global Handler attached: " + type);
  }
  function addMechanismAndCapture(hub, error, event, type) {
    addExceptionMechanism(event, {
      handled: false,
      type
    });
    hub.captureEvent(event, {
      originalException: error
    });
  }
  function getHubAndAttachStacktrace() {
    var hub = getCurrentHub();
    var client = hub.getClient();
    var attachStacktrace = client && client.getOptions().attachStacktrace;
    return [hub, attachStacktrace];
  }

  // ../node_modules/@sentry/browser/esm/integrations/trycatch.js
  var DEFAULT_EVENT_TARGET = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload"
  ];
  var TryCatch = function() {
    function TryCatch2(options) {
      this.name = TryCatch2.id;
      this._options = __assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
    }
    TryCatch2.prototype.setupOnce = function() {
      var global12 = getGlobalObject();
      if (this._options.setTimeout) {
        fill(global12, "setTimeout", _wrapTimeFunction);
      }
      if (this._options.setInterval) {
        fill(global12, "setInterval", _wrapTimeFunction);
      }
      if (this._options.requestAnimationFrame) {
        fill(global12, "requestAnimationFrame", _wrapRAF);
      }
      if (this._options.XMLHttpRequest && "XMLHttpRequest" in global12) {
        fill(XMLHttpRequest.prototype, "send", _wrapXHR);
      }
      var eventTargetOption = this._options.eventTarget;
      if (eventTargetOption) {
        var eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
        eventTarget.forEach(_wrapEventTarget);
      }
    };
    TryCatch2.id = "TryCatch";
    return TryCatch2;
  }();
  function _wrapTimeFunction(original) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var originalCallback = args[0];
      args[0] = wrap(originalCallback, {
        mechanism: {
          data: { function: getFunctionName(original) },
          handled: true,
          type: "instrument"
        }
      });
      return original.apply(this, args);
    };
  }
  function _wrapRAF(original) {
    return function(callback) {
      return original.apply(this, [
        wrap(callback, {
          mechanism: {
            data: {
              function: "requestAnimationFrame",
              handler: getFunctionName(original)
            },
            handled: true,
            type: "instrument"
          }
        })
      ]);
    };
  }
  function _wrapXHR(originalSend) {
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var xhr = this;
      var xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
      xmlHttpRequestProps.forEach(function(prop) {
        if (prop in xhr && typeof xhr[prop] === "function") {
          fill(xhr, prop, function(original) {
            var wrapOptions = {
              mechanism: {
                data: {
                  function: prop,
                  handler: getFunctionName(original)
                },
                handled: true,
                type: "instrument"
              }
            };
            var originalFunction = getOriginalFunction(original);
            if (originalFunction) {
              wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
            }
            return wrap(original, wrapOptions);
          });
        }
      });
      return originalSend.apply(this, args);
    };
  }
  function _wrapEventTarget(target) {
    var global12 = getGlobalObject();
    var proto = global12[target] && global12[target].prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(original) {
      return function(eventName, fn, options) {
        try {
          if (typeof fn.handleEvent === "function") {
            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {
              mechanism: {
                data: {
                  function: "handleEvent",
                  handler: getFunctionName(fn),
                  target
                },
                handled: true,
                type: "instrument"
              }
            });
          }
        } catch (err) {
        }
        return original.apply(this, [
          eventName,
          wrap(fn, {
            mechanism: {
              data: {
                function: "addEventListener",
                handler: getFunctionName(fn),
                target
              },
              handled: true,
              type: "instrument"
            }
          }),
          options
        ]);
      };
    });
    fill(proto, "removeEventListener", function(originalRemoveEventListener) {
      return function(eventName, fn, options) {
        var wrappedEventHandler = fn;
        try {
          var originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
          if (originalEventHandler) {
            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
          }
        } catch (e) {
        }
        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
      };
    });
  }

  // ../node_modules/@sentry/browser/esm/integrations/breadcrumbs.js
  var Breadcrumbs = function() {
    function Breadcrumbs2(options) {
      this.name = Breadcrumbs2.id;
      this._options = __assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
    }
    Breadcrumbs2.prototype.addSentryBreadcrumb = function(event) {
      if (!this._options.sentry) {
        return;
      }
      getCurrentHub().addBreadcrumb({
        category: "sentry." + (event.type === "transaction" ? "transaction" : "event"),
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      }, {
        event
      });
    };
    Breadcrumbs2.prototype.setupOnce = function() {
      if (this._options.console) {
        addInstrumentationHandler("console", _consoleBreadcrumb);
      }
      if (this._options.dom) {
        addInstrumentationHandler("dom", _domBreadcrumb(this._options.dom));
      }
      if (this._options.xhr) {
        addInstrumentationHandler("xhr", _xhrBreadcrumb);
      }
      if (this._options.fetch) {
        addInstrumentationHandler("fetch", _fetchBreadcrumb);
      }
      if (this._options.history) {
        addInstrumentationHandler("history", _historyBreadcrumb);
      }
    };
    Breadcrumbs2.id = "Breadcrumbs";
    return Breadcrumbs2;
  }();
  function _domBreadcrumb(dom) {
    function _innerDomBreadcrumb(handlerData) {
      var target;
      var keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
      if (typeof keyAttrs === "string") {
        keyAttrs = [keyAttrs];
      }
      try {
        target = handlerData.event.target ? htmlTreeAsString(handlerData.event.target, keyAttrs) : htmlTreeAsString(handlerData.event, keyAttrs);
      } catch (e) {
        target = "<unknown>";
      }
      if (target.length === 0) {
        return;
      }
      getCurrentHub().addBreadcrumb({
        category: "ui." + handlerData.name,
        message: target
      }, {
        event: handlerData.event,
        name: handlerData.name,
        global: handlerData.global
      });
    }
    return _innerDomBreadcrumb;
  }
  function _consoleBreadcrumb(handlerData) {
    var breadcrumb = {
      category: "console",
      data: {
        arguments: handlerData.args,
        logger: "console"
      },
      level: severityFromString(handlerData.level),
      message: safeJoin(handlerData.args, " ")
    };
    if (handlerData.level === "assert") {
      if (handlerData.args[0] === false) {
        breadcrumb.message = "Assertion failed: " + (safeJoin(handlerData.args.slice(1), " ") || "console.assert");
        breadcrumb.data.arguments = handlerData.args.slice(1);
      } else {
        return;
      }
    }
    getCurrentHub().addBreadcrumb(breadcrumb, {
      input: handlerData.args,
      level: handlerData.level
    });
  }
  function _xhrBreadcrumb(handlerData) {
    if (handlerData.endTimestamp) {
      if (handlerData.xhr.__sentry_own_request__) {
        return;
      }
      var _a = handlerData.xhr.__sentry_xhr__ || {}, method = _a.method, url = _a.url, status_code = _a.status_code, body = _a.body;
      getCurrentHub().addBreadcrumb({
        category: "xhr",
        data: {
          method,
          url,
          status_code
        },
        type: "http"
      }, {
        xhr: handlerData.xhr,
        input: body
      });
      return;
    }
  }
  function _fetchBreadcrumb(handlerData) {
    if (!handlerData.endTimestamp) {
      return;
    }
    if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
      return;
    }
    if (handlerData.error) {
      getCurrentHub().addBreadcrumb({
        category: "fetch",
        data: handlerData.fetchData,
        level: Severity.Error,
        type: "http"
      }, {
        data: handlerData.error,
        input: handlerData.args
      });
    } else {
      getCurrentHub().addBreadcrumb({
        category: "fetch",
        data: __assign(__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
        type: "http"
      }, {
        input: handlerData.args,
        response: handlerData.response
      });
    }
  }
  function _historyBreadcrumb(handlerData) {
    var global12 = getGlobalObject();
    var from = handlerData.from;
    var to = handlerData.to;
    var parsedLoc = parseUrl(global12.location.href);
    var parsedFrom = parseUrl(from);
    var parsedTo = parseUrl(to);
    if (!parsedFrom.path) {
      parsedFrom = parsedLoc;
    }
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
      to = parsedTo.relative;
    }
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
      from = parsedFrom.relative;
    }
    getCurrentHub().addBreadcrumb({
      category: "navigation",
      data: {
        from,
        to
      }
    });
  }

  // ../node_modules/@sentry/browser/esm/integrations/linkederrors.js
  var DEFAULT_KEY = "cause";
  var DEFAULT_LIMIT = 5;
  var LinkedErrors = function() {
    function LinkedErrors2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = LinkedErrors2.id;
      this._key = options.key || DEFAULT_KEY;
      this._limit = options.limit || DEFAULT_LIMIT;
    }
    LinkedErrors2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event, hint) {
        var self2 = getCurrentHub().getIntegration(LinkedErrors2);
        return self2 ? _handler(self2._key, self2._limit, event, hint) : event;
      });
    };
    LinkedErrors2.id = "LinkedErrors";
    return LinkedErrors2;
  }();
  function _handler(key, limit, event, hint) {
    if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
      return event;
    }
    var linkedErrors = _walkErrorTree(limit, hint.originalException, key);
    event.exception.values = __spread(linkedErrors, event.exception.values);
    return event;
  }
  function _walkErrorTree(limit, error, key, stack) {
    if (stack === void 0) {
      stack = [];
    }
    if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {
      return stack;
    }
    var exception = exceptionFromError(error[key]);
    return _walkErrorTree(limit, error[key], key, __spread([exception], stack));
  }

  // ../node_modules/@sentry/browser/esm/integrations/useragent.js
  var global7 = getGlobalObject();
  var UserAgent = function() {
    function UserAgent2() {
      this.name = UserAgent2.id;
    }
    UserAgent2.prototype.setupOnce = function() {
      addGlobalEventProcessor(function(event) {
        if (getCurrentHub().getIntegration(UserAgent2)) {
          if (!global7.navigator && !global7.location && !global7.document) {
            return event;
          }
          var url = event.request && event.request.url || global7.location && global7.location.href;
          var referrer = (global7.document || {}).referrer;
          var userAgent = (global7.navigator || {}).userAgent;
          var headers = __assign(__assign(__assign({}, event.request && event.request.headers), referrer && { Referer: referrer }), userAgent && { "User-Agent": userAgent });
          var request = __assign(__assign({}, url && { url }), { headers });
          return __assign(__assign({}, event), { request });
        }
        return event;
      });
    };
    UserAgent2.id = "UserAgent";
    return UserAgent2;
  }();

  // ../node_modules/@sentry/browser/esm/integrations/dedupe.js
  var Dedupe = function() {
    function Dedupe2() {
      this.name = Dedupe2.id;
    }
    Dedupe2.prototype.setupOnce = function(addGlobalEventProcessor2, getCurrentHub2) {
      addGlobalEventProcessor2(function(currentEvent) {
        var self2 = getCurrentHub2().getIntegration(Dedupe2);
        if (self2) {
          try {
            if (_shouldDropEvent2(currentEvent, self2._previousEvent)) {
              IS_DEBUG_BUILD4 && logger.warn("Event dropped due to being a duplicate of previously captured event.");
              return null;
            }
          } catch (_oO) {
            return self2._previousEvent = currentEvent;
          }
          return self2._previousEvent = currentEvent;
        }
        return currentEvent;
      });
    };
    Dedupe2.id = "Dedupe";
    return Dedupe2;
  }();
  function _shouldDropEvent2(currentEvent, previousEvent) {
    if (!previousEvent) {
      return false;
    }
    if (_isSameMessageEvent(currentEvent, previousEvent)) {
      return true;
    }
    if (_isSameExceptionEvent(currentEvent, previousEvent)) {
      return true;
    }
    return false;
  }
  function _isSameMessageEvent(currentEvent, previousEvent) {
    var currentMessage = currentEvent.message;
    var previousMessage = previousEvent.message;
    if (!currentMessage && !previousMessage) {
      return false;
    }
    if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
      return false;
    }
    if (currentMessage !== previousMessage) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameExceptionEvent(currentEvent, previousEvent) {
    var previousException = _getExceptionFromEvent(previousEvent);
    var currentException = _getExceptionFromEvent(currentEvent);
    if (!previousException || !currentException) {
      return false;
    }
    if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
      return false;
    }
    if (!_isSameFingerprint(currentEvent, previousEvent)) {
      return false;
    }
    if (!_isSameStacktrace(currentEvent, previousEvent)) {
      return false;
    }
    return true;
  }
  function _isSameStacktrace(currentEvent, previousEvent) {
    var currentFrames = _getFramesFromEvent(currentEvent);
    var previousFrames = _getFramesFromEvent(previousEvent);
    if (!currentFrames && !previousFrames) {
      return true;
    }
    if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
      return false;
    }
    currentFrames = currentFrames;
    previousFrames = previousFrames;
    if (previousFrames.length !== currentFrames.length) {
      return false;
    }
    for (var i = 0; i < previousFrames.length; i++) {
      var frameA = previousFrames[i];
      var frameB = currentFrames[i];
      if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
        return false;
      }
    }
    return true;
  }
  function _isSameFingerprint(currentEvent, previousEvent) {
    var currentFingerprint = currentEvent.fingerprint;
    var previousFingerprint = previousEvent.fingerprint;
    if (!currentFingerprint && !previousFingerprint) {
      return true;
    }
    if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
      return false;
    }
    currentFingerprint = currentFingerprint;
    previousFingerprint = previousFingerprint;
    try {
      return !!(currentFingerprint.join("") === previousFingerprint.join(""));
    } catch (_oO) {
      return false;
    }
  }
  function _getExceptionFromEvent(event) {
    return event.exception && event.exception.values && event.exception.values[0];
  }
  function _getFramesFromEvent(event) {
    var exception = event.exception;
    if (exception) {
      try {
        return exception.values[0].stacktrace.frames;
      } catch (_oO) {
        return void 0;
      }
    } else if (event.stacktrace) {
      return event.stacktrace.frames;
    }
    return void 0;
  }

  // ../node_modules/@sentry/browser/esm/client.js
  var BrowserClient = function(_super) {
    __extends(BrowserClient2, _super);
    function BrowserClient2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = this;
      options._metadata = options._metadata || {};
      options._metadata.sdk = options._metadata.sdk || {
        name: "sentry.javascript.browser",
        packages: [
          {
            name: "npm:@sentry/browser",
            version: SDK_VERSION
          }
        ],
        version: SDK_VERSION
      };
      _this = _super.call(this, BrowserBackend, options) || this;
      return _this;
    }
    BrowserClient2.prototype.showReportDialog = function(options) {
      if (options === void 0) {
        options = {};
      }
      var document2 = getGlobalObject().document;
      if (!document2) {
        return;
      }
      if (!this._isEnabled()) {
        IS_DEBUG_BUILD4 && logger.error("Trying to call showReportDialog with Sentry Client disabled");
        return;
      }
      injectReportDialog(__assign(__assign({}, options), { dsn: options.dsn || this.getDsn() }));
    };
    BrowserClient2.prototype._prepareEvent = function(event, scope, hint) {
      event.platform = event.platform || "javascript";
      return _super.prototype._prepareEvent.call(this, event, scope, hint);
    };
    BrowserClient2.prototype._sendEvent = function(event) {
      var integration = this.getIntegration(Breadcrumbs);
      if (integration) {
        integration.addSentryBreadcrumb(event);
      }
      _super.prototype._sendEvent.call(this, event);
    };
    return BrowserClient2;
  }(BaseClient);

  // ../node_modules/@sentry/browser/esm/sdk.js
  var defaultIntegrations = [
    new integrations_exports.InboundFilters(),
    new integrations_exports.FunctionToString(),
    new TryCatch(),
    new Breadcrumbs(),
    new GlobalHandlers(),
    new LinkedErrors(),
    new Dedupe(),
    new UserAgent()
  ];
  function init(options) {
    if (options === void 0) {
      options = {};
    }
    if (options.defaultIntegrations === void 0) {
      options.defaultIntegrations = defaultIntegrations;
    }
    if (options.release === void 0) {
      var window_1 = getGlobalObject();
      if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
        options.release = window_1.SENTRY_RELEASE.id;
      }
    }
    if (options.autoSessionTracking === void 0) {
      options.autoSessionTracking = true;
    }
    if (options.sendClientReports === void 0) {
      options.sendClientReports = true;
    }
    initAndBind(BrowserClient, options);
    if (options.autoSessionTracking) {
      startSessionTracking();
    }
  }
  function close(timeout) {
    var client = getCurrentHub().getClient();
    if (client) {
      return client.close(timeout);
    }
    IS_DEBUG_BUILD4 && logger.warn("Cannot flush events and disable SDK. No client defined.");
    return resolvedSyncPromise(false);
  }
  function startSessionOnHub(hub) {
    hub.startSession({ ignoreDuration: true });
    hub.captureSession();
  }
  function startSessionTracking() {
    var window2 = getGlobalObject();
    var document2 = window2.document;
    if (typeof document2 === "undefined") {
      IS_DEBUG_BUILD4 && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
      return;
    }
    var hub = getCurrentHub();
    if (!hub.captureSession) {
      return;
    }
    startSessionOnHub(hub);
    addInstrumentationHandler("history", function(_a) {
      var from = _a.from, to = _a.to;
      if (!(from === void 0 || from === to)) {
        startSessionOnHub(getCurrentHub());
      }
    });
  }

  // ../node_modules/@sentry/tracing/node_modules/tslib/modules/index.js
  var import_tslib39 = __toESM(require_tslib6(), 1);
  var {
    __extends: __extends6,
    __assign: __assign6,
    __rest: __rest6,
    __decorate: __decorate6,
    __param: __param6,
    __metadata: __metadata6,
    __awaiter: __awaiter7,
    __generator: __generator6,
    __exportStar: __exportStar6,
    __createBinding: __createBinding6,
    __values: __values6,
    __read: __read6,
    __spread: __spread6,
    __spreadArrays: __spreadArrays6,
    __await: __await6,
    __asyncGenerator: __asyncGenerator6,
    __asyncDelegator: __asyncDelegator6,
    __asyncValues: __asyncValues6,
    __makeTemplateObject: __makeTemplateObject6,
    __importStar: __importStar6,
    __importDefault: __importDefault6,
    __classPrivateFieldGet: __classPrivateFieldGet6,
    __classPrivateFieldSet: __classPrivateFieldSet6
  } = import_tslib39.default;

  // ../node_modules/@sentry/tracing/esm/flags.js
  var IS_DEBUG_BUILD5 = typeof __SENTRY_DEBUG__ === "undefined" ? true : __SENTRY_DEBUG__;

  // ../node_modules/@sentry/tracing/esm/utils.js
  function hasTracingEnabled(maybeOptions) {
    var client = getCurrentHub().getClient();
    var options = maybeOptions || client && client.getOptions();
    return !!options && ("tracesSampleRate" in options || "tracesSampler" in options);
  }
  function getActiveTransaction(maybeHub) {
    var hub = maybeHub || getCurrentHub();
    var scope = hub.getScope();
    return scope && scope.getTransaction();
  }
  function msToSec(time) {
    return time / 1e3;
  }
  function secToMs(time) {
    return time * 1e3;
  }

  // ../node_modules/@sentry/tracing/esm/errors.js
  function registerErrorInstrumentation() {
    addInstrumentationHandler("error", errorCallback);
    addInstrumentationHandler("unhandledrejection", errorCallback);
  }
  function errorCallback() {
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      var status_1 = "internal_error";
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Transaction: " + status_1 + " -> Global error occured");
      activeTransaction.setStatus(status_1);
    }
  }

  // ../node_modules/@sentry/tracing/esm/constants.js
  var FINISH_REASON_TAG = "finishReason";
  var IDLE_TRANSACTION_FINISH_REASONS = ["heartbeatFailed", "idleTimeout", "documentHidden"];

  // ../node_modules/@sentry/tracing/esm/span.js
  var SpanRecorder = function() {
    function SpanRecorder2(maxlen) {
      if (maxlen === void 0) {
        maxlen = 1e3;
      }
      this.spans = [];
      this._maxlen = maxlen;
    }
    SpanRecorder2.prototype.add = function(span) {
      if (this.spans.length > this._maxlen) {
        span.spanRecorder = void 0;
      } else {
        this.spans.push(span);
      }
    };
    return SpanRecorder2;
  }();
  var Span = function() {
    function Span2(spanContext) {
      this.traceId = uuid4();
      this.spanId = uuid4().substring(16);
      this.startTimestamp = timestampWithMs();
      this.tags = {};
      this.data = {};
      if (!spanContext) {
        return this;
      }
      if (spanContext.traceId) {
        this.traceId = spanContext.traceId;
      }
      if (spanContext.spanId) {
        this.spanId = spanContext.spanId;
      }
      if (spanContext.parentSpanId) {
        this.parentSpanId = spanContext.parentSpanId;
      }
      if ("sampled" in spanContext) {
        this.sampled = spanContext.sampled;
      }
      if (spanContext.op) {
        this.op = spanContext.op;
      }
      if (spanContext.description) {
        this.description = spanContext.description;
      }
      if (spanContext.data) {
        this.data = spanContext.data;
      }
      if (spanContext.tags) {
        this.tags = spanContext.tags;
      }
      if (spanContext.status) {
        this.status = spanContext.status;
      }
      if (spanContext.startTimestamp) {
        this.startTimestamp = spanContext.startTimestamp;
      }
      if (spanContext.endTimestamp) {
        this.endTimestamp = spanContext.endTimestamp;
      }
    }
    Span2.prototype.child = function(spanContext) {
      return this.startChild(spanContext);
    };
    Span2.prototype.startChild = function(spanContext) {
      var childSpan = new Span2(__assign6(__assign6({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
      childSpan.spanRecorder = this.spanRecorder;
      if (childSpan.spanRecorder) {
        childSpan.spanRecorder.add(childSpan);
      }
      childSpan.transaction = this.transaction;
      return childSpan;
    };
    Span2.prototype.setTag = function(key, value) {
      var _a;
      this.tags = __assign6(__assign6({}, this.tags), (_a = {}, _a[key] = value, _a));
      return this;
    };
    Span2.prototype.setData = function(key, value) {
      var _a;
      this.data = __assign6(__assign6({}, this.data), (_a = {}, _a[key] = value, _a));
      return this;
    };
    Span2.prototype.setStatus = function(value) {
      this.status = value;
      return this;
    };
    Span2.prototype.setHttpStatus = function(httpStatus) {
      this.setTag("http.status_code", String(httpStatus));
      var spanStatus = spanStatusfromHttpCode(httpStatus);
      if (spanStatus !== "unknown_error") {
        this.setStatus(spanStatus);
      }
      return this;
    };
    Span2.prototype.isSuccess = function() {
      return this.status === "ok";
    };
    Span2.prototype.finish = function(endTimestamp) {
      this.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
    };
    Span2.prototype.toTraceparent = function() {
      var sampledString = "";
      if (this.sampled !== void 0) {
        sampledString = this.sampled ? "-1" : "-0";
      }
      return this.traceId + "-" + this.spanId + sampledString;
    };
    Span2.prototype.toContext = function() {
      return dropUndefinedKeys({
        data: this.data,
        description: this.description,
        endTimestamp: this.endTimestamp,
        op: this.op,
        parentSpanId: this.parentSpanId,
        sampled: this.sampled,
        spanId: this.spanId,
        startTimestamp: this.startTimestamp,
        status: this.status,
        tags: this.tags,
        traceId: this.traceId
      });
    };
    Span2.prototype.updateWithContext = function(spanContext) {
      var _a, _b, _c, _d, _e;
      this.data = (_a = spanContext.data, _a !== null && _a !== void 0 ? _a : {});
      this.description = spanContext.description;
      this.endTimestamp = spanContext.endTimestamp;
      this.op = spanContext.op;
      this.parentSpanId = spanContext.parentSpanId;
      this.sampled = spanContext.sampled;
      this.spanId = (_b = spanContext.spanId, _b !== null && _b !== void 0 ? _b : this.spanId);
      this.startTimestamp = (_c = spanContext.startTimestamp, _c !== null && _c !== void 0 ? _c : this.startTimestamp);
      this.status = spanContext.status;
      this.tags = (_d = spanContext.tags, _d !== null && _d !== void 0 ? _d : {});
      this.traceId = (_e = spanContext.traceId, _e !== null && _e !== void 0 ? _e : this.traceId);
      return this;
    };
    Span2.prototype.getTraceContext = function() {
      return dropUndefinedKeys({
        data: Object.keys(this.data).length > 0 ? this.data : void 0,
        description: this.description,
        op: this.op,
        parent_span_id: this.parentSpanId,
        span_id: this.spanId,
        status: this.status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        trace_id: this.traceId
      });
    };
    Span2.prototype.toJSON = function() {
      return dropUndefinedKeys({
        data: Object.keys(this.data).length > 0 ? this.data : void 0,
        description: this.description,
        op: this.op,
        parent_span_id: this.parentSpanId,
        span_id: this.spanId,
        start_timestamp: this.startTimestamp,
        status: this.status,
        tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
        timestamp: this.endTimestamp,
        trace_id: this.traceId
      });
    };
    return Span2;
  }();
  function spanStatusfromHttpCode(httpStatus) {
    if (httpStatus < 400 && httpStatus >= 100) {
      return "ok";
    }
    if (httpStatus >= 400 && httpStatus < 500) {
      switch (httpStatus) {
        case 401:
          return "unauthenticated";
        case 403:
          return "permission_denied";
        case 404:
          return "not_found";
        case 409:
          return "already_exists";
        case 413:
          return "failed_precondition";
        case 429:
          return "resource_exhausted";
        default:
          return "invalid_argument";
      }
    }
    if (httpStatus >= 500 && httpStatus < 600) {
      switch (httpStatus) {
        case 501:
          return "unimplemented";
        case 503:
          return "unavailable";
        case 504:
          return "deadline_exceeded";
        default:
          return "internal_error";
      }
    }
    return "unknown_error";
  }

  // ../node_modules/@sentry/tracing/esm/transaction.js
  var Transaction = function(_super) {
    __extends6(Transaction2, _super);
    function Transaction2(transactionContext, hub) {
      var _this = _super.call(this, transactionContext) || this;
      _this._measurements = {};
      _this._hub = getCurrentHub();
      if (isInstanceOf(hub, Hub)) {
        _this._hub = hub;
      }
      _this.name = transactionContext.name || "";
      _this.metadata = transactionContext.metadata || {};
      _this._trimEnd = transactionContext.trimEnd;
      _this.transaction = _this;
      return _this;
    }
    Transaction2.prototype.setName = function(name69) {
      this.name = name69;
    };
    Transaction2.prototype.initSpanRecorder = function(maxlen) {
      if (maxlen === void 0) {
        maxlen = 1e3;
      }
      if (!this.spanRecorder) {
        this.spanRecorder = new SpanRecorder(maxlen);
      }
      this.spanRecorder.add(this);
    };
    Transaction2.prototype.setMeasurements = function(measurements) {
      this._measurements = __assign6({}, measurements);
    };
    Transaction2.prototype.setMetadata = function(newMetadata) {
      this.metadata = __assign6(__assign6({}, this.metadata), newMetadata);
    };
    Transaction2.prototype.finish = function(endTimestamp) {
      var _this = this;
      if (this.endTimestamp !== void 0) {
        return void 0;
      }
      if (!this.name) {
        IS_DEBUG_BUILD5 && logger.warn("Transaction has no name, falling back to `<unlabeled transaction>`.");
        this.name = "<unlabeled transaction>";
      }
      _super.prototype.finish.call(this, endTimestamp);
      if (this.sampled !== true) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled.");
        var client = this._hub.getClient();
        var transport = client && client.getTransport && client.getTransport();
        if (transport && transport.recordLostEvent) {
          transport.recordLostEvent("sample_rate", "transaction");
        }
        return void 0;
      }
      var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function(s) {
        return s !== _this && s.endTimestamp;
      }) : [];
      if (this._trimEnd && finishedSpans.length > 0) {
        this.endTimestamp = finishedSpans.reduce(function(prev, current) {
          if (prev.endTimestamp && current.endTimestamp) {
            return prev.endTimestamp > current.endTimestamp ? prev : current;
          }
          return prev;
        }).endTimestamp;
      }
      var transaction = {
        contexts: {
          trace: this.getTraceContext()
        },
        spans: finishedSpans,
        start_timestamp: this.startTimestamp,
        tags: this.tags,
        timestamp: this.endTimestamp,
        transaction: this.name,
        type: "transaction",
        sdkProcessingMetadata: this.metadata
      };
      var hasMeasurements = Object.keys(this._measurements).length > 0;
      if (hasMeasurements) {
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding measurements to transaction", JSON.stringify(this._measurements, void 0, 2));
        transaction.measurements = this._measurements;
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Finishing " + this.op + " transaction: " + this.name + ".");
      return this._hub.captureEvent(transaction);
    };
    Transaction2.prototype.toContext = function() {
      var spanContext = _super.prototype.toContext.call(this);
      return dropUndefinedKeys(__assign6(__assign6({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
    };
    Transaction2.prototype.updateWithContext = function(transactionContext) {
      var _a;
      _super.prototype.updateWithContext.call(this, transactionContext);
      this.name = (_a = transactionContext.name, _a !== null && _a !== void 0 ? _a : "");
      this._trimEnd = transactionContext.trimEnd;
      return this;
    };
    return Transaction2;
  }(Span);

  // ../node_modules/@sentry/tracing/esm/idletransaction.js
  var DEFAULT_IDLE_TIMEOUT = 1e3;
  var HEARTBEAT_INTERVAL = 5e3;
  var IdleTransactionSpanRecorder = function(_super) {
    __extends6(IdleTransactionSpanRecorder2, _super);
    function IdleTransactionSpanRecorder2(_pushActivity, _popActivity, transactionSpanId, maxlen) {
      if (transactionSpanId === void 0) {
        transactionSpanId = "";
      }
      var _this = _super.call(this, maxlen) || this;
      _this._pushActivity = _pushActivity;
      _this._popActivity = _popActivity;
      _this.transactionSpanId = transactionSpanId;
      return _this;
    }
    IdleTransactionSpanRecorder2.prototype.add = function(span) {
      var _this = this;
      if (span.spanId !== this.transactionSpanId) {
        span.finish = function(endTimestamp) {
          span.endTimestamp = typeof endTimestamp === "number" ? endTimestamp : timestampWithMs();
          _this._popActivity(span.spanId);
        };
        if (span.endTimestamp === void 0) {
          this._pushActivity(span.spanId);
        }
      }
      _super.prototype.add.call(this, span);
    };
    return IdleTransactionSpanRecorder2;
  }(SpanRecorder);
  var IdleTransaction = function(_super) {
    __extends6(IdleTransaction2, _super);
    function IdleTransaction2(transactionContext, _idleHub, _idleTimeout, _onScope) {
      if (_idleTimeout === void 0) {
        _idleTimeout = DEFAULT_IDLE_TIMEOUT;
      }
      if (_onScope === void 0) {
        _onScope = false;
      }
      var _this = _super.call(this, transactionContext, _idleHub) || this;
      _this._idleHub = _idleHub;
      _this._idleTimeout = _idleTimeout;
      _this._onScope = _onScope;
      _this.activities = {};
      _this._heartbeatCounter = 0;
      _this._finished = false;
      _this._beforeFinishCallbacks = [];
      if (_idleHub && _onScope) {
        clearActiveTransaction(_idleHub);
        IS_DEBUG_BUILD5 && logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
        _idleHub.configureScope(function(scope) {
          return scope.setSpan(_this);
        });
      }
      _this._initTimeout = setTimeout(function() {
        if (!_this._finished) {
          _this.finish();
        }
      }, _this._idleTimeout);
      return _this;
    }
    IdleTransaction2.prototype.finish = function(endTimestamp) {
      var e_1, _a;
      var _this = this;
      if (endTimestamp === void 0) {
        endTimestamp = timestampWithMs();
      }
      this._finished = true;
      this.activities = {};
      if (this.spanRecorder) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] finishing IdleTransaction", new Date(endTimestamp * 1e3).toISOString(), this.op);
        try {
          for (var _b = __values6(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
            var callback = _c.value;
            callback(this, endTimestamp);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        this.spanRecorder.spans = this.spanRecorder.spans.filter(function(span) {
          if (span.spanId === _this.spanId) {
            return true;
          }
          if (!span.endTimestamp) {
            span.endTimestamp = endTimestamp;
            span.setStatus("cancelled");
            IS_DEBUG_BUILD5 && logger.log("[Tracing] cancelling span since transaction ended early", JSON.stringify(span, void 0, 2));
          }
          var keepSpan = span.startTimestamp < endTimestamp;
          if (!keepSpan) {
            IS_DEBUG_BUILD5 && logger.log("[Tracing] discarding Span since it happened after Transaction was finished", JSON.stringify(span, void 0, 2));
          }
          return keepSpan;
        });
        IS_DEBUG_BUILD5 && logger.log("[Tracing] flushing IdleTransaction");
      } else {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] No active IdleTransaction");
      }
      if (this._onScope) {
        clearActiveTransaction(this._idleHub);
      }
      return _super.prototype.finish.call(this, endTimestamp);
    };
    IdleTransaction2.prototype.registerBeforeFinishCallback = function(callback) {
      this._beforeFinishCallbacks.push(callback);
    };
    IdleTransaction2.prototype.initSpanRecorder = function(maxlen) {
      var _this = this;
      if (!this.spanRecorder) {
        var pushActivity = function(id) {
          if (_this._finished) {
            return;
          }
          _this._pushActivity(id);
        };
        var popActivity = function(id) {
          if (_this._finished) {
            return;
          }
          _this._popActivity(id);
        };
        this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
        IS_DEBUG_BUILD5 && logger.log("Starting heartbeat");
        this._pingHeartbeat();
      }
      this.spanRecorder.add(this);
    };
    IdleTransaction2.prototype._pushActivity = function(spanId) {
      if (this._initTimeout) {
        clearTimeout(this._initTimeout);
        this._initTimeout = void 0;
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] pushActivity: " + spanId);
      this.activities[spanId] = true;
      IS_DEBUG_BUILD5 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
    };
    IdleTransaction2.prototype._popActivity = function(spanId) {
      var _this = this;
      if (this.activities[spanId]) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] popActivity " + spanId);
        delete this.activities[spanId];
        IS_DEBUG_BUILD5 && logger.log("[Tracing] new activities count", Object.keys(this.activities).length);
      }
      if (Object.keys(this.activities).length === 0) {
        var timeout = this._idleTimeout;
        var end_1 = timestampWithMs() + timeout / 1e3;
        setTimeout(function() {
          if (!_this._finished) {
            _this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);
            _this.finish(end_1);
          }
        }, timeout);
      }
    };
    IdleTransaction2.prototype._beat = function() {
      if (this._finished) {
        return;
      }
      var heartbeatString = Object.keys(this.activities).join("");
      if (heartbeatString === this._prevHeartbeatString) {
        this._heartbeatCounter += 1;
      } else {
        this._heartbeatCounter = 1;
      }
      this._prevHeartbeatString = heartbeatString;
      if (this._heartbeatCounter >= 3) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
        this.setStatus("deadline_exceeded");
        this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);
        this.finish();
      } else {
        this._pingHeartbeat();
      }
    };
    IdleTransaction2.prototype._pingHeartbeat = function() {
      var _this = this;
      IS_DEBUG_BUILD5 && logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
      setTimeout(function() {
        _this._beat();
      }, HEARTBEAT_INTERVAL);
    };
    return IdleTransaction2;
  }(Transaction);
  function clearActiveTransaction(hub) {
    if (hub) {
      var scope = hub.getScope();
      if (scope) {
        var transaction = scope.getTransaction();
        if (transaction) {
          scope.setSpan(void 0);
        }
      }
    }
  }

  // ../node_modules/@sentry/tracing/esm/hubextensions.js
  function traceHeaders() {
    var scope = this.getScope();
    if (scope) {
      var span = scope.getSpan();
      if (span) {
        return {
          "sentry-trace": span.toTraceparent()
        };
      }
    }
    return {};
  }
  function sample(transaction, options, samplingContext) {
    if (!hasTracingEnabled(options)) {
      transaction.sampled = false;
      return transaction;
    }
    if (transaction.sampled !== void 0) {
      transaction.setMetadata({
        transactionSampling: { method: "explicitly_set" }
      });
      return transaction;
    }
    var sampleRate;
    if (typeof options.tracesSampler === "function") {
      sampleRate = options.tracesSampler(samplingContext);
      transaction.setMetadata({
        transactionSampling: {
          method: "client_sampler",
          rate: Number(sampleRate)
        }
      });
    } else if (samplingContext.parentSampled !== void 0) {
      sampleRate = samplingContext.parentSampled;
      transaction.setMetadata({
        transactionSampling: { method: "inheritance" }
      });
    } else {
      sampleRate = options.tracesSampleRate;
      transaction.setMetadata({
        transactionSampling: {
          method: "client_rate",
          rate: Number(sampleRate)
        }
      });
    }
    if (!isValidSampleRate(sampleRate)) {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
      transaction.sampled = false;
      return transaction;
    }
    if (!sampleRate) {
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"));
      transaction.sampled = false;
      return transaction;
    }
    transaction.sampled = Math.random() < sampleRate;
    if (!transaction.sampled) {
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
      return transaction;
    }
    IS_DEBUG_BUILD5 && logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
    return transaction;
  }
  function isValidSampleRate(rate) {
    if (isNaN2(rate) || !(typeof rate === "number" || typeof rate === "boolean")) {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
      return false;
    }
    if (rate < 0 || rate > 1) {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
      return false;
    }
    return true;
  }
  function _startTransaction(transactionContext, customSamplingContext) {
    var client = this.getClient();
    var options = client && client.getOptions() || {};
    var transaction = new Transaction(transactionContext, this);
    transaction = sample(transaction, options, __assign6({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
    if (transaction.sampled) {
      transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    return transaction;
  }
  function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
    var client = hub.getClient();
    var options = client && client.getOptions() || {};
    var transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);
    transaction = sample(transaction, options, __assign6({ parentSampled: transactionContext.parentSampled, transactionContext }, customSamplingContext));
    if (transaction.sampled) {
      transaction.initSpanRecorder(options._experiments && options._experiments.maxSpans);
    }
    return transaction;
  }
  function _addTracingExtensions() {
    var carrier = getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
    if (!carrier.__SENTRY__.extensions.startTransaction) {
      carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
    }
    if (!carrier.__SENTRY__.extensions.traceHeaders) {
      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
    }
  }
  function _autoloadDatabaseIntegrations() {
    var carrier = getMainCarrier();
    if (!carrier.__SENTRY__) {
      return;
    }
    var packageToIntegrationMapping = {
      mongodb: function() {
        var integration = dynamicRequire(module, "./integrations/node/mongo");
        return new integration.Mongo();
      },
      mongoose: function() {
        var integration = dynamicRequire(module, "./integrations/node/mongo");
        return new integration.Mongo({ mongoose: true });
      },
      mysql: function() {
        var integration = dynamicRequire(module, "./integrations/node/mysql");
        return new integration.Mysql();
      },
      pg: function() {
        var integration = dynamicRequire(module, "./integrations/node/postgres");
        return new integration.Postgres();
      }
    };
    var mappedPackages = Object.keys(packageToIntegrationMapping).filter(function(moduleName) {
      return !!loadModule(moduleName);
    }).map(function(pkg) {
      try {
        return packageToIntegrationMapping[pkg]();
      } catch (e) {
        return void 0;
      }
    }).filter(function(p) {
      return p;
    });
    if (mappedPackages.length > 0) {
      carrier.__SENTRY__.integrations = __spread6(carrier.__SENTRY__.integrations || [], mappedPackages);
    }
  }
  function addExtensionMethods() {
    _addTracingExtensions();
    if (isNodeEnv()) {
      _autoloadDatabaseIntegrations();
    }
    registerErrorInstrumentation();
  }

  // ../node_modules/@sentry/tracing/esm/browser/backgroundtab.js
  var global8 = getGlobalObject();
  function registerBackgroundTabDetection() {
    if (global8 && global8.document) {
      global8.document.addEventListener("visibilitychange", function() {
        var activeTransaction = getActiveTransaction();
        if (global8.document.hidden && activeTransaction) {
          var statusType = "cancelled";
          IS_DEBUG_BUILD5 && logger.log("[Tracing] Transaction: " + statusType + " -> since tab moved to the background, op: " + activeTransaction.op);
          if (!activeTransaction.status) {
            activeTransaction.setStatus(statusType);
          }
          activeTransaction.setTag("visibilitychange", "document.hidden");
          activeTransaction.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[2]);
          activeTransaction.finish();
        }
      });
    } else {
      IS_DEBUG_BUILD5 && logger.warn("[Tracing] Could not set up background tab detection due to lack of global document");
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js
  var bindReporter = function(callback, metric, reportAllChanges) {
    var prevValue;
    return function(forceReport) {
      if (metric.value >= 0) {
        if (forceReport || reportAllChanges) {
          metric.delta = metric.value - (prevValue || 0);
          if (metric.delta || prevValue === void 0) {
            prevValue = metric.value;
            callback(metric);
          }
        }
      }
    };
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js
  var generateUniqueID = function() {
    return "v2-" + Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js
  var initMetric = function(name69, value) {
    return {
      name: name69,
      value: value !== null && value !== void 0 ? value : -1,
      delta: 0,
      entries: [],
      id: generateUniqueID()
    };
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js
  var observe = function(type, callback) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(type)) {
        if (type === "first-input" && !("PerformanceEventTiming" in self)) {
          return;
        }
        var po = new PerformanceObserver(function(l) {
          return l.getEntries().map(callback);
        });
        po.observe({ type, buffered: true });
        return po;
      }
    } catch (e) {
    }
    return;
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js
  var onHidden = function(cb, once) {
    var onHiddenOrPageHide = function(event) {
      if (event.type === "pagehide" || getGlobalObject().document.visibilityState === "hidden") {
        cb(event);
        if (once) {
          removeEventListener("visibilitychange", onHiddenOrPageHide, true);
          removeEventListener("pagehide", onHiddenOrPageHide, true);
        }
      }
    };
    addEventListener("visibilitychange", onHiddenOrPageHide, true);
    addEventListener("pagehide", onHiddenOrPageHide, true);
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js
  var getCLS = function(onReport, reportAllChanges) {
    var metric = initMetric("CLS", 0);
    var report;
    var sessionValue = 0;
    var sessionEntries = [];
    var entryHandler = function(entry) {
      if (entry && !entry.hadRecentInput) {
        var firstSessionEntry = sessionEntries[0];
        var lastSessionEntry = sessionEntries[sessionEntries.length - 1];
        if (sessionValue && sessionEntries.length !== 0 && entry.startTime - lastSessionEntry.startTime < 1e3 && entry.startTime - firstSessionEntry.startTime < 5e3) {
          sessionValue += entry.value;
          sessionEntries.push(entry);
        } else {
          sessionValue = entry.value;
          sessionEntries = [entry];
        }
        if (sessionValue > metric.value) {
          metric.value = sessionValue;
          metric.entries = sessionEntries;
          if (report) {
            report();
          }
        }
      }
    };
    var po = observe("layout-shift", entryHandler);
    if (po) {
      report = bindReporter(onReport, metric, reportAllChanges);
      onHidden(function() {
        po.takeRecords().map(entryHandler);
        report(true);
      });
    }
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js
  var firstHiddenTime = -1;
  var initHiddenTime = function() {
    return getGlobalObject().document.visibilityState === "hidden" ? 0 : Infinity;
  };
  var trackChanges = function() {
    onHidden(function(_a) {
      var timeStamp = _a.timeStamp;
      firstHiddenTime = timeStamp;
    }, true);
  };
  var getVisibilityWatcher = function() {
    if (firstHiddenTime < 0) {
      firstHiddenTime = initHiddenTime();
      trackChanges();
    }
    return {
      get firstHiddenTime() {
        return firstHiddenTime;
      }
    };
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js
  var getFID = function(onReport, reportAllChanges) {
    var visibilityWatcher = getVisibilityWatcher();
    var metric = initMetric("FID");
    var report;
    var entryHandler = function(entry) {
      if (report && entry.startTime < visibilityWatcher.firstHiddenTime) {
        metric.value = entry.processingStart - entry.startTime;
        metric.entries.push(entry);
        report(true);
      }
    };
    var po = observe("first-input", entryHandler);
    if (po) {
      report = bindReporter(onReport, metric, reportAllChanges);
      onHidden(function() {
        po.takeRecords().map(entryHandler);
        po.disconnect();
      }, true);
    }
  };

  // ../node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js
  var reportedMetricIDs = {};
  var getLCP = function(onReport, reportAllChanges) {
    var visibilityWatcher = getVisibilityWatcher();
    var metric = initMetric("LCP");
    var report;
    var entryHandler = function(entry) {
      var value = entry.startTime;
      if (value < visibilityWatcher.firstHiddenTime) {
        metric.value = value;
        metric.entries.push(entry);
      }
      if (report) {
        report();
      }
    };
    var po = observe("largest-contentful-paint", entryHandler);
    if (po) {
      report = bindReporter(onReport, metric, reportAllChanges);
      var stopListening_1 = function() {
        if (!reportedMetricIDs[metric.id]) {
          po.takeRecords().map(entryHandler);
          po.disconnect();
          reportedMetricIDs[metric.id] = true;
          report(true);
        }
      };
      ["keydown", "click"].forEach(function(type) {
        addEventListener(type, stopListening_1, { once: true, capture: true });
      });
      onHidden(stopListening_1, true);
    }
  };

  // ../node_modules/@sentry/tracing/esm/browser/metrics.js
  var global9 = getGlobalObject();
  var MetricsInstrumentation = function() {
    function MetricsInstrumentation2(_reportAllChanges) {
      if (_reportAllChanges === void 0) {
        _reportAllChanges = false;
      }
      this._reportAllChanges = _reportAllChanges;
      this._measurements = {};
      this._performanceCursor = 0;
      if (!isNodeEnv() && global9 && global9.performance && global9.document) {
        if (global9.performance.mark) {
          global9.performance.mark("sentry-tracing-init");
        }
        this._trackCLS();
        this._trackLCP();
        this._trackFID();
      }
    }
    MetricsInstrumentation2.prototype.addPerformanceEntries = function(transaction) {
      var _this = this;
      if (!global9 || !global9.performance || !global9.performance.getEntries || !browserPerformanceTimeOrigin) {
        return;
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Adding & adjusting spans using Performance API");
      var timeOrigin = msToSec(browserPerformanceTimeOrigin);
      var responseStartTimestamp;
      var requestStartTimestamp;
      global9.performance.getEntries().slice(this._performanceCursor).forEach(function(entry) {
        var startTime = msToSec(entry.startTime);
        var duration = msToSec(entry.duration);
        if (transaction.op === "navigation" && timeOrigin + startTime < transaction.startTimestamp) {
          return;
        }
        switch (entry.entryType) {
          case "navigation": {
            addNavigationSpans(transaction, entry, timeOrigin);
            responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);
            requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);
            break;
          }
          case "mark":
          case "paint":
          case "measure": {
            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
            var firstHidden = getVisibilityWatcher();
            var shouldRecord = entry.startTime < firstHidden.firstHiddenTime;
            if (entry.name === "first-paint" && shouldRecord) {
              IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding FP");
              _this._measurements["fp"] = { value: entry.startTime };
              _this._measurements["mark.fp"] = { value: startTimestamp };
            }
            if (entry.name === "first-contentful-paint" && shouldRecord) {
              IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding FCP");
              _this._measurements["fcp"] = { value: entry.startTime };
              _this._measurements["mark.fcp"] = { value: startTimestamp };
            }
            break;
          }
          case "resource": {
            var resourceName = entry.name.replace(global9.location.origin, "");
            addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
            break;
          }
          default:
        }
      });
      this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
      this._trackNavigator(transaction);
      if (transaction.op === "pageload") {
        var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);
        if (typeof responseStartTimestamp === "number") {
          IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding TTFB");
          this._measurements["ttfb"] = { value: (responseStartTimestamp - transaction.startTimestamp) * 1e3 };
          if (typeof requestStartTimestamp === "number" && requestStartTimestamp <= responseStartTimestamp) {
            this._measurements["ttfb.requestTime"] = { value: (responseStartTimestamp - requestStartTimestamp) * 1e3 };
          }
        }
        ["fcp", "fp", "lcp"].forEach(function(name69) {
          if (!_this._measurements[name69] || timeOrigin_1 >= transaction.startTimestamp) {
            return;
          }
          var oldValue = _this._measurements[name69].value;
          var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);
          var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1e3);
          var delta = normalizedValue - oldValue;
          IS_DEBUG_BUILD5 && logger.log("[Measurements] Normalized " + name69 + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
          _this._measurements[name69].value = normalizedValue;
        });
        if (this._measurements["mark.fid"] && this._measurements["fid"]) {
          _startChild(transaction, {
            description: "first input delay",
            endTimestamp: this._measurements["mark.fid"].value + msToSec(this._measurements["fid"].value),
            op: "web.vitals",
            startTimestamp: this._measurements["mark.fid"].value
          });
        }
        if (!("fcp" in this._measurements)) {
          delete this._measurements.cls;
        }
        transaction.setMeasurements(this._measurements);
        tagMetricInfo(transaction, this._lcpEntry, this._clsEntry);
        transaction.setTag("sentry_reportAllChanges", this._reportAllChanges);
      }
    };
    MetricsInstrumentation2.prototype._trackNavigator = function(transaction) {
      var navigator = global9.navigator;
      if (!navigator) {
        return;
      }
      var connection = navigator.connection;
      if (connection) {
        if (connection.effectiveType) {
          transaction.setTag("effectiveConnectionType", connection.effectiveType);
        }
        if (connection.type) {
          transaction.setTag("connectionType", connection.type);
        }
        if (isMeasurementValue(connection.rtt)) {
          this._measurements["connection.rtt"] = { value: connection.rtt };
        }
        if (isMeasurementValue(connection.downlink)) {
          this._measurements["connection.downlink"] = { value: connection.downlink };
        }
      }
      if (isMeasurementValue(navigator.deviceMemory)) {
        transaction.setTag("deviceMemory", String(navigator.deviceMemory));
      }
      if (isMeasurementValue(navigator.hardwareConcurrency)) {
        transaction.setTag("hardwareConcurrency", String(navigator.hardwareConcurrency));
      }
    };
    MetricsInstrumentation2.prototype._trackCLS = function() {
      var _this = this;
      getCLS(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding CLS");
        _this._measurements["cls"] = { value: metric.value };
        _this._clsEntry = entry;
      });
    };
    MetricsInstrumentation2.prototype._trackLCP = function() {
      var _this = this;
      getLCP(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        var timeOrigin = msToSec(browserPerformanceTimeOrigin);
        var startTime = msToSec(entry.startTime);
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding LCP");
        _this._measurements["lcp"] = { value: metric.value };
        _this._measurements["mark.lcp"] = { value: timeOrigin + startTime };
        _this._lcpEntry = entry;
      }, this._reportAllChanges);
    };
    MetricsInstrumentation2.prototype._trackFID = function() {
      var _this = this;
      getFID(function(metric) {
        var entry = metric.entries.pop();
        if (!entry) {
          return;
        }
        var timeOrigin = msToSec(browserPerformanceTimeOrigin);
        var startTime = msToSec(entry.startTime);
        IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding FID");
        _this._measurements["fid"] = { value: metric.value };
        _this._measurements["mark.fid"] = { value: timeOrigin + startTime };
      });
    };
    return MetricsInstrumentation2;
  }();
  function addNavigationSpans(transaction, entry, timeOrigin) {
    ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach(function(event) {
      addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);
    });
    addPerformanceNavigationTiming(transaction, entry, "secureConnection", timeOrigin, "TLS/SSL", "connectEnd");
    addPerformanceNavigationTiming(transaction, entry, "fetch", timeOrigin, "cache", "domainLookupStart");
    addPerformanceNavigationTiming(transaction, entry, "domainLookup", timeOrigin, "DNS");
    addRequest(transaction, entry, timeOrigin);
  }
  function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
    var measureStartTimestamp = timeOrigin + startTime;
    var measureEndTimestamp = measureStartTimestamp + duration;
    _startChild(transaction, {
      description: entry.name,
      endTimestamp: measureEndTimestamp,
      op: entry.entryType,
      startTimestamp: measureStartTimestamp
    });
    return measureStartTimestamp;
  }
  function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
    if (entry.initiatorType === "xmlhttprequest" || entry.initiatorType === "fetch") {
      return;
    }
    var data = {};
    if ("transferSize" in entry) {
      data["Transfer Size"] = entry.transferSize;
    }
    if ("encodedBodySize" in entry) {
      data["Encoded Body Size"] = entry.encodedBodySize;
    }
    if ("decodedBodySize" in entry) {
      data["Decoded Body Size"] = entry.decodedBodySize;
    }
    var startTimestamp = timeOrigin + startTime;
    var endTimestamp = startTimestamp + duration;
    _startChild(transaction, {
      description: resourceName,
      endTimestamp,
      op: entry.initiatorType ? "resource." + entry.initiatorType : "resource",
      startTimestamp,
      data
    });
  }
  function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, description, eventEnd) {
    var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
    var start = entry[event + "Start"];
    if (!start || !end) {
      return;
    }
    _startChild(transaction, {
      op: "browser",
      description: description !== null && description !== void 0 ? description : event,
      startTimestamp: timeOrigin + msToSec(start),
      endTimestamp: timeOrigin + msToSec(end)
    });
  }
  function addRequest(transaction, entry, timeOrigin) {
    _startChild(transaction, {
      op: "browser",
      description: "request",
      startTimestamp: timeOrigin + msToSec(entry.requestStart),
      endTimestamp: timeOrigin + msToSec(entry.responseEnd)
    });
    _startChild(transaction, {
      op: "browser",
      description: "response",
      startTimestamp: timeOrigin + msToSec(entry.responseStart),
      endTimestamp: timeOrigin + msToSec(entry.responseEnd)
    });
  }
  function _startChild(transaction, _a) {
    var startTimestamp = _a.startTimestamp, ctx = __rest6(_a, ["startTimestamp"]);
    if (startTimestamp && transaction.startTimestamp > startTimestamp) {
      transaction.startTimestamp = startTimestamp;
    }
    return transaction.startChild(__assign6({ startTimestamp }, ctx));
  }
  function isMeasurementValue(value) {
    return typeof value === "number" && isFinite(value);
  }
  function tagMetricInfo(transaction, lcpEntry, clsEntry) {
    if (lcpEntry) {
      IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding LCP Data");
      if (lcpEntry.element) {
        transaction.setTag("lcp.element", htmlTreeAsString(lcpEntry.element));
      }
      if (lcpEntry.id) {
        transaction.setTag("lcp.id", lcpEntry.id);
      }
      if (lcpEntry.url) {
        transaction.setTag("lcp.url", lcpEntry.url.trim().slice(0, 200));
      }
      transaction.setTag("lcp.size", lcpEntry.size);
    }
    if (clsEntry && clsEntry.sources) {
      IS_DEBUG_BUILD5 && logger.log("[Measurements] Adding CLS Data");
      clsEntry.sources.forEach(function(source, index) {
        return transaction.setTag("cls.source." + (index + 1), htmlTreeAsString(source.node));
      });
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/request.js
  var DEFAULT_TRACING_ORIGINS = ["localhost", /^\//];
  var defaultRequestInstrumentationOptions = {
    traceFetch: true,
    traceXHR: true,
    tracingOrigins: DEFAULT_TRACING_ORIGINS
  };
  function instrumentOutgoingRequests(_options) {
    var _a = __assign6(__assign6({}, defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
    var urlMap = {};
    var defaultShouldCreateSpan = function(url) {
      if (urlMap[url]) {
        return urlMap[url];
      }
      var origins = tracingOrigins;
      urlMap[url] = origins.some(function(origin) {
        return isMatchingPattern(url, origin);
      }) && !isMatchingPattern(url, "sentry_key");
      return urlMap[url];
    };
    var shouldCreateSpan = defaultShouldCreateSpan;
    if (typeof shouldCreateSpanForRequest === "function") {
      shouldCreateSpan = function(url) {
        return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
      };
    }
    var spans = {};
    if (traceFetch) {
      addInstrumentationHandler("fetch", function(handlerData) {
        fetchCallback(handlerData, shouldCreateSpan, spans);
      });
    }
    if (traceXHR) {
      addInstrumentationHandler("xhr", function(handlerData) {
        xhrCallback(handlerData, shouldCreateSpan, spans);
      });
    }
  }
  function fetchCallback(handlerData, shouldCreateSpan, spans) {
    if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
      return;
    }
    if (handlerData.endTimestamp) {
      var spanId = handlerData.fetchData.__span;
      if (!spanId)
        return;
      var span = spans[spanId];
      if (span) {
        if (handlerData.response) {
          span.setHttpStatus(handlerData.response.status);
        } else if (handlerData.error) {
          span.setStatus("internal_error");
        }
        span.finish();
        delete spans[spanId];
      }
      return;
    }
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      var span = activeTransaction.startChild({
        data: __assign6(__assign6({}, handlerData.fetchData), { type: "fetch" }),
        description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
        op: "http.client"
      });
      handlerData.fetchData.__span = span.spanId;
      spans[span.spanId] = span;
      var request = handlerData.args[0] = handlerData.args[0];
      var options = handlerData.args[1] = handlerData.args[1] || {};
      var headers = options.headers;
      if (isInstanceOf(request, Request)) {
        headers = request.headers;
      }
      if (headers) {
        if (typeof headers.append === "function") {
          headers.append("sentry-trace", span.toTraceparent());
        } else if (Array.isArray(headers)) {
          headers = __spread6(headers, [["sentry-trace", span.toTraceparent()]]);
        } else {
          headers = __assign6(__assign6({}, headers), { "sentry-trace": span.toTraceparent() });
        }
      } else {
        headers = { "sentry-trace": span.toTraceparent() };
      }
      options.headers = headers;
    }
  }
  function xhrCallback(handlerData, shouldCreateSpan, spans) {
    if (!hasTracingEnabled() || handlerData.xhr && handlerData.xhr.__sentry_own_request__ || !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))) {
      return;
    }
    var xhr = handlerData.xhr.__sentry_xhr__;
    if (handlerData.endTimestamp) {
      var spanId = handlerData.xhr.__sentry_xhr_span_id__;
      if (!spanId)
        return;
      var span = spans[spanId];
      if (span) {
        span.setHttpStatus(xhr.status_code);
        span.finish();
        delete spans[spanId];
      }
      return;
    }
    var activeTransaction = getActiveTransaction();
    if (activeTransaction) {
      var span = activeTransaction.startChild({
        data: __assign6(__assign6({}, xhr.data), { type: "xhr", method: xhr.method, url: xhr.url }),
        description: xhr.method + " " + xhr.url,
        op: "http.client"
      });
      handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
      spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
      if (handlerData.xhr.setRequestHeader) {
        try {
          handlerData.xhr.setRequestHeader("sentry-trace", span.toTraceparent());
        } catch (_) {
        }
      }
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/router.js
  var global10 = getGlobalObject();
  function instrumentRoutingWithDefaults(customStartTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
    if (startTransactionOnPageLoad === void 0) {
      startTransactionOnPageLoad = true;
    }
    if (startTransactionOnLocationChange === void 0) {
      startTransactionOnLocationChange = true;
    }
    if (!global10 || !global10.location) {
      IS_DEBUG_BUILD5 && logger.warn("Could not initialize routing instrumentation due to invalid location");
      return;
    }
    var startingUrl = global10.location.href;
    var activeTransaction;
    if (startTransactionOnPageLoad) {
      activeTransaction = customStartTransaction({ name: global10.location.pathname, op: "pageload" });
    }
    if (startTransactionOnLocationChange) {
      addInstrumentationHandler("history", function(_a) {
        var to = _a.to, from = _a.from;
        if (from === void 0 && startingUrl && startingUrl.indexOf(to) !== -1) {
          startingUrl = void 0;
          return;
        }
        if (from !== to) {
          startingUrl = void 0;
          if (activeTransaction) {
            IS_DEBUG_BUILD5 && logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
            activeTransaction.finish();
          }
          activeTransaction = customStartTransaction({ name: global10.location.pathname, op: "navigation" });
        }
      });
    }
  }

  // ../node_modules/@sentry/tracing/esm/browser/browsertracing.js
  var DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
  var DEFAULT_BROWSER_TRACING_OPTIONS = __assign6({ idleTimeout: DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: instrumentRoutingWithDefaults, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, defaultRequestInstrumentationOptions);
  var BrowserTracing = function() {
    function BrowserTracing2(_options) {
      this.name = BrowserTracing2.id;
      this._configuredIdleTimeout = void 0;
      var tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
      if (_options) {
        this._configuredIdleTimeout = _options.idleTimeout;
        if (_options.tracingOrigins && Array.isArray(_options.tracingOrigins) && _options.tracingOrigins.length !== 0) {
          tracingOrigins = _options.tracingOrigins;
        } else {
          IS_DEBUG_BUILD5 && (this._emitOptionsWarning = true);
        }
      }
      this.options = __assign6(__assign6(__assign6({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins });
      var _metricOptions = this.options._metricOptions;
      this._metrics = new MetricsInstrumentation(_metricOptions && _metricOptions._reportAllChanges);
    }
    BrowserTracing2.prototype.setupOnce = function(_, getCurrentHub2) {
      var _this = this;
      this._getCurrentHub = getCurrentHub2;
      if (this._emitOptionsWarning) {
        IS_DEBUG_BUILD5 && logger.warn("[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.");
        IS_DEBUG_BUILD5 && logger.warn("[Tracing] We added a reasonable default for you: " + defaultRequestInstrumentationOptions.tracingOrigins);
      }
      var _a = this.options, instrumentRouting = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
      instrumentRouting(function(context) {
        return _this._createRouteTransaction(context);
      }, startTransactionOnPageLoad, startTransactionOnLocationChange);
      if (markBackgroundTransactions) {
        registerBackgroundTabDetection();
      }
      instrumentOutgoingRequests({ traceFetch, traceXHR, tracingOrigins, shouldCreateSpanForRequest });
    };
    BrowserTracing2.prototype._createRouteTransaction = function(context) {
      var _this = this;
      if (!this._getCurrentHub) {
        IS_DEBUG_BUILD5 && logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
        return void 0;
      }
      var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
      var parentContextFromHeader = context.op === "pageload" ? getHeaderContext() : void 0;
      var expandedContext = __assign6(__assign6(__assign6({}, context), parentContextFromHeader), { trimEnd: true });
      var modifiedContext = typeof beforeNavigate === "function" ? beforeNavigate(expandedContext) : expandedContext;
      var finalContext = modifiedContext === void 0 ? __assign6(__assign6({}, expandedContext), { sampled: false }) : modifiedContext;
      if (finalContext.sampled === false) {
        IS_DEBUG_BUILD5 && logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
      }
      IS_DEBUG_BUILD5 && logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
      var hub = this._getCurrentHub();
      var location = getGlobalObject().location;
      var idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, true, { location });
      idleTransaction.registerBeforeFinishCallback(function(transaction, endTimestamp) {
        _this._metrics.addPerformanceEntries(transaction);
        adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);
      });
      idleTransaction.setTag("idleTimeout", this._configuredIdleTimeout);
      return idleTransaction;
    };
    BrowserTracing2.id = "BrowserTracing";
    return BrowserTracing2;
  }();
  function getHeaderContext() {
    var header = getMetaContent("sentry-trace");
    if (header) {
      return extractTraceparentData(header);
    }
    return void 0;
  }
  function getMetaContent(metaName) {
    var el = getGlobalObject().document.querySelector("meta[name=" + metaName + "]");
    return el ? el.getAttribute("content") : null;
  }
  function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
    var diff = endTimestamp - transaction.startTimestamp;
    var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
    if (isOutdatedTransaction) {
      transaction.setStatus("deadline_exceeded");
      transaction.setTag("maxTransactionDurationExceeded", "true");
    }
  }

  // ../node_modules/@sentry/tracing/esm/index.js
  addExtensionMethods();

  // ../node_modules/@sentry/integrations/esm/captureconsole.js
  var global11 = getGlobalObject();
  var CaptureConsole = function() {
    function CaptureConsole2(options) {
      if (options === void 0) {
        options = {};
      }
      this.name = CaptureConsole2.id;
      this._levels = CONSOLE_LEVELS;
      if (options.levels) {
        this._levels = options.levels;
      }
    }
    CaptureConsole2.prototype.setupOnce = function(_, getCurrentHub2) {
      if (!("console" in global11)) {
        return;
      }
      this._levels.forEach(function(level) {
        if (!(level in global11.console)) {
          return;
        }
        fill(global11.console, level, function(originalConsoleMethod) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var hub = getCurrentHub2();
            if (hub.getIntegration(CaptureConsole2)) {
              hub.withScope(function(scope) {
                scope.setLevel(severityFromString(level));
                scope.setExtra("arguments", args);
                scope.addEventProcessor(function(event) {
                  event.logger = "console";
                  return event;
                });
                var message = safeJoin(args, " ");
                if (level === "assert") {
                  if (args[0] === false) {
                    message = "Assertion failed: " + (safeJoin(args.slice(1), " ") || "console.assert");
                    scope.setExtra("arguments", args.slice(1));
                    hub.captureMessage(message);
                  }
                } else if (level === "error" && args[0] instanceof Error) {
                  hub.captureException(args[0]);
                } else {
                  hub.captureMessage(message);
                }
              });
            }
            if (originalConsoleMethod) {
              originalConsoleMethod.apply(global11.console, args);
            }
          };
        });
      });
    };
    CaptureConsole2.id = "CaptureConsole";
    return CaptureConsole2;
  }();

  // src/systems/sentry-client/src/FbwAircraftSentryClient.ts
  var SENTRY_CONSENT_KEY = "SENTRY_CONSENT";
  var FbwAircraftSentryClient = class {
    onInstrumentLoaded(config4) {
      if (!config4.dsn) {
        console.log("[SentryClient] No DSN defined. Will not try to initialize");
        return Promise.resolve(false);
      }
      this.runClientSubscription(config4);
      if (config4.root) {
        console.log("[SentryClient] Starting as root client");
        return this.runRootClientFlow(config4);
      }
      return Promise.resolve(false);
    }
    async runClientSubscription(config4) {
      NXDataStore.getAndSubscribe(SENTRY_CONSENT_KEY, (key, value) => {
        if (value === "Given" /* Given */) {
          console.log("[SentryClient] Synchronised consent state is Given. Initializing sentry");
          FbwAircraftSentryClient.attemptInitializeSentry(config4);
        }
        if (value === "Refused" /* Refused */) {
          console.log("[SentryClient] Synchronised consent state is Refused. Shutting down the client");
          FbwAircraftSentryClient.closeSentry();
        }
      });
    }
    async runRootClientFlow(config4) {
      const consentValue = NXDataStore.get(SENTRY_CONSENT_KEY, "Unknown" /* Unknown */);
      switch (consentValue) {
        case "Given" /* Given */:
          console.log("[SentryClient] Consent state is Given. Initializing sentry");
          return FbwAircraftSentryClient.attemptInitializeSentry(config4);
        case "Unknown" /* Unknown */:
          console.log("[SentryClient] Consent state is Unknown. Asking for consent");
          return new Promise((resolve, reject) => {
            const instrument2 = document.querySelector("vcockpit-panel > *");
            if (instrument2) {
              instrument2.addEventListener("FlightStart", () => {
                setTimeout(() => {
                  resolve(FbwAircraftSentryClient.requestConsent().then((didConsent) => {
                    if (didConsent) {
                      NXDataStore.set(SENTRY_CONSENT_KEY, "Given" /* Given */);
                      console.log("[SentryClient] User requested consent state Given. Initializing sentry");
                      return FbwAircraftSentryClient.attemptInitializeSentry(config4);
                    }
                    NXDataStore.set(SENTRY_CONSENT_KEY, "Refused" /* Refused */);
                    console.log("[SentryClient] User requested consent state Refused. Doing nothing");
                    return false;
                  }).catch(() => false));
                }, 1e3);
              });
            } else {
              reject(new Error("[SentryClient] Could not find an instrument element to hook onto"));
            }
          });
        case "Refused" /* Refused */:
          console.log("[SentryClient] Consent state is Refused. Doing nothing");
          break;
        default:
          console.log("[SentryClient] Consent state is corrupted. Doing nothing");
          break;
      }
      return false;
    }
    static async requestConsent() {
      const popup = new PopUpDialog();
      return new Promise((resolve) => {
        popup.showPopUp(
          "A32NX - ERROR REPORTING",
          "Are you willing to help FlyByWire Simulations by enabling anonymous reporting of errors that may occur in the future? This is 100% optional and we will never collect your personal data, but it will help us diagnose issues quickly.",
          "normal",
          () => resolve(true),
          () => resolve(false)
        );
      });
    }
    static async attemptInitializeSentry(config4) {
      return FbwAircraftSentryClient.initializeSentry(config4).then(() => true).catch((e) => {
        console.error("[SentryClient] Error while initializing sentry");
        console.error(e);
        return false;
      });
    }
    static closeSentry() {
      close();
      console.log("[SentryClient] Sentry closed");
    }
    static async initializeSentry(config4) {
      let release = "unknown";
      try {
        const manifest = await (await fetch(`/VFS/${config4.buildInfoFilePrefix}_build_info.json`)).json();
        release = manifest.pretty_release_name;
      } catch (e) {
        console.warn(`[SentryClient] Could not load ${config4.buildInfoFilePrefix}_build_info.json. Using 'unknown' as release name`);
      }
      const integrations = [new CaptureConsole({ levels: ["error"] })];
      if (config4.enableTracing) {
        integrations.push(new BrowserTracing());
      }
      init({
        dsn: config4.dsn,
        release,
        integrations,
        sampleRate: 0.1
      });
      console.log("[SentryClient] Sentry initialized");
      NXDataStore.getAndSubscribe("A32NX_SENTRY_SESSION_ID", (_, value) => {
        if (value) {
          setTag("session_id", value);
          console.log('[SentryClient] Sentry tag "session_id" set to', value);
        }
      });
    }
  };

  // src/systems/instruments/src/Common/index.tsx
  var render = (Slot, enableSentryTracing = false, sentryRootClient = false) => {
    const doRender = () => {
      new FbwAircraftSentryClient().onInstrumentLoaded({
        dsn: "https://abd67c4440a644b3aaaf44838e565bea@o1135700.ingest.sentry.io/6185355",
        buildInfoFilePrefix: "a32nx",
        enableTracing: enableSentryTracing,
        root: sentryRootClient
      });
      import_react_dom.default.render(Slot, getRenderTarget());
    };
    if (false) {
      window.addEventListener("AceInitialized", () => doRender());
    } else {
      doRender();
    }
  };
  var debouncedTimeDelta = (absTimeSeconds, prevTimeSeconds) => {
    const diff = Math.max(absTimeSeconds - prevTimeSeconds, 0);
    return diff < 60 ? diff : 0;
  };

  // src/systems/instruments/src/ND/pages/ArcMode.tsx
  var import_react16 = __toESM(require_react());

  // src/systems/instruments/src/ND/elements/TopMessages.tsx
  var import_react7 = __toESM(require_react());
  var GridTrack = ({ gridTrack }) => {
    var _a;
    return /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, /* @__PURE__ */ import_react7.default.createElement("rect", { x: 0, width: 94, y: -20, height: 23, className: "White", strokeWidth: 1.5 }), /* @__PURE__ */ import_react7.default.createElement("text", { x: 45, fontSize: 22, textAnchor: "middle" }, /* @__PURE__ */ import_react7.default.createElement("tspan", { className: "Green" }, "\u25C7", (_a = gridTrack == null ? void 0 : gridTrack.toFixed(0).padStart(3, "0")) != null ? _a : ""), /* @__PURE__ */ import_react7.default.createElement("tspan", { className: "Cyan" }, /* @__PURE__ */ import_react7.default.createElement("tspan", { dx: "-5", dy: "8", fontSize: 28 }, "\xB0"), /* @__PURE__ */ import_react7.default.createElement("tspan", { dy: "-8" }, "G"))));
  };
  var TrueFlag = ({ xOffset = 0, box }) => /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, /* @__PURE__ */ import_react7.default.createElement("rect", { x: -30 + xOffset, width: 68, y: -20, height: 23, className: "Cyan", strokeWidth: 1.5, visibility: box ? "inherit" : "hidden" }), /* @__PURE__ */ import_react7.default.createElement("text", { x: 4 + xOffset, fontSize: 22, className: "Cyan", textAnchor: "middle" }, "TRUE"));
  var TopMessages = ({ side, ppos, trueTrack, trueRef }) => {
    const [apprMsg0] = useSimVar(`L:A32NX_EFIS_${side}_APPR_MSG_0`, "number", 5e3);
    const [apprMsg1] = useSimVar(`L:A32NX_EFIS_${side}_APPR_MSG_1`, "number", 5e3);
    const [apprMsg, setApprMsg] = (0, import_react7.useState)(null);
    const [gridTrack, setGridTrack] = (0, import_react7.useState)(null);
    (0, import_react7.useEffect)(() => {
      if (trueTrack.isNormalOperation() && Math.abs(ppos.lat) > 65) {
        setGridTrack(Math.round(Avionics.Utils.clampAngle(trueTrack.value - Math.sign(ppos.lat) * ppos.long)) % 360);
      } else {
        setGridTrack(null);
      }
    }, [ppos.lat.toFixed(0), ppos.long.toFixed(1), trueTrack.value.toFixed(0), trueTrack.ssm]);
    (0, import_react7.useEffect)(() => {
      const msg = SimVarString.unpack([apprMsg0, apprMsg1]);
      setApprMsg(msg.length > 0 ? msg : null);
    }, [apprMsg0, apprMsg1]);
    return /* @__PURE__ */ import_react7.default.createElement(import_react7.default.Fragment, null, /* @__PURE__ */ import_react7.default.createElement(Layer, { x: 384, y: 28, visibility: apprMsg === null ? "hidden" : "visible" }, /* @__PURE__ */ import_react7.default.createElement("text", { x: 0, y: 0, fontSize: 25, className: "Green", textAnchor: "middle" }, apprMsg != null ? apprMsg : "")), /* @__PURE__ */ import_react7.default.createElement(Layer, { x: 384, y: apprMsg === null ? 36 : 56, visibility: trueRef ? "visible" : "hidden" }, /* @__PURE__ */ import_react7.default.createElement(TrueFlag, { xOffset: apprMsg === null && gridTrack !== null ? -54 : 0, box: apprMsg === null }), /* @__PURE__ */ import_react7.default.createElement(Layer, { x: 0, y: 0, visibility: apprMsg === null && gridTrack !== null ? "inherit" : "hidden" }, /* @__PURE__ */ import_react7.default.createElement(GridTrack, { gridTrack: gridTrack != null ? gridTrack : 0 }))));
  };

  // src/systems/instruments/src/ND/elements/FlightPlan.tsx
  var import_react9 = __toESM(require_react());

  // src/systems/instruments/src/ND/elements/FlightPlanVectors.tsx
  var import_react8 = __toESM(require_react());
  var FlightPlanVectors = (0, import_react8.memo)(({ x, y, mapParams, side, group }) => {
    const [vectors, setVectors] = (0, import_react8.useState)([]);
    const lineStyle = vectorsGroupLineStyle(group);
    useFlowSyncEvent(`A32NX_EFIS_VECTORS_${side}_${EfisVectorsGroup[group]}`, (0, import_react8.useCallback)((_topic, data) => {
      if (data) {
        setVectors(data);
      } else if (LnavConfig.DEBUG_PATH_DRAWING) {
        console.warn(`[ND/Vectors] Received falsy vectors on event '${EfisVectorsGroup[group]}'.`);
      }
    }, [group]));
    return /* @__PURE__ */ import_react8.default.createElement(Layer, { x, y }, vectors.filter((vector) => isVectorValid(vector)).map((vector, index) => {
      var _a;
      switch (vector.type) {
        case 0 /* Line */:
          const [sx, sy] = mapParams.coordinatesToXYy(vector.startPoint);
          const [ex, ey] = mapParams.coordinatesToXYy(vector.endPoint);
          return /* @__PURE__ */ import_react8.default.createElement(
            "line",
            __spreadProps(__spreadValues({}, lineStyle), {
              fill: "none",
              strokeWidth: 2,
              x1: sx,
              y1: sy,
              x2: ex,
              y2: ey
            })
          );
        case 1 /* Arc */:
          const [ix, iy] = mapParams.coordinatesToXYy(vector.startPoint);
          const [fx, fy] = mapParams.coordinatesToXYy(vector.endPoint);
          const radius = Avionics.Utils.computeDistance(vector.centrePoint, vector.endPoint) * mapParams.nmToPx;
          return /* @__PURE__ */ import_react8.default.createElement(
            "path",
            __spreadProps(__spreadValues({}, lineStyle), {
              fill: "none",
              strokeWidth: 2,
              d: `M ${ix} ${iy} A ${radius} ${radius} 0 ${Math.abs(vector.sweepAngle) > 180 ? 1 : 0} ${vector.sweepAngle > 0 ? 1 : 0} ${fx} ${fy}`
            })
          );
        case 2 /* DebugPoint */:
          const [x2, y2] = mapParams.coordinatesToXYy(vector.startPoint);
          const offset = index % 2 === 0;
          const colour = DebugPointColour[(_a = vector.colour) != null ? _a : 3 /* Cyan */];
          return /* @__PURE__ */ import_react8.default.createElement(import_react8.default.Fragment, null, /* @__PURE__ */ import_react8.default.createElement(
            "path",
            {
              stroke: colour,
              fill: "none",
              strokeWidth: 1.5,
              d: `M ${x2} ${y2} h -7 h 14 m -7 -7 v 14`
            }
          ), /* @__PURE__ */ import_react8.default.createElement("text", { x: x2 + (offset ? -15 : 15), y: y2 + 5, fontSize: 13, textAnchor: offset ? "end" : "start", fill: colour }, vector.annotation));
        default:
          return null;
      }
    }));
  });
  function isVectorValid(vector) {
    if (!vector) {
      return false;
    }
    if (vector.type === null || vector.type === void 0) {
      return false;
    }
    switch (vector.type) {
      case 0 /* Line */:
        return !!vector.startPoint;
      case 1 /* Arc */:
        return !!vector.startPoint && !!vector.centrePoint && !!vector.endPoint;
      case 2 /* DebugPoint */:
        return !!vector.startPoint;
      default:
        return false;
    }
  }
  function vectorsGroupLineStyle(group) {
    switch (group) {
      case 0 /* ACTIVE */:
        return { stroke: "#0f0" };
      case 1 /* DASHED */:
      case 2 /* OFFSET */:
        return { stroke: "#0f0", strokeDasharray: "15 12" };
      case 3 /* TEMPORARY */:
        return { stroke: "#ff0", strokeDasharray: "15 12" };
      case 4 /* SECONDARY */:
        return { stroke: "#888" };
      case 5 /* SECONDARY_DASHED */:
        return { stroke: "#888", strokeDasharray: "15 12" };
      case 6 /* MISSED */:
        return { stroke: "#0ff" };
      case 7 /* ALTERNATE */:
        return { stroke: "#0ff", strokeDasharray: "15 12" };
      case 8 /* ACTIVE_EOSID */:
        return { stroke: "#ff0" };
      default:
        return { stroke: "#f00" };
    }
  }

  // src/systems/instruments/src/ND/elements/FlightPlan.tsx
  var FlightPlan2 = (0, import_react9.memo)(({ x = 0, y = 0, side, range: range2, symbols, mapParams }) => {
    if (!mapParams.valid) {
      return null;
    }
    return /* @__PURE__ */ import_react9.default.createElement(Layer, { x, y }, symbols.filter((symbol) => (symbol.type & 1024 /* Constraint */) > 0).map((symbol) => {
      const position = mapParams.coordinatesToXYy(symbol.location);
      return /* @__PURE__ */ import_react9.default.createElement(
        ConstraintMarker,
        {
          key: symbol.databaseId,
          x: Number(MathUtils.fastToFixed(position[0], 1)),
          y: Number(MathUtils.fastToFixed(position[1], 1)),
          type: symbol.type
        }
      );
    }), Object.keys(EfisVectorsGroup).filter((it) => !Number.isNaN(parseInt(it))).map((group) => /* @__PURE__ */ import_react9.default.createElement(
      FlightPlanVectors,
      {
        key: EfisVectorsGroup[group],
        x: 0,
        y: 0,
        mapParams,
        mapParamsVersion: mapParams.version,
        side,
        group: parseInt(group)
      }
    )), symbols.map((symbol) => {
      if (!symbol.location) {
        return false;
      }
      const position = mapParams.coordinatesToXYy(symbol.location);
      return /* @__PURE__ */ import_react9.default.createElement(
        SymbolMarker,
        {
          key: symbol.databaseId,
          ident: symbol.ident,
          x: Number(MathUtils.fastToFixed(position[0], 1)),
          y: Number(MathUtils.fastToFixed(position[1], 1)),
          type: symbol.type,
          length: symbol.length,
          direction: symbol.direction,
          constraints: symbol.constraints,
          radials: symbol.radials,
          radii: symbol.radii,
          mapParams,
          ndRange: range2
        }
      );
    }));
  });
  var VorMarker = ({ colour }) => /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: 15, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: 15, y1: 0, y2: 0, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: 15, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: 15, y1: 0, y2: 0, className: colour, strokeWidth: 2 }));
  var VorDmeMarker = ({ colour }) => /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("circle", { r: 7, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: -7, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: 15, y2: 7, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: -7, y1: 0, y2: 0, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 15, x2: 7, y1: 0, y2: 0, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("circle", { r: 7, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: -7, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: 15, y2: 7, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: -7, y1: 0, y2: 0, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 15, x2: 7, y1: 0, y2: 0, className: colour, strokeWidth: 2 }));
  var DmeMarker = ({ colour }) => /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("circle", { r: 7, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("circle", { r: 7, className: colour, strokeWidth: 2 }));
  var NdbMarker = ({ colour }) => /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M-10,10 L0,-10 L10,10 L-10,10", className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("path", { d: "M-10,10 L0,-10 L10,10 L-10,10", className: colour, strokeWidth: 2 }));
  var WaypointMarker = ({ colour }) => /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("rect", { x: -4.5, y: -4.5, width: 9, height: 9, className: "shadow", strokeWidth: 2.5, transform: "rotate(45 0 0)" }), /* @__PURE__ */ import_react9.default.createElement("rect", { x: -4.5, y: -4.5, width: 9, height: 9, className: colour, strokeWidth: 2, transform: "rotate(45 0 0)" }));
  var AirportMarker = ({ colour }) => /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: 15, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: 15, className: "shadow", strokeWidth: 2.5, transform: "rotate(45)" }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: 15, y1: 0, y2: 0, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: 15, y1: 0, y2: 0, className: "shadow", strokeWidth: 2.5, transform: "rotate(45)" }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: 15, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 0, x2: 0, y1: -15, y2: 15, className: colour, strokeWidth: 2, transform: "rotate(45)" }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: 15, y1: 0, y2: 0, className: colour, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -15, x2: 15, y1: 0, y2: 0, className: colour, strokeWidth: 2, transform: "rotate(45)" }));
  var RunwayIdent = ({ ident, rotation }) => {
    const airportIdent = ident.substring(0, 4);
    const runwayIdent = ident.substring(4);
    return /* @__PURE__ */ import_react9.default.createElement("g", { transform: `rotate(${-rotation} 40 -20)` }, /* @__PURE__ */ import_react9.default.createElement("text", { x: 40, y: -30, fontSize: 20, className: "shadow", textAnchor: "middle", alignmentBaseline: "central" }, airportIdent), /* @__PURE__ */ import_react9.default.createElement("text", { x: 40, y: -10, fontSize: 20, className: "shadow", textAnchor: "middle", alignmentBaseline: "central" }, runwayIdent.padEnd(4, "\xA0")));
  };
  var RunwayMarkerClose = (0, import_react9.memo)(({ ident, mapParams, direction, lengthPx }) => {
    useSimVar("PLANE HEADING DEGREES TRUE", "number");
    const rotation = mapParams.rotation(direction);
    return /* @__PURE__ */ import_react9.default.createElement("g", { transform: `rotate(${rotation})`, className: "White" }, /* @__PURE__ */ import_react9.default.createElement("line", { x1: -5, x2: -5, y1: 0, y2: -lengthPx, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 5, x2: 5, y1: 0, y2: -lengthPx, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: -5, x2: -5, y1: 0, y2: -lengthPx, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: 5, x2: 5, y1: 0, y2: -lengthPx, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement(RunwayIdent, { ident, rotation }));
  });
  var RunwayMarkerFar = (0, import_react9.memo)(({ ident, mapParams, direction }) => {
    useSimVar("PLANE HEADING DEGREES TRUE", "number");
    const rotation = mapParams.rotation(direction);
    return /* @__PURE__ */ import_react9.default.createElement("g", { transform: `rotate(${rotation})`, className: "White" }, /* @__PURE__ */ import_react9.default.createElement("rect", { x: -5, y: -12.5, width: 10, height: 25, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("rect", { x: -5, y: -12.5, width: 10, height: 25, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement(RunwayIdent, { ident, rotation }));
  });
  var CourseReversalMarker = (0, import_react9.memo)(({ mapParams, left, direction }) => {
    useSimVar("PLANE HEADING DEGREES TRUE", "number");
    const rotation = mapParams.rotation(direction);
    const arcEnd = left ? -42 : 42;
    return /* @__PURE__ */ import_react9.default.createElement("g", { transform: `rotate(${rotation})`, className: "White" }, /* @__PURE__ */ import_react9.default.createElement("path", { d: `M0,0 a21,21 0 0 ${left ? 0 : 1} ${arcEnd},0`, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: arcEnd, x2: arcEnd - 4, y1: 0, y2: -4, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: arcEnd, x2: arcEnd + 4, y1: 0, y2: -4, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("path", { d: `M0,0 a21,21 0 0 ${left ? 0 : 1} ${arcEnd},0`, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: arcEnd, x2: arcEnd - 4, y1: 0, y2: -4, strokeWidth: 2 }), /* @__PURE__ */ import_react9.default.createElement("line", { x1: arcEnd, x2: arcEnd + 4, y1: 0, y2: -4, strokeWidth: 2 }));
  });
  var SymbolMarker = (0, import_react9.memo)(({ ident, x, y, type, constraints, length, direction, radials, radii, mapParams, ndRange }) => {
    let colour = "White";
    let shadow = true;
    if (type & 32 /* Runway */) {
      colour = "White";
    } else if (type & 128 /* ActiveLegTermination */) {
      colour = "White";
    } else if (type & 64 /* Tuned */) {
      colour = "Cyan";
    } else if (type & (4096 /* FlightPlan */ | 2048 /* FixInfo */)) {
      colour = "Green";
    } else if (type & 256 /* EfisOption */) {
      colour = "Magenta";
      shadow = false;
    }
    const elements = [];
    if (type & 2048 /* FixInfo */) {
      if (radii !== void 0) {
        for (const radius of radii) {
          const radiusPx = radius * mapParams.nmToPx;
          elements.push(
            /* @__PURE__ */ import_react9.default.createElement(
              "path",
              {
                d: `m-${radiusPx},0 a${radiusPx},${radiusPx} 0 1,0 ${radiusPx * 2},0 a${radiusPx},${radiusPx} 0 1,0 -${radiusPx * 2},0`,
                strokeWidth: 2.5,
                className: "shadow",
                strokeDasharray: "15 10"
              }
            )
          );
          elements.push(
            /* @__PURE__ */ import_react9.default.createElement(
              "path",
              {
                d: `m-${radiusPx},0 a${radiusPx},${radiusPx} 0 1,0 ${radiusPx * 2},0 a${radiusPx},${radiusPx} 0 1,0 -${radiusPx * 2},0`,
                strokeWidth: 2,
                className: "Cyan",
                strokeDasharray: "15 10"
              }
            )
          );
        }
      }
      if (radials !== void 0) {
        for (const bearing of radials) {
          const rotation = mapParams.rotation(bearing) * Math.PI / 180;
          const x2 = Math.sin(rotation) * 9e3;
          const y2 = -Math.cos(rotation) * 9e3;
          elements.push(/* @__PURE__ */ import_react9.default.createElement("line", { x2, y2, strokeWidth: 2.5, className: "shadow", strokeDasharray: "15 10" }));
          elements.push(/* @__PURE__ */ import_react9.default.createElement("line", { x2, y2, strokeWidth: 2, className: "Cyan", strokeDasharray: "15 10" }));
        }
      }
    }
    if (constraints) {
      let constraintY = 17;
      elements.push(...constraints.map((t) => /* @__PURE__ */ import_react9.default.createElement("text", { x: 13.5, y: constraintY += 17, className: "shadow Magenta", fontSize: 20 }, t)));
    }
    if (type & (131072 /* CourseReversalLeft */ | 262144 /* CourseReversalRight */)) {
      elements.push(/* @__PURE__ */ import_react9.default.createElement(CourseReversalMarker, { mapParams, left: (type & 131072 /* CourseReversalLeft */) > 0, direction }));
    }
    let showIdent = false;
    const identYOffset = 0;
    if (type & 2 /* VorDme */) {
      elements.push(/* @__PURE__ */ import_react9.default.createElement(VorDmeMarker, { colour }));
      showIdent = true;
    } else if (type & 1 /* Vor */) {
      elements.push(/* @__PURE__ */ import_react9.default.createElement(VorMarker, { colour }));
      showIdent = true;
    } else if (type & 512 /* Dme */) {
      elements.push(/* @__PURE__ */ import_react9.default.createElement(DmeMarker, { colour }));
      showIdent = true;
    } else if (type & 4 /* Ndb */) {
      elements.push(/* @__PURE__ */ import_react9.default.createElement(NdbMarker, { colour }));
      showIdent = true;
    } else if (type & 32 /* Runway */) {
      if (ndRange > 80) {
        elements.push(/* @__PURE__ */ import_react9.default.createElement(
          RunwayMarkerFar,
          {
            ident,
            mapParams,
            direction
          }
        ));
      } else {
        elements.push(/* @__PURE__ */ import_react9.default.createElement(
          RunwayMarkerClose,
          {
            ident,
            mapParams,
            direction,
            lengthPx: mapParams.nmToPx * length
          }
        ));
      }
    } else if (type & 16 /* Airport */) {
      showIdent = true;
      elements.push(/* @__PURE__ */ import_react9.default.createElement(AirportMarker, { colour }));
    } else if (type & (8 /* Waypoint */ | 4096 /* FlightPlan */ | 2048 /* FixInfo */)) {
      showIdent = true;
      elements.push(/* @__PURE__ */ import_react9.default.createElement(WaypointMarker, { colour }));
    } else if (type & 1048576 /* PwpTopOfDescent */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M 0 0 h 22.2 l 19.8 16.2 m -6 0 h 6 v -6", strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("path", { d: "M 0 0 h 22.2 l 19.8 16.2 m -6 0 h 6 v -6", strokeWidth: 1.5, className: typeFlagToColor(type) }))
      );
    } else if (type & 134217728 /* PwpCdaFlap1 */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 13, strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 13, strokeWidth: 1.5, className: typeFlagToColor(type) }), /* @__PURE__ */ import_react9.default.createElement("text", { x: 2.5, y: 2, className: `shadow ${typeFlagToColor(type)}`, textAnchor: "middle", dominantBaseline: "middle", fontSize: 21 }, "1"))
      );
    } else if (type & 268435456 /* PwpCdaFlap2 */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 13, strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 13, strokeWidth: 1.5, className: typeFlagToColor(type) }), /* @__PURE__ */ import_react9.default.createElement("text", { x: 1, y: 2, className: `shadow ${typeFlagToColor(type)}`, textAnchor: "middle", dominantBaseline: "middle", fontSize: 21 }, "2"))
      );
    } else if (type & 524288 /* PwpDecel */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 13, strokeWidth: 1.6, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 13, strokeWidth: 1.5, className: typeFlagToColor(type) }), /* @__PURE__ */ import_react9.default.createElement("text", { x: 1.5, y: 2, className: `${typeFlagToColor(type)} shadow`, strokeWidth: 1, textAnchor: "middle", dominantBaseline: "middle", fontSize: 22 }, "D"))
      );
    } else if (type & 4194304 /* PwpClimbLevelOff */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M -42 16.2 l 19.8 -16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2", strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("path", { d: "M -42 16.2 l 19.8 -16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2", strokeWidth: 1.5, className: typeFlagToColor(type) }))
      );
    } else if (type & 8388608 /* PwpDescentLevelOff */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M -42 -16.2 l 19.8 16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2", strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("path", { d: "M -42 -16.2 l 19.8 16.2 h 22.2 m -4.2 -4.2 l 4.2 4.2 l -4.2 4.2", strokeWidth: 1.5, className: typeFlagToColor(type) }))
      );
    } else if (type & 16777216 /* PwpStartOfClimb */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M 0 0 h 22.2 l 19.8 -16.2 m -6 0 h 6 v 6", strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("path", { d: "M 0 0 h 22.2 l 19.8 -16.2 m -6 0 h 6 v 6", strokeWidth: 1.5, className: typeFlagToColor(type) }))
      );
    } else if (type & 33554432 /* PwpInterceptProfile */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M -38, 0 l 14, -17 v 34 l 14 -17 h10 m -5 -5 l 5 5 l -5 5", strokeWidth: 1.8, className: "shadow" }), /* @__PURE__ */ import_react9.default.createElement("path", { d: "M -38, 0 l 14, -17 v 34 l 14 -17 h10 m -5 -5 l 5 5 l -5 5", strokeWidth: 1.5, className: typeFlagToColor(type) }))
      );
    } else if (type & 67108864 /* PwpTimeMarker */) {
      colour = "Green";
      showIdent = true;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement(import_react9.default.Fragment, null, /* @__PURE__ */ import_react9.default.createElement("circle", { r: 12, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("circle", { r: 12, className: "Green", strokeWidth: 2 }))
      );
    } else if (type & 2097152 /* PwpSpeedChange */) {
      showIdent = false;
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement("circle", { cx: 0, cy: 0, r: 8, className: `${typeFlagToColor(type)} Fill` })
      );
    }
    if (showIdent) {
      elements.push(
        /* @__PURE__ */ import_react9.default.createElement("text", { x: 13.5, y: 17 + identYOffset, fontSize: 20, className: `${colour}${shadow ? " shadow" : ""}` }, ident)
      );
    }
    return /* @__PURE__ */ import_react9.default.createElement(Layer, { x, y }, elements);
  });
  var ConstraintMarker = (0, import_react9.memo)(({ x, y, type }) => /* @__PURE__ */ import_react9.default.createElement(Layer, { x, y }, /* @__PURE__ */ import_react9.default.createElement("circle", { r: 14, className: "shadow", strokeWidth: 2.5 }), /* @__PURE__ */ import_react9.default.createElement("circle", { r: 14, className: typeFlagToColor(type), strokeWidth: 2 })));
  var typeFlagToColor = (typeFlag) => {
    if (typeFlag & 536870912 /* CyanColor */) {
      return "Cyan";
    }
    if (typeFlag & -2147483648 /* MagentaColor */) {
      return "Magenta";
    }
    if (typeFlag & 1073741824 /* AmberColor */) {
      return "Amber";
    }
    return "White";
  };

  // src/systems/instruments/src/ND/utils/MapParameters.ts
  var MapParameters = class {
    constructor() {
      __publicField(this, "centerCoordinates");
      __publicField(this, "mapUpTrueDeg");
      __publicField(this, "nmToPx");
      __publicField(this, "mToPx");
      __publicField(this, "nmRadius");
      __publicField(this, "centerYBias");
      __publicField(this, "version", 0);
      __publicField(this, "valid", false);
    }
    compute(centerCoordinates, centerYBias, nmRadius, pxRadius, mapUpTrueDeg) {
      this.version++;
      this.valid = Number.isFinite(centerCoordinates.lat) && Number.isFinite(centerCoordinates.long) && Number.isFinite(pxRadius) && Number.isFinite(mapUpTrueDeg);
      this.mapUpTrueDeg = mapUpTrueDeg;
      this.centerCoordinates = centerCoordinates;
      this.centerYBias = centerYBias;
      this.nmToPx = pxRadius / nmRadius;
      this.mToPx = this.nmToPx / 1852;
      this.nmRadius = nmRadius;
    }
    coordinatesToXYy(coordinates) {
      const bearing = Avionics.Utils.computeGreatCircleHeading(this.centerCoordinates, coordinates) - this.mapUpTrueDeg - 90;
      const distance = Avionics.Utils.computeGreatCircleDistance(this.centerCoordinates, coordinates);
      const xNm = distance * Math.cos(bearing * Math.PI / 180);
      const yNm = distance * Math.sin(bearing * Math.PI / 180);
      return [
        xNm * this.nmToPx,
        yNm * this.nmToPx + this.centerYBias
      ];
    }
    rotation(trueBearing) {
      return trueBearing - this.mapUpTrueDeg;
    }
  };

  // src/systems/instruments/src/ND/elements/RadioNeedles.tsx
  var import_react10 = __toESM(require_react());
  var AdfNeedle = ({ index, displayMode, centreHeight }) => {
    const [relativeBearing] = useSimVar(`ADF RADIAL:${index}`, "degrees");
    const [available] = useSimVar(`ADF SIGNAL:${index}`, "number");
    let paths;
    switch (displayMode) {
      case 3 /* ARC */:
        paths = [
          "M384,251 L384,128 M370,179 L384,155 L398,179 M384,1112 L384,989 M370,1085 L384,1061 L398,1085",
          "M370,251 L370,219 L384,195 L398,219 L398,251 M384,195 L384,128 M384,1112 L384,1023 M370,989 L370,1040 L384,1023 L398,1040 L398,989"
        ];
        break;
      case 0 /* ROSE_ILS */:
      case 1 /* ROSE_VOR */:
      case 2 /* ROSE_NAV */:
        paths = [
          "M384,257 L384,134 M370,185 L384,161 L398,185 M384,634 L384,511 M370,607 L384,583 L398,607",
          "M370,257 L370,225 L384,201 L398,225 L398,257 M384,201 L384,134 M384,634 L384,545 M370,511 L370,562 L384,545 L398,562 L398,511"
        ];
        break;
      default:
        console.error(`RadioNeedle: invalid display mode: ${displayMode}`);
        return null;
    }
    return available && /* @__PURE__ */ import_react10.default.createElement("g", { transform: `rotate(${relativeBearing} 384 ${centreHeight})` }, /* @__PURE__ */ import_react10.default.createElement(
      "path",
      {
        d: paths[index - 1],
        strokeWidth: 3.7,
        className: "rounded shadow"
      }
    ), /* @__PURE__ */ import_react10.default.createElement(
      "path",
      {
        d: paths[index - 1],
        strokeWidth: 3.2,
        className: "rounded Green"
      }
    ));
  };
  var VorNeedle = ({ index, displayMode, centreHeight, trueRef }) => {
    const [relativeBearing] = useSimVar(`NAV RELATIVE BEARING TO STATION:${index}`, "degrees");
    const [available] = useSimVar(`NAV HAS NAV:${index}`, "number");
    const [isLoc] = useSimVar(`NAV HAS LOCALIZER:${index}`, "number");
    const [stationDeclination] = useSimVar(`NAV MAGVAR:${index}`, "degrees");
    const [stationLocation] = useSimVar(`NAV VOR LATLONALT:${index}`, "latlonalt");
    const [stationRefTrue, setStationRefTrue] = (0, import_react10.useState)(false);
    (0, import_react10.useEffect)(() => {
      setStationRefTrue(stationLocation.lat > 75 && stationDeclination < Number.EPSILON);
    }, [stationDeclination, stationLocation.lat]);
    let paths;
    switch (displayMode) {
      case 3 /* ARC */:
        paths = [
          "M384,251 L384,179 M384,128 L384,155 L370,179 L398,179 L384,155 M384,1112 L384,1085 M384,989 L384,1061 L370,1085 L398,1085 L384,1061",
          "M377,251 L377,219 L370,219 L384,195 L398,219 L391,219 L391,251 M384,195 L384,128 M384,1112 L384,1045 M377,989 L377,1045 L391,1045 L391,989"
        ];
        break;
      case 0 /* ROSE_ILS */:
      case 1 /* ROSE_VOR */:
      case 2 /* ROSE_NAV */:
        paths = [
          "M384,257 L384,185 M384,134 L384,161 L370,185 L398,185 L384,161 M384,634 L384,607 M384,511 L384,583 L370,607 L398,607 L384,583",
          "M377,257 L377,225 L370,225 L384,201 L398,225 L391,225 L391,256 M384,201 L384,134 M384,634 L384,567 M377,511 L377,567 L391,567 L391,511"
        ];
        break;
      default:
        console.error(`RadioNeedle: invalid display mode: ${displayMode}`);
        return null;
    }
    return available && !isLoc && /* @__PURE__ */ import_react10.default.createElement("g", { transform: `rotate(${relativeBearing} 384 ${centreHeight})` }, /* @__PURE__ */ import_react10.default.createElement(
      "path",
      {
        d: paths[index - 1],
        strokeWidth: 3.7,
        className: "rounded shadow"
      }
    ), /* @__PURE__ */ import_react10.default.createElement(
      "path",
      {
        d: paths[index - 1],
        strokeWidth: 3.2,
        className: `rounded ${!!trueRef !== stationRefTrue ? "Magenta" : "White"}`
      }
    ));
  };
  var RadioNeedle = ({ index, side, displayMode, centreHeight, trueRef }) => {
    const [mode] = useSimVar(`L:A32NX_EFIS_${side}_NAVAID_${index}_MODE`, "enum");
    switch (mode) {
      case 1 /* ADF */:
        return /* @__PURE__ */ import_react10.default.createElement(AdfNeedle, { index, displayMode, centreHeight, trueRef });
      case 2 /* VOR */:
        return /* @__PURE__ */ import_react10.default.createElement(VorNeedle, { index, displayMode, centreHeight, trueRef });
      case 0 /* Off */:
      default:
        return null;
    }
  };

  // src/systems/instruments/src/ND/elements/ToWaypointIndicator.tsx
  var import_react11 = __toESM(require_react());
  var ToWaypointIndicator = (0, import_react11.memo)(({ side, trueRef }) => {
    const [ident, setIdent] = (0, import_react11.useState)(null);
    const [ident0] = useSimVar(`L:A32NX_EFIS_${side}_TO_WPT_IDENT_0`, "number", 500);
    const [ident1] = useSimVar(`L:A32NX_EFIS_${side}_TO_WPT_IDENT_1`, "number", 500);
    const [bearing] = useSimVar(`L:A32NX_EFIS_${side}_TO_WPT_BEARING`, "Degrees");
    const [trueBearing] = useSimVar(`L:A32NX_EFIS_${side}_TO_WPT_TRUE_BEARING`, "Degrees");
    const [distance] = useSimVar(`L:A32NX_EFIS_${side}_TO_WPT_DISTANCE`, "Number");
    const [eta] = useSimVar(`L:A32NX_EFIS_${side}_TO_WPT_ETA`, "Seconds");
    (0, import_react11.useEffect)(() => {
      setIdent(SimVarString.unpack([ident0, ident1]));
    }, [ident0, ident1]);
    let distanceFixed;
    let distanceIntegralPart;
    let distanceDecimalPart;
    if (!distance) {
      distanceFixed = "";
      distanceIntegralPart = "";
      distanceDecimalPart = "";
    } else if (distance < 20) {
      distanceFixed = distance.toFixed(1);
      [distanceIntegralPart, distanceDecimalPart] = distanceFixed.split(".");
    } else {
      distanceFixed = Math.round(Math.min(9999, distance));
    }
    const hh = Math.floor(eta / 3600);
    const mm = Math.floor(eta % 3600 / 60);
    const utc = `${hh.toString().padStart(2, "0")}:${mm.toString().padStart(2, "0")}`;
    return /* @__PURE__ */ import_react11.default.createElement(Layer, { x: 690, y: 28 }, ident && /* @__PURE__ */ import_react11.default.createElement("text", { x: -9, y: 0, fontSize: 25, className: "White", textAnchor: "end" }, ident), bearing && bearing !== -1 && Number.isFinite(bearing) && /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, /* @__PURE__ */ import_react11.default.createElement("text", { x: 54, y: 0, fontSize: 25, className: "Green", textAnchor: "end" }, Math.round(trueRef ? trueBearing : bearing).toString().padStart(3, "0")), /* @__PURE__ */ import_react11.default.createElement("text", { x: 73, y: trueRef ? -3 : 2, fontSize: trueRef ? 21 : 25, className: "Cyan", textAnchor: "end" }, trueRef ? "T" : "\xB0")), distance && distance !== -1 && Number.isFinite(distance) && /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, distance < 20 ? /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, /* @__PURE__ */ import_react11.default.createElement("text", { x: 8, y: 30, fontSize: 24, className: "Green", textAnchor: "end" }, distanceIntegralPart), /* @__PURE__ */ import_react11.default.createElement("text", { x: 8, y: 30, fontSize: 23, className: "Green", textAnchor: "start" }, "."), /* @__PURE__ */ import_react11.default.createElement("text", { x: 22, y: 30, fontSize: 19, className: "Green", textAnchor: "start" }, distanceDecimalPart)) : /* @__PURE__ */ import_react11.default.createElement(import_react11.default.Fragment, null, /* @__PURE__ */ import_react11.default.createElement("text", { x: 34, y: 30, fontSize: 24, className: "Green", textAnchor: "end" }, distanceFixed)), /* @__PURE__ */ import_react11.default.createElement("text", { x: 72, y: 30, fontSize: 18, className: "Cyan", textAnchor: "end" }, "NM")), eta !== -1 && utc && /* @__PURE__ */ import_react11.default.createElement("text", { x: 72, y: 62, fontSize: 25, className: "Green", textAnchor: "end" }, utc));
  });

  // src/systems/instruments/src/ND/elements/CrossTrack.tsx
  var import_react12 = __toESM(require_react());
  var CrossTrack = ({ x, y, isPlanMode, side }) => {
    const [crossTrackError] = useSimVar("L:A32NX_FG_CROSS_TRACK_ERROR", "nautical miles", 250);
    const [rnp] = useSimVar(`L:A32NX_FMGC_${side}_RNP`, "number");
    let crossTrackText = "";
    let crossTrackAnchor = "start";
    let crossTrackX = x;
    const crossTrackAbs = Math.min(99.9, Math.abs(crossTrackError));
    if (rnp > 0 && rnp < 0.305 && crossTrackAbs > 0.0195 && crossTrackAbs < 0.295) {
      crossTrackText = crossTrackAbs.toFixed(2);
    } else if (crossTrackAbs >= 0.1) {
      crossTrackText = crossTrackAbs.toFixed(1);
    }
    if (crossTrackText.length > 0) {
      if (crossTrackError < 0) {
        crossTrackText += "R";
        crossTrackAnchor = "start";
        crossTrackX = x + 34;
      } else {
        crossTrackText += "L";
        crossTrackAnchor = "end";
        crossTrackX = x - 38;
      }
    }
    return /* @__PURE__ */ import_react12.default.createElement("text", { x: isPlanMode ? x : crossTrackX, y, textAnchor: isPlanMode ? "start" : crossTrackAnchor, fontSize: 24, className: "shadow Green" }, crossTrackText);
  };

  // src/systems/instruments/src/ND/elements/TrackLine.tsx
  var import_react13 = __toESM(require_react());
  var TrackLine = (0, import_react13.memo)(({ x, y, heading, track, mapParams, groundSpeed, symbols, ndRange }) => {
    const rotate = MathUtils.diffAngle(heading, track);
    const [lastUpdateTime, setLastUpdateTime] = (0, import_react13.useState)(Date.now());
    (0, import_react13.useEffect)(() => {
      setLastUpdateTime(Date.now());
    }, [symbols]);
    return /* @__PURE__ */ import_react13.default.createElement("g", { transform: `rotate(${rotate} ${x} ${y})` }, /* @__PURE__ */ import_react13.default.createElement("line", { x1: 384, y1: 149, x2: x, y2: y, className: "rounded shadow", strokeWidth: 3 }), /* @__PURE__ */ import_react13.default.createElement("line", { x1: 384, y1: 149, x2: x, y2: y, className: "rounded Green", strokeWidth: 2.5 }), symbols.map((symbol) => {
      if (!symbol.distanceFromAirplane || symbol.location) {
        return false;
      }
      const dy = (symbol.distanceFromAirplane - groundSpeed * (Date.now() - lastUpdateTime) / 1e3 / 60 / 60) * mapParams.nmToPx;
      return /* @__PURE__ */ import_react13.default.createElement(SymbolMarker, { x, y: y - dy, type: symbol.type, mapParams, ident: symbol.ident, ndRange });
    }));
  });

  // src/systems/instruments/src/ND/elements/Traffic.tsx
  var import_react15 = __toESM(require_react());

  // src/systems/tcas/src/lib/TcasConstants.ts
  var REFRESH_RATE = 1e3;
  var TRACKING_MAX = 40;
  var DISPLAY_MAX = 8;
  var MEMORY_MAX = 200;
  var MIN_VS = -6e3;
  var MAX_VS = 6e3;
  var INHIBIT_CLB_RA = 39e3;
  var INHIBIT_INC_DES_RA_AGL = 1450;
  var INHIBIT_ALL_DES_RA_AGL = 1200;
  var INHIBIT_ALL_RA = 1e3;
  var REALLY_BIG_NUMBER = 1e6;
  var INITIAL_DELAY = 5;
  var FOLLOWUP_DELAY = 2.5;
  var INITIAL_ACCEL = 8.04;
  var FOLLOWUP_ACCEL = 10.62;
  var TA_EXPIRATION_DELAY = 4;
  var MIN_RA_DURATION = 5;
  var VOL_BOOST = 1.25;
  var CLOSURE_RATE_THRESH = -40;
  var THREAT = {
    [0 /* THREAT */]: [-2700, 2700],
    [1 /* ALL */]: [-2700, 2700],
    [2 /* ABOVE */]: [-2700, 9900],
    [3 /* BELOW */]: [-9900, 2700]
  };
  var SENSE = {
    3: [1e3, 2350],
    4: [2350, 5e3],
    5: [5e3, 1e4],
    6: [1e4, 2e4],
    7: [2e4, 47e3]
  };
  var RANGE = {
    forward: [60, 100],
    side: 30,
    back: 20,
    alt: 9900
  };
  var TAU = {
    1: [-1, -1],
    2: [20, -1],
    3: [25, 15],
    4: [30, 20],
    5: [40, 25],
    6: [45, 30],
    7: [48, 35],
    8: [48, 35]
  };
  var DMOD = {
    1: [-1, -1],
    2: [0.3, -1],
    3: [0.33, 0.2],
    4: [0.48, 0.35],
    5: [0.75, 0.55],
    6: [1, 0.8],
    7: [1.3, 1.1],
    8: [1.3, 1.1]
  };
  var ZTHR = {
    1: [-1, -1],
    2: [850, -1],
    3: [850, 300],
    4: [850, 300],
    5: [850, 350],
    6: [850, 400],
    7: [850, 600],
    8: [1200, 700]
  };
  var TVTHR = {
    1: -1,
    2: -1,
    3: 15,
    4: 18,
    5: 20,
    6: 22,
    7: 25,
    8: 25
  };
  var ALIM = {
    1: -1,
    2: -1,
    3: 300,
    4: 300,
    5: 350,
    6: 400,
    7: 600,
    8: 700
  };
  var ACCEL = {
    1: [900, 900],
    2: [1e3, 1e3],
    3: [1100, 1200],
    4: [1200, 1300],
    5: [1300, 1400],
    6: [2e3, 2200],
    7: [2100, 2300],
    8: [2200, 2500]
  };
  var SOUNDS = {
    pull_up: {
      name: "aural_pullup_new",
      length: 0.9
    },
    sink_rate: {
      name: "aural_sink_rate_new",
      length: 0.9
    },
    dont_sink: {
      name: "aural_dontsink_new",
      length: 0.9
    },
    too_low_gear: {
      name: "aural_too_low_gear",
      length: 0.8
    },
    too_low_flaps: {
      name: "aural_too_low_flaps",
      length: 0.8
    },
    too_low_terrain: {
      name: "aural_too_low_terrain",
      length: 0.9
    },
    minimums: {
      name: "aural_minimumnew",
      length: 0.67
    },
    hundred_above: {
      name: "aural_100above",
      length: 0.72
    },
    retard: {
      name: "new_retard",
      length: 0.9
    },
    alt_2500: {
      name: "new_2500",
      length: 1.1
    },
    alt_1000: {
      name: "new_1000",
      length: 0.9
    },
    alt_500: {
      name: "new_500",
      length: 0.6
    },
    alt_400: {
      name: "new_400",
      length: 0.6
    },
    alt_300: {
      name: "new_300",
      length: 0.6
    },
    alt_200: {
      name: "new_200",
      length: 0.6
    },
    alt_100: {
      name: "new_100",
      length: 0.6
    },
    alt_50: {
      name: "new_50",
      length: 0.4
    },
    alt_40: {
      name: "new_40",
      length: 0.4
    },
    alt_30: {
      name: "new_30",
      length: 0.4
    },
    alt_20: {
      name: "new_20",
      length: 0.4
    },
    alt_10: {
      name: "new_10",
      length: 0.3
    },
    alt_5: {
      name: "new_5",
      length: 0.3
    },
    climb_climb: {
      name: "climb_climb",
      length: 1.6
    },
    climb_crossing_climb: {
      name: "climb_crossing_climb",
      length: 1.7
    },
    increase_climb: {
      name: "increase_climb",
      length: 1.2
    },
    climb_climb_now: {
      name: "climb_climb_now",
      length: 1.9
    },
    clear_of_conflict: {
      name: "clear_of_conflict",
      length: 1.5
    },
    descend_descend: {
      name: "descend_descend",
      length: 2.1
    },
    descend_crossing_descend: {
      name: "descend_crossing_descend",
      length: 1.9
    },
    increase_descent: {
      name: "increase_descent",
      length: 1.3
    },
    descend_descend_now: {
      name: "descend_descend_now",
      length: 2.2
    },
    monitor_vs: {
      name: "monitor_vs",
      length: 1.7
    },
    maint_vs_maint: {
      name: "maint_vs_maint",
      length: 3.2
    },
    maint_vs_crossing_maint: {
      name: "maint_vs_crossing_maint",
      length: 3.2
    },
    level_off_level_off: {
      name: "level_off_level_off",
      length: 2.3
    },
    traffic_traffic: {
      name: "traffic_traffic",
      length: 1.5
    }
  };
  var CALLOUTS = {
    climb: {
      id: 0,
      repeat: false,
      sound: SOUNDS.climb_climb
    },
    climb_cross: {
      id: 1,
      repeat: true,
      sound: SOUNDS.climb_crossing_climb
    },
    climb_increase: {
      id: 2,
      repeat: true,
      sound: SOUNDS.increase_climb
    },
    climb_now: {
      id: 3,
      repeat: true,
      sound: SOUNDS.climb_climb_now
    },
    clear_of_conflict: {
      id: 4,
      repeat: false,
      sound: SOUNDS.clear_of_conflict
    },
    descend: {
      id: 5,
      repeat: false,
      sound: SOUNDS.descend_descend
    },
    descend_cross: {
      id: 6,
      repeat: true,
      sound: SOUNDS.descend_crossing_descend
    },
    descend_increase: {
      id: 7,
      repeat: true,
      sound: SOUNDS.increase_descent
    },
    descend_now: {
      id: 8,
      repeat: true,
      sound: SOUNDS.descend_descend_now
    },
    monitor_vs: {
      id: 9,
      repeat: false,
      sound: SOUNDS.monitor_vs
    },
    maintain_vs: {
      id: 10,
      repeat: false,
      sound: SOUNDS.maint_vs_maint
    },
    maintain_vs_cross: {
      id: 11,
      repeat: false,
      sound: SOUNDS.maint_vs_crossing_maint
    },
    level_off: {
      id: 12,
      repeat: false,
      sound: SOUNDS.level_off_level_off
    },
    traffic: {
      id: 13,
      repeat: false,
      sound: SOUNDS.traffic_traffic
    }
  };
  var RA_VARIANTS = {
    monitor_vs_climb_0: {
      callout: CALLOUTS.monitor_vs,
      sense: 0 /* UP */,
      type: 1 /* PREVENT */,
      vs: {
        green: [0, MAX_VS],
        red: [MIN_VS, 0]
      }
    },
    monitor_vs_climb_500: {
      callout: CALLOUTS.monitor_vs,
      sense: 0 /* UP */,
      type: 1 /* PREVENT */,
      vs: {
        green: [-500, MAX_VS],
        red: [MIN_VS, -500]
      }
    },
    monitor_vs_climb_1000: {
      callout: CALLOUTS.monitor_vs,
      sense: 0 /* UP */,
      type: 1 /* PREVENT */,
      vs: {
        green: [-1e3, MAX_VS],
        red: [MIN_VS, -1e3]
      }
    },
    monitor_vs_climb_2000: {
      callout: CALLOUTS.monitor_vs,
      sense: 0 /* UP */,
      type: 1 /* PREVENT */,
      vs: {
        green: [-2e3, MAX_VS],
        red: [MIN_VS, -2e3]
      }
    },
    monitor_vs_descend_0: {
      callout: CALLOUTS.monitor_vs,
      sense: 1 /* DOWN */,
      type: 1 /* PREVENT */,
      vs: {
        green: [MIN_VS, 0],
        red: [0, MAX_VS]
      }
    },
    monitor_vs_descend_500: {
      callout: CALLOUTS.monitor_vs,
      sense: 1 /* DOWN */,
      type: 1 /* PREVENT */,
      vs: {
        green: [MIN_VS, 500],
        red: [500, MAX_VS]
      }
    },
    monitor_vs_descend_1000: {
      callout: CALLOUTS.monitor_vs,
      sense: 1 /* DOWN */,
      type: 1 /* PREVENT */,
      vs: {
        green: [MIN_VS, 1e3],
        red: [1e3, MAX_VS]
      }
    },
    monitor_vs_descend_2000: {
      callout: CALLOUTS.monitor_vs,
      sense: 1 /* DOWN */,
      type: 1 /* PREVENT */,
      vs: {
        green: [MIN_VS, 2e3],
        red: [2e3, MAX_VS]
      }
    },
    climb: {
      callout: CALLOUTS.climb,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [1500, 2e3],
        red: [MIN_VS, 1500]
      }
    },
    climb_cross: {
      callout: CALLOUTS.climb_cross,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [1500, 2e3],
        red: [MIN_VS, 1500]
      }
    },
    climb_increase: {
      callout: CALLOUTS.climb_increase,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [2500, 4400],
        red: [MIN_VS, 2500]
      }
    },
    climb_now: {
      callout: CALLOUTS.climb_now,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [1500, 2e3],
        red: [MIN_VS, 1500]
      }
    },
    descend: {
      callout: CALLOUTS.descend,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-2e3, -1500],
        red: [-1500, MAX_VS]
      }
    },
    descend_cross: {
      callout: CALLOUTS.descend_cross,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-2e3, -1500],
        red: [-1500, MAX_VS]
      }
    },
    descend_increase: {
      callout: CALLOUTS.descend_increase,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-4400, -2500],
        red: [-2500, MAX_VS]
      }
    },
    descend_now: {
      callout: CALLOUTS.descend_now,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-2e3, -1500],
        red: [-1500, MAX_VS]
      }
    },
    level_off_300_below: {
      callout: CALLOUTS.level_off,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-400, 0],
        red: [0, MAX_VS]
      }
    },
    level_off_300_above: {
      callout: CALLOUTS.level_off,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [0, 400],
        red: [MIN_VS, 0]
      }
    },
    climb_maintain_vs: {
      callout: CALLOUTS.maintain_vs,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [1500, 4400],
        red: [MIN_VS, 1500]
      }
    },
    climb_maintain_vs_crossing: {
      callout: CALLOUTS.maintain_vs,
      sense: 0 /* UP */,
      type: 0 /* CORRECT */,
      vs: {
        green: [1500, 4400],
        red: [MIN_VS, 1500]
      }
    },
    descend_maintain_vs: {
      callout: CALLOUTS.maintain_vs,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-4400, -1500],
        red: [-1500, MAX_VS]
      }
    },
    descend_maintain_vs_crossing: {
      callout: CALLOUTS.maintain_vs,
      sense: 1 /* DOWN */,
      type: 0 /* CORRECT */,
      vs: {
        green: [-4400, -1500],
        red: [-1500, MAX_VS]
      }
    }
  };
  var TCAS_CONST = {
    REFRESH_RATE,
    TRACKING_MAX,
    DISPLAY_MAX,
    MEMORY_MAX,
    MIN_VS,
    INHIBIT_CLB_RA,
    INHIBIT_INC_DES_RA_AGL,
    INHIBIT_ALL_DES_RA_AGL,
    INHIBIT_ALL_RA,
    REALLY_BIG_NUMBER,
    INITIAL_DELAY,
    FOLLOWUP_DELAY,
    INITIAL_ACCEL,
    FOLLOWUP_ACCEL,
    TA_EXPIRATION_DELAY,
    MIN_RA_DURATION,
    VOL_BOOST,
    CLOSURE_RATE_THRESH,
    THREAT,
    SENSE,
    RANGE,
    TAU,
    DMOD,
    ZTHR,
    TVTHR,
    ALIM,
    ACCEL,
    SOUNDS,
    CALLOUTS,
    RA_VARIANTS
  };

  // src/systems/instruments/src/Common/persistence.tsx
  var import_react14 = __toESM(require_react());
  function usePersistentProperty(propertyName, defaultValue) {
    const [propertyValue, rawPropertySetter] = (0, import_react14.useState)(() => NXDataStore.get(propertyName, defaultValue));
    (0, import_react14.useEffect)(() => {
      const unsubscribe = NXDataStore.subscribe(propertyName, (key, value) => rawPropertySetter(value));
      return () => {
        unsubscribe();
      };
    }, []);
    const propertySetter = (value) => {
      NXDataStore.set(propertyName, value);
      rawPropertySetter(value);
    };
    return [propertyValue, propertySetter];
  }

  // src/systems/instruments/src/ND/elements/Traffic.tsx
  var TCAS_MASK_ARC = [
    [-384, -310],
    [-384, 0],
    [-264, 0],
    [-210, 59],
    [-210, 143],
    [210, 143],
    [210, 0],
    [267, -61],
    [384, -61],
    [384, -310],
    [340, -355],
    [300, -390],
    [240, -431.5],
    [180, -460],
    [100, -482],
    [0, -492],
    [-100, -482],
    [-180, -460],
    [-240, -431.5],
    [-300, -390],
    [-340, -355],
    [-384, -310]
  ];
  var TCAS_MASK_ROSE = [
    [-340, -227],
    [-103, -227],
    [-50, -244],
    [0, -250],
    [50, -244],
    [103, -227],
    [340, -227],
    [340, 180],
    [267, 180],
    [210, 241],
    [210, 383],
    [-210, 383],
    [-210, 300],
    [-264, 241],
    [-340, 241],
    [-340, -227]
  ];
  var useAirTraffic = (mapParams, mode) => {
    const [airTraffic, setAirTraffic] = (0, import_react15.useState)([]);
    const tcasMask = mode === 3 /* ARC */ ? TCAS_MASK_ARC : TCAS_MASK_ROSE;
    useFlowSyncEvent("A32NX_TCAS_TRAFFIC", (_topic, data) => {
      if (data) {
        setAirTraffic(trafficToDisplay(data, mapParams, tcasMask));
      }
    });
    (0, import_react15.useEffect)(() => {
      setAirTraffic(trafficToDisplay(airTraffic, mapParams, tcasMask));
    }, [mapParams == null ? void 0 : mapParams.nmRadius, mode]);
    return airTraffic;
  };
  var trafficToDisplay = (airTraffic, mapParams, tcasMask) => airTraffic.map((traffic) => {
    const latLong = { lat: traffic.lat, long: traffic.lon };
    let [x, y] = mapParams.coordinatesToXYy(latLong);
    if (!MathUtils.pointInPolygon(x, y, tcasMask)) {
      if (traffic.intrusionLevel < 2 /* TA */) {
        traffic.alive = false;
        return traffic;
      }
      const ret = MathUtils.intersectWithPolygon(x, y, 0, 0, tcasMask);
      if (ret)
        [x, y] = ret;
    }
    traffic.alive = true;
    traffic.posX = x;
    traffic.posY = y;
    return traffic;
  });
  var Traffic = ({ mapParams, mode }) => {
    const airTraffic = useAirTraffic(mapParams, mode);
    const [debug] = usePersistentProperty("TCAS_DEBUG", "0");
    const [sensitivity] = useSimVar("L:A32NX_TCAS_SENSITIVITY", "number", 200);
    const x = 361.5;
    const y = mode === 3 /* ARC */ ? 606.5 : 368;
    if (debug !== "0") {
      const dmodRa = mapParams.nmToPx * TCAS_CONST.DMOD[sensitivity || 1][1 /* RA */];
      const dmodTa = mapParams.nmToPx * TCAS_CONST.DMOD[sensitivity || 1][0 /* TA */];
      return /* @__PURE__ */ import_react15.default.createElement(Layer, { x, y }, dmodTa >= 0 && /* @__PURE__ */ import_react15.default.createElement(
        "path",
        {
          d: `M 22.5, 16 m -${dmodTa}, 0 a ${dmodTa},${dmodTa} 0 1,0 ${dmodTa * 2},0 a ${dmodTa},${dmodTa} 0 1,0 -${dmodTa * 2},0`,
          strokeWidth: 2,
          className: "Amber",
          strokeDasharray: "5 2.5"
        }
      ), dmodRa >= 0 && /* @__PURE__ */ import_react15.default.createElement(
        "path",
        {
          d: `M 22.5, 16 m -${dmodRa}, 0 a ${dmodRa},${dmodRa} 0 1,0 ${dmodRa * 2},0 a ${dmodRa},${dmodRa} 0 1,0 -${dmodRa * 2},0`,
          strokeWidth: 2,
          className: "Red",
          strokeDasharray: "6 3"
        }
      ), /* @__PURE__ */ import_react15.default.createElement("text", { x: 290, y: -200, fill: "#ffffff", fontSize: "12px", height: 1.25, strokeWidth: 0.3, textAnchor: "middle", xmlSpace: "preserve" }, /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ffffff" }, `SENSITIVITY: ${sensitivity}`), /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 290, dy: 15, fill: "#ffffff" }, "DMOD: "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#e38c56" }, dmodTa.toFixed(3)), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ffffff" }, " | "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ff0000" }, dmodRa.toFixed(3)), /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 290, dy: 15, fill: "#ffffff" }, "TAU THR: "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#e38c56" }, TCAS_CONST.TAU[sensitivity || 1][0 /* TA */]), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ffffff" }, " | "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ff0000" }, TCAS_CONST.TAU[sensitivity || 1][1 /* RA */]), /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 290, dy: 15, fill: "#ffffff" }, "Z THR: "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#e38c56" }, TCAS_CONST.ZTHR[sensitivity || 1][0 /* TA */]), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ffffff" }, " | "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ff0000" }, TCAS_CONST.ZTHR[sensitivity || 1][1 /* RA */]), /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 290, dy: 15, fill: "#ffffff" }, "ALIM: "), /* @__PURE__ */ import_react15.default.createElement("tspan", { fill: "#ff0000" }, TCAS_CONST.ALIM[sensitivity])), airTraffic.map((tf) => {
        var _a, _b, _c, _d, _e;
        return tf.alive ? /* @__PURE__ */ import_react15.default.createElement(
          TrafficIndicatorDebug,
          {
            key: tf.ID,
            x: tf.posX,
            y: tf.posY,
            relativeAlt: tf.relativeAlt,
            vertSpeed: tf.vertSpeed,
            intrusionLevel: tf.intrusionLevel,
            ID: tf.ID,
            hidden: tf.hidden,
            seen: tf.seen,
            raTau: tf.raTau && tf.raTau < 200 ? (_a = tf.raTau) == null ? void 0 : _a.toFixed(0) : void 0,
            taTau: tf.taTau && tf.taTau < 200 ? (_b = tf.taTau) == null ? void 0 : _b.toFixed(0) : void 0,
            vTau: tf.vTau && tf.vTau < 200 ? (_c = tf.vTau) == null ? void 0 : _c.toFixed(0) : void 0,
            closureAccel: (_d = tf.closureAccel) == null ? void 0 : _d.toFixed(1),
            closureRate: (_e = tf.closureRate) == null ? void 0 : _e.toFixed(1)
          }
        ) : null;
      }));
    }
    return /* @__PURE__ */ import_react15.default.createElement(Layer, { x, y }, airTraffic.map((tf) => tf.alive ? /* @__PURE__ */ import_react15.default.createElement(
      TrafficIndicator,
      {
        key: tf.ID,
        x: tf.posX,
        y: tf.posY,
        relativeAlt: tf.relativeAlt,
        vertSpeed: tf.vertSpeed,
        intrusionLevel: tf.intrusionLevel
      }
    ) : null));
  };
  var TrafficIndicator = (0, import_react15.memo)(({ x, y, relativeAlt, vertSpeed, intrusionLevel }) => {
    if (relativeAlt === void 0 || vertSpeed === void 0 || x === void 0 || y === void 0)
      return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null);
    let color = "#ffffff";
    switch (intrusionLevel) {
      case 2 /* TA */:
        color = "#e38c56";
        break;
      case 3 /* RA */:
        color = "#ff0000";
        break;
      default:
        break;
    }
    const relAltY = relativeAlt > 0 ? 7 : 43.5;
    return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement(Layer, { x, y }, intrusionLevel === 0 /* TRAFFIC */ && /* @__PURE__ */ import_react15.default.createElement("image", { x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_NORMAL.svg" }), intrusionLevel === 1 /* PROXIMITY */ && /* @__PURE__ */ import_react15.default.createElement("image", { x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_PROXIMITY.svg" }), intrusionLevel === 2 /* TA */ && /* @__PURE__ */ import_react15.default.createElement("image", { x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_TA.svg" }), intrusionLevel === 3 /* RA */ && /* @__PURE__ */ import_react15.default.createElement("image", { x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_RA.svg" }), /* @__PURE__ */ import_react15.default.createElement("g", null, /* @__PURE__ */ import_react15.default.createElement("text", { x: 30, y: relAltY, fill: color, height: 1.25, paintOrder: "stroke", stroke: "#040404", strokeWidth: 1, textAnchor: "end", xmlSpace: "preserve" }, /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 17.25, y: relAltY, fill: color, fontSize: "20px", paintOrder: "stroke", stroke: "#040404", strokeWidth: 1, textAnchor: "middle" }, `${relativeAlt > 0 ? "+" : "-"}${Math.abs(relativeAlt) < 10 ? "0" : ""}${Math.abs(relativeAlt)}`)), vertSpeed <= -500 && /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", fill: "none", strokeWidth: 3, d: "M35,21V9.7" }), /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", stroke: "none", fillRule: "evenodd", d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z" }), /* @__PURE__ */ import_react15.default.createElement("path", { fill: "none", stroke: color, strokeWidth: 1.6, d: "M35,21V9.7" }), /* @__PURE__ */ import_react15.default.createElement("path", { fill: color, stroke: "none", fillRule: "evenodd", d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z" })), vertSpeed >= 500 && /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", fill: "none", strokeWidth: 3, d: "M35,14.2v11.3" }), /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", stroke: "none", fillRule: "evenodd", d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z" }), /* @__PURE__ */ import_react15.default.createElement("path", { fill: "none", stroke: color, strokeWidth: 1.6, d: "M35,14.2v11.3" }), /* @__PURE__ */ import_react15.default.createElement("path", { fill: color, stroke: "none", fillRule: "evenodd", d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z" })))));
  });
  var TrafficIndicatorDebug = (0, import_react15.memo)(({ x, y, relativeAlt, vertSpeed, intrusionLevel, ID, hidden, seen, raTau, taTau, vTau, closureRate, closureAccel }) => {
    if (relativeAlt === void 0 || vertSpeed === void 0 || x === void 0 || y === void 0)
      return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null);
    let color = "#ffffff";
    switch (intrusionLevel) {
      case 2 /* TA */:
        color = "#e38c56";
        break;
      case 3 /* RA */:
        color = "#ff0000";
        break;
      default:
        break;
    }
    const relAltY = relativeAlt > 0 ? 7 : 43.5;
    const debugY1 = relativeAlt > 0 ? 38 : -1;
    const debugY2 = relativeAlt > 0 ? 50 : -13;
    return /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement(Layer, { x, y }, intrusionLevel === 0 /* TRAFFIC */ && /* @__PURE__ */ import_react15.default.createElement("image", { opacity: hidden ? 0.125 : 1, x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_NORMAL.svg" }), intrusionLevel === 1 /* PROXIMITY */ && /* @__PURE__ */ import_react15.default.createElement("image", { opacity: hidden ? 0.125 : 1, x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_PROXIMITY.svg" }), intrusionLevel === 2 /* TA */ && /* @__PURE__ */ import_react15.default.createElement("image", { opacity: hidden ? 0.125 : 1, x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_TA.svg" }), intrusionLevel === 3 /* RA */ && /* @__PURE__ */ import_react15.default.createElement("image", { opacity: hidden ? 0.125 : 1, x: 0, y: 0, width: 45, height: 32, xlinkHref: "/Images/fbw-a32nx/ND/TRAFFIC_RA.svg" }), /* @__PURE__ */ import_react15.default.createElement("g", null, /* @__PURE__ */ import_react15.default.createElement("text", { x: 30, y: relAltY, fillOpacity: hidden ? 0.125 : 1, fill: color, height: 1.25, strokeWidth: 0.3, textAnchor: "end", xmlSpace: "preserve" }, /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 17.25, y: relAltY, fill: color, fontSize: "20px", strokeWidth: 0.3, textAnchor: "middle" }, `${relativeAlt > 0 ? "+" : "-"}${Math.abs(relativeAlt) < 10 ? "0" : ""}${Math.abs(relativeAlt)}`), !hidden && /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 17.25, y: debugY1, fillOpacity: 0.6, fill: color, fontSize: "8px", strokeWidth: 0.2, textAnchor: "middle" }, `${ID} [${closureRate}|${closureAccel}] <${seen}>`), /* @__PURE__ */ import_react15.default.createElement("tspan", { x: 17.25, y: debugY2, fill: color, fontSize: "12px", strokeWidth: 0.2, textAnchor: "middle" }, `R ${raTau || "-"} V ${vTau || "-"} T ${taTau || "-"}`))), vertSpeed <= -500 && /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", fill: "none", strokeWidth: 3, d: "M35,21V9.7" }), /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", stroke: "none", fillRule: "evenodd", d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z" }), /* @__PURE__ */ import_react15.default.createElement("path", { opacity: hidden ? 0.125 : 1, fill: "none", stroke: color, strokeWidth: 1.6, d: "M35,21V9.7" }), /* @__PURE__ */ import_react15.default.createElement("path", { opacity: hidden ? 0.125 : 1, fill: color, stroke: "none", fillRule: "evenodd", d: "M31.3,18.5l3.3,7.1h0.9l3.3-7.1H31.3z" })), vertSpeed >= 500 && /* @__PURE__ */ import_react15.default.createElement(import_react15.default.Fragment, null, /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", fill: "none", strokeWidth: 3, d: "M35,14.2v11.3" }), /* @__PURE__ */ import_react15.default.createElement("path", { className: "shadow", stroke: "none", fillRule: "evenodd", d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z" }), /* @__PURE__ */ import_react15.default.createElement("path", { opacity: hidden ? 0.125 : 1, fill: "none", stroke: color, strokeWidth: 1.6, d: "M35,14.2v11.3" }), /* @__PURE__ */ import_react15.default.createElement("path", { opacity: hidden ? 0.125 : 1, fill: color, stroke: "none", fillRule: "evenodd", d: "M38.7,16.7l-3.3-7.1h-0.9l-3.3,7.1H38.7z" })))));
  });

  // src/systems/instruments/src/ND/pages/ArcMode.tsx
  var ArcMode = ({ symbols, adirsAlign, rangeSetting, side, ppos, mapHidden, trueRef }) => {
    const magHeading = useArinc429Var("L:A32NX_ADIRS_IR_1_HEADING");
    const magTrack = useArinc429Var("L:A32NX_ADIRS_IR_1_TRACK");
    const trueHeading = useArinc429Var("L:A32NX_ADIRS_IR_1_TRUE_HEADING");
    const trueTrack = useArinc429Var("L:A32NX_ADIRS_IR_1_TRUE_TRACK");
    const [tcasMode] = useSimVar("L:A32NX_SWITCH_TCAS_Position", "number");
    const [selectedHeading] = useSimVar("L:A32NX_FCU_HEADING_SELECTED", "degrees");
    const [lsCourse] = useSimVar("L:A32NX_FM_LS_COURSE", "number");
    const [lsDisplayed] = useSimVar(`L:BTN_LS_${side === "L" ? 1 : 2}_FILTER_ACTIVE`, "bool");
    const [fmaLatMode] = useSimVar("L:A32NX_FMA_LATERAL_MODE", "enum", 200);
    const [armedLateralBitmask] = useSimVar("L:A32NX_FMA_LATERAL_ARMED", "enum", 200);
    const [groundSpeed] = useSimVar("GPS GROUND SPEED", "Meters per second", 200);
    const heading = Number(MathUtils.fastToFixed(trueRef ? trueHeading.value : magHeading.value, 2));
    const track = Number(MathUtils.fastToFixed(trueRef ? trueTrack.value : magTrack.value, 2));
    const [mapParams] = (0, import_react16.useState)(() => {
      const params = new MapParameters();
      params.compute(ppos, 0, rangeSetting, 492, trueHeading.value);
      return params;
    });
    (0, import_react16.useEffect)(() => {
      mapParams.compute(ppos, 0, rangeSetting, 492, trueHeading.value);
    }, [ppos.lat, ppos.long, trueHeading.value, rangeSetting].map((n) => MathUtils.fastToFixed(n, 6)));
    if (adirsAlign) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(
        Overlay,
        {
          heading,
          rangeSetting,
          tcasMode
        }
      ), /* @__PURE__ */ import_react16.default.createElement("g", { id: "map", clipPath: "url(#arc-mode-map-clip)" }, /* @__PURE__ */ import_react16.default.createElement("g", { visibility: mapHidden ? "hidden" : "visible" }, /* @__PURE__ */ import_react16.default.createElement(
        FlightPlan2,
        {
          x: 384,
          y: 620,
          side,
          range: rangeSetting,
          symbols,
          mapParams,
          mapParamsVersion: mapParams.version,
          debug: false
        }
      ), (fmaLatMode === 0 /* NONE */ || fmaLatMode === 10 /* HDG */ || fmaLatMode === 11 /* TRACK */) && !isArmed(armedLateralBitmask, 0 /* NAV */) && /* @__PURE__ */ import_react16.default.createElement(
        TrackLine,
        {
          x: 384,
          y: 620,
          heading,
          track,
          groundSpeed: Number(MathUtils.fastToFixed(groundSpeed, 2)),
          mapParams,
          symbols,
          ndRange: rangeSetting
        }
      )), /* @__PURE__ */ import_react16.default.createElement(RadioNeedle, { index: 1, side, displayMode: 3 /* ARC */, centreHeight: 620, trueRef }), /* @__PURE__ */ import_react16.default.createElement(RadioNeedle, { index: 2, side, displayMode: 3 /* ARC */, centreHeight: 620, trueRef })), /* @__PURE__ */ import_react16.default.createElement(ToWaypointIndicator, { side, trueRef }), /* @__PURE__ */ import_react16.default.createElement(TopMessages, { side, ppos, trueTrack, trueRef }), /* @__PURE__ */ import_react16.default.createElement(TrackBug, { heading, track }), lsDisplayed && /* @__PURE__ */ import_react16.default.createElement(LsCourseBug, { heading, lsCourse }), /* @__PURE__ */ import_react16.default.createElement(SelectedHeadingBug, { heading, selected: selectedHeading }), /* @__PURE__ */ import_react16.default.createElement(Plane, null), /* @__PURE__ */ import_react16.default.createElement(CrossTrack, { x: 390, y: 646, side }), /* @__PURE__ */ import_react16.default.createElement("g", { clipPath: "url(#arc-mode-tcas-clip)" }, /* @__PURE__ */ import_react16.default.createElement(Traffic, { mode: 3 /* ARC */, mapParams })));
    }
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(
      MapFailOverlay,
      {
        rangeSetting
      }
    ), /* @__PURE__ */ import_react16.default.createElement("text", { x: 681, y: 28, fontSize: 25, className: "White", textAnchor: "end" }, "PPOS"));
  };
  var Overlay = (0, import_react16.memo)(({ heading, rangeSetting, tcasMode }) => /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(ArcModeOverlayDefs, null), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotateX(0deg)", stroke: "white", strokeWidth: 2, fill: "none" }, /* @__PURE__ */ import_react16.default.createElement("g", { clipPath: "url(#arc-mode-overlay-clip-4)" }, /* @__PURE__ */ import_react16.default.createElement("g", { transform: `rotate(${MathUtils.diffAngle(heading, 60)} 384 620)` }, /* @__PURE__ */ import_react16.default.createElement(ArcModeOverlayHeadingRing, null))), /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M15,620a369,369 0 1,0 738,0a369,369 0 1,0 -738,0",
      strokeDasharray: "15 10.5",
      strokeDashoffset: "15",
      clipPath: "url(#arc-mode-overlay-clip-3)"
    }
  ), /* @__PURE__ */ import_react16.default.createElement("text", { x: 58, y: 482, fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 4 * 3), /* @__PURE__ */ import_react16.default.createElement("text", { x: 709, y: 482, textAnchor: "end", fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 4 * 3), /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M138,620a246,246 0 1,0 492,0a246,246 0 1,0 -492,00",
      strokeDasharray: "15 10",
      strokeDashoffset: "-6",
      clipPath: "url(#arc-mode-overlay-clip-2)"
    }
  ), /* @__PURE__ */ import_react16.default.createElement("text", { x: 175, y: 528, fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 2), /* @__PURE__ */ import_react16.default.createElement("text", { x: 592, y: 528, textAnchor: "end", fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 2), (tcasMode === 0 || rangeSetting > 10) && /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M261,620a123,123 0 1,0 246,0a123,123 0 1,0 -246,00",
      strokeDasharray: "15 10",
      strokeDashoffset: "-4.2",
      clipPath: "url(#arc-mode-overlay-clip-1)"
    }
  ), tcasMode > 0 && rangeSetting === 10 && /* @__PURE__ */ import_react16.default.createElement("g", null, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 497 - 6, y2: 497 + 6, className: "rounded White", transform: "rotate(-60 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 497 - 6, y2: 497 + 6, className: "rounded White", transform: "rotate(-30 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 497 - 6, y2: 497 + 6, className: "rounded White", transform: "rotate(0 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 497 - 6, y2: 497 + 6, className: "rounded White", transform: "rotate(30 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 497 - 6, y2: 497 + 6, className: "rounded White", transform: "rotate(60 384 620)" })), tcasMode > 0 && rangeSetting === 20 && /* @__PURE__ */ import_react16.default.createElement("g", null, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 558 - 6, y2: 558 + 6, className: "rounded White", transform: "rotate(-60 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 558 - 6, y2: 558 + 6, className: "rounded White", transform: "rotate(-30 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 558 - 6, y2: 558 + 6, className: "rounded White", transform: "rotate(0 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 558 - 6, y2: 558 + 6, className: "rounded White", transform: "rotate(30 384 620)" }), /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, x2: 384, y1: 558 - 6, y2: 558 + 6, className: "rounded White", transform: "rotate(60 384 620)" })))));
  var ArcModeOverlayDefs = (0, import_react16.memo)(() => /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-map-clip" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "M0,312 a492,492 0 0 1 768,0 L768,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L0,625 L0,312" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-wx-terr-clip" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "M0,312 a492,492 0 0 1 768,0 L768,562 L648,562 L591,625 L0,625 L0,312" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-tcas-clip" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "M0,312 a492,492 0 0 1 768,0 L768,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L0,625 L0,312" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-4" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 6 0 h 756 v 768 h -756 z" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-3" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 0 564 l 384 145 l 384 -145 v -564 h -768 z" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-2" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 0 532 l 384 155 l 384 -146 v -512 h -768 z" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-1" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 0 519 l 384 145 l 384 -86 v -580 h -768 z" })), /* @__PURE__ */ import_react16.default.createElement("path", { name: "arc-mode-bottom-left-map-area", d: "M0,625 L122,625 L174,683 L174,768 L0,768 L0,625", className: "nd-inverted-map-area" }), /* @__PURE__ */ import_react16.default.createElement("path", { name: "arc-mode-bottom-right-map-area", d: "M768,562 L648,562 L591,625 L591,768 L768,768 L768,562", className: "nd-inverted-map-area" }), /* @__PURE__ */ import_react16.default.createElement("path", { name: "arc-mode-top-map-area", d: "M0,0 L0,312 a492,492 0 0 1 768,0 L768,0 L0,0", className: "nd-inverted-map-area" })));
  var ArcModeOverlayHeadingRing = (0, import_react16.memo)(() => /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M-108,620a492,492 0 1,0 984,0a492,492 0 1,0 -984,0",
      strokeWidth: 2
    }
  ), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-60 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "0")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-55 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-50 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "1")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-45 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-40 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "2")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-35 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-30 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "3")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-25 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-20 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "4")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-15 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-10 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "5")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(-5 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(0 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "6")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(5 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(10 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 95, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "7")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(15 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(20 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 95, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "8")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(25 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(30 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "9")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(35 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(40 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "10")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(45 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(50 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "11")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(55 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(60 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "12")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(65 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(70 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "13")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(75 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(80 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "14")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(85 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(90 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "15")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(95 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(100 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "16")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(105 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(110 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "17")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(115 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(120 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "18")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(125 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(130 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "19")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(135 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(140 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "20")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(145 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(150 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "21")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(155 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(160 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "22")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(165 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(170 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "23")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(175 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(180 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "24")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(185 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(190 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "25")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(195 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(200 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "26")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(205 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(210 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "27")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(215 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(220 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "28")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(225 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(230 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "29")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(235 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(240 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "30")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(245 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(250 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "31")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(255 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(260 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "32")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(265 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(270 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 34, fill: "white", stroke: "none" }, "33")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(275 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(280 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "34")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(285 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 })), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(290 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 99, strokeWidth: 2 }), /* @__PURE__ */ import_react16.default.createElement("text", { x: 384, y: 91, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "35")), /* @__PURE__ */ import_react16.default.createElement("g", { transform: "rotate(295 384 620)" }, /* @__PURE__ */ import_react16.default.createElement("line", { x1: 384, y1: 128, x2: 384, y2: 113, strokeWidth: 2 }))));
  var MapFailOverlay = (0, import_react16.memo)(({ rangeSetting }) => /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("text", { className: "Red", fontSize: 30, textAnchor: "middle", x: 384, y: 241 }, "HDG"), /* @__PURE__ */ import_react16.default.createElement("text", { className: "Red", fontSize: 30, textAnchor: "middle", x: 384, y: 320.6 }, "MAP NOT AVAIL")), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-map-clip" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "M-384,-308 a492,492 0 0 1 768,0 L384,-58 L264,-58 L207,5 L207,148 L-210,148 L-210,63 L-262,5 L-384,5 L-384,-308" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-4" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 6 0 h 756 v 768 h -756 z" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-3" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 0 564 l 384 145 l 384 -145 v -564 h -768 z" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-2" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 0 532 l 384 155 l 384 -146 v -512 h -768 z" })), /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "arc-mode-overlay-clip-1" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "m 0 519 l 384 145 l 384 -86 v -580 h -768 z" })), /* @__PURE__ */ import_react16.default.createElement("g", { stroke: "white", strokeWidth: 3, fill: "none" }, /* @__PURE__ */ import_react16.default.createElement("g", { clipPath: "url(#arc-mode-overlay-clip-4)" }, /* @__PURE__ */ import_react16.default.createElement("g", null, /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M-108,620a492,492 0 1,0 984,0a492,492 0 1,0 -984,0",
      strokeWidth: 3.25,
      stroke: "red"
    }
  ))), /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M15,620a369,369 0 1,0 738,0a369,369 0 1,0 -738,0",
      strokeDasharray: "15 10.5",
      strokeDashoffset: "15",
      clipPath: "url(#arc-mode-overlay-clip-3)",
      stroke: "red"
    }
  ), /* @__PURE__ */ import_react16.default.createElement("text", { x: 58, y: 482, fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 4 * 3), /* @__PURE__ */ import_react16.default.createElement("text", { x: 709, y: 482, textAnchor: "end", fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 4 * 3), /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M138,620a246,246 0 1,0 492,0a246,246 0 1,0 -492,00",
      strokeDasharray: "15 10",
      strokeDashoffset: "-6",
      clipPath: "url(#arc-mode-overlay-clip-2)",
      stroke: "red"
    }
  ), /* @__PURE__ */ import_react16.default.createElement("text", { x: 168, y: 528, fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 2), /* @__PURE__ */ import_react16.default.createElement("text", { x: 592, y: 528, textAnchor: "end", fill: "#00ffff", stroke: "none", fontSize: 22 }, rangeSetting / 2), /* @__PURE__ */ import_react16.default.createElement(
    "path",
    {
      d: "M261,620a123,123 0 1,0 246,0a123,123 0 1,0 -246,00",
      strokeDasharray: "15 10",
      strokeDashoffset: "-4.2",
      clipPath: "url(#arc-mode-overlay-clip-1)",
      stroke: "red"
    }
  )), /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement("clipPath", { id: "mask" }, /* @__PURE__ */ import_react16.default.createElement("rect", { x: 372, y: 615, width: 24, height: 20 })), /* @__PURE__ */ import_react16.default.createElement("circle", { cx: 384, cy: 634, r: 10, fill: "none", stroke: "red", strokeWidth: 3.25, clipPath: "url(#mask)" }))));
  var Plane = (0, import_react16.memo)(() => /* @__PURE__ */ import_react16.default.createElement("g", null, /* @__PURE__ */ import_react16.default.createElement("line", { id: "lubber-shadow", x1: 384, y1: 108, x2: 384, y2: 148, className: "shadow", strokeWidth: 5.5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react16.default.createElement("line", { id: "lubber", x1: 384, y1: 108, x2: 384, y2: 148, className: "Yellow", strokeWidth: 5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react16.default.createElement("path", { id: "plane-shadow", d: "M 384 594 l 0 75 m -37 -49 l 74 0 m -50 36 l 26 0", className: "shadow", strokeWidth: 5.5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react16.default.createElement("path", { id: "plane", d: "M 384 594 l 0 75 m -37 -49 l 74 0 m -50 36 l 26 0", className: "Yellow", strokeWidth: 5, strokeLinejoin: "round", strokeLinecap: "round" })));
  var TrackBug = (0, import_react16.memo)(({ heading, track }) => {
    const diff = getSmallestAngle(track, heading);
    if (diff > 48) {
      return null;
    }
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(
      "path",
      {
        d: "M384,128 L378,138 L384,148 L390,138 L384,128",
        transform: `rotate(${diff} 384 620)`,
        className: "rounded shadow",
        strokeWidth: 3.5
      }
    ), /* @__PURE__ */ import_react16.default.createElement(
      "path",
      {
        d: "M384,128 L378,138 L384,148 L390,138 L384,128",
        transform: `rotate(${diff} 384 620)`,
        className: "rounded Green",
        strokeWidth: 3
      }
    ));
  });
  var LsCourseBug = ({ heading, lsCourse }) => {
    const diff = getSmallestAngle(lsCourse, heading);
    if (lsCourse < 0 || Math.abs(diff) > 48) {
      return null;
    }
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(
      "path",
      {
        d: "M384,122 L384,74 M376,114 L392,114",
        transform: `rotate(${diff} 384 620)`,
        className: "rounded shadow",
        strokeWidth: 2.5
      }
    ), /* @__PURE__ */ import_react16.default.createElement(
      "path",
      {
        d: "M384,122 L384,74 M376,114 L392,114",
        transform: `rotate(${diff} 384 620)`,
        className: "rounded Magenta",
        strokeWidth: 2
      }
    ));
  };
  var SelectedHeadingBug = ({ heading, selected }) => {
    if (selected < 0) {
      return null;
    }
    const diff = getSmallestAngle(selected, heading);
    if (Math.abs(diff) <= 48) {
      return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(
        "path",
        {
          d: "M382,126 L370,99 L398,99 L386,126",
          transform: `rotate(${diff} 384 620)`,
          className: "rounded shadow",
          strokeWidth: 3.5
        }
      ), /* @__PURE__ */ import_react16.default.createElement(
        "path",
        {
          d: "M382,126 L370,99 L398,99 L386,126",
          transform: `rotate(${diff} 384 620)`,
          className: "rounded Cyan",
          strokeWidth: 3
        }
      ));
    }
    return /* @__PURE__ */ import_react16.default.createElement(
      "text",
      {
        x: 384,
        y: 60,
        textAnchor: "middle",
        transform: `rotate(${diff < 0 ? -38 : 38} 384 620)`,
        className: "shadow Cyan",
        fontSize: 22
      },
      `${Math.round(selected).toString().padStart(3, "0")}`
    );
  };

  // src/systems/instruments/src/ND/elements/WindIndicator.tsx
  var import_react17 = __toESM(require_react());
  var mod3 = (x, n) => x - Math.floor(x / n) * n;
  var WindIndicator = ({ irs }) => {
    const windDirection = useArinc429Var(`L:A32NX_ADIRS_IR_${irs}_WIND_DIRECTION_BNR`, 500);
    const windSpeed = useArinc429Var(`L:A32NX_ADIRS_IR_${irs}_WIND_SPEED_BNR`, 500);
    const planeHeading = useArinc429Var(`L:A32NX_ADIRS_IR_${irs}_TRUE_HEADING`, 500);
    const windDirection360 = windDirection.value < 0 ? windDirection.value + 360 : windDirection.value;
    let windDirectionText;
    let windSpeedText;
    let windArrowShow = false;
    if (windSpeed.isFailureWarning() || windDirection.isFailureWarning()) {
      windDirectionText = "";
      windSpeedText = "";
      windArrowShow = false;
    } else if (windSpeed.isNoComputedData() || windDirection.isNoComputedData()) {
      windDirectionText = "---";
      windSpeedText = "---";
    } else {
      windDirectionText = Math.round(windDirection360).toString().padStart(3, "0");
      windSpeedText = Math.round(windSpeed.value).toString();
      if (windSpeed.value >= 2) {
        windArrowShow = true;
      }
    }
    let rotation;
    if (planeHeading.isNormalOperation() && windDirection.isNormalOperation()) {
      rotation = mod3(Math.round(windDirection360) - Math.round(planeHeading.value) + 180, 360);
    }
    return /* @__PURE__ */ import_react17.default.createElement(Layer, { x: 17, y: 56 }, /* @__PURE__ */ import_react17.default.createElement("text", { x: 25, y: 0, fontSize: 22, textAnchor: "end", className: "Green" }, windDirectionText), /* @__PURE__ */ import_react17.default.createElement("text", { x: 30, y: 0, fontSize: 22, className: "White" }, "/"), /* @__PURE__ */ import_react17.default.createElement("text", { x: 48, y: 0, fontSize: 22, className: "Green" }, windSpeedText), windArrowShow && /* @__PURE__ */ import_react17.default.createElement(
      "path",
      {
        className: "Green",
        strokeWidth: 2.25,
        strokeLinecap: "round",
        d: "M 0 30 v -20 m -7 8 l 7 -8 l 7 8",
        transform: `rotate(${rotation} 0 20)`,
        visibility: "visible"
      }
    ));
  };

  // src/systems/instruments/src/ND/elements/SpeedIndicator.tsx
  var import_react18 = __toESM(require_react());
  var SpeedIndicator = ({ adrs, irs }) => {
    const tas = useArinc429Var(`L:A32NX_ADIRS_ADR_${adrs}_TRUE_AIRSPEED`, 200);
    const gs = useArinc429Var(`L:A32NX_ADIRS_IR_${irs}_GROUND_SPEED`, 200);
    let tasText;
    if (!tas.isNormalOperation()) {
      tasText = "";
    } else if (tas.value < 1e-5) {
      tasText = "---";
    } else {
      tasText = Math.round(tas.value).toString().padStart(3, "0");
    }
    return /* @__PURE__ */ import_react18.default.createElement(Layer, { x: 2, y: 28 }, /* @__PURE__ */ import_react18.default.createElement("text", { x: 0, y: 0, fontSize: 20, className: "White" }, "GS"), /* @__PURE__ */ import_react18.default.createElement("text", { x: 82, y: 0, fontSize: 25, textAnchor: "end", className: "Green" }, gs.isNormalOperation() ? Math.round(gs.value).toString().padStart(3) : ""), /* @__PURE__ */ import_react18.default.createElement("text", { x: 90, y: 0, fontSize: 20, className: "White" }, "TAS"), /* @__PURE__ */ import_react18.default.createElement("text", { x: 189, y: 0, fontSize: 25, textAnchor: "end", className: "Green" }, tasText));
  };

  // src/systems/instruments/src/ND/elements/RadioNavInfo.tsx
  var import_react19 = __toESM(require_react());
  var TuningModeIndicator = ({ index, adf = false }) => {
    const [fm1Healthy] = useSimVar("L:A32NX_FM1_HEALTHY_DISCRETE", "boolean");
    const [fm2Healthy] = useSimVar("L:A32NX_FM2_HEALTHY_DISCRETE", "boolean");
    const fm1NavDiscrete = useArinc429Var("L:A32NX_FM1_NAV_DISCRETE");
    const fm2NavDiscrete = useArinc429Var("L:A32NX_FM2_NAV_DISCRETE");
    const [tuningMode, setTuningMode] = (0, import_react19.useState)("");
    (0, import_react19.useEffect)(() => {
      const bitIndex = 10 + index + (adf ? 2 : 0);
      if (!fm1Healthy && !fm2Healthy || !fm1NavDiscrete.isNormalOperation() && !fm2NavDiscrete.isNormalOperation()) {
        setTuningMode("R");
      } else if (fm1NavDiscrete.getBitValueOr(bitIndex, false) || fm2NavDiscrete.getBitValueOr(bitIndex, false)) {
        setTuningMode("M");
      } else {
        setTuningMode("");
      }
    }, [fm1Healthy, fm1NavDiscrete.value, fm1NavDiscrete.ssm, fm2Healthy, fm2NavDiscrete.value, fm2NavDiscrete.ssm]);
    return /* @__PURE__ */ import_react19.default.createElement("text", { x: index === 1 ? 138 : 616, y: 720, fontSize: 20, textDecoration: "underline", fill: "#ffffff" }, tuningMode);
  };
  var VorInfo = ({ index, trueRef, mode }) => {
    const [vorIdent] = useSimVar(`NAV IDENT:${index}`, "string");
    const [vorFrequency] = useSimVar(`NAV ACTIVE FREQUENCY:${index}`, "megahertz");
    const [vorHasDme] = useSimVar(`NAV HAS DME:${index}`, "bool");
    const [dmeDistance] = useSimVar(`NAV DME:${index}`, "nautical miles");
    const [vorAvailable] = useSimVar(`NAV HAS NAV:${index}`, "boolean");
    const [stationDeclination] = useSimVar(`NAV MAGVAR:${index}`, "degrees");
    const [stationLocation] = useSimVar(`NAV VOR LATLONALT:${index}`, "latlonalt");
    const [stationRefTrue, setStationRefTrue] = (0, import_react19.useState)(false);
    const [corrected, setCorrected] = (0, import_react19.useState)(false);
    const [magWarning, setMagWarning] = (0, import_react19.useState)(false);
    const [trueWarning, setTrueWarning] = (0, import_react19.useState)(false);
    (0, import_react19.useEffect)(() => {
      setStationRefTrue(stationLocation.lat > 75 && stationDeclination < Number.EPSILON);
    }, [stationDeclination, stationLocation.lat]);
    (0, import_react19.useEffect)(() => {
      setCorrected(vorAvailable && !!trueRef !== stationRefTrue && mode !== 1 /* ROSE_VOR */ && mode !== 0 /* ROSE_ILS */);
      setMagWarning(vorAvailable && !!trueRef && !stationRefTrue && (mode === 1 /* ROSE_VOR */ || mode === 0 /* ROSE_ILS */));
      setTrueWarning(vorAvailable && !trueRef && stationRefTrue && (mode === 1 /* ROSE_VOR */ || mode === 0 /* ROSE_ILS */));
    }, [trueRef, stationRefTrue, mode, vorAvailable]);
    const x = index === 1 ? 37 : 668;
    const bigLittle = (value, digits2) => {
      const [intPart, decimalPart] = value.toFixed(digits2).split(".", 2);
      return /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, intPart, /* @__PURE__ */ import_react19.default.createElement("tspan", { fontSize: 20 }, ".", decimalPart));
    };
    const freqText = bigLittle(vorFrequency, 2);
    let dmeText = /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, "---");
    if (vorHasDme && dmeDistance > 0) {
      if (dmeDistance > 20) {
        dmeText = /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, dmeDistance.toFixed(0));
      } else {
        dmeText = bigLittle(dmeDistance, 1);
      }
    }
    const path = index === 1 ? "M25,675 L25,680 L37,696 L13,696 L25,680 M25,696 L25,719" : "M749,719 L749,696 L755,696 L743,680 L731,696 L737,696 L737,719 M743,680 L743,675";
    return /* @__PURE__ */ import_react19.default.createElement("g", { className: "GtLayer" }, /* @__PURE__ */ import_react19.default.createElement(
      "path",
      {
        d: path,
        strokeWidth: 2,
        className: vorAvailable && !!trueRef !== stationRefTrue && (mode === 3 /* ARC */ || mode === 2 /* ROSE_NAV */) ? "Magenta" : "White",
        strokeLinejoin: "round",
        strokeLinecap: "round"
      }
    ), /* @__PURE__ */ import_react19.default.createElement("text", { x, y: 692, fontSize: 24, className: "White" }, "VOR", index), (vorAvailable || vorHasDme) && vorFrequency > 1 && /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, /* @__PURE__ */ import_react19.default.createElement("text", { x, y: 722, fontSize: 24, className: "White" }, vorIdent), /* @__PURE__ */ import_react19.default.createElement("text", { x: index === 2 ? x - 54 : x + 61, y: 692, fontSize: 20, className: "Magenta", visibility: corrected ? "inherit" : "hidden" }, "CORR"), /* @__PURE__ */ import_react19.default.createElement("text", { x: index === 2 ? x - 54 : x + 73, y: 692, fontSize: 20, className: "Amber", visibility: magWarning ? "inherit" : "hidden" }, "MAG"), /* @__PURE__ */ import_react19.default.createElement("text", { x: index === 2 ? x - 54 : x + 61, y: 692, fontSize: 20, className: "Amber", visibility: trueWarning ? "inherit" : "hidden" }, "TRUE")), !(vorAvailable || vorHasDme) && vorFrequency > 1 && /* @__PURE__ */ import_react19.default.createElement("text", { x: index === 2 ? x - 26 : x, y: 722, fontSize: 24, className: "White" }, freqText), /* @__PURE__ */ import_react19.default.createElement("g", { transform: `translate(${index === 1 ? -16 : 0})` }, /* @__PURE__ */ import_react19.default.createElement("text", { x: dmeDistance > 20 ? x + 46 : x + 58, y: 759, fontSize: 24, fill: "#00ff00", textAnchor: "end" }, dmeText), /* @__PURE__ */ import_react19.default.createElement("text", { x: x + 66, y: 759, fontSize: 20, fill: "#00ffff" }, "NM")), /* @__PURE__ */ import_react19.default.createElement(TuningModeIndicator, { index }));
  };
  var AdfInfo = ({ index }) => {
    const [adfIdent] = useSimVar(`ADF IDENT:${index}`, "string");
    const [adfFrequency] = useSimVar(`ADF ACTIVE FREQUENCY:${index}`, "kilohertz");
    const [adfAvailable] = useSimVar(`ADF SIGNAL:${index}`, "boolean");
    const x = index === 1 ? 37 : 668;
    const path = index === 1 ? "M31,686 L25,680 L19,686 M25,680 L25,719" : "M749,719 L749,696 L743,690 L737,696 L737,719 M743,690 L743,675";
    return /* @__PURE__ */ import_react19.default.createElement("g", { className: "GtLayer" }, /* @__PURE__ */ import_react19.default.createElement(
      "path",
      {
        d: path,
        strokeWidth: 2,
        className: "Green",
        strokeLinejoin: "round",
        strokeLinecap: "round"
      }
    ), /* @__PURE__ */ import_react19.default.createElement("text", { x, y: 692, fontSize: 24, className: "Green" }, "ADF", index), adfAvailable && /* @__PURE__ */ import_react19.default.createElement("text", { x, y: 722, fontSize: 24, className: "Green" }, adfIdent), !adfAvailable && adfFrequency > 0 && /* @__PURE__ */ import_react19.default.createElement("text", { x, y: 722, fontSize: 24, className: "Green" }, Math.floor(adfFrequency).toFixed(0)), /* @__PURE__ */ import_react19.default.createElement(TuningModeIndicator, { index, adf: true }));
  };
  var RadioNavInfo = ({ index, side, trueRef, mode }) => {
    const [navaidMode] = useSimVar(`L:A32NX_EFIS_${side}_NAVAID_${index}_MODE`, "enum");
    if (navaidMode === 2 /* VOR */) {
      return /* @__PURE__ */ import_react19.default.createElement(VorInfo, { index, trueRef, mode });
    }
    if (navaidMode === 1 /* ADF */) {
      return /* @__PURE__ */ import_react19.default.createElement(AdfInfo, { index });
    }
    return /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null);
  };

  // src/systems/instruments/src/ND/elements/Chrono.tsx
  var import_react20 = __toESM(require_react());
  var getDisplayString = (seconds) => {
    if (seconds >= 3600) {
      return `${Math.floor(seconds / 3600).toString().padStart(2, "0")}H${Math.floor(seconds % 3600 / 60).toString().padStart(2, "0")}'`;
    }
    return `${Math.floor(seconds / 60).toString().padStart(2, "0")}'${Math.floor(seconds % 60).toString().padStart(2, "0")}"`;
  };
  var Chrono = ({ side }) => {
    const [absTime] = useSimVar("E:ABSOLUTE TIME", "Seconds", 200);
    const [prevTime, setPrevTime] = (0, import_react20.useState)(absTime);
    const [elapsedTime, setElapsedTime] = (0, import_react20.useState)(0);
    const [state, setState] = (0, import_react20.useState)("HIDDEN");
    (0, import_react20.useEffect)(() => {
      if (state === "RUNNING") {
        setElapsedTime(
          Math.min(359940, elapsedTime + debouncedTimeDelta(absTime, prevTime))
        );
      }
      setPrevTime(absTime);
    }, [absTime]);
    useInteractionEvent(`A32NX_EFIS_${side}_CHRONO_PUSHED`, () => {
      switch (state) {
        case "HIDDEN":
          setPrevTime(absTime);
          setElapsedTime(0);
          setState("RUNNING");
          break;
        case "RUNNING":
          setState("STOPPED");
          break;
        case "STOPPED":
          setState("HIDDEN");
          break;
        default:
      }
    });
    if (state === "HIDDEN") {
      return /* @__PURE__ */ import_react20.default.createElement(import_react20.default.Fragment, null);
    }
    return /* @__PURE__ */ import_react20.default.createElement("g", { className: "chrono" }, /* @__PURE__ */ import_react20.default.createElement("rect", { x: 0, y: 632, width: 104, height: 30, className: "Grey Fill" }), /* @__PURE__ */ import_react20.default.createElement("text", { x: 8, y: 652, fontSize: 24, className: "Green" }, getDisplayString(elapsedTime)));
  };

  // src/systems/instruments/src/ND/elements/messages/NavigationDisplayMessages.tsx
  var import_react21 = __toESM(require_react());
  var NavigationDisplayMessages = ({ adirsAlign, mode, modeChangeShown, rangeChangeShown }) => {
    const modeValidForGeneralMessages = mode !== 1 /* ROSE_VOR */ && mode !== 0 /* ROSE_ILS */ && (adirsAlign || mode === 4 /* PLAN */);
    const [tcasState] = useSimVar("L:A32NX_TCAS_STATE", "Enum", 200);
    return /* @__PURE__ */ import_react21.default.createElement(import_react21.default.Fragment, null, /* @__PURE__ */ import_react21.default.createElement(
      "text",
      {
        x: 384,
        y: 320,
        className: "Green",
        textAnchor: "middle",
        fontSize: 31,
        visibility: modeChangeShown && !rangeChangeShown && modeValidForGeneralMessages ? "visible" : "hidden"
      },
      "MODE CHANGE"
    ), /* @__PURE__ */ import_react21.default.createElement(
      "text",
      {
        x: 384,
        y: 320,
        className: "Green",
        textAnchor: "middle",
        fontSize: 31,
        visibility: rangeChangeShown && modeValidForGeneralMessages ? "visible" : "hidden"
      },
      "RANGE CHANGE"
    ), tcasState === 2 && (mode === 4 /* PLAN */ || mode === 0 /* ROSE_ILS */ || mode === 1 /* ROSE_VOR */) && !modeChangeShown && !rangeChangeShown && /* @__PURE__ */ import_react21.default.createElement(
      "text",
      {
        x: 384,
        y: 320,
        className: "Amber",
        textAnchor: "middle",
        fontSize: 31
      },
      "TCAS: CHANGE MODE"
    ), tcasState === 3 && (mode === 4 /* PLAN */ || mode === 0 /* ROSE_ILS */ || mode === 1 /* ROSE_VOR */) && !modeChangeShown && !rangeChangeShown && /* @__PURE__ */ import_react21.default.createElement(
      "text",
      {
        x: 384,
        y: 320,
        className: "Red",
        textAnchor: "middle",
        fontSize: 31
      },
      "TCAS: CHANGE MODE"
    ));
  };

  // src/systems/instruments/src/ND/elements/messages/FMMessages.tsx
  var import_react22 = __toESM(require_react());
  var FMMessages = ({ modeIndex, side }) => {
    var _a;
    const [activeMessages, setActiveMessages] = (0, import_react22.useState)([]);
    const [messageFlags] = useSimVar(`L:A32NX_EFIS_${side}_ND_FM_MESSAGE_FLAGS`, "number", 500);
    (0, import_react22.useEffect)(() => {
      var _a2, _b;
      const newActiveMessages = activeMessages.slice();
      for (const message of Object.values(FMMessageTypes)) {
        if ((((_a2 = message.ndFlag) != null ? _a2 : 0) & messageFlags) > 0) {
          if (newActiveMessages.findIndex(({ ndFlag }) => ndFlag === message.ndFlag) === -1) {
            newActiveMessages.push(message);
            newActiveMessages.sort((a, b) => {
              var _a3, _b2;
              return ((_a3 = b.ndPriority) != null ? _a3 : 0) - ((_b2 = a.ndPriority) != null ? _b2 : 0);
            });
          }
        } else if (((_b = message.ndFlag) != null ? _b : 0) > 0) {
          const idx = newActiveMessages.findIndex(({ ndFlag }) => ndFlag === message.ndFlag);
          if (idx !== -1) {
            newActiveMessages.splice(idx, 1);
          }
        }
      }
      setActiveMessages(newActiveMessages);
    }, [messageFlags]);
    if (modeIndex !== 3 /* ARC */ && modeIndex !== 4 /* PLAN */ && modeIndex !== 2 /* ROSE_NAV */ || activeMessages.length < 1) {
      return null;
    }
    return /* @__PURE__ */ import_react22.default.createElement(Layer, { x: 164, y: 713 }, /* @__PURE__ */ import_react22.default.createElement("rect", { x: 0, y: 0, width: 440, height: 30, className: "White BackgroundFill", strokeWidth: 1.75 }), /* @__PURE__ */ import_react22.default.createElement(
      "text",
      {
        x: 420 / 2,
        y: 25,
        className: `${activeMessages[activeMessages.length - 1].color} MiddleAlign`,
        textAnchor: "middle",
        fontSize: 25
      },
      `${(_a = activeMessages[activeMessages.length - 1].text) != null ? _a : activeMessages[activeMessages.length - 1].efisText}`
    ), activeMessages.length > 1 && /* @__PURE__ */ import_react22.default.createElement("path", { d: "M428,2 L428,20 L424,20 L430,28 L436,20 L432,20 L432,2 L428,2", className: "Green Fill" }));
  };

  // src/systems/instruments/src/ND/elements/messages/TcasWxrMessages.tsx
  var import_react23 = __toESM(require_react());
  var TcasWxrMessages = ({ modeIndex }) => {
    let leftMessage;
    let rightMessage;
    const [tcasOnly] = useSimVar("L:A32NX_TCAS_TA_ONLY", "boolean", 200);
    const [tcasFault] = useSimVar("L:A32NX_TCAS_FAULT", "boolean", 200);
    if (tcasFault) {
      leftMessage = { text: "TCAS", color: "Amber" };
    } else if (tcasOnly) {
      leftMessage = { text: "TA ONLY", color: "White" };
    }
    if (modeIndex !== 3 /* ARC */ && modeIndex !== 2 /* ROSE_NAV */ && modeIndex !== 1 /* ROSE_VOR */ && modeIndex !== 0 /* ROSE_ILS */ || !leftMessage && !rightMessage) {
      return null;
    }
    const y = modeIndex === 1 /* ROSE_VOR */ || modeIndex === 0 /* ROSE_ILS */ ? 713 : 684;
    return /* @__PURE__ */ import_react23.default.createElement(Layer, { x: 164, y }, (modeIndex === 3 /* ARC */ || modeIndex === 2 /* ROSE_NAV */) && /* @__PURE__ */ import_react23.default.createElement("rect", { x: 0, y: 0, width: 440, height: 59, className: "BackgroundFill", stroke: "none" }), /* @__PURE__ */ import_react23.default.createElement("rect", { x: 0, y: 0, width: 440, height: 30, className: "White BackgroundFill", strokeWidth: 1.75 }), leftMessage && /* @__PURE__ */ import_react23.default.createElement(
      "text",
      {
        x: 8,
        y: 25,
        className: `${leftMessage.color}`,
        textAnchor: "start",
        fontSize: 25
      },
      leftMessage.text
    ), rightMessage && /* @__PURE__ */ import_react23.default.createElement(
      "text",
      {
        x: 425,
        y: 25,
        className: `${rightMessage.color}`,
        textAnchor: "end",
        fontSize: 25
      },
      rightMessage.text
    ));
  };

  // src/systems/instruments/src/ND/pages/PlanMode.tsx
  var import_react24 = __toESM(require_react());
  var PlanMode = ({ side, symbols, adirsAlign, rangeSetting, ppos, mapHidden }) => {
    const [planCentreLat] = useSimVar("L:A32NX_SELECTED_WAYPOINT_LAT", "Degrees");
    const [planCentreLong] = useSimVar("L:A32NX_SELECTED_WAYPOINT_LONG", "Degrees");
    const trueHeading = useArinc429Var("L:A32NX_ADIRS_IR_1_TRUE_HEADING");
    const irMaint = useArinc429Var("L:A32NX_ADIRS_IR_1_MAINT_WORD");
    const [trueRefPb] = useSimVar("L:A32NX_PUSH_TRUE_REF", "bool");
    const [trueRef, setTrueRef] = (0, import_react24.useState)(false);
    const [mapParams] = (0, import_react24.useState)(new MapParameters());
    (0, import_react24.useEffect)(() => {
      mapParams.compute({ lat: planCentreLat, long: planCentreLong }, 0, rangeSetting / 2, 250, 0);
    }, [planCentreLat, planCentreLong, rangeSetting]);
    (0, import_react24.useEffect)(() => {
      setTrueRef((irMaint.getBitValueOr(15, false) || trueRefPb) && !irMaint.getBitValueOr(2, false));
    }, [irMaint.value, trueRefPb]);
    return /* @__PURE__ */ import_react24.default.createElement(import_react24.default.Fragment, null, /* @__PURE__ */ import_react24.default.createElement(Overlay2, { rangeSetting }), /* @__PURE__ */ import_react24.default.createElement("g", { id: "map", clipPath: "url(#plan-mode-map-clip)", visibility: mapHidden ? "hidden" : "visible" }, /* @__PURE__ */ import_react24.default.createElement(
      FlightPlan2,
      {
        x: 384,
        y: 384,
        side,
        range: rangeSetting,
        symbols,
        mapParams,
        mapParamsVersion: mapParams.version,
        debug: false
      }
    )), adirsAlign && !mapHidden && mapParams.valid && /* @__PURE__ */ import_react24.default.createElement(Plane2, { location: ppos, heading: trueHeading.value, mapParams }), /* @__PURE__ */ import_react24.default.createElement(ToWaypointIndicator, { side, trueRef }), /* @__PURE__ */ import_react24.default.createElement(CrossTrack, { x: 44, y: 690, side, isPlanMode: true }));
  };
  var Overlay2 = (0, import_react24.memo)(({ rangeSetting }) => /* @__PURE__ */ import_react24.default.createElement(import_react24.default.Fragment, null, /* @__PURE__ */ import_react24.default.createElement("clipPath", { id: "plan-mode-map-clip" }, /* @__PURE__ */ import_react24.default.createElement("polygon", { points: "45,112 140,112 280,56 488,56 628,112 723,112 723,720 114,720 114,633 45,633" })), /* @__PURE__ */ import_react24.default.createElement("g", { strokeWidth: 3 }, /* @__PURE__ */ import_react24.default.createElement("circle", { cx: 384, cy: 384, r: 250, className: "White" }), /* @__PURE__ */ import_react24.default.createElement("path", { d: "M259,384a125,125 0 1,0 250,0a125,125 0 1,0 -250,0", strokeDasharray: "14 13", className: "White" }), /* @__PURE__ */ import_react24.default.createElement("text", { x: 310, y: 474, className: "Cyan", fontSize: 22 }, rangeSetting / 4), /* @__PURE__ */ import_react24.default.createElement("text", { x: 212, y: 556, className: "Cyan", fontSize: 22 }, rangeSetting / 2), /* @__PURE__ */ import_react24.default.createElement("text", { x: 384, y: 170, className: "White", fontSize: 25, textAnchor: "middle", alignmentBaseline: "central" }, "N"), /* @__PURE__ */ import_react24.default.createElement("path", { d: "M384,141.5 L390,151 L378,151 L384,141.5", fill: "white", stroke: "none" }), /* @__PURE__ */ import_react24.default.createElement("text", { x: 598, y: 384, className: "White", fontSize: 25, textAnchor: "middle", alignmentBaseline: "central" }, "E"), /* @__PURE__ */ import_react24.default.createElement("path", { d: "M626.2,384 L617,390 L617,378 L626.5,384", fill: "white", stroke: "none" }), /* @__PURE__ */ import_react24.default.createElement("text", { x: 384, y: 598, className: "White", fontSize: 25, textAnchor: "middle", alignmentBaseline: "central" }, "S"), /* @__PURE__ */ import_react24.default.createElement("path", { d: "M384,626.5 L390,617 L378,617 L384,626.5", fill: "white", stroke: "none" }), /* @__PURE__ */ import_react24.default.createElement("text", { x: 170, y: 384, className: "White", fontSize: 25, textAnchor: "middle", alignmentBaseline: "central" }, "W"), /* @__PURE__ */ import_react24.default.createElement("path", { d: "M141.5,384 L151,390 L151,378 L141.5,384", fill: "white", stroke: "none" }))));
  var Plane2 = ({ location, heading, mapParams }) => {
    const [x, y] = mapParams.coordinatesToXYy(location);
    const rotation = mapParams.rotation(heading);
    return /* @__PURE__ */ import_react24.default.createElement("g", { transform: `translate(${x} ${y}) rotate(${rotation} 384 384)` }, /* @__PURE__ */ import_react24.default.createElement("path", { id: "plane-shadow", d: "M 384 358 l 0 75 m -37 -49 l 74 0 m -50 36 l 26 0", className: "shadow", strokeWidth: 5.5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react24.default.createElement("path", { id: "plane", d: "M 384 358 l 0 75 m -37 -49 l 74 0 m -50 36 l 26 0", className: "Yellow", strokeWidth: 5, strokeLinejoin: "round", strokeLinecap: "round" }));
  };

  // src/systems/instruments/src/ND/pages/RoseMode.tsx
  var import_react25 = __toESM(require_react());
  var RoseMode = ({ symbols, adirsAlign, rangeSetting, mode, side, ppos, mapHidden, trueRef }) => {
    const magHeading = useArinc429Var("L:A32NX_ADIRS_IR_1_HEADING");
    const magTrack = useArinc429Var("L:A32NX_ADIRS_IR_1_TRACK");
    const trueHeading = useArinc429Var("L:A32NX_ADIRS_IR_1_TRUE_HEADING");
    const trueTrack = useArinc429Var("L:A32NX_ADIRS_IR_1_TRUE_TRACK");
    const [tcasMode] = useSimVar("L:A32NX_SWITCH_TCAS_Position", "number");
    const [selectedHeading] = useSimVar("L:A32NX_FCU_HEADING_SELECTED", "degrees");
    const [lsCourse] = useSimVar("L:A32NX_FM_LS_COURSE", "number");
    const [lsDisplayed] = useSimVar(`L:BTN_LS_${side === "L" ? 1 : 2}_FILTER_ACTIVE`, "bool");
    const [fmaLatMode] = useSimVar("L:A32NX_FMA_LATERAL_MODE", "enum", 200);
    const [armedLateralBitmask] = useSimVar("L:A32NX_FMA_LATERAL_ARMED", "enum", 200);
    const [groundSpeed] = useSimVar("GPS GROUND SPEED", "Meters per second", 200);
    const heading = Number(MathUtils.fastToFixed(trueRef ? trueHeading.value : magHeading.value, 2));
    const track = Number(MathUtils.fastToFixed(trueRef ? trueTrack.value : magTrack.value, 2));
    const [mapParams] = (0, import_react25.useState)(() => {
      const params = new MapParameters();
      params.compute(ppos, 0, rangeSetting / 2, 250, trueHeading.value);
      return params;
    });
    (0, import_react25.useEffect)(() => {
      mapParams.compute(ppos, 0, rangeSetting / 2, 250, trueHeading.value);
    }, [ppos.lat, ppos.long, trueHeading.value, rangeSetting].map((n) => MathUtils.fastToFixed(n, 6)));
    if (adirsAlign) {
      return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
        Overlay3,
        {
          heading,
          rangeSetting,
          tcasMode
        }
      ), /* @__PURE__ */ import_react25.default.createElement("g", { id: "map", clipPath: "url(#rose-mode-map-clip)" }, mode === 2 /* ROSE_NAV */ && /* @__PURE__ */ import_react25.default.createElement("g", { visibility: mapHidden ? "hidden" : "visible" }, /* @__PURE__ */ import_react25.default.createElement(
        FlightPlan2,
        {
          x: 384,
          y: 384,
          side,
          range: rangeSetting,
          symbols,
          mapParams,
          mapParamsVersion: mapParams.version,
          debug: false
        }
      ), (fmaLatMode === 0 /* NONE */ || fmaLatMode === 10 /* HDG */ || fmaLatMode === 11 /* TRACK */) && !isArmed(armedLateralBitmask, 0 /* NAV */) && /* @__PURE__ */ import_react25.default.createElement(TrackLine, { x: 384, y: 384, heading, track, mapParams, groundSpeed, symbols, ndRange: rangeSetting })), /* @__PURE__ */ import_react25.default.createElement(RadioNeedle, { index: 1, side, displayMode: mode, centreHeight: 384, trueRef }), /* @__PURE__ */ import_react25.default.createElement(RadioNeedle, { index: 2, side, displayMode: mode, centreHeight: 384, trueRef })), mode === 1 /* ROSE_VOR */ && /* @__PURE__ */ import_react25.default.createElement(VorCaptureOverlay, { heading, side }), mode === 0 /* ROSE_ILS */ && /* @__PURE__ */ import_react25.default.createElement(IlsCaptureOverlay, { heading, side }), mode === 2 /* ROSE_NAV */ && /* @__PURE__ */ import_react25.default.createElement(ToWaypointIndicator, { side, trueRef }), mode === 1 /* ROSE_VOR */ && /* @__PURE__ */ import_react25.default.createElement(VorInfo2, { side }), mode === 0 /* ROSE_ILS */ && /* @__PURE__ */ import_react25.default.createElement(IlsInfo, { side }), /* @__PURE__ */ import_react25.default.createElement(TopMessages, { side, ppos, trueTrack, trueRef }), /* @__PURE__ */ import_react25.default.createElement(TrackBug2, { heading, track }), mode === 2 /* ROSE_NAV */ && lsDisplayed && /* @__PURE__ */ import_react25.default.createElement(LsCourseBug2, { heading, lsCourse }), /* @__PURE__ */ import_react25.default.createElement(SelectedHeadingBug2, { heading, selected: selectedHeading }), mode === 0 /* ROSE_ILS */ && /* @__PURE__ */ import_react25.default.createElement(GlideSlope, null), /* @__PURE__ */ import_react25.default.createElement(Plane3, null), mode === 2 /* ROSE_NAV */ && /* @__PURE__ */ import_react25.default.createElement(CrossTrack, { x: 390, y: 407, side }), /* @__PURE__ */ import_react25.default.createElement("g", { clipPath: "url(#rose-mode-tcas-clip)" }, /* @__PURE__ */ import_react25.default.createElement(Traffic, { mode, mapParams })));
    }
    return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(MapFailOverlay2, { rangeSetting }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 681, y: 28, fontSize: 25, className: "White", textAnchor: "end" }, "PPOS"));
  };
  var Overlay3 = ({ heading, rangeSetting, tcasMode }) => /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(RoseModeOverlayDefs, null), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotateX(0deg)", stroke: "white", strokeWidth: 3, fill: "none" }, /* @__PURE__ */ import_react25.default.createElement("g", { clipPath: "url(#arc-mode-overlay-clip-4)" }, /* @__PURE__ */ import_react25.default.createElement("g", { transform: `rotate(${MathUtils.diffAngle(heading, 0)} 384 384)` }, /* @__PURE__ */ import_react25.default.createElement(RoseModeOverlayHeadingRing, null))), (tcasMode === 0 || rangeSetting > 10) && /* @__PURE__ */ import_react25.default.createElement(
    "path",
    {
      d: "M 509 384 A 125 125 0 0 1 259 384 M 259 384 A 125 125 180 0 1 509 384",
      strokeDasharray: "15 10",
      strokeDashoffset: "-4.2"
    }
  ), tcasMode > 0 && rangeSetting === 10 && /* @__PURE__ */ import_react25.default.createElement("g", null, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(0 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(30 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(60 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(90 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(120 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(150 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(180 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(210 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(240 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(270 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(300 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 264, y2: 254, className: "rounded White", transform: "rotate(330 384 384)" })), tcasMode > 0 && rangeSetting === 20 && /* @__PURE__ */ import_react25.default.createElement("g", null, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(0 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(30 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(60 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(90 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(120 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(150 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(180 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(210 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(240 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(270 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(300 384 384)" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, x2: 384, y1: 327, y2: 317, className: "rounded White", transform: "rotate(330 384 384)" })), /* @__PURE__ */ import_react25.default.createElement("text", { x: 212, y: 556, className: "Cyan", fontSize: 22 }, rangeSetting / 2), /* @__PURE__ */ import_react25.default.createElement("text", { x: 310, y: 474, className: "Cyan", fontSize: 22 }, rangeSetting / 4), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(45 384 384)", fill: "white" }), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(90 384 384)", fill: "white" }), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(135 384 384)", fill: "white" }), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(180 384 384)", fill: "white" }), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(225 384 384)", fill: "white" }), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(270 384 384)", fill: "white" }), /* @__PURE__ */ import_react25.default.createElement("path", { d: "M384,132 L379,123 L389,123 L384,132", transform: "rotate(315 384 384)", fill: "white" })));
  var RoseModeOverlayDefs = (0, import_react25.memo)(() => /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement("clipPath", { id: "rose-mode-map-clip" }, /* @__PURE__ */ import_react25.default.createElement("path", { d: "M45,155 L282,155 a250,250 0 0 1 204,0 L723,155 L723,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L45,625 L45,155" })), /* @__PURE__ */ import_react25.default.createElement("clipPath", { id: "rose-mode-wx-terr-clip" }, /* @__PURE__ */ import_react25.default.createElement("path", { d: "M45,155 L282,155 a250,250 0 0 1 204,0 L723,155 L723,384 L45,384 L45,155" })), /* @__PURE__ */ import_react25.default.createElement("clipPath", { id: "rose-mode-tcas-clip" }, /* @__PURE__ */ import_react25.default.createElement("path", { d: "M45,155 L282,155 a250,250 0 0 1 204,0 L723,155 L723,562 L648,562 L591,625 L591,768 L174,768 L174,683 L122,625 L45,625 L45,155" })), /* @__PURE__ */ import_react25.default.createElement("path", { name: "rose-mode-bottom-left-map-area", d: "M45,625 L122,625 L174,683 L174,768 L0,768 L0,0 L45,0L45,625", className: "nd-inverted-map-area" }), /* @__PURE__ */ import_react25.default.createElement("path", { name: "rose-mode-bottom-right-map-area", d: "M591,768 L591,626 L648,562 L723,562 L723,0 L768,0 L768,768 L591,769", className: "nd-inverted-map-area" }), /* @__PURE__ */ import_react25.default.createElement("path", { name: "rose-mode-top-map-area", d: "M45,0 L45,155, L282,155 a250,250 0 0 1 204,0 L723,155 L723,0 L45,0", className: "nd-inverted-map-area" })));
  var RoseModeOverlayHeadingRing = (0, import_react25.memo)(() => /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 384, cy: 384, r: 250 }), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(0 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "0")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(5 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(10 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(15 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(20 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(25 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(30 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "3")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(35 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(40 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(45 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(50 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(55 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(60 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "6")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(65 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(70 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(75 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(80 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(85 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(90 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "9")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(95 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(100 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(105 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(110 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(115 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(120 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "12")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(125 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(130 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(135 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(140 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(145 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(150 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "15")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(155 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(160 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(165 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(170 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(175 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(180 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "18")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(185 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(190 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(195 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(200 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(205 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(210 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "21")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(215 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(220 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(225 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(230 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(235 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(240 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "24")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(245 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(250 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(255 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(260 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(265 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(270 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "27")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(275 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(280 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(285 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(290 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(295 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(300 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "30")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(305 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(310 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(315 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(320 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(325 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(330 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 }), /* @__PURE__ */ import_react25.default.createElement("text", { x: 384, y: 112, textAnchor: "middle", fontSize: 22, fill: "white", stroke: "none" }, "33")), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(335 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(340 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(345 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(350 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 122, strokeWidth: 2.5 })), /* @__PURE__ */ import_react25.default.createElement("g", { transform: "rotate(355 384 384)" }, /* @__PURE__ */ import_react25.default.createElement("line", { x1: 384, y1: 134, x2: 384, y2: 128, strokeWidth: 2.5 }))));
  var MapFailOverlay2 = (0, import_react25.memo)(({ rangeSetting }) => /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement("text", { className: "Red", fontSize: 30, textAnchor: "middle", x: 384, y: 241 }, "HDG"), /* @__PURE__ */ import_react25.default.createElement("text", { className: "Red", fontSize: 30, textAnchor: "middle", x: 384, y: 320.6 }, "MAP NOT AVAIL"), /* @__PURE__ */ import_react25.default.createElement("clipPath", { id: "rose-mode-map-clip" }, /* @__PURE__ */ import_react25.default.createElement("path", { d: "M-339,-229 L-102,-229 a250,250 0 0 1 204,0 L339,-229 L339,178 L264,178 L207,241 L207,384 L-210,384 L-210,299 L-262,241 L-339,241 L-339,-229" })), /* @__PURE__ */ import_react25.default.createElement("g", { stroke: "white", strokeWidth: 3, fill: "none" }, /* @__PURE__ */ import_react25.default.createElement("g", { clipPath: "url(#arc-mode-overlay-clip-4)" }, /* @__PURE__ */ import_react25.default.createElement("g", null, /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 384, cy: 384, r: 250, stroke: "red" }))), /* @__PURE__ */ import_react25.default.createElement(
    "path",
    {
      d: "M 509 384 A 125 125 0 0 1 259 384 M 259 384 A 125 125 180 0 1 509 384",
      stroke: "red"
    }
  )), /* @__PURE__ */ import_react25.default.createElement("text", { x: 212, y: 556, className: "Cyan", fontSize: 22 }, rangeSetting / 2), /* @__PURE__ */ import_react25.default.createElement("text", { x: 310, y: 474, className: "Cyan", fontSize: 22 }, rangeSetting / 4)));
  var VorCaptureOverlay = ({ heading, side }) => {
    const index = side === "L" ? 1 : 2;
    const [course] = useSimVar(`NAV OBS:${index}`, "degrees");
    const [vorFrequency] = useSimVar(`NAV ACTIVE FREQUENCY:${index}`, "megahertz");
    const [courseDeviation] = useSimVar(`NAV RADIAL ERROR:${index}`, "degrees", 20);
    const [available] = useSimVar(`NAV HAS NAV:${index}`, "number");
    const [toward, setToward] = (0, import_react25.useState)(true);
    const [cdiPx, setCdiPx] = (0, import_react25.useState)(12);
    (0, import_react25.useEffect)(() => {
      let cdiDegrees;
      if (Math.abs(courseDeviation) <= 90) {
        cdiDegrees = courseDeviation;
        setToward(true);
      } else {
        cdiDegrees = Math.sign(courseDeviation) * -Avionics.Utils.diffAngle(180, Math.abs(courseDeviation));
        setToward(false);
      }
      setCdiPx(Math.min(12, Math.max(-12, cdiDegrees)) * 74 / 5);
    }, [courseDeviation.toFixed(2)]);
    const vorCourseValid = vorFrequency > 0;
    return /* @__PURE__ */ import_react25.default.createElement("g", { transform: `rotate(${course - heading} 384 384)`, stroke: "white", strokeWidth: 3, fill: "none" }, /* @__PURE__ */ import_react25.default.createElement("g", { id: "vor-deviation-scale" }, /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 236, cy: 384, r: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 310, cy: 384, r: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 458, cy: 384, r: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 532, cy: 384, r: 5 })), vorCourseValid && /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
        className: "rounded shadow",
        id: "vor-course-pointer-shadow",
        strokeWidth: 4.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
        className: "rounded Cyan",
        id: "vor-course-pointer",
        strokeWidth: 4
      }
    )), available && /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M372,322 L384,304 L396,322",
        className: "rounded shadow",
        transform: `translate(${cdiPx}, ${toward ? 0 : 160}) rotate(${toward ? 0 : 180} 384 304)`,
        id: "vor-deviation-direction-shadow",
        strokeWidth: 4.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,304 L384,464",
        className: "rounded shadow",
        transform: `translate(${cdiPx}, 0)`,
        id: "vor-deviation-shadow",
        strokeWidth: 4.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M372,322 L384,304 L396,322",
        className: "rounded Cyan",
        transform: `translate(${cdiPx}, ${toward ? 0 : 160}) rotate(${toward ? 0 : 180} 384 304)`,
        id: "vor-deviation-direction",
        strokeWidth: 4
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,304 L384,464",
        className: "rounded Cyan",
        transform: `translate(${cdiPx}, 0)`,
        id: "vor-deviation",
        strokeWidth: 4
      }
    )));
  };
  var IlsCaptureOverlay = (0, import_react25.memo)(({ heading, side }) => {
    const index = side === "L" ? 2 : 1;
    const [course] = useSimVar(`NAV OBS:${index + 2}`, "degrees");
    const [ilsFrequency] = useSimVar(`NAV ACTIVE FREQUENCY:${index + 2}`, "megahertz");
    const [courseDeviation] = useSimVar("L:A32NX_RADIO_RECEIVER_LOC_DEVIATION", "number", 20);
    const [available] = useSimVar("L:A32NX_RADIO_RECEIVER_LOC_IS_VALID", "number");
    const [cdiPx, setCdiPx] = (0, import_react25.useState)(12);
    (0, import_react25.useEffect)(() => {
      const dots = Math.max(-2, Math.min(2, courseDeviation / 0.8));
      setCdiPx(dots * 74);
    }, [courseDeviation.toFixed(2)]);
    const ilsCourseValid = ilsFrequency >= 108 && ilsFrequency <= 112;
    return /* @__PURE__ */ import_react25.default.createElement("g", { transform: `rotate(${course - heading} 384 384)`, stroke: "white", strokeWidth: 3, fill: "none" }, /* @__PURE__ */ import_react25.default.createElement("g", { id: "ils-deviation-scale" }, /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 236, cy: 384, r: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 310, cy: 384, r: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 458, cy: 384, r: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 532, cy: 384, r: 5 })), ilsCourseValid && /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
        className: "rounded shadow",
        id: "ils-course-pointer-shadow",
        strokeWidth: 4.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M352,256 L416,256 M384,134 L384,294 M384,474 L384,634",
        className: "rounded Magenta",
        id: "ils-course-pointer",
        strokeWidth: 4
      }
    )), available && /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,304 L384,464",
        className: "rounded shadow",
        transform: `translate(${cdiPx}, 0)`,
        id: "ils-deviation-shadow",
        strokeWidth: 4.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,304 L384,464",
        className: "rounded Magenta",
        transform: `translate(${cdiPx}, 0)`,
        id: "ils-deviation",
        strokeWidth: 4
      }
    )));
  });
  var Plane3 = () => /* @__PURE__ */ import_react25.default.createElement("g", null, /* @__PURE__ */ import_react25.default.createElement("line", { id: "lubber-shadow", x1: 384, y1: 116, x2: 384, y2: 152, className: "shadow", strokeWidth: 5.5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react25.default.createElement("line", { id: "lubber", x1: 384, y1: 116, x2: 384, y2: 152, className: "Yellow", strokeWidth: 5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react25.default.createElement("path", { id: "plane-shadow", d: "M 384 358 l 0 75 m -37 -49 l 74 0 m -50 36 l 26 0", className: "shadow", strokeWidth: 5.5, strokeLinejoin: "round", strokeLinecap: "round" }), /* @__PURE__ */ import_react25.default.createElement("path", { id: "plane", d: "M 384 358 l 0 75 m -37 -49 l 74 0 m -50 36 l 26 0", className: "Yellow", strokeWidth: 5, strokeLinejoin: "round", strokeLinecap: "round" }));
  var TrackBug2 = (0, import_react25.memo)(({ heading, track }) => {
    const diff = getSmallestAngle(track, heading);
    return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,134 L379,143 L384,152 L389,143 L384,134",
        transform: `rotate(${diff} 384 384)`,
        className: "rounded shadow",
        strokeWidth: 3.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,134 L379,143 L384,152 L389,143 L384,134",
        transform: `rotate(${diff} 384 384)`,
        className: "rounded Green",
        strokeWidth: 3
      }
    ));
  });
  var LsCourseBug2 = ({ heading, lsCourse }) => {
    if (lsCourse < 0) {
      return null;
    }
    const diff = getSmallestAngle(lsCourse, heading);
    return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,128 L384,96 M376,120 L392,120",
        transform: `rotate(${diff} 384 384)`,
        className: "rounded shadow",
        strokeWidth: 2.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M384,128 L384,96 M376,120 L392,120",
        transform: `rotate(${diff} 384 384)`,
        className: "rounded Magenta",
        strokeWidth: 2
      }
    ));
  };
  var SelectedHeadingBug2 = ({ heading, selected }) => {
    if (selected < 0) {
      return null;
    }
    const diff = getSmallestAngle(selected, heading);
    return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M380,132 L372,114 L396,114 L388,132",
        transform: `rotate(${diff} 384 384)`,
        className: "rounded shadow",
        strokeWidth: 3.5
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M380,132 L372,114 L396,114 L388,132",
        transform: `rotate(${diff} 384 384)`,
        className: "rounded Cyan",
        strokeWidth: 3
      }
    ));
  };
  var VorInfo2 = (0, import_react25.memo)(({ side }) => {
    const index = side === "R" ? 2 : 1;
    const [vorIdent] = useSimVar(`NAV IDENT:${index}`, "string");
    const [vorFrequency] = useSimVar(`NAV ACTIVE FREQUENCY:${index}`, "megahertz");
    const [vorCourse] = useSimVar(`NAV OBS:${index}`, "degrees");
    const [fm1Healthy] = useSimVar("L:A32NX_FM1_HEALTHY_DISCRETE", "boolean");
    const [fm2Healthy] = useSimVar("L:A32NX_FM2_HEALTHY_DISCRETE", "boolean");
    const fm1NavDiscrete = useArinc429Var("L:A32NX_FM1_NAV_DISCRETE");
    const fm2NavDiscrete = useArinc429Var("L:A32NX_FM2_NAV_DISCRETE");
    const [tuningMode, setTuningMode] = (0, import_react25.useState)("");
    const [freqInt, freqDecimal] = vorFrequency.toFixed(2).split(".", 2);
    (0, import_react25.useEffect)(() => {
      const bitIndex = 10 + index;
      if (!fm1Healthy && !fm2Healthy || !fm1NavDiscrete.isNormalOperation() && !fm2NavDiscrete.isNormalOperation()) {
        setTuningMode("R");
      } else if (fm1NavDiscrete.getBitValueOr(bitIndex, false) || fm2NavDiscrete.getBitValueOr(bitIndex, false)) {
        setTuningMode("M");
      } else {
        setTuningMode("");
      }
    }, [fm1Healthy, fm1NavDiscrete.value, fm1NavDiscrete.ssm, fm2Healthy, fm2NavDiscrete.value, fm2NavDiscrete.ssm]);
    const vorFrequencyValid = vorFrequency > 0;
    const vorCourseValid = vorFrequencyValid;
    return /* @__PURE__ */ import_react25.default.createElement(Layer, { x: 748, y: 28 }, /* @__PURE__ */ import_react25.default.createElement("text", { x: -102, y: 0, fontSize: 25, className: "White", textAnchor: "end" }, "VOR", index), /* @__PURE__ */ import_react25.default.createElement("text", { x: 0, y: 0, fontSize: 25, className: "White", textAnchor: "end" }, vorFrequencyValid ? freqInt : "---", /* @__PURE__ */ import_react25.default.createElement("tspan", { fontSize: 20 }, ".", vorFrequencyValid ? freqDecimal : "--")), /* @__PURE__ */ import_react25.default.createElement("text", { x: -56, y: 30, fontSize: 25, className: "White", textAnchor: "end" }, "CRS"), /* @__PURE__ */ import_react25.default.createElement("text", { x: 20, y: 30, fontSize: 25, className: "Cyan", textAnchor: "end" }, vorCourseValid ? `${Math.round(vorCourse)}`.padStart(3, "0") : "---", "\xB0"), /* @__PURE__ */ import_react25.default.createElement("text", { x: -80, y: 58, fontSize: 20, className: "White", textAnchor: "end", textDecoration: "underline" }, tuningMode), /* @__PURE__ */ import_react25.default.createElement("text", { x: 0, y: 60, fontSize: 25, className: "White", textAnchor: "end" }, vorIdent));
  });
  var IlsInfo = (0, import_react25.memo)(({ side }) => {
    const index = side === "R" ? 1 : 2;
    const [ilsIdent] = useSimVar(`NAV IDENT:${index + 2}`, "string");
    const [ilsFrequency] = useSimVar(`NAV ACTIVE FREQUENCY:${index + 2}`, "megahertz");
    const [ilsCourse] = useSimVar(`NAV OBS:${index + 2}`, "degrees");
    const [fm1Healthy] = useSimVar("L:A32NX_FM1_HEALTHY_DISCRETE", "boolean");
    const [fm2Healthy] = useSimVar("L:A32NX_FM2_HEALTHY_DISCRETE", "boolean");
    const fm1NavDiscrete = useArinc429Var("L:A32NX_FM1_NAV_DISCRETE");
    const fm2NavDiscrete = useArinc429Var("L:A32NX_FM2_NAV_DISCRETE");
    const [tuningMode, setTuningMode] = (0, import_react25.useState)("");
    const [freqInt, freqDecimal] = ilsFrequency.toFixed(2).split(".", 2);
    (0, import_react25.useEffect)(() => {
      const bitIndex = 14 + index;
      if (!fm1Healthy && !fm2Healthy || !fm1NavDiscrete.isNormalOperation() && !fm2NavDiscrete.isNormalOperation()) {
        setTuningMode("R");
      } else if (fm1NavDiscrete.getBitValueOr(bitIndex, false) || fm2NavDiscrete.getBitValueOr(bitIndex, false)) {
        setTuningMode("M");
      } else {
        setTuningMode("");
      }
    }, [fm1Healthy, fm1NavDiscrete.value, fm1NavDiscrete.ssm, fm2Healthy, fm2NavDiscrete.value, fm2NavDiscrete.ssm]);
    const ilsFrequencyValid = ilsFrequency >= 108 && ilsFrequency <= 112;
    const ilsCourseValid = ilsFrequencyValid;
    return /* @__PURE__ */ import_react25.default.createElement(Layer, { x: 748, y: 28 }, /* @__PURE__ */ import_react25.default.createElement("text", { x: -102, y: 0, fontSize: 25, className: "White", textAnchor: "end" }, "ILS", index), /* @__PURE__ */ import_react25.default.createElement("text", { x: 0, y: 0, fontSize: 25, className: "Magenta", textAnchor: "end" }, ilsFrequencyValid ? freqInt : "---", /* @__PURE__ */ import_react25.default.createElement("tspan", { fontSize: 20 }, ".", ilsFrequencyValid ? freqDecimal : "--")), /* @__PURE__ */ import_react25.default.createElement("text", { x: -56, y: 30, fontSize: 25, className: "White", textAnchor: "end" }, "CRS"), /* @__PURE__ */ import_react25.default.createElement("text", { x: 20, y: 30, fontSize: 25, className: "Magenta", textAnchor: "end" }, ilsCourseValid ? `${Math.round(ilsCourse)}`.padStart(3, "0") : "---", "\xB0"), /* @__PURE__ */ import_react25.default.createElement("text", { x: -80, y: 58, fontSize: 20, className: "White", textAnchor: "end", textDecoration: "underline" }, tuningMode), /* @__PURE__ */ import_react25.default.createElement("text", { x: 0, y: 60, fontSize: 25, className: "Magenta", textAnchor: "end" }, ilsIdent));
  });
  var GlideSlope = () => {
    const [gsDeviation] = useSimVar("L:A32NX_RADIO_RECEIVER_GS_DEVIATION", "number");
    const [gsAvailable] = useSimVar("L:A32NX_RADIO_RECEIVER_GS_IS_VALID", "number");
    const deviationPx = gsDeviation / 0.8 * 128;
    return /* @__PURE__ */ import_react25.default.createElement(import_react25.default.Fragment, null, /* @__PURE__ */ import_react25.default.createElement(Layer, { x: 750, y: 384 }, /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 0, cy: -128, r: 4, strokeWidth: 2.5, className: "White" }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 0, cy: -64, r: 4, strokeWidth: 2.5, className: "White" }), /* @__PURE__ */ import_react25.default.createElement("line", { x1: -12, x2: 12, y1: 0, y2: 0, className: "Yellow", strokeWidth: 5 }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 0, cy: 64, r: 4, strokeWidth: 2.5, className: "White" }), /* @__PURE__ */ import_react25.default.createElement("circle", { cx: 0, cy: 128, r: 4, strokeWidth: 2.5, className: "White" })), /* @__PURE__ */ import_react25.default.createElement(Layer, { x: 750, y: 384 }, /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M10,0 L0,-16 L-10,0",
        transform: `translate(0 ${Math.max(-128, deviationPx)})`,
        className: "rounded Magenta",
        strokeWidth: 2.5,
        visibility: gsAvailable && deviationPx < 128 ? "visible" : "hidden"
      }
    ), /* @__PURE__ */ import_react25.default.createElement(
      "path",
      {
        d: "M-10,0 L0,16 L10,0",
        transform: `translate(0 ${Math.min(128, deviationPx)})`,
        className: "rounded Magenta",
        strokeWidth: 2.5,
        visibility: gsAvailable && deviationPx > -128 ? "visible" : "hidden"
      }
    )));
  };

  // src/systems/instruments/src/ND/elements/LnavStatus.tsx
  var import_react26 = __toESM(require_react());
  var LnavStatus = () => {
    const [strings, setStrings] = (0, import_react26.useState)([]);
    useCoherentEvent("A32NX_FM_DEBUG_LNAV_STATUS", (message) => {
      setStrings(message.split("\n"));
    });
    return /* @__PURE__ */ import_react26.default.createElement(Layer, { x: 50, y: 280 }, strings.map((line, i) => /* @__PURE__ */ import_react26.default.createElement("text", { x: 0, y: i * 25, fill: "magenta", fontSize: 20 }, line)));
  };

  // src/systems/instruments/src/ND/index.tsx
  var NavigationDisplay = () => {
    const [displayIndex] = (0, import_react27.useState)(() => {
      var _a;
      const url = document.getElementsByTagName("a32nx-nd")[0].getAttribute("url");
      return parseInt((_a = url == null ? void 0 : url.substring(url.length - 1)) != null ? _a : "1", 10);
    });
    const side = displayIndex === 1 ? "L" : "R";
    const [airDataSwitch] = useSimVar("L:A32NX_AIR_DATA_SWITCHING_KNOB", "enum", 200);
    const [attHdgSwitch] = useSimVar("L:A32NX_ATT_HDG_SWITCHING_KNOB", "enum", 200);
    const [airDataReferenceSource, setAirDataSource] = (0, import_react27.useState)(displayIndex);
    const [inertialReferenceSource, setInertialSource] = (0, import_react27.useState)(displayIndex);
    (0, import_react27.useEffect)(() => {
      setAirDataSource(getSupplier(displayIndex, airDataSwitch));
    }, [airDataSwitch]);
    (0, import_react27.useEffect)(() => {
      setInertialSource(getSupplier(displayIndex, attHdgSwitch));
    }, [attHdgSwitch]);
    const arincLat = useArinc429Var(`L:A32NX_ADIRS_IR_${inertialReferenceSource}_LATITUDE`, 200);
    const arincLong = useArinc429Var(`L:A32NX_ADIRS_IR_${inertialReferenceSource}_LONGITUDE`, 200);
    const adirsAlign = arincLat.isNormalOperation() && arincLong.isNormalOperation();
    const ppos = adirsAlign ? { lat: arincLat.value, long: arincLong.value } : { lat: NaN, long: NaN };
    const [rangeIndex] = useSimVar(displayIndex === 1 ? "L:A32NX_EFIS_L_ND_RANGE" : "L:A32NX_EFIS_R_ND_RANGE", "number", 100);
    const [modeIndex] = useSimVar(displayIndex === 1 ? "L:A32NX_EFIS_L_ND_MODE" : "L:A32NX_EFIS_R_ND_MODE", "number", 100);
    const [modeChangeShown, setModeChangeShown] = (0, import_react27.useState)(false);
    const [rangeChangeShown, setRangeChangeShown] = (0, import_react27.useState)(false);
    const firstModeUpdate = (0, import_react27.useRef)(true);
    const firstRangeUpdate = (0, import_react27.useRef)(true);
    (0, import_react27.useEffect)(() => {
      if (firstModeUpdate.current) {
        firstModeUpdate.current = false;
        return () => {
        };
      }
      setModeChangeShown(true);
      const timeout = setTimeout(() => {
        setModeChangeShown(false);
      }, 500);
      return () => clearTimeout(timeout);
    }, [modeIndex]);
    (0, import_react27.useEffect)(() => {
      if (firstRangeUpdate.current) {
        firstRangeUpdate.current = false;
        return () => {
        };
      }
      if (modeChangeShown) {
        setModeChangeShown(false);
      }
      setRangeChangeShown(true);
      const timeout = setTimeout(() => {
        setRangeChangeShown(false);
      }, 500);
      return () => clearTimeout(timeout);
    }, [rangeIndex]);
    const [symbols, setSymbols] = (0, import_react27.useState)([]);
    useFlowSyncEvent(`A32NX_EFIS_${side}_SYMBOLS`, (0, import_react27.useCallback)((_topic, data) => {
      if (data) {
        setSymbols(data);
      }
    }, []));
    const irMaint = useArinc429Var("L:A32NX_ADIRS_IR_1_MAINT_WORD");
    const [trueRefPb] = useSimVar("L:A32NX_PUSH_TRUE_REF", "bool");
    const [trueRef, setTrueRef] = (0, import_react27.useState)(false);
    (0, import_react27.useEffect)(() => {
      setTrueRef((irMaint.getBitValueOr(15, false) || trueRefPb) && !irMaint.getBitValueOr(2, false));
    }, [irMaint.value, trueRefPb]);
    return /* @__PURE__ */ import_react27.default.createElement(
      DisplayUnit,
      {
        electricitySimvar: displayIndex === 1 ? "L:A32NX_ELEC_AC_ESS_BUS_IS_POWERED" : "L:A32NX_ELEC_AC_2_BUS_IS_POWERED",
        potentiometerIndex: displayIndex === 1 ? 89 : 91,
        normDmc: displayIndex
      },
      /* @__PURE__ */ import_react27.default.createElement(FlightPlanProvider, null, /* @__PURE__ */ import_react27.default.createElement("svg", { className: "nd-svg", version: "1.1", viewBox: "0 0 768 768" }, modeIndex === 4 /* PLAN */ && /* @__PURE__ */ import_react27.default.createElement(
        PlanMode,
        {
          adirsAlign,
          rangeSetting: rangeSettings[rangeIndex],
          symbols,
          side,
          ppos,
          mapHidden: modeChangeShown || rangeChangeShown
        }
      ), modeIndex === 3 /* ARC */ && /* @__PURE__ */ import_react27.default.createElement(
        ArcMode,
        {
          adirsAlign,
          rangeSetting: rangeSettings[rangeIndex],
          symbols,
          side,
          ppos,
          mapHidden: modeChangeShown || rangeChangeShown,
          trueRef
        }
      ), (modeIndex === 0 /* ROSE_ILS */ || modeIndex === 1 /* ROSE_VOR */ || modeIndex === 2 /* ROSE_NAV */) && /* @__PURE__ */ import_react27.default.createElement(
        RoseMode,
        {
          adirsAlign,
          rangeSetting: rangeSettings[rangeIndex],
          symbols,
          side,
          ppos,
          mode: modeIndex,
          mapHidden: modeChangeShown || rangeChangeShown,
          trueRef
        }
      ), /* @__PURE__ */ import_react27.default.createElement(Chrono, { side }), /* @__PURE__ */ import_react27.default.createElement(SpeedIndicator, { adrs: airDataReferenceSource, irs: inertialReferenceSource }), /* @__PURE__ */ import_react27.default.createElement(WindIndicator, { adrs: airDataReferenceSource, irs: inertialReferenceSource }), /* @__PURE__ */ import_react27.default.createElement(LnavStatus, null), /* @__PURE__ */ import_react27.default.createElement(TerrainMapThresholds, { side }), /* @__PURE__ */ import_react27.default.createElement(NavigationDisplayMessages, { adirsAlign, mode: modeIndex, modeChangeShown, rangeChangeShown }), adirsAlign && modeIndex !== 4 /* PLAN */ && /* @__PURE__ */ import_react27.default.createElement(import_react27.default.Fragment, null, /* @__PURE__ */ import_react27.default.createElement(RadioNavInfo, { index: 1, side, trueRef, mode: modeIndex }), /* @__PURE__ */ import_react27.default.createElement(RadioNavInfo, { index: 2, side, trueRef, mode: modeIndex })), /* @__PURE__ */ import_react27.default.createElement(TcasWxrMessages, { modeIndex }), /* @__PURE__ */ import_react27.default.createElement(FMMessages, { modeIndex, side })))
    );
  };
  render(/* @__PURE__ */ import_react27.default.createElement(NavigationDisplay, null));
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

    }

    Update() {
        super.Update();
        this.dispatchEvent(new CustomEvent('update', { detail: this.getDeltaTime() }));
    }

    onInteractionEvent(event) {
        const eventName = String(event);
        this.dispatchEvent(new CustomEvent(eventName));
        this.dispatchEvent(new CustomEvent('*', { detail: eventName }));
    }
}

registerInstrument('a32nx-nd', InstrumentLogic);
